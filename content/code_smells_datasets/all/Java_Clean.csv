id,language,text,smell,tokens
27181,Java,"public class EnchantItemOptionsData extends GameXmlReader {

    private static final Logger LOGGER = LoggerFactory.getLogger(EnchantItemOptionsData.class);

    private final IntMap<IntMap<EnchantOptions>> data = new HashIntMap<>();

    private EnchantItemOptionsData() {
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/EnchantItemOptions.xsd"");
    }

    @Override
    public synchronized void load() {
        data.clear();
        parseDatapackFile(""data/EnchantItemOptions.xml"");
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", list -> forEach(list, ""item"", itemNode -> forEach(itemNode, ""options"", optionsNode -> {
                var attr = optionsNode.getAttributes();
                var option = new EnchantOptions(parseInt(attr, ""level""));
                for (byte i = 0; i < 3 ; i++) {
                    option.setOption(i, parseInt(attr, ""option"" + (i+1)));
                }
                data.computeIfAbsent(parseInt(itemNode.getAttributes(), ""id""), id -> new HashIntMap<>()).put(option.getLevel(), option);
            })
        ));
        LOGGER.info(""Loaded {} Option Items."", data.size());
    }

    /**
     * @param itemId
     * @param enchantLevel
     * @return enchant effects information.
     */
    public EnchantOptions getOptions(int itemId, int enchantLevel) {
        if (!data.containsKey(itemId) || !data.get(itemId).containsKey(enchantLevel)) {
            return null;
        }
        return data.get(itemId).get(enchantLevel);
    }

    /**
     * @param item
     * @return enchant effects information.
     */
    public EnchantOptions getOptions(Item item) {
        return computeIfNonNull(item, i -> getOptions(i.getId(), i.getEnchantLevel()));
    }

    public static void init() {
        getInstance().load();
    }

    public static EnchantItemOptionsData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        protected static final EnchantItemOptionsData INSTANCE = new EnchantItemOptionsData();
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2006 60 2007 641 2008 61 418 2009 60 62 40 41 59 437 2000 40 41 123 125 64 2010 438 2011 2012 40 41 123 450 2013 46 2014 40 41 46 2015 40 648 41 59 125 64 2010 439 465 492 2016 40 41 123 2008 46 2017 40 41 59 2018 40 648 41 59 2019 40 41 59 125 64 2010 439 492 2020 40 2021 2022 44 2023 2024 41 123 2025 40 2022 44 648 44 411 45 62 2025 40 411 44 648 44 2026 45 62 2025 40 2026 44 648 44 2027 45 62 123 490 2028 61 2027 46 2029 40 41 59 490 2030 61 418 2007 40 2031 40 2028 44 648 41 41 59 385 40 326 2032 61 1500 59 2032 60 1502 59 2032 637 41 123 2030 46 2033 40 2032 44 2031 40 2028 44 648 43 40 2032 43 1501 41 41 41 59 125 2008 46 2034 40 2031 40 2026 46 2029 40 41 44 648 41 44 2035 45 62 418 2009 60 62 40 41 41 46 2036 40 2030 46 2037 40 41 44 2030 41 59 125 41 41 41 59 2003 46 2038 40 648 44 2008 46 2039 40 41 41 59 125 618 439 2007 2040 40 404 2041 44 404 2042 41 123 392 40 33 2008 46 2043 40 2041 41 606 33 2008 46 2044 40 2041 41 46 2043 40 2042 41 41 123 450 424 59 125 450 2008 46 2044 40 2041 41 46 2044 40 2042 41 59 125 618 439 2007 2040 40 2045 2046 41 123 450 2047 40 2046 44 2048 45 62 2040 40 2048 46 2049 40 41 44 2048 46 2050 40 41 41 41 59 125 439 457 492 2051 40 41 123 2052 40 41 46 2016 40 41 59 125 439 457 2000 2053 40 41 123 450 2054 46 2055 59 125 437 457 334 2056 123 438 457 381 2000 2057 61 418 2000 40 41 59 125 125 
29178,Java,"    protected static class NpcSpawn {
        protected final Location loc;
        protected final int npcId;

        protected NpcSpawn(int pNpcId, Location spawnLoc) {
            loc = spawnLoc;
            npcId = pNpcId;
        }
    }",0,438 457 334 2000 123 438 381 2001 2002 59 438 381 404 2003 59 438 2000 40 404 2004 44 2001 2005 41 123 2002 61 2005 59 2003 61 2004 59 125 125 
29179,Java,"    protected class ScheduleEnd implements Runnable {
        @Override
        public void run() {

            destroyItemsOnEnd();

            if(isNotEmpty(endMessage)) {
                Broadcast.toAllOnlinePlayers(endMessage);
            }

            if(enterAnnounceId != -1) {
                AnnouncementsManager.getInstance().deleteAnnouncement(enterAnnounceId);
            }
        }
    }",0,438 334 2000 395 2001 123 64 2002 439 492 2003 40 41 123 2004 40 41 59 392 40 2005 40 2006 41 41 123 2007 46 2008 40 2006 41 59 125 392 40 2009 631 45 1501 41 123 2010 46 2011 40 41 46 2012 40 2009 41 59 125 125 125 
29381,Java,"	public static class TypeTag extends SchroedingerType {
		private static final ConcurrentMap<String, Object> TYPE_TAG_CACHE = new ConcurrentHashMap<String, Object>();
		private static final ConcurrentMap<Class<?>, Field> FIELD_CACHE = new ConcurrentHashMap<Class<?>, Field>();
		private static final Method TYPE_TYPETAG_METHOD;
		
		static {
			Method m = null;
			try {
				m = Permit.getMethod(Type.class, ""getTag"");
			} catch (NoSuchMethodException e) {}
			TYPE_TYPETAG_METHOD = m;
		}
		
		private TypeTag(Object value) {
			super(value);
		}
		
		public static TypeTag typeTag(JCTree o) {
			try {
				return new TypeTag(getFieldCached(FIELD_CACHE, o, ""typetag""));
			} catch (NoSuchFieldException e) {
				throw Javac.sneakyThrow(e);
			}
		}
		
		public static TypeTag typeTag(Type t) {
			if (t == null) return Javac.CTC_VOID;
			try {
				return new TypeTag(getFieldCached(FIELD_CACHE, t, ""tag""));
			} catch (NoSuchFieldException e) {
				if (TYPE_TYPETAG_METHOD == null) throw new IllegalStateException(""Type "" + t.getClass() + "" has neither 'tag' nor getTag()"");
				try {
					return new TypeTag(TYPE_TYPETAG_METHOD.invoke(t));
				} catch (IllegalAccessException ex) {
					throw Javac.sneakyThrow(ex);
				} catch (InvocationTargetException ex) {
					throw Javac.sneakyThrow(ex.getCause());
				}
			}
		}
		
		public static TypeTag typeTag(String identifier) {
			return new TypeTag(getFieldCached(TYPE_TAG_CACHE, Javac.getJavaCompilerVersion() < 8 ? ""com.sun.tools.javac.code.TypeTags"" : ""com.sun.tools.javac.code.TypeTag"", identifier));
		}
	}",0,439 457 334 2000 378 2001 123 437 457 381 2002 60 2003 44 2004 62 2005 61 418 2006 60 2003 44 2004 62 40 41 59 437 457 381 2002 60 2007 60 63 62 44 2008 62 2009 61 418 2006 60 2007 60 63 62 44 2008 62 40 41 59 437 457 381 2010 2011 59 457 123 2010 2012 61 424 59 474 123 2012 61 2013 46 2014 40 2015 46 334 44 648 41 59 125 329 40 2016 2017 41 123 125 2011 61 2012 59 125 437 2000 40 2004 2018 41 123 463 40 2018 41 59 125 439 457 2000 2019 40 2020 2021 41 123 474 123 450 418 2000 40 2022 40 2009 44 2021 44 648 41 41 59 125 329 40 2023 2024 41 123 469 2025 46 2026 40 2024 41 59 125 125 439 457 2000 2019 40 2027 2028 41 123 392 40 2028 614 424 41 450 2029 46 2030 59 474 123 450 418 2000 40 2031 40 2009 44 2028 44 648 41 41 59 125 329 40 2032 2033 41 123 392 40 2011 614 424 41 469 418 2034 40 648 43 2028 46 2035 40 41 43 648 41 59 474 123 450 418 2000 40 2011 46 2036 40 2028 41 41 59 125 329 40 2037 2038 41 123 469 2029 46 2039 40 2038 41 59 125 329 40 2040 2038 41 123 469 2029 46 2041 40 2038 46 2042 40 41 41 59 125 125 125 439 457 2000 2019 40 2003 2043 41 123 450 418 2000 40 2044 40 2005 44 2045 46 2046 40 41 60 1502 63 648 58 648 44 2043 41 41 59 125 125 
29402,Java,"	public static final class LombokDeps {
		public static final Method ADD_LOMBOK_NOTES;
		public static final Method POST_COMPILER_BYTES_STRING;
		public static final Method POST_COMPILER_OUTPUTSTREAM;
		public static final Method POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING;
		
		static {
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.agent.PatchFixesShadowLoaded"");
			ADD_LOMBOK_NOTES = Util.findMethod(shadowed, ""addLombokNotesToEclipseAboutDialog"", String.class, String.class);
			POST_COMPILER_BYTES_STRING = Util.findMethod(shadowed, ""runPostCompiler"", byte[].class, String.class);
			POST_COMPILER_OUTPUTSTREAM = Util.findMethod(shadowed, ""runPostCompiler"", OutputStream.class);
			POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING = Util.findMethod(shadowed, ""runPostCompiler"", BufferedOutputStream.class, String.class, String.class);
		}
		
		public static String addLombokNotesToEclipseAboutDialog(String origReturnValue, String key) {
			try {
				return (String) Util.invokeMethod(LombokDeps.ADD_LOMBOK_NOTES, origReturnValue, key);
			} catch (Throwable t) {
				return origReturnValue;
			}
		}
		
		public static byte[] runPostCompiler(byte[] bytes, String fileName) {
			return (byte[]) Util.invokeMethod(LombokDeps.POST_COMPILER_BYTES_STRING, bytes, fileName);
		}
		
		public static OutputStream runPostCompiler(OutputStream out) throws IOException {
			return (OutputStream) Util.invokeMethod(LombokDeps.POST_COMPILER_OUTPUTSTREAM, out);
		}
		
		public static BufferedOutputStream runPostCompiler(BufferedOutputStream out, String path, String name) throws IOException {
			return (BufferedOutputStream) Util.invokeMethod(LombokDeps.POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING, out, path, name);
		}
	}",0,439 457 381 334 2000 123 439 457 381 2001 2002 59 439 457 381 2001 2003 59 439 457 381 2001 2004 59 439 457 381 2001 2005 59 457 123 2006 60 63 62 2007 61 2008 46 2009 40 648 41 59 2002 61 2008 46 2010 40 2007 44 648 44 2011 46 334 44 2011 46 334 41 59 2003 61 2008 46 2010 40 2007 44 648 44 326 91 93 46 334 44 2011 46 334 41 59 2004 61 2008 46 2010 40 2007 44 648 44 2012 46 334 41 59 2005 61 2008 46 2010 40 2007 44 648 44 2013 46 334 44 2011 46 334 44 2011 46 334 41 59 125 439 457 2014 2015 40 2014 2016 44 2014 2017 41 123 474 123 450 40 2014 41 2018 46 2019 40 2000 46 2002 44 2016 44 2017 41 59 125 329 40 2020 2021 41 123 450 2016 59 125 125 439 457 326 91 93 2022 40 326 91 93 2023 44 2014 2024 41 123 450 40 326 91 93 41 2025 46 2026 40 2000 46 2003 44 2023 44 2024 41 59 125 439 457 2027 2022 40 2027 430 41 470 2028 123 450 40 2027 41 2029 46 2030 40 2000 46 2004 44 430 41 59 125 439 457 2031 2022 40 2031 430 44 2014 2032 44 2014 2033 41 470 2028 123 450 40 2031 41 2034 46 2035 40 2000 46 2005 44 430 44 2032 44 2033 41 59 125 125 
29398,Java,"	public static abstract class TestParams {
		public abstract Compiler getCompiler();
		public abstract boolean printErrors();
		public abstract File getBeforeDirectory();
		public abstract File getAfterDirectory();
		public abstract File getMessagesDirectory();
		/** Version of the JDK dialect that the compiler can understand; for example, if you return '7', you should know what try-with-resources is. */
		public int getVersion() {
			return getCompiler().getVersion();
		}
		
		public boolean accept(File file) {
			return true;
		}
		
		public abstract boolean expectChanges();
		public String testNamePrefix() {
			return """";
		}
	}",0,439 457 305 334 2000 123 439 305 2001 2002 40 41 59 439 305 324 2003 40 41 59 439 305 2004 2005 40 41 59 439 305 2004 2006 40 41 59 439 305 2004 2007 40 41 59 618 439 404 2008 40 41 123 450 2002 40 41 46 2008 40 41 59 125 439 324 2009 40 2004 2010 41 123 450 473 59 125 439 305 324 2011 40 41 59 439 2012 2013 40 41 123 450 648 59 125 125 
29406,Java,"	public static final class Val {
		private static final String BLOCK_SCOPE_SIG = ""org.eclipse.jdt.internal.compiler.lookup.BlockScope"";
		private static final String LOCAL_DECLARATION_SIG = ""org.eclipse.jdt.internal.compiler.ast.LocalDeclaration"";
		private static final String FOREACH_STATEMENT_SIG = ""org.eclipse.jdt.internal.compiler.ast.ForeachStatement"";
		
		private static final Method HANDLE_VAL_FOR_LOCAL_DECLARATION;
		private static final Method HANDLE_VAL_FOR_FOR_EACH;
		
		static {
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.agent.PatchVal"");
			HANDLE_VAL_FOR_LOCAL_DECLARATION = Util.findMethod(shadowed, ""handleValForLocalDeclaration"", LOCAL_DECLARATION_SIG, BLOCK_SCOPE_SIG);
			HANDLE_VAL_FOR_FOR_EACH = Util.findMethod(shadowed, ""handleValForForEach"", FOREACH_STATEMENT_SIG, BLOCK_SCOPE_SIG);
		}
		
		public static boolean handleValForLocalDeclaration(Object local, Object scope) {
			return (Boolean) Util.invokeMethod(HANDLE_VAL_FOR_LOCAL_DECLARATION, local, scope);
		}
		
		public static boolean handleValForForEach(Object forEach, Object scope) {
			return (Boolean) Util.invokeMethod(HANDLE_VAL_FOR_FOR_EACH, forEach, scope);
		}
		
		/** 
		 * Patches local declaration to not call .resolveType() on the initializer expression if we've already done so (calling it twice causes weird errors) 
		 * This and the next method must be transplanted so that the return type is loaded in the correct class loader
		 */
		public static TypeBinding skipResolveInitializerIfAlreadyCalled(Expression expr, BlockScope scope) {
			if (expr.resolvedType != null) return expr.resolvedType;
			try {
				return expr.resolveType(scope);
			} catch (NullPointerException e) {
				return null;
			} catch (ArrayIndexOutOfBoundsException e) {
				// This will occur internally due to for example 'val x = mth(""X"");', where mth takes 2 arguments.
				return null;
			}
		}
		
		public static TypeBinding skipResolveInitializerIfAlreadyCalled2(Expression expr, BlockScope scope, LocalDeclaration decl) {
			if (decl != null && LocalDeclaration.class.equals(decl.getClass()) && expr.resolvedType != null) return expr.resolvedType;
			try {
				return expr.resolveType(scope);
			} catch (NullPointerException e) {
				return null;
			} catch (ArrayIndexOutOfBoundsException e) {
				// This will occur internally due to for example 'val x = mth(""X"");', where mth takes 2 arguments.
				return null;
			}
		}
	}",0,439 457 381 334 2000 123 437 457 381 2001 2002 61 648 59 437 457 381 2001 2003 61 648 59 437 457 381 2001 2004 61 648 59 437 457 381 2005 2006 59 437 457 381 2005 2007 59 457 123 2008 60 63 62 2009 61 2010 46 2011 40 648 41 59 2006 61 2010 46 2012 40 2009 44 648 44 2003 44 2002 41 59 2007 61 2010 46 2012 40 2009 44 648 44 2004 44 2002 41 59 125 439 457 324 2013 40 2014 2015 44 2014 2016 41 123 450 40 2017 41 2018 46 2019 40 2006 44 2015 44 2016 41 59 125 439 457 324 2020 40 2014 2021 44 2014 2016 41 123 450 40 2022 41 2023 46 2024 40 2007 44 2021 44 2016 41 59 125 618 439 457 2025 2026 40 2027 2028 44 2029 2016 41 123 392 40 2028 46 2030 631 424 41 450 2028 46 2030 59 474 123 450 2028 46 2031 40 2016 41 59 125 329 40 2032 2033 41 123 450 424 59 125 329 40 2034 2033 41 123 621 450 424 59 125 125 439 457 2025 2035 40 2027 2028 44 2029 2016 44 2036 2037 41 123 392 40 2037 631 424 605 2036 46 334 46 2038 40 2037 46 2039 40 41 41 605 2028 46 2040 631 424 41 450 2028 46 2040 59 474 123 450 2028 46 2041 40 2016 41 59 125 329 40 2042 2043 41 123 450 424 59 125 329 40 2044 2043 41 123 621 450 424 59 125 125 125 
29550,Java,"public class BuilderDefaultsTargetTyping {
	String foo;

	static String doSth(java.util.List<Integer> i, java.util.List<Character> c) {
		return null;
	}

	@java.lang.SuppressWarnings(""all"")
	private static String $default$foo() {
		return doSth(Arrays.asList(1), Arrays.asList('a'));
	}

	@java.lang.SuppressWarnings(""all"")
	BuilderDefaultsTargetTyping(final String foo) {
		this.foo = foo;
	}


	@java.lang.SuppressWarnings(""all"")
	public static class BuilderDefaultsTargetTypingBuilder {
		@java.lang.SuppressWarnings(""all"")
		private boolean foo$set;
		@java.lang.SuppressWarnings(""all"")
		private String foo$value;

		@java.lang.SuppressWarnings(""all"")
		BuilderDefaultsTargetTypingBuilder() {
		}

		/**
		 * @return {@code this}.
		 */
		@java.lang.SuppressWarnings(""all"")
		public BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder foo(final String foo) {
			this.foo$value = foo;
			foo$set = true;
			return this;
		}

		@java.lang.SuppressWarnings(""all"")
		public BuilderDefaultsTargetTyping build() {
			String foo$value = this.foo$value;
			if (!this.foo$set) foo$value = BuilderDefaultsTargetTyping.$default$foo();
			return new BuilderDefaultsTargetTyping(foo$value);
		}

		@java.lang.Override
		@java.lang.SuppressWarnings(""all"")
		public java.lang.String toString() {
			return ""BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder(foo$value="" + this.foo$value + "")"";
		}
	}

	@java.lang.SuppressWarnings(""all"")
	public static BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder builder() {
		return new BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder();
	}
}",0,439 334 2000 123 2001 2002 59 457 2001 2003 40 2004 46 2005 46 2006 60 2007 62 2008 44 2004 46 2005 46 2006 60 2009 62 2010 41 123 450 424 59 125 64 2004 46 2011 46 2012 40 648 41 437 457 2001 36 349 36 2002 40 41 123 450 2003 40 2013 46 2014 40 1501 41 44 2013 46 2014 40 607 41 41 59 125 64 2004 46 2011 46 2012 40 648 41 2000 40 381 2001 2002 41 123 467 46 2002 61 2002 59 125 64 2004 46 2011 46 2012 40 648 41 439 457 334 2015 123 64 2004 46 2011 46 2012 40 648 41 437 324 2002 36 2016 59 64 2004 46 2011 46 2012 40 648 41 437 2001 2002 36 2017 59 64 2004 46 2011 46 2012 40 648 41 2015 40 41 123 125 618 64 2004 46 2011 46 2012 40 648 41 439 2000 46 2015 2002 40 381 2001 2002 41 123 467 46 2002 36 2017 61 2002 59 2002 36 2016 61 473 59 450 467 59 125 64 2004 46 2011 46 2012 40 648 41 439 2000 2018 40 41 123 2001 2002 36 2017 61 467 46 2002 36 2017 59 392 40 33 467 46 2002 36 2016 41 2002 36 2017 61 2000 46 36 349 36 2002 40 41 59 450 418 2000 40 2002 36 2017 41 59 125 64 2004 46 2011 46 2019 64 2004 46 2011 46 2012 40 648 41 439 2004 46 2011 46 2001 2020 40 41 123 450 648 43 467 46 2002 36 2017 43 648 59 125 125 64 2004 46 2011 46 2012 40 648 41 439 457 2000 46 2015 2021 40 41 123 450 418 2000 46 2015 40 41 59 125 125 
29557,Java,"	private static class PostponedNoMethodError implements PostponedError {
		private final ProblemReporter problemReporter;
		private final WeakReference<MessageSend> messageSendRef;
		private final TypeBinding recType;
		private final TypeBinding[] params;
		
		PostponedNoMethodError(ProblemReporter problemReporter, MessageSend messageSend, TypeBinding recType, TypeBinding[] params) {
			this.problemReporter = problemReporter;
			this.messageSendRef = new WeakReference<MessageSend>(messageSend);
			this.recType = recType;
			this.params = params;
		}
		
		public void fire() {
			MessageSend messageSend = messageSendRef.get();
			if (messageSend != null) problemReporter.errorNoMethodFor(messageSend, recType, params);
		}
	}",0,437 457 334 2000 395 2001 123 437 381 2002 2003 59 437 381 2004 60 2005 62 2006 59 437 381 2007 2008 59 437 381 2007 91 93 433 59 2000 40 2002 2003 44 2005 2009 44 2007 2008 44 2007 91 93 433 41 123 467 46 2003 61 2003 59 467 46 2006 61 418 2004 60 2005 62 40 2009 41 59 467 46 2008 61 2008 59 467 46 433 61 433 59 125 439 492 2010 40 41 123 2005 2009 61 2006 46 2011 40 41 59 392 40 2009 631 424 41 2003 46 2012 40 2009 44 2008 44 433 41 59 125 125 
29950,Java,"	public static class ValidatePositionProcessor extends TreeProcessor {
		private final int version;
		
		public ValidatePositionProcessor(int version) {
			this.version = version;
		}
		
		private String craftFailMsg(String problematicNode, Deque<JCTree> astContext) {
			StringBuilder msg = new StringBuilder(problematicNode).append("" position of node not set: "");
			for (JCTree t : astContext) {
				msg.append(""\n  "").append(t.getClass().getSimpleName());
				String asStr = t.toString();
				if (asStr.length() < 80) msg.append("": "").append(asStr);
				else if (t instanceof JCClassDecl) msg.append("": "").append(((JCClassDecl) t).name);
				else if (t instanceof JCMethodDecl) msg.append("": "").append(((JCMethodDecl) t).name);
				else if (t instanceof JCVariableDecl) msg.append("": "").append(((JCVariableDecl) t).name);
			}
			return msg.append(""\n-------"").toString();
		}
		
		@Override void processCompilationUnit(final JCCompilationUnit unit) {
			final Deque<JCTree> astContext = new ArrayDeque<JCTree>();
			unit.accept(new TreeScanner() {
				@Override public void scan(JCTree tree) {
					if (tree == null) return;
					if (tree instanceof JCMethodDecl && (((JCMethodDecl) tree).mods.flags & Flags.GENERATEDCONSTR) != 0) return;
					astContext.push(tree);
					try {
						if (tree instanceof JCModifiers) return;
						
						if (!Javac.validateDocComment(unit, tree)) {
							fail(""Start position of doc comment ("" + Javac.getDocComment(unit, tree) + "") of "" + tree + "" not set"");
						}
						
						boolean check = true;
						if (version < 8 && tree instanceof TypeBoundKind) {
							// TypeBoundKind works differently in java6, and as a consequence,
							// the position is not set properly.
							// Given status of j6/j7, not worth properly testing.
							check = false;
						}
						if (version < 8 && tree instanceof JCIdent) {
							// explicit `super()` invocations do not appear to have end pos in j6/7.
							if (""super"".equals("""" + ((JCIdent) tree).name)) check = false;
						}
						
						if (tree instanceof JCVariableDecl && (((JCVariableDecl) tree).mods.flags & Javac.GENERATED_MEMBER) != 0) return;
						
						if (check && tree.pos == -1) fail(craftFailMsg(""Start"", astContext));
						
						if (check && Javac.getEndPosition(tree, unit) == -1) {
							fail(craftFailMsg(""End"", astContext));
						}
					} finally {
						try {
							super.scan(tree);
						} finally {
							astContext.pop();
						}
					}
				}
				
				@Override public void visitMethodDef(JCMethodDecl tree) {
					super.visitMethodDef(tree);
				}
				
				@Override public void visitVarDef(JCVariableDecl tree) {
					if ((tree.mods.flags & Flags.ENUM) != 0) return;
					super.visitVarDef(tree);
				}
				
				@Override public void visitAnnotation(JCAnnotation tree) {
					scan(tree.annotationType);
					// Javac parser maps @Annotation(""val"") to @Annotation(value = ""val"") but does not add an end position for the new JCIdent...
					if (tree.args.length() == 1 && tree.args.head instanceof JCAssign && ((JCIdent)((JCAssign) tree.args.head).lhs).name.toString().equals(""value"")) {
						scan(((JCAssign) tree.args.head).rhs);
					} else {
						scan(tree.args);
					}
				}
			});
		}
	}",0,439 457 334 2000 378 2001 123 437 381 404 2002 59 439 2000 40 404 2002 41 123 467 46 2002 61 2002 59 125 437 2003 2004 40 2003 2005 44 2006 60 2007 62 2008 41 123 2009 2010 61 418 2009 40 2005 41 46 2011 40 648 41 59 385 40 2007 2012 58 2008 41 123 2010 46 2011 40 648 41 46 2011 40 2012 46 2013 40 41 46 2014 40 41 41 59 2003 2015 61 2012 46 2016 40 41 59 392 40 2015 46 2017 40 41 60 1503 41 2010 46 2011 40 648 41 46 2011 40 2015 41 59 360 392 40 2012 402 2018 41 2010 46 2011 40 648 41 46 2011 40 40 40 2018 41 2012 41 46 2019 41 59 360 392 40 2012 402 2020 41 2010 46 2011 40 648 41 46 2011 40 40 40 2020 41 2012 41 46 2019 41 59 360 392 40 2012 402 2021 41 2010 46 2011 40 648 41 46 2011 40 40 40 2021 41 2012 41 46 2019 41 59 125 450 2010 46 2011 40 648 41 46 2022 40 41 59 125 64 2023 492 2024 40 381 2025 2026 41 123 381 2006 60 2007 62 2008 61 418 2027 60 2007 62 40 41 59 2026 46 2028 40 418 2029 40 41 123 64 2023 439 492 2030 40 2007 2031 41 123 392 40 2031 614 424 41 450 59 392 40 2031 402 2032 605 40 40 40 2032 41 2031 41 46 2033 46 2034 38 2035 46 2036 41 631 1500 41 450 59 2008 46 2037 40 2031 41 59 474 123 392 40 2031 402 2038 41 450 59 392 40 33 2039 46 2040 40 2026 44 2031 41 41 123 2041 40 648 43 2039 46 2042 40 2026 44 2031 41 43 648 43 2031 43 648 41 59 125 324 2043 61 473 59 392 40 2002 60 1502 605 2031 402 2044 41 123 621 621 621 2043 61 380 59 125 392 40 2002 60 1502 605 2031 402 2045 41 123 621 392 40 648 46 2046 40 648 43 40 40 2045 41 2031 41 46 2047 41 41 2043 61 380 59 125 392 40 2031 402 2048 605 40 40 40 2048 41 2031 41 46 2033 46 2034 38 2039 46 2049 41 631 1500 41 450 59 392 40 2043 605 2031 46 2050 614 45 1501 41 2051 40 2004 40 648 44 2008 41 41 59 392 40 2043 605 2039 46 2052 40 2031 44 2026 41 614 45 1501 41 123 2051 40 2004 40 648 44 2008 41 41 59 125 125 382 123 474 123 463 46 2030 40 2031 41 59 125 382 123 2008 46 2053 40 41 59 125 125 125 64 2023 439 492 2054 40 2055 2031 41 123 463 46 2054 40 2031 41 59 125 64 2023 439 492 2056 40 2057 2031 41 123 392 40 40 2031 46 2058 46 2059 38 2060 46 2061 41 631 1500 41 450 59 463 46 2056 40 2031 41 59 125 64 2023 439 492 2062 40 2063 2031 41 123 2030 40 2031 46 2064 41 59 621 392 40 2031 46 2065 46 2066 40 41 614 1501 605 2031 46 2065 46 2067 402 2068 605 40 40 2069 41 40 40 2068 41 2031 46 2065 46 2067 41 46 2070 41 46 2071 46 2072 40 41 46 2073 40 648 41 41 123 2030 40 40 40 2068 41 2031 46 2065 46 2067 41 46 2074 41 59 125 360 123 2030 40 2031 46 2065 41 59 125 125 125 41 59 125 125 
29952,Java,"	public static class ValidateTypesProcessor extends TreeProcessor {
		@Override void processCompilationUnit(final JCCompilationUnit unit) {
			final Stack<JCTree> parents = new Stack<JCTree>();
			parents.add(unit);
			
			unit.accept(new TreeScanner() {
				private JCTree parent;
				@Override public void scan(JCTree tree) {
					parent = parents.peek();
					
					parents.push(tree);
					super.scan(tree);
					parents.pop();
				}
				
				@Override public void visitClassDef(JCClassDecl tree) {
					// Skip anonymous or local classes, they have no symbol
					if (!(parent instanceof JCClassDecl || parent instanceof JCCompilationUnit)) return;
					
					validateSymbol(tree, tree.sym);
					super.visitClassDef(tree);
				};

				@Override public void visitMethodDef(JCMethodDecl tree) {
					validateSymbol(tree, tree.sym);
					super.visitMethodDef(tree);
				}
				
				@Override public void visitVarDef(JCVariableDecl tree) {
					// Skip local variables
					if (!(parent instanceof JCClassDecl || parent instanceof JCMethodDecl)) return;
					
					validateSymbol(tree, tree.sym);
					super.visitVarDef(tree);
				}
				
				private void validateSymbol(JCTree tree, Symbol sym) {
					if (sym == null) {
						fail(""Missing symbol for "" + tree);
					}
					// Only classes have enclosed elements, skip everything else
					if (!sym.owner.getKind().isClass()) return;
					
					if (!sym.owner.getEnclosedElements().contains(sym)) {
						fail(tree + "" not added to parent"");
					}
				}
			});
		}
	}",0,439 457 334 2000 378 2001 123 64 2002 492 2003 40 381 2004 2005 41 123 381 2006 60 2007 62 2008 61 418 2006 60 2007 62 40 41 59 2008 46 2009 40 2005 41 59 2005 46 2010 40 418 2011 40 41 123 437 2007 2012 59 64 2002 439 492 2013 40 2007 2014 41 123 2012 61 2008 46 2015 40 41 59 2008 46 2016 40 2014 41 59 463 46 2013 40 2014 41 59 2008 46 2017 40 41 59 125 64 2002 439 492 2018 40 2019 2014 41 123 621 392 40 33 40 2012 402 2019 606 2012 402 2004 41 41 450 59 2020 40 2014 44 2014 46 2021 41 59 463 46 2018 40 2014 41 59 125 59 64 2002 439 492 2022 40 2023 2014 41 123 2024 40 2014 44 2014 46 2025 41 59 463 46 2022 40 2014 41 59 125 64 2002 439 492 2026 40 2027 2014 41 123 621 392 40 33 40 2012 402 2019 606 2012 402 2023 41 41 450 59 2028 40 2014 44 2014 46 2029 41 59 463 46 2026 40 2014 41 59 125 437 492 2030 40 2007 2014 44 2031 2032 41 123 392 40 2032 614 424 41 123 2033 40 648 43 2014 41 59 125 621 392 40 33 2032 46 2034 46 2035 40 41 46 2036 40 41 41 450 59 392 40 33 2032 46 2034 46 2037 40 41 46 2038 40 2032 41 41 123 2039 40 2014 43 648 41 59 125 125 125 41 59 125 125 
30493,Java,"		VERBATIM {
			@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {
				return Javac.getDocComment(cu, node.get());
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 44 381 2006 2007 41 123 450 2008 46 2009 40 2005 44 2007 46 2010 40 41 41 59 125 125 44 
30497,Java,"		WITH {
			@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {
				return addReturnsUpdatedSelfIfNeeded(applySetter(cu, node, ""WITH|WITHER""));
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 44 381 2006 2007 41 123 450 2008 40 2009 40 2005 44 2007 44 648 41 41 59 125 125 44 
30503,Java,"	static class JCAnnotationReflect {
		private static final Field ATTRIBUTE;

		static {
			ATTRIBUTE = Permit.permissiveGetField(JCAnnotation.class, ""attribute"");
		}

		static Attribute.Compound getAttribute(JCAnnotation jcAnnotation) {
			if (ATTRIBUTE != null) {
				try {
					return (Attribute.Compound) ATTRIBUTE.get(jcAnnotation);
				} catch (Exception e) {
					// Ignore
				}
			}
			return null;
		}
		
		static void setAttribute(JCAnnotation jcAnnotation, Attribute.Compound attribute) {
			if (ATTRIBUTE != null) {
				try {
					Permit.set(ATTRIBUTE, jcAnnotation, attribute);
				} catch (Exception e) {
					// Ignore
				}
			}
		}
	}",0,457 334 2000 123 437 457 381 2001 2002 59 457 123 2002 61 2003 46 2004 40 2005 46 334 44 648 41 59 125 457 2006 46 2007 2008 40 2009 2010 41 123 392 40 2002 631 424 41 123 474 123 450 40 2006 46 2007 41 2002 46 2011 40 2010 41 59 125 329 40 2012 2013 41 123 621 125 125 450 424 59 125 457 492 2014 40 2009 2010 44 2006 46 2007 2015 41 123 392 40 2002 631 424 41 123 474 123 2016 46 2017 40 2002 44 2010 44 2015 41 59 125 329 40 2018 2019 41 123 621 125 125 125 125 
30506,Java,"			values.put(mName, new AnnotationValue(node, raws, expressions, guesses, true) {
				@Override public void setError(String message, int valueIdx) {
					if (valueIdx < 0) node.addError(message);
					else node.addError(message, positions.get(valueIdx));
				}
				
				@Override public void setWarning(String message, int valueIdx) {
					if (valueIdx < 0) node.addWarning(message);
					else node.addWarning(message, positions.get(valueIdx));
				}
			});",0,2000 46 2001 40 2002 44 418 2003 40 2004 44 2005 44 2006 44 2007 44 473 41 123 64 2008 439 492 2009 40 2010 2011 44 404 2012 41 123 392 40 2012 60 1500 41 2004 46 2013 40 2011 41 59 360 2004 46 2013 40 2011 44 2014 46 2015 40 2012 41 41 59 125 64 2008 439 492 2016 40 2010 2011 44 404 2012 41 123 392 40 2012 60 1500 41 2004 46 2017 40 2011 41 59 360 2004 46 2017 40 2011 44 2018 46 2019 40 2012 41 41 59 125 125 41 59 
30507,Java,"				values.put(name, new AnnotationValue(node, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {
					@Override public void setError(String message, int valueIdx) {
						node.addError(message);
					}
					@Override public void setWarning(String message, int valueIdx) {
						node.addWarning(message);
					}
				});",0,2000 46 2001 40 2002 44 418 2003 40 2004 44 418 2005 60 2006 62 40 41 44 418 2005 60 2007 62 40 41 44 418 2005 60 2007 62 40 41 44 380 41 123 64 2008 439 492 2009 40 2006 2010 44 404 2011 41 123 2004 46 2012 40 2010 41 59 125 64 2008 439 492 2013 40 2006 2010 44 404 2011 41 123 2004 46 2014 40 2010 41 59 125 125 41 59 
30646,Java,"	@Provides
	public static class HandleNoArgsConstructor extends EclipseAnnotationHandler<NoArgsConstructor> {
		private static final String NAME = NoArgsConstructor.class.getSimpleName();
		private HandleConstructor handleConstructor = new HandleConstructor();
		
		@Override public void handle(AnnotationValues<NoArgsConstructor> annotation, Annotation ast, EclipseNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.NO_ARGS_CONSTRUCTOR_FLAG_USAGE, ""@NoArgsConstructor"", ConfigurationKeys.ANY_CONSTRUCTOR_FLAG_USAGE, ""any @xArgsConstructor"");
			
			EclipseNode typeNode = annotationNode.up();
			if (!checkLegality(typeNode, annotationNode, NAME)) return;
			NoArgsConstructor ann = annotation.getInstance();
			AccessLevel level = ann.access();
			String staticName = ann.staticName();
			if (level == AccessLevel.NONE) return;
			
			boolean force = ann.force();
			
			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, ""onConstructor"", ""@NoArgsConstructor(onConstructor"", annotationNode);
			
			handleConstructor.generateConstructor(typeNode, level, Collections.<EclipseNode>emptyList(), force, staticName, SkipIfConstructorExists.NO, onConstructor, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 2003 46 334 46 2006 40 41 59 437 2007 2008 61 418 2007 40 41 59 64 2009 439 492 2010 40 2011 60 2003 62 2012 44 2013 2014 44 2015 2016 41 123 2017 40 2016 44 2018 46 2019 44 648 44 2018 46 2020 44 648 41 59 2015 2021 61 2016 46 2022 40 41 59 392 40 33 2023 40 2021 44 2016 44 2005 41 41 450 59 2003 2024 61 2012 46 2025 40 41 59 2026 2027 61 2024 46 2028 40 41 59 2004 2029 61 2024 46 2029 40 41 59 392 40 2027 614 2026 46 2030 41 450 59 324 2031 61 2024 46 2031 40 41 59 2032 60 2013 62 2033 61 2034 40 2014 44 648 44 648 44 2016 41 59 2008 46 2035 40 2021 44 2027 44 2036 46 60 2015 62 2037 40 41 44 2031 44 2029 44 2038 46 2039 44 2033 44 2016 41 59 125 125 
30696,Java,"		@java.lang.SuppressWarnings(""all"")
		private static final class ChildBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<SuperBuilderWithDefaultsAndTargetTyping.Child, SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl> {
			@java.lang.SuppressWarnings(""all"")
			private ChildBuilderImpl() {
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl self() {
				return this;
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public SuperBuilderWithDefaultsAndTargetTyping.Child build() {
				return new SuperBuilderWithDefaultsAndTargetTyping.Child(this);
			}
		}",0,64 2000 46 2001 46 2002 40 648 41 437 457 381 334 2003 378 2004 46 2005 46 2006 60 2004 46 2005 44 2004 46 2005 46 2003 62 123 64 2000 46 2001 46 2002 40 648 41 437 2003 40 41 123 125 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 438 2004 46 2005 46 2003 2008 40 41 123 450 467 59 125 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 439 2004 46 2005 2009 40 41 123 450 418 2004 46 2005 40 467 41 59 125 125 
30697,Java,"	public static class Child extends Parent {
		private String foo;

		@java.lang.SuppressWarnings(""all"")
		private static String $default$foo() {
			return doSth(Arrays.asList(1), Arrays.asList('a'));
		}


		@java.lang.SuppressWarnings(""all"")
		public static abstract class ChildBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Child, B extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
			@java.lang.SuppressWarnings(""all"")
			private boolean foo$set;
			@java.lang.SuppressWarnings(""all"")
			private String foo$value;

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected abstract B self();

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public abstract C build();

			/**
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings(""all"")
			public B foo(final String foo) {
				this.foo$value = foo;
				foo$set = true;
				return self();
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder(super="" + super.toString() + "", foo$value="" + this.foo$value + "")"";
			}
		}


		@java.lang.SuppressWarnings(""all"")
		private static final class ChildBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<SuperBuilderWithDefaultsAndTargetTyping.Child, SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl> {
			@java.lang.SuppressWarnings(""all"")
			private ChildBuilderImpl() {
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl self() {
				return this;
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public SuperBuilderWithDefaultsAndTargetTyping.Child build() {
				return new SuperBuilderWithDefaultsAndTargetTyping.Child(this);
			}
		}

		@java.lang.SuppressWarnings(""all"")
		protected Child(final SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> b) {
			super(b);
			if (b.foo$set) this.foo = b.foo$value;
			 else this.foo = SuperBuilderWithDefaultsAndTargetTyping.Child.$default$foo();
		}

		@java.lang.SuppressWarnings(""all"")
		public static SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> builder() {
			return new SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl();
		}
	}",0,439 457 334 2000 378 2001 123 437 2002 2003 59 64 2004 46 2005 46 2006 40 648 41 437 457 2002 36 349 36 2003 40 41 123 450 2007 40 2008 46 2009 40 1501 41 44 2008 46 2009 40 607 41 41 59 125 64 2004 46 2005 46 2006 40 648 41 439 457 305 334 2010 60 2011 378 2012 46 2000 44 2013 378 2012 46 2000 46 2010 60 2011 44 2013 641 378 2001 46 2014 60 2011 44 2013 62 123 64 2004 46 2005 46 2006 40 648 41 437 324 2003 36 2015 59 64 2004 46 2005 46 2006 40 648 41 437 2002 2003 36 2016 59 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 438 305 2013 2018 40 41 59 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 439 305 2011 2019 40 41 59 618 64 2004 46 2005 46 2006 40 648 41 439 2013 2003 40 381 2002 2003 41 123 467 46 2003 36 2016 61 2003 59 2003 36 2015 61 473 59 450 2018 40 41 59 125 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 439 2004 46 2005 46 2002 2020 40 41 123 450 648 43 463 46 2020 40 41 43 648 43 467 46 2003 36 2016 43 648 59 125 125 64 2004 46 2005 46 2006 40 648 41 437 457 381 334 2021 378 2012 46 2000 46 2010 60 2012 46 2000 44 2012 46 2000 46 2021 62 123 64 2004 46 2005 46 2006 40 648 41 437 2021 40 41 123 125 64 2004 46 2005 46 2022 64 2004 46 2005 46 2006 40 648 41 438 2012 46 2000 46 2021 2023 40 41 123 450 467 59 125 64 2004 46 2005 46 2022 64 2004 46 2005 46 2006 40 648 41 439 2012 46 2000 2024 40 41 123 450 418 2012 46 2000 40 467 41 59 125 125 64 2004 46 2005 46 2006 40 648 41 438 2000 40 381 2012 46 2000 46 2010 60 63 44 63 62 2025 41 123 463 40 2025 41 59 392 40 2025 46 2003 36 2026 41 467 46 2003 61 2025 46 2003 36 2027 59 360 467 46 2003 61 2012 46 2000 46 36 349 36 2003 40 41 59 125 64 2004 46 2005 46 2006 40 648 41 439 457 2012 46 2000 46 2010 60 63 44 63 62 2028 40 41 123 450 418 2012 46 2000 46 2021 40 41 59 125 125 
30700,Java,"	public static class Parent {
		private String foo;

		@java.lang.SuppressWarnings(""all"")
		private static String $default$foo() {
			return doSth(Arrays.asList(1), Arrays.asList('a'));
		}


		@java.lang.SuppressWarnings(""all"")
		public static abstract class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
			@java.lang.SuppressWarnings(""all"")
			private boolean foo$set;
			@java.lang.SuppressWarnings(""all"")
			private String foo$value;

			@java.lang.SuppressWarnings(""all"")
			protected abstract B self();

			@java.lang.SuppressWarnings(""all"")
			public abstract C build();

			/**
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings(""all"")
			public B foo(final String foo) {
				this.foo$value = foo;
				foo$set = true;
				return self();
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value + "")"";
			}
		}


		@java.lang.SuppressWarnings(""all"")
		private static final class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
			@java.lang.SuppressWarnings(""all"")
			private ParentBuilderImpl() {
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
				return this;
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
				return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
			}
		}

		@java.lang.SuppressWarnings(""all"")
		protected Parent(final SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> b) {
			if (b.foo$set) this.foo = b.foo$value;
			 else this.foo = SuperBuilderWithDefaultsAndTargetTyping.Parent.$default$foo();
		}

		@java.lang.SuppressWarnings(""all"")
		public static SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> builder() {
			return new SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl();
		}
	}",0,439 457 334 2000 123 437 2001 2002 59 64 2003 46 2004 46 2005 40 648 41 437 457 2001 36 349 36 2002 40 41 123 450 2006 40 2007 46 2008 40 1501 41 44 2007 46 2008 40 607 41 41 59 125 64 2003 46 2004 46 2005 40 648 41 439 457 305 334 2009 60 2010 378 2011 46 2000 44 2012 378 2011 46 2000 46 2009 60 2010 44 2012 641 123 64 2003 46 2004 46 2005 40 648 41 437 324 2002 36 2013 59 64 2003 46 2004 46 2005 40 648 41 437 2001 2002 36 2014 59 64 2003 46 2004 46 2005 40 648 41 438 305 2012 2015 40 41 59 64 2003 46 2004 46 2005 40 648 41 439 305 2010 2016 40 41 59 618 64 2003 46 2004 46 2005 40 648 41 439 2012 2002 40 381 2001 2002 41 123 467 46 2002 36 2014 61 2002 59 2002 36 2013 61 473 59 450 2015 40 41 59 125 64 2003 46 2004 46 2017 64 2003 46 2004 46 2005 40 648 41 439 2003 46 2004 46 2001 2018 40 41 123 450 648 43 467 46 2002 36 2014 43 648 59 125 125 64 2003 46 2004 46 2005 40 648 41 437 457 381 334 2019 378 2011 46 2000 46 2009 60 2011 46 2000 44 2011 46 2000 46 2019 62 123 64 2003 46 2004 46 2005 40 648 41 437 2019 40 41 123 125 64 2003 46 2004 46 2020 64 2003 46 2004 46 2005 40 648 41 438 2011 46 2000 46 2019 2021 40 41 123 450 467 59 125 64 2003 46 2004 46 2020 64 2003 46 2004 46 2005 40 648 41 439 2011 46 2000 2022 40 41 123 450 418 2011 46 2000 40 467 41 59 125 125 64 2003 46 2004 46 2005 40 648 41 438 2000 40 381 2011 46 2000 46 2009 60 63 44 63 62 2023 41 123 392 40 2023 46 2002 36 2024 41 467 46 2002 61 2023 46 2002 36 2025 59 360 467 46 2002 61 2011 46 2000 46 36 349 36 2002 40 41 59 125 64 2003 46 2004 46 2005 40 648 41 439 457 2011 46 2000 46 2009 60 63 44 63 62 2026 40 41 123 450 418 2011 46 2000 46 2019 40 41 59 125 125 
30731,Java,"	@SuppressWarnings(""unused"")
	private static class EclipseInitializer {
		static void initializeEclipseBundles() throws Exception {
			// This code does not work yet, it's research-in-progress.
			// The problem is that parts of the eclipse handler (in `PatchValEclipse` and friends) do not work unless
			// an actual eclipse exists; PatchVal causes code to run that will end up running `ResourcesPlugin.getWorkspace()`, which
			// goes down a rabbit hole of pinging off of various static fields (or `getX()` calls which return static fields), all
			// of which are `null` until the plugin they belong to is properly initialized.
			// This code is work in progress to 'hack' the initialization of each plugin one-by-one, but I doubt this is the right
			// way to do it, as I bet it's fragile (will break when eclipse updates rather easily), and who knows how many fields
			// and things need to be initialized.
			// A better plan would be to start an actual, real eclipse, by telling `EclipseStarter.startup` to launch some sort of
			// application (or at least a bunch of bundles/products/apps, including the JDT). This will then take long enough that
			// it'll need to be cached and re-used for each test or the Eclipse test run would take far too long.
			
			BundleContext context = EclipseStarter.startup(new String[0], null);
			RegistryFactory.setDefaultRegistryProvider(new IRegistryProvider() {
				private final ExtensionRegistry REG = new ExtensionRegistry(null, null, null);
				@Override public IExtensionRegistry getRegistry() {
					return REG;
				}
			});
			new Activator().start(context);
			new PlatformActivator().start(context);
			for (Bundle b : context.getBundles()) System.out.println(""BUNDLE: "" + b.getSymbolicName());
			new ResourcesPlugin().start(context);
			JavaModelManager.getJavaModelManager().startup();
		}
	}",0,64 2000 40 648 41 437 457 334 2001 123 457 492 2002 40 41 470 2003 123 621 621 621 621 621 621 621 621 621 621 621 2004 2005 61 2006 46 2007 40 418 2008 91 1500 93 44 424 41 59 2009 46 2010 40 418 2011 40 41 123 437 381 2012 2013 61 418 2012 40 424 44 424 44 424 41 59 64 2014 439 2015 2016 40 41 123 450 2013 59 125 125 41 59 418 2017 40 41 46 2018 40 2005 41 59 418 2019 40 41 46 2018 40 2005 41 59 385 40 2020 2021 58 2005 46 2022 40 41 41 2023 46 430 46 2024 40 648 43 2021 46 2025 40 41 41 59 418 2026 40 41 46 2018 40 2005 41 59 2027 46 2028 40 41 46 2007 40 41 59 125 125 
30734,Java,"	private static final class TestCompilationUnitEclipse extends org.eclipse.jdt.internal.core.CompilationUnit {
		private final char[] source;
		private final char[] mainTypeName;
		
		private TestCompilationUnitEclipse(String name, String source) {
			super(null, name, null);
			this.source = source.toCharArray();
			
			char[] fileNameCharArray = getFileName();
			int start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;
			int end = CharOperation.lastIndexOf('.', fileNameCharArray);
			if (end == -1) {
				end = fileNameCharArray.length;
			}
			mainTypeName = CharOperation.subarray(fileNameCharArray, start, end);
		}
		
		@Override public char[] getContents() {
			return source;
		}
		
		@Override public char[] getMainTypeName() {
			return mainTypeName;
		}
		
		@Override public boolean ignoreOptionalProblems() {
			return false;
		}
		
		@Override public char[][] getPackageName() {
			return null;
		}
		
		@Override public char[] getModuleName() {
			return null;
		}
	}",0,437 457 381 334 2000 378 2001 46 2002 46 2003 46 406 46 2004 46 2005 123 437 381 330 91 93 2006 59 437 381 330 91 93 2007 59 437 2000 40 2008 2009 44 2008 2006 41 123 463 40 424 44 2009 44 424 41 59 467 46 2006 61 2006 46 2010 40 41 59 330 91 93 2011 61 2012 40 41 59 404 2013 61 2014 46 2015 40 2016 46 2017 44 2011 41 43 1501 59 404 2018 61 2014 46 2015 40 607 44 2011 41 59 392 40 2018 614 45 1501 41 123 2018 61 2011 46 2019 59 125 2007 61 2014 46 2020 40 2011 44 2013 44 2018 41 59 125 64 2021 439 330 91 93 2022 40 41 123 450 2006 59 125 64 2021 439 330 91 93 2023 40 41 123 450 2007 59 125 64 2021 439 324 2024 40 41 123 450 380 59 125 64 2021 439 330 91 93 91 93 2025 40 41 123 450 424 59 125 64 2021 439 330 91 93 2026 40 41 123 450 424 59 125 125 
30737,Java,"		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {
			@Override public void acceptResult(CompilationResult result) {
				compilationResult_.set(result);
			}
		};",0,2000 2001 61 418 2000 40 41 123 64 2002 439 492 2003 40 2004 2005 41 123 2006 46 2007 40 2005 41 59 125 125 59 
30745,Java,"    public static final @lombok.Builder @lombok.Value class TestBuilder {
      public static @java.lang.SuppressWarnings(""all"") class TestBuilderBuilder {
        private @java.lang.SuppressWarnings(""all"") String field;
        @java.lang.SuppressWarnings(""all"") TestBuilderBuilder() {
          super();
        }
        /**
         * @return {@code this}.
         */
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder field(final String field) {
          this.field = field;
          return this;
        }
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder build() {
          return new BuilderNestedInEnum.TestEnum.TestBuilder(this.field);
        }
        public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
          return ((""BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder(field="" + this.field) + "")"");
        }
      }
      private final String field;
      @java.lang.SuppressWarnings(""all"") TestBuilder(final String field) {
        super();
        this.field = field;
      }
      public static @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder builder() {
        return new BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder();
      }
      public @java.lang.SuppressWarnings(""all"") String getField() {
        return this.field;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") boolean equals(final java.lang.Object o) {
        if ((o == this))
            return true;
        if ((! (o instanceof BuilderNestedInEnum.TestEnum.TestBuilder)))
            return false;
        final BuilderNestedInEnum.TestEnum.TestBuilder other = (BuilderNestedInEnum.TestEnum.TestBuilder) o;
        final java.lang.Object this$field = this.getField();
        final java.lang.Object other$field = other.getField();
        if (((this$field == null) ? (other$field != null) : (! this$field.equals(other$field))))
            return false;
        return true;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final java.lang.Object $field = this.getField();
        result = ((result * PRIME) + (($field == null) ? 43 : $field.hashCode()));
        return result;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""BuilderNestedInEnum.TestEnum.TestBuilder(field="" + this.getField()) + "")"");
      }
    }",0,439 457 381 64 2000 46 2001 64 2000 46 2002 334 2003 123 439 457 64 2004 46 2005 46 2006 40 648 41 334 2007 123 437 64 2004 46 2005 46 2006 40 648 41 2008 2009 59 64 2004 46 2005 46 2006 40 648 41 2007 40 41 123 463 40 41 59 125 618 439 64 2004 46 2005 46 2006 40 648 41 2010 46 2011 46 2003 46 2007 2009 40 381 2008 2009 41 123 467 46 2009 61 2009 59 450 467 59 125 439 64 2004 46 2005 46 2006 40 648 41 2010 46 2011 46 2003 2012 40 41 123 450 418 2010 46 2011 46 2003 40 467 46 2009 41 59 125 439 64 2004 46 2005 46 2013 64 2004 46 2005 46 2006 40 648 41 2004 46 2005 46 2008 2014 40 41 123 450 40 40 648 43 467 46 2009 41 43 648 41 59 125 125 437 381 2015 2016 59 64 2004 46 2005 46 2006 40 648 41 2003 40 381 2015 2016 41 123 463 40 41 59 467 46 2016 61 2016 59 125 439 457 64 2004 46 2005 46 2006 40 648 41 2017 46 2018 46 2003 46 2007 2019 40 41 123 450 418 2017 46 2018 46 2003 46 2007 40 41 59 125 439 64 2004 46 2005 46 2006 40 648 41 2015 2020 40 41 123 450 467 46 2016 59 125 439 64 2004 46 2005 46 2021 64 2004 46 2005 46 2006 40 648 41 324 2022 40 381 2004 46 2005 46 2023 2024 41 123 392 40 40 2024 614 467 41 41 450 473 59 392 40 40 33 40 2024 402 2017 46 2018 46 2003 41 41 41 450 380 59 381 2017 46 2018 46 2003 2025 61 40 2017 46 2018 46 2003 41 2024 59 381 2004 46 2005 46 2023 467 36 2016 61 467 46 2020 40 41 59 381 2004 46 2005 46 2023 2025 36 2016 61 2025 46 2020 40 41 59 392 40 40 40 467 36 2016 614 424 41 63 40 2025 36 2016 631 424 41 58 40 33 467 36 2016 46 2022 40 2025 36 2016 41 41 41 41 450 380 59 450 473 59 125 439 64 2004 46 2005 46 2021 64 2004 46 2005 46 2006 40 648 41 404 2026 40 41 123 381 404 2027 61 1503 59 404 2028 61 1501 59 381 2004 46 2005 46 2023 36 2016 61 467 46 2020 40 41 59 2028 61 40 40 2028 42 2027 41 43 40 40 36 2016 614 424 41 63 1503 58 36 2016 46 2026 40 41 41 41 59 450 2028 59 125 439 64 2004 46 2005 46 2021 64 2004 46 2005 46 2006 40 648 41 2004 46 2005 46 2015 2029 40 41 123 450 40 40 648 43 467 46 2020 40 41 41 43 648 41 59 125 125 
30746,Java,"class BuilderNestedInEnum {
  public enum TestEnum {
    public static final @lombok.Builder @lombok.Value class TestBuilder {
      public static @java.lang.SuppressWarnings(""all"") class TestBuilderBuilder {
        private @java.lang.SuppressWarnings(""all"") String field;
        @java.lang.SuppressWarnings(""all"") TestBuilderBuilder() {
          super();
        }
        /**
         * @return {@code this}.
         */
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder field(final String field) {
          this.field = field;
          return this;
        }
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder build() {
          return new BuilderNestedInEnum.TestEnum.TestBuilder(this.field);
        }
        public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
          return ((""BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder(field="" + this.field) + "")"");
        }
      }
      private final String field;
      @java.lang.SuppressWarnings(""all"") TestBuilder(final String field) {
        super();
        this.field = field;
      }
      public static @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder builder() {
        return new BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder();
      }
      public @java.lang.SuppressWarnings(""all"") String getField() {
        return this.field;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") boolean equals(final java.lang.Object o) {
        if ((o == this))
            return true;
        if ((! (o instanceof BuilderNestedInEnum.TestEnum.TestBuilder)))
            return false;
        final BuilderNestedInEnum.TestEnum.TestBuilder other = (BuilderNestedInEnum.TestEnum.TestBuilder) o;
        final java.lang.Object this$field = this.getField();
        final java.lang.Object other$field = other.getField();
        if (((this$field == null) ? (other$field != null) : (! this$field.equals(other$field))))
            return false;
        return true;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final java.lang.Object $field = this.getField();
        result = ((result * PRIME) + (($field == null) ? 43 : $field.hashCode()));
        return result;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""BuilderNestedInEnum.TestEnum.TestBuilder(field="" + this.getField()) + "")"");
      }
    }
    FOO(),
    BAR(),
    <clinit>() {
    }
    public TestEnum() {
      super();
    }
  }",0,334 2000 123 439 370 2001 123 439 457 381 64 2002 46 2003 64 2002 46 2004 334 2005 123 439 457 64 2006 46 2007 46 2008 40 648 41 334 2009 123 437 64 2006 46 2007 46 2008 40 648 41 2010 2011 59 64 2006 46 2007 46 2008 40 648 41 2009 40 41 123 463 40 41 59 125 618 439 64 2006 46 2007 46 2008 40 648 41 2000 46 2001 46 2005 46 2009 2011 40 381 2010 2011 41 123 467 46 2011 61 2011 59 450 467 59 125 439 64 2006 46 2007 46 2008 40 648 41 2000 46 2001 46 2005 2012 40 41 123 450 418 2000 46 2001 46 2005 40 467 46 2011 41 59 125 439 64 2006 46 2007 46 2013 64 2006 46 2007 46 2008 40 648 41 2006 46 2007 46 2010 2014 40 41 123 450 40 40 648 43 467 46 2011 41 43 648 41 59 125 125 437 381 2015 2016 59 64 2006 46 2007 46 2008 40 648 41 2005 40 381 2015 2016 41 123 463 40 41 59 467 46 2016 61 2016 59 125 439 457 64 2006 46 2007 46 2008 40 648 41 2000 46 2001 46 2005 46 2009 2017 40 41 123 450 418 2000 46 2001 46 2005 46 2009 40 41 59 125 439 64 2006 46 2007 46 2008 40 648 41 2015 2018 40 41 123 450 467 46 2016 59 125 439 64 2006 46 2007 46 2019 64 2006 46 2007 46 2008 40 648 41 324 2020 40 381 2006 46 2007 46 2021 2022 41 123 392 40 40 2022 614 467 41 41 450 473 59 392 40 40 33 40 2022 402 2000 46 2001 46 2005 41 41 41 450 380 59 381 2000 46 2001 46 2005 2023 61 40 2000 46 2001 46 2005 41 2022 59 381 2006 46 2007 46 2021 467 36 2016 61 467 46 2018 40 41 59 381 2006 46 2007 46 2021 2023 36 2016 61 2023 46 2018 40 41 59 392 40 40 40 467 36 2016 614 424 41 63 40 2023 36 2016 631 424 41 58 40 33 467 36 2016 46 2020 40 2023 36 2016 41 41 41 41 450 380 59 450 473 59 125 439 64 2006 46 2007 46 2019 64 2006 46 2007 46 2008 40 648 41 404 2024 40 41 123 381 404 2025 61 1503 59 404 2026 61 1501 59 381 2006 46 2007 46 2021 36 2016 61 467 46 2018 40 41 59 2026 61 40 40 2026 42 2025 41 43 40 40 36 2016 614 424 41 63 1503 58 36 2016 46 2024 40 41 41 41 59 450 2026 59 125 439 64 2006 46 2007 46 2019 64 2006 46 2007 46 2008 40 648 41 2006 46 2007 46 2015 2027 40 41 123 450 40 40 648 43 467 46 2018 40 41 41 43 648 41 59 125 125 2028 40 41 44 2029 40 41 44 60 2030 62 40 41 123 125 439 2001 40 41 123 463 40 41 59 125 125 
30818,Java,"	@Provides
	public static class HandleJulLog extends JavacAnnotationHandler<lombok.extern.java.Log> {
		@Override public void handle(AnnotationValues<lombok.extern.java.Log> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_JUL_FLAG_USAGE, ""@java.Log"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.JUL, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
30833,Java,"		WITH {
			@Override public String apply(final EclipseNode node) {
				return addReturnsUpdatedSelfIfNeeded(applySetter(node, ""WITH|WITHER""));
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 41 123 450 2006 40 2007 40 2005 44 648 41 41 59 125 125 44 
30924,Java,"class ExtensionMethodFunctional {
	public void test() {
		String test = ""test"";
		test = ExtensionMethodFunctional.Extensions.map(test, s -> ExtensionMethodFunctional.Extensions.reverse(s));
		ExtensionMethodFunctional.Extensions.consume(test, s -> System.out.println(""1: "" + s), s -> System.out.println(""2: "" + s));
		ExtensionMethodFunctional.Extensions.consume(test, System.out::println, System.out::println);
		ExtensionMethodFunctional.Extensions.toList1(Stream.of(""a"", ""b"", ""c"").map(String::toUpperCase));
		List<Integer> i2 = ExtensionMethodFunctional.Extensions.toList2(Stream.of(""a"", ""b"", ""c"").map(String::toUpperCase));
	}

	static class Extensions {
		public static <T, R> R map(T value, Function<T, R> mapper) {
			return mapper.apply(value);
		}

		public static String reverse(String string) {
			return new StringBuilder(string).reverse().toString();
		}

		@SafeVarargs
		public static <T> void consume(T o, Consumer<T>... consumer) {
			for (int i = 0; i < consumer.length; i++) {
				consumer[i].accept(o);
			}
		}
		
		public static <T> List<T> toList1(Stream<T> stream) {
			return (List<T>) stream.collect(Collectors.toList());
		}

		public static <T, U> List<U> toList2(Stream<T> stream) {
			return null;
		}
	}
}",0,334 2000 123 439 492 2001 40 41 123 2002 2001 61 648 59 2001 61 2000 46 2003 46 2004 40 2001 44 2005 45 62 2000 46 2003 46 2006 40 2005 41 41 59 2000 46 2003 46 2007 40 2001 44 2005 45 62 2008 46 430 46 2009 40 648 43 2005 41 44 2005 45 62 2008 46 430 46 2009 40 648 43 2005 41 41 59 2000 46 2003 46 2007 40 2001 44 2008 46 430 58 58 2009 44 2008 46 430 58 58 2009 41 59 2000 46 2003 46 2010 40 2011 46 2012 40 648 44 648 44 648 41 46 2004 40 2002 58 58 2013 41 41 59 2014 60 2015 62 2016 61 2000 46 2003 46 2017 40 2011 46 2012 40 648 44 648 44 648 41 46 2004 40 2002 58 58 2013 41 41 59 125 457 334 2018 123 439 457 60 2019 44 2020 62 2020 2021 40 2019 2022 44 2023 60 2019 44 2020 62 2024 41 123 450 2024 46 2025 40 2022 41 59 125 439 457 2026 2027 40 2026 461 41 123 450 418 2028 40 461 41 46 2027 40 41 46 2029 40 41 59 125 64 2030 439 457 60 2019 62 492 2031 40 2019 2032 44 2033 60 2019 62 613 2034 41 123 385 40 404 2035 61 1500 59 2035 60 2034 46 2036 59 2035 637 41 123 2034 91 2035 93 46 2037 40 2032 41 59 125 125 439 457 60 2019 62 2038 60 2019 62 2039 40 2040 60 2019 62 2041 41 123 450 40 2038 60 2019 62 41 2041 46 2042 40 2043 46 2044 40 41 41 59 125 439 457 60 2019 44 2045 62 2038 60 2045 62 2046 40 2040 60 2019 62 2041 41 123 450 424 59 125 125 125 
30941,Java,"    private static final @java.lang.SuppressWarnings(""all"") class ChildBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<SuperBuilderWithDefaultsAndTargetTyping.Child, SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl> {
      private ChildBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Child(this);
      }
    }",0,437 457 381 64 2000 46 2001 46 2002 40 648 41 334 2003 378 2004 46 2005 46 2006 60 2004 46 2005 44 2004 46 2005 46 2003 62 123 437 2003 40 41 123 463 40 41 59 125 438 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 2004 46 2005 46 2003 2008 40 41 123 450 467 59 125 439 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 2004 46 2005 2009 40 41 123 450 418 2004 46 2005 40 467 41 59 125 125 
30943,Java,"    public static abstract @java.lang.SuppressWarnings(""all"") class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
      private @java.lang.SuppressWarnings(""all"") String foo$value;
      private @java.lang.SuppressWarnings(""all"") boolean foo$set;
      public ParentBuilder() {
        super();
      }
      protected abstract @java.lang.SuppressWarnings(""all"") B self();
      public abstract @java.lang.SuppressWarnings(""all"") C build();
      /**
       * @return {@code this}.
       */
      public @java.lang.SuppressWarnings(""all"") B foo(final String foo) {
        this.foo$value = foo;
        foo$set = true;
        return self();
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value) + "")"");
      }
    }",0,439 457 305 64 2000 46 2001 46 2002 40 648 41 334 2003 60 2004 378 2005 46 2006 44 2007 378 2005 46 2006 46 2003 60 2004 44 2007 641 123 437 64 2000 46 2001 46 2002 40 648 41 2008 2009 36 2010 59 437 64 2000 46 2001 46 2002 40 648 41 324 2009 36 2011 59 439 2003 40 41 123 463 40 41 59 125 438 305 64 2000 46 2001 46 2002 40 648 41 2007 2012 40 41 59 439 305 64 2000 46 2001 46 2002 40 648 41 2004 2013 40 41 59 618 439 64 2000 46 2001 46 2002 40 648 41 2007 2009 40 381 2008 2009 41 123 467 46 2009 36 2010 61 2009 59 2009 36 2011 61 473 59 450 2012 40 41 59 125 439 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 2000 46 2001 46 2008 2015 40 41 123 450 40 40 648 43 467 46 2009 36 2010 41 43 648 41 59 125 125 
30944,Java,"    private static final @java.lang.SuppressWarnings(""all"") class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
      private ParentBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
      }
    }",0,437 457 381 64 2000 46 2001 46 2002 40 648 41 334 2003 378 2004 46 2005 46 2006 60 2004 46 2005 44 2004 46 2005 46 2003 62 123 437 2003 40 41 123 463 40 41 59 125 438 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 2004 46 2005 46 2003 2008 40 41 123 450 467 59 125 439 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 2004 46 2005 2009 40 41 123 450 418 2004 46 2005 40 467 41 59 125 125 
30945,Java,"  public static @lombok.experimental.SuperBuilder class Parent {
    public static abstract @java.lang.SuppressWarnings(""all"") class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
      private @java.lang.SuppressWarnings(""all"") String foo$value;
      private @java.lang.SuppressWarnings(""all"") boolean foo$set;
      public ParentBuilder() {
        super();
      }
      protected abstract @java.lang.SuppressWarnings(""all"") B self();
      public abstract @java.lang.SuppressWarnings(""all"") C build();
      /**
       * @return {@code this}.
       */
      public @java.lang.SuppressWarnings(""all"") B foo(final String foo) {
        this.foo$value = foo;
        foo$set = true;
        return self();
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value) + "")"");
      }
    }
    private static final @java.lang.SuppressWarnings(""all"") class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
      private ParentBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
      }
    }
    private @lombok.Builder.Default String foo;
    private static @java.lang.SuppressWarnings(""all"") String $default$foo() {
      return doSth(Arrays.asList(1), Arrays.asList('a'));
    }
    protected @java.lang.SuppressWarnings(""all"") Parent(final SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> b) {
      super();
      if (b.foo$set)
          this.foo = b.foo$value;
      else
          this.foo = SuperBuilderWithDefaultsAndTargetTyping.Parent.$default$foo();
    }
    public static @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> builder() {
      return new SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl();
    }
  }",0,439 457 64 2000 46 2001 46 2002 334 2003 123 439 457 305 64 2004 46 2005 46 2006 40 648 41 334 2007 60 2008 378 2009 46 2003 44 2010 378 2009 46 2003 46 2007 60 2008 44 2010 641 123 437 64 2004 46 2005 46 2006 40 648 41 2011 2012 36 2013 59 437 64 2004 46 2005 46 2006 40 648 41 324 2012 36 2014 59 439 2007 40 41 123 463 40 41 59 125 438 305 64 2004 46 2005 46 2006 40 648 41 2010 2015 40 41 59 439 305 64 2004 46 2005 46 2006 40 648 41 2008 2016 40 41 59 618 439 64 2004 46 2005 46 2006 40 648 41 2010 2012 40 381 2011 2012 41 123 467 46 2012 36 2013 61 2012 59 2012 36 2014 61 473 59 450 2015 40 41 59 125 439 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 2004 46 2005 46 2011 2018 40 41 123 450 40 40 648 43 467 46 2012 36 2013 41 43 648 41 59 125 125 437 457 381 64 2004 46 2005 46 2006 40 648 41 334 2019 378 2009 46 2003 46 2007 60 2009 46 2003 44 2009 46 2003 46 2019 62 123 437 2019 40 41 123 463 40 41 59 125 438 64 2004 46 2005 46 2020 64 2004 46 2005 46 2006 40 648 41 2009 46 2003 46 2019 2021 40 41 123 450 467 59 125 439 64 2004 46 2005 46 2020 64 2004 46 2005 46 2006 40 648 41 2009 46 2003 2022 40 41 123 450 418 2009 46 2003 40 467 41 59 125 125 437 64 2000 46 2023 46 2024 2025 2026 59 437 457 64 2004 46 2005 46 2006 40 648 41 2025 36 349 36 2026 40 41 123 450 2027 40 2028 46 2029 40 1501 41 44 2028 46 2029 40 607 41 41 59 125 438 64 2004 46 2005 46 2006 40 648 41 2003 40 381 2009 46 2003 46 2007 60 63 44 63 62 2030 41 123 463 40 41 59 392 40 2030 46 2026 36 2031 41 467 46 2026 61 2030 46 2026 36 2032 59 360 467 46 2026 61 2009 46 2003 46 36 349 36 2026 40 41 59 125 439 457 64 2004 46 2005 46 2006 40 648 41 2009 46 2003 46 2007 60 63 44 63 62 2033 40 41 123 450 418 2009 46 2003 46 2019 40 41 59 125 125 
31327,Java,"		sm.setFilter(new Filter() {
			@Override public boolean shouldTransform(ClassLoader loader, String className, Class<?> classBeingDefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {
				if (loader != null && loader.getClass().getName().startsWith(""org.sonar.classloader."")) return false; // Relevant to bug #2351
				if (!(loader instanceof URLClassLoader)) return true;
				ClassLoader parent = loader.getParent();
				if (parent == null) return true;
				return !parent.getClass().getName().startsWith(""org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader"");
			}
		});",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 324 2004 40 2005 2006 44 2007 2008 44 2009 60 63 62 2010 44 2011 2012 44 326 91 93 2013 41 123 392 40 2006 631 424 605 2006 46 2014 40 41 46 2015 40 41 46 2016 40 648 41 41 450 380 59 621 392 40 33 40 2006 402 2017 41 41 450 473 59 2005 2018 61 2006 46 2019 40 41 59 392 40 2018 614 424 41 450 473 59 450 33 2018 46 2014 40 41 46 2015 40 41 46 2016 40 648 41 59 125 125 41 59 
31352,Java,"		public static final class TestBuilder {
			private final String field;
			@java.lang.SuppressWarnings(""all"")
			TestBuilder(final String field) {
				this.field = field;
			}
			@java.lang.SuppressWarnings(""all"")
			public static class TestBuilderBuilder {
				@java.lang.SuppressWarnings(""all"")
				private String field;
				@java.lang.SuppressWarnings(""all"")
				TestBuilderBuilder() {
				}
				/**
				 * @return {@code this}.
				 */
				@java.lang.SuppressWarnings(""all"")
				public BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder field(final String field) {
					this.field = field;
					return this;
				}
				@java.lang.SuppressWarnings(""all"")
				public BuilderNestedInEnum.TestEnum.TestBuilder build() {
					return new BuilderNestedInEnum.TestEnum.TestBuilder(this.field);
				}
				@java.lang.Override
				@java.lang.SuppressWarnings(""all"")
				public java.lang.String toString() {
					return ""BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder(field="" + this.field + "")"";
				}
			}
			@java.lang.SuppressWarnings(""all"")
			public static BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder builder() {
				return new BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder();
			}
			@java.lang.SuppressWarnings(""all"")
			public String getField() {
				return this.field;
			}
			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public boolean equals(final java.lang.Object o) {
				if (o == this) return true;
				if (!(o instanceof BuilderNestedInEnum.TestEnum.TestBuilder)) return false;
				final BuilderNestedInEnum.TestEnum.TestBuilder other = (BuilderNestedInEnum.TestEnum.TestBuilder) o;
				final java.lang.Object this$field = this.getField();
				final java.lang.Object other$field = other.getField();
				if (this$field == null ? other$field != null : !this$field.equals(other$field)) return false;
				return true;
			}
			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public int hashCode() {
				final int PRIME = 59;
				int result = 1;
				final java.lang.Object $field = this.getField();
				result = result * PRIME + ($field == null ? 43 : $field.hashCode());
				return result;
			}
			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""BuilderNestedInEnum.TestEnum.TestBuilder(field="" + this.getField() + "")"";
			}
		}",0,439 457 381 334 2000 123 437 381 2001 2002 59 64 2003 46 2004 46 2005 40 648 41 2000 40 381 2001 2002 41 123 467 46 2002 61 2002 59 125 64 2003 46 2004 46 2005 40 648 41 439 457 334 2006 123 64 2003 46 2004 46 2005 40 648 41 437 2001 2002 59 64 2003 46 2004 46 2005 40 648 41 2006 40 41 123 125 618 64 2003 46 2004 46 2005 40 648 41 439 2007 46 2008 46 2000 46 2006 2002 40 381 2001 2002 41 123 467 46 2002 61 2002 59 450 467 59 125 64 2003 46 2004 46 2005 40 648 41 439 2007 46 2008 46 2000 2009 40 41 123 450 418 2007 46 2008 46 2000 40 467 46 2002 41 59 125 64 2003 46 2004 46 2010 64 2003 46 2004 46 2005 40 648 41 439 2003 46 2004 46 2001 2011 40 41 123 450 648 43 467 46 2002 43 648 59 125 125 64 2003 46 2004 46 2005 40 648 41 439 457 2012 46 2013 46 2000 46 2006 2014 40 41 123 450 418 2012 46 2013 46 2000 46 2006 40 41 59 125 64 2003 46 2004 46 2005 40 648 41 439 2001 2015 40 41 123 450 467 46 2002 59 125 64 2003 46 2004 46 2016 64 2003 46 2004 46 2005 40 648 41 439 324 2017 40 381 2003 46 2004 46 2018 2019 41 123 392 40 2019 614 467 41 450 473 59 392 40 33 40 2019 402 2012 46 2013 46 2000 41 41 450 380 59 381 2012 46 2013 46 2000 2020 61 40 2012 46 2013 46 2000 41 2019 59 381 2003 46 2004 46 2018 467 36 2002 61 467 46 2015 40 41 59 381 2003 46 2004 46 2018 2020 36 2002 61 2020 46 2015 40 41 59 392 40 467 36 2002 614 424 63 2020 36 2002 631 424 58 33 467 36 2002 46 2017 40 2020 36 2002 41 41 450 380 59 450 473 59 125 64 2003 46 2004 46 2016 64 2003 46 2004 46 2005 40 648 41 439 404 2021 40 41 123 381 404 2022 61 1503 59 404 2023 61 1501 59 381 2003 46 2004 46 2018 36 2002 61 467 46 2015 40 41 59 2023 61 2023 42 2022 43 40 36 2002 614 424 63 1503 58 36 2002 46 2021 40 41 41 59 450 2023 59 125 64 2003 46 2004 46 2016 64 2003 46 2004 46 2005 40 648 41 439 2003 46 2004 46 2001 2024 40 41 123 450 648 43 467 46 2015 40 41 43 648 59 125 125 
32256,Java,"    public static class DrawFlushI implements LInstruction{
        public int target;

        public DrawFlushI(int target){
            this.target = target;
        }

        public DrawFlushI(){
        }

        @Override
        public void run(LExecutor exec){
            //graphics on headless servers are useless.
            if(Vars.headless) return;

            if(exec.building(target) instanceof LogicDisplayBuild d && d.team == exec.team){
                if(d.commands.size + exec.graphicsBuffer.size < maxDisplayBuffer){
                    for(int i = 0; i < exec.graphicsBuffer.size; i++){
                        d.commands.addLast(exec.graphicsBuffer.items[i]);
                    }
                }
                exec.graphicsBuffer.clear();
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 59 439 2000 40 404 2002 41 123 467 46 2002 61 2002 59 125 439 2000 40 41 123 125 64 2003 439 492 2004 40 2005 2006 41 123 621 392 40 2007 46 2008 41 450 59 392 40 2006 46 2009 40 2002 41 402 2010 2011 605 2011 46 2012 614 2006 46 2012 41 123 392 40 2011 46 2013 46 2014 43 2006 46 2015 46 2014 60 2016 41 123 385 40 404 2017 61 1500 59 2017 60 2006 46 2015 46 2014 59 2017 637 41 123 2011 46 2013 46 2018 40 2006 46 2015 46 2019 91 2017 93 41 59 125 125 2006 46 2015 46 2020 40 41 59 125 125 125 
32257,Java,"    public static class DrawI implements LInstruction{
        public byte type;
        public int target;
        public int x, y, p1, p2, p3, p4;

        public DrawI(byte type, int target, int x, int y, int p1, int p2, int p3, int p4){
            this.type = type;
            this.target = target;
            this.x = x;
            this.y = y;
            this.p1 = p1;
            this.p2 = p2;
            this.p3 = p3;
            this.p4 = p4;
        }

        public DrawI(){
        }

        @Override
        public void run(LExecutor exec){
            //graphics on headless servers are useless.
            if(Vars.headless) return;

            int num1 = exec.numi(p1);

            if(type == LogicDisplay.commandImage){
                num1 = exec.obj(p1) instanceof UnlockableContent u ? u.iconId : 0;
            }

            //add graphics calls, cap graphics buffer size
            if(exec.graphicsBuffer.size < maxGraphicsBuffer){
                exec.graphicsBuffer.add(DisplayCmd.get(type, packSign(exec.numi(x)), packSign(exec.numi(y)), packSign(num1), packSign(exec.numi(p2)), packSign(exec.numi(p3)), packSign(exec.numi(p4))));
            }
        }

        static int packSign(int value){
            return (Math.abs(value) & 0b0111111111) | (value < 0 ? 0b1000000000 : 0);
        }
    }",0,439 457 334 2000 395 2001 123 439 326 2002 59 439 404 2003 59 439 404 2004 44 2005 44 2006 44 2007 44 2008 44 2009 59 439 2000 40 326 2002 44 404 2003 44 404 2004 44 404 2005 44 404 2006 44 404 2007 44 404 2008 44 404 2009 41 123 467 46 2002 61 2002 59 467 46 2003 61 2003 59 467 46 2004 61 2004 59 467 46 2005 61 2005 59 467 46 2006 61 2006 59 467 46 2007 61 2007 59 467 46 2008 61 2008 59 467 46 2009 61 2009 59 125 439 2000 40 41 123 125 64 2010 439 492 2011 40 2012 2013 41 123 621 392 40 2014 46 2015 41 450 59 404 2016 61 2013 46 2017 40 2006 41 59 392 40 2002 614 2018 46 2019 41 123 2016 61 2013 46 2020 40 2006 41 402 2021 2022 63 2022 46 2023 58 1500 59 125 621 392 40 2013 46 2024 46 2025 60 2026 41 123 2013 46 2024 46 2027 40 2028 46 2029 40 2002 44 2030 40 2013 46 2017 40 2004 41 41 44 2030 40 2013 46 2017 40 2005 41 41 44 2030 40 2016 41 44 2030 40 2013 46 2017 40 2007 41 41 44 2030 40 2013 46 2017 40 2008 41 41 44 2030 40 2013 46 2017 40 2009 41 41 41 41 59 125 125 457 404 2031 40 404 2032 41 123 450 40 2033 46 2034 40 2032 41 38 1500 41 124 40 2032 60 1500 63 1500 58 1500 41 59 125 125 
32258,Java,"    public static class GetLinkI implements LInstruction{
        public int output, index;

        public GetLinkI(int output, int index){
            this.index = index;
            this.output = output;
        }

        public GetLinkI(){
        }

        @Override
        public void run(LExecutor exec){
            int address = exec.numi(index);

            exec.setobj(output, address >= 0 && address < exec.links.length ? exec.links[address] : null);
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 44 2003 59 439 2000 40 404 2002 44 404 2003 41 123 467 46 2003 61 2003 59 467 46 2002 61 2002 59 125 439 2000 40 41 123 125 64 2004 439 492 2005 40 2006 2007 41 123 404 2008 61 2007 46 2009 40 2003 41 59 2007 46 2010 40 2002 44 2008 615 1500 605 2008 60 2007 46 2011 46 2012 63 2007 46 2011 91 2008 93 58 424 41 59 125 125 
32259,Java,"    public static class JumpI implements LInstruction{
        public ConditionOp op = ConditionOp.notEqual;
        public int value, compare, address;

        public JumpI(ConditionOp op, int value, int compare, int address){
            this.op = op;
            this.value = value;
            this.compare = compare;
            this.address = address;
        }

        public JumpI(){
        }

        @Override
        public void run(LExecutor exec){
            if(address != -1){
                Var va = exec.var(value);
                Var vb = exec.var(compare);
                boolean cmp;

                if(op == ConditionOp.strictEqual){
                    cmp = va.isobj == vb.isobj && ((va.isobj && va.objval == vb.objval) || (!va.isobj && va.numval == vb.numval));
                }else if(op.objFunction != null && va.isobj && vb.isobj){
                    //use object function if both are objects
                    cmp = op.objFunction.get(exec.obj(value), exec.obj(compare));
                }else{
                    cmp = op.function.get(exec.num(value), exec.num(compare));
                }

                if(cmp){
                    exec.var(varCounter).numval = address;
                }
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 2002 2003 61 2002 46 2004 59 439 404 2005 44 2006 44 2007 59 439 2000 40 2002 2003 44 404 2005 44 404 2006 44 404 2007 41 123 467 46 2003 61 2003 59 467 46 2005 61 2005 59 467 46 2006 61 2006 59 467 46 2007 61 2007 59 125 439 2000 40 41 123 125 64 2008 439 492 2009 40 2010 2011 41 123 392 40 2007 631 45 1501 41 123 2012 2013 61 2011 46 490 40 2005 41 59 2012 2014 61 2011 46 490 40 2006 41 59 324 2015 59 392 40 2003 614 2002 46 2016 41 123 2015 61 2013 46 2017 614 2014 46 2017 605 40 40 2013 46 2017 605 2013 46 2018 614 2014 46 2018 41 606 40 33 2013 46 2017 605 2013 46 2019 614 2014 46 2019 41 41 59 125 360 392 40 2003 46 2020 631 424 605 2013 46 2021 605 2014 46 2021 41 123 621 2015 61 2003 46 2020 46 2022 40 2011 46 2023 40 2005 41 44 2011 46 2023 40 2006 41 41 59 125 360 123 2015 61 2003 46 389 46 2024 40 2011 46 2025 40 2005 41 44 2011 46 2025 40 2006 41 41 59 125 392 40 2015 41 123 2011 46 490 40 2026 41 46 2027 61 2007 59 125 125 125 125 
32265,Java,"    public static class SenseI implements LInstruction{
        public int from, to, type;

        public SenseI(int from, int to, int type){
            this.from = from;
            this.to = to;
            this.type = type;
        }

        public SenseI(){
        }

        @Override
        public void run(LExecutor exec){
            Object target = exec.obj(from);
            Object sense = exec.obj(type);

            if(target == null && sense == LAccess.dead){
                exec.setnum(to, 1);
                return;
            }

            //note that remote units/buildings can be sensed as well
            if(target instanceof Senseable se){
                if(sense instanceof Content co){
                    exec.setnum(to, se.sense(co));
                }else if(sense instanceof LAccess la){
                    Object objOut = se.senseObject(la);

                    if(objOut == Senseable.noSensed){
                        //numeric output
                        exec.setnum(to, se.sense(la));
                    }else{
                        //object output
                        exec.setobj(to, objOut);
                    }
                }
            }else{
                exec.setobj(to, null);
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 388 44 2002 44 2003 59 439 2000 40 404 388 44 404 2002 44 404 2003 41 123 467 46 388 61 388 59 467 46 2002 61 2002 59 467 46 2003 61 2003 59 125 439 2000 40 41 123 125 64 2004 439 492 2005 40 2006 2007 41 123 2008 2009 61 2007 46 2010 40 388 41 59 2008 2011 61 2007 46 2010 40 2003 41 59 392 40 2009 614 424 605 2011 614 2012 46 2013 41 123 2007 46 2014 40 2002 44 1501 41 59 450 59 125 621 392 40 2009 402 2015 2016 41 123 392 40 2011 402 2017 2018 41 123 2007 46 2019 40 2002 44 2016 46 2011 40 2018 41 41 59 125 360 392 40 2011 402 2012 2020 41 123 2008 2021 61 2016 46 2022 40 2020 41 59 392 40 2021 614 2015 46 2023 41 123 621 2007 46 2024 40 2002 44 2016 46 2011 40 2020 41 41 59 125 360 123 621 2007 46 2025 40 2002 44 2021 41 59 125 125 125 360 123 2007 46 2026 40 2002 44 424 41 59 125 125 125 
32270,Java,"    public static class WaitI implements LInstruction{
        public int value;

        public float curTime;
        public double wait;
        public long frameId;

        public WaitI(int value){
            this.value = value;
        }

        public WaitI(){

        }

        @Override
        public void run(LExecutor exec){
            if(curTime >= exec.num(value)){
                curTime = 0f;
            }else{
                //skip back to self.
                exec.var(varCounter).numval --;
            }

            if(Core.graphics.getFrameId() != frameId){
                curTime += Time.delta / 60f;
                frameId = Core.graphics.getFrameId();
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 59 439 384 2003 59 439 356 2004 59 439 413 2005 59 439 2000 40 404 2002 41 123 467 46 2002 61 2002 59 125 439 2000 40 41 123 125 64 2006 439 492 2007 40 2008 2009 41 123 392 40 2003 615 2009 46 2010 40 2002 41 41 123 2003 61 1500 59 125 360 123 621 2009 46 490 40 2011 41 46 2012 629 59 125 392 40 2013 46 2014 46 2015 40 41 631 2005 41 123 2003 636 2016 46 2017 47 1503 59 2005 61 2013 46 2014 46 2015 40 41 59 125 125 125 
32331,Java,"    public static class NoopI implements LInstruction{
        @Override
        public void run(LExecutor exec){}
    }",0,439 457 334 2000 395 2001 123 64 2002 439 492 2003 40 2004 2005 41 123 125 125 
32926,Java,"                        new ThrowableAssert.ThrowingCallable() {
                            public void call() {
                                mock.add("""");
                            }
                        })",0,418 2000 46 2001 40 41 123 439 492 2002 40 41 123 2003 46 2004 40 648 41 59 125 125 41 
32928,Java,"                        new ThrowableAssert.ThrowingCallable() {
                            public void call() {
                                mock.clear();
                            }
                        })",0,418 2000 46 2001 40 41 123 439 492 2002 40 41 123 2003 46 2004 40 41 59 125 125 41 
47127,Java,"        new Thread(""TermSessionInputReader[pid="" + mShellPid + ""]"") {
            @Override
            public void run() {
                try (InputStream termIn = new FileInputStream(terminalFileDescriptorWrapped)) {
                    final byte[] buffer = new byte[4096];
                    while (true) {
                        int read = termIn.read(buffer);
                        if (read == -1) return;
                        if (!mProcessToTerminalIOQueue.write(buffer, 0, read)) return;
                        mMainThreadHandler.sendEmptyMessage(MSG_NEW_INPUT);
                    }
                } catch (Exception e) {
                    // Ignore, just shutting down.
                }
            }
        }.start();",0,418 2000 40 648 43 2001 43 648 41 123 64 2002 439 492 2003 40 41 123 474 40 2004 2005 61 418 2006 40 2007 41 41 123 381 326 91 93 2008 61 418 326 91 1505 93 59 496 40 473 41 123 404 2009 61 2005 46 2009 40 2008 41 59 392 40 2009 614 45 1501 41 450 59 392 40 33 2010 46 2011 40 2008 44 1500 44 2009 41 41 450 59 2012 46 2013 40 2014 41 59 125 125 329 40 2015 2016 41 123 621 125 125 125 46 2017 40 41 59 
47128,Java,"        new Thread(""TermSessionOutputWriter[pid="" + mShellPid + ""]"") {
            @Override
            public void run() {
                final byte[] buffer = new byte[4096];
                try (FileOutputStream termOut = new FileOutputStream(terminalFileDescriptorWrapped)) {
                    while (true) {
                        int bytesToWrite = mTerminalToProcessIOQueue.read(buffer, true);
                        if (bytesToWrite == -1) return;
                        termOut.write(buffer, 0, bytesToWrite);
                    }
                } catch (IOException e) {
                    // Ignore.
                }
            }
        }.start();",0,418 2000 40 648 43 2001 43 648 41 123 64 2002 439 492 2003 40 41 123 381 326 91 93 2004 61 418 326 91 1505 93 59 474 40 2005 2006 61 418 2005 40 2007 41 41 123 496 40 473 41 123 404 2008 61 2009 46 2010 40 2004 44 473 41 59 392 40 2008 614 45 1501 41 450 59 2006 46 2011 40 2004 44 1500 44 2008 41 59 125 125 329 40 2012 2013 41 123 621 125 125 125 46 2014 40 41 59 
47129,Java,"        new Thread(""TermSessionWaiter[pid="" + mShellPid + ""]"") {
            @Override
            public void run() {
                int processExitCode = JNI.waitFor(mShellPid);
                mMainThreadHandler.sendMessage(mMainThreadHandler.obtainMessage(MSG_PROCESS_EXITED, processExitCode));
            }
        }.start();",0,418 2000 40 648 43 2001 43 648 41 123 64 2002 439 492 2003 40 41 123 404 2004 61 2005 46 2006 40 2001 41 59 2007 46 2008 40 2007 46 2009 40 2010 44 2004 41 41 59 125 125 46 2011 40 41 59 
27182,Java,"public final class ItemCrystallizationData extends GameXmlReader {
    private static final Logger LOGGER = LoggerFactory.getLogger(ItemCrystallizationData.class);

    private final Map<CrystalType, Map<CrystallizationType, List<ItemChanceHolder>>> crystallizationTemplates = new EnumMap<>(CrystalType.class);
    private final IntMap<CrystallizationDataHolder> items = new HashIntMap<>();

    private ItemCrystallizationData() {
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/crystallizable-items.xsd"");
    }

    @Override
    public void load() {
        crystallizationTemplates.clear();
        CrystalType.forEach(c -> crystallizationTemplates.put(c, new EnumMap<>(CrystallizationType.class)));

        items.clear();
        parseDatapackFile(""data/crystallizable-items.xml"");
        LOGGER.info(""Loaded {} crystallization templates."", crystallizationTemplates.size());
        LOGGER.info(""Loaded {} pre-defined crystallizable items."", items.size());

        // Generate remaining data.
        generateCrystallizationData();
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", listNode -> {
            for(Node node = listNode.getFirstChild(); nonNull(node); node = node.getNextSibling()) {
                switch (node.getNodeName()) {
                    case ""templates"" -> forEach(node, ""template"", this::parseTemplate);
                    case ""items"" -> forEach(node, ""item"", this::parseItem);
                }
            }
        });
    }

    private void parseTemplate(Node node) {
        forEach(node, ""template"", templateNode -> {
            var attr = templateNode.getAttributes();
            var crystalType = parseEnum(attr, CrystalType.class, ""crystalType"");
            var crystallizationType = parseEnum(attr, CrystallizationType.class, ""crystallizationType"");

            crystallizationTemplates.get(crystalType).put(crystallizationType, parseRewards(templateNode));
        });
    }

    private List<ItemChanceHolder> parseRewards(Node templateNode) {
        final List<ItemChanceHolder> crystallizeRewards = new ArrayList<>();

        forEach(templateNode, ""item"", itemNode -> {
            var attrs = itemNode.getAttributes();
            var itemId = parseInt(attrs, ""id"");
            var itemCount = parseLong(attrs, ""count"");
            var itemChance = parseFloat(attrs, ""chance"");
            crystallizeRewards.add(new ItemChanceHolder(itemId, itemChance, itemCount));
        });
        return crystallizeRewards;
    }

    private void parseItem(Node node) {
        forEach(node, ""item"", itemNode -> {
            final int id = parseInt(itemNode.getAttributes(), ""id"");
            items.put(id, new CrystallizationDataHolder(parseRewards(itemNode)));
        });
    }

    private List<ItemChanceHolder> calculateCrystallizeRewards(ItemTemplate item, List<ItemChanceHolder> crystallizeRewards) {
        if (isNull(crystallizeRewards)) {
            return null;
        }

        final List<ItemChanceHolder> rewards = new ArrayList<>();

        for (ItemChanceHolder reward : crystallizeRewards) {
            float chance = reward.getChance() * item.getCrystalCount();
            long count = reward.getCount();

            if (chance > 100.) {
                double countMul = Math.ceil(chance / 100.);
                chance /= countMul;
                count = (long) (count * countMul);
            }

            rewards.add(new ItemChanceHolder(reward.getId(), chance, count));
        }

        return rewards;
    }

    private void generateCrystallizationData() {
        final int previousCount = items.size();

        if(crystallizationTemplates.values().stream().flatMap(c -> c.values().stream()).anyMatch(Predicate.not(List::isEmpty))) {
            for (ItemTemplate item : ItemEngine.getInstance().getAllItems()) {
                // Check if the data has not been generated.
                if ((isWeapon(item) || isArmor(item)) && item.isCrystallizable() && !items.containsKey(item.getId())) {

                    final List<ItemChanceHolder> holder = crystallizationTemplates.get(item.getCrystalType()).get(isWeapon(item) ? CrystallizationType.WEAPON : CrystallizationType.ARMOR);

                    if (nonNull(holder)) {
                        items.put(item.getId(), new CrystallizationDataHolder(calculateCrystallizeRewards(item, holder)));
                    }
                }
            }
        }

        LOGGER.atInfo().addArgument(() -> items.size() - previousCount).log(""Generated {} crystallizable items from templates."");
    }

    /**
     * @param itemId
     * @return {@code CrystallizationData} for unenchanted items (enchanted items just have different crystal count, but same rewards),<br>
     * or {@code null} if there is no such data registered.
     */
    private CrystallizationDataHolder getCrystallizationData(int itemId) {
        return items.get(itemId);
    }

    /**
     * @param item to calculate its worth in crystals.
     * @return List of {@code ItemChanceHolder} for the rewards with altered crystal count.
     */
    public List<ItemChanceHolder> getCrystallizationRewards(Item item) {
        final List<ItemChanceHolder> result = new ArrayList<>();
        var data = getCrystallizationData(item.getId());
        if (nonNull(data)) {
            // If there are no crystals on the template, add such.
            if (data.getItems().stream().noneMatch(i -> i.getId() == item.getTemplate().getCrystalItemId())) {
                result.add(new ItemChanceHolder(item.getTemplate().getCrystalItemId(), 100, item.getCrystalCount()));
            }

            result.addAll(data.getItems());
        } else {
            // Add basic crystal reward.
            result.add(new ItemChanceHolder(item.getTemplate().getCrystalItemId(), 100, item.getCrystalCount()));
        }

        return result;
    }

    public static void init() {
        getInstance().load();
    }

    public static ItemCrystallizationData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final ItemCrystallizationData INSTANCE = new ItemCrystallizationData();
    }
}",0,439 381 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 44 2006 60 2008 44 2009 60 2010 644 2011 61 418 2012 60 62 40 2007 46 334 41 59 437 381 2013 60 2014 62 2015 61 418 2016 60 62 40 41 59 437 2000 40 41 123 125 64 2017 438 2018 2019 40 41 123 450 2020 46 2021 40 41 46 2022 40 648 41 59 125 64 2017 439 492 2023 40 41 123 2011 46 2024 40 41 59 2007 46 2025 40 2026 45 62 2011 46 2027 40 2026 44 418 2012 60 62 40 2008 46 334 41 41 41 59 2015 46 2024 40 41 59 2028 40 648 41 59 2003 46 2029 40 648 44 2011 46 2030 40 41 41 59 2003 46 2029 40 648 44 2015 46 2030 40 41 41 59 621 2031 40 41 59 2032 40 41 59 125 64 2017 439 492 2033 40 2034 2035 44 2036 2037 41 123 2038 40 2035 44 648 44 2039 45 62 123 385 40 2040 2041 61 2039 46 2042 40 41 59 2043 40 2041 41 59 2041 61 2041 46 2044 40 41 41 123 464 40 2041 46 2045 40 41 41 123 328 648 45 62 2038 40 2041 44 648 44 467 58 58 2046 41 59 328 648 45 62 2038 40 2041 44 648 44 467 58 58 2047 41 59 125 125 125 41 59 125 437 492 2048 40 2049 2050 41 123 2051 40 2050 44 648 44 2052 45 62 123 490 2053 61 2052 46 2054 40 41 59 490 2055 61 2056 40 2053 44 2007 46 334 44 648 41 59 490 2057 61 2056 40 2053 44 2008 46 334 44 648 41 59 2011 46 2058 40 2055 41 46 2059 40 2057 44 2060 40 2052 41 41 59 125 41 59 125 437 2009 60 2010 62 2061 40 2049 2062 41 123 381 2009 60 2010 62 2063 61 418 2064 60 62 40 41 59 2065 40 2062 44 648 44 2066 45 62 123 490 2067 61 2066 46 2068 40 41 59 490 2069 61 2070 40 2067 44 648 41 59 490 2071 61 2072 40 2067 44 648 41 59 490 2073 61 2074 40 2067 44 648 41 59 2063 46 2075 40 418 2010 40 2069 44 2073 44 2071 41 41 59 125 41 59 450 2063 59 125 437 492 2076 40 2049 2050 41 123 2077 40 2050 44 648 44 2078 45 62 123 381 404 2079 61 2080 40 2078 46 2081 40 41 44 648 41 59 2015 46 2082 40 2079 44 418 2014 40 2061 40 2078 41 41 41 59 125 41 59 125 437 2009 60 2010 62 2083 40 2084 2085 44 2009 60 2010 62 2086 41 123 392 40 2087 40 2086 41 41 123 450 424 59 125 381 2009 60 2010 62 2088 61 418 2089 60 62 40 41 59 385 40 2010 2090 58 2086 41 123 384 2091 61 2090 46 2092 40 41 42 2085 46 2093 40 41 59 413 2094 61 2090 46 2095 40 41 59 392 40 2091 62 1503 41 123 356 2096 61 2097 46 2098 40 2091 47 1503 41 59 2091 609 2096 59 2094 61 40 413 41 40 2094 42 2096 41 59 125 2088 46 2099 40 418 2010 40 2090 46 2100 40 41 44 2091 44 2094 41 41 59 125 450 2088 59 125 437 492 2101 40 41 123 381 404 2102 61 2015 46 2103 40 41 59 392 40 2011 46 2104 40 41 46 2105 40 41 46 2106 40 2107 45 62 2107 46 2104 40 41 46 2105 40 41 41 46 2108 40 2109 46 422 40 2009 58 58 2110 41 41 41 123 385 40 2084 2085 58 2111 46 2112 40 41 46 2113 40 41 41 123 621 392 40 40 2114 40 2085 41 606 2115 40 2085 41 41 605 2085 46 2116 40 41 605 33 2015 46 2117 40 2085 46 2118 40 41 41 41 123 381 2009 60 2010 62 2119 61 2011 46 2120 40 2085 46 2121 40 41 41 46 2120 40 2114 40 2085 41 63 2008 46 2122 58 2008 46 2123 41 59 392 40 2124 40 2119 41 41 123 2015 46 2125 40 2085 46 2118 40 41 44 418 2014 40 2083 40 2085 44 2119 41 41 41 59 125 125 125 125 2003 46 2126 40 41 46 2127 40 40 41 45 62 2015 46 2103 40 41 45 2102 41 46 2128 40 648 41 59 125 618 437 2014 2129 40 404 2130 41 123 450 2015 46 2131 40 2130 41 59 125 618 439 2009 60 2010 62 2132 40 2133 2085 41 123 381 2009 60 2010 62 2134 61 418 2135 60 62 40 41 59 490 2136 61 2129 40 2085 46 2137 40 41 41 59 392 40 2138 40 2136 41 41 123 621 392 40 2136 46 2139 40 41 46 2140 40 41 46 2141 40 2142 45 62 2142 46 2137 40 41 614 2085 46 2143 40 41 46 2144 40 41 41 41 123 2134 46 2145 40 418 2010 40 2085 46 2143 40 41 46 2144 40 41 44 1503 44 2085 46 2146 40 41 41 41 59 125 2134 46 2147 40 2136 46 2139 40 41 41 59 125 360 123 621 2134 46 2148 40 418 2010 40 2085 46 2149 40 41 46 2150 40 41 44 1503 44 2085 46 2151 40 41 41 41 59 125 450 2134 59 125 439 457 492 2152 40 41 123 2153 40 41 46 2023 40 41 59 125 439 457 2000 2154 40 41 123 450 2155 46 2156 59 125 437 457 334 2157 123 437 457 381 2000 2158 61 418 2000 40 41 59 125 125 
27350,Java,"public final class InitialEquipmentData extends GameXmlReader {
    private static final Logger LOGGER = LoggerFactory.getLogger(InitialEquipmentData.class);
    private static final String NORMAL = ""data/stats/initialEquipment.xml"";
    private static final String EVENT = ""data/stats/initialEquipmentEvent.xml"";
    private final Map<ClassId, List<PcItemTemplate>> _initialEquipmentList = new EnumMap<>(ClassId.class);

    private InitialEquipmentData() {
        load();
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/initialEquipment.xsd"");
    }

    @Override
    public void load() {
        _initialEquipmentList.clear();
        parseDatapackFile(CharacterSettings.initialEquipEvent()  ? EVENT : NORMAL);
        LOGGER.info(""Loaded {} Initial Equipment data."", _initialEquipmentList.size());
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        for (Node n = doc.getFirstChild(); n != null; n = n.getNextSibling()) {
            if (""list"".equalsIgnoreCase(n.getNodeName())) {
                for (Node d = n.getFirstChild(); d != null; d = d.getNextSibling()) {
                    if (""equipment"".equalsIgnoreCase(d.getNodeName())) {
                        parseEquipment(d);
                    }
                }
            }
        }
    }

    /**
     * Parses the equipment.
     *
     * @param d parse an initial equipment and add it to {@link #_initialEquipmentList}
     */
    private void parseEquipment(Node d) {
        NamedNodeMap attrs = d.getAttributes();
        final ClassId classId = ClassId.getClassId(Integer.parseInt(attrs.getNamedItem(""classId"").getNodeValue()));
        final List<PcItemTemplate> equipList = new ArrayList<>();
        for (Node c = d.getFirstChild(); c != null; c = c.getNextSibling()) {
            if (""item"".equalsIgnoreCase(c.getNodeName())) {
                final StatsSet set = new StatsSet();
                attrs = c.getAttributes();
                for (int i = 0; i < attrs.getLength(); i++) {
                    final Node attr = attrs.item(i);
                    set.set(attr.getNodeName(), attr.getNodeValue());
                }
                equipList.add(new PcItemTemplate(set));
            }
        }
        _initialEquipmentList.put(classId, equipList);
    }

    /**
     * Gets the equipment list.
     *
     * @param cId the class Id for the required initial equipment.
     * @return the initial equipment for the given class Id.
     */
    public List<PcItemTemplate> getEquipmentList(ClassId cId) {
        return _initialEquipmentList.getOrDefault(cId, Collections.emptyList());
    }

    /**
     * Gets the equipment list.
     *
     * @param cId the class Id for the required initial equipment.
     * @return the initial equipment for the given class Id.
     */
    public List<PcItemTemplate> getEquipmentList(int cId) {
        return getEquipmentList(ClassId.getClassId(cId));
    }

    public static InitialEquipmentData getInstance() {
        return Singleton.INSTANCE;
    }
    private static class Singleton {
        protected static final InitialEquipmentData INSTANCE = new InitialEquipmentData();
    }
}",0,439 381 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 457 381 2006 2007 61 648 59 437 457 381 2006 2008 61 648 59 437 381 2009 60 2010 44 2011 60 2012 641 2013 61 418 2014 60 62 40 2010 46 334 41 59 437 2000 40 41 123 2015 40 41 59 125 64 2016 438 2017 2018 40 41 123 450 2019 46 2020 40 41 46 2021 40 648 41 59 125 64 2016 439 492 2022 40 41 123 2013 46 2023 40 41 59 2024 40 2025 46 2026 40 41 63 2008 58 2007 41 59 2003 46 2027 40 648 44 2013 46 2028 40 41 41 59 2029 40 41 59 125 64 2016 439 492 2030 40 2031 2032 44 2033 2034 41 123 385 40 2035 2036 61 2032 46 2037 40 41 59 2036 631 424 59 2036 61 2036 46 2038 40 41 41 123 392 40 648 46 2039 40 2036 46 2040 40 41 41 41 123 385 40 2035 2041 61 2036 46 2037 40 41 59 2041 631 424 59 2041 61 2041 46 2038 40 41 41 123 392 40 648 46 2039 40 2041 46 2040 40 41 41 41 123 2042 40 2041 41 59 125 125 125 125 125 618 437 492 2043 40 2044 2045 41 123 2046 2047 61 2045 46 2048 40 41 59 381 2010 2049 61 2010 46 2050 40 2051 46 2052 40 2047 46 2053 40 648 41 46 2054 40 41 41 41 59 381 2011 60 2012 62 2055 61 418 2056 60 62 40 41 59 385 40 2044 2057 61 2045 46 2058 40 41 59 2057 631 424 59 2057 61 2057 46 2059 40 41 41 123 392 40 648 46 2060 40 2057 46 2061 40 41 41 41 123 381 2062 2063 61 418 2062 40 41 59 2047 61 2057 46 2048 40 41 59 385 40 404 2064 61 1500 59 2064 60 2047 46 2065 40 41 59 2064 637 41 123 381 2044 2066 61 2047 46 2067 40 2064 41 59 2063 46 2063 40 2066 46 2061 40 41 44 2066 46 2054 40 41 41 59 125 2055 46 2068 40 418 2012 40 2063 41 41 59 125 125 2013 46 2069 40 2049 44 2055 41 59 125 618 439 2011 60 2012 62 2070 40 2010 2071 41 123 450 2013 46 2072 40 2071 44 2073 46 2074 40 41 41 59 125 618 439 2011 60 2012 62 2070 40 404 2071 41 123 450 2070 40 2010 46 2075 40 2071 41 41 59 125 439 457 2000 2076 40 41 123 450 2077 46 2078 59 125 437 457 334 2079 123 438 457 381 2000 2080 61 418 2000 40 41 59 125 125 
27754,Java,"public class LuckyGameData extends GameXmlReader {

    private static final Logger LOGGER = LoggerFactory.getLogger(LuckyGameData.class);

    private final Map<Integer, LuckyGameDataHolder> _luckyGame = new HashMap<>();
    private final AtomicInteger _serverPlay = new AtomicInteger();

    private LuckyGameData() {
        load();
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/LuckyGameData.xsd"");
    }

    @Override
    public void load() {
        _luckyGame.clear();
        parseDatapackFile(""data/LuckyGameData.xml"");
        LOGGER.info(""Loaded {} lucky game data."", _luckyGame.size() );
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", listNode -> forEach(listNode, ""luckygame"", rewardNode ->
        {
            final LuckyGameDataHolder holder = new LuckyGameDataHolder();

            forEach(rewardNode, ""common_reward"", commonRewardNode -> forEach(commonRewardNode, ""item"", itemNode ->
            {
                final StatsSet stats = new StatsSet(parseAttributes(itemNode));
                holder.addCommonReward(new ItemChanceHolder(stats.getInt(""id""), stats.getFloat(""chance""), stats.getLong(""count"")));
            }));

            forEach(rewardNode, ""unique_reward"", uniqueRewardNode -> forEach(uniqueRewardNode, ""item"", itemNode ->
            {
                holder.addUniqueReward(new ItemPointHolder(new StatsSet(parseAttributes(itemNode))));
            }));

            forEach(rewardNode, ""modify_reward"", uniqueRewardNode ->
            {
                holder.setMinModifyRewardGame(parseInt(uniqueRewardNode.getAttributes(), ""min_game""));
                holder.setMaxModifyRewardGame(parseInt(uniqueRewardNode.getAttributes(), ""max_game""));
                forEach(uniqueRewardNode, ""item"", itemNode ->
                {
                    final StatsSet stats = new StatsSet(parseAttributes(itemNode));
                    holder.addModifyReward(new ItemChanceHolder(stats.getInt(""id""), stats.getFloat(""chance""), stats.getLong(""count"")));
                });
            });

            _luckyGame.put(parseInt(rewardNode.getAttributes(), ""index""), holder);
        }));
    }

    public LuckyGameDataHolder getLuckyGameDataByIndex(int index) {
        return _luckyGame.get(index);
    }

    public int increaseGame() {
        return _serverPlay.incrementAndGet();
    }

    public static LuckyGameData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {

        protected static final LuckyGameData INSTANCE = new LuckyGameData();
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 44 2008 62 2009 61 418 2010 60 62 40 41 59 437 381 2011 2012 61 418 2011 40 41 59 437 2000 40 41 123 2013 40 41 59 125 64 2014 438 2015 2016 40 41 123 450 2017 46 2018 40 41 46 2019 40 648 41 59 125 64 2014 439 492 2020 40 41 123 2009 46 2021 40 41 59 2022 40 648 41 59 2003 46 2023 40 648 44 2009 46 2024 40 41 41 59 2025 40 41 59 125 64 2014 439 492 2026 40 2027 2028 44 2029 2030 41 123 2031 40 2028 44 648 44 2032 45 62 2031 40 2032 44 648 44 2033 45 62 123 381 2008 2034 61 418 2008 40 41 59 2031 40 2033 44 648 44 2035 45 62 2031 40 2035 44 648 44 2036 45 62 123 381 2037 2038 61 418 2037 40 2039 40 2036 41 41 59 2034 46 2040 40 418 2041 40 2038 46 2042 40 648 41 44 2038 46 2043 40 648 41 44 2038 46 2044 40 648 41 41 41 59 125 41 41 59 2031 40 2033 44 648 44 2045 45 62 2031 40 2045 44 648 44 2036 45 62 123 2034 46 2046 40 418 2047 40 418 2048 40 2049 40 2036 41 41 41 41 59 125 41 41 59 2031 40 2033 44 648 44 2045 45 62 123 2034 46 2050 40 2051 40 2045 46 2052 40 41 44 648 41 41 59 2034 46 2053 40 2051 40 2045 46 2052 40 41 44 648 41 41 59 2031 40 2045 44 648 44 2036 45 62 123 381 2054 2055 61 418 2054 40 2056 40 2036 41 41 59 2034 46 2057 40 418 2058 40 2055 46 2059 40 648 41 44 2055 46 2060 40 648 41 44 2055 46 2061 40 648 41 41 41 59 125 41 59 125 41 59 2009 46 2062 40 2063 40 2033 46 2064 40 41 44 648 41 44 2034 41 59 125 41 41 59 125 439 2008 2065 40 404 2066 41 123 450 2009 46 2067 40 2066 41 59 125 439 404 2068 40 41 123 450 2012 46 2069 40 41 59 125 439 457 2000 2070 40 41 123 450 2071 46 2072 59 125 437 457 334 2073 123 438 457 381 2000 2074 61 418 2000 40 41 59 125 125 
27605,Java,"public class PlayerInGame extends GameserverReadablePacket {
    private List<String> accounts;

    @Override
    protected void readImpl() {
        int size = readShort();
        accounts = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            accounts.add(readString());
        }
    }

    @Override
    protected void runImpl()  {
        client.getGameServerInfo().addAccounts(accounts);
        for (String account : accounts) {
            AuthController.getInstance().removeAuthedClient(account);
        }
    }
}",0,439 334 2000 378 2001 123 437 2002 60 2003 62 2004 59 64 2005 438 492 2006 40 41 123 404 2007 61 2008 40 41 59 2004 61 418 2009 60 62 40 2007 41 59 385 40 404 2010 61 1500 59 2010 60 2007 59 2010 637 41 123 2004 46 2011 40 2012 40 41 41 59 125 125 64 2005 438 492 2013 40 41 123 2014 46 2015 40 41 46 2016 40 2004 41 59 385 40 2003 2017 58 2004 41 123 2018 46 2019 40 41 46 2020 40 2017 41 59 125 125 125 
27463,Java,"public class KarmaData extends GameXmlReader {
    private static final Logger LOGGER = LoggerFactory.getLogger(KarmaData.class);

    private final Map<Integer, Double> _karmaTable = new HashMap<>();

    private KarmaData() {
        load();
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/pcKarmaIncrease.xsd"");
    }

    @Override
    public synchronized void load() {
        _karmaTable.clear();
        parseDatapackFile(""data/stats/chars/pcKarmaIncrease.xml"");
        LOGGER.info(""Loaded {} karma modifiers."", _karmaTable.size());
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        for (Node n = doc.getFirstChild(); n != null; n = n.getNextSibling()) {
            if (""pcKarmaIncrease"".equalsIgnoreCase(n.getNodeName())) {
                for (Node d = n.getFirstChild(); d != null; d = d.getNextSibling()) {
                    if (""increase"".equalsIgnoreCase(d.getNodeName())) {
                        final NamedNodeMap attrs = d.getAttributes();
                        final int level = parseInt(attrs, ""lvl"");
                        _karmaTable.put(level, parseDouble(attrs, ""val""));
                    }
                }
            }
        }
    }

    /**
     * @param level
     * @return {@code double} modifier used to calculate karma lost upon death.
     */
    public double getMultiplier(int level) {
        return _karmaTable.get(level);
    }

    public static KarmaData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final KarmaData INSTANCE = new KarmaData();
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 44 2008 62 2009 61 418 2010 60 62 40 41 59 437 2000 40 41 123 2011 40 41 59 125 64 2012 438 2013 2014 40 41 123 450 2015 46 2016 40 41 46 2017 40 648 41 59 125 64 2012 439 465 492 2018 40 41 123 2009 46 2019 40 41 59 2020 40 648 41 59 2003 46 2021 40 648 44 2009 46 2022 40 41 41 59 2023 40 41 59 125 64 2012 439 492 2024 40 2025 2026 44 2027 2028 41 123 385 40 2029 2030 61 2026 46 2031 40 41 59 2030 631 424 59 2030 61 2030 46 2032 40 41 41 123 392 40 648 46 2033 40 2030 46 2034 40 41 41 41 123 385 40 2029 2035 61 2030 46 2031 40 41 59 2035 631 424 59 2035 61 2035 46 2032 40 41 41 123 392 40 648 46 2033 40 2035 46 2034 40 41 41 41 123 381 2036 2037 61 2035 46 2038 40 41 59 381 404 2039 61 2040 40 2037 44 648 41 59 2009 46 2041 40 2039 44 2042 40 2037 44 648 41 41 59 125 125 125 125 125 618 439 356 2043 40 404 2044 41 123 450 2009 46 2045 40 2044 41 59 125 439 457 2000 2046 40 41 123 450 2047 46 2048 59 125 437 457 334 2049 123 437 457 381 2000 2050 61 418 2000 40 41 59 125 125 
29252,Java,"    private class PurgeThread implements Runnable{
        @Override
        public void run() {
            synchronized (authedClients) {
                var entries = authedClients.entrySet().iterator();
                while (entries.hasNext()) {
                    var entry = entries.next();
                    var client = entry.getValue();

                    if(!client.isJoinedGameSever() && client.getConnectionStartTime() + TimeUnit.MINUTES.toMillis(LOGIN_TIMEOUT) <= currentTimeMillis() || !client.isConnected()) {
                        client.close(REASON_ACCESS_FAILED_TRYA1);
                        entries.remove();
                    }
                }

                if(authedClients.isEmpty()) {
                    scheduledPurge.cancel(false);
                }
            }
        }
    }",0,437 334 2000 395 2001 123 64 2002 439 492 2003 40 41 123 465 40 2004 41 123 490 2005 61 2004 46 2006 40 41 46 2007 40 41 59 496 40 2005 46 2008 40 41 41 123 490 2009 61 2005 46 2010 40 41 59 490 2011 61 2009 46 2012 40 41 59 392 40 33 2011 46 2013 40 41 605 2011 46 2014 40 41 43 2015 46 2016 46 2017 40 2018 41 620 2019 40 41 606 33 2011 46 2020 40 41 41 123 2011 46 2021 40 2022 41 59 2005 46 2023 40 41 59 125 125 392 40 2004 46 2024 40 41 41 123 2025 46 2026 40 380 41 59 125 125 125 125 
26401,Java,"public final class BuyListData extends GameXmlReader {
    private static final Logger LOGGER = LoggerFactory.getLogger(BuyListData.class);

    private final IntMap<ProductList> buyLists = new HashIntMap<>();

    private BuyListData() {
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/buylist.xsd"");
    }

    @Override
    public synchronized void load() {
        buyLists.clear();
        parseDatapackDirectory(""data/buylists"", false);
        if (GeneralSettings.loadCustomBuyList()) {
            parseDatapackDirectory(""data/buylists/custom"", false);
        }
        releaseResources();

        LOGGER.info(""Loaded {} BuyLists."", buyLists.size());

        getDAO(BuyListDAO.class).findAll().forEach(info -> {
            final var list = getBuyList(info.getId());
            if(isNull(list)) {
                LOGGER.warn(""BuyList found in database but not loaded from xml! BuyListId: {}"", info.getId());
                return;
            }

            final Product product = list.getProductByItemId(info.getItemId());
            if (isNull(product)) {
                LOGGER.warn(""ItemId found in database but not loaded from xml! BuyListId: {} item id {}"", info.getId(), info.getItemId());
                return;
            }

            product.updateInfo(info);
        });
    }

    @Override
    public void parseDocument(Document doc, File f) {
        try {
            final int buyListId = Integer.parseInt(f.getName().replaceAll("".xml"", """"));
            forEach(doc, ""list"", (list) ->
            {
                final int defaultBaseTax = parseInt(list.getAttributes(), ""baseTax"", 0);
                final ProductList buyList = new ProductList(buyListId);
                forEach(list, (node) ->
                {
                    switch (node.getNodeName()) {
                        case ""item"": {
                            final NamedNodeMap attrs = node.getAttributes();

                            final int itemId = parseInt(attrs, ""id"");
                            final ItemTemplate item = ItemEngine.getInstance().getTemplate(itemId);
                            if (item != null) {
                                final long price = parseLong(attrs, ""price"", -1L);
                                final long restockDelay = parseLong(attrs, ""restock_delay"", -1L);
                                final long count = parseLong(attrs, ""count"", -1L);
                                final int baseTax = parseInt(attrs, ""baseTax"", defaultBaseTax);

                                buyList.addProduct(new Product(buyListId, item, price, restockDelay, count, baseTax));
                            } else {
                                LOGGER.warn(""Item not found. BuyList:"" + buyListId + "" ItemID:"" + itemId + "" File:"" + f);
                            }
                            break;
                        }
                        case ""npcs"": {
                            forEach(node, ""npc"", (npcNode) -> buyList.addAllowedNpc(Integer.parseInt(npcNode.getTextContent())));
                            break;
                        }
                    }
                });
                buyLists.put(buyListId, buyList);
            });
        } catch (Exception e) {
            LOGGER.warn(""Failed to load buyList data from xml File:"" + f.getName(), e);
        }
    }

    public ProductList getBuyList(int listId) {
        return buyLists.get(listId);
    }

    public static void init() {
        getInstance().load();
    }

    public static BuyListData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final BuyListData INSTANCE = new BuyListData();
    }
}",0,439 381 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 62 2008 61 418 2009 60 62 40 41 59 437 2000 40 41 123 125 64 2010 438 2011 2012 40 41 123 450 2013 46 2014 40 41 46 2015 40 648 41 59 125 64 2010 439 465 492 2016 40 41 123 2008 46 2017 40 41 59 2018 40 648 44 380 41 59 392 40 2019 46 2020 40 41 41 123 2018 40 648 44 380 41 59 125 2021 40 41 59 2003 46 2022 40 648 44 2008 46 2023 40 41 41 59 2024 40 2025 46 334 41 46 2026 40 41 46 2027 40 2022 45 62 123 381 490 411 61 2028 40 2022 46 2029 40 41 41 59 392 40 2030 40 411 41 41 123 2003 46 2031 40 648 44 2022 46 2029 40 41 41 59 450 59 125 381 2032 2033 61 411 46 2034 40 2022 46 2035 40 41 41 59 392 40 2030 40 2033 41 41 123 2003 46 2036 40 648 44 2022 46 2029 40 41 44 2022 46 2035 40 41 41 59 450 59 125 2033 46 2037 40 2022 41 59 125 41 59 125 64 2010 439 492 2038 40 2039 2040 44 2041 2042 41 123 474 123 381 404 2043 61 2044 46 2045 40 2042 46 2046 40 41 46 2047 40 648 44 648 41 41 59 2048 40 2040 44 648 44 40 411 41 45 62 123 381 404 2049 61 2045 40 411 46 2050 40 41 44 648 44 1500 41 59 381 2007 2051 61 418 2007 40 2043 41 59 2048 40 411 44 40 2052 41 45 62 123 464 40 2052 46 2053 40 41 41 123 328 648 58 123 381 2054 2055 61 2052 46 2050 40 41 59 381 404 2056 61 2045 40 2055 44 648 41 59 381 2057 2058 61 2059 46 2060 40 41 46 2061 40 2056 41 59 392 40 2058 631 424 41 123 381 413 2062 61 2063 40 2055 44 648 44 45 1501 41 59 381 413 2064 61 2063 40 2055 44 648 44 45 1501 41 59 381 413 2065 61 2063 40 2055 44 648 44 45 1501 41 59 381 404 2066 61 2045 40 2055 44 648 44 2049 41 59 2051 46 2067 40 418 2068 40 2043 44 2058 44 2062 44 2064 44 2065 44 2066 41 41 59 125 360 123 2003 46 2069 40 648 43 2043 43 648 43 2056 43 648 43 2042 41 59 125 325 59 125 328 648 58 123 2048 40 2052 44 648 44 40 2070 41 45 62 2051 46 2071 40 2044 46 2045 40 2070 46 2072 40 41 41 41 41 59 325 59 125 125 125 41 59 2008 46 2073 40 2043 44 2051 41 59 125 41 59 125 329 40 2074 2075 41 123 2003 46 2076 40 648 43 2042 46 2077 40 41 44 2075 41 59 125 125 439 2007 2078 40 404 2079 41 123 450 2008 46 2080 40 2079 41 59 125 439 457 492 2081 40 41 123 2082 40 41 46 2016 40 41 59 125 439 457 2000 2083 40 41 123 450 2084 46 2085 59 125 437 457 334 2086 123 437 457 381 2000 2087 61 418 2000 40 41 59 125 125 
28407,Java,"        new GameXmlReader() {
            @Override
            protected Path getSchemaFilePath() {
                return ServerSettings.dataPackDirectory().resolve(""data/xsd/statBonus.xsd"");
            }

            @Override
            public void load() {
                parseDatapackFile(""data/stats/statBonus.xml"");
            }

            @Override
            public void parseDocument(Document doc, File f) {
                forEach(doc, ""list"", listNode -> forEach(listNode, ""stat"", statNode -> {
                    final var baseStat = parseEnum(statNode.getAttributes(), BaseStats.class, ""type"");
                    for(var node = statNode.getFirstChild(); nonNull(node); node = node.getNextSibling()){
                        switch (node.getNodeName()) {
                            case ""enhancement"" -> parseStatEnhancement(baseStat, node);
                            case ""bonus"" -> parseStatBonus(baseStat, node);
                        }
                    }
                }));
            }

            private void parseStatBonus(BaseStats baseStat, Node bonusNode) {
                forEach(bonusNode, ""value"", statValue -> {
                    final int index = parseInt(statValue.getAttributes(), ""level"");
                    final double bonus = Double.parseDouble(statValue.getTextContent());
                    baseStat.setValue(index, bonus);
                });
            }

            private void parseStatEnhancement(BaseStats baseStat, Node node) {
                final var attr = node.getAttributes();
                baseStat.enhancementSkillId = parseInt(attr, ""skill-id"");
                baseStat.enhancementFirstLevel = parseInt(attr, ""first-level"");
                baseStat.enhancementSecondLevel = parseInt(attr, ""second-level"");
                baseStat.enhancementThirdLevel = parseInt(attr, ""third-level"");
            }
        }.load();",0,418 2000 40 41 123 64 2001 438 2002 2003 40 41 123 450 2004 46 2005 40 41 46 2006 40 648 41 59 125 64 2001 439 492 2007 40 41 123 2008 40 648 41 59 125 64 2001 439 492 2009 40 2010 2011 44 2012 2013 41 123 2014 40 2011 44 648 44 2015 45 62 2014 40 2015 44 648 44 2016 45 62 123 381 490 2017 61 2018 40 2016 46 2019 40 41 44 2020 46 334 44 648 41 59 385 40 490 2021 61 2016 46 2022 40 41 59 2023 40 2021 41 59 2021 61 2021 46 2024 40 41 41 123 464 40 2021 46 2025 40 41 41 123 328 648 45 62 2026 40 2017 44 2021 41 59 328 648 45 62 2027 40 2017 44 2021 41 59 125 125 125 41 41 59 125 437 492 2028 40 2029 2030 44 2031 2032 41 123 2033 40 2032 44 648 44 2034 45 62 123 381 404 2035 61 2036 40 2034 46 2037 40 41 44 648 41 59 381 356 2038 61 2039 46 2040 40 2034 46 2041 40 41 41 59 2030 46 2042 40 2035 44 2038 41 59 125 41 59 125 437 492 2043 40 2029 2030 44 2031 2044 41 123 381 490 2045 61 2044 46 2046 40 41 59 2030 46 2047 61 2048 40 2045 44 648 41 59 2030 46 2049 61 2048 40 2045 44 648 41 59 2030 46 2050 61 2048 40 2045 44 648 41 59 2030 46 2051 61 2048 40 2045 44 648 41 59 125 125 46 2052 40 41 59 
28507,Java,"public class LongTimeEvent extends Quest {

    private static final Logger LOGGER = LoggerFactory.getLogger(LongTimeEvent.class);

    private final List<NpcSpawn> spawnList = new ArrayList<>();
    private final List<EventDropHolder> dropList = new LinkedList<>();
    private final IntSet itemsToDestroy = new HashIntSet();
    private String name;
    private String startMessage;
    private String endMessage;
    private int enterAnnounceId = -1;
    private DateRange period = DateRange.STARTED_DAY;

    protected LongTimeEvent() {
        super(-1);
        var parser = new EventParser();
        parser.load();

        final var today = LocalDateTime.now();
        if (period.isWithinRange(today)) {
            startEvent();
        } else if (period.isAfter(today)) {
            ThreadPool.schedule(this::startEvent, period.secondsToStart(today), TimeUnit.SECONDS);
            LOGGER.info(""Event {} will be started at {}"", name, period.getStartDate());
        } else {
            destroyItemsOnEnd();
            LOGGER.info(""Event {} has passed... Ignored "",  name);
        }
    }

    protected void startEvent() {
        LOGGER.info(""Event {} active until {}"", name, period.getEndDate());
        dropList.forEach(drop -> EventDropList.getInstance().addGlobalDrop(drop, period));

        final var eventEnd = period.millisToEnd();

        spawnList.forEach(spawn -> AbstractScript.addSpawn(spawn.npcId, spawn.loc.getX(), spawn.loc.getY(), spawn.loc.getZ(), spawn.loc.getHeading(), false, eventEnd, false));

        if(isNotEmpty(startMessage)) {
            Broadcast.toAllOnlinePlayers(startMessage);
            var announce = new EventAnnouncement(period, startMessage);
            AnnouncementsManager.getInstance().addAnnouncement(announce);
            enterAnnounceId = announce.getId();
        }
        ThreadPool.schedule(new ScheduleEnd(), eventEnd);
    }

    private void destroyItemsOnEnd() {
        itemsToDestroy.forEach(itemId -> {
            World.getInstance().forEachPlayer(player -> player.destroyItemByItemId(name, itemId, -1, player, true));
            getDAO(ItemDAO.class).deleteAllItemsById(itemId);
        });
    }

    public boolean isEventPeriod() {
        return period.isWithinRange(LocalDateTime.now());
    }

    protected String getConfigPath() {
        return ""data/extension/"" + getPath() + ""/config.xml"";
    }

    @Override
    public String getHtml(Player player, String fileName) {
        if(!fileName.startsWith(""data/"")) {
            fileName = ""./"" + fileName;
        }
        return super.getHtml(player, fileName);
    }

    private class EventParser extends GameXmlReader {

        @Override
        protected Path getSchemaFilePath() {
            return ServerSettings.dataPackDirectory().resolve(""data/xsd/eventConfig.xsd"");
        }

        @Override
        public void load() {
            parseDatapackFile(getConfigPath());
            releaseResources();
        }

        @Override
        public void parseDocument(Document doc, File f) {
            forEach(doc, ""event"", eventNode -> {
                var attrs = eventNode.getAttributes();
                name = parseString(attrs, ""name"");
                period = DateRange.parse(parseString(attrs, ""start-date""), parseString(attrs, ""end-date""));
                startMessage = parseString(attrs, ""start-message"");
                endMessage = parseString(attrs, ""end-message"");

                final var today = LocalDateTime.now();

                if(period.isWithinRange(today)) {
                    for(var node = eventNode.getFirstChild(); nonNull(node); node = node.getNextSibling()) {
                        switch (node.getNodeName()) {
                            case ""drop"" -> parseDrop(node);
                            case ""spawns"" -> parseSpawns(node);
                        }
                    }
                }

                forEach(eventNode, ""destroy-items-on-end"",
                        destroyNode -> itemsToDestroy.addAll(parseIntSet(destroyNode)));

            });
        }

        private void parseSpawns(Node node) {
            forEach(node, ""spawn"", spawnNode -> {
               final var npcId = parseInt(spawnNode.getAttributes(), ""npc"");

               if(!NpcData.getInstance().existsNpc(npcId)) {
                   LOGGER.warn(""{} event: Npc Id {} not found"", getScriptName(), npcId);
                   return;
               }
               spawnList.add(new NpcSpawn(npcId, parseLocation(spawnNode)));
            });
        }

        private void parseDrop(Node node) {
            forEach(node, ""item"", itemNode -> {
                final var attrs  = itemNode.getAttributes();
                final var id = parseInt(attrs, ""id"");
                final var min = parseInt(attrs, ""min"");
                final var max = parseInt(attrs, ""max"");
                final var chance = parseDouble(attrs, ""chance"");
                final var minLevel = parseInt(attrs, ""min-level"");
                final var maxLevel = parseInt(attrs, ""max-level"");
                final var monsters = parseIntSet(attrs, ""monsters"");

                dropList.add(new EventDropHolder(id, min, max, chance, minLevel, maxLevel, monsters));
            });
        }
    }

    protected static class NpcSpawn {
        protected final Location loc;
        protected final int npcId;

        protected NpcSpawn(int pNpcId, Location spawnLoc) {
            loc = spawnLoc;
            npcId = pNpcId;
        }
    }

    protected class ScheduleEnd implements Runnable {
        @Override
        public void run() {

            destroyItemsOnEnd();

            if(isNotEmpty(endMessage)) {
                Broadcast.toAllOnlinePlayers(endMessage);
            }

            if(enterAnnounceId != -1) {
                AnnouncementsManager.getInstance().deleteAnnouncement(enterAnnounceId);
            }
        }
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 62 2008 61 418 2009 60 62 40 41 59 437 381 2006 60 2010 62 2011 61 418 2012 60 62 40 41 59 437 381 2013 2014 61 418 2015 40 41 59 437 2016 2017 59 437 2016 2018 59 437 2016 2019 59 437 404 2020 61 45 1501 59 437 2021 2022 61 2021 46 2023 59 438 2000 40 41 123 463 40 45 1501 41 59 490 2024 61 418 2025 40 41 59 2024 46 2026 40 41 59 381 490 2027 61 2028 46 2029 40 41 59 392 40 2022 46 2030 40 2027 41 41 123 2031 40 41 59 125 360 392 40 2022 46 2032 40 2027 41 41 123 2033 46 2034 40 467 58 58 2035 44 2022 46 2036 40 2027 41 44 2037 46 2038 41 59 2003 46 2039 40 648 44 2017 44 2022 46 2040 40 41 41 59 125 360 123 2041 40 41 59 2003 46 2042 40 648 44 2017 41 59 125 125 438 492 2043 40 41 123 2003 46 2044 40 648 44 2017 44 2022 46 2045 40 41 41 59 2011 46 2046 40 2047 45 62 2048 46 2049 40 41 46 2050 40 2047 44 2022 41 41 59 381 490 2051 61 2022 46 2052 40 41 59 2008 46 2046 40 2053 45 62 2054 46 2055 40 2053 46 2056 44 2053 46 2057 46 2058 40 41 44 2053 46 2057 46 2059 40 41 44 2053 46 2057 46 2060 40 41 44 2053 46 2057 46 2061 40 41 44 380 44 2051 44 380 41 41 59 392 40 2062 40 2018 41 41 123 2063 46 2064 40 2018 41 59 490 2065 61 418 2066 40 2022 44 2018 41 59 2067 46 2049 40 41 46 2068 40 2065 41 59 2020 61 2065 46 2069 40 41 59 125 2070 46 2071 40 418 2072 40 41 44 2051 41 59 125 437 492 2073 40 41 123 2014 46 2074 40 2075 45 62 123 2076 46 2077 40 41 46 2078 40 2079 45 62 2079 46 2080 40 2017 44 2075 44 45 1501 44 2079 44 473 41 41 59 2081 40 2082 46 334 41 46 2083 40 2075 41 59 125 41 59 125 439 324 2084 40 41 123 450 2022 46 2085 40 2086 46 2087 40 41 41 59 125 438 2016 2088 40 41 123 450 648 43 2089 40 41 43 648 59 125 64 2090 439 2016 2091 40 2092 2093 44 2016 2094 41 123 392 40 33 2094 46 2095 40 648 41 41 123 2094 61 648 43 2094 59 125 450 463 46 2091 40 2093 44 2094 41 59 125 437 334 2096 378 2097 123 64 2090 438 2098 2099 40 41 123 450 2100 46 2101 40 41 46 2102 40 648 41 59 125 64 2090 439 492 2103 40 41 123 2104 40 2088 40 41 41 59 2105 40 41 59 125 64 2090 439 492 2106 40 2107 2108 44 2109 2110 41 123 2111 40 2108 44 648 44 2112 45 62 123 490 2113 61 2112 46 2114 40 41 59 2017 61 2115 40 2113 44 648 41 59 2022 61 2021 46 2116 40 2115 40 2113 44 648 41 44 2115 40 2113 44 648 41 41 59 2018 61 2115 40 2113 44 648 41 59 2019 61 2115 40 2113 44 648 41 59 381 490 2117 61 2118 46 2119 40 41 59 392 40 2022 46 2120 40 2117 41 41 123 385 40 490 2121 61 2112 46 2122 40 41 59 2123 40 2121 41 59 2121 61 2121 46 2124 40 41 41 123 464 40 2121 46 2125 40 41 41 123 328 648 45 62 2126 40 2121 41 59 328 648 45 62 2127 40 2121 41 59 125 125 125 2111 40 2112 44 648 44 2128 45 62 2014 46 2129 40 2130 40 2128 41 41 41 59 125 41 59 125 437 492 2131 40 2132 2133 41 123 2134 40 2133 44 648 44 2135 45 62 123 381 490 2136 61 2137 40 2135 46 2138 40 41 44 648 41 59 392 40 33 2139 46 2140 40 41 46 2141 40 2136 41 41 123 2003 46 2142 40 648 44 2143 40 41 44 2136 41 59 450 59 125 2008 46 2144 40 418 2007 40 2136 44 2145 40 2135 41 41 41 59 125 41 59 125 437 492 2146 40 2132 2133 41 123 2147 40 2133 44 648 44 2148 45 62 123 381 490 2149 61 2148 46 2150 40 41 59 381 490 2151 61 2152 40 2149 44 648 41 59 381 490 2153 61 2152 40 2149 44 648 41 59 381 490 2154 61 2152 40 2149 44 648 41 59 381 490 2155 61 2156 40 2149 44 648 41 59 381 490 2157 61 2152 40 2149 44 648 41 59 381 490 2158 61 2152 40 2149 44 648 41 59 381 490 2159 61 2160 40 2149 44 648 41 59 2011 46 2161 40 418 2010 40 2151 44 2153 44 2154 44 2155 44 2157 44 2158 44 2159 41 41 59 125 41 59 125 125 438 457 334 2007 123 438 381 2162 2163 59 438 381 404 2164 59 438 2007 40 404 2165 44 2162 2166 41 123 2163 61 2166 59 2164 61 2165 59 125 125 438 334 2167 395 2168 123 64 2090 439 492 2169 40 41 123 2073 40 41 59 392 40 2170 40 2019 41 41 123 2171 46 2172 40 2019 41 59 125 392 40 2020 631 45 1501 41 123 2173 46 2174 40 41 46 2175 40 2020 41 59 125 125 125 125 
29177,Java,"    private class EventParser extends GameXmlReader {

        @Override
        protected Path getSchemaFilePath() {
            return ServerSettings.dataPackDirectory().resolve(""data/xsd/eventConfig.xsd"");
        }

        @Override
        public void load() {
            parseDatapackFile(getConfigPath());
            releaseResources();
        }

        @Override
        public void parseDocument(Document doc, File f) {
            forEach(doc, ""event"", eventNode -> {
                var attrs = eventNode.getAttributes();
                name = parseString(attrs, ""name"");
                period = DateRange.parse(parseString(attrs, ""start-date""), parseString(attrs, ""end-date""));
                startMessage = parseString(attrs, ""start-message"");
                endMessage = parseString(attrs, ""end-message"");

                final var today = LocalDateTime.now();

                if(period.isWithinRange(today)) {
                    for(var node = eventNode.getFirstChild(); nonNull(node); node = node.getNextSibling()) {
                        switch (node.getNodeName()) {
                            case ""drop"" -> parseDrop(node);
                            case ""spawns"" -> parseSpawns(node);
                        }
                    }
                }

                forEach(eventNode, ""destroy-items-on-end"",
                        destroyNode -> itemsToDestroy.addAll(parseIntSet(destroyNode)));

            });
        }

        private void parseSpawns(Node node) {
            forEach(node, ""spawn"", spawnNode -> {
               final var npcId = parseInt(spawnNode.getAttributes(), ""npc"");

               if(!NpcData.getInstance().existsNpc(npcId)) {
                   LOGGER.warn(""{} event: Npc Id {} not found"", getScriptName(), npcId);
                   return;
               }
               spawnList.add(new NpcSpawn(npcId, parseLocation(spawnNode)));
            });
        }

        private void parseDrop(Node node) {
            forEach(node, ""item"", itemNode -> {
                final var attrs  = itemNode.getAttributes();
                final var id = parseInt(attrs, ""id"");
                final var min = parseInt(attrs, ""min"");
                final var max = parseInt(attrs, ""max"");
                final var chance = parseDouble(attrs, ""chance"");
                final var minLevel = parseInt(attrs, ""min-level"");
                final var maxLevel = parseInt(attrs, ""max-level"");
                final var monsters = parseIntSet(attrs, ""monsters"");

                dropList.add(new EventDropHolder(id, min, max, chance, minLevel, maxLevel, monsters));
            });
        }
    }",0,437 334 2000 378 2001 123 64 2002 438 2003 2004 40 41 123 450 2005 46 2006 40 41 46 2007 40 648 41 59 125 64 2002 439 492 2008 40 41 123 2009 40 2010 40 41 41 59 2011 40 41 59 125 64 2002 439 492 2012 40 2013 2014 44 2015 2016 41 123 2017 40 2014 44 648 44 2018 45 62 123 490 2019 61 2018 46 2020 40 41 59 2021 61 2022 40 2019 44 648 41 59 2023 61 2024 46 2025 40 2022 40 2019 44 648 41 44 2022 40 2019 44 648 41 41 59 2026 61 2022 40 2019 44 648 41 59 2027 61 2022 40 2019 44 648 41 59 381 490 2028 61 2029 46 2030 40 41 59 392 40 2023 46 2031 40 2028 41 41 123 385 40 490 2032 61 2018 46 2033 40 41 59 2034 40 2032 41 59 2032 61 2032 46 2035 40 41 41 123 464 40 2032 46 2036 40 41 41 123 328 648 45 62 2037 40 2032 41 59 328 648 45 62 2038 40 2032 41 59 125 125 125 2017 40 2018 44 648 44 2039 45 62 2040 46 2041 40 2042 40 2039 41 41 41 59 125 41 59 125 437 492 2043 40 2044 2045 41 123 2046 40 2045 44 648 44 2047 45 62 123 381 490 2048 61 2049 40 2047 46 2050 40 41 44 648 41 59 392 40 33 2051 46 2052 40 41 46 2053 40 2048 41 41 123 2054 46 2055 40 648 44 2056 40 41 44 2048 41 59 450 59 125 2057 46 2058 40 418 2059 40 2048 44 2060 40 2047 41 41 41 59 125 41 59 125 437 492 2061 40 2044 2045 41 123 2062 40 2045 44 648 44 2063 45 62 123 381 490 2064 61 2063 46 2065 40 41 59 381 490 2066 61 2067 40 2064 44 648 41 59 381 490 2068 61 2067 40 2064 44 648 41 59 381 490 2069 61 2067 40 2064 44 648 41 59 381 490 2070 61 2071 40 2064 44 648 41 59 381 490 2072 61 2067 40 2064 44 648 41 59 381 490 2073 61 2067 40 2064 44 648 41 59 381 490 2074 61 2075 40 2064 44 648 41 59 2076 46 2077 40 418 2078 40 2066 44 2068 44 2069 44 2070 44 2072 44 2073 44 2074 41 41 59 125 41 59 125 125 
26672,Java,"public class TeleportersData extends GameXmlReader {

    private static final Logger LOGGER = LoggerFactory.getLogger(TeleportersData.class);
    private final IntMap<Map<String, TeleportHolder>> teleporters = new HashIntMap<>();

    private TeleportersData() {
        load();
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/teleporters/teleporterData.xsd"");
    }

    @Override
    public void load() {
        teleporters.clear();
        parseDatapackDirectory(""data/teleporters"", true);
        LOGGER.info(""Loaded: {} npc teleporters."", teleporters.size());
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", list -> forEach(list, ""npc"", npc -> {

            final var teleportList = new HashMap<String, TeleportHolder>();
            final int npcId = parseInt(npc.getAttributes(), ""id"");

            forEach(npc, node -> {
                switch (node.getNodeName()) {
                    case ""teleport"" -> parseTeleport(teleportList, npcId, node);
                    case ""npcs"" -> parseNpcs(teleportList, node);
                }
            });

            registerTeleportList(npcId, teleportList);
        }));
    }

    private void parseNpcs(final HashMap<String, TeleportHolder> teleportList, Node node) {
        forEach(node, ""npc"", npcNode -> registerTeleportList(parseInt(npcNode.getAttributes(), ""id""), teleportList));
    }

    private void parseTeleport(HashMap<String, TeleportHolder> teleportList, int npcId, Node node) {
        final NamedNodeMap nodeAttrs = node.getAttributes();

        final TeleportType type = parseEnum(nodeAttrs, TeleportType.class, ""type"");
        final String name = parseString(nodeAttrs, ""name"", type.name());

        final TeleportHolder holder = new TeleportHolder(name, type);
        forEach(node, ""location"", location -> holder.registerLocation(new StatsSet(parseAttributes(location))));

        if (nonNull(teleportList.putIfAbsent(name, holder))) {
            LOGGER.warn(""Duplicate teleport list ({}) has been found for NPC: {}"", name, npcId);
        }
    }

    /**
     * Register teleport data to global teleport list holder. Also show warning when any duplicate occurs.
     *
     * @param npcId    template id of teleporter
     * @param teleList teleport data to register
     */
    private void registerTeleportList(int npcId, Map<String, TeleportHolder> teleList) {
        teleporters.put(npcId, teleList);
    }

    /**
     * Gets teleport data for specified NPC and list name
     *
     * @param npcId    template id of teleporter
     * @param listName name of teleport list
     * @return {@link TeleportHolder} if found otherwise {@code null}
     */
    public TeleportHolder getHolder(int npcId, String listName) {
        return teleporters.getOrDefault(npcId, Collections.emptyMap()).get(listName);
    }

    public static TeleportersData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final TeleportersData INSTANCE = new TeleportersData();
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 60 2008 44 2009 641 2010 61 418 2011 60 62 40 41 59 437 2000 40 41 123 2012 40 41 59 125 64 2013 438 2014 2015 40 41 123 450 2016 46 2017 40 41 46 2018 40 648 41 59 125 64 2013 439 492 2019 40 41 123 2010 46 2020 40 41 59 2021 40 648 44 473 41 59 2003 46 2022 40 648 44 2010 46 2023 40 41 41 59 2024 40 41 59 125 64 2013 439 492 2025 40 2026 2027 44 2028 2029 41 123 2030 40 2027 44 648 44 411 45 62 2030 40 411 44 648 44 2031 45 62 123 381 490 2032 61 418 2033 60 2008 44 2009 62 40 41 59 381 404 2034 61 2035 40 2031 46 2036 40 41 44 648 41 59 2030 40 2031 44 2037 45 62 123 464 40 2037 46 2038 40 41 41 123 328 648 45 62 2039 40 2032 44 2034 44 2037 41 59 328 648 45 62 2040 40 2032 44 2037 41 59 125 125 41 59 2041 40 2034 44 2032 41 59 125 41 41 59 125 437 492 2042 40 381 2043 60 2008 44 2009 62 2044 44 2045 2046 41 123 2047 40 2046 44 648 44 2048 45 62 2049 40 2050 40 2048 46 2051 40 41 44 648 41 44 2044 41 41 59 125 437 492 2052 40 2043 60 2008 44 2009 62 2044 44 404 2053 44 2045 2046 41 123 381 2054 2055 61 2046 46 2056 40 41 59 381 2057 2058 61 2059 40 2055 44 2057 46 334 44 648 41 59 381 2008 2060 61 2061 40 2055 44 648 44 2058 46 2060 40 41 41 59 381 2009 2062 61 418 2009 40 2060 44 2058 41 59 2063 40 2046 44 648 44 2064 45 62 2062 46 2065 40 418 2066 40 2067 40 2064 41 41 41 41 59 392 40 2068 40 2044 46 2069 40 2060 44 2062 41 41 41 123 2003 46 2070 40 648 44 2060 44 2053 41 59 125 125 618 437 492 2071 40 404 2053 44 2007 60 2008 44 2009 62 2072 41 123 2010 46 2073 40 2053 44 2072 41 59 125 618 439 2009 2074 40 404 2053 44 2008 2075 41 123 450 2010 46 2076 40 2053 44 2077 46 2078 40 41 41 46 2079 40 2075 41 59 125 439 457 2000 2080 40 41 123 450 2081 46 2082 59 125 437 457 334 2083 123 437 457 381 2000 2084 61 418 2000 40 41 59 125 125 
27758,Java,"public class SiegeScheduleData extends GameXmlReader {
    private static final Logger LOGGER = LoggerFactory.getLogger(SiegeScheduleData.class);

    private final List<SiegeScheduleDate> scheduleData = new ArrayList<>();

    private SiegeScheduleData() {
        load();
    }

    @Override
    protected Path getSchemaFilePath() {
        return Path.of(""config/xsd/siege-schedule.xsd"");
    }

    @Override
    public synchronized void load() {
        scheduleData.clear();
        parseFile(""config/siege-schedule.xml"");
        LOGGER.info(""Loaded: {}  siege schedulers."", scheduleData.size());
        if (scheduleData.isEmpty()) {
            scheduleData.add(new SiegeScheduleDate());
            LOGGER.info(""Loaded: default siege schedulers."");
        }
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", listNode -> forEach(listNode, ""schedule"", scheduleNode -> {
            var attrs = scheduleNode.getAttributes();
            var day = parseEnum(attrs, DayOfWeek.class, ""day"", DayOfWeek.SUNDAY);
            scheduleData.add(new SiegeScheduleDate(day, parseInt(attrs, ""hour""), parseInt(attrs, ""max-concurrent"")));
        }));
    }

    public List<SiegeScheduleDate> getScheduleDates() {
        return scheduleData;
    }

    public static SiegeScheduleData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final SiegeScheduleData INSTANCE = new SiegeScheduleData();
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 62 2008 61 418 2009 60 62 40 41 59 437 2000 40 41 123 2010 40 41 59 125 64 2011 438 2012 2013 40 41 123 450 2012 46 2014 40 648 41 59 125 64 2011 439 465 492 2015 40 41 123 2008 46 2016 40 41 59 2017 40 648 41 59 2003 46 2018 40 648 44 2008 46 2019 40 41 41 59 392 40 2008 46 2020 40 41 41 123 2008 46 2021 40 418 2007 40 41 41 59 2003 46 2018 40 648 41 59 125 2022 40 41 59 125 64 2011 439 492 2023 40 2024 2025 44 2026 2027 41 123 2028 40 2025 44 648 44 2029 45 62 2028 40 2029 44 648 44 2030 45 62 123 490 2031 61 2030 46 2032 40 41 59 490 2033 61 2034 40 2031 44 2035 46 334 44 648 44 2035 46 2036 41 59 2008 46 2037 40 418 2007 40 2033 44 2038 40 2031 44 648 41 44 2038 40 2031 44 648 41 41 41 59 125 41 41 59 125 439 2006 60 2007 62 2039 40 41 123 450 2008 59 125 439 457 2000 2040 40 41 123 450 2041 46 2042 59 125 437 457 334 2043 123 437 457 381 2000 2044 61 418 2000 40 41 59 125 125 
26129,Java,"public class FilterUtil {

    private static final Pattern XML_PATTERN = Pattern.compile("".+\\.xml$"", Pattern.CASE_INSENSITIVE);
    private static final Pattern HTML_PATTERN = Pattern.compile("".+\\.html?$"", Pattern.CASE_INSENSITIVE);
    private static final Pattern JAVA_PATTERN = Pattern.compile("".+\\.java?$"", Pattern.CASE_INSENSITIVE);

    public static boolean xmlFile(Path path) {
        return Files.isRegularFile(path) && XML_PATTERN.matcher(path.toString()).matches();
    }

    public static boolean xmlFile(File file) {
        return nonNull(file) && file.isFile() && XML_PATTERN.matcher(file.getName()).matches();
    }

    public static boolean htmlFile(Path path) {
        return Files.isRegularFile(path) && HTML_PATTERN.matcher(path.toString()).matches();
    }

    public static boolean javaFile(Path path) {
        return Files.isRegularFile(path) && JAVA_PATTERN.matcher(path.toString()).matches();
    }
}",0,439 334 2000 123 437 457 381 2001 2002 61 2001 46 2003 40 648 44 2001 46 2004 41 59 437 457 381 2001 2005 61 2001 46 2003 40 648 44 2001 46 2004 41 59 437 457 381 2001 2006 61 2001 46 2003 40 648 44 2001 46 2004 41 59 439 457 324 2007 40 2008 2009 41 123 450 2010 46 2011 40 2009 41 605 2002 46 2012 40 2009 46 2013 40 41 41 46 2014 40 41 59 125 439 457 324 2007 40 2015 2016 41 123 450 2017 40 2016 41 605 2016 46 2018 40 41 605 2002 46 2019 40 2016 46 2020 40 41 41 46 2021 40 41 59 125 439 457 324 2022 40 2008 2009 41 123 450 2023 46 2024 40 2009 41 605 2005 46 2025 40 2009 46 2026 40 41 41 46 2027 40 41 59 125 439 457 324 2028 40 2008 2009 41 123 450 2029 46 2030 40 2009 41 605 2006 46 2031 40 2009 46 2032 40 41 41 46 2033 40 41 59 125 125 
5249,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);

                                if (!empty && newItem != null) {
                                    Trade trade = newItem.getTrade();
                                    String id = trade.getId();

                                    // We use maps for each trade to avoid multiple listener registrations when
                                    // switching views. With current implementation we avoid that but we do not
                                    // remove listeners when a trade is removed (completed) but that has no consequences
                                    // as we will not receive any message anyway from a closed trade. Supporting it
                                    // more correctly would require more effort and managing listener deactivation at
                                    // screen switches (currently we get the update called if we have selected another
                                    // view.
                                    Button button;
                                    if (!buttonByTrade.containsKey(id)) {
                                        button = FormBuilder.getIconButton(MaterialDesignIcon.COMMENT_MULTIPLE_OUTLINE);
                                        buttonByTrade.put(id, button);
                                        button.setTooltip(new Tooltip(Res.get(""tradeChat.openChat"")));
                                    } else {
                                        button = buttonByTrade.get(id);
                                    }

                                    JFXBadge badge;
                                    if (!badgeByTrade.containsKey(id)) {
                                        badge = new JFXBadge(button);
                                        badgeByTrade.put(id, badge);
                                        badge.setPosition(Pos.TOP_RIGHT);
                                    } else {
                                        badge = badgeByTrade.get(id);
                                    }

                                    button.setOnAction(e -> {
                                        tableView.getSelectionModel().select(this.getIndex());
                                        openChat(trade);
                                    });

                                    if (!listenerByTrade.containsKey(id)) {
                                        ListChangeListener<ChatMessage> listener = c -> updateChatMessageCount(trade, badge);
                                        listenerByTrade.put(id, listener);
                                        trade.getChatMessages().addListener(listener);
                                    }

                                    updateChatMessageCount(trade, badge);

                                    setGraphic(badge);
                                } else {
                                    setGraphic(null);
                                }
                            }

                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 33 362 605 2008 631 424 41 123 2009 2010 61 2008 46 2011 40 41 59 2012 2013 61 2010 46 2014 40 41 59 621 621 621 621 621 621 621 2015 2016 59 392 40 33 2017 46 2018 40 2013 41 41 123 2016 61 2019 46 2020 40 2021 46 2022 41 59 2017 46 2023 40 2013 44 2016 41 59 2016 46 2024 40 418 2025 40 2026 46 2027 40 648 41 41 41 59 125 360 123 2016 61 2017 46 2028 40 2013 41 59 125 2029 2030 59 392 40 33 2031 46 2018 40 2013 41 41 123 2030 61 418 2029 40 2016 41 59 2031 46 2032 40 2013 44 2030 41 59 2030 46 2033 40 2034 46 2035 41 59 125 360 123 2030 61 2031 46 2036 40 2013 41 59 125 2016 46 2037 40 2038 45 62 123 2039 46 2040 40 41 46 2041 40 467 46 2042 40 41 41 59 2043 40 2010 41 59 125 41 59 392 40 33 2044 46 2018 40 2013 41 41 123 2045 60 2046 62 2047 61 2048 45 62 2049 40 2010 44 2030 41 59 2044 46 2050 40 2013 44 2047 41 59 2010 46 2051 40 41 46 2052 40 2047 41 59 125 2053 40 2010 44 2030 41 59 2054 40 2030 41 59 125 360 123 2055 40 424 41 59 125 125 125 59 125 125 41 59 
5248,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    final Trade trade = newItem.getTrade();
                                    final NodeAddress tradingPeerNodeAddress = trade.getTradingPeerNodeAddress();
                                    int numPastTrades = model.getNumPastTrades(trade);
                                    String role = Res.get(""peerInfoIcon.tooltip.tradePeer"");
                                    Node peerInfoIcon = new PeerInfoIconTrading(tradingPeerNodeAddress,
                                            role,
                                            numPastTrades,
                                            privateNotificationManager,
                                            trade,
                                            preferences,
                                            model.accountAgeWitnessService,
                                            useDevPrivilegeKeys);
                                    setPadding(new Insets(1, 0, 0, 0));
                                    setGraphic(peerInfoIcon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 33 362 605 2004 631 424 41 123 381 2005 2006 61 2004 46 2007 40 41 59 381 2008 2009 61 2006 46 2010 40 41 59 404 2011 61 2012 46 2013 40 2006 41 59 2014 2015 61 2016 46 2017 40 648 41 59 2018 2019 61 418 2020 40 2009 44 2015 44 2011 44 2021 44 2006 44 2022 44 2012 46 2023 44 2024 41 59 2025 40 418 2026 40 1501 44 1500 44 1500 44 1500 41 41 59 2027 40 2019 41 59 125 360 123 2028 40 424 41 59 125 125 125 59 
5257,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(FormattingUtils.formatPrice(item.getPrice())));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 418 2010 40 2011 46 2012 40 2008 46 2013 40 41 41 41 41 59 360 2009 40 424 41 59 125 125 59 125 125 41 59 
5255,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getPaymentMethod(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 418 2010 40 2011 46 2012 40 2008 41 41 41 59 360 2009 40 424 41 59 125 125 59 125 125 41 59 
5263,Java,"                new Callback<>() {

                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem,
                            PendingTradesListItem> column) {
                        return new TableCell<>() {
                            private Trade trade;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    trade = item.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    setGraphic(null);
                                    if (trade != null && listener != null) {
                                        trade.stateProperty().removeListener(listener);
                                        trade = null;
                                        listener = null;
                                    }
                                }
                            }

                            private void update() {
                                HyperlinkWithIcon field;
                                if (trade == null) return;

                                if (isMaybeInvalidTrade(trade)) {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setIcon(FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE));
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.invalidTradeState.warning"")));
                                    if (trade.isTxChainInvalid()) {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }
                                } else {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                }
                                setGraphic(field);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 437 2009 60 2007 46 2010 62 2011 59 64 2001 439 492 2012 40 381 2003 2013 44 324 362 41 123 463 46 2012 40 2013 44 362 41 59 392 40 2013 631 424 605 33 362 41 123 2008 61 2013 46 2014 40 41 59 2011 61 40 2015 44 2016 44 2017 41 45 62 2018 40 41 59 2008 46 2019 40 41 46 2020 40 2011 41 59 2018 40 41 59 125 360 123 2021 40 424 41 59 392 40 2008 631 424 605 2011 631 424 41 123 2008 46 2022 40 41 46 2023 40 2011 41 59 2008 61 424 59 2011 61 424 59 125 125 125 437 492 2024 40 41 123 2025 2026 59 392 40 2008 614 424 41 450 59 392 40 2027 40 2008 41 41 123 2026 61 418 2025 40 2008 46 2028 40 41 41 59 2026 46 2029 40 2030 46 2031 40 2032 46 2033 41 41 59 2026 46 2034 40 373 45 62 2035 46 2036 40 2008 41 41 59 2026 46 2037 40 418 2038 40 2039 46 2040 40 648 41 41 41 59 392 40 2008 46 2041 40 41 41 123 2026 46 2042 40 41 46 2043 40 41 46 2044 40 648 44 648 41 59 125 360 123 2026 46 2045 40 41 46 2046 40 41 46 2047 40 648 44 648 41 59 125 125 360 123 2026 61 418 2025 40 2008 46 2048 40 41 41 59 2026 46 2049 40 373 45 62 2050 46 2051 40 2008 41 41 59 2026 46 2052 40 418 2053 40 2054 46 2055 40 648 41 41 41 59 125 2056 40 2026 41 59 125 125 59 125 125 41 59 
5259,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem,
                            PendingTradesListItem> column) {
                        return new TableCell<>() {
                            private Trade trade;
                            private JFXButton warnIconButton, trashIconButton;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    trade = newItem.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    cleanup();
                                }
                            }

                            private void update() {
                                if (isMaybeInvalidTrade(trade)) {
                                    Text warnIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE);
                                    Text trashIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ARROW_RIGHT_BOLD_BOX_OUTLINE);
                                    if (trade.isTxChainInvalid()) {
                                        trashIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        trashIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }

                                    warnIconButton = new JFXButton("""", warnIcon);
                                    warnIconButton.getStyleClass().add(""hidden-icon-button"");
                                    warnIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.warningIcon.tooltip"")));
                                    warnIconButton.setOnAction(e -> onShowInfoForInvalidTrade(trade));

                                    trashIconButton = new JFXButton("""", trashIcon);
                                    trashIconButton.getStyleClass().add(""hidden-icon-button"");
                                    trashIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.moveTradeToFailedIcon.tooltip"")));
                                    trashIconButton.setOnAction(e -> onMoveInvalidTradeToFailedTrades(trade));

                                    HBox hBox = new HBox();
                                    hBox.setSpacing(0);
                                    hBox.getChildren().addAll(warnIconButton, trashIconButton);
                                    setGraphic(hBox);
                                } else {
                                    cleanup();
                                }

                                updateMoveTradeToFailedColumnState();
                            }

                            private void cleanup() {
                                if (warnIconButton != null) {
                                    warnIconButton.setOnAction(null);
                                }
                                if (trashIconButton != null) {
                                    trashIconButton.setOnAction(null);
                                }
                                if (listener != null && trade != null) {
                                    trade.stateProperty().removeListener(listener);
                                }
                                setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 437 2009 2010 44 2011 59 437 2012 60 2007 46 2013 62 2014 59 64 2001 439 492 2015 40 2003 2016 44 324 362 41 123 463 46 2015 40 2016 44 362 41 59 392 40 33 362 605 2016 631 424 41 123 2008 61 2016 46 2017 40 41 59 2014 61 40 2018 44 2019 44 2020 41 45 62 2021 40 41 59 2008 46 2022 40 41 46 2023 40 2014 41 59 2021 40 41 59 125 360 123 2024 40 41 59 125 125 437 492 2025 40 41 123 392 40 2026 40 2008 41 41 123 2027 2028 61 2029 46 2030 40 2031 46 2032 41 59 2027 2033 61 2029 46 2030 40 2031 46 2034 41 59 392 40 2008 46 2035 40 41 41 123 2033 46 2036 40 41 46 2037 40 648 44 648 41 59 2028 46 2036 40 41 46 2037 40 648 44 648 41 59 125 360 123 2033 46 2038 40 41 46 2039 40 648 44 648 41 59 2028 46 2038 40 41 46 2039 40 648 44 648 41 59 125 2010 61 418 2009 40 648 44 2028 41 59 2010 46 2040 40 41 46 2041 40 648 41 59 2010 46 2042 40 418 2043 40 2044 46 2045 40 648 41 41 41 59 2010 46 2046 40 2047 45 62 2048 40 2008 41 41 59 2011 61 418 2009 40 648 44 2033 41 59 2011 46 2040 40 41 46 2041 40 648 41 59 2011 46 2042 40 418 2043 40 2044 46 2045 40 648 41 41 41 59 2011 46 2046 40 2047 45 62 2049 40 2008 41 41 59 2050 2051 61 418 2050 40 41 59 2051 46 2052 40 1500 41 59 2051 46 2053 40 41 46 2054 40 2010 44 2011 41 59 2055 40 2051 41 59 125 360 123 2056 40 41 59 125 2057 40 41 59 125 437 492 2058 40 41 123 392 40 2010 631 424 41 123 2010 46 2059 40 424 41 59 125 392 40 2011 631 424 41 123 2011 46 2060 40 424 41 59 125 392 40 2014 631 424 605 2008 631 424 41 123 2008 46 2061 40 41 46 2062 40 2014 41 59 125 2063 40 424 41 59 125 125 59 125 125 41 59 
5250,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);

                                if (!empty && newItem != null) {
                                    Trade trade = newItem.getTrade();
                                    String id = trade.getId();

                                    // We use maps for each trade to avoid multiple listener registrations when
                                    // switching views. With current implementation we avoid that but we do not
                                    // remove listeners when a trade is removed (completed) but that has no consequences
                                    // as we will not receive any message anyway from a closed trade. Supporting it
                                    // more correctly would require more effort and managing listener deactivation at
                                    // screen switches (currently we get the update called if we have selected another
                                    // view.
                                    Button button;
                                    if (!buttonByTrade.containsKey(id)) {
                                        button = FormBuilder.getIconButton(MaterialDesignIcon.COMMENT_MULTIPLE_OUTLINE);
                                        buttonByTrade.put(id, button);
                                        button.setTooltip(new Tooltip(Res.get(""tradeChat.openChat"")));
                                    } else {
                                        button = buttonByTrade.get(id);
                                    }

                                    JFXBadge badge;
                                    if (!badgeByTrade.containsKey(id)) {
                                        badge = new JFXBadge(button);
                                        badgeByTrade.put(id, badge);
                                        badge.setPosition(Pos.TOP_RIGHT);
                                    } else {
                                        badge = badgeByTrade.get(id);
                                    }

                                    button.setOnAction(e -> {
                                        tableView.getSelectionModel().select(this.getIndex());
                                        openChat(trade);
                                    });

                                    if (!listenerByTrade.containsKey(id)) {
                                        ListChangeListener<ChatMessage> listener = c -> updateChatMessageCount(trade, badge);
                                        listenerByTrade.put(id, listener);
                                        trade.getChatMessages().addListener(listener);
                                    }

                                    updateChatMessageCount(trade, badge);

                                    setGraphic(badge);
                                } else {
                                    setGraphic(null);
                                }
                            }

                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 33 362 605 2004 631 424 41 123 2005 2006 61 2004 46 2007 40 41 59 2008 2009 61 2006 46 2010 40 41 59 621 621 621 621 621 621 621 2011 2012 59 392 40 33 2013 46 2014 40 2009 41 41 123 2012 61 2015 46 2016 40 2017 46 2018 41 59 2013 46 2019 40 2009 44 2012 41 59 2012 46 2020 40 418 2021 40 2022 46 2023 40 648 41 41 41 59 125 360 123 2012 61 2013 46 2024 40 2009 41 59 125 2025 2026 59 392 40 33 2027 46 2014 40 2009 41 41 123 2026 61 418 2025 40 2012 41 59 2027 46 2028 40 2009 44 2026 41 59 2026 46 2029 40 2030 46 2031 41 59 125 360 123 2026 61 2027 46 2032 40 2009 41 59 125 2012 46 2033 40 2034 45 62 123 2035 46 2036 40 41 46 2037 40 467 46 2038 40 41 41 59 2039 40 2006 41 59 125 41 59 392 40 33 2040 46 2014 40 2009 41 41 123 2041 60 2042 62 2043 61 2044 45 62 2045 40 2006 44 2026 41 59 2040 46 2046 40 2009 44 2043 41 59 2006 46 2047 40 41 46 2048 40 2043 41 59 125 2049 40 2006 44 2026 41 59 2050 40 2026 41 59 125 360 123 2051 40 424 41 59 125 125 125 59 
5335,Java,"                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = getRegularIconButton(MaterialDesignIcon.CONTENT_COPY);
                                        button.setTooltip(new Tooltip(Res.get(""shared.duplicateOffer"")));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(event -> onDuplicateOffer(item.getOffer()));
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 392 40 2002 614 424 41 123 2002 61 2007 40 2008 46 2009 41 59 2002 46 2010 40 418 2011 40 2012 46 2013 40 648 41 41 41 59 2014 40 2002 41 59 125 2002 46 2015 40 373 45 62 2016 40 2006 46 2017 40 41 41 41 59 125 360 123 2018 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2019 40 424 41 59 2002 61 424 59 125 125 125 125 59 
5265,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    try {
                                        String volume = VolumeUtil.formatVolumeWithCode(item.getTrade().getVolume());
                                        setGraphic(new AutoTooltipLabel(volume));
                                    } catch (Throwable ignore) {
                                        log.debug(ignore.toString()); // Stupidity to make Codacy happy
                                    }
                                } else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 474 123 2009 2010 61 2011 46 2012 40 2008 46 2013 40 41 46 2014 40 41 41 59 2015 40 418 2016 40 2010 41 41 59 125 329 40 2017 2018 41 123 2019 46 2020 40 2018 46 2021 40 41 41 59 621 125 125 360 2022 40 424 41 59 125 125 59 125 125 41 59 
5245,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(formatter.formatCoin(item.getTrade().getAmount())));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 418 2010 40 2011 46 2012 40 2008 46 2013 40 41 46 2014 40 41 41 41 41 59 360 2009 40 424 41 59 125 125 59 125 125 41 59 
4148,Java,"        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                log.warn(""Graceful shutdown not completed in 10 sec. We trigger our timeout handler."");
                flushAndExit(resultHandler, EXIT_SUCCESS);
            }
        }, 10000);",0,418 2000 40 41 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 41 123 2005 46 2006 40 648 41 59 2007 40 2008 44 2009 41 59 125 125 44 1505 41 59 
5251,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(DisplayUtils.formatDateTime(item.getTrade().getDate())));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 418 2010 40 2011 46 2012 40 2008 46 2013 40 41 46 2014 40 41 41 41 41 59 125 360 123 2015 40 424 41 59 125 125 125 59 125 125 41 59 
5253,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 418 2010 40 2011 46 2012 40 2008 41 41 41 59 125 125 59 125 125 41 59 
5260,Java,"                        return new TableCell<>() {
                            private Trade trade;
                            private JFXButton warnIconButton, trashIconButton;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    trade = newItem.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    cleanup();
                                }
                            }

                            private void update() {
                                if (isMaybeInvalidTrade(trade)) {
                                    Text warnIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE);
                                    Text trashIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ARROW_RIGHT_BOLD_BOX_OUTLINE);
                                    if (trade.isTxChainInvalid()) {
                                        trashIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        trashIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }

                                    warnIconButton = new JFXButton("""", warnIcon);
                                    warnIconButton.getStyleClass().add(""hidden-icon-button"");
                                    warnIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.warningIcon.tooltip"")));
                                    warnIconButton.setOnAction(e -> onShowInfoForInvalidTrade(trade));

                                    trashIconButton = new JFXButton("""", trashIcon);
                                    trashIconButton.getStyleClass().add(""hidden-icon-button"");
                                    trashIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.moveTradeToFailedIcon.tooltip"")));
                                    trashIconButton.setOnAction(e -> onMoveInvalidTradeToFailedTrades(trade));

                                    HBox hBox = new HBox();
                                    hBox.setSpacing(0);
                                    hBox.getChildren().addAll(warnIconButton, trashIconButton);
                                    setGraphic(hBox);
                                } else {
                                    cleanup();
                                }

                                updateMoveTradeToFailedColumnState();
                            }

                            private void cleanup() {
                                if (warnIconButton != null) {
                                    warnIconButton.setOnAction(null);
                                }
                                if (trashIconButton != null) {
                                    trashIconButton.setOnAction(null);
                                }
                                if (listener != null && trade != null) {
                                    trade.stateProperty().removeListener(listener);
                                }
                                setGraphic(null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 437 2003 2004 44 2005 59 437 2006 60 2001 46 2007 62 2008 59 64 2009 439 492 2010 40 2011 2012 44 324 362 41 123 463 46 2010 40 2012 44 362 41 59 392 40 33 362 605 2012 631 424 41 123 2002 61 2012 46 2013 40 41 59 2008 61 40 2014 44 2015 44 2016 41 45 62 2017 40 41 59 2002 46 2018 40 41 46 2019 40 2008 41 59 2017 40 41 59 125 360 123 2020 40 41 59 125 125 437 492 2021 40 41 123 392 40 2022 40 2002 41 41 123 2023 2024 61 2025 46 2026 40 2027 46 2028 41 59 2023 2029 61 2025 46 2026 40 2027 46 2030 41 59 392 40 2002 46 2031 40 41 41 123 2029 46 2032 40 41 46 2033 40 648 44 648 41 59 2024 46 2032 40 41 46 2033 40 648 44 648 41 59 125 360 123 2029 46 2034 40 41 46 2035 40 648 44 648 41 59 2024 46 2034 40 41 46 2035 40 648 44 648 41 59 125 2004 61 418 2003 40 648 44 2024 41 59 2004 46 2036 40 41 46 2037 40 648 41 59 2004 46 2038 40 418 2039 40 2040 46 2041 40 648 41 41 41 59 2004 46 2042 40 2043 45 62 2044 40 2002 41 41 59 2005 61 418 2003 40 648 44 2029 41 59 2005 46 2036 40 41 46 2037 40 648 41 59 2005 46 2038 40 418 2039 40 2040 46 2041 40 648 41 41 41 59 2005 46 2042 40 2043 45 62 2045 40 2002 41 41 59 2046 2047 61 418 2046 40 41 59 2047 46 2048 40 1500 41 59 2047 46 2049 40 41 46 2050 40 2004 44 2005 41 59 2051 40 2047 41 59 125 360 123 2052 40 41 59 125 2053 40 41 59 125 437 492 2054 40 41 123 392 40 2004 631 424 41 123 2004 46 2055 40 424 41 59 125 392 40 2005 631 424 41 123 2005 46 2056 40 424 41 59 125 392 40 2008 631 424 605 2002 631 424 41 123 2002 46 2057 40 41 46 2058 40 2008 41 59 125 2059 40 424 41 59 125 125 59 
5266,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    try {
                                        String volume = VolumeUtil.formatVolumeWithCode(item.getTrade().getVolume());
                                        setGraphic(new AutoTooltipLabel(volume));
                                    } catch (Throwable ignore) {
                                        log.debug(ignore.toString()); // Stupidity to make Codacy happy
                                    }
                                } else
                                    setGraphic(null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 474 123 2005 2006 61 2007 46 2008 40 2004 46 2009 40 41 46 2010 40 41 41 59 2011 40 418 2012 40 2006 41 41 59 125 329 40 2013 2014 41 123 2015 46 2016 40 2014 46 2017 40 41 41 59 621 125 125 360 2018 40 424 41 59 125 125 59 
5264,Java,"                        return new TableCell<>() {
                            private Trade trade;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    trade = item.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    setGraphic(null);
                                    if (trade != null && listener != null) {
                                        trade.stateProperty().removeListener(listener);
                                        trade = null;
                                        listener = null;
                                    }
                                }
                            }

                            private void update() {
                                HyperlinkWithIcon field;
                                if (trade == null) return;

                                if (isMaybeInvalidTrade(trade)) {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setIcon(FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE));
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.invalidTradeState.warning"")));
                                    if (trade.isTxChainInvalid()) {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }
                                } else {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                }
                                setGraphic(field);
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 437 2003 60 2001 46 2004 62 2005 59 64 2006 439 492 2007 40 381 2008 2009 44 324 362 41 123 463 46 2007 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2002 61 2009 46 2010 40 41 59 2005 61 40 2011 44 2012 44 2013 41 45 62 2014 40 41 59 2002 46 2015 40 41 46 2016 40 2005 41 59 2014 40 41 59 125 360 123 2017 40 424 41 59 392 40 2002 631 424 605 2005 631 424 41 123 2002 46 2018 40 41 46 2019 40 2005 41 59 2002 61 424 59 2005 61 424 59 125 125 125 437 492 2020 40 41 123 2021 2022 59 392 40 2002 614 424 41 450 59 392 40 2023 40 2002 41 41 123 2022 61 418 2021 40 2002 46 2024 40 41 41 59 2022 46 2025 40 2026 46 2027 40 2028 46 2029 41 41 59 2022 46 2030 40 373 45 62 2031 46 2032 40 2002 41 41 59 2022 46 2033 40 418 2034 40 2035 46 2036 40 648 41 41 41 59 392 40 2002 46 2037 40 41 41 123 2022 46 2038 40 41 46 2039 40 41 46 2040 40 648 44 648 41 59 125 360 123 2022 46 2041 40 41 46 2042 40 41 46 2043 40 648 44 648 41 59 125 125 360 123 2022 61 418 2021 40 2002 46 2044 40 41 41 59 2022 46 2045 40 373 45 62 2046 46 2047 40 2002 41 41 59 2022 46 2048 40 418 2049 40 2050 46 2051 40 648 41 41 41 59 125 2052 40 2022 41 59 125 125 59 
5261,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getMyRole(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 418 2010 40 2011 46 2012 40 2008 41 41 41 59 360 2009 40 424 41 59 125 125 59 125 125 41 59 
5341,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon field;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    field = new HyperlinkWithIcon(model.getOfferId(item));
                                    field.setOnAction(event -> {
                                        if (item.getOffer().isBsqSwapOffer()) {
                                            bsqSwapOfferDetailsWindow.show(item.getOffer());
                                        } else {
                                            offerDetailsWindow.show(item.getOffer());
                                        }
                                    });

                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                    setGraphic(field);
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2002 61 418 2001 40 2007 46 2008 40 2006 41 41 59 2002 46 2009 40 373 45 62 123 392 40 2006 46 2010 40 41 46 2011 40 41 41 123 2012 46 2013 40 2006 46 2010 40 41 41 59 125 360 123 2014 46 2015 40 2006 46 2010 40 41 41 59 125 125 41 59 2002 46 2016 40 418 2017 40 2018 46 2019 40 648 41 41 41 59 2020 40 2002 41 59 125 360 123 2021 40 424 41 59 392 40 2002 631 424 41 2002 46 2022 40 424 41 59 125 125 125 59 
5324,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getAmount(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
5336,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (item.getOffer().isBsqSwapOffer()) {
                                        if (button != null) {
                                            button.setOnAction(null);
                                            button = null;
                                        }
                                        if (item.getOpenOffer().isBsqSwapOfferHasMissingFunds()) {
                                            Label label = new Label();
                                            Text icon = getRegularIconForLabel(MaterialDesignIcon.EYE_OFF, label);
                                            Tooltip.install(icon, new Tooltip(Res.get(""openOffer.bsqSwap.missingFunds"")));
                                            setGraphic(icon);
                                        } else {
                                            setGraphic(null);
                                        }
                                    } else {
                                        if (button == null) {
                                            button = getRegularIconButton(MaterialDesignIcon.PENCIL);
                                            button.setTooltip(new Tooltip(Res.get(""shared.editOffer"")));
                                            button.setOnAction(event -> onEditOpenOffer(item.getOpenOffer()));
                                            setGraphic(button);
                                        }
                                    }
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2010 46 2011 40 41 46 2012 40 41 41 123 392 40 2008 631 424 41 123 2008 46 2013 40 424 41 59 2008 61 424 59 125 392 40 2010 46 2014 40 41 46 2015 40 41 41 123 2016 2017 61 418 2016 40 41 59 2018 2019 61 2020 40 2021 46 2022 44 2017 41 59 2023 46 2024 40 2019 44 418 2023 40 2025 46 2026 40 648 41 41 41 59 2027 40 2019 41 59 125 360 123 2028 40 424 41 59 125 125 360 123 392 40 2008 614 424 41 123 2008 61 2029 40 2030 46 2031 41 59 2008 46 2032 40 418 2033 40 2034 46 2035 40 648 41 41 41 59 2008 46 2036 40 373 45 62 2037 40 2010 46 2038 40 41 41 41 59 2039 40 2008 41 59 125 125 125 360 123 2040 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2041 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
5325,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getAmount(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5326,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");
                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getDate(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
5330,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    AutoTooltipLabel autoTooltipLabel = new AutoTooltipLabel(model.getPriceDeviation(item));
                                    autoTooltipLabel.setOpacity(item.getOffer().isUseMarketBasedPrice() ? 1 : 0.4);
                                    setGraphic(autoTooltipLabel);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 2015 61 418 2014 40 2011 46 2016 40 2008 41 41 59 2015 46 2017 40 2008 46 2018 40 41 46 2019 40 41 63 1501 58 1499 41 59 2020 40 2015 41 59 125 360 123 2021 40 424 41 59 125 125 125 59 125 125 41 59 
5331,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    AutoTooltipLabel autoTooltipLabel = new AutoTooltipLabel(model.getPriceDeviation(item));
                                    autoTooltipLabel.setOpacity(item.getOffer().isUseMarketBasedPrice() ? 1 : 0.4);
                                    setGraphic(autoTooltipLabel);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 2011 61 418 2010 40 2007 46 2012 40 2004 41 41 59 2011 46 2013 40 2004 46 2014 40 41 46 2015 40 41 63 1501 58 1499 41 59 2016 40 2011 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 
5332,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getDirectionLabel(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
5338,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
5342,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getPaymentMethod(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
5346,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = getRegularIconButton(MaterialDesignIcon.DELETE_FOREVER, ""delete"");
                                        button.setTooltip(new Tooltip(Res.get(""shared.removeOffer"")));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(event -> onRemoveOpenOffer(item.getOpenOffer()));
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2008 614 424 41 123 2008 61 2011 40 2012 46 2013 44 648 41 59 2008 46 2014 40 418 2015 40 2016 46 2017 40 648 41 41 41 59 2018 40 2008 41 59 125 2008 46 2019 40 373 45 62 2020 40 2010 46 2021 40 41 41 41 59 125 360 123 2022 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2023 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
5350,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");
                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getTriggerPrice(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
5351,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");
                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getTriggerPrice(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5353,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getVolume(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
4064,Java,"public class ClosedTradesViewModel extends ActivatableWithDataModel<ClosedTradesDataModel> implements ViewModel {
    private final ClosedTradableFormatter closedTradableFormatter;

    @Inject
    public ClosedTradesViewModel(ClosedTradesDataModel dataModel, ClosedTradableFormatter closedTradableFormatter) {
        super(dataModel);

        this.closedTradableFormatter = closedTradableFormatter;
    }

    String getTradeId(Tradable item) {
        return item.getShortId();
    }

    String getAmount(Tradable item) {
        return item != null ? closedTradableFormatter.getAmountAsString(item) : """";
    }

    String getPrice(Tradable item) {
        return item != null ? closedTradableFormatter.getPriceAsString(item) : """";
    }

    String getPriceDeviation(Tradable item) {
        return item != null ? closedTradableFormatter.getPriceDeviationAsString(item) : """";
    }

    String getVolume(Tradable item, boolean appendCode) {
        return item != null ? closedTradableFormatter.getVolumeAsString(item, appendCode) : """";
    }

    String getVolumeCurrency(Tradable item) {
        return item != null ? closedTradableFormatter.getVolumeCurrencyAsString(item) : """";
    }

    String getTxFee(Tradable item) {
        return item != null ? closedTradableFormatter.getTxFeeAsString(item) : """";
    }

    String getTradeFee(Tradable item, boolean appendCode) {
        return item != null ? closedTradableFormatter.getTradeFeeAsString(item, appendCode) : """";
    }

    String getBuyerSecurityDeposit(Tradable item) {
        return item != null ? closedTradableFormatter.getBuyerSecurityDepositAsString(item) : """";
    }

    String getSellerSecurityDeposit(Tradable item) {
        return item != null ? closedTradableFormatter.getSellerSecurityDepositAsString(item) : """";
    }

    String getDirectionLabel(Tradable item) {
        if ((item != null)) {
            OfferDirection direction = dataModel.getDirection(item.getOffer());
            String currencyCode = item.getOffer().getCurrencyCode();
            return DisplayUtils.getDirectionWithCode(direction, currencyCode);
        } else {
            return """";
        }
    }

    String getDate(Tradable item) {
        return DisplayUtils.formatDateTime(item.getDate());
    }

    String getMarketLabel(Tradable item) {
        return item != null ? CurrencyUtil.getCurrencyPair(item.getOffer().getCurrencyCode()) : """";
    }

    String getState(Tradable item) {
        return item != null ? closedTradableFormatter.getStateAsString(item) : """";
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Used in ClosedTradesSummaryWindow
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Coin getTotalTradeAmount() {
        return dataModel.getTotalAmount();
    }

    public String getTotalAmountWithVolume(Coin totalTradeAmount) {
        return dataModel.getVolumeInUserFiatCurrency(totalTradeAmount)
                .map(volume -> closedTradableFormatter.getTotalAmountWithVolumeAsString(totalTradeAmount, volume))
                .orElse("""");
    }

    public Map<String, String> getTotalVolumeByCurrency() {
        return closedTradableFormatter.getTotalVolumeByCurrencyAsString(dataModel.getList());
    }

    public String getTotalTxFee(Coin totalTradeAmount) {
        Coin totalTxFee = dataModel.getTotalTxFee();
        return closedTradableFormatter.getTotalTxFeeAsString(totalTradeAmount, totalTxFee);
    }

    public String getTotalTradeFeeInBtc(Coin totalTradeAmount) {
        Coin totalTradeFee = dataModel.getTotalTradeFee(true);
        return closedTradableFormatter.getTotalTradeFeeInBtcAsString(totalTradeAmount, totalTradeFee);
    }

    public String getTotalTradeFeeInBsq(Coin totalTradeAmount) {
        return dataModel.getVolume(totalTradeAmount, ""USD"")
                .filter(v -> v.getValue() > 0)
                .map(tradeAmountVolume -> {
                    Coin totalTradeFee = dataModel.getTotalTradeFee(false);
                    Volume bsqVolumeInUsd = dataModel.getBsqVolumeInUsdWithAveragePrice(totalTradeFee); // with 4 decimal
                    return closedTradableFormatter.getTotalTradeFeeInBsqAsString(totalTradeFee,
                            tradeAmountVolume,
                            bsqVolumeInUsd);
                })
                .orElse("""");
    }
}",0,439 334 2000 378 2001 60 2002 62 395 2003 123 437 381 2004 2005 59 64 2006 439 2000 40 2002 2007 44 2004 2005 41 123 463 40 2007 41 59 467 46 2005 61 2005 59 125 2008 2009 40 2010 2011 41 123 450 2011 46 2012 40 41 59 125 2008 2013 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2014 40 2011 41 58 648 59 125 2008 2015 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2016 40 2011 41 58 648 59 125 2008 2017 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2018 40 2011 41 58 648 59 125 2008 2019 40 2010 2011 44 324 2020 41 123 450 2011 631 424 63 2005 46 2021 40 2011 44 2020 41 58 648 59 125 2008 2022 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2023 40 2011 41 58 648 59 125 2008 2024 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2025 40 2011 41 58 648 59 125 2008 2026 40 2010 2011 44 324 2020 41 123 450 2011 631 424 63 2005 46 2027 40 2011 44 2020 41 58 648 59 125 2008 2028 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2029 40 2011 41 58 648 59 125 2008 2030 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2031 40 2011 41 58 648 59 125 2008 2032 40 2010 2011 41 123 392 40 40 2011 631 424 41 41 123 2033 2034 61 2007 46 2035 40 2011 46 2036 40 41 41 59 2008 2037 61 2011 46 2036 40 41 46 2038 40 41 59 450 2039 46 2040 40 2034 44 2037 41 59 125 360 123 450 648 59 125 125 2008 2041 40 2010 2011 41 123 450 2042 46 2043 40 2011 46 2041 40 41 41 59 125 2008 2044 40 2010 2011 41 123 450 2011 631 424 63 2045 46 2046 40 2011 46 2047 40 41 46 2048 40 41 41 58 648 59 125 2008 2049 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2050 40 2011 41 58 648 59 125 621 621 621 439 2051 2052 40 41 123 450 2007 46 2053 40 41 59 125 439 2008 2054 40 2051 2055 41 123 450 2007 46 2056 40 2055 41 46 2057 40 2058 45 62 2005 46 2059 40 2055 44 2058 41 41 46 2060 40 648 41 59 125 439 2061 60 2008 44 2008 62 2062 40 41 123 450 2005 46 2063 40 2007 46 2064 40 41 41 59 125 439 2008 2065 40 2051 2055 41 123 2051 2066 61 2007 46 2065 40 41 59 450 2005 46 2067 40 2055 44 2066 41 59 125 439 2008 2068 40 2051 2055 41 123 2051 2069 61 2007 46 2070 40 473 41 59 450 2005 46 2071 40 2055 44 2069 41 59 125 439 2008 2072 40 2051 2055 41 123 450 2007 46 2019 40 2055 44 648 41 46 2073 40 2074 45 62 2074 46 2075 40 41 62 1500 41 46 2076 40 2077 45 62 123 2051 2078 61 2007 46 2079 40 380 41 59 2080 2081 61 2007 46 2082 40 2078 41 59 621 450 2005 46 2083 40 2078 44 2077 44 2081 41 59 125 41 46 2084 40 648 41 59 125 125 
3444,Java,"                return new ListCell<>() {
                    @Override
                    protected void updateItem(TraderDataItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setText(item.getPaymentAccountPayload().getPaymentDetails());
                        } else {
                            setText(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 438 492 2002 40 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 46 2007 40 41 41 59 125 360 123 2008 40 424 41 59 125 125 125 59 
3441,Java,"@Slf4j
public class SignPaymentAccountsWindow extends Overlay<SignPaymentAccountsWindow> {

    private Label descriptionLabel;
    private ComboBox<PaymentMethod> paymentMethodComboBox;
    private CheckBox signAllCheckbox;
    private DatePicker datePicker;
    private InputTextField privateKey;
    private ListView<TraderDataItem> selectedPaymentAccountsList = new ListView<>();
    private final AccountAgeWitnessService accountAgeWitnessService;
    private final ArbitratorManager arbitratorManager;
    private final ArbitrationManager arbitrationManager;
    private final MediationManager mediationManager;
    private final String appName;
    private final boolean useDevPrivilegeKeys;


    @Inject
    public SignPaymentAccountsWindow(AccountAgeWitnessService accountAgeWitnessService,
                                     ArbitratorManager arbitratorManager,
                                     ArbitrationManager arbitrationManager,
                                     MediationManager mediationManager,
                                     @Named(Config.APP_NAME) String appName,
                                     @Named(Config.USE_DEV_PRIVILEGE_KEYS) boolean useDevPrivilegeKeys) {
        this.accountAgeWitnessService = accountAgeWitnessService;
        this.arbitratorManager = arbitratorManager;
        this.arbitrationManager = arbitrationManager;
        this.mediationManager = mediationManager;
        this.appName = appName;
        this.useDevPrivilegeKeys = useDevPrivilegeKeys;
    }

    @Override
    public void show() {
        width = 1000;
        rowIndex = -1;
        createGridPane();

        // We want to have more space to read list entries... initial screen does not look so nice now, but
        // dynamically updating height of window is a bit tricky.... @christoph feel free to improve if you like...
        gridPane.setPrefHeight(600);

        gridPane.getColumnConstraints().get(1).setHgrow(Priority.NEVER);

        headLine(Res.get(""popup.accountSigning.selectAccounts.headline""));
        type = Type.Attention;

        addHeadLine();
        addSelectAccountsContent();
        addButtons();
        applyStyles();

        display();
    }

    private void addSelectAccountsContent() {
        descriptionLabel = addMultilineLabel(gridPane, ++rowIndex,
                Res.get(""popup.accountSigning.selectAccounts.description""));

        paymentMethodComboBox = addComboBox(gridPane, ++rowIndex, Res.get(""shared.selectPaymentMethod""));
        paymentMethodComboBox.setVisibleRowCount(11);
        paymentMethodComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(PaymentMethod paymentMethod) {
                return paymentMethod != null ? Res.get(paymentMethod.getId()) : """";
            }

            @Override
            public PaymentMethod fromString(String s) {
                return null;
            }
        });


        paymentMethodComboBox.setItems(FXCollections.observableArrayList(getPaymentMethods()));
        paymentMethodComboBox.setOnAction(e -> updateAccountSelectionState());

        signAllCheckbox = addLabelCheckBox(gridPane, ++rowIndex, Res.get(""popup.accountSigning.selectAccounts.signAll""));
        GridPane.setHalignment(signAllCheckbox, HPos.LEFT);
        signAllCheckbox.selectedProperty().addListener((observable, oldValue, newValue) -> {
            paymentMethodComboBox.setDisable(newValue);
            updateAccountSelectionState();
        });

        datePicker = addTopLabelDatePicker(gridPane, ++rowIndex,
                Res.get(""popup.accountSigning.selectAccounts.datePicker""),
                0).second;
        datePicker.setOnAction(e -> updateAccountSelectionState());
        datePicker.setValue(Instant.ofEpochMilli(new Date().getTime()).minus(60, ChronoUnit.DAYS)
                .atZone(ZoneId.systemDefault()).toLocalDate());
    }

    private List<PaymentMethod> getPaymentMethods() {
        return PaymentMethod.getPaymentMethods().stream()
                .filter(PaymentMethod::isFiat)
                .filter(PaymentMethod::hasChargebackRisk)
                .collect(Collectors.toList());
    }

    private void addECKeyField() {
        privateKey = addInputTextField(gridPane, ++rowIndex, Res.get(""popup.accountSigning.signAccounts.ECKey""));
        GridPane.setVgrow(privateKey, Priority.ALWAYS);
        GridPane.setValignment(privateKey, VPos.TOP);
    }

    private void updateAccountSelectionState() {
        actionButton.setDisable((!signAllCheckbox.isSelected() && paymentMethodComboBox.getSelectionModel().isEmpty()) ||
                datePicker.getValue() == null
        );
    }

    private void removeContent() {
        removeRowsFromGridPane(gridPane, 2, 3);
        rowIndex = 1;
    }

    private void addSelectedAccountsContent() {
        removeContent();
        Tuple3<Label, ListView<TraderDataItem>, VBox> selectedPaymentAccountsTuple =
                addTopLabelListView(gridPane,
                        ++rowIndex, Res.get(""popup.accountSigning.confirmSelectedAccounts.headline""));
        GridPane.setRowSpan(selectedPaymentAccountsTuple.third, 2);
        selectedPaymentAccountsList = selectedPaymentAccountsTuple.second;
        ObservableList<Dispute> disputesAsObservableList = useDevPrivilegeKeys ?
                mediationManager.getDisputesAsObservableList()
                : arbitrationManager.getDisputesAsObservableList();
        long safeDate = datePicker.getValue().atStartOfDay().toEpochSecond(ZoneOffset.UTC) * 1000;
        List<TraderDataItem> traderDataItemList;
        StringBuilder sb = new StringBuilder(""Summary for "").append(appName).append(""\n"");
        if (signAllCheckbox.isSelected()) {
            traderDataItemList = new ArrayList<>();
            getPaymentMethods().forEach(paymentMethod -> {
                List<TraderDataItem> list = accountAgeWitnessService.getTraderPaymentAccounts(
                        safeDate,
                        paymentMethod,
                        disputesAsObservableList);
                traderDataItemList.addAll(list);

                sb.append(""\nPayment method: "").append(Res.get(paymentMethod.getId()))
                        .append("" (No. of signed accounts: "").append(list.size()).append("")\n"");
                list.forEach(traderDataItem -> {
                    sb.append(""Account created: "")
                            .append(FormattingUtils.formatDateTime(new Date(traderDataItem.getAccountAgeWitness().getDate()), true))
                            .append("" Account: "")
                            .append(traderDataItem.getPaymentAccountPayload().getPaymentDetails()).append(""\n"");
                });
            });
            sb.append(""\nTotal accounts signed: "").append(traderDataItemList.size());
        } else {
            PaymentMethod paymentMethod = paymentMethodComboBox.getSelectionModel().getSelectedItem();
            traderDataItemList = accountAgeWitnessService.getTraderPaymentAccounts(
                    safeDate,
                    paymentMethod,
                    disputesAsObservableList);
            sb.append(""\nPayment method: "").append(Res.get(paymentMethod.getId()))
                    .append("" (No. of signed accounts: "").append(traderDataItemList.size()).append("")\n"");
            traderDataItemList.forEach(traderDataItem -> {
                sb.append(""Account created: "")
                        .append(FormattingUtils.formatDateTime(new Date(traderDataItem.getAccountAgeWitness().getDate()), true))
                        .append("" Account: "")
                        .append(traderDataItem.getPaymentAccountPayload().getPaymentDetails()).append(""\n"");
            });
        }
        log.info(sb.toString());
        Utilities.copyToClipboard(sb.toString());

        selectedPaymentAccountsList.setItems(FXCollections.observableArrayList(traderDataItemList));

        headLineLabel.setText(Res.get(""popup.accountSigning.confirmSelectedAccounts.headline""));
        descriptionLabel.setText(Res.get(""popup.accountSigning.confirmSelectedAccounts.description"",
                selectedPaymentAccountsList.getItems().size()));
        ((AutoTooltipButton) actionButton).updateText(Res.get(""popup.accountSigning.confirmSelectedAccounts.button""));

        updateAccountSelectionState();

        actionButton.setOnAction(e -> addAccountsToSignContent());

        selectedPaymentAccountsList.setCellFactory(new Callback<>() {
            @Override
            public ListCell<TraderDataItem> call(
                    ListView<TraderDataItem> param) {
                return new ListCell<>() {
                    @Override
                    protected void updateItem(TraderDataItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setText(item.getPaymentAccountPayload().getPaymentDetails());
                        } else {
                            setText(null);
                        }
                    }
                };
            }
        });
    }

    private void addAccountsToSignContent() {
        removeContent();
        addECKeyField();

        headLineLabel.setText(Res.get(""popup.accountSigning.signAccounts.headline""));
        descriptionLabel.setText(Res.get(""popup.accountSigning.signAccounts.description"", selectedPaymentAccountsList.getItems().size()));
        ((AutoTooltipButton) actionButton).updateText(Res.get(""popup.accountSigning.signAccounts.button""));
        actionButton.setOnAction(a -> {
            ECKey arbitratorKey = arbitratorManager.getRegistrationKey(privateKey.getText());
            if (arbitratorKey != null) {
                String arbitratorPubKeyAsHex = Utils.HEX.encode(arbitratorKey.getPubKey());
                boolean isKeyValid = arbitratorManager.isPublicKeyInList(arbitratorPubKeyAsHex);
                if (isKeyValid) {
                    selectedPaymentAccountsList.getItems().forEach(item ->
                            accountAgeWitnessService.arbitratorSignAccountAgeWitness(item.getTradeAmount(),
                                    item.getAccountAgeWitness(),
                                    arbitratorKey,
                                    item.getPeersPubKey()));
                    addSuccessContent();
                }
            } else {
                new Popup().error(Res.get(""popup.accountSigning.signAccounts.ECKey.error"")).onClose(this::hide).show();
            }

        });
    }

    private void addSuccessContent() {
        removeContent();
        GridPane.setVgrow(descriptionLabel, Priority.ALWAYS);
        GridPane.setValignment(descriptionLabel, VPos.TOP);

        closeButton.setVisible(false);
        closeButton.setManaged(false);
        headLineLabel.setText(Res.get(""popup.accountSigning.success.headline""));
        descriptionLabel.setText(Res.get(""popup.accountSigning.success.description"", selectedPaymentAccountsList.getItems().size()));
        ((AutoTooltipButton) actionButton).updateText(Res.get(""shared.ok""));
        actionButton.setOnAction(a -> hide());
    }

    @Override
    protected void addButtons() {

        Tuple2<Button, Button> buttonTuple = add2ButtonsAfterGroup(gridPane, ++rowIndex,
                Res.get(""popup.accountSigning.selectAccounts.headline""), Res.get(""shared.cancel""));

        actionButton = buttonTuple.first;
        actionButton.setDisable(true);
        actionButton.setOnAction(e -> addSelectedAccountsContent());

        closeButton = (AutoTooltipButton) buttonTuple.second;
        closeButton.setOnAction(e -> hide());

    }
}",0,64 2000 439 334 2001 378 2002 60 2001 62 123 437 2003 2004 59 437 2005 60 2006 62 2007 59 437 2008 2009 59 437 2010 2011 59 437 2012 2013 59 437 2014 60 2015 62 2016 61 418 2014 60 62 40 41 59 437 381 2017 2018 59 437 381 2019 2020 59 437 381 2021 2022 59 437 381 2023 2024 59 437 381 2025 2026 59 437 381 324 2027 59 64 2028 439 2001 40 2017 2018 44 2019 2020 44 2021 2022 44 2023 2024 44 64 2029 40 2030 46 2031 41 2025 2026 44 64 2029 40 2030 46 2032 41 324 2027 41 123 467 46 2018 61 2018 59 467 46 2020 61 2020 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2026 61 2026 59 467 46 2027 61 2027 59 125 64 2033 439 492 2034 40 41 123 2035 61 1504 59 2036 61 45 1501 59 2037 40 41 59 621 621 2038 46 2039 40 1504 41 59 2038 46 2040 40 41 46 2041 40 1501 41 46 2042 40 2043 46 2044 41 59 2045 40 2046 46 2041 40 648 41 41 59 2047 61 2048 46 2049 59 2050 40 41 59 2051 40 41 59 2052 40 41 59 2053 40 41 59 2054 40 41 59 125 437 492 2055 40 41 123 2004 61 2056 40 2057 44 637 2058 44 2059 46 2060 40 648 41 41 59 2007 61 2061 40 2057 44 637 2058 44 2059 46 2060 40 648 41 41 59 2007 46 2062 40 1503 41 59 2007 46 2063 40 418 2064 60 62 40 41 123 64 2033 439 2025 2065 40 2006 2066 41 123 450 2066 631 424 63 2059 46 2060 40 2066 46 2067 40 41 41 58 648 59 125 64 2033 439 2006 2068 40 2025 2069 41 123 450 424 59 125 125 41 59 2007 46 2070 40 2071 46 2072 40 2073 40 41 41 41 59 2007 46 2074 40 2075 45 62 2076 40 41 41 59 2009 61 2077 40 2057 44 637 2058 44 2059 46 2060 40 648 41 41 59 2078 46 2079 40 2009 44 2080 46 2081 41 59 2009 46 2082 40 41 46 2083 40 40 2084 44 2085 44 2086 41 45 62 123 2007 46 2087 40 2086 41 59 2076 40 41 59 125 41 59 2011 61 2088 40 2057 44 637 2058 44 2059 46 2060 40 648 41 44 1500 41 46 2089 59 2011 46 2074 40 2075 45 62 2076 40 41 41 59 2011 46 2090 40 2091 46 2092 40 418 2093 40 41 46 2094 40 41 41 46 2095 40 1503 44 2096 46 2097 41 46 2098 40 2099 46 2100 40 41 41 46 2101 40 41 41 59 125 437 2102 60 2006 62 2103 40 41 123 450 2006 46 2103 40 41 46 2104 40 41 46 2105 40 2006 58 58 2106 41 46 2105 40 2006 58 58 2107 41 46 2108 40 2109 46 2110 40 41 41 59 125 437 492 2111 40 41 123 2013 61 2112 40 2113 44 637 2114 44 2115 46 2116 40 648 41 41 59 2117 46 2118 40 2013 44 2119 46 2120 41 59 2117 46 2121 40 2013 44 2122 46 2123 41 59 125 437 492 2124 40 41 123 2125 46 2126 40 40 33 2009 46 2127 40 41 605 2007 46 2128 40 41 46 2129 40 41 41 606 2011 46 2130 40 41 614 424 41 59 125 437 492 2131 40 41 123 2132 40 2133 44 1502 44 1502 41 59 2134 61 1501 59 125 437 492 2135 40 41 123 2131 40 41 59 2136 60 2003 44 2014 60 2015 62 44 2137 62 2138 61 2139 40 2140 44 637 2141 44 2142 46 2143 40 648 41 41 59 2144 46 2145 40 2138 46 2146 44 1502 41 59 2016 61 2138 46 2147 59 2148 60 2149 62 2150 61 2027 63 2024 46 2151 40 41 58 2022 46 2151 40 41 59 413 2152 61 2011 46 2153 40 41 46 2154 40 41 46 2155 40 2156 46 2157 41 42 1504 59 2102 60 2015 62 2158 59 2159 2160 61 418 2159 40 648 41 46 2161 40 2026 41 46 2161 40 648 41 59 392 40 2009 46 2162 40 41 41 123 2158 61 418 2163 60 62 40 41 59 2103 40 41 46 2164 40 2165 45 62 123 2102 60 2015 62 411 61 2018 46 2166 40 2152 44 2165 44 2150 41 59 2158 46 2167 40 411 41 59 2160 46 2161 40 648 41 46 2161 40 2142 46 2143 40 2165 46 2168 40 41 41 41 46 2161 40 648 41 46 2161 40 411 46 2169 40 41 41 46 2161 40 648 41 59 411 46 2164 40 2170 45 62 123 2160 46 2161 40 648 41 46 2161 40 2171 46 2172 40 418 2173 40 2170 46 2174 40 41 46 2175 40 41 41 44 473 41 41 46 2161 40 648 41 46 2161 40 2170 46 2176 40 41 46 2177 40 41 41 46 2161 40 648 41 59 125 41 59 125 41 59 2160 46 2161 40 648 41 46 2161 40 2158 46 2178 40 41 41 59 125 360 123 2006 2179 61 2007 46 2180 40 41 46 2181 40 41 59 2158 61 2018 46 2182 40 2152 44 2179 44 2150 41 59 2160 46 2161 40 648 41 46 2161 40 2142 46 2143 40 2179 46 2183 40 41 41 41 46 2161 40 648 41 46 2161 40 2158 46 2184 40 41 41 46 2161 40 648 41 59 2158 46 2185 40 2186 45 62 123 2160 46 2161 40 648 41 46 2161 40 2187 46 2188 40 418 2189 40 2186 46 2190 40 41 46 2191 40 41 41 44 473 41 41 46 2161 40 648 41 46 2161 40 2186 46 2192 40 41 46 2193 40 41 41 46 2161 40 648 41 59 125 41 59 125 2194 46 2195 40 2160 46 2196 40 41 41 59 2197 46 2198 40 2160 46 2196 40 41 41 59 2016 46 2199 40 2200 46 2201 40 2158 41 41 59 2202 46 2203 40 2142 46 2143 40 648 41 41 59 2004 46 2203 40 2142 46 2143 40 648 44 2016 46 2204 40 41 46 2205 40 41 41 41 59 40 40 2206 41 2207 41 46 2208 40 2142 46 2143 40 648 41 41 59 2124 40 41 59 2207 46 2209 40 2210 45 62 2211 40 41 41 59 2016 46 2212 40 418 2213 60 62 40 41 123 64 2033 439 2214 60 2015 62 2215 40 2014 60 2015 62 2216 41 123 450 418 2214 60 62 40 41 123 64 2033 438 492 2217 40 2015 2218 44 324 362 41 123 463 46 2217 40 2218 44 362 41 59 392 40 2218 631 424 605 33 362 41 123 2203 40 2218 46 2219 40 41 46 2220 40 41 41 59 125 360 123 2203 40 424 41 59 125 125 125 59 125 125 41 59 125 437 492 2221 40 41 123 2131 40 41 59 2111 40 41 59 2222 46 2223 40 2224 46 2225 40 648 41 41 59 2004 46 2223 40 2224 46 2225 40 648 44 2016 46 2226 40 41 46 2227 40 41 41 41 59 40 40 2228 41 2229 41 46 2230 40 2224 46 2225 40 648 41 41 59 2229 46 2231 40 2232 45 62 123 2233 2234 61 2020 46 2235 40 2013 46 2236 40 41 41 59 392 40 2234 631 424 41 123 2025 2237 61 2238 46 2239 46 2240 40 2234 46 2241 40 41 41 59 324 2242 61 2020 46 2243 40 2237 41 59 392 40 2242 41 123 2016 46 2226 40 41 46 2244 40 2245 45 62 2018 46 2246 40 2245 46 2247 40 41 44 2245 46 2248 40 41 44 2234 44 2245 46 2249 40 41 41 41 59 2250 40 41 59 125 125 360 123 418 2251 40 41 46 371 40 2224 46 2225 40 648 41 41 46 2252 40 467 58 58 2253 41 46 2034 40 41 59 125 125 41 59 125 437 492 2254 40 41 123 2131 40 41 59 2255 46 2256 40 2004 44 2257 46 2258 41 59 2255 46 2259 40 2004 44 2260 46 2261 41 59 2262 46 2263 40 380 41 59 2262 46 2264 40 380 41 59 2265 46 2266 40 2267 46 2268 40 648 41 41 59 2004 46 2266 40 2267 46 2268 40 648 44 2016 46 2269 40 41 46 2270 40 41 41 41 59 40 40 2271 41 2272 41 46 2273 40 2267 46 2268 40 648 41 41 59 2272 46 2274 40 2275 45 62 2276 40 41 41 59 125 64 2033 438 492 2277 40 41 123 2278 60 2279 44 2279 62 2280 61 2281 40 2282 44 637 2283 44 2284 46 2285 40 648 41 44 2284 46 2285 40 648 41 41 59 2286 61 2280 46 2287 59 2286 46 2288 40 473 41 59 2286 46 2289 40 2290 45 62 2135 40 41 41 59 2291 61 40 2292 41 2280 46 2293 59 2291 46 2289 40 2290 45 62 2294 40 41 41 59 125 125 
3443,Java,"        selectedPaymentAccountsList.setCellFactory(new Callback<>() {
            @Override
            public ListCell<TraderDataItem> call(
                    ListView<TraderDataItem> param) {
                return new ListCell<>() {
                    @Override
                    protected void updateItem(TraderDataItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setText(item.getPaymentAccountPayload().getPaymentDetails());
                        } else {
                            setText(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 62 2006 40 2007 60 2005 62 2008 41 123 450 418 2004 60 62 40 41 123 64 2003 438 492 2009 40 2005 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 40 2010 46 2012 40 41 46 2013 40 41 41 59 125 360 123 2014 40 424 41 59 125 125 125 59 125 125 41 59 
3297,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setText(DisplayUtils.formatDateTime(item.getBlindVoteDate()));
                                } else {
                                    setText("""");
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2006 46 2007 40 2004 46 2008 40 41 41 41 59 125 360 123 2009 40 648 41 59 125 125 125 59 
3296,Java,"                new Callback<>() {
                    @Override
                    public TableCell<VoteListItem, VoteListItem> call(
                            TableColumn<VoteListItem, VoteListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setText(DisplayUtils.formatDateTime(item.getBlindVoteDate()));
                                } else {
                                    setText("""");
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 2010 46 2011 40 2008 46 2012 40 41 41 41 59 125 360 123 2013 40 648 41 59 125 125 125 59 125 125 41 59 
3299,Java,"                        return new TableCell<>() {
                            private Label icon;

                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    Tuple2<AwesomeIcon, String> iconStyleTuple = item.getIconStyleTuple();
                                    icon = new Label();
                                    AwesomeDude.setIcon(icon, iconStyleTuple.first);
                                    icon.getStyleClass().add(iconStyleTuple.second);
                                    setGraphic(icon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 60 2008 44 2009 62 2010 61 2006 46 2011 40 41 59 2002 61 418 2001 40 41 59 2012 46 2013 40 2002 44 2010 46 2014 41 59 2002 46 2015 40 41 46 2016 40 2010 46 2017 41 59 2018 40 2002 41 59 125 360 123 2019 40 424 41 59 125 125 125 59 
3300,Java,"                new Callback<>() {
                    @Override
                    public TableCell<VoteListItem, VoteListItem> call(
                            TableColumn<VoteListItem, VoteListItem> column) {
                        return new TableCell<>() {

                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String transactionId = item.getBlindVoteTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> openTxInBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 40 2010 41 41 59 2008 46 2017 40 418 2018 40 2019 46 2020 40 648 44 2012 41 41 41 59 2021 40 2008 41 59 125 360 123 2022 40 424 41 59 392 40 2008 631 424 41 2008 46 2023 40 424 41 59 125 125 125 59 125 125 41 59 
3302,Java,"                new Callback<>() {
                    @Override
                    public TableCell<VoteListItem, VoteListItem> call(
                            TableColumn<VoteListItem, VoteListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getMerit());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
4168,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    var isSellOffer = item.getOffer().getDirection() == OfferDirection.SELL;
                                    var deposit = isSellOffer ? item.getOffer().getBuyerSecurityDeposit() :
                                            item.getOffer().getSellerSecurityDeposit();
                                    if (deposit == null) {
                                        setText(Res.get(""shared.na""));
                                        setGraphic(null);
                                    } else {
                                        setText("""");
                                        setGraphic(new ColoredDecimalPlacesWithZerosText(model.formatDepositString(
                                                deposit, item.getOffer().getAmount().getValue()),
                                                GUIUtil.AMOUNT_DECIMALS_WITH_ZEROS));
                                    }
                                } else {
                                    setText("""");
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 490 2005 61 2004 46 2006 40 41 46 2007 40 41 614 2008 46 2009 59 490 2010 61 2005 63 2004 46 2006 40 41 46 2011 40 41 58 2004 46 2006 40 41 46 2012 40 41 59 392 40 2010 614 424 41 123 2013 40 2014 46 2015 40 648 41 41 59 2016 40 424 41 59 125 360 123 2017 40 648 41 59 2018 40 418 2019 40 2020 46 2021 40 2010 44 2004 46 2006 40 41 46 2022 40 41 46 2023 40 41 41 44 2024 46 2025 41 41 59 125 125 360 123 2026 40 648 41 59 2027 40 424 41 59 125 125 125 59 
4158,Java,"    static class CurrencyStringConverter extends StringConverter<TradeCurrency> {
        private final ComboBox<TradeCurrency> comboBox;

        CurrencyStringConverter(ComboBox<TradeCurrency> comboBox) {
            this.comboBox = comboBox;
        }

        @Override
        public String toString(TradeCurrency item) {
            return item != null ? asString(item) : """";
        }

        @Override
        public TradeCurrency fromString(String query) {
            if (comboBox.getItems().isEmpty())
                return null;
            if (query.isEmpty())
                return specialShowAllItem();
            return comboBox.getItems().stream().
                    filter(item -> asString(item).equals(query)).
                    findAny().orElse(null);
        }

        private String asString(TradeCurrency item) {
            if (isSpecialShowAllItem(item))
                return Res.get(GUIUtil.SHOW_ALL_FLAG);
            if (isSpecialEditItem(item))
                return Res.get(GUIUtil.EDIT_FLAG);
            return item.getCode() + ""  -  "" + item.getName();
        }

        private boolean isSpecialShowAllItem(TradeCurrency item) {
            return item.getCode().equals(GUIUtil.SHOW_ALL_FLAG);
        }

        private boolean isSpecialEditItem(TradeCurrency item) {
            return item.getCode().equals(GUIUtil.EDIT_FLAG);
        }

        private TradeCurrency specialShowAllItem() {
            return comboBox.getItems().get(SHOW_ALL);
        }
    }",0,457 334 2000 378 2001 60 2002 62 123 437 381 2003 60 2002 62 2004 59 2000 40 2003 60 2002 62 2004 41 123 467 46 2004 61 2004 59 125 64 2005 439 2006 2007 40 2002 2008 41 123 450 2008 631 424 63 2009 40 2008 41 58 648 59 125 64 2005 439 2002 2010 40 2006 2011 41 123 392 40 2004 46 2012 40 41 46 2013 40 41 41 450 424 59 392 40 2011 46 2013 40 41 41 450 2014 40 41 59 450 2004 46 2012 40 41 46 2015 40 41 46 2016 40 2008 45 62 2017 40 2008 41 46 2018 40 2011 41 41 46 2019 40 41 46 2020 40 424 41 59 125 437 2006 2021 40 2002 2008 41 123 392 40 2022 40 2008 41 41 450 2023 46 2024 40 2025 46 2026 41 59 392 40 2027 40 2008 41 41 450 2023 46 2024 40 2025 46 2028 41 59 450 2008 46 2029 40 41 43 648 43 2008 46 2030 40 41 59 125 437 324 2031 40 2002 2008 41 123 450 2008 46 2032 40 41 46 2033 40 2034 46 2035 41 59 125 437 324 2036 40 2002 2008 41 123 450 2008 46 2037 40 41 46 2038 40 2039 46 2040 41 59 125 437 2002 2041 40 41 123 450 2004 46 2042 40 41 46 2043 40 2044 41 59 125 125 
3304,Java,"                new Callback<>() {
                    @Override
                    public TableCell<VoteListItem, VoteListItem> call(
                            TableColumn<VoteListItem, VoteListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getStake());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
5464,Java,"                    TxBroadcaster.Callback callback = new TxBroadcaster.Callback() {
                        @Override
                        public void onSuccess(@Nullable Transaction result) {
                            log.info(""onSuccess"");
                            UserThread.execute(() -> {
                                String txId = result != null ? result.getTxId().toString() : ""null"";
                                new Popup().information(""Transaction successfully published. Transaction ID: "" + txId).show();
                            });
                        }
                        @Override
                        public void onFailure(TxBroadcastException exception) {
                            log.error(exception.toString());
                            UserThread.execute(() -> new Popup().warning(exception.toString()).show());
                        }
                    };",0,2000 46 2001 2002 61 418 2000 46 2001 40 41 123 64 2003 439 492 2004 40 64 2005 2006 2007 41 123 2008 46 2009 40 648 41 59 2010 46 2011 40 40 41 45 62 123 2012 2013 61 2007 631 424 63 2007 46 2014 40 41 46 2015 40 41 58 648 59 418 2016 40 41 46 2017 40 648 43 2013 41 46 2018 40 41 59 125 41 59 125 64 2003 439 492 2019 40 2020 2021 41 123 2022 46 371 40 2021 46 2023 40 41 41 59 2024 46 2025 40 40 41 45 62 418 2026 40 41 46 494 40 2021 46 2023 40 41 41 46 2027 40 41 41 59 125 125 59 
4161,Java,"                new Callback<>() {

                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            final ImageView iconView = new ImageView();
                            final AutoTooltipButton button = new AutoTooltipButton();
                            OfferFilterService.Result canTakeOfferResult = null;

                            {
                                button.setGraphic(iconView);
                                button.setMinWidth(200);
                                button.setMaxWidth(Double.MAX_VALUE);
                                button.setGraphicTextGap(10);
                            }

                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                TableRow<OfferBookListItem> tableRow = getTableRow();
                                if (item != null && !empty) {
                                    Offer offer = item.getOffer();
                                    boolean myOffer = model.isMyOffer(offer);

                                    if (tableRow != null) {
                                        canTakeOfferResult = model.offerFilterService.canTakeOffer(offer, false);
                                        tableRow.setOpacity(canTakeOfferResult.isValid() || myOffer ? 1 : 0.4);

                                        if (myOffer) {
                                            button.setDefaultButton(false);
                                            tableRow.setOnMousePressed(null);
                                        } else if (canTakeOfferResult.isValid()) {
                                            // set first row button as default
                                            button.setDefaultButton(getIndex() == 0);
                                            tableRow.setOnMousePressed(null);
                                        } else {
                                            button.setDefaultButton(false);
                                            tableRow.setOnMousePressed(e -> {
                                                // ugly hack to get the icon clickable when deactivated
                                                if (!(e.getTarget() instanceof ImageView || e.getTarget() instanceof Canvas))
                                                    onShowInfo(offer, canTakeOfferResult);
                                            });
                                        }
                                    }

                                    String title;
                                    if (myOffer) {
                                        iconView.setId(""image-remove"");
                                        title = Res.get(""shared.remove"");
                                        button.setId(null);
                                        button.setStyle(CssTheme.isDarkTheme() ? ""-fx-text-fill: white"" : ""-fx-text-fill: #444444"");
                                        button.setOnAction(e -> onRemoveOpenOffer(offer));
                                    } else {
                                        boolean isSellOffer = offer.getDirection() == OfferDirection.SELL;
                                        iconView.setId(isSellOffer ? ""image-buy-white"" : ""image-sell-white"");
                                        button.setId(isSellOffer ? ""buy-button"" : ""sell-button"");
                                        button.setStyle(""-fx-text-fill: white"");
                                        if (isSellOffer) {
                                            title = CurrencyUtil.isFiatCurrency(offer.getCurrencyCode()) ?
                                                    Res.get(""offerbook.takeOfferToBuy"", offer.getBaseCurrencyCode()) :
                                                    Res.get(""offerbook.takeOfferToSell"", offer.getCurrencyCode());
                                        } else {
                                            title = CurrencyUtil.isFiatCurrency(offer.getCurrencyCode()) ?
                                                    Res.get(""offerbook.takeOfferToSell"", offer.getBaseCurrencyCode()) :
                                                    Res.get(""offerbook.takeOfferToBuy"", offer.getCurrencyCode());
                                        }
                                        button.setTooltip(new Tooltip(Res.get(""offerbook.takeOfferButton.tooltip"", model.getDirectionLabelTooltip(offer))));
                                        button.setOnAction(e -> onTakeOffer(offer));
                                    }

                                    if (!myOffer) {
                                        if (canTakeOfferResult == null) {
                                            canTakeOfferResult = model.offerFilterService.canTakeOffer(offer, false);
                                        }

                                        if (!canTakeOfferResult.isValid()) {
                                            button.setOnAction(e -> onShowInfo(offer, canTakeOfferResult));
                                        }
                                    }

                                    button.updateText(title);
                                    setPadding(new Insets(0, 15, 0, 0));
                                    setGraphic(button);
                                } else {
                                    setGraphic(null);
                                    button.setOnAction(null);
                                    if (tableRow != null) {
                                        tableRow.setOpacity(1);
                                        tableRow.setOnMousePressed(null);
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 381 2007 2008 61 418 2007 40 41 59 381 2009 2010 61 418 2009 40 41 59 2011 46 2012 2013 61 424 59 123 2010 46 2014 40 2008 41 59 2010 46 2015 40 1504 41 59 2010 46 2016 40 2017 46 2018 41 59 2010 46 2019 40 1502 41 59 125 64 2001 439 492 2020 40 381 2003 2021 44 324 362 41 123 463 46 2020 40 2021 44 362 41 59 2022 60 2003 62 2023 61 2024 40 41 59 392 40 2021 631 424 605 33 362 41 123 2025 2026 61 2021 46 2027 40 41 59 324 2028 61 2029 46 2030 40 2026 41 59 392 40 2023 631 424 41 123 2013 61 2029 46 2031 46 2032 40 2026 44 380 41 59 2023 46 2033 40 2013 46 2034 40 41 606 2028 63 1501 58 1499 41 59 392 40 2028 41 123 2010 46 2035 40 380 41 59 2023 46 2036 40 424 41 59 125 360 392 40 2013 46 2034 40 41 41 123 621 2010 46 2037 40 2038 40 41 614 1500 41 59 2023 46 2039 40 424 41 59 125 360 123 2010 46 2040 40 380 41 59 2023 46 2041 40 2042 45 62 123 621 392 40 33 40 2042 46 2043 40 41 402 2007 606 2042 46 2043 40 41 402 2044 41 41 2045 40 2026 44 2013 41 59 125 41 59 125 125 2046 2047 59 392 40 2028 41 123 2008 46 2048 40 648 41 59 2047 61 2049 46 2050 40 648 41 59 2010 46 2048 40 424 41 59 2010 46 2051 40 2052 46 2053 40 41 63 648 58 648 41 59 2010 46 2054 40 2055 45 62 2056 40 2026 41 41 59 125 360 123 324 2057 61 2026 46 2058 40 41 614 2059 46 2060 59 2008 46 2061 40 2057 63 648 58 648 41 59 2010 46 2061 40 2057 63 648 58 648 41 59 2010 46 2062 40 648 41 59 392 40 2057 41 123 2047 61 2063 46 2064 40 2026 46 2065 40 41 41 63 2066 46 2067 40 648 44 2026 46 2068 40 41 41 58 2066 46 2067 40 648 44 2026 46 2065 40 41 41 59 125 360 123 2047 61 2069 46 2070 40 2026 46 2071 40 41 41 63 2072 46 2073 40 648 44 2026 46 2074 40 41 41 58 2072 46 2073 40 648 44 2026 46 2071 40 41 41 59 125 2010 46 2075 40 418 2076 40 2077 46 2078 40 648 44 2029 46 2079 40 2026 41 41 41 41 59 2010 46 2080 40 2081 45 62 2082 40 2026 41 41 59 125 392 40 33 2028 41 123 392 40 2013 614 424 41 123 2013 61 2029 46 2083 46 2084 40 2026 44 380 41 59 125 392 40 33 2013 46 2085 40 41 41 123 2010 46 2086 40 2087 45 62 2088 40 2026 44 2013 41 41 59 125 125 2010 46 2089 40 2047 41 59 2090 40 418 2091 40 1500 44 1503 44 1500 44 1500 41 41 59 2092 40 2010 41 59 125 360 123 2093 40 424 41 59 2010 46 2094 40 424 41 59 392 40 2023 631 424 41 123 2023 46 2095 40 1501 41 59 2023 46 2096 40 424 41 59 125 125 125 125 59 125 125 41 59 
4163,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(
                            TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new ColoredDecimalPlacesWithZerosText(model.getAmount(item), GUIUtil.AMOUNT_DECIMALS_WITH_ZEROS));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 418 2010 40 2011 46 2012 40 2008 41 44 2013 46 2014 41 41 59 360 2009 40 424 41 59 125 125 59 125 125 41 59 
4164,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new ColoredDecimalPlacesWithZerosText(model.getAmount(item), GUIUtil.AMOUNT_DECIMALS_WITH_ZEROS));
                                else
                                    setGraphic(null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 2005 40 418 2006 40 2007 46 2008 40 2004 41 44 2009 46 2010 41 41 59 360 2005 40 424 41 59 125 125 59 
4166,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (newItem != null && !empty) {
                                    final Offer offer = newItem.getOffer();
                                    final NodeAddress makersNodeAddress = offer.getOwnerNodeAddress();
                                    String role = Res.get(""peerInfoIcon.tooltip.maker"");
                                    int numTrades = model.getNumTrades(offer);
                                    PeerInfoIconTrading peerInfoIcon = new PeerInfoIconTrading(makersNodeAddress,
                                            role,
                                            numTrades,
                                            privateNotificationManager,
                                            offer,
                                            model.preferences,
                                            model.accountAgeWitnessService,
                                            useDevPrivilegeKeys);
                                    setGraphic(peerInfoIcon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 381 2005 2006 61 2004 46 2007 40 41 59 381 2008 2009 61 2006 46 2010 40 41 59 2011 2012 61 2013 46 2014 40 648 41 59 404 2015 61 2016 46 2017 40 2006 41 59 2018 2019 61 418 2018 40 2009 44 2012 44 2015 44 2020 44 2006 44 2016 46 2021 44 2016 46 2022 44 2023 41 59 2024 40 2019 41 59 125 360 123 2025 40 424 41 59 125 125 125 59 
4169,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(
                            TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty)
                                    setText(CurrencyUtil.getCurrencyPair(item.getOffer().getCurrencyCode()));
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 2010 46 2011 40 2008 46 2012 40 41 46 2013 40 41 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
4175,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<OfferBookListItem, OfferBookListItem> call(TableColumn<OfferBookListItem, OfferBookListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final OfferBookListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            var witnessAgeData = item.getWitnessAgeData(accountAgeWitnessService, signedWitnessService);
                            var label = witnessAgeData.isSigningRequired()
                                    ? new AccountStatusTooltipLabel(witnessAgeData, formatter)
                                    : new InfoAutoTooltipLabel(witnessAgeData.getDisplayString(), witnessAgeData.getIcon(), ContentDisplay.RIGHT, witnessAgeData.getInfo());
                            setGraphic(label);
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 490 2010 61 2009 46 2011 40 2012 44 2013 41 59 490 2014 61 2010 46 2015 40 41 63 418 2016 40 2010 44 2017 41 58 418 2018 40 2010 46 2019 40 41 44 2010 46 2020 40 41 44 2021 46 2022 44 2010 46 2023 40 41 41 59 2024 40 2014 41 59 125 360 123 2025 40 424 41 59 125 125 125 59 125 125 41 59 
5122,Java,"                                .onAction(() -> doWithdraw(sendersAmount, fee, new FutureCallback<>() {
                                    @Override
                                    public void onSuccess(@javax.annotation.Nullable Transaction transaction) {
                                        if (transaction != null) {
                                            String key = ""showTransactionSent"";
                                            if (DontShowAgainLookup.showAgain(key)) {
                                                new TxDetails(transaction.getTxId().toString(), withdrawToAddress, formatter.formatCoinWithCode(sendersAmount))
                                                        .dontShowAgainId(key)
                                                        .show();
                                            }
                                            log.debug(""onWithdraw onSuccess tx ID:{}"", transaction.getTxId().toString());
                                        } else {
                                            log.error(""onWithdraw transaction is null"");
                                        }

                                        List<Trade> trades = new ArrayList<>(tradeManager.getObservableList());
                                        trades.stream()
                                                .filter(Trade::isPayoutPublished)
                                                .forEach(trade -> btcWalletService.getAddressEntry(trade.getId(), AddressEntry.Context.TRADE_PAYOUT)
                                                        .ifPresent(addressEntry -> {
                                                            if (btcWalletService.getBalanceForAddress(addressEntry.getAddress()).isZero())
                                                                tradeManager.onTradeCompleted(trade);
                                                        }));
                                    }

                                    @Override
                                    public void onFailure(@NotNull Throwable t) {
                                        log.error(""onWithdraw onFailure"");
                                    }
                                }))",0,46 2000 40 40 41 45 62 2001 40 2002 44 2003 44 418 2004 60 62 40 41 123 64 2005 439 492 2006 40 64 2007 46 2008 46 2009 2010 2011 41 123 392 40 2011 631 424 41 123 2012 2013 61 648 59 392 40 2014 46 2015 40 2013 41 41 123 418 2016 40 2011 46 2017 40 41 46 2018 40 41 44 2019 44 2020 46 2021 40 2002 41 41 46 2022 40 2013 41 46 2023 40 41 59 125 2024 46 2025 40 648 44 2011 46 2026 40 41 46 2027 40 41 41 59 125 360 123 2028 46 371 40 648 41 59 125 2029 60 2030 62 2031 61 418 2032 60 62 40 2033 46 2034 40 41 41 59 2031 46 2035 40 41 46 2036 40 2030 58 58 2037 41 46 2038 40 2039 45 62 2040 46 2041 40 2039 46 2042 40 41 44 2043 46 2044 46 2045 41 46 2046 40 2047 45 62 123 392 40 2040 46 2048 40 2047 46 2049 40 41 41 46 2050 40 41 41 2033 46 2051 40 2039 41 59 125 41 41 59 125 64 2005 439 492 2052 40 64 2053 2054 2055 41 123 2056 46 371 40 648 41 59 125 125 41 41 
5125,Java,"                new Callback<>() {

                    @Override
                    public TableCell<WithdrawalListItem, WithdrawalListItem> call(TableColumn<WithdrawalListItem,
                            WithdrawalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic((item != null && !empty) ? item.getBalanceLabel() : null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 40 2008 631 424 605 33 362 41 63 2008 46 2010 40 41 58 424 41 59 125 125 59 125 125 41 59 
5127,Java,"                new Callback<>() {

                    @Override
                    public TableCell<WithdrawalListItem, WithdrawalListItem> call(TableColumn<WithdrawalListItem,
                            WithdrawalListItem> column) {
                        return new TableCell<>() {

                            CheckBox checkBox = new AutoTooltipCheckBox();

                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    checkBox.setOnAction(e -> {
                                        item.setSelected(checkBox.isSelected());
                                        selectForWithdrawal(item);

                                        // If all are selected we select useAllInputsRadioButton
                                        if (observableList.size() == selectedItems.size()) {
                                            inputsToggleGroup.selectToggle(useAllInputsRadioButton);
                                        } else {
                                            // We don't want to get deselected all when we activate the useCustomInputsRadioButton
                                            // so we temporarily disable the listener
                                            inputsToggleGroup.selectedToggleProperty().removeListener(inputsToggleGroupListener);
                                            inputsToggleGroup.selectToggle(useCustomInputsRadioButton);
                                            useAllInputs.set(false);
                                            inputsToggleGroup.selectedToggleProperty().addListener(inputsToggleGroupListener);
                                        }
                                    });
                                    setGraphic(checkBox);
                                    checkBox.setSelected(item.isSelected());
                                } else {
                                    checkBox.setOnAction(null);
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 61 418 2009 40 41 59 64 2001 439 492 2010 40 381 2003 2011 44 324 362 41 123 463 46 2010 40 2011 44 362 41 59 392 40 2011 631 424 605 33 362 41 123 2008 46 2012 40 2013 45 62 123 2011 46 2014 40 2008 46 2015 40 41 41 59 2016 40 2011 41 59 621 392 40 2017 46 2018 40 41 614 2019 46 2018 40 41 41 123 2020 46 2021 40 2022 41 59 125 360 123 621 621 2023 46 2024 40 41 46 2025 40 2026 41 59 2023 46 2027 40 2028 41 59 2029 46 2030 40 380 41 59 2023 46 2024 40 41 46 2031 40 2026 41 59 125 125 41 59 2032 40 2008 41 59 2008 46 2033 40 2011 46 2034 40 41 41 59 125 360 123 2008 46 2035 40 424 41 59 2036 40 424 41 59 125 125 125 59 125 125 41 59 
5034,Java,"                        return new TableCell<>() {

                            private AddressWithIconAndDirection field;

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String addressString = item.getAddressString();
                                    field = new AddressWithIconAndDirection(item.getDirection(), addressString,
                                            item.getReceived());
                                    field.setOnAction(event -> openAddressInBlockExplorer(item));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", addressString)));
                                    setGraphic(field);
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 59 2002 61 418 2001 40 2006 46 2010 40 41 44 2008 44 2006 46 2011 40 41 41 59 2002 46 2012 40 373 45 62 2013 40 2006 41 41 59 2002 46 2014 40 418 2015 40 2016 46 2017 40 648 44 2008 41 41 41 59 2018 40 2002 41 59 125 360 123 2019 40 424 41 59 392 40 2002 631 424 41 2002 46 2020 40 424 41 59 125 125 125 59 
5041,Java,"                new Callback<>() {

                    @Override
                    public TableCell<TransactionsListItem, TransactionsListItem> call(TableColumn<TransactionsListItem,
                            TransactionsListItem> column) {
                        return new TableCell<>() {

                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (item.getDetailsAvailable()) {
                                        hyperlinkWithIcon = new HyperlinkWithIcon(item.getDetails(), AwesomeIcon.INFO_SIGN);
                                        hyperlinkWithIcon.setOnAction(event -> openDetailPopup(item));
                                        hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                        setGraphic(hyperlinkWithIcon);
                                        // If details are available its a trade tx and we don't expect any dust attack tx
                                    } else {
                                        if (item.isDustAttackTx()) {
                                            hyperlinkWithIcon = new HyperlinkWithIcon(item.getDetails(), AwesomeIcon.WARNING_SIGN);
                                            hyperlinkWithIcon.setOnAction(event -> new Popup().warning(Res.get(""funds.tx.dustAttackTx.popup"")).show());
                                            setGraphic(hyperlinkWithIcon);
                                        } else {
                                            setGraphic(new AutoTooltipLabel(item.getDetails()));
                                        }
                                    }
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2010 46 2011 40 41 41 123 2008 61 418 2007 40 2010 46 2012 40 41 44 2013 46 2014 41 59 2008 46 2015 40 373 45 62 2016 40 2010 41 41 59 2008 46 2017 40 418 2018 40 2019 46 2020 40 648 41 41 41 59 2021 40 2008 41 59 621 125 360 123 392 40 2010 46 2022 40 41 41 123 2008 61 418 2007 40 2010 46 2023 40 41 44 2024 46 2025 41 59 2008 46 2026 40 373 45 62 418 2027 40 41 46 494 40 2028 46 2029 40 648 41 41 46 2030 40 41 41 59 2031 40 2008 41 59 125 360 123 2032 40 418 2033 40 2010 46 2034 40 41 41 41 59 125 125 125 360 123 2035 40 424 41 59 392 40 2008 631 424 41 2008 46 2036 40 424 41 59 125 125 125 59 125 125 41 59 
5128,Java,"                        return new TableCell<>() {

                            CheckBox checkBox = new AutoTooltipCheckBox();

                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    checkBox.setOnAction(e -> {
                                        item.setSelected(checkBox.isSelected());
                                        selectForWithdrawal(item);

                                        // If all are selected we select useAllInputsRadioButton
                                        if (observableList.size() == selectedItems.size()) {
                                            inputsToggleGroup.selectToggle(useAllInputsRadioButton);
                                        } else {
                                            // We don't want to get deselected all when we activate the useCustomInputsRadioButton
                                            // so we temporarily disable the listener
                                            inputsToggleGroup.selectedToggleProperty().removeListener(inputsToggleGroupListener);
                                            inputsToggleGroup.selectToggle(useCustomInputsRadioButton);
                                            useAllInputs.set(false);
                                            inputsToggleGroup.selectedToggleProperty().addListener(inputsToggleGroupListener);
                                        }
                                    });
                                    setGraphic(checkBox);
                                    checkBox.setSelected(item.isSelected());
                                } else {
                                    checkBox.setOnAction(null);
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 61 418 2003 40 41 59 64 2004 439 492 2005 40 381 2006 2007 44 324 362 41 123 463 46 2005 40 2007 44 362 41 59 392 40 2007 631 424 605 33 362 41 123 2002 46 2008 40 2009 45 62 123 2007 46 2010 40 2002 46 2011 40 41 41 59 2012 40 2007 41 59 621 392 40 2013 46 2014 40 41 614 2015 46 2014 40 41 41 123 2016 46 2017 40 2018 41 59 125 360 123 621 621 2019 46 2020 40 41 46 2021 40 2022 41 59 2019 46 2023 40 2024 41 59 2025 46 2026 40 380 41 59 2019 46 2020 40 41 46 2027 40 2022 41 59 125 125 41 59 2028 40 2002 41 59 2002 46 2029 40 2007 46 2030 40 41 41 59 125 360 123 2002 46 2031 40 424 41 59 2032 40 424 41 59 125 125 125 59 
5033,Java,"                new Callback<>() {

                    @Override
                    public TableCell<TransactionsListItem, TransactionsListItem> call(TableColumn<TransactionsListItem,
                            TransactionsListItem> column) {
                        return new TableCell<>() {

                            private AddressWithIconAndDirection field;

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String addressString = item.getAddressString();
                                    field = new AddressWithIconAndDirection(item.getDirection(), addressString,
                                            item.getReceived());
                                    field.setOnAction(event -> openAddressInBlockExplorer(item));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", addressString)));
                                    setGraphic(field);
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2007 40 2010 46 2014 40 41 44 2012 44 2010 46 2015 40 41 41 59 2008 46 2016 40 373 45 62 2017 40 2010 41 41 59 2008 46 2018 40 418 2019 40 2020 46 2021 40 648 44 2012 41 41 41 59 2022 40 2008 41 59 125 360 123 2023 40 424 41 59 392 40 2008 631 424 41 2008 46 2024 40 424 41 59 125 125 125 59 125 125 41 59 
5037,Java,"                new Callback<>() {

                    @Override
                    public TableCell<TransactionsListItem, TransactionsListItem> call(TableColumn<TransactionsListItem,
                            TransactionsListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(item.getTxConfidenceIndicator());
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 2008 46 2010 40 41 41 59 125 360 123 2011 40 424 41 59 125 125 125 59 125 125 41 59 
5039,Java,"                new Callback<>() {

                    @Override
                    public TableCell<TransactionsListItem, TransactionsListItem> call(TableColumn<TransactionsListItem,
                            TransactionsListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(item.getDateString()));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 418 2010 40 2008 46 2011 40 41 41 41 59 125 360 123 2012 40 424 41 59 125 125 125 59 125 125 41 59 
5043,Java,"                new Callback<>() {

                    @Override
                    public TableCell<TransactionsListItem, TransactionsListItem> call(TableColumn<TransactionsListItem,
                            TransactionsListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(item.getMemo()));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 418 2010 40 2008 46 2011 40 41 41 41 59 125 360 123 2012 40 424 41 59 125 125 125 59 125 125 41 59 
5044,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(item.getMemo()));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 418 2006 40 2004 46 2007 40 41 41 41 59 125 360 123 2008 40 424 41 59 125 125 125 59 
5045,Java,"                new Callback<>() {

                    @Override
                    public TableCell<TransactionsListItem, TransactionsListItem> call(TableColumn<TransactionsListItem,
                            TransactionsListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    TransactionConfidence confidence = btcWalletService.getConfidenceForTxId(item.getTxId());
                                    if (confidence != null) {
                                        if (confidence.getConfidenceType() == TransactionConfidence.ConfidenceType.PENDING) {
                                            if (button == null) {
                                                button = new AutoTooltipButton(Res.get(""funds.tx.revert""));
                                                setGraphic(button);
                                            }
                                            button.setOnAction(e -> revertTransaction(item.getTxId(), item.getTradable()));
                                        } else {
                                            setGraphic(null);
                                            if (button != null) {
                                                button.setOnAction(null);
                                                button = null;
                                            }
                                        }
                                    }
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2013 46 2014 40 2010 46 2015 40 41 41 59 392 40 2012 631 424 41 123 392 40 2012 46 2016 40 41 614 2011 46 2017 46 2018 41 123 392 40 2008 614 424 41 123 2008 61 418 2019 40 2020 46 2021 40 648 41 41 59 2022 40 2008 41 59 125 2008 46 2023 40 2024 45 62 2025 40 2010 46 2015 40 41 44 2010 46 2026 40 41 41 41 59 125 360 123 2027 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2028 40 424 41 59 2008 61 424 59 125 125 125 125 360 123 2029 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2030 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
5046,Java,"                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    TransactionConfidence confidence = btcWalletService.getConfidenceForTxId(item.getTxId());
                                    if (confidence != null) {
                                        if (confidence.getConfidenceType() == TransactionConfidence.ConfidenceType.PENDING) {
                                            if (button == null) {
                                                button = new AutoTooltipButton(Res.get(""funds.tx.revert""));
                                                setGraphic(button);
                                            }
                                            button.setOnAction(e -> revertTransaction(item.getTxId(), item.getTradable()));
                                        } else {
                                            setGraphic(null);
                                            if (button != null) {
                                                button.setOnAction(null);
                                                button = null;
                                            }
                                        }
                                    }
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2009 46 2010 40 2006 46 2011 40 41 41 59 392 40 2008 631 424 41 123 392 40 2008 46 2012 40 41 614 2007 46 2013 46 2014 41 123 392 40 2002 614 424 41 123 2002 61 418 2015 40 2016 46 2017 40 648 41 41 59 2018 40 2002 41 59 125 2002 46 2019 40 2020 45 62 2021 40 2006 46 2011 40 41 44 2006 46 2022 40 41 41 41 59 125 360 123 2023 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2024 40 424 41 59 2002 61 424 59 125 125 125 125 360 123 2025 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2026 40 424 41 59 2002 61 424 59 125 125 125 125 59 
4995,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(final DepositListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(item.getTxConfidenceIndicator());
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 123 2007 40 424 41 59 125 125 125 59 
4037,Java,"        dateColumn.setCellFactory(new Callback<>() {

            @Override
            public TableCell<ReservedListItem, ReservedListItem> call(TableColumn<ReservedListItem,
                    ReservedListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final ReservedListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            if (getTradable(item).isPresent()) {
                                setGraphic(new AutoTooltipLabel(item.getDateAsString()));
                            } else
                                setGraphic(new AutoTooltipLabel(Res.get(""shared.noDateAvailable"")));
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2008 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2009 40 381 2005 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2011 40 2010 41 46 2012 40 41 41 123 2013 40 418 2014 40 2010 46 2015 40 41 41 41 59 125 360 2016 40 418 2017 40 2018 46 2019 40 648 41 41 41 59 125 360 123 2020 40 424 41 59 125 125 125 59 125 125 41 59 
4032,Java,"        balanceListener = new BalanceListener() {
            @Override
            public void onBalanceChanged(Coin balance, Transaction tx) {
                updateList();
            }
        };",0,2000 61 418 2001 40 41 123 64 2002 439 492 2003 40 2004 2005 44 2006 2007 41 123 2008 40 41 59 125 125 59 
4035,Java,"                new Callback<>() {

                    @Override
                    public TableCell<ReservedListItem, ReservedListItem> call(TableColumn<ReservedListItem,
                            ReservedListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ReservedListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic((item != null && !empty) ? item.getBalanceLabel() : null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 40 2008 631 424 605 33 362 41 63 2008 46 2010 40 41 58 424 41 59 125 125 59 125 125 41 59 
4038,Java,"                return new TableCell<>() {

                    @Override
                    public void updateItem(final ReservedListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            if (getTradable(item).isPresent()) {
                                setGraphic(new AutoTooltipLabel(item.getDateAsString()));
                            } else
                                setGraphic(new AutoTooltipLabel(Res.get(""shared.noDateAvailable"")));
                        } else {
                            setGraphic(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 392 40 2005 40 2004 41 46 2006 40 41 41 123 2007 40 418 2008 40 2004 46 2009 40 41 41 41 59 125 360 2010 40 418 2011 40 2012 46 2013 40 648 41 41 41 59 125 360 123 2014 40 424 41 59 125 125 125 59 
5485,Java,"        balanceListener = new BalanceListener() {
            @Override
            public void onBalanceChanged(Coin balance, Transaction tx) {
                updateList();
            }
        };",0,2000 61 418 2001 40 41 123 64 2002 439 492 2003 40 2004 2005 44 2006 2007 41 123 2008 40 41 59 125 125 59 
5162,Java,"        comboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(Class<? extends Task> item) {
                return item.getSimpleName();
            }

            @Override
            public Class<? extends Task> fromString(String s) {
                return null;
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 60 63 378 2007 62 2008 41 123 450 2008 46 2009 40 41 59 125 64 2003 439 2006 60 63 378 2007 62 2010 40 2004 2011 41 123 450 424 59 125 125 41 59 
5488,Java,"                new Callback<>() {

                    @Override
                    public TableCell<LockedListItem, LockedListItem> call(TableColumn<LockedListItem,
                            LockedListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final LockedListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic((item != null && !empty) ? item.getBalanceLabel() : null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 40 2008 631 424 605 33 362 41 63 2008 46 2010 40 41 58 424 41 59 125 125 59 125 125 41 59 
5489,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final LockedListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic((item != null && !empty) ? item.getBalanceLabel() : null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 40 2004 631 424 605 33 362 41 63 2004 46 2006 40 41 58 424 41 59 125 125 59 
5490,Java,"        dateColumn.setCellFactory(new Callback<>() {

            @Override
            public TableCell<LockedListItem, LockedListItem> call(TableColumn<LockedListItem,
                    LockedListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final LockedListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            if (getTradable(item).isPresent())
                                setGraphic(new AutoTooltipLabel(item.getDateString()));
                            else
                                setGraphic(new AutoTooltipLabel(item.getDateString()));
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2008 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2009 40 381 2005 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2011 40 2010 41 46 2012 40 41 41 2013 40 418 2014 40 2010 46 2015 40 41 41 41 59 360 2013 40 418 2014 40 2010 46 2015 40 41 41 41 59 125 360 123 2016 40 424 41 59 125 125 125 59 125 125 41 59 
4421,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> openTxInBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 621 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 59 2002 61 418 2010 40 2008 41 59 2002 46 2011 40 373 45 62 2012 40 2006 41 41 59 2002 46 2013 40 418 2014 40 2015 46 2016 40 648 44 2008 41 41 41 59 2017 40 2002 41 59 125 360 123 2018 40 424 41 59 392 40 2002 631 424 41 2002 46 2019 40 424 41 59 125 125 125 59 
4989,Java,"        balanceListener = new BalanceListener() {
            @Override
            public void onBalanceChanged(Coin balance, Transaction tx) {
                updateList();
            }
        };",0,2000 61 418 2001 40 41 123 64 2002 439 492 2003 40 2004 2005 44 2006 2007 41 123 2008 40 41 59 125 125 59 
4992,Java,"        balanceColumn.setCellFactory(new Callback<>() {

            @Override
            public TableCell<DepositListItem, DepositListItem> call(TableColumn<DepositListItem,
                    DepositListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final DepositListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            if (textProperty().isBound())
                                textProperty().unbind();

                            textProperty().bind(item.balanceProperty());
                        } else {
                            textProperty().unbind();
                            setText("""");
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2008 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2009 40 381 2005 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2011 40 41 46 2012 40 41 41 2011 40 41 46 2013 40 41 59 2011 40 41 46 2014 40 2010 46 2015 40 41 41 59 125 360 123 2016 40 41 46 2017 40 41 59 2018 40 648 41 59 125 125 125 59 125 125 41 59 
4994,Java,"                new Callback<>() {

                    @Override
                    public TableCell<DepositListItem, DepositListItem> call(TableColumn<DepositListItem,
                            DepositListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final DepositListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(item.getTxConfidenceIndicator());
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 2008 46 2010 40 41 41 59 125 360 123 2011 40 424 41 59 125 125 125 59 125 125 41 59 
4415,Java,"                return new TableCell<>() {

                    @Override
                    public void updateItem(final BsqTxListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setGraphic(item.getTxConfidenceIndicator());
                        } else {
                            setGraphic(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 123 2007 40 424 41 59 125 125 125 59 
4412,Java,"        column.setCellFactory(new Callback<>() {

            @Override
            public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                    BsqTxListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final BsqTxListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            TxType txType = item.getTxType();

                            String bsqAmount = Res.get(""shared.na"");

                            if (item.getConfirmations() > 0) {
                                if (isValidType(txType))
                                    bsqAmount = item.getAmountAsString();
                                else if (item.isWithdrawalToBTCWallet())
                                    bsqAmount = bsqFormatter.formatBSQSatoshis(0L);
                            }

                            setText(bsqAmount);
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 2011 61 2009 46 2012 40 41 59 2013 2014 61 2015 46 2016 40 648 41 59 392 40 2009 46 2017 40 41 62 1500 41 123 392 40 2018 40 2011 41 41 2014 61 2009 46 2019 40 41 59 360 392 40 2009 46 2020 40 41 41 2014 61 2021 46 2022 40 1500 41 59 125 2023 40 2014 41 59 125 360 2024 40 648 41 59 125 125 59 125 125 41 59 
4416,Java,"                new Callback<>() {

                    @Override
                    public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                            BsqTxListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setText(item.getDateAsString());
                                } else {
                                    setText("""");
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 2008 46 2010 40 41 41 59 125 360 123 2011 40 648 41 59 125 125 125 59 125 125 41 59 
4417,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setText(item.getDateAsString());
                                } else {
                                    setText("""");
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 123 2007 40 648 41 59 125 125 125 59 
3255,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getCycle());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3261,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getMeritAndStake());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3277,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getQuorumAsString());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3256,Java,"                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getNumProposals());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3257,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getNumProposals());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3260,Java,"                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getMeritAndStake());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3262,Java,"                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getIssuance());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3656,Java,"                new Callback<>() {

                    @Override
                    public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                            MyProofOfBurnListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = new AutoTooltipButton(Res.get(""dao.proofOfBurn.sign""));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(e -> new ProofOfBurnSignatureWindow(proofOfBurnService, item.getTxId()).show());
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2008 614 424 41 123 2008 61 418 2011 40 2012 46 2013 40 648 41 41 59 2014 40 2008 41 59 125 2008 46 2015 40 2016 45 62 418 2017 40 2018 44 2010 46 2019 40 41 41 46 2020 40 41 41 59 125 360 123 2021 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2022 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
3263,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getIssuance());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3270,Java,"                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getDetails());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3272,Java,"        column.setCellFactory(new Callback<>() {

            @Override
            public TableCell<ProposalListItem, ProposalListItem> call(TableColumn<ProposalListItem,
                    ProposalListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProposalListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setGraphic(item.getMyVoteIcon());
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 123 2012 40 424 41 59 125 125 125 59 125 125 41 59 
3273,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProposalListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setGraphic(item.getMyVoteIcon());
                        } else {
                            setGraphic(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 123 2007 40 424 41 59 125 125 125 59 
3276,Java,"                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getQuorumAsString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3278,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProposalListItem, ProposalListItem> call(TableColumn<ProposalListItem,
                    ProposalListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProposalListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            Label icon = new Label();
                            AwesomeDude.setIcon(icon, item.getIcon());
                            icon.getStyleClass().add(item.getColorStyleClass());
                            setGraphic(icon);
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 2011 61 418 2010 40 41 59 2012 46 2013 40 2011 44 2009 46 2014 40 41 41 59 2011 46 2015 40 41 46 2016 40 2009 46 2017 40 41 41 59 2018 40 2011 41 59 125 360 123 2019 40 424 41 59 125 125 125 59 125 125 41 59 
3649,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPubKey());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
3650,Java,"                new Callback<>() {

                    @Override
                    public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                            ProofOfBurnListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = new AutoTooltipButton(Res.get(""dao.proofOfBurn.verify""));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(e -> new ProofOfBurnVerificationWindow(proofOfBurnService, item.getTxId()).show());
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2008 614 424 41 123 2008 61 418 2011 40 2012 46 2013 40 648 41 41 59 2014 40 2008 41 59 125 2008 46 2015 40 2016 45 62 418 2017 40 2018 44 2010 46 2019 40 41 41 46 2020 40 41 41 59 125 360 123 2021 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2022 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
3640,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                    ProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmountAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
3642,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                    ProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getDateAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
3644,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                    ProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getHashAsHex());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
3646,Java,"                new Callback<>() {
                    @Override
                    public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                            ProofOfBurnListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(item.getTxId(), preferences));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 621 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 46 2017 40 2010 46 2013 40 41 44 2018 41 41 59 2008 46 2019 40 418 2020 40 2021 46 2022 40 648 44 2012 41 41 41 59 2023 40 2008 41 59 125 360 123 2024 40 424 41 59 392 40 2008 631 424 41 2008 46 2025 40 424 41 59 125 125 125 59 125 125 41 59 
3651,Java,"                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = new AutoTooltipButton(Res.get(""dao.proofOfBurn.verify""));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(e -> new ProofOfBurnVerificationWindow(proofOfBurnService, item.getTxId()).show());
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 392 40 2002 614 424 41 123 2002 61 418 2007 40 2008 46 2009 40 648 41 41 59 2010 40 2002 41 59 125 2002 46 2011 40 2012 45 62 418 2013 40 2014 44 2006 46 2015 40 41 41 46 2016 40 41 41 59 125 360 123 2017 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2018 40 424 41 59 2002 61 424 59 125 125 125 125 59 
3652,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmountAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
3654,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPubKey());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
3657,Java,"                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = new AutoTooltipButton(Res.get(""dao.proofOfBurn.sign""));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(e -> new ProofOfBurnSignatureWindow(proofOfBurnService, item.getTxId()).show());
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 392 40 2002 614 424 41 123 2002 61 418 2007 40 2008 46 2009 40 648 41 41 59 2010 40 2002 41 59 125 2002 46 2011 40 2012 45 62 418 2013 40 2014 44 2006 46 2015 40 41 41 46 2016 40 41 41 59 125 360 123 2017 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2018 40 424 41 59 2002 61 424 59 125 125 125 125 59 
3658,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getDateAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
3660,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPreImage());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4720,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAssetStateString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
5594,Java,"                new Callback<>() {
                    @Override
                    public TableCell<BondListItem, BondListItem> call(TableColumn<BondListItem,
                            BondListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final BondListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String lockupTxId = item.getLockupTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(lockupTxId);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(lockupTxId, preferences));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", lockupTxId)));
                                    if (item.getLockupDateString().equals(""-"")) hyperlinkWithIcon.hideIcon();
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 46 2017 40 2012 44 2018 41 41 59 2008 46 2019 40 418 2020 40 2021 46 2022 40 648 44 2012 41 41 41 59 392 40 2010 46 2023 40 41 46 2024 40 648 41 41 2008 46 2025 40 41 59 2026 40 2008 41 59 125 360 123 2027 40 424 41 59 392 40 2008 631 424 41 2008 46 2028 40 424 41 59 125 125 125 59 125 125 41 59 
3662,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getHashAsHex());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
3663,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getHashAsHex());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4714,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getFeeOfTrialPeriodAsString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4713,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<AssetListItem, AssetListItem> call(TableColumn<AssetListItem,
                    AssetListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getFeeOfTrialPeriodAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4715,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<AssetListItem, AssetListItem> call(TableColumn<AssetListItem,
                    AssetListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getTotalFeesPaidAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4717,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<AssetListItem, AssetListItem> call(TableColumn<AssetListItem,
                    AssetListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getNameAndCode());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4719,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<AssetListItem, AssetListItem> call(TableColumn<AssetListItem,
                    AssetListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAssetStateString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4721,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<AssetListItem, AssetListItem> call(TableColumn<AssetListItem,
                    AssetListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getTradedVolumeAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4723,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<AssetListItem, AssetListItem> call(TableColumn<AssetListItem,
                    AssetListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLookBackPeriodInDays());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4725,Java,"        assetComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(StatefulAsset statefulAsset) {
                return CurrencyUtil.getNameAndCode(statefulAsset.getAsset().getTickerSymbol());
            }

            @Override
            public StatefulAsset fromString(String string) {
                return null;
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 450 2008 46 2009 40 2007 46 2010 40 41 46 2011 40 41 41 59 125 64 2003 439 2006 2012 40 2004 461 41 123 450 424 59 125 125 41 59 
4096,Java,"                        return new TableCell<>() {
                            AutoTooltipButton button;

                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty && item.isButtonVisible()) {
                                    if (button == null) {
                                        button = new AutoTooltipButton(item.getButtonText());
                                        button.setMinWidth(70);
                                        button.setOnAction(e -> {
                                            if (item.getBondState() == BondState.READY_FOR_LOCKUP) {
                                                bondingViewUtils.lockupBondForBondedRole(item.getRole(),
                                                        txId -> {
                                                        });
                                            } else if (item.getBondState() == BondState.LOCKUP_TX_CONFIRMED) {
                                                bondingViewUtils.unLock(item.getLockupTxId(),
                                                        txId -> {
                                                        });
                                            }
                                        });
                                        setGraphic(button);
                                    }
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 605 2006 46 2007 40 41 41 123 392 40 2002 614 424 41 123 2002 61 418 2001 40 2006 46 2008 40 41 41 59 2002 46 2009 40 1503 41 59 2002 46 2010 40 2011 45 62 123 392 40 2006 46 2012 40 41 614 2013 46 2014 41 123 2015 46 2016 40 2006 46 2017 40 41 44 2018 45 62 123 125 41 59 125 360 392 40 2006 46 2012 40 41 614 2013 46 2019 41 123 2020 46 2021 40 2006 46 2022 40 41 44 2023 45 62 123 125 41 59 125 125 41 59 2024 40 2002 41 59 125 125 360 123 2025 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2026 40 424 41 59 2002 61 424 59 125 125 125 125 59 
4097,Java,"                new Callback<>() {
                    @Override
                    public TableCell<RolesListItem, RolesListItem> call(TableColumn<RolesListItem,
                            RolesListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    String link = item.getRole().getLink();
                                    hyperlinkWithIcon = new ExternalHyperlink(link);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openWebPage(link));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""shared.openURL"", link)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 46 2014 40 41 59 2008 61 418 2015 40 2012 41 59 2008 46 2016 40 373 45 62 2017 46 2018 40 2012 41 41 59 2008 46 2019 40 418 2020 40 2021 46 2022 40 648 44 2012 41 41 41 59 2023 40 2008 41 59 125 360 123 2024 40 424 41 59 392 40 2008 631 424 41 2008 46 2025 40 424 41 59 125 125 125 59 125 125 41 59 
4855,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyReputationListItem, MyReputationListItem> call(TableColumn<MyReputationListItem,
                    MyReputationListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getSalt());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4098,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    String link = item.getRole().getLink();
                                    hyperlinkWithIcon = new ExternalHyperlink(link);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openWebPage(link));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""shared.openURL"", link)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 46 2010 40 41 59 2002 61 418 2011 40 2008 41 59 2002 46 2012 40 373 45 62 2013 46 2014 40 2008 41 41 59 2002 46 2015 40 418 2016 40 2017 46 2018 40 648 44 2008 41 41 41 59 2019 40 2002 41 59 125 360 123 2020 40 424 41 59 392 40 2002 631 424 41 2002 46 2021 40 424 41 59 125 125 125 59 
4102,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;
                            private Label label;

                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String transactionId = item.getBondedRole().getLockupTxId();
                                    if (transactionId != null) {
                                        hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                        hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(transactionId, preferences));
                                        hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                        setGraphic(hyperlinkWithIcon);
                                    } else {
                                        label = new Label(""-"");
                                        setGraphic(label);
                                    }
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                    if (label != null)
                                        label = null;
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 437 2003 2004 59 64 2005 439 492 2006 40 381 2007 2008 44 324 362 41 123 463 46 2006 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 2010 61 2008 46 2011 40 41 46 2012 40 41 59 392 40 2010 631 424 41 123 2002 61 418 2013 40 2010 41 59 2002 46 2014 40 373 45 62 2015 46 2016 40 2010 44 2017 41 41 59 2002 46 2018 40 418 2019 40 2020 46 2021 40 648 44 2010 41 41 41 59 2022 40 2002 41 59 125 360 123 2004 61 418 2003 40 648 41 59 2023 40 2004 41 59 125 125 360 123 2024 40 424 41 59 392 40 2002 631 424 41 2002 46 2025 40 424 41 59 392 40 2004 631 424 41 2004 61 424 59 125 125 125 59 
4857,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyReputationListItem, MyReputationListItem> call(TableColumn<MyReputationListItem,
                    MyReputationListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getHash());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4859,Java,"                new Callback<>() {
                    @Override
                    public TableCell<MyReputationListItem, MyReputationListItem> call(TableColumn<MyReputationListItem,
                            MyReputationListItem> column) {
                        return new TableCell<>() {
                            AutoTooltipButton button;

                            @Override
                            public void updateItem(final MyReputationListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty && item.isShowButton()) {
                                    button = new AutoTooltipButton(item.getButtonText());
                                    button.setOnAction(e -> {
                                        if (item.getBondState() == BondState.LOCKUP_TX_CONFIRMED) {
                                            bondingViewUtils.unLock(item.getLockupTxId(),
                                                    txId -> {
                                                    });
                                        }
                                    });
                                    setGraphic(button);
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 605 2010 46 2011 40 41 41 123 2008 61 418 2007 40 2010 46 2012 40 41 41 59 2008 46 2013 40 2014 45 62 123 392 40 2010 46 2015 40 41 614 2016 46 2017 41 123 2018 46 2019 40 2010 46 2020 40 41 44 2021 45 62 123 125 41 59 125 125 41 59 2022 40 2008 41 59 125 360 123 2023 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2024 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
4103,Java,"                new Callback<>() {
                    @Override
                    public TableCell<RolesListItem, RolesListItem> call(TableColumn<RolesListItem,
                            RolesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setText(item.getBondStateString());
                                } else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 2008 46 2010 40 41 41 59 125 360 2011 40 648 41 59 125 125 59 125 125 41 59 
4853,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyReputationListItem, MyReputationListItem> call(TableColumn<MyReputationListItem,
                    MyReputationListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmount());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4861,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyReputationListItem, MyReputationListItem> call(TableColumn<MyReputationListItem,
                    MyReputationListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLockTime());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4862,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLockTime());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4863,Java,"                new Callback<>() {
                    @Override
                    public TableCell<MyReputationListItem, MyReputationListItem> call(TableColumn<MyReputationListItem,
                            MyReputationListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(MyReputationListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setText(item.getBondStateString());
                                } else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 2008 46 2010 40 41 41 59 125 360 2011 40 648 41 59 125 125 59 125 125 41 59 
4865,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyReputationListItem, MyReputationListItem> call(TableColumn<MyReputationListItem,
                    MyReputationListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLockupDateString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4867,Java,"                new Callback<>() {
                    @Override
                    public TableCell<MyReputationListItem, MyReputationListItem> call(TableColumn<MyReputationListItem,
                            MyReputationListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final MyReputationListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(item.getTxId(), preferences));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 621 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 46 2017 40 2010 46 2013 40 41 44 2018 41 41 59 2008 46 2019 40 418 2020 40 2021 46 2022 40 648 44 2012 41 41 41 59 2023 40 2008 41 59 125 360 123 2024 40 424 41 59 392 40 2008 631 424 41 2008 46 2025 40 424 41 59 125 125 125 59 125 125 41 59 
5592,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<BondListItem, BondListItem> call(TableColumn<BondListItem, BondListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLockupDateString());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
5593,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLockupDateString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
5601,Java,"                return new TableCell<>() {

                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getBondType());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
5590,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<BondListItem, BondListItem> call(TableColumn<BondListItem, BondListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmount());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
5596,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<BondListItem, BondListItem> call(TableColumn<BondListItem, BondListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLockTime());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
5717,Java,"            p2PService.addP2PServiceListener(new BootstrapListener() {
                @Override
                public void onUpdatedDataReceived() {
                    setupInvalidOpenOffersHandler();
                }
            });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 41 123 2005 40 41 59 125 125 41 59 
2825,Java,"    private class NavButton extends AutoTooltipToggleButton {

        private final Class<? extends View> viewClass;

        NavButton(Class<? extends View> viewClass, String title) {
            super(title);

            this.viewClass = viewClass;

            this.setToggleGroup(navButtons);
            this.getStyleClass().add(""nav-button"");
            // Japanese fonts are dense, increase top nav button text size
            if (model.getPreferences() != null && ""ja"".equals(model.getPreferences().getUserLanguage())) {
                this.getStyleClass().add(""nav-button-japanese"");
            }

            this.selectedProperty().addListener((ov, oldValue, newValue) -> this.setMouseTransparent(newValue));

            this.setOnAction(e -> navigation.navigateTo(MainView.class, viewClass));
        }

    }",0,437 334 2000 378 2001 123 437 381 2002 60 63 378 2003 62 2004 59 2000 40 2002 60 63 378 2003 62 2004 44 2005 2006 41 123 463 40 2006 41 59 467 46 2004 61 2004 59 467 46 2007 40 2008 41 59 467 46 2009 40 41 46 2010 40 648 41 59 621 392 40 2011 46 2012 40 41 631 424 605 648 46 2013 40 2011 46 2012 40 41 46 2014 40 41 41 41 123 467 46 2009 40 41 46 2010 40 648 41 59 125 467 46 2015 40 41 46 2016 40 40 2017 44 2018 44 2019 41 45 62 467 46 2020 40 2019 41 41 59 467 46 2021 40 2022 45 62 2023 46 2024 40 2025 46 334 44 2004 41 41 59 125 125 
5598,Java,"                new Callback<>() {
                    @Override
                    public TableCell<BondListItem, BondListItem> call(TableColumn<BondListItem,
                            BondListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final BondListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setText(item.getBondStateString());
                                } else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 2008 46 2010 40 41 41 59 125 360 2011 40 648 41 59 125 125 59 125 125 41 59 
5600,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<BondListItem, BondListItem> call(TableColumn<BondListItem, BondListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getBondType());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
5602,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<BondListItem, BondListItem> call(TableColumn<BondListItem, BondListItem> column) {
                return new TableCell<>() {
                    private InfoAutoTooltipLabel infoTextField;

                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            String info = Res.get(""shared.id"") + "": "" + item.getBond().getBondedAsset().getUid();

                            if (item.getBond() instanceof BondedRole) {
                                info = item.getBondDetails() + ""\n"" + info;
                            }

                            infoTextField = new InfoAutoTooltipLabel(item.getBondDetails(),
                                    AwesomeIcon.INFO_SIGN,
                                    ContentDisplay.LEFT,
                                    info,
                                    350
                            );
                            setGraphic(infoTextField);
                        } else
                            setGraphic(null);
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 437 2008 2009 59 64 2003 439 492 2010 40 381 2005 2011 44 324 362 41 123 463 46 2010 40 2011 44 362 41 59 392 40 2011 631 424 605 33 362 41 123 2012 2013 61 2014 46 2015 40 648 41 43 648 43 2011 46 2016 40 41 46 2017 40 41 46 2018 40 41 59 392 40 2011 46 2016 40 41 402 2019 41 123 2013 61 2011 46 2020 40 41 43 648 43 2013 59 125 2009 61 418 2008 40 2011 46 2021 40 41 44 2022 46 2023 44 2024 46 2025 44 2013 44 1504 41 59 2026 40 2009 41 59 125 360 2027 40 424 41 59 125 125 59 125 125 41 59 
5653,Java,"        currencyComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(TradeCurrency tradeCurrency) {
                return tradeCurrency != null ? tradeCurrency.getNameAndCode() : """";
            }

            @Override
            public TradeCurrency fromString(String s) {
                return currencyComboBox.getItems().stream().
                        filter(item -> item.getNameAndCode().equals(s)).
                        findAny().orElse(null);
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 450 2007 631 424 63 2007 46 2008 40 41 58 648 59 125 64 2003 439 2006 2009 40 2004 2010 41 123 450 2000 46 2011 40 41 46 2012 40 41 46 2013 40 2014 45 62 2014 46 2015 40 41 46 2016 40 2010 41 41 46 2017 40 41 46 2018 40 424 41 59 125 125 41 59 
5603,Java,"                return new TableCell<>() {
                    private InfoAutoTooltipLabel infoTextField;

                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            String info = Res.get(""shared.id"") + "": "" + item.getBond().getBondedAsset().getUid();

                            if (item.getBond() instanceof BondedRole) {
                                info = item.getBondDetails() + ""\n"" + info;
                            }

                            infoTextField = new InfoAutoTooltipLabel(item.getBondDetails(),
                                    AwesomeIcon.INFO_SIGN,
                                    ContentDisplay.LEFT,
                                    info,
                                    350
                            );
                            setGraphic(infoTextField);
                        } else
                            setGraphic(null);
                    }
                };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2009 46 2010 40 648 41 43 648 43 2006 46 2011 40 41 46 2012 40 41 46 2013 40 41 59 392 40 2006 46 2011 40 41 402 2014 41 123 2008 61 2006 46 2015 40 41 43 648 43 2008 59 125 2002 61 418 2001 40 2006 46 2016 40 41 44 2017 46 2018 44 2019 46 2020 44 2008 44 1504 41 59 2021 40 2002 41 59 125 360 2022 40 424 41 59 125 125 59 
5658,Java,"public class RefundAgentRegistrationViewModel extends AgentRegistrationViewModel<RefundAgent, RefundAgentManager> {

    @Inject
    public RefundAgentRegistrationViewModel(RefundAgentManager arbitratorManager,
                                            User user,
                                            P2PService p2PService,
                                            BtcWalletService walletService,
                                            KeyRing keyRing) {
        super(arbitratorManager, user, p2PService, walletService, keyRing);
    }

    @Override
    protected RefundAgent getDisputeAgent(String registrationSignature,
                                          String emailAddress) {
        return new RefundAgent(
                p2PService.getAddress(),
                keyRing.getPubKeyRing(),
                new ArrayList<>(languageCodes),
                new Date().getTime(),
                registrationKey.getPubKey(),
                registrationSignature,
                emailAddress,
                null,
                null
        );
    }

    @Override
    protected RefundAgent getRegisteredDisputeAgentFromUser() {
        return user.getRegisteredRefundAgent();
    }
}",0,439 334 2000 378 2001 60 2002 44 2003 62 123 64 2004 439 2000 40 2003 2005 44 2006 2007 44 2008 2009 44 2010 2011 44 2012 2013 41 123 463 40 2005 44 2007 44 2009 44 2011 44 2013 41 59 125 64 2014 438 2002 2015 40 2016 2017 44 2016 2018 41 123 450 418 2002 40 2009 46 2019 40 41 44 2013 46 2020 40 41 44 418 2021 60 62 40 2022 41 44 418 2023 40 41 46 2024 40 41 44 2025 46 2026 40 41 44 2017 44 2018 44 424 44 424 41 59 125 64 2014 438 2002 2027 40 41 123 450 2007 46 2028 40 41 59 125 125 
5557,Java,"@FxmlView
public class RefundAgentRegistrationView extends AgentRegistrationView<RefundAgent, RefundAgentRegistrationViewModel> {

    @Inject
    public RefundAgentRegistrationView(RefundAgentRegistrationViewModel model,
                                       @Named(Config.USE_DEV_PRIVILEGE_KEYS) boolean useDevPrivilegeKeys) {
        super(model, useDevPrivilegeKeys);
    }

    @Override
    protected String getRole() {
        return Res.get(""shared.refundAgentForSupportStaff"");
    }
}",0,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 123 64 2005 439 2001 40 2004 2006 44 64 2007 40 2008 46 2009 41 324 2010 41 123 463 40 2006 44 2010 41 59 125 64 2011 438 2012 2013 40 41 123 450 2014 46 2015 40 648 41 59 125 125 
3883,Java,"        paymentMethodComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(PaymentMethod paymentMethod) {
                return paymentMethod != null ? Res.get(paymentMethod.getId()) : """";
            }

            @Override
            public PaymentMethod fromString(String s) {
                return null;
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 450 2007 631 424 63 2008 46 2009 40 2007 46 2010 40 41 41 58 648 59 125 64 2003 439 2006 2011 40 2004 2012 41 123 450 424 59 125 125 41 59 
3009,Java,"@Slf4j
@Singleton
public class DefaultSeedNodeRepository implements SeedNodeRepository {
    //TODO add support for localhost addresses
    private static final Pattern pattern = Pattern.compile(""^([a-z0-9]+\\.onion:\\d+)"");
    private static final String ENDING = "".seednodes"";
    private final Collection<NodeAddress> cache = new HashSet<>();
    private final Config config;

    @Inject
    public DefaultSeedNodeRepository(Config config) {
        this.config = config;
    }

    private void reload() {
        try {
            // see if there are any seed nodes configured manually
            if (!config.seedNodes.isEmpty()) {
                cache.clear();
                config.seedNodes.forEach(s -> cache.add(new NodeAddress(s)));

                return;
            }

            cache.clear();
            List<NodeAddress> result = getSeedNodeAddressesFromPropertyFile(config.baseCurrencyNetwork.name().toLowerCase());
            cache.addAll(result);

            // let values configured by filter fail more gracefully
            cache.removeAll(
                    config.bannedSeedNodes.stream()
                            .filter(n -> !n.isEmpty())
                            .map(this::getNodeAddress)
                            .filter(Objects::nonNull)
                            .collect(Collectors.toSet()));

            log.info(""Seed nodes: {}"", cache);
        } catch (Throwable t) {
            log.error(""exception in DefaultSeedNodeRepository"", t);
            t.printStackTrace();
            throw t;
        }
    }

    public static Optional<BufferedReader> readSeedNodePropertyFile(String fileName) {
        InputStream fileInputStream = DefaultSeedNodeRepository.class.getClassLoader().getResourceAsStream(
                fileName + ENDING);
        if (fileInputStream == null) {
            return Optional.empty();
        }
        return Optional.of(new BufferedReader(new InputStreamReader(fileInputStream)));
    }

    public static List<NodeAddress> getSeedNodeAddressesFromPropertyFile(String fileName) {
        List<NodeAddress> list = new ArrayList<>();
        readSeedNodePropertyFile(fileName).ifPresent(seedNodeFile -> {
            seedNodeFile.lines().forEach(line -> {
                Matcher matcher = pattern.matcher(line);
                if (matcher.find())
                    list.add(new NodeAddress(matcher.group(1)));

                // Maybe better include in regex...
                if (line.startsWith(""localhost"")) {
                    String[] strings = line.split("" \\(@"");
                    String node = strings[0];
                    list.add(new NodeAddress(node));
                }
            });
        });
        return list;
    }

    public Collection<NodeAddress> getSeedNodeAddresses() {
        if (cache.isEmpty())
            reload();

        return cache;
    }

    public boolean isSeedNode(NodeAddress nodeAddress) {
        if (cache.isEmpty())
            reload();
        return cache.contains(nodeAddress);
    }

    @Nullable
    private NodeAddress getNodeAddress(String n) {
        try {
            return new NodeAddress(n);
        } catch (Throwable t) {
            log.error(""exception when filtering banned seednodes"", t);
        }
        return null;
    }
}",0,64 2000 64 2001 439 334 2002 395 2003 123 621 437 457 381 2004 2005 61 2004 46 2006 40 648 41 59 437 457 381 2007 2008 61 648 59 437 381 2009 60 2010 62 2011 61 418 2012 60 62 40 41 59 437 381 2013 2014 59 64 2015 439 2002 40 2013 2014 41 123 467 46 2014 61 2014 59 125 437 492 2016 40 41 123 474 123 621 392 40 33 2014 46 2017 46 2018 40 41 41 123 2011 46 2019 40 41 59 2014 46 2017 46 2020 40 2021 45 62 2011 46 2022 40 418 2010 40 2021 41 41 41 59 450 59 125 2011 46 2023 40 41 59 2024 60 2010 62 2025 61 2026 40 2014 46 2027 46 2028 40 41 46 2029 40 41 41 59 2011 46 2030 40 2025 41 59 621 2011 46 2031 40 2014 46 2032 46 2033 40 41 46 2034 40 2035 45 62 33 2035 46 2018 40 41 41 46 2036 40 467 58 58 2037 41 46 2034 40 2038 58 58 2039 41 46 2040 40 2041 46 2042 40 41 41 41 59 2043 46 2044 40 648 44 2011 41 59 125 329 40 2045 2046 41 123 2047 46 371 40 648 44 2046 41 59 2046 46 2048 40 41 59 469 2046 59 125 125 439 457 2049 60 2050 62 2051 40 2007 2052 41 123 2053 2054 61 2002 46 334 46 2055 40 41 46 2056 40 2052 43 2008 41 59 392 40 2054 614 424 41 123 450 2049 46 362 40 41 59 125 450 2049 46 2057 40 418 2050 40 418 2058 40 2054 41 41 41 59 125 439 457 2059 60 2010 62 2060 40 2007 2052 41 123 2059 60 2010 62 411 61 418 2061 60 62 40 41 59 2051 40 2052 41 46 2062 40 2063 45 62 123 2063 46 2064 40 41 46 2065 40 410 45 62 123 2066 2067 61 2005 46 2067 40 410 41 59 392 40 2067 46 2068 40 41 41 411 46 2069 40 418 2010 40 2067 46 2070 40 1501 41 41 41 59 621 392 40 410 46 2071 40 648 41 41 123 2007 91 93 2072 61 410 46 2073 40 648 41 59 2007 2074 61 2072 91 1500 93 59 411 46 2069 40 418 2010 40 2074 41 41 59 125 125 41 59 125 41 59 450 411 59 125 439 2009 60 2010 62 2075 40 41 123 392 40 2011 46 2076 40 41 41 2016 40 41 59 450 2011 59 125 439 324 2077 40 2010 2078 41 123 392 40 2011 46 2079 40 41 41 2016 40 41 59 450 2011 46 2080 40 2078 41 59 125 64 2081 437 2010 2082 40 2007 2083 41 123 474 123 450 418 2010 40 2083 41 59 125 329 40 2084 2085 41 123 2086 46 371 40 648 44 2085 41 59 125 450 424 59 125 125 
5113,Java,"        paymentAccountsListView.setCellFactory(new Callback<>() {
            @Override
            public ListCell<PaymentAccount> call(ListView<PaymentAccount> list) {
                return new ListCell<>() {
                    final InfoAutoTooltipLabel label = new InfoAutoTooltipLabel("""", ContentDisplay.RIGHT);
                    final ImageView icon = ImageUtil.getImageViewById(ImageUtil.REMOVE_ICON);
                    final Button removeButton = new AutoTooltipButton("""", icon);
                    final AnchorPane pane = new AnchorPane(label, removeButton);

                    {
                        label.setLayoutY(5);
                        removeButton.setId(""icon-button"");
                        AnchorPane.setRightAnchor(removeButton, 0d);
                    }

                    @Override
                    public void updateItem(final PaymentAccount item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            label.setText(item.getAccountName());

                            boolean needsSigning = PaymentMethod.hasChargebackRisk(item.getPaymentMethod(),
                                    item.getTradeCurrencies());

                            if (needsSigning) {
                                AccountAgeWitnessService.SignState signState =
                                        accountAgeWitnessService.getSignState(accountAgeWitnessService.getMyWitness(
                                                item.paymentAccountPayload));

                                String info = StringUtils.capitalize(signState.getDisplayString());
                                label.setIcon(GUIUtil.getIconForSignState(signState), info);
                            } else {
                                label.hideIcon();
                            }

                            removeButton.setOnAction(e -> onDeleteAccount(item));
                            setGraphic(pane);
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 62 2006 40 2007 60 2005 62 411 41 123 450 418 2004 60 62 40 41 123 381 2008 2009 61 418 2008 40 648 44 2010 46 2011 41 59 381 2012 2013 61 2014 46 2015 40 2014 46 2016 41 59 381 2017 2018 61 418 2019 40 648 44 2013 41 59 381 2020 2021 61 418 2020 40 2009 44 2018 41 59 123 2009 46 2022 40 1502 41 59 2018 46 2023 40 648 41 59 2020 46 2024 40 2018 44 1500 41 59 125 64 2003 439 492 2025 40 381 2005 2026 44 324 362 41 123 463 46 2025 40 2026 44 362 41 59 392 40 2026 631 424 605 33 362 41 123 2009 46 2027 40 2026 46 2028 40 41 41 59 324 2029 61 2030 46 2031 40 2026 46 2032 40 41 44 2026 46 2033 40 41 41 59 392 40 2029 41 123 2034 46 2035 2036 61 2037 46 2038 40 2037 46 2039 40 2026 46 2040 41 41 59 2041 2042 61 2043 46 2044 40 2036 46 2045 40 41 41 59 2009 46 2046 40 2047 46 2048 40 2036 41 44 2042 41 59 125 360 123 2009 46 2049 40 41 59 125 2018 46 2050 40 2051 45 62 2052 40 2026 41 41 59 2053 40 2021 41 59 125 360 123 2054 40 424 41 59 125 125 125 59 125 125 41 59 
5114,Java,"                return new ListCell<>() {
                    final InfoAutoTooltipLabel label = new InfoAutoTooltipLabel("""", ContentDisplay.RIGHT);
                    final ImageView icon = ImageUtil.getImageViewById(ImageUtil.REMOVE_ICON);
                    final Button removeButton = new AutoTooltipButton("""", icon);
                    final AnchorPane pane = new AnchorPane(label, removeButton);

                    {
                        label.setLayoutY(5);
                        removeButton.setId(""icon-button"");
                        AnchorPane.setRightAnchor(removeButton, 0d);
                    }

                    @Override
                    public void updateItem(final PaymentAccount item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            label.setText(item.getAccountName());

                            boolean needsSigning = PaymentMethod.hasChargebackRisk(item.getPaymentMethod(),
                                    item.getTradeCurrencies());

                            if (needsSigning) {
                                AccountAgeWitnessService.SignState signState =
                                        accountAgeWitnessService.getSignState(accountAgeWitnessService.getMyWitness(
                                                item.paymentAccountPayload));

                                String info = StringUtils.capitalize(signState.getDisplayString());
                                label.setIcon(GUIUtil.getIconForSignState(signState), info);
                            } else {
                                label.hideIcon();
                            }

                            removeButton.setOnAction(e -> onDeleteAccount(item));
                            setGraphic(pane);
                        } else {
                            setGraphic(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 381 2001 2002 61 418 2001 40 648 44 2003 46 2004 41 59 381 2005 2006 61 2007 46 2008 40 2007 46 2009 41 59 381 2010 2011 61 418 2012 40 648 44 2006 41 59 381 2013 2014 61 418 2013 40 2002 44 2011 41 59 123 2002 46 2015 40 1502 41 59 2011 46 2016 40 648 41 59 2013 46 2017 40 2011 44 1500 41 59 125 64 2018 439 492 2019 40 381 2020 2021 44 324 362 41 123 463 46 2019 40 2021 44 362 41 59 392 40 2021 631 424 605 33 362 41 123 2002 46 2022 40 2021 46 2023 40 41 41 59 324 2024 61 2025 46 2026 40 2021 46 2027 40 41 44 2021 46 2028 40 41 41 59 392 40 2024 41 123 2029 46 2030 2031 61 2032 46 2033 40 2032 46 2034 40 2021 46 2035 41 41 59 2036 2037 61 2038 46 2039 40 2031 46 2040 40 41 41 59 2002 46 2041 40 2042 46 2043 40 2031 41 44 2037 41 59 125 360 123 2002 46 2044 40 41 59 125 2011 46 2045 40 2046 45 62 2047 40 2021 41 41 59 2048 40 2014 41 59 125 360 123 2049 40 424 41 59 125 125 125 59 
5715,Java,"        ClockWatcher.Listener clockListener = new ClockWatcher.Listener() {
            @Override
            public void onSecondTick() {
            }

            @Override
            public void onMinuteTick() {
            }

            @Override
            public void onAwakeFromStandby(long missedMs) {
                if (missedMs > TimeUnit.SECONDS.toMillis(10)) {
                    String key = ""clockWatcherWarning"";
                    if (DontShowAgainLookup.showAgain(key)) {
                        new Popup().warning(Res.get(""mainView.networkWarning.clockWatcher"", missedMs / 1000))
                                .actionButtonText(Res.get(""shared.iUnderstand""))
                                .useIUnderstandButton()
                                .dontShowAgainId(key)
                                .hideCloseButton()
                                .show();
                    }
                }
            }
        };",0,2000 46 2001 2002 61 418 2000 46 2001 40 41 123 64 2003 439 492 2004 40 41 123 125 64 2003 439 492 2005 40 41 123 125 64 2003 439 492 2006 40 413 2007 41 123 392 40 2007 62 2008 46 2009 46 2010 40 1502 41 41 123 2011 2012 61 648 59 392 40 2013 46 2014 40 2012 41 41 123 418 2015 40 41 46 494 40 2016 46 2017 40 648 44 2007 47 1504 41 41 46 2018 40 2016 46 2017 40 648 41 41 46 2019 40 41 46 2020 40 2012 41 46 2021 40 41 46 2022 40 41 59 125 125 125 125 59 
2828,Java,"        availableBalanceBox.first.tooltipProperty().bind(new ObjectBinding<>() {
            {
                bind(model.getAvailableBalance());
                bind(model.getMarketPrice());
            }

            @Override
            protected Tooltip computeValue() {
                String tooltipText = Res.get(""mainView.balance.available"");
                try {
                    String preferredTradeCurrency = model.getPreferences().getPreferredTradeCurrency().getCode();
                    double availableBalance = Double.parseDouble(
                            model.getAvailableBalance().getValue().replace(""BTC"", """"));
                    double marketPrice = Double.parseDouble(model.getMarketPrice(preferredTradeCurrency).getValue());
                    tooltipText += ""\n"" + currencyFormat.format(availableBalance * marketPrice) +
                            "" "" + preferredTradeCurrency;
                } catch (NullPointerException | NumberFormatException e) {
                    // Either the balance or market price is not available yet
                }
                return new Tooltip(tooltipText);
            }
        });",0,2000 46 2001 46 2002 40 41 46 2003 40 418 2004 60 62 40 41 123 123 2003 40 2005 46 2006 40 41 41 59 2003 40 2005 46 2007 40 41 41 59 125 64 2008 438 2009 2010 40 41 123 2011 2012 61 2013 46 2014 40 648 41 59 474 123 2011 2015 61 2016 46 2017 40 41 46 2018 40 41 46 2019 40 41 59 356 2020 61 2021 46 2022 40 2016 46 2023 40 41 46 2024 40 41 46 2025 40 648 44 648 41 41 59 356 2026 61 2021 46 2022 40 2016 46 2027 40 2015 41 46 2024 40 41 41 59 2012 636 648 43 2028 46 2029 40 2020 42 2026 41 43 648 43 2015 59 125 329 40 2030 124 2031 2032 41 123 621 125 450 418 2009 40 2012 41 59 125 125 41 59 
2830,Java,"        lockedBalanceBox.first.tooltipProperty().bind(new ObjectBinding<>() {
            {
                bind(model.getLockedBalance());
                bind(model.getMarketPrice());
            }

            @Override
            protected Tooltip computeValue() {
                String tooltipText = Res.get(""mainView.balance.locked"");
                try {
                    String preferredTradeCurrency = model.getPreferences().getPreferredTradeCurrency().getCode();
                    double lockedBalance = Double.parseDouble(
                            model.getLockedBalance().getValue().replace(""BTC"", """"));
                    double marketPrice = Double.parseDouble(model.getMarketPrice(preferredTradeCurrency).getValue());
                    tooltipText += ""\n"" + currencyFormat.format(lockedBalance * marketPrice) +
                            "" "" + preferredTradeCurrency;
                } catch (NullPointerException | NumberFormatException e) {
                    // Either the balance or market price is not available yet
                }
                return new Tooltip(tooltipText);
            }
        });",0,2000 46 2001 46 2002 40 41 46 2003 40 418 2004 60 62 40 41 123 123 2003 40 2005 46 2006 40 41 41 59 2003 40 2005 46 2007 40 41 41 59 125 64 2008 438 2009 2010 40 41 123 2011 2012 61 2013 46 2014 40 648 41 59 474 123 2011 2015 61 2016 46 2017 40 41 46 2018 40 41 46 2019 40 41 59 356 2020 61 2021 46 2022 40 2016 46 2023 40 41 46 2024 40 41 46 2025 40 648 44 648 41 41 59 356 2026 61 2021 46 2022 40 2016 46 2027 40 2015 41 46 2024 40 41 41 59 2012 636 648 43 2028 46 2029 40 2020 42 2026 41 43 648 43 2015 59 125 329 40 2030 124 2031 2032 41 123 621 125 450 418 2009 40 2012 41 59 125 125 41 59 
3889,Java,"@Slf4j
public class RevolutForm extends PaymentMethodForm {
    private final RevolutAccount account;
    private RevolutValidator validator;
    private InputTextField userNameInputTextField;

    public static int addFormForBuyer(GridPane gridPane, int gridRow,
                                      PaymentAccountPayload paymentAccountPayload) {
        Tuple2<String, String> tuple = ((RevolutAccountPayload) paymentAccountPayload).getRecipientsAccountData();
        addCompactTopLabelTextFieldWithCopyIcon(gridPane, ++gridRow, tuple.first, tuple.second);
        return gridRow;
    }

    public RevolutForm(PaymentAccount paymentAccount, AccountAgeWitnessService accountAgeWitnessService,
                       RevolutValidator revolutValidator, InputValidator inputValidator, GridPane gridPane,
                       int gridRow, CoinFormatter formatter) {
        super(paymentAccount, accountAgeWitnessService, inputValidator, gridPane, gridRow, formatter);
        this.account = (RevolutAccount) paymentAccount;
        this.validator = revolutValidator;
    }

    @Override
    public void addFormForAddAccount() {
        gridRowFrom = gridRow + 1;

        userNameInputTextField = FormBuilder.addInputTextField(gridPane, ++gridRow, Res.get(""payment.account.userName""));
        userNameInputTextField.setValidator(validator);
        userNameInputTextField.textProperty().addListener((ov, oldValue, newValue) -> {
            account.setUserName(newValue.trim());
            updateFromInputs();
        });

        addCurrenciesGrid(true);
        addLimitations(false);
        addAccountNameTextFieldWithAutoFillToggleButton();
    }

    private void addCurrenciesGrid(boolean isEditable) {
        FlowPane flowPane = addTopLabelFlowPane(gridPane, ++gridRow,
                Res.get(""payment.supportedCurrencies""), Layout.FLOATING_LABEL_DISTANCE * 3,
                Layout.FLOATING_LABEL_DISTANCE * 3).second;

        if (isEditable)
            flowPane.setId(""flow-pane-checkboxes-bg"");
        else
            flowPane.setId(""flow-pane-checkboxes-non-editable-bg"");

        CurrencyUtil.getAllRevolutCurrencies().forEach(e ->
                fillUpFlowPaneWithCurrencies(isEditable, flowPane, e, account));
    }

    @Override
    protected void autoFillNameTextField() {
        setAccountNameWithString(userNameInputTextField.getText());
    }

    @Override
    public void addFormForDisplayAccount() {
        gridRowFrom = gridRow;
        addTopLabelTextField(gridPane, gridRow, Res.get(""payment.account.name""),
                account.getAccountName(), Layout.FIRST_ROW_AND_GROUP_DISTANCE);
        addCompactTopLabelTextField(gridPane, ++gridRow, Res.get(""shared.paymentMethod""),
                Res.get(account.getPaymentMethod().getId()));

        String userName = account.getUserName();
        TextField userNameTf = addCompactTopLabelTextField(gridPane, ++gridRow, Res.get(""payment.account.userName""), userName).second;
        userNameTf.setMouseTransparent(false);

        if (account.hasOldAccountId()) {
            String accountId = account.getAccountId();
            TextField accountIdTf = addCompactTopLabelTextField(gridPane, ++gridRow, Res.get(""payment.account.phoneNr""), accountId).second;
            accountIdTf.setMouseTransparent(false);
        }

        addLimitations(true);
        addCurrenciesGrid(false);
    }

    @Override
    public void updateAllInputsValid() {
        allInputsValid.set(isAccountNameValid()
                && validator.validate(account.getUserName()).isValid
                && account.getTradeCurrencies().size() > 0);
    }
}",0,64 2000 439 334 2001 378 2002 123 437 381 2003 2004 59 437 2005 2006 59 437 2007 2008 59 439 457 404 2009 40 2010 2011 44 404 2012 44 2013 2014 41 123 2015 60 2016 44 2016 62 2017 61 40 40 2018 41 2014 41 46 2019 40 41 59 2020 40 2011 44 637 2012 44 2017 46 2021 44 2017 46 2022 41 59 450 2012 59 125 439 2001 40 2023 2024 44 2025 2026 44 2005 2027 44 2028 2029 44 2010 2011 44 404 2012 44 2030 2031 41 123 463 40 2024 44 2026 44 2029 44 2011 44 2012 44 2031 41 59 467 46 2004 61 40 2003 41 2024 59 467 46 2006 61 2027 59 125 64 2032 439 492 2033 40 41 123 2034 61 2012 43 1501 59 2008 61 2035 46 2036 40 2011 44 637 2012 44 2037 46 2038 40 648 41 41 59 2008 46 2039 40 2006 41 59 2008 46 2040 40 41 46 2041 40 40 2042 44 2043 44 2044 41 45 62 123 2004 46 2045 40 2044 46 2046 40 41 41 59 2047 40 41 59 125 41 59 2048 40 473 41 59 2049 40 380 41 59 2050 40 41 59 125 437 492 2051 40 324 2052 41 123 2053 2054 61 2055 40 2011 44 637 2012 44 2056 46 2057 40 648 41 44 2058 46 2059 42 1502 44 2058 46 2059 42 1502 41 46 2060 59 392 40 2052 41 2054 46 2061 40 648 41 59 360 2054 46 2061 40 648 41 59 2062 46 2063 40 41 46 2064 40 2065 45 62 2066 40 2052 44 2054 44 2065 44 2004 41 41 59 125 64 2032 438 492 2067 40 41 123 2068 40 2008 46 2069 40 41 41 59 125 64 2032 439 492 2070 40 41 123 2071 61 2012 59 2072 40 2011 44 2012 44 2073 46 2074 40 648 41 44 2004 46 2075 40 41 44 2076 46 2077 41 59 2078 40 2011 44 637 2012 44 2073 46 2074 40 648 41 44 2073 46 2074 40 2004 46 2079 40 41 46 2080 40 41 41 41 59 2081 2082 61 2004 46 2083 40 41 59 2084 2085 61 2078 40 2011 44 637 2012 44 2073 46 2074 40 648 41 44 2082 41 46 2086 59 2085 46 2087 40 380 41 59 392 40 2004 46 2088 40 41 41 123 2081 2089 61 2004 46 2090 40 41 59 2084 2091 61 2078 40 2011 44 637 2012 44 2073 46 2074 40 648 41 44 2089 41 46 2086 59 2091 46 2087 40 380 41 59 125 2092 40 473 41 59 2051 40 380 41 59 125 64 2032 439 492 2093 40 41 123 2094 46 2095 40 2096 40 41 605 2006 46 2097 40 2004 46 2098 40 41 41 46 2099 605 2004 46 2100 40 41 46 2101 40 41 62 1500 41 59 125 125 
5221,Java,"        currencyComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(TradeCurrency tradeCurrency) {
                return tradeCurrency.getNameAndCode();
            }

            @Override
            public TradeCurrency fromString(String s) {
                return null;
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 450 2007 46 2008 40 41 59 125 64 2003 439 2006 2009 40 2004 2010 41 123 450 424 59 125 125 41 59 
3197,Java,"public class AssetsForm extends PaymentMethodForm {
    public static final String INSTANT_TRADE_NEWS = ""instantTradeNews0.9.5"";
    private final AssetAccount assetAccount;
    private final AltCoinAddressValidator altCoinAddressValidator;
    private final AssetService assetService;
    private final FilterManager filterManager;

    private InputTextField addressInputTextField;
    private CheckBox tradeInstantCheckBox;
    private boolean tradeInstant;

    public static int addFormForBuyer(GridPane gridPane,
                                      int gridRow,
                                      PaymentAccountPayload paymentAccountPayload,
                                      String labelTitle) {
        addCompactTopLabelTextFieldWithCopyIcon(gridPane, ++gridRow, labelTitle,
                ((AssetsAccountPayload) paymentAccountPayload).getAddress());
        return gridRow;
    }

    public AssetsForm(PaymentAccount paymentAccount,
                      AccountAgeWitnessService accountAgeWitnessService,
                      AltCoinAddressValidator altCoinAddressValidator,
                      InputValidator inputValidator,
                      GridPane gridPane,
                      int gridRow,
                      CoinFormatter formatter,
                      AssetService assetService,
                      FilterManager filterManager) {
        super(paymentAccount, accountAgeWitnessService, inputValidator, gridPane, gridRow, formatter);
        this.assetAccount = (AssetAccount) paymentAccount;
        this.altCoinAddressValidator = altCoinAddressValidator;
        this.assetService = assetService;
        this.filterManager = filterManager;

        tradeInstant = paymentAccount instanceof InstantCryptoCurrencyAccount;
    }

    @Override
    public void addFormForAddAccount() {
        gridRowFrom = gridRow + 1;

        addTradeCurrencyComboBox();
        currencyComboBox.setPrefWidth(250);

        tradeInstantCheckBox = addLabelCheckBox(gridPane, ++gridRow,
                Res.get(""payment.altcoin.tradeInstantCheckbox""), 10);
        tradeInstantCheckBox.setSelected(tradeInstant);
        tradeInstantCheckBox.setOnAction(e -> {
            tradeInstant = tradeInstantCheckBox.isSelected();
            if (tradeInstant)
                new Popup().information(Res.get(""payment.altcoin.tradeInstant.popup"")).show();
            paymentLimitationsTextField.setText(getLimitationsText());
        });

        gridPane.getChildren().remove(tradeInstantCheckBox);
        tradeInstantCheckBox.setPadding(new Insets(0, 40, 0, 0));

        gridPane.getChildren().add(tradeInstantCheckBox);

        addressInputTextField = FormBuilder.addInputTextField(gridPane, ++gridRow,
                Res.get(""payment.altcoin.address""));
        addressInputTextField.setValidator(altCoinAddressValidator);

        addressInputTextField.textProperty().addListener((ov, oldValue, newValue) -> {
            if (newValue.startsWith(""monero:"")) {
                UserThread.execute(() -> {
                    String addressWithoutPrefix = newValue.replace(""monero:"", """");
                    addressInputTextField.setText(addressWithoutPrefix);
                });
                return;
            }
            assetAccount.setAddress(newValue);
            updateFromInputs();
        });

        addLimitations(false);
        addAccountNameTextFieldWithAutoFillToggleButton();
    }

    @Override
    public PaymentAccount getPaymentAccount() {
        if (tradeInstant) {
            InstantCryptoCurrencyAccount instantCryptoCurrencyAccount = new InstantCryptoCurrencyAccount();
            instantCryptoCurrencyAccount.init();
            instantCryptoCurrencyAccount.setAccountName(paymentAccount.getAccountName());
            instantCryptoCurrencyAccount.setSaltAsHex(paymentAccount.getSaltAsHex());
            instantCryptoCurrencyAccount.setSalt(paymentAccount.getSalt());
            instantCryptoCurrencyAccount.setSingleTradeCurrency(paymentAccount.getSingleTradeCurrency());
            instantCryptoCurrencyAccount.setSelectedTradeCurrency(paymentAccount.getSelectedTradeCurrency());
            instantCryptoCurrencyAccount.setAddress(assetAccount.getAddress());
            return instantCryptoCurrencyAccount;
        } else {
            return paymentAccount;
        }
    }

    @Override
    public void updateFromInputs() {
        if (addressInputTextField != null && assetAccount.getSingleTradeCurrency() != null)
            addressInputTextField.setPromptText(Res.get(""payment.altcoin.address.dyn"",
                    assetAccount.getSingleTradeCurrency().getName()));
        super.updateFromInputs();
    }

    @Override
    protected void autoFillNameTextField() {
        if (useCustomAccountNameToggleButton != null && !useCustomAccountNameToggleButton.isSelected()) {
            accountNameTextField.setText(createAssetsAccountName(paymentAccount, addressInputTextField.getText()));
        }
    }

    @Override
    public void addFormForDisplayAccount() {
        gridRowFrom = gridRow;
        addTopLabelTextField(gridPane, gridRow, Res.get(""payment.account.name""),
                assetAccount.getAccountName(), Layout.FIRST_ROW_AND_GROUP_DISTANCE);
        addCompactTopLabelTextField(gridPane, ++gridRow, Res.get(""shared.paymentMethod""),
                Res.get(assetAccount.getPaymentMethod().getId()));
        Tuple3<Label, TextField, VBox> tuple2 = addCompactTopLabelTextField(gridPane, ++gridRow,
                Res.get(""payment.altcoin.address""), assetAccount.getAddress());
        TextField field = tuple2.second;
        field.setMouseTransparent(false);
        final TradeCurrency singleTradeCurrency = assetAccount.getSingleTradeCurrency();
        final String nameAndCode = singleTradeCurrency != null ? singleTradeCurrency.getNameAndCode() : """";
        addCompactTopLabelTextField(gridPane, ++gridRow, Res.get(""payment.altcoin""),
                nameAndCode);
        addLimitations(true);
    }

    @Override
    public void updateAllInputsValid() {
        TradeCurrency selectedTradeCurrency = assetAccount.getSelectedTradeCurrency();
        if (selectedTradeCurrency != null) {
            altCoinAddressValidator.setCurrencyCode(selectedTradeCurrency.getCode());
            allInputsValid.set(isAccountNameValid()
                    && altCoinAddressValidator.validate(assetAccount.getAddress()).isValid
                    && assetAccount.getSingleTradeCurrency() != null);
        }
    }

    @Override
    protected void addTradeCurrencyComboBox() {
        currencyComboBox = FormBuilder.<TradeCurrency>addLabelAutocompleteComboBox(gridPane, ++gridRow, Res.get(""payment.altcoin""),
                Layout.FIRST_ROW_AND_GROUP_DISTANCE).second;
        currencyComboBox.setPromptText(Res.get(""payment.select.altcoin""));
        currencyComboBox.setButtonCell(getComboBoxButtonCell(Res.get(""payment.select.altcoin""), currencyComboBox));

        currencyComboBox.getEditor().focusedProperty().addListener(observable ->
                currencyComboBox.setPromptText(""""));

        ((AutocompleteComboBox<TradeCurrency>) currencyComboBox).setAutocompleteItems(
                CurrencyUtil.getActiveSortedCryptoCurrencies(assetService, filterManager));
        currencyComboBox.setVisibleRowCount(Math.min(currencyComboBox.getItems().size(), 10));

        currencyComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(TradeCurrency tradeCurrency) {
                return tradeCurrency != null ? tradeCurrency.getNameAndCode() : """";
            }

            @Override
            public TradeCurrency fromString(String s) {
                return currencyComboBox.getItems().stream().
                        filter(item -> item.getNameAndCode().equals(s)).
                        findAny().orElse(null);
            }
        });

        ((AutocompleteComboBox<?>) currencyComboBox).setOnChangeConfirmed(e -> {
            addressInputTextField.resetValidation();
            addressInputTextField.validate();
            TradeCurrency tradeCurrency = currencyComboBox.getSelectionModel().getSelectedItem();
            paymentAccount.setSingleTradeCurrency(tradeCurrency);
            updateFromInputs();

            if (tradeCurrency != null && tradeCurrency.getCode().equals(""BSQ"")) {
                new Popup().information(Res.get(""payment.select.altcoin.bsq.warning"")).show();
            }
        });
    }
}",0,439 334 2000 378 2001 123 439 457 381 2002 2003 61 648 59 437 381 2004 2005 59 437 381 2006 2007 59 437 381 2008 2009 59 437 381 2010 2011 59 437 2012 2013 59 437 2014 2015 59 437 324 2016 59 439 457 404 2017 40 2018 2019 44 404 2020 44 2021 2022 44 2002 2023 41 123 2024 40 2019 44 637 2020 44 2023 44 40 40 2025 41 2022 41 46 2026 40 41 41 59 450 2020 59 125 439 2000 40 2027 2028 44 2029 2030 44 2006 2007 44 2031 2032 44 2018 2019 44 404 2020 44 2033 2034 44 2008 2009 44 2010 2011 41 123 463 40 2028 44 2030 44 2032 44 2019 44 2020 44 2034 41 59 467 46 2005 61 40 2004 41 2028 59 467 46 2007 61 2007 59 467 46 2009 61 2009 59 467 46 2011 61 2011 59 2016 61 2028 402 2035 59 125 64 2036 439 492 2037 40 41 123 2038 61 2020 43 1501 59 2039 40 41 59 2040 46 2041 40 1504 41 59 2015 61 2042 40 2019 44 637 2020 44 2043 46 2044 40 648 41 44 1502 41 59 2015 46 2045 40 2016 41 59 2015 46 2046 40 2047 45 62 123 2016 61 2015 46 2048 40 41 59 392 40 2016 41 418 2049 40 41 46 2050 40 2043 46 2044 40 648 41 41 46 2051 40 41 59 2052 46 2053 40 2054 40 41 41 59 125 41 59 2019 46 2055 40 41 46 2056 40 2015 41 59 2015 46 2057 40 418 2058 40 1500 44 1503 44 1500 44 1500 41 41 59 2019 46 2055 40 41 46 2059 40 2015 41 59 2013 61 2060 46 2061 40 2019 44 637 2020 44 2043 46 2044 40 648 41 41 59 2013 46 2062 40 2007 41 59 2013 46 2063 40 41 46 2064 40 40 2065 44 2066 44 2067 41 45 62 123 392 40 2067 46 2068 40 648 41 41 123 2069 46 2070 40 40 41 45 62 123 2002 2071 61 2067 46 2072 40 648 44 648 41 59 2013 46 2073 40 2071 41 59 125 41 59 450 59 125 2005 46 2074 40 2067 41 59 2075 40 41 59 125 41 59 2076 40 380 41 59 2077 40 41 59 125 64 2036 439 2027 2078 40 41 123 392 40 2016 41 123 2079 2080 61 418 2079 40 41 59 2080 46 2081 40 41 59 2080 46 2082 40 2028 46 2083 40 41 41 59 2080 46 2084 40 2028 46 2085 40 41 41 59 2080 46 2086 40 2028 46 2087 40 41 41 59 2080 46 2088 40 2028 46 2089 40 41 41 59 2080 46 2090 40 2028 46 2091 40 41 41 59 2080 46 2092 40 2005 46 2093 40 41 41 59 450 2080 59 125 360 123 450 2028 59 125 125 64 2036 439 492 2094 40 41 123 392 40 2013 631 424 605 2005 46 2095 40 41 631 424 41 2013 46 2096 40 2097 46 2098 40 648 44 2005 46 2095 40 41 46 2099 40 41 41 41 59 463 46 2094 40 41 59 125 64 2036 438 492 2100 40 41 123 392 40 2101 631 424 605 33 2101 46 2102 40 41 41 123 2103 46 2104 40 2105 40 2028 44 2013 46 2106 40 41 41 41 59 125 125 64 2036 439 492 2107 40 41 123 2108 61 2020 59 2109 40 2019 44 2020 44 2110 46 2111 40 648 41 44 2005 46 2112 40 41 44 2113 46 2114 41 59 2115 40 2019 44 637 2020 44 2110 46 2111 40 648 41 44 2110 46 2111 40 2005 46 2116 40 41 46 2117 40 41 41 41 59 2118 60 2119 44 2120 44 2121 62 2122 61 2115 40 2019 44 637 2020 44 2110 46 2111 40 648 41 44 2005 46 2123 40 41 41 59 2120 2124 61 2122 46 2125 59 2124 46 2126 40 380 41 59 381 2127 2128 61 2005 46 2129 40 41 59 381 2002 2130 61 2128 631 424 63 2128 46 2131 40 41 58 648 59 2115 40 2019 44 637 2020 44 2110 46 2111 40 648 41 44 2130 41 59 2132 40 473 41 59 125 64 2036 439 492 2133 40 41 123 2134 2135 61 2005 46 2136 40 41 59 392 40 2135 631 424 41 123 2007 46 2137 40 2135 46 2138 40 41 41 59 2139 46 2140 40 2141 40 41 605 2007 46 2142 40 2005 46 2143 40 41 41 46 2144 605 2005 46 2145 40 41 631 424 41 59 125 125 64 2036 438 492 2146 40 41 123 2147 61 2148 46 60 2149 62 2150 40 2019 44 637 2020 44 2151 46 2152 40 648 41 44 2153 46 2154 41 46 2155 59 2147 46 2156 40 2151 46 2152 40 648 41 41 59 2147 46 2157 40 2158 40 2151 46 2152 40 648 41 44 2147 41 41 59 2147 46 2159 40 41 46 2160 40 41 46 2161 40 2162 45 62 2147 46 2156 40 648 41 41 59 40 40 2163 60 2149 62 41 2147 41 46 2164 40 2165 46 2166 40 2009 44 2011 41 41 59 2147 46 2167 40 2168 46 2169 40 2147 46 2170 40 41 46 2171 40 41 44 1502 41 41 59 2147 46 2172 40 418 2173 60 62 40 41 123 64 2036 439 2002 2174 40 2149 2175 41 123 450 2175 631 424 63 2175 46 2176 40 41 58 648 59 125 64 2036 439 2149 2177 40 2002 2178 41 123 450 2147 46 2170 40 41 46 2179 40 41 46 2180 40 2181 45 62 2181 46 2182 40 41 46 2183 40 2178 41 41 46 2184 40 41 46 2185 40 424 41 59 125 125 41 59 40 40 2163 60 63 62 41 2147 41 46 2186 40 2187 45 62 123 2013 46 2188 40 41 59 2013 46 2189 40 41 59 2149 2190 61 2147 46 2191 40 41 46 2192 40 41 59 2028 46 2193 40 2190 41 59 2094 40 41 59 392 40 2190 631 424 605 2190 46 2194 40 41 46 2195 40 648 41 41 123 418 2196 40 41 46 2197 40 2151 46 2152 40 648 41 41 46 2198 40 41 59 125 125 41 59 125 125 
3284,Java,"public class ExternalHyperlink extends HyperlinkWithIcon {

    public ExternalHyperlink(String text) {
        super(text, MaterialDesignIcon.LINK);
    }

    public ExternalHyperlink(String text, String style) {
        super(text, MaterialDesignIcon.LINK, style);
    }

    public ExternalHyperlink(String text, String style, String iconSize) {
        super(text, MaterialDesignIcon.LINK, style, iconSize);
    }
}",0,439 334 2000 378 2001 123 439 2000 40 2002 2003 41 123 463 40 2003 44 2004 46 2005 41 59 125 439 2000 40 2002 2003 44 2002 2006 41 123 463 40 2003 44 2007 46 2008 44 2006 41 59 125 439 2000 40 2002 2003 44 2002 2006 44 2002 2009 41 123 463 40 2003 44 2010 46 2011 44 2006 44 2009 41 59 125 125 
5622,Java,"public class UserPayloadModelVOTest {
    @Ignore(""TODO InvalidKeySpecException at bisq.common.crypto.Sig.getPublicKeyFromBytes(Sig.java:135)"")
    public void testRoundtrip() {
        UserPayload vo = new UserPayload();
        vo.setAccountId(""accountId"");
        UserPayload newVo = UserPayload.fromProto(vo.toProtoMessage().getUserPayload(), new CoreProtoResolver());
    }

    @Ignore(""TODO InvalidKeySpecException at bisq.common.crypto.Sig.getPublicKeyFromBytes(Sig.java:135)"")
    public void testRoundtripFull() {
        UserPayload vo = new UserPayload();
        vo.setAccountId(""accountId"");
        vo.setDisplayedAlert(new Alert(""message"", true, false, ""version"", new byte[]{12, -64, 12}, ""string"", null));
        vo.setDevelopersFilter(new Filter(Lists.newArrayList(),
                Lists.newArrayList(),
                Lists.newArrayList(),
                Lists.newArrayList(),
                Lists.newArrayList(),
                Lists.newArrayList(),
                Lists.newArrayList(),
                Lists.newArrayList(),
                false,
                Lists.newArrayList(),
                false,
                null,
                null,
                Lists.newArrayList(),
                Lists.newArrayList(),
                Lists.newArrayList(),
                Lists.newArrayList(),
                null,
                0,
                null,
                null,
                null,
                null,
                false,
                Lists.newArrayList(),
                new HashSet<>(),
                false,
                false,
                false,
                0,
                Lists.newArrayList(),
                0,
                0,
                0,
                0));

        vo.setRegisteredArbitrator(ArbitratorTest.getArbitratorMock());
        vo.setRegisteredMediator(MediatorTest.getMediatorMock());
        vo.setAcceptedArbitrators(Lists.newArrayList(ArbitratorTest.getArbitratorMock()));
        vo.setAcceptedMediators(Lists.newArrayList(MediatorTest.getMediatorMock()));
        UserPayload newVo = UserPayload.fromProto(vo.toProtoMessage().getUserPayload(), new CoreProtoResolver());
    }
}",0,439 334 2000 123 64 2001 40 648 41 439 492 2002 40 41 123 2003 2004 61 418 2003 40 41 59 2004 46 2005 40 648 41 59 2003 2006 61 2003 46 2007 40 2004 46 2008 40 41 46 2009 40 41 44 418 2010 40 41 41 59 125 64 2001 40 648 41 439 492 2011 40 41 123 2012 2013 61 418 2012 40 41 59 2013 46 2014 40 648 41 59 2013 46 2015 40 418 2016 40 648 44 473 44 380 44 648 44 418 326 91 93 123 1503 44 45 1503 44 1503 125 44 648 44 424 41 41 59 2013 46 2017 40 418 2018 40 2019 46 2020 40 41 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 380 44 2019 46 2020 40 41 44 380 44 424 44 424 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 2019 46 2020 40 41 44 424 44 1500 44 424 44 424 44 424 44 424 44 380 44 2019 46 2020 40 41 44 418 2021 60 62 40 41 44 380 44 380 44 380 44 1500 44 2019 46 2020 40 41 44 1500 44 1500 44 1500 44 1500 41 41 59 2013 46 2022 40 2023 46 2024 40 41 41 59 2013 46 2025 40 2026 46 2027 40 41 41 59 2013 46 2028 40 2019 46 2020 40 2023 46 2024 40 41 41 41 59 2013 46 2029 40 2019 46 2020 40 2026 46 2027 40 41 41 41 59 2012 2030 61 2012 46 2031 40 2013 46 2032 40 41 46 2033 40 41 44 418 2034 40 41 41 59 125 125 
4666,Java,"                new SendMailboxMessageListener() {
                    @Override
                    public void onArrived() {
                        log.info(""{} arrived at peer {}. tradeId={}, peerOpenedDisputeMessage.uid={}, "" +
                                        ""chatMessage.uid={}"",
                                peerOpenedDisputeMessage.getClass().getSimpleName(), peersNodeAddress,
                                peerOpenedDisputeMessage.getTradeId(), peerOpenedDisputeMessage.getUid(),
                                chatMessage.getUid());

                        // We use the chatMessage wrapped inside the peerOpenedDisputeMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setArrived(true);
                        requestPersistence();
                    }

                    @Override
                    public void onStoredInMailbox() {
                        log.info(""{} stored in mailbox for peer {}. tradeId={}, peerOpenedDisputeMessage.uid={}, "" +
                                        ""chatMessage.uid={}"",
                                peerOpenedDisputeMessage.getClass().getSimpleName(), peersNodeAddress,
                                peerOpenedDisputeMessage.getTradeId(), peerOpenedDisputeMessage.getUid(),
                                chatMessage.getUid());

                        // We use the chatMessage wrapped inside the peerOpenedDisputeMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setStoredInMailbox(true);
                        requestPersistence();
                    }

                    @Override
                    public void onFault(String errorMessage) {
                        log.error(""{} failed: Peer {}. tradeId={}, peerOpenedDisputeMessage.uid={}, "" +
                                        ""chatMessage.uid={}, errorMessage={}"",
                                peerOpenedDisputeMessage.getClass().getSimpleName(), peersNodeAddress,
                                peerOpenedDisputeMessage.getTradeId(), peerOpenedDisputeMessage.getUid(),
                                chatMessage.getUid(), errorMessage);

                        // We use the chatMessage wrapped inside the peerOpenedDisputeMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setSendMessageError(errorMessage);
                        requestPersistence();
                    }
                }",0,418 2000 40 41 123 64 2001 439 492 2002 40 41 123 2003 46 2004 40 648 43 648 44 2005 46 2006 40 41 46 2007 40 41 44 2008 44 2005 46 2009 40 41 44 2005 46 2010 40 41 44 2011 46 2010 40 41 41 59 621 621 2011 46 2012 40 473 41 59 2013 40 41 59 125 64 2001 439 492 2014 40 41 123 2015 46 2016 40 648 43 648 44 2017 46 2018 40 41 46 2019 40 41 44 2020 44 2017 46 2021 40 41 44 2017 46 2022 40 41 44 2023 46 2022 40 41 41 59 621 621 2023 46 2024 40 473 41 59 2025 40 41 59 125 64 2001 439 492 2026 40 2027 2028 41 123 2029 46 371 40 648 43 648 44 2030 46 2031 40 41 46 2032 40 41 44 2033 44 2030 46 2034 40 41 44 2030 46 2035 40 41 44 2036 46 2035 40 41 44 2028 41 59 621 621 2036 46 2037 40 2028 41 59 2038 40 41 59 125 125 
3568,Java,"        clockWatcher.addListener(new ClockWatcher.Listener() {
            @Override
            public void onSecondTick() {
            }

            @Override
            public void onMinuteTick() {
                updateTradePeriodState();
            }
        });",0,2000 46 2001 40 418 2002 46 2003 40 41 123 64 2004 439 492 2005 40 41 123 125 64 2004 439 492 2006 40 41 123 2007 40 41 59 125 125 41 59 
3570,Java,"        FutureCallback<Transaction> callback = new FutureCallback<>() {
            @Override
            public void onSuccess(@javax.annotation.Nullable Transaction transaction) {
                if (transaction != null) {
                    log.debug(""onWithdraw onSuccess tx ID:"" + transaction.getTxId().toString());
                    onTradeCompleted(trade);
                    trade.setState(Trade.State.WITHDRAW_COMPLETED);
                    getTradeProtocol(trade).onWithdrawCompleted();
                    requestPersistence();
                    resultHandler.handleResult();
                }
            }

            @Override
            public void onFailure(@NotNull Throwable t) {
                t.printStackTrace();
                log.error(t.getMessage());
                faultHandler.handleFault(""An exception occurred at requestWithdraw (onFailure)."", t);
            }
        };",0,2000 60 2001 62 2002 61 418 2000 60 62 40 41 123 64 2003 439 492 2004 40 64 2005 46 2006 46 2007 2001 2008 41 123 392 40 2008 631 424 41 123 2009 46 2010 40 648 43 2008 46 2011 40 41 46 2012 40 41 41 59 2013 40 2014 41 59 2014 46 2015 40 2016 46 2017 46 2018 41 59 2019 40 2014 41 46 2020 40 41 59 2021 40 41 59 2022 46 2023 40 41 59 125 125 64 2003 439 492 2024 40 64 2025 2026 2027 41 123 2027 46 2028 40 41 59 2029 46 371 40 2027 46 2030 40 41 41 59 2031 46 2032 40 648 44 2027 41 59 125 125 59 
5719,Java,"@Singleton
public class RefundAgentService extends DisputeAgentService<RefundAgent> {
    @Inject
    public RefundAgentService(P2PService p2PService, FilterManager filterManager) {
        super(p2PService, filterManager);
    }

    @Override
    protected Set<RefundAgent> getDisputeAgentSet(List<String> bannedDisputeAgents) {
        return p2PService.getDataMap().values().stream()
                .filter(data -> data.getProtectedStoragePayload() instanceof RefundAgent)
                .map(data -> (RefundAgent) data.getProtectedStoragePayload())
                .filter(a -> bannedDisputeAgents == null ||
                        !bannedDisputeAgents.contains(a.getNodeAddress().getFullAddress()))
                .collect(Collectors.toSet());
    }

    @Override
    protected List<String> getDisputeAgentsFromFilter() {
        return filterManager.getFilter() != null ? filterManager.getFilter().getRefundAgents() : new ArrayList<>();
    }

    public Map<NodeAddress, RefundAgent> getRefundAgents() {
        return super.getDisputeAgents();
    }
}",0,64 2000 439 334 2001 378 2002 60 2003 62 123 64 2004 439 2001 40 2005 2006 44 2007 2008 41 123 463 40 2006 44 2008 41 59 125 64 2009 438 2010 60 2003 62 2011 40 2012 60 2013 62 2014 41 123 450 2006 46 2015 40 41 46 2016 40 41 46 2017 40 41 46 2018 40 2019 45 62 2019 46 2020 40 41 402 2003 41 46 2021 40 2019 45 62 40 2003 41 2019 46 2020 40 41 41 46 2018 40 2022 45 62 2014 614 424 606 33 2014 46 2023 40 2022 46 2024 40 41 46 2025 40 41 41 41 46 2026 40 2027 46 2028 40 41 41 59 125 64 2009 438 2012 60 2013 62 2029 40 41 123 450 2008 46 2030 40 41 631 424 63 2008 46 2030 40 41 46 2031 40 41 58 418 2032 60 62 40 41 59 125 439 2033 60 2034 44 2003 62 2035 40 41 123 450 463 46 2036 40 41 59 125 125 
2980,Java,"@Slf4j
@Singleton
public class RefundAgentManager extends DisputeAgentManager<RefundAgent> {

    @Inject
    public RefundAgentManager(KeyRing keyRing,
                              RefundAgentService refundAgentService,
                              User user,
                              FilterManager filterManager,
                              @Named(Config.USE_DEV_PRIVILEGE_KEYS) boolean useDevPrivilegeKeys) {
        super(keyRing, refundAgentService, user, filterManager, useDevPrivilegeKeys);
    }

    @Override
    protected List<String> getPubKeyList() {
        return List.of(""02a25798e256b800d7ea71c31098ac9a47cb20892176afdfeb051f5ded382d44af"",
                ""0360455d3cffe00ef73cc1284c84eedacc8c5c3374c43f4aac8ffb95f5130b9ef5"",
                ""03b0513afbb531bc4551b379eba027feddd33c92b5990fd477b0fa6eff90a5b7db"",
                ""03533fd75fda29c351298e50b8ea696656dcb8ce4e263d10618c6901a50450bf0e"",
                ""028124436482aa4c61a4bc4097d60c80b09f4285413be3b023a37a0164cbd5d818"",
                ""0384fcf883116d8e9469720ed7808cc4141f6dc6a5ed23d76dd48f2f5f255590d7"",
                ""029bd318ecee4e212ff06a4396770d600d72e9e0c6532142a428bdb401491e9721"",
                ""02e375b4b24d0a858953f7f94666667554d41f78000b9c8a301294223688b29011"",
                ""0232c088ae7c070de89d2b6c8d485b34bf0e3b2a964a2c6622f39ca501260c23f7"",
                ""033e047f74f2aa1ce41e8c85731f97ab83d448d65dc8518ab3df4474a5d53a3d19"",
                ""02f52a8cf373c8cbddb318e523b7f111168bf753fdfb6f8aa81f88c950ede3a5ce"",
                ""039784029922c54bcd0f0e7f14530f586053a5f4e596e86b3474cd7404657088ae"",
                ""037969f9d5ab2cc609104c6e61323df55428f8f108c11aab7c7b5f953081d39304"",
                ""031bd37475b8c5615ac46d6816e791c59d806d72a0bc6739ae94e5fe4545c7f8a6"",
                ""021bb92c636feacf5b082313eb071a63dfcd26501a48b3cd248e35438e5afb7daf"");


    }

    @Override
    protected boolean isExpectedInstance(ProtectedStorageEntry data) {
        return data.getProtectedStoragePayload() instanceof RefundAgent;
    }

    @Override
    protected void addAcceptedDisputeAgentToUser(RefundAgent disputeAgent) {
        user.addAcceptedRefundAgent(disputeAgent);
    }

    @Override
    protected void removeAcceptedDisputeAgentFromUser(ProtectedStorageEntry data) {
        user.removeAcceptedRefundAgent((RefundAgent) data.getProtectedStoragePayload());
    }

    @Override
    protected List<RefundAgent> getAcceptedDisputeAgentsFromUser() {
        return user.getAcceptedRefundAgents();
    }

    @Override
    protected void clearAcceptedDisputeAgentsAtUser() {
        user.clearAcceptedRefundAgents();
    }

    @Override
    protected RefundAgent getRegisteredDisputeAgentFromUser() {
        return user.getRegisteredRefundAgent();
    }

    @Override
    protected void setRegisteredDisputeAgentAtUser(RefundAgent disputeAgent) {
        user.setRegisteredRefundAgent(disputeAgent);
    }
}",0,64 2000 64 2001 439 334 2002 378 2003 60 2004 62 123 64 2005 439 2002 40 2006 2007 44 2008 2009 44 2010 2011 44 2012 2013 44 64 2014 40 2015 46 2016 41 324 2017 41 123 463 40 2007 44 2009 44 2011 44 2013 44 2017 41 59 125 64 2018 438 2019 60 2020 62 2021 40 41 123 450 2019 46 2022 40 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 41 59 125 64 2018 438 324 2023 40 2024 2025 41 123 450 2025 46 2026 40 41 402 2004 59 125 64 2018 438 492 2027 40 2004 2028 41 123 2011 46 2029 40 2028 41 59 125 64 2018 438 492 2030 40 2024 2025 41 123 2011 46 2031 40 40 2004 41 2025 46 2032 40 41 41 59 125 64 2018 438 2019 60 2004 62 2033 40 41 123 450 2011 46 2034 40 41 59 125 64 2018 438 492 2035 40 41 123 2011 46 2036 40 41 59 125 64 2018 438 2004 2037 40 41 123 450 2011 46 2038 40 41 59 125 64 2018 438 492 2039 40 2004 2028 41 123 2011 46 2040 40 2028 41 59 125 125 
4359,Java,"@EqualsAndHashCode(callSuper = true)
@Slf4j
@Getter
public final class RefundAgent extends DisputeAgent implements CapabilityRequiringPayload {

    public RefundAgent(NodeAddress nodeAddress,
                       PubKeyRing pubKeyRing,
                       List<String> languageCodes,
                       long registrationDate,
                       byte[] registrationPubKey,
                       String registrationSignature,
                       @Nullable String emailAddress,
                       @Nullable String info,
                       @Nullable Map<String, String> extraDataMap) {

        super(nodeAddress,
                pubKeyRing,
                languageCodes,
                registrationDate,
                registrationPubKey,
                registrationSignature,
                emailAddress,
                info,
                extraDataMap);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // PROTO BUFFER
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public protobuf.StoragePayload toProtoMessage() {
        protobuf.RefundAgent.Builder builder = protobuf.RefundAgent.newBuilder()
                .setNodeAddress(nodeAddress.toProtoMessage())
                .setPubKeyRing(pubKeyRing.toProtoMessage())
                .addAllLanguageCodes(languageCodes)
                .setRegistrationDate(registrationDate)
                .setRegistrationPubKey(ByteString.copyFrom(registrationPubKey))
                .setRegistrationSignature(registrationSignature);
        Optional.ofNullable(emailAddress).ifPresent(builder::setEmailAddress);
        Optional.ofNullable(info).ifPresent(builder::setInfo);
        Optional.ofNullable(extraDataMap).ifPresent(builder::putAllExtraData);
        return protobuf.StoragePayload.newBuilder().setRefundAgent(builder).build();
    }

    public static RefundAgent fromProto(protobuf.RefundAgent proto) {
        return new RefundAgent(NodeAddress.fromProto(proto.getNodeAddress()),
                PubKeyRing.fromProto(proto.getPubKeyRing()),
                new ArrayList<>(proto.getLanguageCodesList()),
                proto.getRegistrationDate(),
                proto.getRegistrationPubKey().toByteArray(),
                proto.getRegistrationSignature(),
                ProtoUtil.stringOrNullFromProto(proto.getEmailAddress()),
                ProtoUtil.stringOrNullFromProto(proto.getInfo()),
                CollectionUtils.isEmpty(proto.getExtraDataMap()) ? null : proto.getExtraDataMap());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////


    @Override
    public String toString() {
        return ""RefundAgent{} "" + super.toString();
    }

    @Override
    public Capabilities getRequiredCapabilities() {
        return new Capabilities(Capability.REFUND_AGENT);
    }
}",0,64 2000 40 2001 61 473 41 64 2002 64 2003 439 381 334 2004 378 2005 395 2006 123 439 2004 40 2007 2008 44 2009 2010 44 2011 60 2012 62 2013 44 413 2014 44 326 91 93 2015 44 2012 2016 44 64 2017 2012 2018 44 64 2017 2012 2019 44 64 2017 2020 60 2012 44 2012 62 2021 41 123 463 40 2008 44 2010 44 2013 44 2014 44 2015 44 2016 44 2018 44 2019 44 2021 41 59 125 621 621 621 64 2022 439 2023 46 2024 2025 40 41 123 2023 46 2004 46 2026 2027 61 2023 46 2004 46 2028 40 41 46 2029 40 2008 46 2025 40 41 41 46 2030 40 2010 46 2025 40 41 41 46 2031 40 2013 41 46 2032 40 2014 41 46 2033 40 2034 46 2035 40 2015 41 41 46 2036 40 2016 41 59 2037 46 2038 40 2018 41 46 2039 40 2027 58 58 2040 41 59 2037 46 2038 40 2019 41 46 2039 40 2027 58 58 2041 41 59 2037 46 2038 40 2021 41 46 2039 40 2027 58 58 2042 41 59 450 2023 46 2024 46 2028 40 41 46 2043 40 2027 41 46 2044 40 41 59 125 439 457 2004 2045 40 2023 46 2004 2046 41 123 450 418 2004 40 2007 46 2045 40 2046 46 2047 40 41 41 44 2009 46 2045 40 2046 46 2048 40 41 41 44 418 2049 60 62 40 2046 46 2050 40 41 41 44 2046 46 2051 40 41 44 2046 46 2052 40 41 46 2053 40 41 44 2046 46 2054 40 41 44 2055 46 2056 40 2046 46 2057 40 41 41 44 2055 46 2056 40 2046 46 2058 40 41 41 44 2059 46 2060 40 2046 46 2061 40 41 41 63 424 58 2046 46 2061 40 41 41 59 125 621 621 621 64 2022 439 2012 2062 40 41 123 450 648 43 463 46 2062 40 41 59 125 64 2022 439 2063 2064 40 41 123 450 418 2063 40 2065 46 2066 41 59 125 125 
3850,Java,"@Slf4j
public class RefundSession extends DisputeSession {

    public RefundSession(@Nullable Dispute dispute, boolean isTrader) {
        super(dispute, isTrader);
    }
}",0,64 2000 439 334 2001 378 2002 123 439 2001 40 64 2003 2004 2005 44 324 2006 41 123 463 40 2005 44 2006 41 59 125 125 
4984,Java,"@Singleton
public final class RefundDisputeListService extends DisputeListService<RefundDisputeList> {

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public RefundDisputeListService(PersistenceManager<RefundDisputeList> persistenceManager) {
        super(persistenceManager);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Implement template methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    protected RefundDisputeList getConcreteDisputeList() {
        return new RefundDisputeList();
    }
}",0,64 2000 439 381 334 2001 378 2002 60 2003 62 123 621 621 621 64 2004 439 2001 40 2005 60 2003 62 2006 41 123 463 40 2006 41 59 125 621 621 621 64 2007 438 2003 2008 40 41 123 450 418 2003 40 41 59 125 125 
5509,Java,"                        tradeWalletService.broadcastTx(committedDisputedPayoutTx, new TxBroadcaster.Callback() {
                            @Override
                            public void onSuccess(Transaction transaction) {
                                // after successful publish we send peer the tx
                                dispute.setDisputePayoutTxId(transaction.getTxId().toString());
                                sendPeerPublishedPayoutTxMessage(transaction, dispute, contract);
                                updateTradeOrOpenOfferManager(tradeId);
                            }

                            @Override
                            public void onFailure(TxBroadcastException exception) {
                                log.error(exception.getMessage());
                            }
                        }, 15);",0,2000 46 2001 40 2002 44 418 2003 46 2004 40 41 123 64 2005 439 492 2006 40 2007 2008 41 123 621 2009 46 2010 40 2008 46 2011 40 41 46 2012 40 41 41 59 2013 40 2008 44 2009 44 2014 41 59 2015 40 2016 41 59 125 64 2005 439 492 2017 40 2018 2019 41 123 2020 46 371 40 2019 46 2021 40 41 41 59 125 125 44 1503 41 59 
5510,Java,"                new SendMailboxMessageListener() {
                    @Override
                    public void onArrived() {
                        log.info(""{} arrived at peer {}. tradeId={}, uid={}"",
                                message.getClass().getSimpleName(), peersNodeAddress, message.getTradeId(), message.getUid());
                    }

                    @Override
                    public void onStoredInMailbox() {
                        log.info(""{} stored in mailbox for peer {}. tradeId={}, uid={}"",
                                message.getClass().getSimpleName(), peersNodeAddress, message.getTradeId(), message.getUid());
                    }

                    @Override
                    public void onFault(String errorMessage) {
                        log.error(""{} failed: Peer {}. tradeId={}, uid={}, errorMessage={}"",
                                message.getClass().getSimpleName(), peersNodeAddress, message.getTradeId(), message.getUid(), errorMessage);
                    }
                }",0,418 2000 40 41 123 64 2001 439 492 2002 40 41 123 2003 46 2004 40 648 44 2005 46 2006 40 41 46 2007 40 41 44 2008 44 2005 46 2009 40 41 44 2005 46 2010 40 41 41 59 125 64 2001 439 492 2011 40 41 123 2012 46 2013 40 648 44 2014 46 2015 40 41 46 2016 40 41 44 2017 44 2014 46 2018 40 41 44 2014 46 2019 40 41 41 59 125 64 2001 439 492 2020 40 2021 2022 41 123 2023 46 371 40 648 44 2024 46 2025 40 41 46 2026 40 41 44 2027 44 2024 46 2028 40 41 44 2024 46 2029 40 41 44 2022 41 59 125 125 
4151,Java,"@Slf4j
public class CorePersistedDataHost {

    // All classes which are persisting objects need to be added here
    public static List<PersistedDataHost> getPersistedDataHosts(Injector injector) {
        List<PersistedDataHost> persistedDataHosts = new ArrayList<>();
        persistedDataHosts.add(injector.getInstance(Preferences.class));
        persistedDataHosts.add(injector.getInstance(User.class));
        persistedDataHosts.add(injector.getInstance(AddressEntryList.class));
        persistedDataHosts.add(injector.getInstance(OpenOfferManager.class));
        persistedDataHosts.add(injector.getInstance(TradeManager.class));
        persistedDataHosts.add(injector.getInstance(ClosedTradableManager.class));
        persistedDataHosts.add(injector.getInstance(BsqSwapTradeManager.class));
        persistedDataHosts.add(injector.getInstance(FailedTradesManager.class));
        persistedDataHosts.add(injector.getInstance(ArbitrationDisputeListService.class));
        persistedDataHosts.add(injector.getInstance(MediationDisputeListService.class));
        persistedDataHosts.add(injector.getInstance(RefundDisputeListService.class));
        persistedDataHosts.add(injector.getInstance(P2PDataStorage.class));
        persistedDataHosts.add(injector.getInstance(PeerManager.class));
        persistedDataHosts.add(injector.getInstance(MailboxMessageService.class));
        persistedDataHosts.add(injector.getInstance(IgnoredMailboxService.class));
        persistedDataHosts.add(injector.getInstance(RemovedPayloadsService.class));

        if (injector.getInstance(Config.class).daoActivated) {
            persistedDataHosts.add(injector.getInstance(BallotListService.class));
            persistedDataHosts.add(injector.getInstance(MyBlindVoteListService.class));
            persistedDataHosts.add(injector.getInstance(MyVoteListService.class));
            persistedDataHosts.add(injector.getInstance(MyProposalListService.class));
            persistedDataHosts.add(injector.getInstance(MyReputationListService.class));
            persistedDataHosts.add(injector.getInstance(MyProofOfBurnListService.class));
            persistedDataHosts.add(injector.getInstance(UnconfirmedBsqChangeOutputListService.class));
        }
        return persistedDataHosts;
    }
}",0,64 2000 439 334 2001 123 621 439 457 2002 60 2003 62 2004 40 2005 2006 41 123 2002 60 2003 62 2007 61 418 2008 60 62 40 41 59 2007 46 2009 40 2006 46 2010 40 2011 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2012 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2013 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2014 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2015 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2016 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2017 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2018 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2019 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2020 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2021 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2022 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2023 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2024 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2025 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2026 46 334 41 41 59 392 40 2006 46 2010 40 2027 46 334 41 46 2028 41 123 2007 46 2009 40 2006 46 2010 40 2029 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2030 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2031 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2032 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2033 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2034 46 334 41 41 59 2007 46 2009 40 2006 46 2010 40 2035 46 334 41 41 59 125 450 2007 59 125 125 
4536,Java,"@Slf4j
public class CoreNetworkCapabilities {

    static void setSupportedCapabilities(Config config) {
        Capabilities.app.addAll(
                Capability.TRADE_STATISTICS,
                Capability.TRADE_STATISTICS_2,
                Capability.ACCOUNT_AGE_WITNESS,
                Capability.ACK_MSG,
                Capability.PROPOSAL,
                Capability.BLIND_VOTE,
                Capability.DAO_STATE,
                Capability.BUNDLE_OF_ENVELOPES,
                Capability.MEDIATION,
                Capability.SIGNED_ACCOUNT_AGE_WITNESS,
                Capability.REFUND_AGENT,
                Capability.TRADE_STATISTICS_HASH_UPDATE,
                Capability.NO_ADDRESS_PRE_FIX,
                Capability.TRADE_STATISTICS_3,
                Capability.BSQ_SWAP_OFFER
        );

        if (config.daoActivated) {
            maybeApplyDaoFullMode(config);
        }

        log.info(Capabilities.app.prettyPrint());
    }

    public static void maybeApplyDaoFullMode(Config config) {
        // If we set dao full mode at the preferences view we add the capability there. We read the preferences a
        // bit later than we call that method so we have to add DAO_FULL_NODE Capability at preferences as well to
        // be sure it is set in both cases.
        if (config.fullDaoNode) {
            Capabilities.app.addAll(Capability.DAO_FULL_NODE);
        } else {
            // A lite node has the capability to receive bsq blocks. We do not want to send BSQ blocks to full nodes
            // as they ignore them anyway.
            Capabilities.app.addAll(Capability.RECEIVE_BSQ_BLOCK);
        }
    }
}",0,64 2000 439 334 2001 123 457 492 2002 40 2003 2004 41 123 2005 46 2006 46 2007 40 2008 46 2009 44 2008 46 2010 44 2008 46 2011 44 2008 46 2012 44 2008 46 2013 44 2008 46 2014 44 2008 46 2015 44 2008 46 2016 44 2008 46 2017 44 2008 46 2018 44 2008 46 2019 44 2008 46 2020 44 2008 46 2021 44 2008 46 2022 44 2008 46 2023 41 59 392 40 2004 46 2024 41 123 2025 40 2004 41 59 125 2026 46 2027 40 2005 46 2006 46 2028 40 41 41 59 125 439 457 492 2029 40 2003 2004 41 123 621 621 621 392 40 2004 46 2030 41 123 2031 46 2032 46 2033 40 2034 46 2035 41 59 125 360 123 621 621 2036 46 2037 46 2038 40 2039 46 2040 41 59 125 125 125 
3749,Java,"@Slf4j
public class ProcessOfferAvailabilityResponse extends Task<OfferAvailabilityModel> {
    public ProcessOfferAvailabilityResponse(TaskRunner<OfferAvailabilityModel> taskHandler,
                                            OfferAvailabilityModel model) {
        super(taskHandler, model);
    }

    @Override
    protected void run() {
        Offer offer = model.getOffer();
        try {
            runInterceptHook();

            checkArgument(offer.getState() != Offer.State.REMOVED, ""Offer state must not be Offer.State.REMOVED"");

            OfferAvailabilityResponse offerAvailabilityResponse = model.getMessage();

            if (offerAvailabilityResponse.getAvailabilityResult() != AvailabilityResult.AVAILABLE) {
                offer.setState(Offer.State.NOT_AVAILABLE);
                failed(""Take offer attempt rejected because of: "" + offerAvailabilityResponse.getAvailabilityResult());
                return;
            }

            offer.setState(Offer.State.AVAILABLE);

            model.setSelectedArbitrator(offerAvailabilityResponse.getArbitrator());

            NodeAddress mediator = offerAvailabilityResponse.getMediator();
            if (mediator == null) {
                // We do not get a mediator from old clients so we need to handle the null case.
                mediator = DisputeAgentSelection.getLeastUsedMediator(model.getTradeStatisticsManager(), model.getMediatorManager()).getNodeAddress();
            }
            model.setSelectedMediator(mediator);

            model.setSelectedRefundAgent(offerAvailabilityResponse.getRefundAgent());

            complete();
        } catch (Throwable t) {
            offer.setErrorMessage(""An error occurred.\n"" +
                    ""Error message:\n""
                    + t.getMessage());

            failed(t);
        }
    }
}",0,64 2000 439 334 2001 378 2002 60 2003 62 123 439 2001 40 2004 60 2003 62 2005 44 2003 2006 41 123 463 40 2005 44 2006 41 59 125 64 2007 438 492 2008 40 41 123 2009 2010 61 2006 46 2011 40 41 59 474 123 2012 40 41 59 2013 40 2010 46 2014 40 41 631 2009 46 2015 46 2016 44 648 41 59 2017 2018 61 2006 46 2019 40 41 59 392 40 2018 46 2020 40 41 631 2021 46 2022 41 123 2010 46 2023 40 2009 46 2015 46 2024 41 59 2025 40 648 43 2018 46 2020 40 41 41 59 450 59 125 2010 46 2026 40 2009 46 2015 46 2022 41 59 2006 46 2027 40 2018 46 2028 40 41 41 59 2029 2030 61 2018 46 2031 40 41 59 392 40 2030 614 424 41 123 621 2030 61 2032 46 2033 40 2006 46 2034 40 41 44 2006 46 2035 40 41 41 46 2036 40 41 59 125 2006 46 2037 40 2030 41 59 2006 46 2038 40 2018 46 2039 40 41 41 59 2040 40 41 59 125 329 40 2041 2042 41 123 2010 46 2043 40 648 43 648 43 2042 46 2044 40 41 41 59 2045 40 2042 41 59 125 125 125 
5607,Java,"            p2PService.addP2PServiceListener(new BootstrapListener() {
                @Override
                public void onUpdatedDataReceived() {
                    addOfferBookChangedListener(new OfferBookChangedListener() {
                        @Override
                        public void onAdded(Offer offer) {
                            doDumpStatistics();
                        }

                        @Override
                        public void onRemoved(Offer offer) {
                            doDumpStatistics();
                        }
                    });
                    UserThread.runAfter(OfferBookService.this::doDumpStatistics, 1);
                }
            });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 41 123 2005 40 418 2006 40 41 123 64 2003 439 492 2007 40 2008 2009 41 123 2010 40 41 59 125 64 2003 439 492 2011 40 2008 2009 41 123 2012 40 41 59 125 125 41 59 2013 46 2014 40 2015 46 467 58 58 2016 44 1501 41 59 125 125 41 59 
5770,Java,"        walletsManager.publishAndCommitBsqTx(transaction, TxType.PROOF_OF_BURN, new TxBroadcaster.Callback() {
            @Override
            public void onSuccess(Transaction transaction) {
                log.info(""Proof of burn tx has been published. TxId={}"", transaction.getTxId().toString());
                resultHandler.handleResult();
            }

            @Override
            public void onFailure(TxBroadcastException exception) {
                errorMessageHandler.handleErrorMessage(exception.getMessage());
            }
        });",0,2000 46 2001 40 2002 44 2003 46 2004 44 418 2005 46 2006 40 41 123 64 2007 439 492 2008 40 2009 2002 41 123 2010 46 2011 40 648 44 2002 46 2012 40 41 46 2013 40 41 41 59 2014 46 2015 40 41 59 125 64 2007 439 492 2016 40 2017 2018 41 123 2019 46 2020 40 2018 46 2021 40 41 41 59 125 125 41 59 
3760,Java,"                new SendDirectMessageListener() {
                    @Override
                    public void onArrived() {
                        log.info(""AckMessage for OfferAvailabilityRequest arrived at takersNodeAddress {}. offerId={}, sourceUid={}"",
                                takersNodeAddress, offerId, ackMessage.getSourceUid());
                    }

                    @Override
                    public void onFault(String errorMessage) {
                        log.error(""AckMessage for OfferAvailabilityRequest failed. AckMessage={}, takersNodeAddress={}, errorMessage={}"",
                                ackMessage, takersNodeAddress, errorMessage);
                    }
                }",0,418 2000 40 41 123 64 2001 439 492 2002 40 41 123 2003 46 2004 40 648 44 2005 44 2006 44 2007 46 2008 40 41 41 59 125 64 2001 439 492 2009 40 2010 2011 41 123 2012 46 371 40 648 44 2013 44 2014 44 2011 41 59 125 125 
3758,Java,"                    new SendDirectMessageListener() {
                        @Override
                        public void onArrived() {
                            log.info(""{} arrived at peer: offerId={}; uid={}"",
                                    offerAvailabilityResponse.getClass().getSimpleName(),
                                    offerAvailabilityResponse.getOfferId(),
                                    offerAvailabilityResponse.getUid());
                        }

                        @Override
                        public void onFault(String errorMessage) {
                            log.error(""Sending {} failed: uid={}; peer={}; error={}"",
                                    offerAvailabilityResponse.getClass().getSimpleName(),
                                    offerAvailabilityResponse.getUid(),
                                    peer,
                                    errorMessage);
                        }
                    });",0,418 2000 40 41 123 64 2001 439 492 2002 40 41 123 2003 46 2004 40 648 44 2005 46 2006 40 41 46 2007 40 41 44 2005 46 2008 40 41 44 2005 46 2009 40 41 41 59 125 64 2001 439 492 2010 40 2011 2012 41 123 2013 46 371 40 648 44 2014 46 2015 40 41 46 2016 40 41 44 2014 46 2017 40 41 44 2018 44 2012 41 59 125 125 41 59 
3827,Java,"        p2PService.addHashSetChangedListener(new HashMapChangedListener() {
            @Override
            public void onAdded(Collection<ProtectedStorageEntry> protectedStorageEntries) {
                protectedStorageEntries.stream()
                        .filter(protectedStorageEntry -> protectedStorageEntry.getProtectedStoragePayload() instanceof Filter)
                        .forEach(protectedStorageEntry -> {
                            Filter filter = (Filter) protectedStorageEntry.getProtectedStoragePayload();
                            onFilterAddedFromNetwork(filter);
                        });
            }

            @Override
            public void onRemoved(Collection<ProtectedStorageEntry> protectedStorageEntries) {
                protectedStorageEntries.stream()
                        .filter(protectedStorageEntry -> protectedStorageEntry.getProtectedStoragePayload() instanceof Filter)
                        .forEach(protectedStorageEntry -> {
                            Filter filter = (Filter) protectedStorageEntry.getProtectedStoragePayload();
                            onFilterRemovedFromNetwork(filter);
                        });
            }
        });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 2005 60 2006 62 2007 41 123 2007 46 2008 40 41 46 2009 40 2010 45 62 2010 46 2011 40 41 402 2012 41 46 2013 40 2010 45 62 123 2012 2009 61 40 2012 41 2010 46 2011 40 41 59 2014 40 2009 41 59 125 41 59 125 64 2003 439 492 2015 40 2005 60 2006 62 2007 41 123 2007 46 2016 40 41 46 2017 40 2018 45 62 2018 46 2019 40 41 402 2020 41 46 2021 40 2018 45 62 123 2020 2017 61 40 2020 41 2018 46 2019 40 41 59 2022 40 2017 41 59 125 41 59 125 125 41 59 
3594,Java,"@Slf4j
public abstract class BaseProposalFactory<R extends Proposal> {
    protected final BsqWalletService bsqWalletService;
    protected final BtcWalletService btcWalletService;
    private final DaoStateService daoStateService;
    private final ProposalValidator proposalValidator;
    @Nullable
    protected String name;
    @Nullable
    protected String link;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected BaseProposalFactory(BsqWalletService bsqWalletService,
                                  BtcWalletService btcWalletService,
                                  DaoStateService daoStateService,
                                  ProposalValidator proposalValidator) {
        this.bsqWalletService = bsqWalletService;
        this.btcWalletService = btcWalletService;
        this.daoStateService = daoStateService;
        this.proposalValidator = proposalValidator;
    }

    protected ProposalWithTransaction createProposalWithTransaction(String name,
                                                                    String link)
            throws ProposalValidationException, InsufficientMoneyException, TxException {
        this.name = name;
        this.link = link;
        // As we don't know the txId yet we create a temp proposal with txId set to an empty string.
        R proposal = createProposalWithoutTxId();
        proposalValidator.validateDataFields(proposal);
        Transaction transaction = createTransaction(proposal);
        Proposal proposalWithTxId = proposal.cloneProposalAndAddTxId(transaction.getTxId().toString());
        return new ProposalWithTransaction(proposalWithTxId, transaction);
    }

    protected abstract R createProposalWithoutTxId();

    // We have txId set to null in proposal as we cannot know it before the tx is created.
    // Once the tx is known we will create a new object including the txId.
    // The hashOfPayload used in the opReturnData is created with the txId set to null.
    private Transaction createTransaction(R proposal) throws InsufficientMoneyException, TxException {
        try {
            Coin fee = ProposalConsensus.getFee(daoStateService, daoStateService.getChainHeight());
            // We create a prepared Bsq Tx for the proposal fee.
            Transaction preparedBurnFeeTx = proposal instanceof IssuanceProposal ?
                    bsqWalletService.getPreparedIssuanceTx(fee) :
                    bsqWalletService.getPreparedProposalTx(fee);

            // payload does not have txId at that moment
            byte[] hashOfPayload = ProposalConsensus.getHashOfPayload(proposal);
            byte[] opReturnData = getOpReturnData(hashOfPayload);

            // We add the BTC inputs for the miner fee.
            Transaction txWithBtcFee = completeTx(preparedBurnFeeTx, opReturnData, proposal);

            // We sign the BSQ inputs of the final tx.
            Transaction transaction = bsqWalletService.signTxAndVerifyNoDustOutputs(txWithBtcFee);
            log.info(""Proposal tx: "" + transaction);
            return transaction;
        } catch (WalletException | TransactionVerificationException e) {
            throw new TxException(e);
        }
    }

    protected byte[] getOpReturnData(byte[] hashOfPayload) {
        return ProposalConsensus.getOpReturnData(hashOfPayload, OpReturnType.PROPOSAL.getType(), Version.PROPOSAL);
    }

    protected Transaction completeTx(Transaction preparedBurnFeeTx, byte[] opReturnData, Proposal proposal)
            throws WalletException, InsufficientMoneyException, TransactionVerificationException {
        return btcWalletService.completePreparedBurnBsqTx(preparedBurnFeeTx, opReturnData);
    }
}",0,64 2000 439 305 334 2001 60 2002 378 2003 62 123 438 381 2004 2005 59 438 381 2006 2007 59 437 381 2008 2009 59 437 381 2010 2011 59 64 2012 438 2013 2014 59 64 2012 438 2013 2015 59 621 621 621 438 2001 40 2004 2005 44 2006 2007 44 2008 2009 44 2010 2011 41 123 467 46 2005 61 2005 59 467 46 2007 61 2007 59 467 46 2009 61 2009 59 467 46 2011 61 2011 59 125 438 2016 2017 40 2013 2014 44 2013 2015 41 470 2018 44 2019 44 2020 123 467 46 2014 61 2014 59 467 46 2015 61 2015 59 621 2002 2021 61 2022 40 41 59 2011 46 2023 40 2021 41 59 2024 2025 61 2026 40 2021 41 59 2003 2027 61 2021 46 2028 40 2025 46 2029 40 41 46 2030 40 41 41 59 450 418 2016 40 2027 44 2025 41 59 125 438 305 2002 2031 40 41 59 621 621 621 437 2032 2033 40 2002 2034 41 470 2019 44 2020 123 474 123 2035 2036 61 2037 46 2038 40 2009 44 2009 46 2039 40 41 41 59 621 2032 2040 61 2034 402 2041 63 2005 46 2042 40 2036 41 58 2005 46 2043 40 2036 41 59 621 326 91 93 2044 61 2037 46 2045 40 2034 41 59 326 91 93 2046 61 2047 40 2044 41 59 621 2032 2048 61 2049 40 2040 44 2046 44 2034 41 59 621 2032 2050 61 2005 46 2051 40 2048 41 59 2052 46 2053 40 648 43 2050 41 59 450 2050 59 125 329 40 2054 124 2055 2056 41 123 469 418 2020 40 2056 41 59 125 125 438 326 91 93 2057 40 326 91 93 2058 41 123 450 2059 46 2057 40 2058 44 2060 46 2061 46 2062 40 41 44 2063 46 2061 41 59 125 438 2032 2064 40 2032 2065 44 326 91 93 2066 44 2003 2034 41 470 2067 44 2019 44 2068 123 450 2007 46 2069 40 2065 44 2066 41 59 125 125 
5716,Java,"                p2PService.addP2PServiceListener(new BootstrapListener() {
                    @Override
                    public void onUpdatedDataReceived() {
                        accountAgeWitnessService.publishMyAccountAgeWitness(aliPayAccount.getPaymentAccountPayload());
                    }
                });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 41 123 2005 46 2006 40 2007 46 2008 40 41 41 59 125 125 41 59 
4892,Java,"public class ExplorerAddressTextField extends AnchorPane {
    @Setter
    private static Preferences preferences;

    @Getter
    private final TextField textField;
    private final Label copyIcon, blockExplorerIcon, missingAddressWarningIcon;
    @Setter
    private boolean isBsq;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    public ExplorerAddressTextField() {
        copyIcon = new Label();
        copyIcon.setLayoutY(3);
        copyIcon.getStyleClass().addAll(""icon"", ""highlight"");
        copyIcon.setTooltip(new Tooltip(Res.get(""explorerAddressTextField.copyToClipboard"")));
        AwesomeDude.setIcon(copyIcon, AwesomeIcon.COPY);
        AnchorPane.setRightAnchor(copyIcon, 30.0);

        Tooltip tooltip = new Tooltip(Res.get(""explorerAddressTextField.blockExplorerIcon.tooltip""));

        blockExplorerIcon = new Label();
        blockExplorerIcon.getStyleClass().addAll(""icon"", ""highlight"");
        blockExplorerIcon.setTooltip(tooltip);
        AwesomeDude.setIcon(blockExplorerIcon, AwesomeIcon.EXTERNAL_LINK);
        blockExplorerIcon.setMinWidth(20);
        AnchorPane.setRightAnchor(blockExplorerIcon, 52.0);
        AnchorPane.setTopAnchor(blockExplorerIcon, 4.0);

        missingAddressWarningIcon = new Label();
        missingAddressWarningIcon.getStyleClass().addAll(""icon"", ""error-icon"");
        AwesomeDude.setIcon(missingAddressWarningIcon, AwesomeIcon.WARNING_SIGN);
        missingAddressWarningIcon.setTooltip(new Tooltip(Res.get(""explorerAddressTextField.missingTx.warning.tooltip"")));
        missingAddressWarningIcon.setMinWidth(20);
        AnchorPane.setRightAnchor(missingAddressWarningIcon, 52.0);
        AnchorPane.setTopAnchor(missingAddressWarningIcon, 4.0);
        missingAddressWarningIcon.setVisible(false);
        missingAddressWarningIcon.setManaged(false);

        textField = new JFXTextField();
        textField.setId(""address-text-field"");
        textField.setEditable(false);
        textField.setTooltip(tooltip);
        AnchorPane.setRightAnchor(textField, 80.0);
        AnchorPane.setLeftAnchor(textField, 0.0);
        textField.focusTraversableProperty().set(focusTraversableProperty().get());
        getChildren().addAll(textField, missingAddressWarningIcon, blockExplorerIcon, copyIcon);
    }

    public void setup(@Nullable String address) {
        if (address == null) {
            textField.setText(Res.get(""shared.na""));
            textField.setId(""address-text-field-error"");
            blockExplorerIcon.setVisible(false);
            blockExplorerIcon.setManaged(false);
            copyIcon.setVisible(false);
            copyIcon.setManaged(false);
            missingAddressWarningIcon.setVisible(true);
            missingAddressWarningIcon.setManaged(true);
            return;
        }

        textField.setText(address);
        textField.setOnMouseClicked(mouseEvent -> openBlockExplorer(address));
        blockExplorerIcon.setOnMouseClicked(mouseEvent -> openBlockExplorer(address));
        copyIcon.setOnMouseClicked(e -> Utilities.copyToClipboard(address));
    }

    public void cleanup() {
        textField.setOnMouseClicked(null);
        blockExplorerIcon.setOnMouseClicked(null);
        copyIcon.setOnMouseClicked(null);
        textField.setText("""");
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void openBlockExplorer(String address) {
        if (preferences != null) {
            BlockChainExplorer blockChainExplorer = isBsq ?
                    preferences.getBsqBlockChainExplorer() :
                    preferences.getBlockChainExplorer();
            GUIUtil.openWebPage(blockChainExplorer.addressUrl + address, false);
        }
    }
}",0,439 334 2000 378 2001 123 64 2002 437 457 2003 2004 59 64 2005 437 381 2006 2007 59 437 381 2008 2009 44 2010 44 2011 59 64 2002 437 324 2012 59 621 621 621 439 2000 40 41 123 2009 61 418 2008 40 41 59 2009 46 2013 40 1502 41 59 2009 46 2014 40 41 46 2015 40 648 44 648 41 59 2009 46 2016 40 418 2017 40 2018 46 2019 40 648 41 41 41 59 2020 46 2021 40 2009 44 2022 46 2023 41 59 2001 46 2024 40 2009 44 1503 41 59 2017 2025 61 418 2017 40 2018 46 2019 40 648 41 41 59 2010 61 418 2008 40 41 59 2010 46 2014 40 41 46 2015 40 648 44 648 41 59 2010 46 2016 40 2025 41 59 2020 46 2021 40 2010 44 2022 46 2026 41 59 2010 46 2027 40 1503 41 59 2001 46 2024 40 2010 44 1503 41 59 2001 46 2028 40 2010 44 1502 41 59 2011 61 418 2008 40 41 59 2011 46 2014 40 41 46 2015 40 648 44 648 41 59 2020 46 2021 40 2011 44 2022 46 2029 41 59 2011 46 2016 40 418 2017 40 2018 46 2019 40 648 41 41 41 59 2011 46 2027 40 1503 41 59 2001 46 2024 40 2011 44 1503 41 59 2001 46 2028 40 2011 44 1502 41 59 2011 46 2030 40 380 41 59 2011 46 2031 40 380 41 59 2007 61 418 2032 40 41 59 2007 46 2033 40 648 41 59 2007 46 2034 40 380 41 59 2007 46 2016 40 2025 41 59 2001 46 2024 40 2007 44 1503 41 59 2001 46 2035 40 2007 44 1500 41 59 2007 46 2036 40 41 46 2037 40 2036 40 41 46 2019 40 41 41 59 2038 40 41 46 2015 40 2007 44 2011 44 2010 44 2009 41 59 125 439 492 2039 40 64 2040 2041 2042 41 123 392 40 2042 614 424 41 123 2007 46 2043 40 2044 46 2045 40 648 41 41 59 2007 46 2046 40 648 41 59 2010 46 2047 40 380 41 59 2010 46 2048 40 380 41 59 2009 46 2047 40 380 41 59 2009 46 2048 40 380 41 59 2011 46 2047 40 473 41 59 2011 46 2048 40 473 41 59 450 59 125 2007 46 2049 40 2042 41 59 2007 46 2050 40 2051 45 62 2052 40 2042 41 41 59 2010 46 2050 40 2051 45 62 2052 40 2042 41 41 59 2009 46 2050 40 2053 45 62 2054 46 2055 40 2042 41 41 59 125 439 492 2056 40 41 123 2007 46 2057 40 424 41 59 2010 46 2057 40 424 41 59 2009 46 2057 40 424 41 59 2007 46 2058 40 648 41 59 125 621 621 621 437 492 2059 40 2041 2042 41 123 392 40 2004 631 424 41 123 2060 2061 61 2012 63 2004 46 2062 40 41 58 2004 46 2063 40 41 59 2064 46 2065 40 2061 46 2066 43 2042 44 380 41 59 125 125 125 
5015,Java,"    public class BisqWalletListener implements WalletCoinsReceivedEventListener,
            WalletCoinsSentEventListener,
            WalletReorganizeEventListener,
            TransactionConfidenceEventListener {
        @Override
        public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {
            notifyBalanceListeners(tx);
        }

        @Override
        public void onCoinsSent(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {
            notifyBalanceListeners(tx);
        }

        @Override
        public void onReorganize(Wallet wallet) {
            log.warn(""onReorganize "");
        }

        @Override
        public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
            for (AddressConfidenceListener addressConfidenceListener : addressConfidenceListeners) {
                TransactionConfidence confidence = getTransactionConfidence(tx, addressConfidenceListener.getAddress());
                addressConfidenceListener.onTransactionConfidenceChanged(confidence);
            }
            txConfidenceListeners.stream()
                    .filter(txConfidenceListener -> tx != null &&
                            tx.getTxId().toString() != null &&
                            txConfidenceListener != null &&
                            tx.getTxId().toString().equals(txConfidenceListener.getTxId()))
                    .forEach(txConfidenceListener ->
                            txConfidenceListener.onTransactionConfidenceChanged(tx.getConfidence()));
        }

        void notifyBalanceListeners(Transaction tx) {
            for (BalanceListener balanceListener : balanceListeners) {
                Coin balance;
                if (balanceListener.getAddress() != null)
                    balance = getBalanceForAddress(balanceListener.getAddress());
                else
                    balance = getAvailableBalance();

                balanceListener.onBalanceChanged(balance, tx);
            }
        }
    }",0,439 334 2000 395 2001 44 2002 44 2003 44 2004 123 64 2005 439 492 2006 40 2007 2008 44 2009 2010 44 2011 2012 44 2011 2013 41 123 2014 40 2010 41 59 125 64 2005 439 492 2015 40 2007 2008 44 2009 2010 44 2011 2012 44 2011 2013 41 123 2016 40 2010 41 59 125 64 2005 439 492 2017 40 2007 2008 41 123 2018 46 2019 40 648 41 59 125 64 2005 439 492 2020 40 2007 2008 44 2009 2010 41 123 385 40 2021 2022 58 2023 41 123 2024 2025 61 2026 40 2010 44 2022 46 2027 40 41 41 59 2022 46 2020 40 2025 41 59 125 2028 46 2029 40 41 46 2030 40 2031 45 62 2010 631 424 605 2010 46 2032 40 41 46 2033 40 41 631 424 605 2031 631 424 605 2010 46 2032 40 41 46 2033 40 41 46 2034 40 2031 46 2032 40 41 41 41 46 2035 40 2031 45 62 2031 46 2020 40 2010 46 2036 40 41 41 41 59 125 492 2037 40 2009 2010 41 123 385 40 2038 2039 58 2040 41 123 2011 2041 59 392 40 2039 46 2042 40 41 631 424 41 2041 61 2043 40 2039 46 2042 40 41 41 59 360 2041 61 2044 40 41 59 2039 46 2045 40 2041 44 2010 41 59 125 125 125 
5016,Java,"        Futures.addCallback(sendResult.broadcastComplete, new FutureCallback<>() {
            @Override
            public void onSuccess(Transaction result) {
                log.info(""emptyBtcWallet onSuccess Transaction="" + result);
                resultHandler.handleResult();
            }

            @Override
            public void onFailure(@NotNull Throwable t) {
                log.error(""emptyBtcWallet onFailure "" + t.toString());
                errorMessageHandler.handleErrorMessage(t.getMessage());
            }
        }, MoreExecutors.directExecutor());",0,2000 46 2001 40 2002 46 2003 44 418 2004 60 62 40 41 123 64 2005 439 492 2006 40 2007 2008 41 123 2009 46 2010 40 648 43 2008 41 59 2011 46 2012 40 41 59 125 64 2005 439 492 2013 40 64 2014 2015 2016 41 123 2017 46 371 40 648 43 2016 46 2018 40 41 41 59 2019 46 2020 40 2016 46 2021 40 41 41 59 125 125 44 2022 46 2023 40 41 41 59 
4751,Java,"@Slf4j
public class TxBroadcaster {
    public interface Callback {
        void onSuccess(Transaction transaction);

        default void onTimeout(TxBroadcastTimeoutException exception) {
            Transaction tx = exception.getLocalTx();
            if (tx != null) {
                // We optimistically assume that the tx broadcast succeeds later and call onSuccess on the callback handler.
                // This behaviour carries less potential problems than if we would trigger a failure (e.g. which would cause
                // a failed create offer attempt or failed take offer attempt).
                // We have no guarantee how long it will take to get the information that sufficiently many BTC nodes have
                // reported back to BitcoinJ that the tx is in their mempool.
                // In normal situations that's very fast but in some cases it can take minutes (mostly related to Tor
                // connection issues). So if we just go on in the application logic and treat it as successful and the
                // tx will be broadcast successfully later all is fine.
                // If it will fail to get broadcast, it will lead to a failure state, the same as if we would trigger a
                // failure due the timeout.
                // So we can assume that this behaviour will lead to less problems as otherwise.
                // Long term we should implement better monitoring for Tor and the provided Bitcoin nodes to find out
                // why those delays happen and add some rollback behaviour to the app state in case the tx will never
                // get broadcast.
                log.warn(""TxBroadcaster.onTimeout called: {}"", exception.toString());
                onSuccess(tx);
            } else {
                log.error(""TxBroadcaster.onTimeout: Tx is null. exception={} "", exception.toString());
                onFailure(exception);
            }
        }

        void onFailure(TxBroadcastException exception);
    }

    // Currently there is a bug in BitcoinJ causing the timeout at all BSQ transactions.
    // It is because BitcoinJ does not handle confidence object correctly in case as tx got altered after the
    // Wallet.complete() method is called which is the case for all BSQ txs. We will work on a fix for that but that
    // will take more time. In the meantime we reduce the timeout to 5 seconds to avoid that the trade protocol runs
    // into a timeout when using BSQ for trade fee.
    // For trade fee txs we set only 1 sec timeout for now.
    // FIXME
    private static final int DEFAULT_BROADCAST_TIMEOUT = 5;
    private static final Map<String, Timer> broadcastTimerMap = new HashMap<>();

    public static void broadcastTx(Wallet wallet, PeerGroup peerGroup, Transaction localTx, Callback callback) {
        broadcastTx(wallet, peerGroup, localTx, callback, DEFAULT_BROADCAST_TIMEOUT);
    }

    public static void broadcastTx(Wallet wallet, PeerGroup peerGroup, Transaction tx, Callback callback, int timeOut) {
        Timer timeoutTimer;
        final String txId = tx.getTxId().toString();
        log.info(""Txid: {} hex: {}"", txId, Utils.HEX.encode(tx.bitcoinSerialize()));
        if (!broadcastTimerMap.containsKey(txId)) {
            timeoutTimer = UserThread.runAfter(() -> {
                log.warn(""Broadcast of tx {} not completed after {} sec."", txId, timeOut);
                stopAndRemoveTimer(txId);
                UserThread.execute(() -> callback.onTimeout(new TxBroadcastTimeoutException(tx, timeOut, wallet)));
            }, timeOut);

            broadcastTimerMap.put(txId, timeoutTimer);
        } else {
            // Would be the wrong way how to use the API (calling 2 times a broadcast with same tx).
            // An arbitrator reported that got the error after a manual payout, need to investigate why...
            stopAndRemoveTimer(txId);
            UserThread.execute(() -> callback.onFailure(new TxBroadcastException(""We got broadcastTx called with a tx "" +
                    ""which has an open timeoutTimer. txId="" + txId, txId)));
        }

        // We decided the least risky scenario is to commit the tx to the wallet and broadcast it later.
        // If it's a bsq tx WalletManager.publishAndCommitBsqTx() should have committed the tx to both bsq and btc
        // wallets so the next line causes no effect.
        // If it's a btc tx, the next line adds the tx to the wallet.
        wallet.maybeCommitTx(tx);

        Futures.addCallback(peerGroup.broadcastTransaction(tx).future(), new FutureCallback<>() {
            @Override
            public void onSuccess(@Nullable Transaction result) {
                // We expect that there is still a timeout in our map, otherwise the timeout got triggered
                if (broadcastTimerMap.containsKey(txId)) {
                    stopAndRemoveTimer(txId);
                    // At regtest we get called immediately back but we want to make sure that the handler is not called
                    // before the caller is finished.
                    UserThread.execute(() -> callback.onSuccess(tx));
                } else {
                    log.warn(""We got an onSuccess callback for a broadcast which already triggered the timeout. txId={}"", txId);
                }
            }

            @Override
            public void onFailure(@NotNull Throwable throwable) {
                stopAndRemoveTimer(txId);
                UserThread.execute(() -> callback.onFailure(new TxBroadcastException(""We got an onFailure from "" +
                        ""the peerGroup.broadcastTransaction callback."", throwable)));
            }
        }, MoreExecutors.directExecutor());

        // For better redundancy in case the broadcast via BitcoinJ fails we also
        // publish the tx via mempool nodes.
        MemPoolSpaceTxBroadcaster.broadcastTx(tx);
    }

    private static void stopAndRemoveTimer(String txId) {
        Timer timer = broadcastTimerMap.get(txId);
        if (timer != null)
            timer.stop();

        broadcastTimerMap.remove(txId);
    }
}",0,64 2000 439 334 2001 123 439 405 2002 123 492 2003 40 2004 2005 41 59 349 492 2006 40 2007 2008 41 123 2004 2009 61 2008 46 2010 40 41 59 392 40 2009 631 424 41 123 621 621 621 621 621 621 621 621 621 621 621 621 621 621 2011 46 2012 40 648 44 2008 46 2013 40 41 41 59 2003 40 2009 41 59 125 360 123 2014 46 371 40 648 44 2008 46 2015 40 41 41 59 2016 40 2008 41 59 125 125 492 2017 40 2018 2008 41 59 125 621 621 621 621 621 621 621 437 457 381 404 2019 61 1502 59 437 457 381 2020 60 2021 44 2022 62 2023 61 418 2024 60 62 40 41 59 439 457 492 2025 40 2026 2027 44 2028 2029 44 2030 2031 44 2002 2032 41 123 2025 40 2027 44 2029 44 2031 44 2032 44 2019 41 59 125 439 457 492 2025 40 2026 2027 44 2028 2029 44 2030 2033 44 2002 2032 44 404 2034 41 123 2022 2035 59 381 2021 2036 61 2033 46 2037 40 41 46 2038 40 41 59 2039 46 2040 40 648 44 2036 44 2041 46 2042 46 2043 40 2033 46 2044 40 41 41 41 59 392 40 33 2023 46 2045 40 2036 41 41 123 2035 61 2046 46 2047 40 40 41 45 62 123 2039 46 2048 40 648 44 2036 44 2034 41 59 2049 40 2036 41 59 2046 46 2050 40 40 41 45 62 2032 46 2051 40 418 2052 40 2033 44 2034 44 2027 41 41 41 59 125 44 2034 41 59 2023 46 2053 40 2036 44 2035 41 59 125 360 123 621 621 2054 40 2036 41 59 2055 46 2056 40 40 41 45 62 2032 46 2057 40 418 2058 40 648 43 648 43 2036 44 2036 41 41 41 59 125 621 621 621 621 2027 46 2059 40 2033 41 59 2060 46 2061 40 2029 46 2062 40 2033 41 46 2063 40 41 44 418 2064 60 62 40 41 123 64 2065 439 492 2066 40 64 2067 2030 2068 41 123 621 392 40 2023 46 2045 40 2036 41 41 123 2069 40 2036 41 59 621 621 2070 46 2071 40 40 41 45 62 2032 46 2066 40 2033 41 41 59 125 360 123 2039 46 2072 40 648 44 2036 41 59 125 125 64 2065 439 492 2073 40 64 2074 2075 2076 41 123 2077 40 2036 41 59 2078 46 2079 40 40 41 45 62 2032 46 2073 40 418 2080 40 648 43 648 44 2076 41 41 41 59 125 125 44 2081 46 2082 40 41 41 59 621 621 2083 46 2025 40 2033 41 59 125 437 457 492 2084 40 2021 2085 41 123 2022 2086 61 2023 46 2087 40 2085 41 59 392 40 2086 631 424 41 2086 46 2088 40 41 59 2023 46 2089 40 2085 41 59 125 125 
5473,Java,"                            Futures.addCallback(sendResult.broadcastComplete, new FutureCallback<>() {
                                @Override
                                public void onSuccess(Transaction result) {
                                    log.info(""Double spending transaction published. "" + result);
                                    resultHandler.run();
                                }

                                @Override
                                public void onFailure(@NotNull Throwable t) {
                                    log.error(""Broadcasting double spending transaction failed. "" + t.getMessage());
                                    errorMessageHandler.handleErrorMessage(t.getMessage());
                                }
                            }, MoreExecutors.directExecutor());",0,2000 46 2001 40 2002 46 2003 44 418 2004 60 62 40 41 123 64 2005 439 492 2006 40 2007 2008 41 123 2009 46 2010 40 648 43 2008 41 59 2011 46 2012 40 41 59 125 64 2005 439 492 2013 40 64 2014 2015 2016 41 123 2017 46 371 40 648 43 2016 46 2018 40 41 41 59 2019 46 2020 40 2016 46 2018 40 41 41 59 125 125 44 2021 46 2022 40 41 41 59 
3216,Java,"    @EqualsAndHashCode
    @Getter
    public static class BtcNode {
        private static final int DEFAULT_PORT = Config.baseCurrencyNetworkParameters().getPort(); //8333

        @Nullable
        private final String onionAddress;
        @Nullable
        private final String hostName;
        @Nullable
        private final String operator; // null in case the user provides a list of custom btc nodes
        @Nullable
        private final String address; // IPv4 address
        private int port = DEFAULT_PORT;

        /**
         * @param fullAddress [IPv4 address:port or onion:port]
         * @return BtcNode instance
         */
        public static BtcNode fromFullAddress(String fullAddress) {
            String[] parts = fullAddress.split(""]"");
            checkArgument(parts.length > 0);
            String host = """";
            int port = DEFAULT_PORT;
            if (parts[0].contains(""["") && parts[0].contains("":"")) {
                // IPv6 address and optional port number
                // address part delimited by square brackets e.g. [2a01:123:456:789::2]:8333
                host = parts[0].replace(""["", """").replace(""]"", """");
                if (parts.length == 2)
                    port = Integer.parseInt(parts[1].replace("":"", """"));
            } else if (parts[0].contains("":"") && !parts[0].contains(""."")) {
                // IPv6 address only; not delimited by square brackets
                host = parts[0];
            } else if (parts[0].contains(""."")) {
                // address and an optional port number
                // e.g. 127.0.0.1:8333 or abcdef123xyz.onion:9999
                parts = fullAddress.split("":"");
                checkArgument(parts.length > 0);
                host = parts[0];
                if (parts.length == 2)
                    port = Integer.parseInt(parts[1]);
            }

            checkArgument(host.length() > 0, ""BtcNode address format not recognised"");
            return host.contains("".onion"") ? new BtcNode(null, host, null, port, null) : new BtcNode(null, null, host, port, null);
        }

        public BtcNode(@Nullable String hostName,
                       @Nullable String onionAddress,
                       @Nullable String address,
                       int port,
                       @Nullable String operator) {
            this.hostName = hostName;
            this.onionAddress = onionAddress;
            this.address = address;
            this.port = port;
            this.operator = operator;
        }

        public boolean hasOnionAddress() {
            return onionAddress != null;
        }

        public String getHostNameOrAddress() {
            if (hostName != null)
                return hostName;
            else
                return address;
        }

        public boolean hasClearNetAddress() {
            return hostName != null || address != null;
        }

        @Override
        public String toString() {
            return ""onionAddress='"" + onionAddress + '\'' +
                    "", hostName='"" + hostName + '\'' +
                    "", address='"" + address + '\'' +
                    "", port='"" + port + '\'' +
                    "", operator='"" + operator;
        }
    }",0,64 2000 64 2001 439 457 334 2002 123 437 457 381 404 2003 61 2004 46 2005 40 41 46 2006 40 41 59 621 64 2007 437 381 2008 2009 59 64 2007 437 381 2008 2010 59 64 2007 437 381 2008 427 59 621 64 2007 437 381 2008 2011 59 621 437 404 2012 61 2003 59 618 439 457 2002 2013 40 2008 2014 41 123 2008 91 93 2015 61 2014 46 2016 40 648 41 59 2017 40 2015 46 2018 62 1500 41 59 2008 2019 61 648 59 404 2012 61 2003 59 392 40 2015 91 1500 93 46 2020 40 648 41 605 2015 91 1500 93 46 2020 40 648 41 41 123 621 621 2019 61 2015 91 1500 93 46 2021 40 648 44 648 41 46 2021 40 648 44 648 41 59 392 40 2015 46 2018 614 1502 41 2012 61 2022 46 2023 40 2015 91 1501 93 46 2021 40 648 44 648 41 41 59 125 360 392 40 2015 91 1500 93 46 2020 40 648 41 605 33 2015 91 1500 93 46 2020 40 648 41 41 123 621 2019 61 2015 91 1500 93 59 125 360 392 40 2015 91 1500 93 46 2020 40 648 41 41 123 621 621 2015 61 2014 46 2016 40 648 41 59 2017 40 2015 46 2018 62 1500 41 59 2019 61 2015 91 1500 93 59 392 40 2015 46 2018 614 1502 41 2012 61 2024 46 2025 40 2015 91 1501 93 41 59 125 2017 40 2019 46 2018 40 41 62 1500 44 648 41 59 450 2019 46 2020 40 648 41 63 418 2002 40 424 44 2019 44 424 44 2012 44 424 41 58 418 2002 40 424 44 424 44 2019 44 2012 44 424 41 59 125 439 2002 40 64 2007 2008 2010 44 64 2007 2008 2009 44 64 2007 2008 2011 44 404 2012 44 64 2007 2008 427 41 123 467 46 2010 61 2010 59 467 46 2009 61 2009 59 467 46 2011 61 2011 59 467 46 2012 61 2012 59 467 46 427 61 427 59 125 439 324 2026 40 41 123 450 2009 631 424 59 125 439 2008 2027 40 41 123 392 40 2010 631 424 41 450 2010 59 360 450 2011 59 125 439 324 2028 40 41 123 450 2010 631 424 606 2011 631 424 59 125 64 2029 439 2008 2030 40 41 123 450 648 43 2009 43 607 43 648 43 2010 43 607 43 648 43 2011 43 607 43 648 43 2012 43 607 43 648 43 427 59 125 125 
3556,Java,"@Slf4j
public class TxFeeEstimationService {

//  Size/vsize of typical trade txs
//  Real txs size/vsize may vary in 1 or 2 bytes from the estimated values.
//  Values calculated with https://gist.github.com/oscarguindzberg/3d1349cb65d9fd9af9de0feaa3fd27ac
//  legacy fee tx with 1 input, maker/taker fee paid in btc size/vsize = 258
//  legacy deposit tx without change size/vsize = 381
//  legacy deposit tx with change size/vsize = 414
//  legacy payout tx size/vsize = 337
//  legacy delayed payout tx size/vsize = 302
//  segwit fee tx with 1 input, maker/taker fee paid in btc vsize = 173
//  segwit deposit tx without change vsize = 232
//  segwit deposit tx with change vsize = 263
//  segwit payout tx vsize = 169
//  segwit delayed payout tx vsize = 139
public static final int TYPICAL_TX_WITH_1_INPUT_VSIZE = 175;
    private static final int DEPOSIT_TX_VSIZE = 233;

    private static final int BSQ_INPUT_INCREASE = 70;
    private static final int MAX_ITERATIONS = 10;

    private final FeeService feeService;
    private final BtcWalletService btcWalletService;
    private final Preferences preferences;

    @Inject
    public TxFeeEstimationService(FeeService feeService,
                                  BtcWalletService btcWalletService,
                                  Preferences preferences) {

        this.feeService = feeService;
        this.btcWalletService = btcWalletService;
        this.preferences = preferences;
    }

    public Tuple2<Coin, Integer> getEstimatedFeeAndTxVsizeForTaker(Coin fundsNeededForTrade, Coin tradeFee) {
        return getEstimatedFeeAndTxVsize(true,
                fundsNeededForTrade,
                tradeFee,
                feeService,
                btcWalletService,
                preferences);
    }

    public Tuple2<Coin, Integer> getEstimatedFeeAndTxVsizeForMaker(Coin reservedFundsForOffer,
                                                                   Coin tradeFee) {
        return getEstimatedFeeAndTxVsize(false,
                reservedFundsForOffer,
                tradeFee,
                feeService,
                btcWalletService,
                preferences);
    }

    private Tuple2<Coin, Integer> getEstimatedFeeAndTxVsize(boolean isTaker,
                                                            Coin amount,
                                                            Coin tradeFee,
                                                            FeeService feeService,
                                                            BtcWalletService btcWalletService,
                                                            Preferences preferences) {
        Coin txFeePerVbyte = feeService.getTxFeePerVbyte();
        // We start with min taker fee vsize of 175
        int estimatedTxVsize = TYPICAL_TX_WITH_1_INPUT_VSIZE;
        try {
            estimatedTxVsize = getEstimatedTxVsize(List.of(tradeFee, amount), estimatedTxVsize, txFeePerVbyte, btcWalletService);
        } catch (InsufficientMoneyException e) {
            if (isTaker) {
                // If we cannot do the estimation, we use the vsize o the largest of our txs which is the deposit tx.
                estimatedTxVsize = DEPOSIT_TX_VSIZE;
            }
            log.info(""We cannot do the fee estimation because there are not enough funds in the wallet. This is expected "" +
                    ""if the user pays from an external wallet. In that case we use an estimated tx vsize of {} vbytes."", estimatedTxVsize);
        }

        if (!preferences.isPayFeeInBtc()) {
            // If we pay the fee in BSQ we have one input more which adds about 150 bytes
            // TODO: Clarify if there is always just one additional input or if there can be more.
            estimatedTxVsize += BSQ_INPUT_INCREASE;
        }

        Coin txFee;
        int vsize;
        if (isTaker) {
            int averageVsize = (estimatedTxVsize + DEPOSIT_TX_VSIZE) / 2;  // deposit tx has about 233 vbytes
            // We use at least the vsize of the deposit tx to not underpay it.
            vsize = Math.max(DEPOSIT_TX_VSIZE, averageVsize);
            txFee = txFeePerVbyte.multiply(vsize);
            log.info(""Fee estimation resulted in a tx vsize of {} vbytes.\n"" +
                    ""We use an average between the taker fee tx and the deposit tx (233 vbytes) which results in {} vbytes.\n"" +
                    ""The deposit tx has 233 vbytes, we use that as our min value. Vsize for fee calculation is {} vbytes.\n"" +
                    ""The tx fee of {} Sat"", estimatedTxVsize, averageVsize, vsize, txFee.value);
        } else {
            vsize = estimatedTxVsize;
            txFee = txFeePerVbyte.multiply(vsize);
            log.info(""Fee estimation resulted in a tx vsize of {} vbytes and a tx fee of {} Sat."", vsize, txFee.value);
        }

        return new Tuple2<>(txFee, vsize);
    }

    public Tuple2<Coin, Integer> getEstimatedFeeAndTxVsize(Coin amount,
                                                           BtcWalletService btcWalletService) {
        Coin txFeePerVbyte = btcWalletService.getTxFeeForWithdrawalPerVbyte();
        // We start with min taker fee vsize of 175
        int estimatedTxVsize = TYPICAL_TX_WITH_1_INPUT_VSIZE;
        try {
            estimatedTxVsize = getEstimatedTxVsize(List.of(amount), estimatedTxVsize, txFeePerVbyte, btcWalletService);
        } catch (InsufficientMoneyException e) {
            log.info(""We cannot do the fee estimation because there are not enough funds in the wallet. This is expected "" +
                    ""if the user pays from an external wallet. In that case we use an estimated tx vsize of {} vbytes."", estimatedTxVsize);
        }

        Coin txFee = txFeePerVbyte.multiply(estimatedTxVsize);
        log.info(""Fee estimation resulted in a tx vsize of {} vbytes and a tx fee of {} Sat."", estimatedTxVsize, txFee.value);

        return new Tuple2<>(txFee, estimatedTxVsize);
    }

    // We start with the initialEstimatedTxVsize for a tx with 1 input (175) vbytes and get from BitcoinJ a tx back which
    // contains the required inputs to fund that tx (outputs + miner fee). The miner fee in that case is based on
    // the assumption that we only need 1 input. Once we receive back the real tx vsize from the tx BitcoinJ has created
    // with the required inputs we compare if the vsize is not more then 20% different to our assumed tx vsize. If we are inside
    // that tolerance we use that tx vsize for our fee estimation, if not (if there has been more then 1 inputs) we
    // apply the new fee based on the reported tx vsize and request again from BitcoinJ to fill that tx with the inputs
    // to be sufficiently funded. The algorithm how BitcoinJ selects utxos is complex and contains several aspects
    // (minimize fee, don't create too many tiny utxos,...). We treat that algorithm as an unknown and it is not
    // guaranteed that there are more inputs required if we increase the fee (it could be that there is a better
    // selection of inputs chosen if we have increased the fee and therefore less inputs and smaller tx vsize). As the increased fee might
    // change the number of inputs we need to repeat that process until we are inside of a certain tolerance. To avoid
    // potential endless loops we add a counter (we use 10, usually it takes just very few iterations).
    // Worst case would be that the last vsize we got reported is > 20% off to
    // the real tx vsize but as fee estimation is anyway a educated guess in the best case we don't worry too much.
    // If we have underpaid the tx might take longer to get confirmed.
    @VisibleForTesting
    static int getEstimatedTxVsize(List<Coin> outputValues,
                                   int initialEstimatedTxVsize,
                                   Coin txFeePerVbyte,
                                   BtcWalletService btcWalletService)
            throws InsufficientMoneyException {
        boolean isInTolerance;
        int estimatedTxVsize = initialEstimatedTxVsize;
        int realTxVsize;
        int counter = 0;
        do {
            Coin txFee = txFeePerVbyte.multiply(estimatedTxVsize);
            realTxVsize = btcWalletService.getEstimatedFeeTxVsize(outputValues, txFee);
            isInTolerance = isInTolerance(estimatedTxVsize, realTxVsize, 0.2);
            if (!isInTolerance) {
                estimatedTxVsize = realTxVsize;
            }
            counter++;
        }
        while (!isInTolerance && counter < MAX_ITERATIONS);
        if (!isInTolerance) {
            log.warn(""We could not find a tx which satisfies our tolerance requirement of 20%. "" +
                            ""realTxVsize={}, estimatedTxVsize={}"",
                    realTxVsize, estimatedTxVsize);
        }
        return estimatedTxVsize;
    }

    @VisibleForTesting
    static boolean isInTolerance(int estimatedVsize, int txVsize, double tolerance) {
        checkArgument(estimatedVsize > 0, ""estimatedVsize must be positive"");
        checkArgument(txVsize > 0, ""txVsize must be positive"");
        checkArgument(tolerance > 0, ""tolerance must be positive"");
        double deviation = Math.abs(1 - ((double) estimatedVsize / (double) txVsize));
        return deviation <= tolerance;
    }
}",0,64 2000 439 334 2001 123 621 621 621 621 621 621 621 621 621 621 621 621 621 439 457 381 404 2002 61 1504 59 437 457 381 404 2003 61 1504 59 437 457 381 404 2004 61 1503 59 437 457 381 404 2005 61 1502 59 437 381 2006 2007 59 437 381 2008 2009 59 437 381 2010 2011 59 64 2012 439 2001 40 2006 2007 44 2008 2009 44 2010 2011 41 123 467 46 2007 61 2007 59 467 46 2009 61 2009 59 467 46 2011 61 2011 59 125 439 2013 60 2014 44 2015 62 2016 40 2014 2017 44 2014 2018 41 123 450 2019 40 473 44 2017 44 2018 44 2007 44 2009 44 2011 41 59 125 439 2013 60 2014 44 2015 62 2020 40 2014 2021 44 2014 2018 41 123 450 2022 40 380 44 2021 44 2018 44 2007 44 2009 44 2011 41 59 125 437 2013 60 2014 44 2015 62 2023 40 324 2024 44 2014 2025 44 2014 2018 44 2006 2007 44 2008 2009 44 2010 2011 41 123 2014 2026 61 2007 46 2027 40 41 59 621 404 2028 61 2002 59 474 123 2028 61 2029 40 2030 46 2031 40 2018 44 2025 41 44 2028 44 2026 44 2009 41 59 125 329 40 2032 2033 41 123 392 40 2024 41 123 621 2028 61 2003 59 125 2034 46 2035 40 648 43 648 44 2028 41 59 125 392 40 33 2011 46 2036 40 41 41 123 621 621 2028 636 2004 59 125 2014 2037 59 404 2038 59 392 40 2024 41 123 404 2039 61 40 2028 43 2003 41 47 1502 59 621 621 2038 61 2040 46 2041 40 2003 44 2039 41 59 2037 61 2026 46 2042 40 2038 41 59 2043 46 2044 40 648 43 648 43 648 43 648 44 2028 44 2039 44 2038 44 2037 46 2045 41 59 125 360 123 2038 61 2028 59 2037 61 2026 46 2046 40 2038 41 59 2047 46 2048 40 648 44 2038 44 2037 46 2049 41 59 125 450 418 2013 60 62 40 2037 44 2038 41 59 125 439 2013 60 2014 44 2015 62 2023 40 2014 2025 44 2008 2009 41 123 2014 2050 61 2009 46 2051 40 41 59 621 404 2052 61 2002 59 474 123 2052 61 2053 40 2054 46 2055 40 2025 41 44 2052 44 2050 44 2009 41 59 125 329 40 2056 2057 41 123 2058 46 2059 40 648 43 648 44 2052 41 59 125 2014 2060 61 2050 46 2061 40 2052 41 59 2062 46 2063 40 648 44 2052 44 2060 46 2064 41 59 450 418 2013 60 62 40 2060 44 2052 41 59 125 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 64 2065 457 404 2066 40 2067 60 2014 62 2068 44 404 2069 44 2014 2070 44 2008 2009 41 470 2071 123 324 2072 59 404 2073 61 2069 59 404 2074 59 404 2075 61 1500 59 355 123 2014 2076 61 2070 46 2077 40 2073 41 59 2074 61 2009 46 2078 40 2068 44 2076 41 59 2072 61 2072 40 2073 44 2074 44 1499 41 59 392 40 33 2072 41 123 2073 61 2074 59 125 2075 637 59 125 496 40 33 2072 605 2075 60 2005 41 59 392 40 33 2072 41 123 2079 46 2080 40 648 43 648 44 2074 44 2073 41 59 125 450 2073 59 125 64 2065 457 324 2081 40 404 2082 44 404 2083 44 356 2084 41 123 2085 40 2082 62 1500 44 648 41 59 2085 40 2083 62 1500 44 648 41 59 2085 40 2084 62 1500 44 648 41 59 356 2086 61 2087 46 2088 40 1501 45 40 40 356 41 2082 47 40 356 41 2083 41 41 59 450 2086 620 2084 59 125 125 
4897,Java,"        btcWalletService.addBalanceListener(new BalanceListener() {
            @Override
            public void onBalanceChanged(Coin balance, Transaction tx) {
                updateBalance();
            }
        });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 2005 2006 44 2007 2008 41 123 2009 40 41 59 125 125 41 59 
4053,Java,"@Slf4j
public abstract class ExecutableForAppWithP2p extends BisqExecutable {
    private static final long CHECK_MEMORY_PERIOD_SEC = 300;
    private static final long CHECK_SHUTDOWN_SEC = TimeUnit.HOURS.toSeconds(1);
    private static final long SHUTDOWN_INTERVAL = TimeUnit.HOURS.toMillis(24);
    private volatile boolean stopped;
    private final long startTime = System.currentTimeMillis();
    private TradeLimits tradeLimits;

    public ExecutableForAppWithP2p(String fullName, String scriptName, String appName, String version) {
        super(fullName, scriptName, appName, version);
    }

    @Override
    protected void configUserThread() {
        final ThreadFactory threadFactory = new ThreadFactoryBuilder()
                .setNameFormat(this.getClass().getSimpleName())
                .setDaemon(true)
                .build();
        UserThread.setExecutor(Executors.newSingleThreadExecutor(threadFactory));
    }

    @Override
    protected void startApplication() {
        // Pin that as it is used in PaymentMethods and verification in TradeStatistics
        tradeLimits = injector.getInstance(TradeLimits.class);
    }

    @Override
    public void onSetupComplete() {
        log.info(""onSetupComplete"");
    }

    // We don't use the gracefulShutDown implementation of the super class as we have a limited set of modules
    @Override
    public void gracefulShutDown(ResultHandler resultHandler) {
        log.info(""gracefulShutDown"");
        try {
            if (injector != null) {
                JsonFileManager.shutDownAllInstances();
                injector.getInstance(OpenBsqSwapOfferService.class).shutDown();
                injector.getInstance(RpcService.class).shutDown();
                injector.getInstance(DaoSetup.class).shutDown();
                injector.getInstance(ArbitratorManager.class).shutDown();
                injector.getInstance(OpenOfferManager.class).shutDown(() -> injector.getInstance(P2PService.class).shutDown(() -> {
                    injector.getInstance(WalletsSetup.class).shutDownComplete.addListener((ov, o, n) -> {
                        module.close(injector);

                        PersistenceManager.flushAllDataToDiskAtShutdown(() -> {
                            resultHandler.handleResult();
                            log.info(""Graceful shutdown completed. Exiting now."");
                            UserThread.runAfter(() -> System.exit(BisqExecutable.EXIT_SUCCESS), 1);
                        });
                    });
                    injector.getInstance(WalletsSetup.class).shutDown();
                    injector.getInstance(BtcWalletService.class).shutDown();
                    injector.getInstance(BsqWalletService.class).shutDown();
                }));
                // we wait max 5 sec.
                UserThread.runAfter(() -> {
                    PersistenceManager.flushAllDataToDiskAtShutdown(() -> {
                        resultHandler.handleResult();
                        log.info(""Graceful shutdown caused a timeout. Exiting now."");
                        UserThread.runAfter(() -> System.exit(BisqExecutable.EXIT_SUCCESS), 1);
                    });
                }, 5);
            } else {
                UserThread.runAfter(() -> {
                    resultHandler.handleResult();
                    System.exit(BisqExecutable.EXIT_SUCCESS);
                }, 1);
            }
        } catch (Throwable t) {
            log.debug(""App shutdown failed with exception"");
            t.printStackTrace();
            PersistenceManager.flushAllDataToDiskAtShutdown(() -> {
                resultHandler.handleResult();
                log.info(""Graceful shutdown resulted in an error. Exiting now."");
                UserThread.runAfter(() -> System.exit(BisqExecutable.EXIT_FAILURE), 1);
            });

        }
    }

    public void startShutDownInterval(GracefulShutDownHandler gracefulShutDownHandler) {
        if (DevEnv.isDevMode() || injector.getInstance(Config.class).useLocalhostForP2P) {
            return;
        }

        List<NodeAddress> seedNodeAddresses = new ArrayList<>(injector.getInstance(SeedNodeRepository.class).getSeedNodeAddresses());
        seedNodeAddresses.sort(Comparator.comparing(NodeAddress::getFullAddress));

        NodeAddress myAddress = injector.getInstance(P2PService.class).getNetworkNode().getNodeAddress();
        int myIndex = -1;
        for (int i = 0; i < seedNodeAddresses.size(); i++) {
            if (seedNodeAddresses.get(i).equals(myAddress)) {
                myIndex = i;
                break;
            }
        }

        if (myIndex == -1) {
            log.warn(""We did not find our node address in the seed nodes repository. "" +
                            ""We use a 24 hour delay after startup as shut down strategy."" +
                            ""myAddress={}, seedNodeAddresses={}"",
                    myAddress, seedNodeAddresses);

            UserThread.runPeriodically(() -> {
                if (System.currentTimeMillis() - startTime > SHUTDOWN_INTERVAL) {
                    log.warn(""\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"" +
                                    ""Shut down as node was running longer as {} hours"" +
                                    ""\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n"",
                            SHUTDOWN_INTERVAL / 3600000);

                    shutDown(gracefulShutDownHandler);
                }

            }, CHECK_SHUTDOWN_SEC);
            return;
        }

        // We interpret the value of myIndex as hour of day (0-23). That way we avoid the risk of a restart of
        // multiple nodes around the same time in case it would be not deterministic.

        // We wrap our periodic check in a delay of 2 hours to avoid that we get
        // triggered multiple times after a restart while being in the same hour. It can be that we miss our target
        // hour during that delay but that is not considered problematic, the seed would just restart a bit longer than
        // 24 hours.
        int target = myIndex;
        UserThread.runAfter(() -> {
            // We check every hour if we are in the target hour.
            UserThread.runPeriodically(() -> {
                int currentHour = ZonedDateTime.ofInstant(Instant.now(), ZoneId.of(""UTC"")).getHour();
                if (currentHour == target) {
                    log.warn(""\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"" +
                                    ""Shut down node at hour {} (UTC time is {})"" +
                                    ""\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n"",
                            target,
                            ZonedDateTime.ofInstant(Instant.now(), ZoneId.of(""UTC"")).toString());
                    shutDown(gracefulShutDownHandler);
                }
            }, TimeUnit.MINUTES.toSeconds(10));
        }, TimeUnit.HOURS.toSeconds(2));
    }

    @SuppressWarnings(""InfiniteLoopStatement"")
    protected void keepRunning() {
        while (true) {
            try {
                Thread.sleep(Long.MAX_VALUE);
            } catch (InterruptedException ignore) {
            }
        }
    }

    protected void checkMemory(Config config, GracefulShutDownHandler gracefulShutDownHandler) {
        int maxMemory = config.maxMemory;
        UserThread.runPeriodically(() -> {
            Profiler.printSystemLoad();
            if (!stopped) {
                long usedMemoryInMB = Profiler.getUsedMemoryInMB();
                double warningTrigger = maxMemory * 0.8;
                if (usedMemoryInMB > warningTrigger) {
                    log.warn(""\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"" +
                                    ""We are over 80% of our memory limit ({}) and call the GC. usedMemory: {} MB. freeMemory: {} MB"" +
                                    ""\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n"",
                            (int) warningTrigger, usedMemoryInMB, Profiler.getFreeMemoryInMB());
                    System.gc();
                    Profiler.printSystemLoad();
                }

                UserThread.runAfter(() -> {
                    log.info(""Memory 2 sec. after calling the GC. usedMemory: {} MB. freeMemory: {} MB"",
                            Profiler.getUsedMemoryInMB(), Profiler.getFreeMemoryInMB());
                }, 2);

                UserThread.runAfter(() -> {
                    long usedMemory = Profiler.getUsedMemoryInMB();
                    if (usedMemory > maxMemory) {
                        log.warn(""\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"" +
                                        ""We are over our memory limit ({}) and trigger a shutdown. usedMemory: {} MB. freeMemory: {} MB"" +
                                        ""\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n"",
                                (int) maxMemory, usedMemory, Profiler.getFreeMemoryInMB());
                        shutDown(gracefulShutDownHandler);
                    }
                }, 5);
            }
        }, CHECK_MEMORY_PERIOD_SEC);
    }

    protected void shutDown(GracefulShutDownHandler gracefulShutDownHandler) {
        stopped = true;
        gracefulShutDownHandler.gracefulShutDown(() -> {
            log.info(""Shutdown complete"");
            System.exit(1);
        });
    }
}",0,64 2000 439 305 334 2001 378 2002 123 437 457 381 413 2003 61 1504 59 437 457 381 413 2004 61 2005 46 2006 46 2007 40 1501 41 59 437 457 381 413 2008 61 2005 46 2006 46 2009 40 1503 41 59 437 493 324 2010 59 437 381 413 2011 61 2012 46 2013 40 41 59 437 2014 2015 59 439 2001 40 2016 2017 44 2016 2018 44 2016 2019 44 2016 2020 41 123 463 40 2017 44 2018 44 2019 44 2020 41 59 125 64 2021 438 492 2022 40 41 123 381 2023 2024 61 418 2025 40 41 46 2026 40 467 46 2027 40 41 46 2028 40 41 41 46 2029 40 473 41 46 2030 40 41 59 2031 46 2032 40 2033 46 2034 40 2024 41 41 59 125 64 2021 438 492 2035 40 41 123 621 2015 61 2036 46 2037 40 2014 46 334 41 59 125 64 2021 439 492 2038 40 41 123 2039 46 2040 40 648 41 59 125 621 64 2021 439 492 2041 40 2042 2043 41 123 2044 46 2045 40 648 41 59 474 123 392 40 2046 631 424 41 123 2047 46 2048 40 41 59 2046 46 2049 40 2050 46 334 41 46 2051 40 41 59 2046 46 2049 40 2052 46 334 41 46 2051 40 41 59 2046 46 2049 40 2053 46 334 41 46 2051 40 41 59 2046 46 2049 40 2054 46 334 41 46 2051 40 41 59 2046 46 2049 40 2055 46 334 41 46 2051 40 40 41 45 62 2046 46 2049 40 2056 46 334 41 46 2051 40 40 41 45 62 123 2046 46 2049 40 2057 46 334 41 46 2058 46 2059 40 40 2060 44 2061 44 2062 41 45 62 123 414 46 2063 40 2046 41 59 2064 46 2065 40 40 41 45 62 123 2043 46 2066 40 41 59 2044 46 2045 40 648 41 59 2067 46 2068 40 40 41 45 62 2012 46 375 40 2002 46 2069 41 44 1501 41 59 125 41 59 125 41 59 2046 46 2049 40 2057 46 334 41 46 2051 40 41 59 2046 46 2049 40 2070 46 334 41 46 2051 40 41 59 2046 46 2049 40 2071 46 334 41 46 2051 40 41 59 125 41 41 59 621 2072 46 2073 40 40 41 45 62 123 2074 46 2075 40 40 41 45 62 123 2043 46 2076 40 41 59 2044 46 2045 40 648 41 59 2072 46 2073 40 40 41 45 62 2012 46 375 40 2002 46 2077 41 44 1501 41 59 125 41 59 125 44 1502 41 59 125 360 123 2078 46 2079 40 40 41 45 62 123 2043 46 2080 40 41 59 2012 46 375 40 2002 46 2081 41 59 125 44 1501 41 59 125 125 329 40 2082 2083 41 123 2044 46 2084 40 648 41 59 2083 46 2085 40 41 59 2086 46 2087 40 40 41 45 62 123 2043 46 2088 40 41 59 2044 46 2045 40 648 41 59 2089 46 2090 40 40 41 45 62 2012 46 375 40 2002 46 2091 41 44 1501 41 59 125 41 59 125 125 439 492 2092 40 2093 2094 41 123 392 40 2095 46 2096 40 41 606 2097 46 2098 40 2099 46 334 41 46 2100 41 123 450 59 125 2101 60 2102 62 2103 61 418 2104 60 62 40 2097 46 2098 40 2105 46 334 41 46 2106 40 41 41 59 2103 46 2107 40 2108 46 2109 40 2102 58 58 2110 41 41 59 2102 2111 61 2097 46 2098 40 2112 46 334 41 46 2113 40 41 46 2114 40 41 59 404 2115 61 45 1501 59 385 40 404 2116 61 1500 59 2116 60 2103 46 2117 40 41 59 2116 637 41 123 392 40 2103 46 2118 40 2116 41 46 2119 40 2111 41 41 123 2115 61 2116 59 325 59 125 125 392 40 2115 614 45 1501 41 123 2120 46 2121 40 648 43 648 43 648 44 2111 44 2103 41 59 2122 46 2123 40 40 41 45 62 123 392 40 2012 46 2013 40 41 45 2011 62 2008 41 123 2120 46 2121 40 648 43 648 43 648 44 2008 47 1508 41 59 2124 40 2094 41 59 125 125 44 2004 41 59 450 59 125 621 621 621 621 621 621 404 2125 61 2115 59 2126 46 2127 40 40 41 45 62 123 621 2126 46 2128 40 40 41 45 62 123 404 2129 61 2130 46 2131 40 2132 46 2133 40 41 44 2134 46 2135 40 648 41 41 46 2136 40 41 59 392 40 2129 614 2125 41 123 2137 46 2138 40 648 43 648 43 648 44 2125 44 2130 46 2131 40 2132 46 2133 40 41 44 2134 46 2135 40 648 41 41 46 2139 40 41 41 59 2140 40 2094 41 59 125 125 44 2005 46 2141 46 2007 40 1502 41 41 59 125 44 2005 46 2006 46 2007 40 1502 41 41 59 125 64 2142 40 648 41 438 492 2143 40 41 123 496 40 473 41 123 474 123 2144 46 2145 40 2146 46 2147 41 59 125 329 40 2148 2149 41 123 125 125 125 438 492 2150 40 2151 2152 44 2093 2094 41 123 404 2153 61 2152 46 2153 59 2154 46 2155 40 40 41 45 62 123 2156 46 2157 40 41 59 392 40 33 2010 41 123 413 2158 61 2156 46 2159 40 41 59 356 2160 61 2153 42 1499 59 392 40 2158 62 2160 41 123 2161 46 2162 40 648 43 648 43 648 44 40 404 41 2160 44 2158 44 2156 46 2163 40 41 41 59 2012 46 2164 40 41 59 2156 46 2157 40 41 59 125 2154 46 2165 40 40 41 45 62 123 2166 46 2167 40 648 44 2156 46 2159 40 41 44 2156 46 2168 40 41 41 59 125 44 1502 41 59 2154 46 2165 40 40 41 45 62 123 413 2169 61 2156 46 2159 40 41 59 392 40 2169 62 2153 41 123 2170 46 2171 40 648 43 648 43 648 44 40 404 41 2153 44 2169 44 2156 46 2172 40 41 41 59 2173 40 2094 41 59 125 125 44 1502 41 59 125 125 44 2003 41 59 125 438 492 2174 40 2093 2094 41 123 2010 61 473 59 2094 46 2041 40 40 41 45 62 123 2175 46 2176 40 648 41 59 2012 46 375 40 1501 41 59 125 41 59 125 125 
5708,Java,"@FxmlView
public class PasswordView extends ActivatableView<GridPane, Void> {

    private final WalletsManager walletsManager;
    private final PasswordValidator passwordValidator;
    private final Navigation navigation;

    private PasswordTextField passwordField;
    private PasswordTextField repeatedPasswordField;
    private AutoTooltipButton pwButton;
    private TitledGroupBg headline;
    private int gridRow = 0;
    private ChangeListener<Boolean> passwordFieldFocusChangeListener;
    private ChangeListener<String> passwordFieldTextChangeListener;
    private ChangeListener<String> repeatedPasswordFieldChangeListener;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    private PasswordView(WalletsManager walletsManager, PasswordValidator passwordValidator, Navigation navigation) {
        this.walletsManager = walletsManager;
        this.passwordValidator = passwordValidator;
        this.navigation = navigation;
    }

    @Override
    public void initialize() {
        headline = addTitledGroupBg(root, gridRow, 3, """");
        passwordField = addPasswordTextField(root, gridRow, Res.get(""password.enterPassword""), Layout.TWICE_FIRST_ROW_DISTANCE);
        final RequiredFieldValidator requiredFieldValidator = new RequiredFieldValidator();
        passwordField.getValidators().addAll(requiredFieldValidator, passwordValidator);
        passwordFieldFocusChangeListener = (observable, oldValue, newValue) -> {
            if (!newValue) validatePasswords();
        };

        passwordFieldTextChangeListener = (observable, oldvalue, newValue) -> {
            if (oldvalue != newValue) validatePasswords();
        };

        repeatedPasswordField = addPasswordTextField(root, ++gridRow, Res.get(""password.confirmPassword""));
        requiredFieldValidator.setMessage(Res.get(""validation.empty""));
        repeatedPasswordField.getValidators().addAll(requiredFieldValidator, passwordValidator);
        repeatedPasswordFieldChangeListener = (observable, oldValue, newValue) -> {
            if (oldValue != newValue) validatePasswords();
        };

        Tuple4<Button, BusyAnimation, Label, HBox> tuple = addButtonBusyAnimationLabel(root, ++gridRow, 0, """", 10);
        pwButton = (AutoTooltipButton) tuple.first;
        BusyAnimation busyAnimation = tuple.second;
        Label deriveStatusLabel = tuple.third;
        pwButton.setDisable(true);

        setText();

        pwButton.setOnAction(e -> {
            if (!walletsManager.areWalletsEncrypted()) {
                new Popup().backgroundInfo(Res.get(""password.backupReminder""))
                        .actionButtonText(Res.get(""password.setPassword""))
                        .onAction(() -> onApplyPassword(busyAnimation, deriveStatusLabel))
                        .secondaryActionButtonText(Res.get(""password.makeBackup""))
                        .onSecondaryAction(() -> {
                            navigation.setReturnPath(navigation.getCurrentPath());
                            navigation.navigateTo(MainView.class, AccountView.class, BackupView.class);
                        })
                        .width(800)
                        .show();
            } else {
                onApplyPassword(busyAnimation, deriveStatusLabel);
            }
        });

        addTitledGroupBg(root, ++gridRow, 1, Res.get(""shared.information""), Layout.GROUP_DISTANCE);
        addMultilineLabel(root, gridRow, Res.get(""account.password.info""), Layout.FIRST_ROW_AND_GROUP_DISTANCE);
    }

    private void onApplyPassword(BusyAnimation busyAnimation, Label deriveStatusLabel) {
        String password = passwordField.getText();
        checkArgument(password.length() < 500, Res.get(""password.tooLong""));

        pwButton.setDisable(true);
        deriveStatusLabel.setText(Res.get(""password.deriveKey""));
        busyAnimation.play();

        KeyCrypterScrypt keyCrypterScrypt = walletsManager.getKeyCrypterScrypt();
        ScryptUtil.deriveKeyWithScrypt(keyCrypterScrypt, password, aesKey -> {
            deriveStatusLabel.setText("""");
            busyAnimation.stop();

            if (walletsManager.areWalletsEncrypted()) {
                if (walletsManager.checkAESKey(aesKey)) {
                    walletsManager.decryptWallets(aesKey);
                    new Popup()
                            .feedback(Res.get(""password.walletDecrypted""))
                            .show();
                    backupWalletAndResetFields();
                } else {
                    pwButton.setDisable(false);
                    new Popup()
                            .warning(Res.get(""password.wrongPw""))
                            .show();
                }
            } else {
                try {
                    walletsManager.encryptWallets(keyCrypterScrypt, aesKey);
                    new Popup()
                            .feedback(Res.get(""password.walletEncrypted""))
                            .show();
                    backupWalletAndResetFields();
                    walletsManager.clearBackup();
                } catch (Throwable t) {
                    new Popup()
                            .warning(Res.get(""password.walletEncryptionFailed""))
                            .show();
                }
            }
            setText();
            updatePasswordListeners();
        });
    }

    private void backupWalletAndResetFields() {
        passwordField.clear();
        repeatedPasswordField.clear();
        walletsManager.backupWallets();
    }

    private void setText() {
        if (walletsManager.areWalletsEncrypted()) {
            pwButton.updateText(Res.get(""account.password.removePw.button""));
            headline.setText(Res.get(""account.password.removePw.headline""));

            repeatedPasswordField.setVisible(false);
            repeatedPasswordField.setManaged(false);
        } else {
            pwButton.updateText(Res.get(""account.password.setPw.button""));
            headline.setText(Res.get(""account.password.setPw.headline""));

            repeatedPasswordField.setVisible(true);
            repeatedPasswordField.setManaged(true);
        }
    }

    @Override
    protected void activate() {
        updatePasswordListeners();

        repeatedPasswordField.textProperty().addListener(repeatedPasswordFieldChangeListener);
    }

    private void updatePasswordListeners() {
        passwordField.focusedProperty().removeListener(passwordFieldFocusChangeListener);
        passwordField.textProperty().removeListener(passwordFieldTextChangeListener);

        if (walletsManager.areWalletsEncrypted()) {
            passwordField.textProperty().addListener(passwordFieldTextChangeListener);
        } else {
            passwordField.focusedProperty().addListener(passwordFieldFocusChangeListener);
        }
    }

    @Override
    protected void deactivate() {
        passwordField.focusedProperty().removeListener(passwordFieldFocusChangeListener);
        passwordField.textProperty().removeListener(passwordFieldTextChangeListener);
        repeatedPasswordField.textProperty().removeListener(repeatedPasswordFieldChangeListener);

    }

    private void validatePasswords() {
        passwordValidator.setPasswordsMatch(true);

        if (passwordField.validate()) {
            if (walletsManager.areWalletsEncrypted()) {
                pwButton.setDisable(false);
                return;
            } else {
                if (repeatedPasswordField.validate()) {
                    if (passwordField.getText().equals(repeatedPasswordField.getText())) {
                        pwButton.setDisable(false);
                        return;
                    } else {
                        passwordValidator.setPasswordsMatch(false);
                        repeatedPasswordField.validate();
                    }
                }
            }
        }
        pwButton.setDisable(true);
    }
}",0,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 123 437 381 2005 2006 59 437 381 2007 2008 59 437 381 2009 2010 59 437 2011 2012 59 437 2011 2013 59 437 2014 2015 59 437 2016 2017 59 437 404 2018 61 1500 59 437 2019 60 2020 62 2021 59 437 2019 60 2022 62 2023 59 437 2019 60 2022 62 2024 59 621 621 621 64 2025 437 2001 40 2005 2006 44 2007 2008 44 2009 2010 41 123 467 46 2006 61 2006 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 125 64 2026 439 492 2027 40 41 123 2017 61 2028 40 2029 44 2018 44 1502 44 648 41 59 2012 61 2030 40 2029 44 2018 44 2031 46 2032 40 648 41 44 2033 46 2034 41 59 381 2035 2036 61 418 2035 40 41 59 2012 46 2037 40 41 46 2038 40 2036 44 2008 41 59 2021 61 40 2039 44 2040 44 2041 41 45 62 123 392 40 33 2041 41 2042 40 41 59 125 59 2023 61 40 2039 44 2043 44 2041 41 45 62 123 392 40 2043 631 2041 41 2044 40 41 59 125 59 2013 61 2030 40 2029 44 637 2018 44 2031 46 2032 40 648 41 41 59 2036 46 2045 40 2031 46 2032 40 648 41 41 59 2013 46 2037 40 41 46 2038 40 2036 44 2008 41 59 2024 61 40 2039 44 2040 44 2041 41 45 62 123 392 40 2040 631 2041 41 2046 40 41 59 125 59 2047 60 2048 44 2049 44 2050 44 2051 62 2052 61 2053 40 2029 44 637 2018 44 1500 44 648 44 1502 41 59 2015 61 40 2014 41 2052 46 2054 59 2049 2055 61 2052 46 2056 59 2050 2057 61 2052 46 2058 59 2015 46 2059 40 473 41 59 2060 40 41 59 2015 46 2061 40 2062 45 62 123 392 40 33 2006 46 2063 40 41 41 123 418 2064 40 41 46 2065 40 2031 46 2032 40 648 41 41 46 2066 40 2031 46 2032 40 648 41 41 46 2067 40 40 41 45 62 2068 40 2055 44 2057 41 41 46 2069 40 2031 46 2032 40 648 41 41 46 2070 40 40 41 45 62 123 2010 46 2071 40 2010 46 2072 40 41 41 59 2010 46 2073 40 2074 46 334 44 2075 46 334 44 2076 46 334 41 59 125 41 46 2077 40 1504 41 46 2078 40 41 59 125 360 123 2079 40 2055 44 2057 41 59 125 125 41 59 2028 40 2029 44 637 2018 44 1501 44 2031 46 2032 40 648 41 44 2033 46 2080 41 59 2081 40 2029 44 2018 44 2031 46 2032 40 648 41 44 2033 46 2082 41 59 125 437 492 2083 40 2084 2085 44 2086 2087 41 123 2022 2088 61 2012 46 2089 40 41 59 2090 40 2088 46 2091 40 41 60 1504 44 2092 46 2093 40 648 41 41 59 2015 46 2094 40 473 41 59 2087 46 2095 40 2092 46 2093 40 648 41 41 59 2085 46 2096 40 41 59 2097 2098 61 2006 46 2099 40 41 59 2100 46 2101 40 2098 44 2088 44 2102 45 62 123 2087 46 2095 40 648 41 59 2085 46 2103 40 41 59 392 40 2006 46 2104 40 41 41 123 392 40 2006 46 2105 40 2102 41 41 123 2006 46 2106 40 2102 41 59 418 2107 40 41 46 2108 40 2092 46 2093 40 648 41 41 46 2109 40 41 59 2110 40 41 59 125 360 123 2015 46 2094 40 380 41 59 418 2111 40 41 46 494 40 2092 46 2093 40 648 41 41 46 2112 40 41 59 125 125 360 123 474 123 2006 46 2113 40 2098 44 2102 41 59 418 2114 40 41 46 2115 40 2092 46 2093 40 648 41 41 46 2116 40 41 59 2117 40 41 59 2006 46 2118 40 41 59 125 329 40 2119 2120 41 123 418 2121 40 41 46 494 40 2092 46 2093 40 648 41 41 46 2122 40 41 59 125 125 2095 40 41 59 2123 40 41 59 125 41 59 125 437 492 2124 40 41 123 2012 46 2125 40 41 59 2013 46 2125 40 41 59 2006 46 2126 40 41 59 125 437 492 2127 40 41 123 392 40 2006 46 2128 40 41 41 123 2015 46 2129 40 2130 46 2131 40 648 41 41 59 2017 46 2127 40 2130 46 2131 40 648 41 41 59 2013 46 2132 40 380 41 59 2013 46 2133 40 380 41 59 125 360 123 2015 46 2134 40 2135 46 2136 40 648 41 41 59 2017 46 2127 40 2135 46 2136 40 648 41 41 59 2013 46 2137 40 473 41 59 2013 46 2138 40 473 41 59 125 125 64 2026 438 492 2139 40 41 123 2140 40 41 59 2013 46 2141 40 41 46 2142 40 2024 41 59 125 437 492 2143 40 41 123 2012 46 2144 40 41 46 2145 40 2021 41 59 2012 46 2146 40 41 46 2145 40 2023 41 59 392 40 2006 46 2147 40 41 41 123 2012 46 2146 40 41 46 2148 40 2023 41 59 125 360 123 2012 46 2144 40 41 46 2149 40 2021 41 59 125 125 64 2026 438 492 2150 40 41 123 2012 46 2151 40 41 46 2152 40 2021 41 59 2012 46 2153 40 41 46 2152 40 2023 41 59 2013 46 2153 40 41 46 2152 40 2024 41 59 125 437 492 2154 40 41 123 2008 46 2155 40 473 41 59 392 40 2012 46 2156 40 41 41 123 392 40 2006 46 2157 40 41 41 123 2015 46 2158 40 380 41 59 450 59 125 360 123 392 40 2013 46 2156 40 41 41 123 392 40 2012 46 2159 40 41 46 2160 40 2013 46 2159 40 41 41 41 123 2015 46 2161 40 380 41 59 450 59 125 360 123 2008 46 2155 40 380 41 59 2013 46 2156 40 41 59 125 125 125 125 2015 46 2162 40 473 41 59 125 125 
3856,Java,"                paramComboBox.setConverter(new StringConverter<>() {
                    @Override
                    public String toString(Param param) {
                        return param != null ? param.getDisplayString() : """";
                    }

                    @Override
                    public Param fromString(String string) {
                        return null;
                    }
                });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 450 2007 631 424 63 2007 46 2008 40 41 58 648 59 125 64 2003 439 2006 2009 40 2004 461 41 123 450 424 59 125 125 41 59 
3121,Java,"        daoStateService.addDaoStateListener(new DaoStateListener() {
            @Override
            public void onNewBlockHeight(int blockHeight) {
                if (blockHeight > 0 && periodService.getCurrentCycle() != null)
                    periodService.getCurrentCycle().getPhaseForHeight(blockHeight).ifPresent(phaseProperty::set);
            }
        });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 404 2005 41 123 392 40 2005 62 1500 605 2006 46 2007 40 41 631 424 41 2006 46 2007 40 41 46 2008 40 2005 41 46 2009 40 2010 58 58 2011 41 59 125 125 41 59 
3451,Java,"    static class Opt {
        private final String name;
        private final String arg;

        public Opt(String name) {
            this(name, null);
        }

        public Opt(String name, String arg) {
            this.name = name;
            this.arg = arg;
        }

        @Override
        public String toString() {
            return format(""--%s%s"", name, arg != null ? (""="" + arg) : """");
        }
    }",0,457 334 2000 123 437 381 2001 2002 59 437 381 2001 2003 59 439 2000 40 2001 2002 41 123 467 40 2002 44 424 41 59 125 439 2000 40 2001 2002 44 2001 2003 41 123 467 46 2002 61 2002 59 467 46 2003 61 2003 59 125 64 2004 439 2001 2005 40 41 123 450 2006 40 648 44 2002 44 2003 631 424 63 40 648 43 2003 41 58 648 41 59 125 125 
3857,Java,"                bondedRoleTypeComboBox.setConverter(new StringConverter<>() {
                    @Override
                    public String toString(BondedRoleType bondedRoleType) {
                        return bondedRoleType != null ? bondedRoleType.getDisplayString() : """";
                    }

                    @Override
                    public BondedRoleType fromString(String string) {
                        return null;
                    }
                });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 450 2007 631 424 63 2007 46 2008 40 41 58 648 59 125 64 2003 439 2006 2009 40 2004 461 41 123 450 424 59 125 125 41 59 
3858,Java,"                confiscateBondComboBox.setConverter(new StringConverter<>() {
                    @Override
                    public String toString(Bond bond) {
                        String details = "" ("" + Res.get(""dao.bond.table.column.lockupTxId"") + "": "" + bond.getLockupTxId() + "")"";
                        if (bond instanceof BondedRole) {
                            return bond.getBondedAsset().getDisplayString() + details;
                        } else {
                            return Res.get(""dao.bond.bondedReputation"") + details;
                        }
                    }

                    @Override
                    public Bond fromString(String string) {
                        return null;
                    }
                });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 2004 2008 61 648 43 2009 46 2010 40 648 41 43 648 43 2007 46 2011 40 41 43 648 59 392 40 2007 402 2012 41 123 450 2007 46 2013 40 41 46 2014 40 41 43 2008 59 125 360 123 450 2009 46 2010 40 648 41 43 2008 59 125 125 64 2003 439 2006 2015 40 2004 461 41 123 450 424 59 125 125 41 59 
24876,Java,"class IsPotentialJUnit4TestClassTests {

	private final IsPotentialJUnit4TestClass isPotentialJUnit4TestClass = new IsPotentialJUnit4TestClass();

	@Test
	void staticMemberClass() {
		assertTrue(isPotentialJUnit4TestClass.test(Foo.class));
	}

	public static class Foo {
	}

	@Test
	void nonPublicClass() {
		assertFalse(isPotentialJUnit4TestClass.test(Bar.class));
	}

	static class Bar {
	}

	@Test
	void abstractClass() {
		assertFalse(isPotentialJUnit4TestClass.test(Baz.class));
	}

	public static abstract class Baz {
	}

	@Test
	void anonymousClass() {
		var foo = new Foo() {
		};

		assertFalse(isPotentialJUnit4TestClass.test(foo.getClass()));
	}

	public class FooBaz {
	}

	@Test
	void publicInnerClass() {
		assertFalse(isPotentialJUnit4TestClass.test(FooBaz.class));
	}
}",0,334 2000 123 437 381 2001 2002 61 418 2001 40 41 59 64 2003 492 2004 40 41 123 2005 40 2002 46 2006 40 2007 46 334 41 41 59 125 439 457 334 2008 123 125 64 2003 492 2009 40 41 123 2010 40 2002 46 2011 40 2012 46 334 41 41 59 125 457 334 2013 123 125 64 2003 492 2014 40 41 123 2015 40 2002 46 2016 40 2017 46 334 41 41 59 125 439 457 305 334 2018 123 125 64 2003 492 2019 40 41 123 490 2020 61 418 2008 40 41 123 125 59 2021 40 2002 46 2022 40 2020 46 2023 40 41 41 41 59 125 439 334 2024 123 125 64 2003 492 2025 40 41 123 2026 40 2002 46 2027 40 2024 46 334 41 41 59 125 125 
2486,Java,"    public final class Setting<T> {

        public T value;
        public final T defaultValue;
        private String name;

        @SuppressWarnings(""unchecked"")
        private Setting(T value) {
            if (value == null) {
                throw new IllegalArgumentException(""Cannot determine value type class from null"");
            }
            this.value = value;
            this.defaultValue = value;
        }

        /**
         * Deprecated! Please use .value directly instead
         *
         * @return the current setting value
         */
        @Deprecated
        public final T get() {
            return value;
        }

        public final String getName() {
            return name;
        }

        public Class<T> getValueClass() {
            // noinspection unchecked
            return (Class<T>) TypeUtils.resolveBaseClass(getType());
        }

        @Override
        public String toString() {
            return SettingsUtil.settingToString(this);
        }

        /**
         * Reset this setting to its default value
         */
        public void reset() {
            value = defaultValue;
        }

        public final Type getType() {
            return settingTypes.get(this);
        }
    }",0,439 381 334 2000 60 2001 62 123 439 2001 2002 59 439 381 2001 2003 59 437 2004 2005 59 64 2006 40 648 41 437 2000 40 2001 2002 41 123 392 40 2002 614 424 41 123 469 418 2007 40 648 41 59 125 467 46 2002 61 2002 59 467 46 2003 61 2002 59 125 618 64 2008 439 381 2001 2009 40 41 123 450 2002 59 125 439 381 2004 2010 40 41 123 450 2005 59 125 439 2011 60 2001 62 2012 40 41 123 621 450 40 2011 60 2001 62 41 2013 46 2014 40 2015 40 41 41 59 125 64 2016 439 2004 2017 40 41 123 450 2018 46 2019 40 467 41 59 125 618 439 492 2020 40 41 123 2002 61 2003 59 125 439 381 2021 2022 40 41 123 450 2023 46 2009 40 467 41 59 125 125 
2484,Java,"public final class BlockBreakHelper implements Helper {

    private final IPlayerContext ctx;
    private boolean didBreakLastTick;

    BlockBreakHelper(IPlayerContext ctx) {
        this.ctx = ctx;
    }

    public void stopBreakingBlock() {
        // The player controller will never be null, but the player can be
        if (ctx.player() != null && didBreakLastTick) {
            if (!ctx.playerController().hasBrokenBlock()) {
                // insane bypass to check breaking succeeded
                ctx.playerController().setHittingBlock(true);
            }
            ctx.playerController().resetBlockRemoving();
            didBreakLastTick = false;
        }
    }

    public void tick(boolean isLeftClick) {
        RayTraceResult trace = ctx.objectMouseOver();
        boolean isBlockTrace = trace != null && trace.typeOfHit == RayTraceResult.Type.BLOCK;

        if (isLeftClick && isBlockTrace) {
            if (!didBreakLastTick) {
                ctx.playerController().syncHeldItem();
                ctx.playerController().clickBlock(trace.getBlockPos(), trace.sideHit);
                ctx.player().swingArm(EnumHand.MAIN_HAND);
            }

            // Attempt to break the block
            if (ctx.playerController().onPlayerDamageBlock(trace.getBlockPos(), trace.sideHit)) {
                ctx.player().swingArm(EnumHand.MAIN_HAND);
            }

            ctx.playerController().setHittingBlock(false);

            didBreakLastTick = true;
        } else if (didBreakLastTick) {
            stopBreakingBlock();
            didBreakLastTick = false;
        }
    }
}",0,439 381 334 2000 395 2001 123 437 381 2002 2003 59 437 324 2004 59 2000 40 2002 2003 41 123 467 46 2003 61 2003 59 125 439 492 2005 40 41 123 621 392 40 2003 46 2006 40 41 631 424 605 2004 41 123 392 40 33 2003 46 2007 40 41 46 2008 40 41 41 123 621 2003 46 2007 40 41 46 2009 40 473 41 59 125 2003 46 2007 40 41 46 2010 40 41 59 2004 61 380 59 125 125 439 492 2011 40 324 2012 41 123 2013 2014 61 2003 46 2015 40 41 59 324 2016 61 2014 631 424 605 2014 46 2017 614 2013 46 2018 46 2019 59 392 40 2012 605 2016 41 123 392 40 33 2004 41 123 2003 46 2020 40 41 46 2021 40 41 59 2003 46 2020 40 41 46 2022 40 2014 46 2023 40 41 44 2014 46 2024 41 59 2003 46 2025 40 41 46 2026 40 2027 46 2028 41 59 125 621 392 40 2003 46 2029 40 41 46 2030 40 2014 46 2031 40 41 44 2014 46 2032 41 41 123 2003 46 2033 40 41 46 2034 40 2035 46 2036 41 59 125 2003 46 2029 40 41 46 2037 40 380 41 59 2004 61 473 59 125 360 392 40 2004 41 123 2005 40 41 59 2004 61 380 59 125 125 125 
2723,Java,"@Mixin(EntityLivingBase.class)
public abstract class MixinEntityLivingBase extends Entity {

    /**
     * Event called to override the movement direction when jumping
     */
    private RotationMoveEvent jumpRotationEvent;

    public MixinEntityLivingBase(World worldIn, RotationMoveEvent jumpRotationEvent) {
        super(worldIn);
        this.jumpRotationEvent = jumpRotationEvent;
    }

    @Inject(
            method = ""jump"",
            at = @At(""HEAD"")
    )
    private void preMoveRelative(CallbackInfo ci) {
        // noinspection ConstantConditions
        if (EntityPlayerSP.class.isInstance(this)) {
            IBaritone baritone = BaritoneAPI.getProvider().getBaritoneForPlayer((EntityPlayerSP) (Object) this);
            if (baritone != null) {
                this.jumpRotationEvent = new RotationMoveEvent(RotationMoveEvent.Type.JUMP, this.rotationYaw);
                baritone.getGameEventHandler().onPlayerRotationMove(this.jumpRotationEvent);
            }
        }
    }

    @Redirect(
            method = ""jump"",
            at = @At(
                    value = ""FIELD"",
                    opcode = GETFIELD,
                    target = ""net/minecraft/entity/EntityLivingBase.rotationYaw:F""
            )
    )
    private float overrideYaw(EntityLivingBase self) {
        if (self instanceof EntityPlayerSP && BaritoneAPI.getProvider().getBaritoneForPlayer((EntityPlayerSP) (Object) this) != null) {
            return this.jumpRotationEvent.getYaw();
        }
        return self.rotationYaw;
    }

    @Redirect(
            method = ""travel"",
            at = @At(
                    value = ""INVOKE"",
                    target = ""net/minecraft/entity/EntityLivingBase.moveRelative(FFFF)V""
            )
    )
    private void travel(EntityLivingBase self, float strafe, float up, float forward, float friction) {
        // noinspection ConstantConditions
        if (!EntityPlayerSP.class.isInstance(this) || BaritoneAPI.getProvider().getBaritoneForPlayer((EntityPlayerSP) (Object) this) == null) {
            moveRelative(strafe, up, forward, friction);
            return;
        }
        RotationMoveEvent motionUpdateRotationEvent = new RotationMoveEvent(RotationMoveEvent.Type.MOTION_UPDATE, this.rotationYaw);
        BaritoneAPI.getProvider().getBaritoneForPlayer((EntityPlayerSP) (Object) this).getGameEventHandler().onPlayerRotationMove(motionUpdateRotationEvent);
        float originalYaw = this.rotationYaw;
        this.rotationYaw = motionUpdateRotationEvent.getYaw();
        this.moveRelative(strafe, up, forward, friction);
        this.rotationYaw = originalYaw;
    }
}",0,64 2000 40 2001 46 334 41 439 305 334 2002 378 2003 123 618 437 2004 2005 59 439 2002 40 2006 2007 44 2004 2005 41 123 463 40 2007 41 59 467 46 2005 61 2005 59 125 64 2008 40 2009 61 648 44 2010 61 64 2011 40 648 41 41 437 492 2012 40 2013 2014 41 123 621 392 40 2015 46 334 46 2016 40 467 41 41 123 2017 2018 61 2019 46 2020 40 41 46 2021 40 40 2015 41 40 2022 41 467 41 59 392 40 2018 631 424 41 123 467 46 2005 61 418 2004 40 2004 46 2023 46 2024 44 467 46 2025 41 59 2018 46 2026 40 41 46 2027 40 467 46 2005 41 59 125 125 125 64 2028 40 2009 61 648 44 2010 61 64 2011 40 2029 61 648 44 2030 61 2031 44 2032 61 648 41 41 437 384 2033 40 2001 2034 41 123 392 40 2034 402 2035 605 2036 46 2037 40 41 46 2038 40 40 2035 41 40 2039 41 467 41 631 424 41 123 450 467 46 2005 46 2040 40 41 59 125 450 2034 46 2041 59 125 64 2028 40 2009 61 648 44 2010 61 64 2011 40 2029 61 648 44 2032 61 648 41 41 437 492 2042 40 2001 2034 44 384 2043 44 384 2044 44 384 2045 44 384 2046 41 123 621 392 40 33 2047 46 334 46 2048 40 467 41 606 2049 46 2050 40 41 46 2051 40 40 2047 41 40 2052 41 467 41 614 424 41 123 2053 40 2043 44 2044 44 2045 44 2046 41 59 450 59 125 2004 2054 61 418 2004 40 2004 46 2055 46 2056 44 467 46 2057 41 59 2049 46 2050 40 41 46 2051 40 40 2047 41 40 2052 41 467 41 46 2058 40 41 46 2059 40 2054 41 59 384 2060 61 467 46 2057 59 467 46 2057 61 2054 46 2061 40 41 59 467 46 2062 40 2043 44 2044 44 2045 44 2046 41 59 467 46 2057 61 2060 59 125 125 
2483,Java,"public class BetterWorldBorder {

    private final double minX;
    private final double maxX;
    private final double minZ;
    private final double maxZ;

    public BetterWorldBorder(WorldBorder border) {
        this.minX = border.minX();
        this.maxX = border.maxX();
        this.minZ = border.minZ();
        this.maxZ = border.maxZ();
    }

    public boolean entirelyContains(int x, int z) {
        return x + 1 > minX && x < maxX && z + 1 > minZ && z < maxZ;
    }

    public boolean canPlaceAt(int x, int z) {
        // move it in 1 block on all sides
        // because we can't place a block at the very edge against a block outside the border
        // it won't let us right click it
        return x > minX && x + 1 < maxX && z > minZ && z + 1 < maxZ;
    }
}",0,439 334 2000 123 437 381 356 2001 59 437 381 356 2002 59 437 381 356 2003 59 437 381 356 2004 59 439 2000 40 2005 2006 41 123 467 46 2001 61 2006 46 2001 40 41 59 467 46 2002 61 2006 46 2002 40 41 59 467 46 2003 61 2006 46 2003 40 41 59 467 46 2004 61 2006 46 2004 40 41 59 125 439 324 2007 40 404 2008 44 404 2009 41 123 450 2008 43 1501 62 2001 605 2008 60 2002 605 2009 43 1501 62 2003 605 2009 60 2004 59 125 439 324 2010 40 404 2008 44 404 2009 41 123 621 621 621 450 2008 62 2001 605 2008 43 1501 60 2002 605 2009 62 2003 605 2009 43 1501 60 2004 59 125 125 
2583,Java,"    public class GetToBlockCalculationContext extends CalculationContext {

        public GetToBlockCalculationContext(boolean forUseOnAnotherThread) {
            super(GetToBlockProcess.super.baritone, forUseOnAnotherThread);
        }

        @Override
        public double breakCostMultiplierAt(int x, int y, int z, IBlockState current) {
            return 1;
        }
    }",0,439 334 2000 378 2001 123 439 2000 40 324 2002 41 123 463 40 2003 46 463 46 2004 44 2002 41 59 125 64 2005 439 356 2006 40 404 2007 44 404 2008 44 404 2009 44 2010 2011 41 123 450 1501 59 125 125 
2548,Java,"@Mixin(ChunkProviderClient.class)
public class MixinChunkProviderClient implements IChunkProviderClient {

    @Shadow
    @Final
    private Long2ObjectMap<Chunk> loadedChunks;

    @Override
    public Long2ObjectMap<Chunk> loadedChunks() {
        return this.loadedChunks;
    }
}",0,64 2000 40 2001 46 334 41 439 334 2002 395 2003 123 64 2004 64 2005 437 2006 60 2007 62 2008 59 64 2009 439 2006 60 2007 62 2008 40 41 123 450 467 46 2008 59 125 125 
2653,Java,"public final class CachedChunk {

    public static final ImmutableSet<Block> BLOCKS_TO_KEEP_TRACK_OF = ImmutableSet.of(
            Blocks.DIAMOND_BLOCK,
            //Blocks.COAL_ORE,
            Blocks.COAL_BLOCK,
            //Blocks.IRON_ORE,
            Blocks.IRON_BLOCK,
            //Blocks.GOLD_ORE,
            Blocks.GOLD_BLOCK,
            Blocks.EMERALD_ORE,
            Blocks.EMERALD_BLOCK,

            Blocks.ENDER_CHEST,
            Blocks.FURNACE,
            Blocks.CHEST,
            Blocks.TRAPPED_CHEST,
            Blocks.END_PORTAL,
            Blocks.END_PORTAL_FRAME,
            Blocks.MOB_SPAWNER,
            Blocks.BARRIER,
            Blocks.OBSERVER,
            Blocks.WHITE_SHULKER_BOX,
            Blocks.ORANGE_SHULKER_BOX,
            Blocks.MAGENTA_SHULKER_BOX,
            Blocks.LIGHT_BLUE_SHULKER_BOX,
            Blocks.YELLOW_SHULKER_BOX,
            Blocks.LIME_SHULKER_BOX,
            Blocks.PINK_SHULKER_BOX,
            Blocks.GRAY_SHULKER_BOX,
            Blocks.SILVER_SHULKER_BOX,
            Blocks.CYAN_SHULKER_BOX,
            Blocks.PURPLE_SHULKER_BOX,
            Blocks.BLUE_SHULKER_BOX,
            Blocks.BROWN_SHULKER_BOX,
            Blocks.GREEN_SHULKER_BOX,
            Blocks.RED_SHULKER_BOX,
            Blocks.BLACK_SHULKER_BOX,
            Blocks.PORTAL,
            Blocks.HOPPER,
            Blocks.BEACON,
            Blocks.BREWING_STAND,
            Blocks.SKULL,
            Blocks.ENCHANTING_TABLE,
            Blocks.ANVIL,
            Blocks.LIT_FURNACE,
            Blocks.BED,
            Blocks.DRAGON_EGG,
            Blocks.JUKEBOX,
            Blocks.END_GATEWAY,
            Blocks.WEB,
            Blocks.NETHER_WART,
            Blocks.LADDER,
            Blocks.VINE
    );


    /**
     * The size of the chunk data in bits. Equal to 16 KiB.
     * <p>
     * Chunks are 16x16x256, each block requires 2 bits.
     */
    public static final int SIZE = 2 * 16 * 16 * 256;

    /**
     * The size of the chunk data in bytes. Equal to 16 KiB.
     */
    public static final int SIZE_IN_BYTES = SIZE / 8;

    /**
     * The chunk x coordinate
     */
    public final int x;

    /**
     * The chunk z coordinate
     */
    public final int z;

    /**
     * The actual raw data of this packed chunk.
     * <p>
     * Each block is expressed as 2 bits giving a total of 16 KiB
     */
    private final BitSet data;

    private final Int2ObjectOpenHashMap<String> special;

    /**
     * The block names of each surface level block for generating an overview
     */
    private final IBlockState[] overview;

    private final int[] heightMap;

    private final Map<String, List<BlockPos>> specialBlockLocations;

    public final long cacheTimestamp;

    CachedChunk(int x, int z, BitSet data, IBlockState[] overview, Map<String, List<BlockPos>> specialBlockLocations, long cacheTimestamp) {
        validateSize(data);

        this.x = x;
        this.z = z;
        this.data = data;
        this.overview = overview;
        this.heightMap = new int[256];
        this.specialBlockLocations = specialBlockLocations;
        this.cacheTimestamp = cacheTimestamp;
        if (specialBlockLocations.isEmpty()) {
            this.special = null;
        } else {
            this.special = new Int2ObjectOpenHashMap<>();
            setSpecial();
        }
        calculateHeightMap();
    }

    private final void setSpecial() {
        for (Map.Entry<String, List<BlockPos>> entry : specialBlockLocations.entrySet()) {
            for (BlockPos pos : entry.getValue()) {
                special.put(getPositionIndex(pos.getX(), pos.getY(), pos.getZ()), entry.getKey());
            }
        }
    }

    public final IBlockState getBlock(int x, int y, int z, int dimension) {
        int index = getPositionIndex(x, y, z);
        PathingBlockType type = getType(index);
        int internalPos = z << 4 | x;
        if (heightMap[internalPos] == y && type != PathingBlockType.AVOID) {
            // if the top block in a column is water, we cache it as AVOID but we don't want to just return default state water (which is not flowing) beacuse then it would try to path through it

            // we have this exact block, it's a surface block
            /*System.out.println(""Saying that "" + x + "","" + y + "","" + z + "" is "" + state);
            if (!Minecraft.getMinecraft().world.getBlockState(new BlockPos(x + this.x * 16, y, z + this.z * 16)).getBlock().equals(state.getBlock())) {
                throw new IllegalStateException(""failed "" + Minecraft.getMinecraft().world.getBlockState(new BlockPos(x + this.x * 16, y, z + this.z * 16)).getBlock() + "" "" + state.getBlock() + "" "" + (x + this.x * 16) + "" "" + y + "" "" + (z + this.z * 16));
            }*/
            return overview[internalPos];
        }
        if (special != null) {
            String str = special.get(index);
            if (str != null) {
                return BlockUtils.stringToBlockRequired(str).getDefaultState();
            }
        }

        if (type == PathingBlockType.SOLID) {
            if (y == 127 && dimension == -1) {
                // nether roof is always unbreakable
                return Blocks.BEDROCK.getDefaultState();
            }
            if (y < 5 && dimension == 0) {
                // solid blocks below 5 are commonly bedrock
                // however, returning bedrock always would be a little yikes
                // discourage paths that include breaking blocks below 5 a little more heavily just so that it takes paths breaking what's known to be stone (at 5 or above) instead of what could maybe be bedrock (below 5)
                return Blocks.OBSIDIAN.getDefaultState();
            }
        }
        return ChunkPacker.pathingTypeToBlock(type, dimension);
    }

    private PathingBlockType getType(int index) {
        return PathingBlockType.fromBits(data.get(index), data.get(index + 1));
    }

    private void calculateHeightMap() {
        for (int z = 0; z < 16; z++) {
            for (int x = 0; x < 16; x++) {
                int index = z << 4 | x;
                heightMap[index] = 0;
                for (int y = 256; y >= 0; y--) {
                    int i = getPositionIndex(x, y, z);
                    if (data.get(i) || data.get(i + 1)) {
                        heightMap[index] = y;
                        break;
                    }
                }
            }
        }
    }

    public final IBlockState[] getOverview() {
        return overview;
    }

    public final Map<String, List<BlockPos>> getRelativeBlocks() {
        return specialBlockLocations;
    }

    public final ArrayList<BlockPos> getAbsoluteBlocks(String blockType) {
        if (specialBlockLocations.get(blockType) == null) {
            return null;
        }
        ArrayList<BlockPos> res = new ArrayList<>();
        for (BlockPos pos : specialBlockLocations.get(blockType)) {
            res.add(new BlockPos(pos.getX() + x * 16, pos.getY(), pos.getZ() + z * 16));
        }
        return res;
    }

    /**
     * @return Returns the raw packed chunk data as a byte array
     */
    public final byte[] toByteArray() {
        return this.data.toByteArray();
    }

    /**
     * Returns the raw bit index of the specified position
     *
     * @param x The x position
     * @param y The y position
     * @param z The z position
     * @return The bit index
     */
    public static int getPositionIndex(int x, int y, int z) {
        return (x << 1) | (z << 5) | (y << 9);
    }

    /**
     * Validates the size of an input {@link BitSet} containing the raw
     * packed chunk data. Sizes that exceed {@link CachedChunk#SIZE} are
     * considered invalid, and thus, an exception will be thrown.
     *
     * @param data The raw data
     * @throws IllegalArgumentException if the bitset size exceeds the maximum size
     */
    private static void validateSize(BitSet data) {
        if (data.size() > SIZE) {
            throw new IllegalArgumentException(""BitSet of invalid length provided"");
        }
    }
}",0,439 381 334 2000 123 439 457 381 2001 60 2002 62 2003 61 2001 46 2004 40 2005 46 2006 44 621 2005 46 2007 44 621 2005 46 2008 44 621 2005 46 2009 44 2005 46 2010 44 2005 46 2011 44 2005 46 2012 44 2005 46 2013 44 2005 46 2014 44 2005 46 2015 44 2005 46 2016 44 2005 46 2017 44 2005 46 2018 44 2005 46 2019 44 2005 46 2020 44 2005 46 2021 44 2005 46 2022 44 2005 46 2023 44 2005 46 2024 44 2005 46 2025 44 2005 46 2026 44 2005 46 2027 44 2005 46 2028 44 2005 46 2029 44 2005 46 2030 44 2005 46 2031 44 2005 46 2032 44 2005 46 2033 44 2005 46 2034 44 2005 46 2035 44 2005 46 2036 44 2005 46 2037 44 2005 46 2038 44 2005 46 2039 44 2005 46 2040 44 2005 46 2041 44 2005 46 2042 44 2005 46 2043 44 2005 46 2044 44 2005 46 2045 44 2005 46 2046 44 2005 46 2047 44 2005 46 2048 44 2005 46 2049 44 2005 46 2050 44 2005 46 2051 44 2005 46 2052 41 59 618 439 457 381 404 2053 61 1502 42 1503 42 1503 42 1504 59 618 439 457 381 404 2054 61 2053 47 1502 59 618 439 381 404 2055 59 618 439 381 404 2056 59 618 437 381 2057 2058 59 437 381 2059 60 2060 62 2061 59 618 437 381 2062 91 93 2063 59 437 381 404 91 93 2064 59 437 381 2065 60 2060 44 2066 60 2067 641 2068 59 439 381 413 2069 59 2000 40 404 2055 44 404 2056 44 2057 2058 44 2062 91 93 2063 44 2065 60 2060 44 2066 60 2067 641 2068 44 413 2069 41 123 2070 40 2058 41 59 467 46 2055 61 2055 59 467 46 2056 61 2056 59 467 46 2058 61 2058 59 467 46 2063 61 2063 59 467 46 2064 61 418 404 91 1504 93 59 467 46 2068 61 2068 59 467 46 2069 61 2069 59 392 40 2068 46 2071 40 41 41 123 467 46 2061 61 424 59 125 360 123 467 46 2061 61 418 2059 60 62 40 41 59 2072 40 41 59 125 2073 40 41 59 125 437 381 492 2074 40 41 123 385 40 2065 46 2075 60 2060 44 2066 60 2067 641 2076 58 2068 46 2077 40 41 41 123 385 40 2067 2078 58 2076 46 2079 40 41 41 123 2061 46 2080 40 2081 40 2078 46 2082 40 41 44 2078 46 2083 40 41 44 2078 46 2084 40 41 41 44 2076 46 2085 40 41 41 59 125 125 125 439 381 2062 2086 40 404 2055 44 404 2087 44 404 2056 44 404 2088 41 123 404 2089 61 2090 40 2055 44 2087 44 2056 41 59 2091 2092 61 2093 40 2089 41 59 404 2094 61 2056 622 1502 124 2055 59 392 40 2064 91 2094 93 614 2087 605 2092 631 2091 46 2095 41 123 621 621 604 450 2063 91 2094 93 59 125 392 40 2061 631 424 41 123 2060 2096 61 2061 46 2097 40 2089 41 59 392 40 2096 631 424 41 123 450 2098 46 2099 40 2096 41 46 2100 40 41 59 125 125 392 40 2092 614 2091 46 2101 41 123 392 40 2087 614 1504 605 2088 614 45 1501 41 123 621 450 2005 46 2102 46 2103 40 41 59 125 392 40 2087 60 1502 605 2088 614 1500 41 123 621 621 621 450 2005 46 2104 46 2105 40 41 59 125 125 450 2106 46 2107 40 2092 44 2088 41 59 125 437 2108 2109 40 404 2110 41 123 450 2108 46 2111 40 2058 46 2112 40 2110 41 44 2058 46 2112 40 2110 43 1501 41 41 59 125 437 492 2113 40 41 123 385 40 404 2056 61 1500 59 2056 60 1503 59 2056 637 41 123 385 40 404 2055 61 1500 59 2055 60 1503 59 2055 637 41 123 404 2110 61 2056 622 1502 124 2055 59 2064 91 2110 93 61 1500 59 385 40 404 2087 61 1504 59 2087 615 1500 59 2087 629 41 123 404 2114 61 2115 40 2055 44 2087 44 2056 41 59 392 40 2058 46 2116 40 2114 41 606 2058 46 2116 40 2114 43 1501 41 41 123 2064 91 2110 93 61 2087 59 325 59 125 125 125 125 125 439 381 2062 91 93 2117 40 41 123 450 2063 59 125 439 381 2065 60 2060 44 2066 60 2067 641 2118 40 41 123 450 2068 59 125 439 381 2119 60 2067 62 2120 40 2060 2121 41 123 392 40 2068 46 2122 40 2121 41 614 424 41 123 450 424 59 125 2119 60 2067 62 2123 61 418 2119 60 62 40 41 59 385 40 2067 2124 58 2068 46 2122 40 2121 41 41 123 2123 46 2125 40 418 2067 40 2124 46 2126 40 41 43 2055 42 1503 44 2124 46 2127 40 41 44 2124 46 2128 40 41 43 2056 42 1503 41 41 59 125 450 2123 59 125 618 439 381 326 91 93 2129 40 41 123 450 467 46 2058 46 2129 40 41 59 125 618 439 457 404 2130 40 404 2055 44 404 2087 44 404 2056 41 123 450 40 2055 622 1501 41 124 40 2056 622 1502 41 124 40 2087 622 1502 41 59 125 618 437 457 492 2131 40 2057 2058 41 123 392 40 2058 46 2132 40 41 62 2053 41 123 469 418 2133 40 648 41 59 125 125 125 
2612,Java,"    public static class EnderChestMemory {

        private static final Map<Path, EnderChestMemory> memory = new HashMap<>();
        private final Path enderChest;
        private List<ItemStack> contents;

        private EnderChestMemory(Path enderChest) {
            this.enderChest = enderChest;
            System.out.println(""Echest storing in "" + enderChest);
            try {
                this.contents = ContainerMemory.readItemStacks(Files.readAllBytes(enderChest));
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println(""CANNOT read echest =( =("");
                this.contents = null;
            }
        }

        public synchronized void save() {
            System.out.println(""Saving"");
            if (contents != null) {
                try {
                    enderChest.getParent().toFile().mkdir();
                    Files.write(enderChest, ContainerMemory.writeItemStacks(contents));
                } catch (IOException e) {
                    e.printStackTrace();
                    System.out.println(""CANNOT save echest =( =("");
                }
            }
        }

        private static synchronized EnderChestMemory getByServerAndPlayer(Path serverStorage, UUID player) {
            return memory.computeIfAbsent(serverStorage.resolve(""echests"").resolve(player.toString()), EnderChestMemory::new);
        }
    }",0,439 457 334 2000 123 437 457 381 2001 60 2002 44 2000 62 2003 61 418 2004 60 62 40 41 59 437 381 2002 2005 59 437 2006 60 2007 62 2008 59 437 2000 40 2002 2005 41 123 467 46 2005 61 2005 59 2009 46 430 46 2010 40 648 43 2005 41 59 474 123 467 46 2008 61 2011 46 2012 40 2013 46 2014 40 2005 41 41 59 125 329 40 2015 2016 41 123 2016 46 2017 40 41 59 2009 46 430 46 2010 40 648 41 59 467 46 2008 61 424 59 125 125 439 465 492 2018 40 41 123 2019 46 430 46 2020 40 648 41 59 392 40 2008 631 424 41 123 474 123 2005 46 2021 40 41 46 2022 40 41 46 2023 40 41 59 2024 46 2025 40 2005 44 2026 46 2027 40 2008 41 41 59 125 329 40 2028 2029 41 123 2029 46 2030 40 41 59 2019 46 430 46 2020 40 648 41 59 125 125 125 437 457 465 2000 2031 40 2002 2032 44 2033 2034 41 123 450 2003 46 2035 40 2032 46 2036 40 648 41 46 2036 40 2034 46 2037 40 41 41 44 2000 58 58 418 41 59 125 125 
2613,Java,"    private static final class FutureInventory {

        /**
         * The time that we initially expected the inventory to be provided, in milliseconds
         */
        private final long time;

        /**
         * The amount of slots in the inventory
         */
        private final int slots;

        /**
         * The type of inventory
         */
        private final String type;

        /**
         * The position of the inventory container
         */
        private final BlockPos pos;

        private FutureInventory(long time, int slots, String type, BlockPos pos) {
            this.time = time;
            this.slots = slots;
            this.type = type;
            this.pos = pos;
            // betterblockpos has censoring
            System.out.println(""Future inventory created "" + time + "" "" + slots + "" "" + type + "" "" + BetterBlockPos.from(pos));
        }
    }",0,437 457 381 334 2000 123 618 437 381 413 2001 59 618 437 381 404 2002 59 618 437 381 2003 2004 59 618 437 381 2005 2006 59 437 2000 40 413 2001 44 404 2002 44 2003 2004 44 2005 2006 41 123 467 46 2001 61 2001 59 467 46 2002 61 2002 59 467 46 2004 61 2004 59 467 46 2006 61 2006 59 621 2007 46 430 46 2008 40 648 43 2001 43 648 43 2002 43 648 43 2004 43 648 43 2009 46 388 40 2006 41 41 59 125 125 
2518,Java,"        CACTUS(Blocks.CACTUS, null) {
            @Override
            public boolean readyToHarvest(World world, BlockPos pos, IBlockState state) {
                if (Baritone.settings().replantCrops.value) {
                    return world.getBlockState(pos.down()).getBlock() instanceof BlockCactus;
                }
                return true;
            }
        };",0,2000 40 2001 46 2000 44 424 41 123 64 2002 439 324 2003 40 2004 2005 44 2006 2007 44 2008 2009 41 123 392 40 2010 46 2011 40 41 46 2012 46 2013 41 123 450 2005 46 2014 40 2007 46 2015 40 41 41 46 2016 40 41 402 2017 59 125 450 473 59 125 125 59 
2517,Java,"        SUGARCANE(Blocks.REEDS, null) {
            @Override
            public boolean readyToHarvest(World world, BlockPos pos, IBlockState state) {
                if (Baritone.settings().replantCrops.value) {
                    return world.getBlockState(pos.down()).getBlock() instanceof BlockReed;
                }
                return true;
            }
        },",0,2000 40 2001 46 2002 44 424 41 123 64 2003 439 324 2004 40 2005 2006 44 2007 2008 44 2009 2010 41 123 392 40 2011 46 2012 40 41 46 2013 46 2014 41 123 450 2006 46 2015 40 2008 46 2016 40 41 41 46 2017 40 41 402 2018 59 125 450 473 59 125 125 44 
2487,Java,"public final class Settings {

    /**
     * Allow Baritone to break blocks
     */
    public final Setting<Boolean> allowBreak = new Setting<>(true);

    /**
     * Allow Baritone to sprint
     */
    public final Setting<Boolean> allowSprint = new Setting<>(true);

    /**
     * Allow Baritone to place blocks
     */
    public final Setting<Boolean> allowPlace = new Setting<>(true);

    /**
     * Allow Baritone to move items in your inventory to your hotbar
     */
    public final Setting<Boolean> allowInventory = new Setting<>(false);

    /**
     * Disable baritone's auto-tool at runtime, but still assume that another mod will provide auto tool functionality
     * <p>
     * Specifically, path calculation will still assume that an auto tool will run at execution time, even though
     * Baritone itself will not do that.
     */
    public final Setting<Boolean> assumeExternalAutoTool = new Setting<>(false);

    /**
     * Automatically select the best available tool
     */
    public final Setting<Boolean> autoTool = new Setting<>(true);

    /**
     * It doesn't actually take twenty ticks to place a block, this cost is so high
     * because we want to generally conserve blocks which might be limited.
     * <p>
     * Decrease to make Baritone more often consider paths that would require placing blocks
     */
    public final Setting<Double> blockPlacementPenalty = new Setting<>(20D);

    /**
     * This is just a tiebreaker to make it less likely to break blocks if it can avoid it.
     * For example, fire has a break cost of 0, this makes it nonzero, so all else being equal
     * it will take an otherwise equivalent route that doesn't require it to put out fire.
     */
    public final Setting<Double> blockBreakAdditionalPenalty = new Setting<>(2D);

    /**
     * Additional penalty for hitting the space bar (ascend, pillar, or parkour) because it uses hunger
     */
    public final Setting<Double> jumpPenalty = new Setting<>(2D);

    /**
     * Walking on water uses up hunger really quick, so penalize it
     */
    public final Setting<Double> walkOnWaterOnePenalty = new Setting<>(3D);

    /**
     * Allow Baritone to fall arbitrary distances and place a water bucket beneath it.
     * Reliability: questionable.
     */
    public final Setting<Boolean> allowWaterBucketFall = new Setting<>(true);

    /**
     * Allow Baritone to assume it can walk on still water just like any other block.
     * This functionality is assumed to be provided by a separate library that might have imported Baritone.
     */
    public final Setting<Boolean> assumeWalkOnWater = new Setting<>(false);

    /**
     * If you have Fire Resistance and Jesus then I guess you could turn this on lol
     */
    public final Setting<Boolean> assumeWalkOnLava = new Setting<>(false);

    /**
     * Assume step functionality; don't jump on an Ascend.
     */
    public final Setting<Boolean> assumeStep = new Setting<>(false);

    /**
     * Assume safe walk functionality; don't sneak on a backplace traverse.
     * <p>
     * Warning: if you do something janky like sneak-backplace from an ender chest, if this is true
     * it won't sneak right click, it'll just right click, which means it'll open the chest instead of placing
     * against it. That's why this defaults to off.
     */
    public final Setting<Boolean> assumeSafeWalk = new Setting<>(false);

    /**
     * If true, parkour is allowed to make jumps when standing on blocks at the maximum height, so player feet is y=256
     * <p>
     * Defaults to false because this fails on constantiam. Please let me know if this is ever disabled. Please.
     */
    public final Setting<Boolean> allowJumpAt256 = new Setting<>(false);

    /**
     * This should be monetized it's so good
     * <p>
     * Defaults to true, but only actually takes effect if allowParkour is also true
     */
    public final Setting<Boolean> allowParkourAscend = new Setting<>(true);

    /**
     * Allow descending diagonally
     * <p>
     * Safer than allowParkour yet still slightly unsafe, can make contact with unchecked adjacent blocks, so it's unsafe in the nether.
     * <p>
     * For a generic ""take some risks"" mode I'd turn on this one, parkour, and parkour place.
     */
    public final Setting<Boolean> allowDiagonalDescend = new Setting<>(false);

    /**
     * Allow diagonal ascending
     * <p>
     * Actually pretty safe, much safer than diagonal descend tbh
     */
    public final Setting<Boolean> allowDiagonalAscend = new Setting<>(false);

    /**
     * Allow mining the block directly beneath its feet
     * <p>
     * Turn this off to force it to make more staircases and less shafts
     */
    public final Setting<Boolean> allowDownward = new Setting<>(true);

    /**
     * Blocks that Baritone is allowed to place (as throwaway, for sneak bridging, pillaring, etc.)
     */
    public final Setting<List<Item>> acceptableThrowawayItems = new Setting<>(new ArrayList<>(Arrays.asList(
            Item.getItemFromBlock(Blocks.DIRT),
            Item.getItemFromBlock(Blocks.COBBLESTONE),
            Item.getItemFromBlock(Blocks.NETHERRACK),
            Item.getItemFromBlock(Blocks.STONE)
    )));

    /**
     * Blocks that Baritone will attempt to avoid (Used in avoidance)
     */
    public final Setting<List<Block>> blocksToAvoid = new Setting<>(new ArrayList<>(
            // Leave Empty by Default
    ));

    /**
     * Blocks that Baritone is not allowed to break
     */
    public final Setting<List<Block>> blocksToDisallowBreaking = new Setting<>(new ArrayList<>(
        // Leave Empty by Default
    ));

    /**
     * blocks that baritone shouldn't break, but can if it needs to.
     */
    public final Setting<List<Block>> blocksToAvoidBreaking = new Setting<>(new ArrayList<>(Arrays.asList( // TODO can this be a HashSet or ImmutableSet?
            Blocks.CRAFTING_TABLE,
            Blocks.FURNACE,
            Blocks.LIT_FURNACE,
            Blocks.CHEST,
            Blocks.TRAPPED_CHEST,
            Blocks.STANDING_SIGN,
            Blocks.WALL_SIGN
    )));

    /**
     * this multiplies the break speed, if set above 1 it's ""encourage breaking"" instead
     */
    public final Setting<Double> avoidBreakingMultiplier = new Setting<>(.1);

    /**
     * A list of blocks to be treated as if they're air.
     * <p>
     * If a schematic asks for air at a certain position, and that position currently contains a block on this list, it will be treated as correct.
     */
    public final Setting<List<Block>> buildIgnoreBlocks = new Setting<>(new ArrayList<>(Arrays.asList(

    )));

    /**
     * A list of blocks to be treated as correct.
     * <p>
     * If a schematic asks for any block on this list at a certain position, it will be treated as correct, regardless of what it currently is.
     */
    public final Setting<List<Block>> buildSkipBlocks = new Setting<>(new ArrayList<>(Arrays.asList(

    )));

    /**
     * A mapping of blocks to blocks treated as correct in their position
     * <p>
     * If a schematic asks for a block on this mapping, all blocks on the mapped list will be accepted at that location as well
     */
    public final Setting<Map<Block, List<Block>>> buildValidSubstitutes = new Setting<>(new HashMap<>());

    /**
     * A mapping of blocks to blocks to be built instead
     * <p>
     * If a schematic asks for a block on this mapping, Baritone will place the first placeable block in the mapped list
     */
    public final Setting<Map<Block, List<Block>>> buildSubstitutes = new Setting<>(new HashMap<>());

    /**
     * A list of blocks to become air
     * <p>
     * If a schematic asks for a block on this list, only air will be accepted at that location (and nothing on buildIgnoreBlocks)
     */
    public final Setting<List<Block>> okIfAir = new Setting<>(new ArrayList<>(Arrays.asList(

    )));

    /**
     * If this is true, the builder will treat all non-air blocks as correct. It will only place new blocks.
     */
    public final Setting<Boolean> buildIgnoreExisting = new Setting<>(false);

    /**
     * If this is true, the builder will ignore directionality of certain blocks like glazed terracotta.
     */
    public final Setting<Boolean> buildIgnoreDirection = new Setting<>(false);

    /**
     * If this setting is true, Baritone will never break a block that is adjacent to an unsupported falling block.
     * <p>
     * I.E. it will never trigger cascading sand / gravel falls
     */
    public final Setting<Boolean> avoidUpdatingFallingBlocks = new Setting<>(true);

    /**
     * Enables some more advanced vine features. They're honestly just gimmicks and won't ever be needed in real
     * pathing scenarios. And they can cause Baritone to get trapped indefinitely in a strange scenario.
     * <p>
     * Almost never turn this on lol
     */
    public final Setting<Boolean> allowVines = new Setting<>(false);

    /**
     * Slab behavior is complicated, disable this for higher path reliability. Leave enabled if you have bottom slabs
     * everywhere in your base.
     */
    public final Setting<Boolean> allowWalkOnBottomSlab = new Setting<>(true);

    /**
     * You know what it is
     * <p>
     * But it's very unreliable and falls off when cornering like all the time so.
     * <p>
     * It also overshoots the landing pretty much always (making contact with the next block over), so be careful
     */
    public final Setting<Boolean> allowParkour = new Setting<>(false);

    /**
     * Actually pretty reliable.
     * <p>
     * Doesn't make it any more dangerous compared to just normal allowParkour th
     */
    public final Setting<Boolean> allowParkourPlace = new Setting<>(false);

    /**
     * For example, if you have Mining Fatigue or Haste, adjust the costs of breaking blocks accordingly.
     */
    public final Setting<Boolean> considerPotionEffects = new Setting<>(true);

    /**
     * Sprint and jump a block early on ascends wherever possible
     */
    public final Setting<Boolean> sprintAscends = new Setting<>(true);

    /**
     * If we overshoot a traverse and end up one block beyond the destination, mark it as successful anyway.
     * <p>
     * This helps with speed exceeding 20m/s
     */
    public final Setting<Boolean> overshootTraverse = new Setting<>(true);

    /**
     * When breaking blocks for a movement, wait until all falling blocks have settled before continuing
     */
    public final Setting<Boolean> pauseMiningForFallingBlocks = new Setting<>(true);

    /**
     * How many ticks between right clicks are allowed. Default in game is 4
     */
    public final Setting<Integer> rightClickSpeed = new Setting<>(4);

    /**
     * Block reach distance
     */
    public final Setting<Float> blockReachDistance = new Setting<>(4.5f);

    /**
     * How many degrees to randomize the pitch and yaw every tick. Set to 0 to disable
     */
    public final Setting<Double> randomLooking = new Setting<>(0.01d);

    /**
     * This is the big A* setting.
     * As long as your cost heuristic is an *underestimate*, it's guaranteed to find you the best path.
     * 3.5 is always an underestimate, even if you are sprinting.
     * If you're walking only (with allowSprint off) 4.6 is safe.
     * Any value below 3.5 is never worth it. It's just more computation to find the same path, guaranteed.
     * (specifically, it needs to be strictly slightly less than ActionCosts.WALK_ONE_BLOCK_COST, which is about 3.56)
     * <p>
     * Setting it at 3.57 or above with sprinting, or to 4.64 or above without sprinting, will result in
     * faster computation, at the cost of a suboptimal path. Any value above the walk / sprint cost will result
     * in it going straight at its goal, and not investigating alternatives, because the combined cost / heuristic
     * metric gets better and better with each block, instead of slightly worse.
     * <p>
     * Finding the optimal path is worth it, so it's the default.
     */
    public final Setting<Double> costHeuristic = new Setting<>(3.563);

    // a bunch of obscure internal A* settings that you probably don't want to change
    /**
     * The maximum number of times it will fetch outside loaded or cached chunks before assuming that
     * pathing has reached the end of the known area, and should therefore stop.
     */
    public final Setting<Integer> pathingMaxChunkBorderFetch = new Setting<>(50);

    /**
     * Set to 1.0 to effectively disable this feature
     *
     * @see <a href=""https://github.com/cabaletta/baritone/issues/18"">Issue #18</a>
     */
    public final Setting<Double> backtrackCostFavoringCoefficient = new Setting<>(0.5);

    /**
     * Toggle the following 4 settings
     * <p>
     * They have a noticeable performance impact, so they default off
     * <p>
     * Specifically, building up the avoidance map on the main thread before pathing starts actually takes a noticeable
     * amount of time, especially when there are a lot of mobs around, and your game jitters for like 200ms while doing so
     */
    public final Setting<Boolean> avoidance = new Setting<>(false);

    /**
     * Set to 1.0 to effectively disable this feature
     * <p>
     * Set below 1.0 to go out of your way to walk near mob spawners
     */
    public final Setting<Double> mobSpawnerAvoidanceCoefficient = new Setting<>(2.0);

    public final Setting<Integer> mobSpawnerAvoidanceRadius = new Setting<>(16);

    /**
     * Set to 1.0 to effectively disable this feature
     * <p>
     * Set below 1.0 to go out of your way to walk near mobs
     */
    public final Setting<Double> mobAvoidanceCoefficient = new Setting<>(1.5);

    public final Setting<Integer> mobAvoidanceRadius = new Setting<>(8);

    /**
     * When running a goto towards a container block (chest, ender chest, furnace, etc),
     * right click and open it once you arrive.
     */
    public final Setting<Boolean> rightClickContainerOnArrival = new Setting<>(true);

    /**
     * When running a goto towards a nether portal block, walk all the way into the portal
     * instead of stopping one block before.
     */
    public final Setting<Boolean> enterPortal = new Setting<>(true);

    /**
     * Don't repropagate cost improvements below 0.01 ticks. They're all just floating point inaccuracies,
     * and there's no point.
     */
    public final Setting<Boolean> minimumImprovementRepropagation = new Setting<>(true);

    /**
     * After calculating a path (potentially through cached chunks), artificially cut it off to just the part that is
     * entirely within currently loaded chunks. Improves path safety because cached chunks are heavily simplified.
     * <p>
     * This is much safer to leave off now, and makes pathing more efficient. More explanation in the issue.
     *
     * @see <a href=""https://github.com/cabaletta/baritone/issues/114"">Issue #114</a>
     */
    public final Setting<Boolean> cutoffAtLoadBoundary = new Setting<>(false);

    /**
     * If a movement's cost increases by more than this amount between calculation and execution (due to changes
     * in the environment / world), cancel and recalculate
     */
    public final Setting<Double> maxCostIncrease = new Setting<>(10D);

    /**
     * Stop 5 movements before anything that made the path COST_INF.
     * For example, if lava has spread across the path, don't walk right up to it then recalculate, it might
     * still be spreading lol
     */
    public final Setting<Integer> costVerificationLookahead = new Setting<>(5);

    /**
     * Static cutoff factor. 0.9 means cut off the last 10% of all paths, regardless of chunk load state
     */
    public final Setting<Double> pathCutoffFactor = new Setting<>(0.9);

    /**
     * Only apply static cutoff for paths of at least this length (in terms of number of movements)
     */
    public final Setting<Integer> pathCutoffMinimumLength = new Setting<>(30);

    /**
     * Start planning the next path once the remaining movements tick estimates sum up to less than this value
     */
    public final Setting<Integer> planningTickLookahead = new Setting<>(150);

    /**
     * Default size of the Long2ObjectOpenHashMap used in pathing
     */
    public final Setting<Integer> pathingMapDefaultSize = new Setting<>(1024);

    /**
     * Load factor coefficient for the Long2ObjectOpenHashMap used in pathing
     * <p>
     * Decrease for faster map operations, but higher memory usage
     */
    public final Setting<Float> pathingMapLoadFactor = new Setting<>(0.75f);

    /**
     * How far are you allowed to fall onto solid ground (without a water bucket)?
     * 3 won't deal any damage. But if you just want to get down the mountain quickly and you have
     * Feather Falling IV, you might set it a bit higher, like 4 or 5.
     */
    public final Setting<Integer> maxFallHeightNoWater = new Setting<>(3);

    /**
     * How far are you allowed to fall onto solid ground (with a water bucket)?
     * It's not that reliable, so I've set it below what would kill an unarmored player (23)
     */
    public final Setting<Integer> maxFallHeightBucket = new Setting<>(20);

    /**
     * Is it okay to sprint through a descend followed by a diagonal?
     * The player overshoots the landing, but not enough to fall off. And the diagonal ensures that there isn't
     * lava or anything that's !canWalkInto in that space, so it's technically safe, just a little sketchy.
     * <p>
     * Note: this is *not* related to the allowDiagonalDescend setting, that is a completely different thing.
     */
    public final Setting<Boolean> allowOvershootDiagonalDescend = new Setting<>(true);

    /**
     * If your goal is a GoalBlock in an unloaded chunk, assume it's far enough away that the Y coord
     * doesn't matter yet, and replace it with a GoalXZ to the same place before calculating a path.
     * Once a segment ends within chunk load range of the GoalBlock, it will go back to normal behavior
     * of considering the Y coord. The reasoning is that if your X and Z are 10,000 blocks away,
     * your Y coordinate's accuracy doesn't matter at all until you get much much closer.
     */
    public final Setting<Boolean> simplifyUnloadedYCoord = new Setting<>(true);

    /**
     * Whenever a block changes, repack the whole chunk that it's in
     */
    public final Setting<Boolean> repackOnAnyBlockChange = new Setting<>(true);

    /**
     * If a movement takes this many ticks more than its initial cost estimate, cancel it
     */
    public final Setting<Integer> movementTimeoutTicks = new Setting<>(100);

    /**
     * Pathing ends after this amount of time, but only if a path has been found
     * <p>
     * If no valid path (length above the minimum) has been found, pathing continues up until the failure timeout
     */
    public final Setting<Long> primaryTimeoutMS = new Setting<>(500L);

    /**
     * Pathing can never take longer than this, even if that means failing to find any path at all
     */
    public final Setting<Long> failureTimeoutMS = new Setting<>(2000L);

    /**
     * Planning ahead while executing a segment ends after this amount of time, but only if a path has been found
     * <p>
     * If no valid path (length above the minimum) has been found, pathing continues up until the failure timeout
     */
    public final Setting<Long> planAheadPrimaryTimeoutMS = new Setting<>(4000L);

    /**
     * Planning ahead while executing a segment can never take longer than this, even if that means failing to find any path at all
     */
    public final Setting<Long> planAheadFailureTimeoutMS = new Setting<>(5000L);

    /**
     * For debugging, consider nodes much much slower
     */
    public final Setting<Boolean> slowPath = new Setting<>(false);

    /**
     * Milliseconds between each node
     */
    public final Setting<Long> slowPathTimeDelayMS = new Setting<>(100L);

    /**
     * The alternative timeout number when slowPath is on
     */
    public final Setting<Long> slowPathTimeoutMS = new Setting<>(40000L);

    /**
     * The big one. Download all chunks in simplified 2-bit format and save them for better very-long-distance pathing.
     */
    public final Setting<Boolean> chunkCaching = new Setting<>(true);

    /**
     * On save, delete from RAM any cached regions that are more than 1024 blocks away from the player
     * <p>
     * Temporarily disabled
     * <p>
     * Temporarily reenabled
     *
     * @see <a href=""https://github.com/cabaletta/baritone/issues/248"">Issue #248</a>
     */
    public final Setting<Boolean> pruneRegionsFromRAM = new Setting<>(true);

    /**
     * Remember the contents of containers (chests, echests, furnaces)
     * <p>
     * Really buggy since the packet stuff is multithreaded badly thanks to brady
     */
    public final Setting<Boolean> containerMemory = new Setting<>(false);

    /**
     * Fill in blocks behind you
     */
    public final Setting<Boolean> backfill = new Setting<>(false);

    /**
     * Shows popup message in the upper right corner, similarly to when you make an advancement
     */
    public final Setting<Boolean> logAsToast = new Setting<>(false);

    /**
     * The time of how long the message in the pop-up will display
     * <p>
     * If below 1000L (1sec), it's better to disable this
     */
    public final Setting<Long> toastTimer = new Setting<>(5000L);

    /**
     * Print all the debug messages to chat
     */
    public final Setting<Boolean> chatDebug = new Setting<>(false);

    /**
     * Allow chat based control of Baritone. Most likely should be disabled when Baritone is imported for use in
     * something else
     */
    public final Setting<Boolean> chatControl = new Setting<>(true);

    /**
     * Some clients like Impact try to force chatControl to off, so here's a second setting to do it anyway
     */
    public final Setting<Boolean> chatControlAnyway = new Setting<>(false);

    /**
     * Render the path
     */
    public final Setting<Boolean> renderPath = new Setting<>(true);

    /**
     * Render the path as a line instead of a frickin thingy
     */
    public final Setting<Boolean> renderPathAsLine = new Setting<>(false);

    /**
     * Render the goal
     */
    public final Setting<Boolean> renderGoal = new Setting<>(true);

    /**
     * Render the goal as a sick animated thingy instead of just a box
     * (also controls animation of GoalXZ if {@link #renderGoalXZBeacon} is enabled)
     */
    public final Setting<Boolean> renderGoalAnimated = new Setting<>(true);

    /**
     * Render selection boxes
     */
    public final Setting<Boolean> renderSelectionBoxes = new Setting<>(true);

    /**
     * Ignore depth when rendering the goal
     */
    public final Setting<Boolean> renderGoalIgnoreDepth = new Setting<>(true);

    /**
     * Renders X/Z type Goals with the vanilla beacon beam effect. Combining this with
     * {@link #renderGoalIgnoreDepth} will cause strange render clipping.
     */
    public final Setting<Boolean> renderGoalXZBeacon = new Setting<>(false);

    /**
     * Ignore depth when rendering the selection boxes (to break, to place, to walk into)
     */
    public final Setting<Boolean> renderSelectionBoxesIgnoreDepth = new Setting<>(true);

    /**
     * Ignore depth when rendering the path
     */
    public final Setting<Boolean> renderPathIgnoreDepth = new Setting<>(true);

    /**
     * Line width of the path when rendered, in pixels
     */
    public final Setting<Float> pathRenderLineWidthPixels = new Setting<>(5F);

    /**
     * Line width of the goal when rendered, in pixels
     */
    public final Setting<Float> goalRenderLineWidthPixels = new Setting<>(3F);

    /**
     * Start fading out the path at 20 movements ahead, and stop rendering it entirely 30 movements ahead.
     * Improves FPS.
     */
    public final Setting<Boolean> fadePath = new Setting<>(false);

    /**
     * Move without having to force the client-sided rotations
     */
    public final Setting<Boolean> freeLook = new Setting<>(true);

    /**
     * Will cause some minor behavioral differences to ensure that Baritone works on anticheats.
     * <p>
     * At the moment this will silently set the player's rotations when using freeLook so you're not sprinting in
     * directions other than forward, which is picken up by more ""advanced"" anticheats like AAC, but not NCP.
     */
    public final Setting<Boolean> antiCheatCompatibility = new Setting<>(true);

    /**
     * Exclusively use cached chunks for pathing
     * <p>
     * Never turn this on
     */
    public final Setting<Boolean> pathThroughCachedOnly = new Setting<>(false);

    /**
     * Continue sprinting while in water
     */
    public final Setting<Boolean> sprintInWater = new Setting<>(true);

    /**
     * When GetToBlockProcess or MineProcess fails to calculate a path, instead of just giving up, mark the closest instance
     * of that block as ""unreachable"" and go towards the next closest. GetToBlock expands this search to the whole ""vein""; MineProcess does not.
     * This is because MineProcess finds individual impossible blocks (like one block in a vein that has gravel on top then lava, so it can't break)
     * Whereas GetToBlock should blacklist the whole ""vein"" if it can't get to any of them.
     */
    public final Setting<Boolean> blacklistClosestOnFailure = new Setting<>(true);

    /**
     * 😎 Render cached chunks as semitransparent. Doesn't work with OptiFine 😭 Rarely randomly crashes, see <a href=""https://github.com/cabaletta/baritone/issues/327"">this issue</a>.
     * <p>
     * Can be very useful on servers with low render distance. After enabling, you may need to reload the world in order for it to have an effect
     * (e.g. disconnect and reconnect, enter then exit the nether, die and respawn, etc). This may literally kill your FPS and CPU because
     * every chunk gets recompiled twice as much as normal, since the cached version comes into range, then the normal one comes from the server for real.
     * <p>
     * Note that flowing water is cached as AVOID, which is rendered as lava. As you get closer, you may therefore see lava falls being replaced with water falls.
     * <p>
     * SOLID is rendered as stone in the overworld, netherrack in the nether, and end stone in the end
     */
    public final Setting<Boolean> renderCachedChunks = new Setting<>(false);

    /**
     * 0.0f = not visible, fully transparent (instead of setting this to 0, turn off renderCachedChunks)
     * 1.0f = fully opaque
     */
    public final Setting<Float> cachedChunksOpacity = new Setting<>(0.5f);

    /**
     * Whether or not to allow you to run Baritone commands with the prefix
     */
    public final Setting<Boolean> prefixControl = new Setting<>(true);

    /**
     * The command prefix for chat control
     */
    public final Setting<String> prefix = new Setting<>(""#"");

    /**
     * Use a short Baritone prefix [B] instead of [Baritone] when logging to chat
     */
    public final Setting<Boolean> shortBaritonePrefix = new Setting<>(false);

    /**
     * Echo commands to chat when they are run
     */
    public final Setting<Boolean> echoCommands = new Setting<>(true);

    /**
     * Censor coordinates in goals and block positions
     */
    public final Setting<Boolean> censorCoordinates = new Setting<>(false);

    /**
     * Censor arguments to ran commands, to hide, for example, coordinates to #goal
     */
    public final Setting<Boolean> censorRanCommands = new Setting<>(false);

    /**
     * Stop using tools just before they are going to break.
     */
    public final Setting<Boolean> itemSaver = new Setting<>(false);

    /**
     * Durability to leave on the tool when using itemSaver
     */
    public final Setting<Integer> itemSaverThreshold = new Setting<>(10);

    /**
     * Always prefer silk touch tools over regular tools. This will not sacrifice speed, but it will always prefer silk
     * touch tools over other tools of the same speed. This includes always choosing ANY silk touch tool over your hand.
     */
    public final Setting<Boolean> preferSilkTouch = new Setting<>(false);

    /**
     * Don't stop walking forward when you need to break blocks in your way
     */
    public final Setting<Boolean> walkWhileBreaking = new Setting<>(true);

    /**
     * When a new segment is calculated that doesn't overlap with the current one, but simply begins where the current segment ends,
     * splice it on and make a longer combined path. If this setting is off, any planned segment will not be spliced and will instead
     * be the ""next path"" in PathingBehavior, and will only start after this one ends. Turning this off hurts planning ahead,
     * because the next segment will exist even if it's very short.
     *
     * @see #planningTickLookahead
     */
    public final Setting<Boolean> splicePath = new Setting<>(true);

    /**
     * If we are more than 300 movements into the current path, discard the oldest segments, as they are no longer useful
     */
    public final Setting<Integer> maxPathHistoryLength = new Setting<>(300);

    /**
     * If the current path is too long, cut off this many movements from the beginning.
     */
    public final Setting<Integer> pathHistoryCutoffAmount = new Setting<>(50);

    /**
     * Rescan for the goal once every 5 ticks.
     * Set to 0 to disable.
     */
    public final Setting<Integer> mineGoalUpdateInterval = new Setting<>(5);

    /**
     * After finding this many instances of the target block in the cache, it will stop expanding outward the chunk search.
     */
    public final Setting<Integer> maxCachedWorldScanCount = new Setting<>(10);

    /**
     * Sets the minimum y level whilst mining - set to 0 to turn off.
     */
    public final Setting<Integer> minYLevelWhileMining = new Setting<>(0);

    /**
     * This will only allow baritone to mine exposed ores, can be used to stop ore obfuscators on servers that use them.
     */
    public final Setting<Boolean> allowOnlyExposedOres = new Setting<>(false);

    /**
     * When allowOnlyExposedOres is enabled this is the distance around to search.
     * <p>
     * It is recommended to keep this value low, as it dramatically increases calculation times.
     */
    public final Setting<Integer> allowOnlyExposedOresDistance = new Setting<>(1);

    /**
     * When GetToBlock or non-legit Mine doesn't know any locations for the desired block, explore randomly instead of giving up.
     */
    public final Setting<Boolean> exploreForBlocks = new Setting<>(true);

    /**
     * While exploring the world, offset the closest unloaded chunk by this much in both axes.
     * <p>
     * This can result in more efficient loading, if you set this to the render distance.
     */
    public final Setting<Integer> worldExploringChunkOffset = new Setting<>(0);

    /**
     * Take the 10 closest chunks, even if they aren't strictly tied for distance metric from origin.
     */
    public final Setting<Integer> exploreChunkSetMinimumSize = new Setting<>(10);

    /**
     * Attempt to maintain Y coordinate while exploring
     * <p>
     * -1 to disable
     */
    public final Setting<Integer> exploreMaintainY = new Setting<>(64);

    /**
     * Replant normal Crops while farming and leave cactus and sugarcane to regrow
     */
    public final Setting<Boolean> replantCrops = new Setting<>(true);

    /**
     * Replant nether wart while farming. This setting only has an effect when replantCrops is also enabled
     */
    public final Setting<Boolean> replantNetherWart = new Setting<>(false);

    /**
     * When the cache scan gives less blocks than the maximum threshold (but still above zero), scan the main world too.
     * <p>
     * Only if you have a beefy CPU and automatically mine blocks that are in cache
     */
    public final Setting<Boolean> extendCacheOnThreshold = new Setting<>(false);

    /**
     * Don't consider the next layer in builder until the current one is done
     */
    public final Setting<Boolean> buildInLayers = new Setting<>(false);

    /**
     * false = build from bottom to top
     * <p>
     * true = build from top to bottom
     */
    public final Setting<Boolean> layerOrder = new Setting<>(false);

    /**
     * How high should the individual layers be?
     */
    public final Setting<Integer> layerHeight = new Setting<>(1);

    /**
     * Start building the schematic at a specific layer.
     * Can help on larger builds when schematic wants to break things its already built
     */
    public final Setting<Integer> startAtLayer = new Setting<>(0);

    /**
     * If a layer is unable to be constructed, just skip it.
     */
    public final Setting<Boolean> skipFailedLayers = new Setting<>(false);

    /**
     * Only build the selected part of schematics
     */
     public final Setting<Boolean> buildOnlySelection = new Setting<>(false);

    /**
     * How far to move before repeating the build. 0 to disable repeating on a certain axis, 0,0,0 to disable entirely
     */
    public final Setting<Vec3i> buildRepeat = new Setting<>(new Vec3i(0, 0, 0));

    /**
     * How many times to buildrepeat. -1 for infinite.
     */
    public final Setting<Integer> buildRepeatCount = new Setting<>(-1);

    /**
     * Don't notify schematics that they are moved.
     * e.g. replacing will replace the same spots for every repetition
     * Mainly for backward compatibility.
     */
    public final Setting<Boolean> buildRepeatSneaky = new Setting<>(true);

    /**
     * Allow standing above a block while mining it, in BuilderProcess
     * <p>
     * Experimental
     */
    public final Setting<Boolean> breakFromAbove = new Setting<>(false);

    /**
     * As well as breaking from above, set a goal to up and to the side of all blocks to break.
     * <p>
     * Never turn this on without also turning on breakFromAbove.
     */
    public final Setting<Boolean> goalBreakFromAbove = new Setting<>(false);

    /**
     * Build in map art mode, which makes baritone only care about the top block in each column
     */
    public final Setting<Boolean> mapArtMode = new Setting<>(false);

    /**
     * Override builder's behavior to not attempt to correct blocks that are currently water
     */
    public final Setting<Boolean> okIfWater = new Setting<>(false);

    /**
     * The set of incorrect blocks can never grow beyond this size
     */
    public final Setting<Integer> incorrectSize = new Setting<>(100);

    /**
     * Multiply the cost of breaking a block that's correct in the builder's schematic by this coefficient
     */
    public final Setting<Double> breakCorrectBlockPenaltyMultiplier = new Setting<>(10d);

    /**
     * When this setting is true, build a schematic with the highest X coordinate being the origin, instead of the lowest
     */
    public final Setting<Boolean> schematicOrientationX = new Setting<>(false);

    /**
     * When this setting is true, build a schematic with the highest Y coordinate being the origin, instead of the lowest
     */
    public final Setting<Boolean> schematicOrientationY = new Setting<>(false);

    /**
     * When this setting is true, build a schematic with the highest Z coordinate being the origin, instead of the lowest
     */
    public final Setting<Boolean> schematicOrientationZ = new Setting<>(false);

    /**
     * The fallback used by the build command when no extension is specified. This may be useful if schematics of a
     * particular format are used often, and the user does not wish to have to specify the extension with every usage.
     */
    public final Setting<String> schematicFallbackExtension = new Setting<>(""schematic"");

    /**
     * Distance to scan every tick for updates. Expanding this beyond player reach distance (i.e. setting it to 6 or above)
     * is only necessary in very large schematics where rescanning the whole thing is costly.
     */
    public final Setting<Integer> builderTickScanRadius = new Setting<>(5);

    /**
     * While mining, should it also consider dropped items of the correct type as a pathing destination (as well as ore blocks)?
     */
    public final Setting<Boolean> mineScanDroppedItems = new Setting<>(true);

    /**
     * While mining, wait this number of milliseconds after mining an ore to see if it will drop an item
     * instead of immediately going onto the next one
     * <p>
     * Thanks Louca
     */
    public final Setting<Long> mineDropLoiterDurationMSThanksLouca = new Setting<>(250L);

    /**
     * Trim incorrect positions too far away, helps performance but hurts reliability in very large schematics
     */
    public final Setting<Boolean> distanceTrim = new Setting<>(true);

    /**
     * Cancel the current path if the goal has changed, and the path originally ended in the goal but doesn't anymore.
     * <p>
     * Currently only runs when either MineBehavior or FollowBehavior is active.
     * <p>
     * For example, if Baritone is doing ""mine iron_ore"", the instant it breaks the ore (and it becomes air), that location
     * is no longer a goal. This means that if this setting is true, it will stop there. If this setting were off, it would
     * continue with its path, and walk into that location. The tradeoff is if this setting is true, it mines ores much faster
     * since it doesn't waste any time getting into locations that no longer contain ores, but on the other hand, it misses
     * some drops, and continues on without ever picking them up.
     * <p>
     * Also on cosmic prisons this should be set to true since you don't actually mine the ore it just gets replaced with stone.
     */
    public final Setting<Boolean> cancelOnGoalInvalidation = new Setting<>(true);

    /**
     * The ""axis"" command (aka GoalAxis) will go to a axis, or diagonal axis, at this Y level.
     */
    public final Setting<Integer> axisHeight = new Setting<>(120);

    /**
     * Disconnect from the server upon arriving at your goal
     */
    public final Setting<Boolean> disconnectOnArrival = new Setting<>(false);

    /**
     * Disallow MineBehavior from using X-Ray to see where the ores are. Turn this option on to force it to mine ""legit""
     * where it will only mine an ore once it can actually see it, so it won't do or know anything that a normal player
     * couldn't. If you don't want it to look like you're X-Raying, turn this on
     * This will always explore, regardless of exploreForBlocks
     */
    public final Setting<Boolean> legitMine = new Setting<>(false);

    /**
     * What Y level to go to for legit strip mining
     */
    public final Setting<Integer> legitMineYLevel = new Setting<>(11);

    /**
     * Magically see ores that are separated diagonally from existing ores. Basically like mining around the ores that it finds
     * in case there's one there touching it diagonally, except it checks it un-legit-ly without having the mine blocks to see it.
     * You can decide whether this looks plausible or not.
     * <p>
     * This is disabled because it results in some weird behavior. For example, it can """"""see"""""" the top block of a vein of iron_ore
     * through a lava lake. This isn't an issue normally since it won't consider anything touching lava, so it just ignores it.
     * However, this setting expands that and allows it to see the entire vein so it'll mine under the lava lake to get the iron that
     * it can reach without mining blocks adjacent to lava. This really defeats the purpose of legitMine since a player could never
     * do that lol, so thats one reason why its disabled
     */
    public final Setting<Boolean> legitMineIncludeDiagonals = new Setting<>(false);

    /**
     * When mining block of a certain type, try to mine two at once instead of one.
     * If the block above is also a goal block, set GoalBlock instead of GoalTwoBlocks
     * If the block below is also a goal block, set GoalBlock to the position one down instead of GoalTwoBlocks
     */
    public final Setting<Boolean> forceInternalMining = new Setting<>(true);

    /**
     * Modification to the previous setting, only has effect if forceInternalMining is true
     * If true, only apply the previous setting if the block adjacent to the goal isn't air.
     */
    public final Setting<Boolean> internalMiningAirException = new Setting<>(true);

    /**
     * The actual GoalNear is set this distance away from the entity you're following
     * <p>
     * For example, set followOffsetDistance to 5 and followRadius to 0 to always stay precisely 5 blocks north of your follow target.
     */
    public final Setting<Double> followOffsetDistance = new Setting<>(0D);

    /**
     * The actual GoalNear is set in this direction from the entity you're following. This value is in degrees.
     */
    public final Setting<Float> followOffsetDirection = new Setting<>(0F);

    /**
     * The radius (for the GoalNear) of how close to your target position you actually have to be
     */
    public final Setting<Integer> followRadius = new Setting<>(3);

    /**
     * Turn this on if your exploration filter is enormous, you don't want it to check if it's done,
     * and you are just fine with it just hanging on completion
     */
    public final Setting<Boolean> disableCompletionCheck = new Setting<>(false);

    /**
     * Cached chunks (regardless of if they're in RAM or saved to disk) expire and are deleted after this number of seconds
     * -1 to disable
     * <p>
     * I would highly suggest leaving this setting disabled (-1).
     * <p>
     * The only valid reason I can think of enable this setting is if you are extremely low on disk space and you play on multiplayer,
     * and can't take (average) 300kb saved for every 512x512 area. (note that more complicated terrain is less compressible and will take more space)
     * <p>
     * However, simply discarding old chunks because they are old is inadvisable. Baritone is extremely good at correcting
     * itself and its paths as it learns new information, as new chunks load. There is no scenario in which having an
     * incorrect cache can cause Baritone to get stuck, take damage, or perform any action it wouldn't otherwise, everything
     * is rechecked once the real chunk is in range.
     * <p>
     * Having a robust cache greatly improves long distance pathfinding, as it's able to go around large scale obstacles
     * before they're in render distance. In fact, when the chunkCaching setting is disabled and Baritone starts anew
     * every time, or when you enter a completely new and very complicated area, it backtracks far more often because it
     * has to build up that cache from scratch. But after it's gone through an area just once, the next time will have zero
     * backtracking, since the entire area is now known and cached.
     */
    public final Setting<Long> cachedChunksExpirySeconds = new Setting<>(-1L);

    /**
     * The function that is called when Baritone will log to chat. This function can be added to
     * via {@link Consumer#andThen(Consumer)} or it can completely be overriden via setting
     * {@link Setting#value};
     */
    public final Setting<Consumer<ITextComponent>> logger = new Setting<>(Minecraft.getMinecraft().ingameGUI.getChatGUI()::printChatMessage);

    /**
     * The function that is called when Baritone will send a desktop notification. This function can be added to
     * via {@link Consumer#andThen(Consumer)} or it can completely be overriden via setting
     * {@link Setting#value};
     */
    public final Setting<BiConsumer<String, Boolean>> notifier = new Setting<>(NotificationHelper::notify);

    /**
     * The function that is called when Baritone will show a toast. This function can be added to
     * via {@link Consumer#andThen(Consumer)} or it can completely be overriden via setting
     * {@link Setting#value};
     */
    public final Setting<BiConsumer<ITextComponent, ITextComponent>> toaster = new Setting<>(BaritoneToast::addOrUpdate);

    /**
     * The size of the box that is rendered when the current goal is a GoalYLevel
     */
    public final Setting<Double> yLevelBoxSize = new Setting<>(15D);

    /**
     * The color of the current path
     */
    public final Setting<Color> colorCurrentPath = new Setting<>(Color.RED);

    /**
     * The color of the next path
     */
    public final Setting<Color> colorNextPath = new Setting<>(Color.MAGENTA);

    /**
     * The color of the blocks to break
     */
    public final Setting<Color> colorBlocksToBreak = new Setting<>(Color.RED);

    /**
     * The color of the blocks to place
     */
    public final Setting<Color> colorBlocksToPlace = new Setting<>(Color.GREEN);

    /**
     * The color of the blocks to walk into
     */
    public final Setting<Color> colorBlocksToWalkInto = new Setting<>(Color.MAGENTA);

    /**
     * The color of the best path so far
     */
    public final Setting<Color> colorBestPathSoFar = new Setting<>(Color.BLUE);

    /**
     * The color of the path to the most recent considered node
     */
    public final Setting<Color> colorMostRecentConsidered = new Setting<>(Color.CYAN);

    /**
     * The color of the goal box
     */
    public final Setting<Color> colorGoalBox = new Setting<>(Color.GREEN);

    /**
     * The color of the goal box when it's inverted
     */
    public final Setting<Color> colorInvertedGoalBox = new Setting<>(Color.RED);

    /**
     * The color of all selections
     */
    public final Setting<Color> colorSelection = new Setting<>(Color.CYAN);

    /**
     * The color of the selection pos 1
     */
    public final Setting<Color> colorSelectionPos1 = new Setting<>(Color.BLACK);

    /**
     * The color of the selection pos 2
     */
    public final Setting<Color> colorSelectionPos2 = new Setting<>(Color.ORANGE);

    /**
     * The opacity of the selection. 0 is completely transparent, 1 is completely opaque
     */
    public final Setting<Float> selectionOpacity = new Setting<>(.5f);

    /**
     * Line width of the goal when rendered, in pixels
     */
    public final Setting<Float> selectionLineWidth = new Setting<>(2F);

    /**
     * Render selections
     */
    public final Setting<Boolean> renderSelection = new Setting<>(true);

    /**
     * Ignore depth when rendering selections
     */
    public final Setting<Boolean> renderSelectionIgnoreDepth = new Setting<>(true);

    /**
     * Render selection corners
     */
    public final Setting<Boolean> renderSelectionCorners = new Setting<>(true);

    /**
     * Use sword to mine.
     */
    public final Setting<Boolean> useSwordToMine = new Setting<>(true);

    /**
     * Desktop notifications
     */
    public final Setting<Boolean> desktopNotifications = new Setting<>(false);

    /**
     * Desktop notification on path complete
     */
    public final Setting<Boolean> notificationOnPathComplete = new Setting<>(true);

    /**
     * Desktop notification on farm fail
     */
    public final Setting<Boolean> notificationOnFarmFail = new Setting<>(true);

    /**
     * Desktop notification on build finished
     */
    public final Setting<Boolean> notificationOnBuildFinished = new Setting<>(true);

    /**
     * Desktop notification on explore finished
     */
    public final Setting<Boolean> notificationOnExploreFinished = new Setting<>(true);

    /**
     * Desktop notification on mine fail
     */
    public final Setting<Boolean> notificationOnMineFail = new Setting<>(true);

    /**
     * A map of lowercase setting field names to their respective setting
     */
    public final Map<String, Setting<?>> byLowerName;

    /**
     * A list of all settings
     */
    public final List<Setting<?>> allSettings;

    public final Map<Setting<?>, Type> settingTypes;

    public final class Setting<T> {

        public T value;
        public final T defaultValue;
        private String name;

        @SuppressWarnings(""unchecked"")
        private Setting(T value) {
            if (value == null) {
                throw new IllegalArgumentException(""Cannot determine value type class from null"");
            }
            this.value = value;
            this.defaultValue = value;
        }

        /**
         * Deprecated! Please use .value directly instead
         *
         * @return the current setting value
         */
        @Deprecated
        public final T get() {
            return value;
        }

        public final String getName() {
            return name;
        }

        public Class<T> getValueClass() {
            // noinspection unchecked
            return (Class<T>) TypeUtils.resolveBaseClass(getType());
        }

        @Override
        public String toString() {
            return SettingsUtil.settingToString(this);
        }

        /**
         * Reset this setting to its default value
         */
        public void reset() {
            value = defaultValue;
        }

        public final Type getType() {
            return settingTypes.get(this);
        }
    }

    // here be dragons

    Settings() {
        Field[] temp = getClass().getFields();

        Map<String, Setting<?>> tmpByName = new HashMap<>();
        List<Setting<?>> tmpAll = new ArrayList<>();
        Map<Setting<?>, Type> tmpSettingTypes = new HashMap<>();

        try {
            for (Field field : temp) {
                if (field.getType().equals(Setting.class)) {
                    Setting<?> setting = (Setting<?>) field.get(this);
                    String name = field.getName();
                    setting.name = name;
                    name = name.toLowerCase();
                    if (tmpByName.containsKey(name)) {
                        throw new IllegalStateException(""Duplicate setting name"");
                    }
                    tmpByName.put(name, setting);
                    tmpAll.add(setting);
                    tmpSettingTypes.put(setting, ((ParameterizedType) field.getGenericType()).getActualTypeArguments()[0]);
                }
            }
        } catch (IllegalAccessException e) {
            throw new IllegalStateException(e);
        }
        byLowerName = Collections.unmodifiableMap(tmpByName);
        allSettings = Collections.unmodifiableList(tmpAll);
        settingTypes = Collections.unmodifiableMap(tmpSettingTypes);
    }

    @SuppressWarnings(""unchecked"")
    public <T> List<Setting<T>> getAllValuesByType(Class<T> cla$$) {
        List<Setting<T>> result = new ArrayList<>();
        for (Setting<?> setting : allSettings) {
            if (setting.getValueClass().equals(cla$$)) {
                result.add((Setting<T>) setting);
            }
        }
        return result;
    }
}",0,439 381 334 2000 123 618 439 381 2001 60 2002 62 2003 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2004 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2005 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2006 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2007 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2008 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2009 62 2010 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2009 62 2011 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2009 62 2012 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2009 62 2013 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2002 62 2014 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2015 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2016 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2017 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2018 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2019 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2020 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2021 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2022 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2023 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2024 60 2025 641 2026 61 418 2001 60 62 40 418 2027 60 62 40 2028 46 2029 40 2025 46 2030 40 2031 46 2032 41 44 2025 46 2030 40 2031 46 2033 41 44 2025 46 2030 40 2031 46 2034 41 44 2025 46 2030 40 2031 46 2035 41 41 41 41 59 618 439 381 2001 60 2024 60 2036 641 2037 61 418 2001 60 62 40 418 2027 60 62 40 621 41 41 59 618 439 381 2001 60 2024 60 2036 641 2038 61 418 2001 60 62 40 418 2027 60 62 40 621 41 41 59 618 439 381 2001 60 2024 60 2036 641 2039 61 418 2001 60 62 40 418 2027 60 62 40 2028 46 2029 40 621 2031 46 2040 44 2031 46 2041 44 2031 46 2042 44 2031 46 2043 44 2031 46 2044 44 2031 46 2045 44 2031 46 2046 41 41 41 59 618 439 381 2001 60 2009 62 2047 61 418 2001 60 62 40 1499 41 59 618 439 381 2001 60 2024 60 2036 641 2048 61 418 2001 60 62 40 418 2027 60 62 40 2028 46 2029 40 41 41 41 59 618 439 381 2001 60 2024 60 2036 641 2049 61 418 2001 60 62 40 418 2027 60 62 40 2028 46 2029 40 41 41 41 59 618 439 381 2001 60 2050 60 2036 44 2024 60 2036 644 2051 61 418 2001 60 62 40 418 2052 60 62 40 41 41 59 618 439 381 2001 60 2050 60 2036 44 2024 60 2036 644 2053 61 418 2001 60 62 40 418 2052 60 62 40 41 41 59 618 439 381 2001 60 2024 60 2036 641 2054 61 418 2001 60 62 40 418 2027 60 62 40 2028 46 2029 40 41 41 41 59 618 439 381 2001 60 2002 62 2055 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2056 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2057 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2058 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2059 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2060 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2061 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2062 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2063 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2064 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2065 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2066 62 2067 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2068 62 2069 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2009 62 2070 61 418 2001 60 62 40 1498 41 59 618 439 381 2001 60 2009 62 2071 61 418 2001 60 62 40 1502 41 59 621 618 439 381 2001 60 2066 62 2072 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2009 62 2073 61 418 2001 60 62 40 1499 41 59 618 439 381 2001 60 2002 62 2074 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2009 62 2075 61 418 2001 60 62 40 1502 41 59 439 381 2001 60 2066 62 2076 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2009 62 2077 61 418 2001 60 62 40 1502 41 59 439 381 2001 60 2066 62 2078 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2002 62 2079 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2080 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2081 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2082 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2009 62 2083 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2066 62 2084 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2009 62 2085 61 418 2001 60 62 40 1499 41 59 618 439 381 2001 60 2066 62 2086 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2066 62 2087 61 418 2001 60 62 40 1504 41 59 618 439 381 2001 60 2066 62 2088 61 418 2001 60 62 40 1505 41 59 618 439 381 2001 60 2068 62 2089 61 418 2001 60 62 40 1499 41 59 618 439 381 2001 60 2066 62 2090 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2066 62 2091 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2002 62 2092 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2093 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2094 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2066 62 2095 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2096 62 2097 61 418 2001 60 62 40 1504 41 59 618 439 381 2001 60 2096 62 2098 61 418 2001 60 62 40 1505 41 59 618 439 381 2001 60 2096 62 2099 61 418 2001 60 62 40 1505 41 59 618 439 381 2001 60 2096 62 2100 61 418 2001 60 62 40 1505 41 59 618 439 381 2001 60 2002 62 2101 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2096 62 2102 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2096 62 2103 61 418 2001 60 62 40 1506 41 59 618 439 381 2001 60 2002 62 2104 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2105 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2106 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2107 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2108 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2096 62 2109 61 418 2001 60 62 40 1505 41 59 618 439 381 2001 60 2002 62 2110 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2111 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2112 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2113 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2114 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2115 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2116 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2117 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2118 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2119 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2120 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2121 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2068 62 2122 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2068 62 2123 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2002 62 2124 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2125 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2126 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2127 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2128 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2129 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2130 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2068 62 2131 61 418 2001 60 62 40 1499 41 59 618 439 381 2001 60 2002 62 2132 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2133 62 2134 61 418 2001 60 62 40 648 41 59 618 439 381 2001 60 2002 62 2135 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2136 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2137 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2138 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2139 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2066 62 2140 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2002 62 2141 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2142 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2143 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2066 62 2144 61 418 2001 60 62 40 1504 41 59 618 439 381 2001 60 2066 62 2145 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2066 62 2146 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2066 62 2147 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2066 62 2148 61 418 2001 60 62 40 1500 41 59 618 439 381 2001 60 2002 62 2149 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2066 62 2150 61 418 2001 60 62 40 1501 41 59 618 439 381 2001 60 2002 62 2151 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2066 62 2152 61 418 2001 60 62 40 1500 41 59 618 439 381 2001 60 2066 62 2153 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2066 62 2154 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2002 62 2155 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2156 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2157 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2158 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2159 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2066 62 2160 61 418 2001 60 62 40 1501 41 59 618 439 381 2001 60 2066 62 2161 61 418 2001 60 62 40 1500 41 59 618 439 381 2001 60 2002 62 2162 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2163 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2164 62 2165 61 418 2001 60 62 40 418 2164 40 1500 44 1500 44 1500 41 41 59 618 439 381 2001 60 2066 62 2166 61 418 2001 60 62 40 45 1501 41 59 618 439 381 2001 60 2002 62 2167 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2168 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2169 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2170 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2171 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2066 62 2172 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2009 62 2173 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2002 62 2174 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2175 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2176 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2133 62 2177 61 418 2001 60 62 40 648 41 59 618 439 381 2001 60 2066 62 2178 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2002 62 2179 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2096 62 2180 61 418 2001 60 62 40 1504 41 59 618 439 381 2001 60 2002 62 2181 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2182 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2066 62 2183 61 418 2001 60 62 40 1504 41 59 618 439 381 2001 60 2002 62 2184 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2185 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2066 62 2186 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2002 62 2187 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2188 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2189 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2009 62 2190 61 418 2001 60 62 40 1500 41 59 618 439 381 2001 60 2068 62 2191 61 418 2001 60 62 40 1500 41 59 618 439 381 2001 60 2066 62 2192 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2002 62 2193 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2096 62 2194 61 418 2001 60 62 40 45 1501 41 59 618 439 381 2001 60 2195 60 2196 641 2197 61 418 2001 60 62 40 2198 46 2199 40 41 46 2200 46 2201 40 41 58 58 2202 41 59 618 439 381 2001 60 2203 60 2133 44 2002 641 2204 61 418 2001 60 62 40 2205 58 58 2206 41 59 618 439 381 2001 60 2203 60 2196 44 2196 641 2207 61 418 2001 60 62 40 2208 58 58 2209 41 59 618 439 381 2001 60 2009 62 2210 61 418 2001 60 62 40 1503 41 59 618 439 381 2001 60 2211 62 2212 61 418 2001 60 62 40 2211 46 2213 41 59 618 439 381 2001 60 2211 62 2214 61 418 2001 60 62 40 2211 46 2215 41 59 618 439 381 2001 60 2211 62 2216 61 418 2001 60 62 40 2211 46 2213 41 59 618 439 381 2001 60 2211 62 2217 61 418 2001 60 62 40 2211 46 2218 41 59 618 439 381 2001 60 2211 62 2219 61 418 2001 60 62 40 2211 46 2215 41 59 618 439 381 2001 60 2211 62 2220 61 418 2001 60 62 40 2211 46 2221 41 59 618 439 381 2001 60 2211 62 2222 61 418 2001 60 62 40 2211 46 2223 41 59 618 439 381 2001 60 2211 62 2224 61 418 2001 60 62 40 2211 46 2218 41 59 618 439 381 2001 60 2211 62 2225 61 418 2001 60 62 40 2211 46 2213 41 59 618 439 381 2001 60 2211 62 2226 61 418 2001 60 62 40 2211 46 2223 41 59 618 439 381 2001 60 2211 62 2227 61 418 2001 60 62 40 2211 46 2228 41 59 618 439 381 2001 60 2211 62 2229 61 418 2001 60 62 40 2211 46 2230 41 59 618 439 381 2001 60 2068 62 2231 61 418 2001 60 62 40 1499 41 59 618 439 381 2001 60 2068 62 2232 61 418 2001 60 62 40 1502 41 59 618 439 381 2001 60 2002 62 2233 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2234 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2235 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2236 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2237 61 418 2001 60 62 40 380 41 59 618 439 381 2001 60 2002 62 2238 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2239 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2240 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2241 61 418 2001 60 62 40 473 41 59 618 439 381 2001 60 2002 62 2242 61 418 2001 60 62 40 473 41 59 618 439 381 2050 60 2133 44 2001 60 63 641 2243 59 618 439 381 2024 60 2001 60 63 641 2244 59 439 381 2050 60 2001 60 63 62 44 2245 62 2246 59 439 381 334 2001 60 2247 62 123 439 2247 2248 59 439 381 2247 2249 59 437 2133 2250 59 64 2251 40 648 41 437 2001 40 2247 2248 41 123 392 40 2248 614 424 41 123 469 418 2252 40 648 41 59 125 467 46 2248 61 2248 59 467 46 2249 61 2248 59 125 618 64 2253 439 381 2247 2254 40 41 123 450 2248 59 125 439 381 2133 2255 40 41 123 450 2250 59 125 439 2256 60 2247 62 2257 40 41 123 621 450 40 2256 60 2247 62 41 2258 46 2259 40 2260 40 41 41 59 125 64 2261 439 2133 2262 40 41 123 450 2263 46 2264 40 467 41 59 125 618 439 492 2265 40 41 123 2248 61 2249 59 125 439 381 2245 2266 40 41 123 450 2246 46 2254 40 467 41 59 125 125 621 2000 40 41 123 2267 91 93 2268 61 2269 40 41 46 2270 40 41 59 2050 60 2133 44 2001 60 63 641 2271 61 418 2052 60 62 40 41 59 2024 60 2001 60 63 641 2272 61 418 2027 60 62 40 41 59 2050 60 2001 60 63 62 44 2245 62 2273 61 418 2052 60 62 40 41 59 474 123 385 40 2267 2274 58 2268 41 123 392 40 2274 46 2275 40 41 46 2276 40 2001 46 334 41 41 123 2001 60 63 62 2277 61 40 2001 60 63 62 41 2274 46 2278 40 467 41 59 2133 2279 61 2274 46 2280 40 41 59 2277 46 2279 61 2279 59 2279 61 2279 46 2281 40 41 59 392 40 2271 46 2282 40 2279 41 41 123 469 418 2283 40 648 41 59 125 2271 46 2284 40 2279 44 2277 41 59 2272 46 2285 40 2277 41 59 2273 46 2284 40 2277 44 40 40 2286 41 2274 46 2287 40 41 41 46 2288 40 41 91 1500 93 41 59 125 125 125 329 40 2289 2290 41 123 469 418 2291 40 2290 41 59 125 2243 61 2292 46 2293 40 2271 41 59 2244 61 2292 46 2294 40 2272 41 59 2246 61 2292 46 2293 40 2273 41 59 125 64 2295 40 648 41 439 60 2247 62 2024 60 2001 60 2247 641 2296 40 2297 60 2247 62 2298 36 36 41 123 2024 60 2001 60 2247 641 2299 61 418 2027 60 62 40 41 59 385 40 2001 60 63 62 2300 58 2244 41 123 392 40 2300 46 2301 40 41 46 2302 40 2298 36 36 41 41 123 2299 46 2303 40 40 2001 60 2247 62 41 2300 41 59 125 125 450 2299 59 125 125 
2608,Java,"    private static class GoalThreeBlocks extends GoalTwoBlocks {

        public GoalThreeBlocks(BlockPos pos) {
            super(pos);
        }

        @Override
        public boolean isInGoal(int x, int y, int z) {
            return x == this.x && (y == this.y || y == this.y - 1 || y == this.y - 2) && z == this.z;
        }

        @Override
        public double heuristic(int x, int y, int z) {
            int xDiff = x - this.x;
            int yDiff = y - this.y;
            int zDiff = z - this.z;
            return GoalBlock.calculate(xDiff, yDiff < -1 ? yDiff + 2 : yDiff == -1 ? 0 : yDiff, zDiff);
        }
    }",0,437 457 334 2000 378 2001 123 439 2000 40 2002 2003 41 123 463 40 2003 41 59 125 64 2004 439 324 2005 40 404 2006 44 404 2007 44 404 2008 41 123 450 2006 614 467 46 2006 605 40 2007 614 467 46 2007 606 2007 614 467 46 2007 45 1501 606 2007 614 467 46 2007 45 1502 41 605 2008 614 467 46 2008 59 125 64 2004 439 356 2009 40 404 2006 44 404 2007 44 404 2008 41 123 404 2010 61 2006 45 467 46 2006 59 404 2011 61 2007 45 467 46 2007 59 404 2012 61 2008 45 467 46 2008 59 450 2013 46 2014 40 2010 44 2011 60 45 1501 63 2011 43 1502 58 2011 614 45 1501 63 1500 58 2011 44 2012 41 59 125 125 
29407,Java,"	public static final class ValPortal {
		private static final Method COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE;
		private static final Method COPY_INITIALIZATION_OF_LOCAL_DECLARATION;
		private static final Method ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT;
		private static final Method ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION;
		
		static {
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.agent.PatchValEclipsePortal"");
			COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE = Util.findMethod(shadowed, ""copyInitializationOfForEachIterable"", Object.class);
			COPY_INITIALIZATION_OF_LOCAL_DECLARATION = Util.findMethod(shadowed, ""copyInitializationOfLocalDeclaration"", Object.class);
			ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT = Util.findMethod(shadowed, ""addFinalAndValAnnotationToVariableDeclarationStatement"", Object.class, Object.class, Object.class);
			ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION = Util.findMethod(shadowed, ""addFinalAndValAnnotationToSingleVariableDeclaration"", Object.class, Object.class, Object.class);
		}

		public static void copyInitializationOfForEachIterable(Object parser) {
			Util.invokeMethod(COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE, parser);
		}
		
		public static void copyInitializationOfLocalDeclaration(Object parser) {
			Util.invokeMethod(COPY_INITIALIZATION_OF_LOCAL_DECLARATION, parser);
		}
		
		public static void addFinalAndValAnnotationToVariableDeclarationStatement(Object converter, Object out, Object in) {
			Util.invokeMethod(ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT, converter, out, in);
		}
		
		public static void addFinalAndValAnnotationToSingleVariableDeclaration(Object converter, Object out, Object in) {
			Util.invokeMethod(ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION, converter, out, in);
		}
	}",0,439 457 381 334 2000 123 437 457 381 2001 2002 59 437 457 381 2001 2003 59 437 457 381 2001 2004 59 437 457 381 2001 2005 59 457 123 2006 60 63 62 2007 61 2008 46 2009 40 648 41 59 2002 61 2008 46 2010 40 2007 44 648 44 2011 46 334 41 59 2003 61 2008 46 2010 40 2007 44 648 44 2011 46 334 41 59 2004 61 2008 46 2010 40 2007 44 648 44 2011 46 334 44 2011 46 334 44 2011 46 334 41 59 2005 61 2008 46 2010 40 2007 44 648 44 2011 46 334 44 2011 46 334 44 2011 46 334 41 59 125 439 457 492 2012 40 2013 2014 41 123 2015 46 2016 40 2002 44 2014 41 59 125 439 457 492 2017 40 2013 2014 41 123 2018 46 2019 40 2003 44 2014 41 59 125 439 457 492 2020 40 2013 2021 44 2013 430 44 2013 398 41 123 2022 46 2023 40 2004 44 2021 44 430 44 398 41 59 125 439 457 492 2024 40 2013 2021 44 2013 430 44 2013 398 41 123 2025 46 2026 40 2005 44 2021 44 430 44 398 41 59 125 125 
29948,Java,"	static class ChangedChecker {
		private final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
		private final PrintStream feedback;
		
		ChangedChecker() throws UnsupportedEncodingException {
			feedback = new PrintStream(bytes, true, ""UTF-8"");
		}
		
		boolean isChanged() throws UnsupportedEncodingException {
			feedback.flush();
			return bytes.toString(""UTF-8"").endsWith(""[delomboked]\n"");
		}
	}",0,457 334 2000 123 437 381 2001 2002 61 418 2001 40 41 59 437 381 2003 2004 59 2000 40 41 470 2005 123 2004 61 418 2003 40 2002 44 473 44 648 41 59 125 324 2006 40 41 470 2005 123 2004 46 2007 40 41 59 450 2002 46 2008 40 648 41 46 2009 40 648 41 59 125 125 
31328,Java,"		sm.setTransplantMapper(new TransplantMapper() {
			public String mapResourceName(int classFileFormatVersion, String resourceName) {
				if (classFileFormatVersion < 50 || forceBaseResourceNames) return resourceName;
				return ""Class50/"" + resourceName;
			}
		});",0,2000 46 2001 40 418 2002 40 41 123 439 2003 2004 40 404 2005 44 2003 2006 41 123 392 40 2005 60 1503 606 2007 41 450 2006 59 450 648 43 2006 59 125 125 41 59 
29549,Java,"	@java.lang.SuppressWarnings(""all"")
	public static class BuilderDefaultsTargetTypingBuilder {
		@java.lang.SuppressWarnings(""all"")
		private boolean foo$set;
		@java.lang.SuppressWarnings(""all"")
		private String foo$value;

		@java.lang.SuppressWarnings(""all"")
		BuilderDefaultsTargetTypingBuilder() {
		}

		/**
		 * @return {@code this}.
		 */
		@java.lang.SuppressWarnings(""all"")
		public BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder foo(final String foo) {
			this.foo$value = foo;
			foo$set = true;
			return this;
		}

		@java.lang.SuppressWarnings(""all"")
		public BuilderDefaultsTargetTyping build() {
			String foo$value = this.foo$value;
			if (!this.foo$set) foo$value = BuilderDefaultsTargetTyping.$default$foo();
			return new BuilderDefaultsTargetTyping(foo$value);
		}

		@java.lang.Override
		@java.lang.SuppressWarnings(""all"")
		public java.lang.String toString() {
			return ""BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder(foo$value="" + this.foo$value + "")"";
		}
	}",0,64 2000 46 2001 46 2002 40 648 41 439 457 334 2003 123 64 2000 46 2001 46 2002 40 648 41 437 324 2004 36 2005 59 64 2000 46 2001 46 2002 40 648 41 437 2006 2004 36 2007 59 64 2000 46 2001 46 2002 40 648 41 2003 40 41 123 125 618 64 2000 46 2001 46 2002 40 648 41 439 2008 46 2003 2004 40 381 2006 2004 41 123 467 46 2004 36 2007 61 2004 59 2004 36 2005 61 473 59 450 467 59 125 64 2000 46 2001 46 2002 40 648 41 439 2008 2009 40 41 123 2006 2004 36 2007 61 467 46 2004 36 2007 59 392 40 33 467 46 2004 36 2005 41 2004 36 2007 61 2008 46 36 349 36 2004 40 41 59 450 418 2008 40 2004 36 2007 41 59 125 64 2000 46 2001 46 2010 64 2000 46 2001 46 2002 40 648 41 439 2000 46 2001 46 2006 2011 40 41 123 450 648 43 467 46 2004 36 2007 43 648 59 125 125 
29959,Java,"		StatementMaker returnStatementMaker = new StatementMaker() { @Override public JCStatement make() {
			return maker.Return(maker.Apply(List.<JCExpression>nil(), maker.Ident(job.toName(SELF_METHOD)), List.<JCExpression>nil()));
		}};",0,2000 2001 61 418 2000 40 41 123 64 2002 439 2003 2004 40 41 123 450 2005 46 2006 40 2005 46 2007 40 2008 46 60 2009 62 2010 40 41 44 2005 46 2011 40 2012 46 2013 40 2014 41 41 44 2008 46 60 2009 62 2010 40 41 41 41 59 125 125 59 
29958,Java,"		ExpressionMaker returnTypeMaker = new ExpressionMaker() { @Override public JCExpression make() {
			return maker.Ident(job.toName(builderGenericName));
		}};",0,2000 2001 61 418 2000 40 41 123 64 2002 439 2003 2004 40 41 123 450 2005 46 2006 40 2007 46 2008 40 2009 41 41 59 125 125 59 
29399,Java,"	public static final class Delegate {
		private static final Method HANDLE_DELEGATE_FOR_TYPE;
		private static final Method ADD_GENERATED_DELEGATE_METHODS;
		
		static {
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.agent.PatchDelegatePortal"");
			HANDLE_DELEGATE_FOR_TYPE = Util.findMethod(shadowed, ""handleDelegateForType"", Object.class);
			ADD_GENERATED_DELEGATE_METHODS = Util.findMethod(shadowed, ""addGeneratedDelegateMethods"", Object.class, Object.class);
		}
		
		public static boolean handleDelegateForType(Object classScope) {
			return (Boolean) Util.invokeMethod(HANDLE_DELEGATE_FOR_TYPE, classScope);
		}
		
		public static Object[] addGeneratedDelegateMethods(Object returnValue, Object javaElement) {
			return (Object[]) Util.invokeMethod(ADD_GENERATED_DELEGATE_METHODS, returnValue, javaElement);
		}
	}",0,439 457 381 334 2000 123 437 457 381 2001 2002 59 437 457 381 2001 2003 59 457 123 2004 60 63 62 2005 61 2006 46 2007 40 648 41 59 2002 61 2006 46 2008 40 2005 44 648 44 2009 46 334 41 59 2003 61 2006 46 2008 40 2005 44 648 44 2009 46 334 44 2009 46 334 41 59 125 439 457 324 2010 40 2011 2012 41 123 450 40 2013 41 2014 46 2015 40 2002 44 2012 41 59 125 439 457 2011 91 93 2016 40 2011 2017 44 2011 2018 41 123 450 40 2011 91 93 41 2019 46 2020 40 2003 44 2017 44 2018 41 59 125 125 
29400,Java,"	public static final class ExtensionMethod {
		private static final String MESSAGE_SEND_SIG = ""org.eclipse.jdt.internal.compiler.ast.MessageSend"";
		private static final String TYPE_BINDING_SIG = ""org.eclipse.jdt.internal.compiler.lookup.TypeBinding"";
		private static final String SCOPE_SIG = ""org.eclipse.jdt.internal.compiler.lookup.Scope"";
		private static final String BLOCK_SCOPE_SIG = ""org.eclipse.jdt.internal.compiler.lookup.BlockScope"";
		private static final String TYPE_BINDINGS_SIG = ""[Lorg.eclipse.jdt.internal.compiler.lookup.TypeBinding;"";
		private static final String PROBLEM_REPORTER_SIG = ""org.eclipse.jdt.internal.compiler.problem.ProblemReporter"";
		private static final String METHOD_BINDING_SIG = ""org.eclipse.jdt.internal.compiler.lookup.MethodBinding"";
		private static final String AST_NODE_SIG = ""org.eclipse.jdt.internal.compiler.ast.ASTNode"";
		
		private static final Method RESOLVE_TYPE;
		private static final Method ERROR_NO_METHOD_FOR;
		private static final Method INVALID_METHOD, INVALID_METHOD2;
		private static final Method NON_STATIC_ACCESS_TO_STATIC_METHOD;
		
		static {
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.agent.PatchExtensionMethod"");
			RESOLVE_TYPE = Util.findMethod(shadowed, ""resolveType"", TYPE_BINDING_SIG, MESSAGE_SEND_SIG, BLOCK_SCOPE_SIG);
			ERROR_NO_METHOD_FOR = Util.findMethod(shadowed, ""errorNoMethodFor"", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, TYPE_BINDING_SIG, TYPE_BINDINGS_SIG);
			INVALID_METHOD = Util.findMethod(shadowed, ""invalidMethod"", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, METHOD_BINDING_SIG);
			INVALID_METHOD2 = Util.findMethod(shadowed, ""invalidMethod"", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, METHOD_BINDING_SIG, SCOPE_SIG);
			NON_STATIC_ACCESS_TO_STATIC_METHOD = Util.findMethod(shadowed, ""nonStaticAccessToStaticMethod"", PROBLEM_REPORTER_SIG, AST_NODE_SIG, METHOD_BINDING_SIG, MESSAGE_SEND_SIG);
		}
		
		public static Object resolveType(Object resolvedType, Object methodCall, Object scope) {
			return Util.invokeMethod(RESOLVE_TYPE, resolvedType, methodCall, scope);
		}
		
		public static void errorNoMethodFor(Object problemReporter, Object messageSend, Object recType, Object params) {
			Util.invokeMethod(ERROR_NO_METHOD_FOR, problemReporter, messageSend, recType, params);
		}
		
		public static void invalidMethod(Object problemReporter, Object messageSend, Object method) {
			Util.invokeMethod(INVALID_METHOD, problemReporter, messageSend, method);
		}
		
		public static void invalidMethod(Object problemReporter, Object messageSend, Object method, Object scope) {
			Util.invokeMethod(INVALID_METHOD2, problemReporter, messageSend, method, scope);
		}
		
		public static void nonStaticAccessToStaticMethod(Object problemReporter, Object location, Object method, Object messageSend) {
			Util.invokeMethod(NON_STATIC_ACCESS_TO_STATIC_METHOD, problemReporter, location, method, messageSend);
		}
	}",0,439 457 381 334 2000 123 437 457 381 2001 2002 61 648 59 437 457 381 2001 2003 61 648 59 437 457 381 2001 2004 61 648 59 437 457 381 2001 2005 61 648 59 437 457 381 2001 2006 61 648 59 437 457 381 2001 2007 61 648 59 437 457 381 2001 2008 61 648 59 437 457 381 2001 2009 61 648 59 437 457 381 2010 2011 59 437 457 381 2010 2012 59 437 457 381 2010 2013 44 2014 59 437 457 381 2010 2015 59 457 123 2016 60 63 62 2017 61 2018 46 2019 40 648 41 59 2011 61 2018 46 2020 40 2017 44 648 44 2003 44 2002 44 2005 41 59 2012 61 2018 46 2020 40 2017 44 648 44 2007 44 2002 44 2003 44 2006 41 59 2013 61 2018 46 2020 40 2017 44 648 44 2007 44 2002 44 2008 41 59 2014 61 2018 46 2020 40 2017 44 648 44 2007 44 2002 44 2008 44 2004 41 59 2015 61 2018 46 2020 40 2017 44 648 44 2007 44 2009 44 2008 44 2002 41 59 125 439 457 2021 2022 40 2021 2023 44 2021 2024 44 2021 2025 41 123 450 2026 46 2027 40 2011 44 2023 44 2024 44 2025 41 59 125 439 457 492 2028 40 2021 2029 44 2021 2030 44 2021 2031 44 2021 433 41 123 2032 46 2033 40 2012 44 2029 44 2030 44 2031 44 433 41 59 125 439 457 492 2034 40 2021 2029 44 2021 2030 44 2021 2035 41 123 2036 46 2037 40 2013 44 2029 44 2030 44 2035 41 59 125 439 457 492 2034 40 2021 2029 44 2021 2030 44 2021 2035 44 2021 2025 41 123 2038 46 2039 40 2014 44 2029 44 2030 44 2035 44 2025 41 59 125 439 457 492 2040 40 2021 2029 44 2021 2041 44 2021 2035 44 2021 2030 41 123 2042 46 2043 40 2015 44 2029 44 2041 44 2035 44 2030 41 59 125 125 
29401,Java,"	public static final class Javadoc {
		private static final Method GET_HTML;
		private static final Method PRINT_METHOD;
		
		static {
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.agent.PatchJavadoc"");
			GET_HTML = Util.findMethod(shadowed, ""getHTMLContentFromSource"", String.class, Object.class);
			PRINT_METHOD = Util.findMethod(shadowed, ""printMethod"", AbstractMethodDeclaration.class, Integer.class, StringBuffer.class, TypeDeclaration.class);
		}
		
		public static String getHTMLContentFromSource(String original, IJavaElement member) {
			return (String) Util.invokeMethod(GET_HTML, original, member);
		}
		
		public static StringBuffer printMethod(AbstractMethodDeclaration methodDeclaration, int tab, StringBuffer output, TypeDeclaration type) {
			return (StringBuffer) Util.invokeMethod(PRINT_METHOD, methodDeclaration, tab, output, type);
		}
	}",0,439 457 381 334 2000 123 437 457 381 2001 2002 59 437 457 381 2001 2003 59 457 123 2004 60 63 62 2005 61 2006 46 2007 40 648 41 59 2002 61 2006 46 2008 40 2005 44 648 44 2009 46 334 44 2010 46 334 41 59 2003 61 2006 46 2008 40 2005 44 648 44 2011 46 334 44 2012 46 334 44 2013 46 334 44 2014 46 334 41 59 125 439 457 2015 2016 40 2015 2017 44 2018 2019 41 123 450 40 2015 41 2020 46 2021 40 2002 44 2017 44 2019 41 59 125 439 457 2022 2023 40 2024 2025 44 404 2026 44 2022 2027 44 2028 2029 41 123 450 40 2022 41 2030 46 2031 40 2003 44 2025 44 2026 44 2027 44 2029 41 59 125 125 
29404,Java,"	public static final class Transform {
		private static Method TRANSFORM;
		private static Method TRANSFORM_SWAPPED;
		
		private static synchronized void init(ClassLoader prepend) {
			if (TRANSFORM != null) return;
			
			Main.prependClassLoader(prepend);
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.TransformEclipseAST"");
			TRANSFORM = Util.findMethodAnyArgs(shadowed, ""transform"");
			TRANSFORM_SWAPPED = Util.findMethodAnyArgs(shadowed, ""transform_swapped"");
		}
		
		public static void transform(Object parser, Object ast) throws IOException {
			init(parser.getClass().getClassLoader());
			Util.invokeMethod(TRANSFORM, parser, ast);
		}
		
		public static void transform_swapped(Object ast, Object parser) throws IOException {
			init(parser.getClass().getClassLoader());
			Util.invokeMethod(TRANSFORM_SWAPPED, ast, parser);
		}
	}",0,439 457 381 334 2000 123 437 457 2001 2002 59 437 457 2001 2003 59 437 457 465 492 2004 40 2005 2006 41 123 392 40 2002 631 424 41 450 59 2007 46 2008 40 2006 41 59 2009 60 63 62 2010 61 2011 46 2012 40 648 41 59 2002 61 2011 46 2013 40 2010 44 648 41 59 2003 61 2011 46 2013 40 2010 44 648 41 59 125 439 457 492 2014 40 2015 2016 44 2015 2017 41 470 2018 123 2004 40 2016 46 2019 40 41 46 2020 40 41 41 59 2021 46 2022 40 2002 44 2016 44 2017 41 59 125 439 457 492 2023 40 2015 2017 44 2015 2016 41 470 2018 123 2004 40 2016 46 2024 40 41 46 2025 40 41 41 59 2026 46 2027 40 2003 44 2017 44 2016 41 59 125 125 
29405,Java,"	public static final class Util {
		private static ClassLoader shadowLoader;
		
		public static ClassLoader getShadowLoader() {
			if (shadowLoader == null) {
				try {
					Class.forName(""lombok.core.LombokNode"");
					// If we get here, then lombok is already available.
					shadowLoader = Util.class.getClassLoader();
				} catch (ClassNotFoundException e) {
					// If we get here, it isn't, and we should use the shadowloader.
					shadowLoader = Main.getShadowClassLoader();
				}
			}
			
			return shadowLoader;
		}
		
		public static Class<?> shadowLoadClass(String name) {
			try {
				return Class.forName(name, true, getShadowLoader());
			} catch (ClassNotFoundException e) {
				throw sneakyThrow(e);
			}
		}
		
		public static Method findMethod(Class<?> type, String name, Class<?>... parameterTypes) {
			try {
				return type.getDeclaredMethod(name, parameterTypes);
			} catch (NoSuchMethodException e) {
				throw sneakyThrow(e);
			}
		}
		
		public static Method findMethod(Class<?> type, String name, String... parameterTypes) {
			for (Method m : type.getDeclaredMethods()) {
				if (name.equals(m.getName()) && sameTypes(m.getParameterTypes(), parameterTypes)) {
					return m;
				}
			}
			throw sneakyThrow(new NoSuchMethodException(type.getName() + ""::"" + name));
		}
		
		public static Method findMethodAnyArgs(Class<?> type, String name) {
			for (Method m : type.getDeclaredMethods()) if (name.equals(m.getName())) return m;
			throw sneakyThrow(new NoSuchMethodException(type.getName() + ""::"" + name));
		}
		
		public static Object invokeMethod(Method method, Object... args) {
			try {
				return method.invoke(null, args);
			} catch (IllegalAccessException e) {
				throw sneakyThrow(e);
			} catch (InvocationTargetException e) {
				throw sneakyThrow(e.getCause());
			}
		}
		
		private static RuntimeException sneakyThrow(Throwable t) {
			if (t == null) throw new NullPointerException(""t"");
			Util.<RuntimeException>sneakyThrow0(t);
			return null;
		}
		
		@SuppressWarnings(""unchecked"")
		private static <T extends Throwable> void sneakyThrow0(Throwable t) throws T {
			throw (T)t;
		}
		
		private static boolean sameTypes(Class<?>[] types, String[] typeNames) {
			if (types.length != typeNames.length) return false;
			for (int i = 0; i < types.length; i++) {
				if (!types[i].getName().equals(typeNames[i])) return false;
			}
			return true;
		}
	}",0,439 457 381 334 2000 123 437 457 2001 2002 59 439 457 2001 2003 40 41 123 392 40 2002 614 424 41 123 474 123 2004 46 2005 40 648 41 59 621 2002 61 2000 46 334 46 2006 40 41 59 125 329 40 2007 2008 41 123 621 2002 61 2009 46 2010 40 41 59 125 125 450 2002 59 125 439 457 2011 60 63 62 2012 40 2013 2014 41 123 474 123 450 2011 46 2015 40 2014 44 473 44 2003 40 41 41 59 125 329 40 2016 2017 41 123 469 2018 40 2017 41 59 125 125 439 457 2019 2020 40 2011 60 63 62 2021 44 2013 2014 44 2011 60 63 62 613 2022 41 123 474 123 450 2021 46 2023 40 2014 44 2022 41 59 125 329 40 2024 2025 41 123 469 2026 40 2025 41 59 125 125 439 457 2019 2020 40 2011 60 63 62 2021 44 2013 2014 44 2013 613 2022 41 123 385 40 2019 2027 58 2021 46 2028 40 41 41 123 392 40 2014 46 2029 40 2027 46 2030 40 41 41 605 2031 40 2027 46 2032 40 41 44 2022 41 41 123 450 2027 59 125 125 469 2033 40 418 2034 40 2021 46 2035 40 41 43 648 43 2014 41 41 59 125 439 457 2019 2036 40 2011 60 63 62 2021 44 2013 2014 41 123 385 40 2019 2037 58 2021 46 2038 40 41 41 392 40 2014 46 2039 40 2037 46 2040 40 41 41 41 450 2037 59 469 2041 40 418 2042 40 2021 46 2040 40 41 43 648 43 2014 41 41 59 125 439 457 2043 2044 40 2019 2045 44 2043 613 2046 41 123 474 123 450 2045 46 2047 40 424 44 2046 41 59 125 329 40 2048 2049 41 123 469 2050 40 2049 41 59 125 329 40 2051 2049 41 123 469 2052 40 2049 46 2053 40 41 41 59 125 125 437 457 2054 2055 40 2056 2057 41 123 392 40 2057 614 424 41 469 418 2058 40 648 41 59 2000 46 60 2054 62 2059 40 2057 41 59 450 424 59 125 64 2060 40 648 41 437 457 60 2061 378 2056 62 492 2062 40 2056 2057 41 470 2061 123 469 40 2061 41 2057 59 125 437 457 324 2063 40 2011 60 63 62 91 93 2064 44 2013 91 93 2065 41 123 392 40 2064 46 2066 631 2065 46 2066 41 450 380 59 385 40 404 2067 61 1500 59 2067 60 2064 46 2066 59 2067 637 41 123 392 40 33 2064 91 2067 93 46 2068 40 41 46 2069 40 2065 91 2067 93 41 41 450 380 59 125 450 473 59 125 125 
31325,Java,"				.target(new TargetMatcher() {
					@Override public boolean matches(String classSpec, String methodName, String descriptor) {
						if (!""convert"".equals(methodName)) return false;
						
						List<String> fullDesc = MethodTarget.decomposeFullDesc(descriptor);
						if (""V"".equals(fullDesc.get(0))) return false;
						if (fullDesc.size() < 2) return false;
						if (!fullDesc.get(1).startsWith(""Lorg/eclipse/jdt/internal/compiler/ast/"")) return false;
						return true;
					}
					
					@Override public String describe() {
						return ""ASTConverter:[all relevant]"";
					}
					
					@Override public Collection<String> getAffectedClasses() {
						return Collections.singleton(""org.eclipse.jdt.core.dom.ASTConverter"");
					}
				}).request(StackRequest.PARAM1, StackRequest.RETURN_VALUE)",0,46 2000 40 418 2001 40 41 123 64 2002 439 324 2003 40 2004 2005 44 2004 2006 44 2004 2007 41 123 392 40 33 648 46 2008 40 2006 41 41 450 380 59 2009 60 2004 62 2010 61 2011 46 2012 40 2007 41 59 392 40 648 46 2008 40 2010 46 2013 40 1500 41 41 41 450 380 59 392 40 2010 46 2014 40 41 60 1502 41 450 380 59 392 40 33 2010 46 2013 40 1501 41 46 2015 40 648 41 41 450 380 59 450 473 59 125 64 2002 439 2004 2016 40 41 123 450 648 59 125 64 2002 439 2017 60 2004 62 2018 40 41 123 450 2019 46 2020 40 648 41 59 125 125 41 46 2021 40 2022 46 2023 44 2022 46 2024 41 
31326,Java,"				.target(new TargetMatcher() {
					@Override public boolean matches(String classSpec, String methodName, String descriptor) {
						if (!methodName.startsWith(""convert"")) return false;
						
						List<String> fullDesc = MethodTarget.decomposeFullDesc(descriptor);
						if (fullDesc.size() < 2) return false;
						if (!fullDesc.get(1).startsWith(""Lorg/eclipse/jdt/internal/compiler/ast/"")) return false;
						
						return true;
					}
					
					@Override public String describe() {
						return ""ASTConverter::(all relevant)"";
					}
					
					@Override public Collection<String> getAffectedClasses() {
						return Collections.singleton(""org.eclipse.jdt.core.dom.ASTConverter"");
					}
				}).methodToWrap(new Hook(""org.eclipse.jdt.core.dom.SimpleName"", ""<init>"", ""void"", ""org.eclipse.jdt.core.dom.AST""))",0,46 2000 40 418 2001 40 41 123 64 2002 439 324 2003 40 2004 2005 44 2004 2006 44 2004 2007 41 123 392 40 33 2006 46 2008 40 648 41 41 450 380 59 2009 60 2004 62 2010 61 2011 46 2012 40 2007 41 59 392 40 2010 46 2013 40 41 60 1502 41 450 380 59 392 40 33 2010 46 2014 40 1501 41 46 2008 40 648 41 41 450 380 59 450 473 59 125 64 2002 439 2004 2015 40 41 123 450 648 59 125 64 2002 439 2016 60 2004 62 2017 40 41 123 450 2018 46 2019 40 648 41 59 125 125 41 46 2020 40 418 2021 40 648 44 648 44 648 44 648 41 41 
29953,Java,"			unit.accept(new TreeScanner() {
				private JCTree parent;
				@Override public void scan(JCTree tree) {
					parent = parents.peek();
					
					parents.push(tree);
					super.scan(tree);
					parents.pop();
				}
				
				@Override public void visitClassDef(JCClassDecl tree) {
					// Skip anonymous or local classes, they have no symbol
					if (!(parent instanceof JCClassDecl || parent instanceof JCCompilationUnit)) return;
					
					validateSymbol(tree, tree.sym);
					super.visitClassDef(tree);
				};

				@Override public void visitMethodDef(JCMethodDecl tree) {
					validateSymbol(tree, tree.sym);
					super.visitMethodDef(tree);
				}
				
				@Override public void visitVarDef(JCVariableDecl tree) {
					// Skip local variables
					if (!(parent instanceof JCClassDecl || parent instanceof JCMethodDecl)) return;
					
					validateSymbol(tree, tree.sym);
					super.visitVarDef(tree);
				}
				
				private void validateSymbol(JCTree tree, Symbol sym) {
					if (sym == null) {
						fail(""Missing symbol for "" + tree);
					}
					// Only classes have enclosed elements, skip everything else
					if (!sym.owner.getKind().isClass()) return;
					
					if (!sym.owner.getEnclosedElements().contains(sym)) {
						fail(tree + "" not added to parent"");
					}
				}
			});",0,2000 46 2001 40 418 2002 40 41 123 437 2003 2004 59 64 2005 439 492 2006 40 2003 2007 41 123 2004 61 2008 46 2009 40 41 59 2008 46 2010 40 2007 41 59 463 46 2006 40 2007 41 59 2008 46 2011 40 41 59 125 64 2005 439 492 2012 40 2013 2007 41 123 621 392 40 33 40 2004 402 2013 606 2004 402 2014 41 41 450 59 2015 40 2007 44 2007 46 2016 41 59 463 46 2012 40 2007 41 59 125 59 64 2005 439 492 2017 40 2018 2007 41 123 2019 40 2007 44 2007 46 2020 41 59 463 46 2017 40 2007 41 59 125 64 2005 439 492 2021 40 2022 2007 41 123 621 392 40 33 40 2004 402 2013 606 2004 402 2018 41 41 450 59 2023 40 2007 44 2007 46 2024 41 59 463 46 2021 40 2007 41 59 125 437 492 2025 40 2003 2007 44 2026 2027 41 123 392 40 2027 614 424 41 123 2028 40 648 43 2007 41 59 125 621 392 40 33 2027 46 2029 46 2030 40 41 46 2031 40 41 41 450 59 392 40 33 2027 46 2029 46 2032 40 41 46 2033 40 2027 41 41 123 2034 40 2007 43 648 41 59 125 125 125 41 59 
29954,Java,"public class RunTestsViaDelombok extends AbstractRunTests {
	private Delombok delombok = new Delombok();
	
	@Override
	public boolean transformCode(Collection<CompilerMessage> messages, StringWriter result, final File file, String encoding, Map<String, String> formatPreferences, int version, boolean checkPositions) throws Throwable {
		delombok.setVerbose(true);
		ChangedChecker cc = new ChangedChecker();
		delombok.setFeedback(cc.feedback);
		delombok.setForceProcess(true);
		delombok.setCharset(encoding == null ? ""UTF-8"" : encoding);
		delombok.setFormatPreferences(formatPreferences);
		
		delombok.setDiagnosticsListener(new CapturingDiagnosticListener(file, messages));
		
		if (checkPositions) delombok.addAdditionalAnnotationProcessor(new ValidatePositionProcessor(version));
		delombok.addAdditionalAnnotationProcessor(new ValidateTypesProcessor());
		
		delombok.addFile(file.getAbsoluteFile().getParentFile(), file.getName());
		delombok.setSourcepath(file.getAbsoluteFile().getParent());
		String bcp = System.getProperty(""delombok.bootclasspath"");
		if (bcp != null) delombok.setBootclasspath(bcp);
		delombok.setWriter(result);
		Locale originalLocale = Locale.getDefault();
		try {
			Locale.setDefault(Locale.ENGLISH);
			delombok.delombok();
			return cc.isChanged();
		} finally {
			Locale.setDefault(originalLocale);
		}
	}
	
	public static class ValidatePositionProcessor extends TreeProcessor {
		private final int version;
		
		public ValidatePositionProcessor(int version) {
			this.version = version;
		}
		
		private String craftFailMsg(String problematicNode, Deque<JCTree> astContext) {
			StringBuilder msg = new StringBuilder(problematicNode).append("" position of node not set: "");
			for (JCTree t : astContext) {
				msg.append(""\n  "").append(t.getClass().getSimpleName());
				String asStr = t.toString();
				if (asStr.length() < 80) msg.append("": "").append(asStr);
				else if (t instanceof JCClassDecl) msg.append("": "").append(((JCClassDecl) t).name);
				else if (t instanceof JCMethodDecl) msg.append("": "").append(((JCMethodDecl) t).name);
				else if (t instanceof JCVariableDecl) msg.append("": "").append(((JCVariableDecl) t).name);
			}
			return msg.append(""\n-------"").toString();
		}
		
		@Override void processCompilationUnit(final JCCompilationUnit unit) {
			final Deque<JCTree> astContext = new ArrayDeque<JCTree>();
			unit.accept(new TreeScanner() {
				@Override public void scan(JCTree tree) {
					if (tree == null) return;
					if (tree instanceof JCMethodDecl && (((JCMethodDecl) tree).mods.flags & Flags.GENERATEDCONSTR) != 0) return;
					astContext.push(tree);
					try {
						if (tree instanceof JCModifiers) return;
						
						if (!Javac.validateDocComment(unit, tree)) {
							fail(""Start position of doc comment ("" + Javac.getDocComment(unit, tree) + "") of "" + tree + "" not set"");
						}
						
						boolean check = true;
						if (version < 8 && tree instanceof TypeBoundKind) {
							// TypeBoundKind works differently in java6, and as a consequence,
							// the position is not set properly.
							// Given status of j6/j7, not worth properly testing.
							check = false;
						}
						if (version < 8 && tree instanceof JCIdent) {
							// explicit `super()` invocations do not appear to have end pos in j6/7.
							if (""super"".equals("""" + ((JCIdent) tree).name)) check = false;
						}
						
						if (tree instanceof JCVariableDecl && (((JCVariableDecl) tree).mods.flags & Javac.GENERATED_MEMBER) != 0) return;
						
						if (check && tree.pos == -1) fail(craftFailMsg(""Start"", astContext));
						
						if (check && Javac.getEndPosition(tree, unit) == -1) {
							fail(craftFailMsg(""End"", astContext));
						}
					} finally {
						try {
							super.scan(tree);
						} finally {
							astContext.pop();
						}
					}
				}
				
				@Override public void visitMethodDef(JCMethodDecl tree) {
					super.visitMethodDef(tree);
				}
				
				@Override public void visitVarDef(JCVariableDecl tree) {
					if ((tree.mods.flags & Flags.ENUM) != 0) return;
					super.visitVarDef(tree);
				}
				
				@Override public void visitAnnotation(JCAnnotation tree) {
					scan(tree.annotationType);
					// Javac parser maps @Annotation(""val"") to @Annotation(value = ""val"") but does not add an end position for the new JCIdent...
					if (tree.args.length() == 1 && tree.args.head instanceof JCAssign && ((JCIdent)((JCAssign) tree.args.head).lhs).name.toString().equals(""value"")) {
						scan(((JCAssign) tree.args.head).rhs);
					} else {
						scan(tree.args);
					}
				}
			});
		}
	}
	
	public static class ValidateTypesProcessor extends TreeProcessor {
		@Override void processCompilationUnit(final JCCompilationUnit unit) {
			final Stack<JCTree> parents = new Stack<JCTree>();
			parents.add(unit);
			
			unit.accept(new TreeScanner() {
				private JCTree parent;
				@Override public void scan(JCTree tree) {
					parent = parents.peek();
					
					parents.push(tree);
					super.scan(tree);
					parents.pop();
				}
				
				@Override public void visitClassDef(JCClassDecl tree) {
					// Skip anonymous or local classes, they have no symbol
					if (!(parent instanceof JCClassDecl || parent instanceof JCCompilationUnit)) return;
					
					validateSymbol(tree, tree.sym);
					super.visitClassDef(tree);
				};

				@Override public void visitMethodDef(JCMethodDecl tree) {
					validateSymbol(tree, tree.sym);
					super.visitMethodDef(tree);
				}
				
				@Override public void visitVarDef(JCVariableDecl tree) {
					// Skip local variables
					if (!(parent instanceof JCClassDecl || parent instanceof JCMethodDecl)) return;
					
					validateSymbol(tree, tree.sym);
					super.visitVarDef(tree);
				}
				
				private void validateSymbol(JCTree tree, Symbol sym) {
					if (sym == null) {
						fail(""Missing symbol for "" + tree);
					}
					// Only classes have enclosed elements, skip everything else
					if (!sym.owner.getKind().isClass()) return;
					
					if (!sym.owner.getEnclosedElements().contains(sym)) {
						fail(tree + "" not added to parent"");
					}
				}
			});
		}
	}
	
	public static abstract class TreeProcessor extends AbstractProcessor {
		private Trees trees;
		@Override public synchronized void init(ProcessingEnvironment processingEnv) {
			super.init(processingEnv);
			trees = Trees.instance(processingEnv);
		}
		
		@Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
			for (Element element : roundEnv.getRootElements()) {
				JCCompilationUnit unit = toUnit(element);
				if (unit != null) {
					processCompilationUnit(unit);
				}
			}
			return false;
		}
		
		abstract void processCompilationUnit(JCCompilationUnit unit);
		
		@Override public Set<String> getSupportedAnnotationTypes() {
			return Collections.singleton(""*"");
		}
		
		@Override public SourceVersion getSupportedSourceVersion() {
			return SourceVersion.latest();
		}
		
		private JCCompilationUnit toUnit(Element element) {
			TreePath path = null;
			if (trees != null) {
				try {
					path = trees.getPath(element);
				} catch (NullPointerException ignore) {
					// Happens if a package-info.java doesn't contain a package declaration.
					// https://github.com/projectlombok/lombok/issues/2184
					// We can safely ignore those, since they do not need any processing
				}
			}
			if (path == null) return null;
			
			return (JCCompilationUnit) path.getCompilationUnit();
		}
	}

	static class ChangedChecker {
		private final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
		private final PrintStream feedback;
		
		ChangedChecker() throws UnsupportedEncodingException {
			feedback = new PrintStream(bytes, true, ""UTF-8"");
		}
		
		boolean isChanged() throws UnsupportedEncodingException {
			feedback.flush();
			return bytes.toString(""UTF-8"").endsWith(""[delomboked]\n"");
		}
	}
}",0,439 334 2000 378 2001 123 437 2002 2003 61 418 2002 40 41 59 64 2004 439 324 2005 40 2006 60 2007 62 2008 44 2009 2010 44 381 2011 2012 44 2013 2014 44 2015 60 2013 44 2013 62 2016 44 404 2017 44 324 2018 41 470 2019 123 2003 46 2020 40 473 41 59 2021 2022 61 418 2021 40 41 59 2003 46 2023 40 2022 46 2024 41 59 2003 46 2025 40 473 41 59 2003 46 2026 40 2014 614 424 63 648 58 2014 41 59 2003 46 2027 40 2016 41 59 2003 46 2028 40 418 2029 40 2012 44 2008 41 41 59 392 40 2018 41 2003 46 2030 40 418 2031 40 2017 41 41 59 2003 46 2030 40 418 2032 40 41 41 59 2003 46 2033 40 2012 46 2034 40 41 46 2035 40 41 44 2012 46 2036 40 41 41 59 2003 46 2037 40 2012 46 2034 40 41 46 2038 40 41 41 59 2013 2039 61 2040 46 2041 40 648 41 59 392 40 2039 631 424 41 2003 46 2042 40 2039 41 59 2003 46 2043 40 2010 41 59 2044 2045 61 2044 46 2046 40 41 59 474 123 2044 46 2047 40 2044 46 2048 41 59 2003 46 2003 40 41 59 450 2022 46 2049 40 41 59 125 382 123 2044 46 2050 40 2045 41 59 125 125 439 457 334 2051 378 2052 123 437 381 404 2017 59 439 2051 40 404 2017 41 123 467 46 2017 61 2017 59 125 437 2013 2053 40 2013 2054 44 2055 60 2056 62 2057 41 123 2058 2059 61 418 2058 40 2054 41 46 2060 40 648 41 59 385 40 2056 2061 58 2057 41 123 2059 46 2060 40 648 41 46 2060 40 2061 46 2062 40 41 46 2063 40 41 41 59 2013 2064 61 2061 46 2065 40 41 59 392 40 2064 46 2066 40 41 60 1503 41 2059 46 2060 40 648 41 46 2060 40 2064 41 59 360 392 40 2061 402 2067 41 2059 46 2060 40 648 41 46 2060 40 40 40 2067 41 2061 41 46 2068 41 59 360 392 40 2061 402 2069 41 2059 46 2060 40 648 41 46 2060 40 40 40 2069 41 2061 41 46 2068 41 59 360 392 40 2061 402 2070 41 2059 46 2060 40 648 41 46 2060 40 40 40 2070 41 2061 41 46 2068 41 59 125 450 2059 46 2060 40 648 41 46 2071 40 41 59 125 64 2004 492 2072 40 381 2073 2074 41 123 381 2055 60 2056 62 2057 61 418 2075 60 2056 62 40 41 59 2074 46 2076 40 418 2077 40 41 123 64 2004 439 492 2078 40 2056 2079 41 123 392 40 2079 614 424 41 450 59 392 40 2079 402 2080 605 40 40 40 2080 41 2079 41 46 2081 46 2082 38 2083 46 2084 41 631 1500 41 450 59 2057 46 2085 40 2079 41 59 474 123 392 40 2079 402 2086 41 450 59 392 40 33 2087 46 2088 40 2074 44 2079 41 41 123 2089 40 648 43 2087 46 2090 40 2074 44 2079 41 43 648 43 2079 43 648 41 59 125 324 2091 61 473 59 392 40 2017 60 1502 605 2079 402 2092 41 123 621 621 621 2091 61 380 59 125 392 40 2017 60 1502 605 2079 402 2093 41 123 621 392 40 648 46 2094 40 648 43 40 40 2093 41 2079 41 46 2095 41 41 2091 61 380 59 125 392 40 2079 402 2096 605 40 40 40 2096 41 2079 41 46 2081 46 2082 38 2087 46 2097 41 631 1500 41 450 59 392 40 2091 605 2079 46 2098 614 45 1501 41 2099 40 2053 40 648 44 2057 41 41 59 392 40 2091 605 2087 46 2100 40 2079 44 2074 41 614 45 1501 41 123 2099 40 2053 40 648 44 2057 41 41 59 125 125 382 123 474 123 463 46 2078 40 2079 41 59 125 382 123 2057 46 2101 40 41 59 125 125 125 64 2004 439 492 2102 40 2103 2079 41 123 463 46 2102 40 2079 41 59 125 64 2004 439 492 2104 40 2105 2079 41 123 392 40 40 2079 46 2106 46 2107 38 2108 46 2109 41 631 1500 41 450 59 463 46 2104 40 2079 41 59 125 64 2004 439 492 2110 40 2111 2079 41 123 2078 40 2079 46 2112 41 59 621 392 40 2079 46 2113 46 2114 40 41 614 1501 605 2079 46 2113 46 2115 402 2116 605 40 40 2117 41 40 40 2116 41 2079 46 2113 46 2115 41 46 2118 41 46 2119 46 2120 40 41 46 2121 40 648 41 41 123 2078 40 40 40 2116 41 2079 46 2113 46 2115 41 46 2122 41 59 125 360 123 2078 40 2079 46 2113 41 59 125 125 125 41 59 125 125 439 457 334 2123 378 2052 123 64 2004 492 2124 40 381 2125 2126 41 123 381 2127 60 2128 62 2129 61 418 2127 60 2128 62 40 41 59 2129 46 2130 40 2126 41 59 2126 46 2131 40 418 2132 40 41 123 437 2128 2133 59 64 2004 439 492 2134 40 2128 2135 41 123 2133 61 2129 46 2136 40 41 59 2129 46 2137 40 2135 41 59 463 46 2134 40 2135 41 59 2129 46 2138 40 41 59 125 64 2004 439 492 2139 40 2140 2135 41 123 621 392 40 33 40 2133 402 2140 606 2133 402 2125 41 41 450 59 2141 40 2135 44 2135 46 2142 41 59 463 46 2139 40 2135 41 59 125 59 64 2004 439 492 2143 40 2144 2135 41 123 2145 40 2135 44 2135 46 2146 41 59 463 46 2143 40 2135 41 59 125 64 2004 439 492 2147 40 2148 2135 41 123 621 392 40 33 40 2133 402 2140 606 2133 402 2144 41 41 450 59 2149 40 2135 44 2135 46 2150 41 59 463 46 2147 40 2135 41 59 125 437 492 2151 40 2128 2135 44 2152 2153 41 123 392 40 2153 614 424 41 123 2154 40 648 43 2135 41 59 125 621 392 40 33 2153 46 2155 46 2156 40 41 46 2157 40 41 41 450 59 392 40 33 2153 46 2155 46 2158 40 41 46 2159 40 2153 41 41 123 2160 40 2135 43 648 41 59 125 125 125 41 59 125 125 439 457 305 334 2052 378 2161 123 437 2162 2163 59 64 2004 439 465 492 2164 40 2165 2166 41 123 463 46 2164 40 2166 41 59 2163 61 2162 46 2167 40 2166 41 59 125 64 2004 439 324 2168 40 2169 60 63 378 2170 62 2171 44 2172 2173 41 123 385 40 2174 2175 58 2173 46 2176 40 41 41 123 2177 2178 61 2179 40 2175 41 59 392 40 2178 631 424 41 123 2180 40 2178 41 59 125 125 450 380 59 125 305 492 2181 40 2182 2183 41 59 64 2004 439 2169 60 2013 62 2184 40 41 123 450 2185 46 2186 40 648 41 59 125 64 2004 439 2187 2188 40 41 123 450 2187 46 2189 40 41 59 125 437 2182 2190 40 2191 2192 41 123 2193 2194 61 424 59 392 40 2163 631 424 41 123 474 123 2194 61 2163 46 2195 40 2192 41 59 125 329 40 2196 2197 41 123 621 621 621 125 125 392 40 2194 614 424 41 450 424 59 450 40 2182 41 2194 46 2198 40 41 59 125 125 457 334 2199 123 437 381 2200 2201 61 418 2200 40 41 59 437 381 2202 2203 59 2199 40 41 470 2204 123 2203 61 418 2202 40 2201 44 473 44 648 41 59 125 324 2205 40 41 470 2204 123 2203 46 2206 40 41 59 450 2201 46 2207 40 648 41 46 2208 40 648 41 59 125 125 125 
30501,Java,"	private static class GetterMethod {
		private final Name name;
		private final JCExpression type;
		
		GetterMethod(Name name, JCExpression type) {
			this.name = name;
			this.type = type;
		}
	}",0,437 457 334 2000 123 437 381 2001 2002 59 437 381 2003 2004 59 2000 40 2001 2002 44 2003 2004 41 123 467 46 2002 61 2002 59 467 46 2004 61 2004 59 125 125 
30492,Java,"	static class ClassSymbolMembersField {
		private static final Field membersField;
		private static final Method removeMethod;
		private static final Method enterMethod;
		
		static {
			Field f = null;
			Method r = null;
			Method e = null;
			try {
				f = Permit.getField(ClassSymbol.class, ""members_field"");
				r = Permit.getMethod(f.getType(), ""remove"", Symbol.class);
				e = Permit.getMethod(f.getType(), ""enter"", Symbol.class);
			} catch (Exception ex) {}
			membersField = f;
			removeMethod = r;
			enterMethod = e;
		}
		
		static void remove(ClassSymbol from, Symbol toRemove) {
			if (from == null) return;
			try {
				Scope scope = (Scope) membersField.get(from);
				if (scope == null) return;
				Permit.invoke(removeMethod, scope, toRemove);
			} catch (Exception e) {}
		}
		
		static void enter(ClassSymbol from, Symbol toEnter) {
			if (from == null) return;
			try {
				Scope scope = (Scope) membersField.get(from);
				if (scope == null) return;
				Permit.invoke(enterMethod, scope, toEnter);
			} catch (Exception e) {}
		}
	}",0,457 334 2000 123 437 457 381 2001 2002 59 437 457 381 2003 2004 59 437 457 381 2003 2005 59 457 123 2001 2006 61 424 59 2003 2007 61 424 59 2003 2008 61 424 59 474 123 2006 61 2009 46 2010 40 2011 46 334 44 648 41 59 2007 61 2009 46 2012 40 2006 46 2013 40 41 44 648 44 2014 46 334 41 59 2008 61 2009 46 2012 40 2006 46 2013 40 41 44 648 44 2014 46 334 41 59 125 329 40 2015 2016 41 123 125 2002 61 2006 59 2004 61 2007 59 2005 61 2008 59 125 457 492 2017 40 2018 388 44 2019 2020 41 123 392 40 388 614 424 41 450 59 474 123 2021 2022 61 40 2021 41 2002 46 2023 40 388 41 59 392 40 2022 614 424 41 450 59 2024 46 2025 40 2004 44 2022 44 2020 41 59 125 329 40 2026 2027 41 123 125 125 457 492 2028 40 2018 388 44 2019 2029 41 123 392 40 388 614 424 41 450 59 474 123 2030 2031 61 40 2030 41 2002 46 2032 40 388 41 59 392 40 2031 614 424 41 450 59 2033 46 2034 40 2005 44 2031 44 2029 41 59 125 329 40 2035 2036 41 123 125 125 125 
30500,Java,"	static class EnterReflect {
		private static final Method classEnter;
		private static final Method memberEnter;
		private static final Method blockAnnotations;
		private static final Method unblockAnnotations;
		
		static {
			classEnter = Permit.permissiveGetMethod(Enter.class, ""classEnter"", JCTree.class, Env.class);
			memberEnter = Permit.permissiveGetMethod(MemberEnter.class, ""memberEnter"", JCTree.class, Env.class);
			
			Method block = Permit.permissiveGetMethod(Annotate.class, ""blockAnnotations"");
			if (block == null) block = Permit.permissiveGetMethod(Annotate.class, ""enterStart"");
			blockAnnotations = block;
			
			Method unblock = Permit.permissiveGetMethod(Annotate.class, ""unblockAnnotations"");
			if (unblock == null) unblock = Permit.permissiveGetMethod(Annotate.class, ""enterDone"");
			unblockAnnotations = unblock;
		}
		
		static Type classEnter(JCTree tree, JavacNode parent) {
			Enter enter = Enter.instance(parent.getContext());
			Env<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());
			if (classEnv == null) return null;
			Type type = (Type) Permit.invokeSneaky(classEnter, enter, tree, classEnv);
			if (type == null) return null;
			type.complete();
			return type;
		}
		
		static void memberEnter(JCTree tree, JavacNode parent) {
			Context context = parent.getContext();
			MemberEnter me = MemberEnter.instance(context);
			Annotate annotate = Annotate.instance(context);
			Enter enter = Enter.instance(context);
			
			Env<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());
			if (classEnv == null) return;
			
			Permit.invokeSneaky(blockAnnotations, annotate);
			Permit.invokeSneaky(memberEnter, me, tree, classEnv);
			Permit.invokeSneaky(unblockAnnotations, annotate);
		}
	}",0,457 334 2000 123 437 457 381 2001 2002 59 437 457 381 2001 2003 59 437 457 381 2001 2004 59 437 457 381 2001 2005 59 457 123 2002 61 2006 46 2007 40 2008 46 334 44 648 44 2009 46 334 44 2010 46 334 41 59 2003 61 2006 46 2007 40 2011 46 334 44 648 44 2009 46 334 44 2010 46 334 41 59 2001 2012 61 2006 46 2007 40 2013 46 334 44 648 41 59 392 40 2012 614 424 41 2012 61 2006 46 2007 40 2013 46 334 44 648 41 59 2004 61 2012 59 2001 2014 61 2006 46 2007 40 2013 46 334 44 648 41 59 392 40 2014 614 424 41 2014 61 2006 46 2007 40 2013 46 334 44 648 41 59 2005 61 2014 59 125 457 2015 2002 40 2016 2017 44 2018 2019 41 123 2020 2021 61 2020 46 2022 40 2019 46 2023 40 41 41 59 2024 60 2025 62 2026 61 2021 46 2027 40 40 2028 41 2019 46 2029 40 41 41 59 392 40 2026 614 424 41 450 424 59 2015 2030 61 40 2015 41 2031 46 2032 40 2002 44 2021 44 2017 44 2026 41 59 392 40 2030 614 424 41 450 424 59 2030 46 2033 40 41 59 450 2030 59 125 457 492 2003 40 2016 2017 44 2018 2019 41 123 2034 2035 61 2019 46 2036 40 41 59 2037 2038 61 2037 46 2039 40 2035 41 59 2040 2041 61 2040 46 2039 40 2035 41 59 2042 2043 61 2042 46 2039 40 2035 41 59 2044 60 2045 62 2046 61 2043 46 2047 40 40 2048 41 2019 46 2049 40 41 41 59 392 40 2046 614 424 41 450 59 2050 46 2051 40 2004 44 2041 41 59 2050 46 2051 40 2003 44 2038 44 2017 44 2046 41 59 2050 46 2051 40 2005 44 2041 41 59 125 125 
30814,Java,"	@Provides
	public static class HandleCommonsLog extends JavacAnnotationHandler<lombok.extern.apachecommons.CommonsLog> {
		@Override public void handle(AnnotationValues<lombok.extern.apachecommons.CommonsLog> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_COMMONS_FLAG_USAGE, ""@apachecommons.CommonsLog"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.COMMONS, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
30816,Java,"	@Provides
	public static class HandleFloggerLog extends JavacAnnotationHandler<lombok.extern.flogger.Flogger> {
		@Override public void handle(AnnotationValues<lombok.extern.flogger.Flogger> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_FLOGGER_FLAG_USAGE, ""@Flogger"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.FLOGGER, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
30819,Java,"	@Provides
	public static class HandleLog4j2Log extends JavacAnnotationHandler<lombok.extern.log4j.Log4j2> {
		@Override public void handle(AnnotationValues<lombok.extern.log4j.Log4j2> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_LOG4J2_FLAG_USAGE, ""@Log4j2"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.LOG4J2, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
29956,Java,"	class SuperBuilderJob extends BuilderJob {
		JavacNode builderAbstractType;
		String builderAbstractClassName;
		JavacNode builderImplType;
		String builderImplClassName;
		List<JCTypeParameter> builderTypeParams_;
		
		void init(AnnotationValues<SuperBuilder> annValues, SuperBuilder ann, JavacNode node) {
			accessOuters = accessInners = AccessLevel.PUBLIC;
			oldFluent = true;
			oldChain = true;
			
			builderMethodName = ann.builderMethodName();
			buildMethodName = ann.buildMethodName();
			toBuilder = ann.toBuilder();
			
			if (builderMethodName == null) builderMethodName = ""builder"";
			if (buildMethodName == null) buildMethodName = ""build"";
			builderClassName = getBuilderClassNameTemplate(node, null);
		}
		
		void setBuilderToImpl() {
			builderType = builderImplType;
			builderClassName = builderImplClassName;
			builderTypeParams = typeParams;
		}
		
		void setBuilderToAbstract() {
			builderType = builderAbstractType;
			builderClassName = builderAbstractClassName;
			builderTypeParams = builderTypeParams_;
		}
	}",0,334 2000 378 2001 123 2002 2003 59 2004 2005 59 2002 2006 59 2004 2007 59 2008 60 2009 62 2010 59 492 2011 40 2012 60 2013 62 2014 44 2013 2015 44 2002 2016 41 123 2017 61 2018 61 2019 46 2020 59 2021 61 473 59 2022 61 473 59 2023 61 2015 46 2023 40 41 59 2024 61 2015 46 2024 40 41 59 2025 61 2015 46 2025 40 41 59 392 40 2023 614 424 41 2023 61 648 59 392 40 2024 614 424 41 2024 61 648 59 2026 61 2027 40 2016 44 424 41 59 125 492 2028 40 41 123 2029 61 2006 59 2030 61 2007 59 2031 61 2032 59 125 492 2033 40 41 123 2034 61 2003 59 2035 61 2005 59 2036 61 2010 59 125 125 
30820,Java,"	@Provides
	public static class HandleLog4jLog extends JavacAnnotationHandler<lombok.extern.log4j.Log4j> {
		@Override public void handle(AnnotationValues<lombok.extern.log4j.Log4j> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_LOG4J_FLAG_USAGE, ""@Log4j"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.LOG4J, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
30822,Java,"	@Provides
	public static class HandleXSlf4jLog extends JavacAnnotationHandler<lombok.extern.slf4j.XSlf4j> {
		@Override public void handle(AnnotationValues<lombok.extern.slf4j.XSlf4j> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_XSLF4J_FLAG_USAGE, ""@XSlf4j"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.XSLF4J, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
30513,Java,"	@Provides
	public static class HandleAllArgsConstructor extends JavacAnnotationHandler<AllArgsConstructor> {
		private static final String NAME = AllArgsConstructor.class.getSimpleName();
		private HandleConstructor handleConstructor = new HandleConstructor();
		
		@Override public void handle(AnnotationValues<AllArgsConstructor> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.ALL_ARGS_CONSTRUCTOR_FLAG_USAGE, ""@AllArgsConstructor"", ConfigurationKeys.ANY_CONSTRUCTOR_FLAG_USAGE, ""any @xArgsConstructor"");
			
			deleteAnnotationIfNeccessary(annotationNode, AllArgsConstructor.class);
			deleteImportFromCompilationUnit(annotationNode, ""lombok.AccessLevel"");
			JavacNode typeNode = annotationNode.up();
			if (!checkLegality(typeNode, annotationNode, NAME)) return;
			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, ""onConstructor"", ""@AllArgsConstructor(onConstructor"", annotationNode);
			AllArgsConstructor ann = annotation.getInstance();
			AccessLevel level = ann.access();
			if (level == AccessLevel.NONE) return;
			String staticName = ann.staticName();
			if (annotation.isExplicit(""suppressConstructorProperties"")) {
				annotationNode.addError(""This deprecated feature is no longer supported. Remove it; you can create a lombok.config file with 'lombok.anyConstructor.suppressConstructorProperties = true'."");
			}
			handleConstructor.generateConstructor(typeNode, level, onConstructor, findAllFields(typeNode), false, staticName, SkipIfConstructorExists.NO, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 2003 46 334 46 2006 40 41 59 437 2007 2008 61 418 2007 40 41 59 64 2009 439 492 2010 40 2011 60 2003 62 2012 44 2013 2014 44 2015 2016 41 123 2017 40 2016 44 2018 46 2019 44 648 44 2018 46 2020 44 648 41 59 2021 40 2016 44 2003 46 334 41 59 2022 40 2016 44 648 41 59 2015 2023 61 2016 46 2024 40 41 59 392 40 33 2025 40 2023 44 2016 44 2005 41 41 450 59 2026 60 2013 62 2027 61 2028 40 2014 44 648 44 648 44 2016 41 59 2003 2029 61 2012 46 2030 40 41 59 2031 2032 61 2029 46 2033 40 41 59 392 40 2032 614 2031 46 2034 41 450 59 2004 2035 61 2029 46 2035 40 41 59 392 40 2012 46 2036 40 648 41 41 123 2016 46 2037 40 648 41 59 125 2008 46 2038 40 2023 44 2032 44 2027 44 2039 40 2023 41 44 380 44 2035 44 2040 46 2041 44 2016 41 59 125 125 
30514,Java,"	@Provides
	public static class HandleNoArgsConstructor extends JavacAnnotationHandler<NoArgsConstructor> {
		private static final String NAME = NoArgsConstructor.class.getSimpleName();
		private HandleConstructor handleConstructor = new HandleConstructor();
		
		@Override public void handle(AnnotationValues<NoArgsConstructor> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.NO_ARGS_CONSTRUCTOR_FLAG_USAGE, ""@NoArgsConstructor"", ConfigurationKeys.ANY_CONSTRUCTOR_FLAG_USAGE, ""any @xArgsConstructor"");
			
			deleteAnnotationIfNeccessary(annotationNode, NoArgsConstructor.class);
			deleteImportFromCompilationUnit(annotationNode, ""lombok.AccessLevel"");
			JavacNode typeNode = annotationNode.up();
			if (!checkLegality(typeNode, annotationNode, NAME)) return;
			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, ""onConstructor"", ""@NoArgsConstructor(onConstructor"", annotationNode);
			NoArgsConstructor ann = annotation.getInstance();
			AccessLevel level = ann.access();
			if (level == AccessLevel.NONE) return;
			String staticName = ann.staticName();
			boolean force = ann.force();
			handleConstructor.generateConstructor(typeNode, level, onConstructor, List.<JavacNode>nil(), force, staticName, SkipIfConstructorExists.NO, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 2003 46 334 46 2006 40 41 59 437 2007 2008 61 418 2007 40 41 59 64 2009 439 492 2010 40 2011 60 2003 62 2012 44 2013 2014 44 2015 2016 41 123 2017 40 2016 44 2018 46 2019 44 648 44 2018 46 2020 44 648 41 59 2021 40 2016 44 2003 46 334 41 59 2022 40 2016 44 648 41 59 2015 2023 61 2016 46 2024 40 41 59 392 40 33 2025 40 2023 44 2016 44 2005 41 41 450 59 2026 60 2013 62 2027 61 2028 40 2014 44 648 44 648 44 2016 41 59 2003 2029 61 2012 46 2030 40 41 59 2031 2032 61 2029 46 2033 40 41 59 392 40 2032 614 2031 46 2034 41 450 59 2004 2035 61 2029 46 2035 40 41 59 324 2036 61 2029 46 2036 40 41 59 2008 46 2037 40 2023 44 2032 44 2027 44 2026 46 60 2015 62 2038 40 41 44 2036 44 2035 44 2039 46 2040 44 2016 41 59 125 125 
30515,Java,"	@Provides
	public static class HandleRequiredArgsConstructor extends JavacAnnotationHandler<RequiredArgsConstructor> {
		private static final String NAME = RequiredArgsConstructor.class.getSimpleName();
		private HandleConstructor handleConstructor = new HandleConstructor();
		
		@Override public void handle(AnnotationValues<RequiredArgsConstructor> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.REQUIRED_ARGS_CONSTRUCTOR_FLAG_USAGE, ""@RequiredArgsConstructor"", ConfigurationKeys.ANY_CONSTRUCTOR_FLAG_USAGE, ""any @xArgsConstructor"");
			
			deleteAnnotationIfNeccessary(annotationNode, RequiredArgsConstructor.class);
			deleteImportFromCompilationUnit(annotationNode, ""lombok.AccessLevel"");
			JavacNode typeNode = annotationNode.up();
			if (!checkLegality(typeNode, annotationNode, NAME)) return;
			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, ""onConstructor"", ""@RequiredArgsConstructor(onConstructor"", annotationNode);
			RequiredArgsConstructor ann = annotation.getInstance();
			AccessLevel level = ann.access();
			if (level == AccessLevel.NONE) return;
			String staticName = ann.staticName();
			if (annotation.isExplicit(""suppressConstructorProperties"")) {
				annotationNode.addError(""This deprecated feature is no longer supported. Remove it; you can create a lombok.config file with 'lombok.anyConstructor.suppressConstructorProperties = true'."");
			}
			
			handleConstructor.generateConstructor(typeNode, level, onConstructor, findRequiredFields(typeNode), false, staticName, SkipIfConstructorExists.NO, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 2003 46 334 46 2006 40 41 59 437 2007 2008 61 418 2007 40 41 59 64 2009 439 492 2010 40 2011 60 2003 62 2012 44 2013 2014 44 2015 2016 41 123 2017 40 2016 44 2018 46 2019 44 648 44 2018 46 2020 44 648 41 59 2021 40 2016 44 2003 46 334 41 59 2022 40 2016 44 648 41 59 2015 2023 61 2016 46 2024 40 41 59 392 40 33 2025 40 2023 44 2016 44 2005 41 41 450 59 2026 60 2013 62 2027 61 2028 40 2014 44 648 44 648 44 2016 41 59 2003 2029 61 2012 46 2030 40 41 59 2031 2032 61 2029 46 2033 40 41 59 392 40 2032 614 2031 46 2034 41 450 59 2004 2035 61 2029 46 2035 40 41 59 392 40 2012 46 2036 40 648 41 41 123 2016 46 2037 40 648 41 59 125 2008 46 2038 40 2023 44 2032 44 2027 44 2039 40 2023 41 44 380 44 2035 44 2040 46 2041 44 2016 41 59 125 125 
30504,Java,"	private static class MarkingScanner extends TreeScanner {
		private final JavacNode source;
		
		MarkingScanner(JavacNode source) {
			this.source = source;
		}
		
		@Override public void scan(JCTree tree) {
			if (tree == null) return;
			setGeneratedBy(tree, source);
			super.scan(tree);
		}
	}",0,437 457 334 2000 378 2001 123 437 381 2002 2003 59 2000 40 2002 2003 41 123 467 46 2003 61 2003 59 125 64 2004 439 492 2005 40 2006 2007 41 123 392 40 2007 614 424 41 450 59 2008 40 2007 44 2003 41 59 463 46 2005 40 2007 41 59 125 125 
30817,Java,"	@Provides
	public static class HandleJBossLog extends JavacAnnotationHandler<lombok.extern.jbosslog.JBossLog> {
		@Override public void handle(AnnotationValues<lombok.extern.jbosslog.JBossLog> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_JBOSSLOG_FLAG_USAGE, ""@JBossLog"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.JBOSSLOG, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
30821,Java,"	@Provides
	public static class HandleSlf4jLog extends JavacAnnotationHandler<lombok.extern.slf4j.Slf4j> {
		@Override public void handle(AnnotationValues<lombok.extern.slf4j.Slf4j> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_SLF4J_FLAG_USAGE, ""@Slf4j"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.SLF4J, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
30830,Java,"		VERBATIM {
			@Override public String apply(final EclipseNode node) {
				return getDocComment(node);
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 41 123 450 2006 40 2005 41 59 125 125 44 
30386,Java,"public class SuperBuilderWithDefaultsAndTargetTyping {
	@lombok.experimental.SuperBuilder
	public static class Parent {
		@lombok.Builder.Default private String foo = doSth(Arrays.asList(1), Arrays.asList('a'));
	}
	
	@lombok.experimental.SuperBuilder
	public static class Child extends Parent {
		@lombok.Builder.Default private String foo = doSth(Arrays.asList(1), Arrays.asList('a'));
	}
	
	static String doSth(java.util.List<Integer> i, java.util.List<Character> c) {
		return null;
	}
}",0,439 334 2000 123 64 2001 46 2002 46 2003 439 457 334 2004 123 64 2001 46 2005 46 2006 437 2007 2008 61 2009 40 2010 46 2011 40 1501 41 44 2010 46 2011 40 607 41 41 59 125 64 2001 46 2002 46 2003 439 457 334 2012 378 2004 123 64 2001 46 2013 46 2014 437 2015 2016 61 2017 40 2018 46 2019 40 1501 41 44 2018 46 2019 40 607 41 41 59 125 457 2020 2021 40 2022 46 2023 46 2024 60 2025 62 2026 44 2022 46 2023 46 2024 60 2027 62 2028 41 123 450 424 59 125 125 
29778,Java,"@Builder
public class BuilderDefaultsTargetTyping {
	@Builder.Default 
	String foo = doSth(Arrays.asList(1), Arrays.asList('a'));
	
	static String doSth(java.util.List<Integer> i, java.util.List<Character> c) {
		return null;
	}
}",0,64 2000 439 334 2001 123 64 2000 46 2002 2003 2004 61 2005 40 2006 46 2007 40 1501 41 44 2006 46 2007 40 607 41 41 59 457 2003 2005 40 2008 46 2009 46 2010 60 2011 62 2012 44 2008 46 2009 46 2010 60 2013 62 2014 41 123 450 424 59 125 125 
30940,Java,"    public static abstract @java.lang.SuppressWarnings(""all"") class ChildBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Child, B extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
      private @java.lang.SuppressWarnings(""all"") String foo$value;
      private @java.lang.SuppressWarnings(""all"") boolean foo$set;
      public ChildBuilder() {
        super();
      }
      protected abstract @java.lang.Override @java.lang.SuppressWarnings(""all"") B self();
      public abstract @java.lang.Override @java.lang.SuppressWarnings(""all"") C build();
      /**
       * @return {@code this}.
       */
      public @java.lang.SuppressWarnings(""all"") B foo(final String foo) {
        this.foo$value = foo;
        foo$set = true;
        return self();
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((((""SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder(super="" + super.toString()) + "", foo$value="") + this.foo$value) + "")"");
      }
    }",0,439 457 305 64 2000 46 2001 46 2002 40 648 41 334 2003 60 2004 378 2005 46 2006 44 2007 378 2005 46 2006 46 2003 60 2004 44 2007 641 378 2008 46 2009 60 2004 44 2007 62 123 437 64 2000 46 2001 46 2002 40 648 41 2010 2011 36 2012 59 437 64 2000 46 2001 46 2002 40 648 41 324 2011 36 2013 59 439 2003 40 41 123 463 40 41 59 125 438 305 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 2007 2015 40 41 59 439 305 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 2004 2016 40 41 59 618 439 64 2000 46 2001 46 2002 40 648 41 2007 2011 40 381 2010 2011 41 123 467 46 2011 36 2012 61 2011 59 2011 36 2013 61 473 59 450 2015 40 41 59 125 439 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 2000 46 2001 46 2010 2017 40 41 123 450 40 40 40 40 648 43 463 46 2017 40 41 41 43 648 41 43 467 46 2011 36 2012 41 43 648 41 59 125 125 
30942,Java,"  public static @lombok.experimental.SuperBuilder class Child extends Parent {
    public static abstract @java.lang.SuppressWarnings(""all"") class ChildBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Child, B extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
      private @java.lang.SuppressWarnings(""all"") String foo$value;
      private @java.lang.SuppressWarnings(""all"") boolean foo$set;
      public ChildBuilder() {
        super();
      }
      protected abstract @java.lang.Override @java.lang.SuppressWarnings(""all"") B self();
      public abstract @java.lang.Override @java.lang.SuppressWarnings(""all"") C build();
      /**
       * @return {@code this}.
       */
      public @java.lang.SuppressWarnings(""all"") B foo(final String foo) {
        this.foo$value = foo;
        foo$set = true;
        return self();
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((((""SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder(super="" + super.toString()) + "", foo$value="") + this.foo$value) + "")"");
      }
    }
    private static final @java.lang.SuppressWarnings(""all"") class ChildBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<SuperBuilderWithDefaultsAndTargetTyping.Child, SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl> {
      private ChildBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Child(this);
      }
    }
    private @lombok.Builder.Default String foo;
    private static @java.lang.SuppressWarnings(""all"") String $default$foo() {
      return doSth(Arrays.asList(1), Arrays.asList('a'));
    }
    protected @java.lang.SuppressWarnings(""all"") Child(final SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> b) {
      super(b);
      if (b.foo$set)
          this.foo = b.foo$value;
      else
          this.foo = SuperBuilderWithDefaultsAndTargetTyping.Child.$default$foo();
    }
    public static @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> builder() {
      return new SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl();
    }
  }",0,439 457 64 2000 46 2001 46 2002 334 2003 378 2004 123 439 457 305 64 2005 46 2006 46 2007 40 648 41 334 2008 60 2009 378 2010 46 2003 44 2011 378 2010 46 2003 46 2008 60 2009 44 2011 641 378 2004 46 2012 60 2009 44 2011 62 123 437 64 2005 46 2006 46 2007 40 648 41 2013 2014 36 2015 59 437 64 2005 46 2006 46 2007 40 648 41 324 2014 36 2016 59 439 2008 40 41 123 463 40 41 59 125 438 305 64 2005 46 2006 46 2017 64 2005 46 2006 46 2007 40 648 41 2011 2018 40 41 59 439 305 64 2005 46 2006 46 2017 64 2005 46 2006 46 2007 40 648 41 2009 2019 40 41 59 618 439 64 2005 46 2006 46 2007 40 648 41 2011 2014 40 381 2013 2014 41 123 467 46 2014 36 2015 61 2014 59 2014 36 2016 61 473 59 450 2018 40 41 59 125 439 64 2005 46 2006 46 2017 64 2005 46 2006 46 2007 40 648 41 2005 46 2006 46 2013 2020 40 41 123 450 40 40 40 40 648 43 463 46 2020 40 41 41 43 648 41 43 467 46 2014 36 2015 41 43 648 41 59 125 125 437 457 381 64 2005 46 2006 46 2007 40 648 41 334 2021 378 2010 46 2003 46 2008 60 2010 46 2003 44 2010 46 2003 46 2021 62 123 437 2021 40 41 123 463 40 41 59 125 438 64 2005 46 2006 46 2022 64 2005 46 2006 46 2007 40 648 41 2010 46 2003 46 2021 2023 40 41 123 450 467 59 125 439 64 2005 46 2006 46 2022 64 2005 46 2006 46 2007 40 648 41 2010 46 2003 2024 40 41 123 450 418 2010 46 2003 40 467 41 59 125 125 437 64 2000 46 2025 46 2026 2027 2028 59 437 457 64 2005 46 2006 46 2007 40 648 41 2027 36 349 36 2028 40 41 123 450 2029 40 2030 46 2031 40 1501 41 44 2030 46 2031 40 607 41 41 59 125 438 64 2005 46 2006 46 2007 40 648 41 2003 40 381 2010 46 2003 46 2008 60 63 44 63 62 2032 41 123 463 40 2032 41 59 392 40 2032 46 2028 36 2033 41 467 46 2028 61 2032 46 2028 36 2034 59 360 467 46 2028 61 2010 46 2003 46 36 349 36 2028 40 41 59 125 439 457 64 2005 46 2006 46 2007 40 648 41 2010 46 2003 46 2008 60 63 44 63 62 2035 40 41 123 450 418 2010 46 2003 46 2021 40 41 59 125 125 
30578,Java,"public class ValInvalidParameter {
	public void val() {
		val a = a(new NonExistingClass());
		val b = a(a(new NonExistingClass()));
		val c = nonExisitingMethod(b(1));
		val d = nonExistingObject.nonExistingMethod();
		val e = b(1).nonExistingMethod();
		val f = 1 > 2 ? a(new NonExistingClass()) : a(new NonExistingClass());
		val g = b2(1);
		val h = b2(a(""a""), a(null));
		val i = a(a(null));
	}
	
	public int a(String param) {
		return 0;
	}
	
	public int a(Integer param) {
		return 0;
	}
	
	public Integer b(int i) {
		return i;
	}
	
	public Integer b2(int i, int j) {
		return i;
	}
}",0,439 334 2000 123 439 492 2001 40 41 123 2001 2002 61 2002 40 418 2003 40 41 41 59 2001 2004 61 2002 40 2002 40 418 2003 40 41 41 41 59 2001 2005 61 2006 40 2004 40 1501 41 41 59 2001 2007 61 2008 46 2009 40 41 59 2001 2010 61 2004 40 1501 41 46 2009 40 41 59 2001 2011 61 1501 62 1502 63 2002 40 418 2003 40 41 41 58 2002 40 418 2003 40 41 41 59 2001 2012 61 2013 40 1501 41 59 2001 2014 61 2013 40 2002 40 648 41 44 2002 40 424 41 41 59 2001 2015 61 2002 40 2002 40 424 41 41 59 125 439 404 2016 40 2017 2018 41 123 450 1500 59 125 439 404 2016 40 2019 2018 41 123 450 1500 59 125 439 2019 2020 40 404 2021 41 123 450 2021 59 125 439 2019 2022 40 404 2021 44 404 2023 41 123 450 2021 59 125 125 
30838,Java,"				values.put(name, new AnnotationValue(annotationNode, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {
					@Override public void setError(String message, int valueIdx) {
						annotationNode.addError(message);
					}
					@Override public void setWarning(String message, int valueIdx) {
						annotationNode.addWarning(message);
					}
				});",0,2000 46 2001 40 2002 44 418 2003 40 2004 44 418 2005 60 2006 62 40 41 44 418 2005 60 2007 62 40 41 44 418 2005 60 2007 62 40 41 44 380 41 123 64 2008 439 492 2009 40 2006 2010 44 404 2011 41 123 2004 46 2012 40 2010 41 59 125 64 2008 439 492 2013 40 2006 2010 44 404 2011 41 123 2004 46 2014 40 2010 41 59 125 125 41 59 
30946,Java,"public class SuperBuilderWithDefaultsAndTargetTyping {
  public static @lombok.experimental.SuperBuilder class Parent {
    public static abstract @java.lang.SuppressWarnings(""all"") class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
      private @java.lang.SuppressWarnings(""all"") String foo$value;
      private @java.lang.SuppressWarnings(""all"") boolean foo$set;
      public ParentBuilder() {
        super();
      }
      protected abstract @java.lang.SuppressWarnings(""all"") B self();
      public abstract @java.lang.SuppressWarnings(""all"") C build();
      /**
       * @return {@code this}.
       */
      public @java.lang.SuppressWarnings(""all"") B foo(final String foo) {
        this.foo$value = foo;
        foo$set = true;
        return self();
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value) + "")"");
      }
    }
    private static final @java.lang.SuppressWarnings(""all"") class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
      private ParentBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
      }
    }
    private @lombok.Builder.Default String foo;
    private static @java.lang.SuppressWarnings(""all"") String $default$foo() {
      return doSth(Arrays.asList(1), Arrays.asList('a'));
    }
    protected @java.lang.SuppressWarnings(""all"") Parent(final SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> b) {
      super();
      if (b.foo$set)
          this.foo = b.foo$value;
      else
          this.foo = SuperBuilderWithDefaultsAndTargetTyping.Parent.$default$foo();
    }
    public static @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> builder() {
      return new SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl();
    }
  }
  public static @lombok.experimental.SuperBuilder class Child extends Parent {
    public static abstract @java.lang.SuppressWarnings(""all"") class ChildBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Child, B extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
      private @java.lang.SuppressWarnings(""all"") String foo$value;
      private @java.lang.SuppressWarnings(""all"") boolean foo$set;
      public ChildBuilder() {
        super();
      }
      protected abstract @java.lang.Override @java.lang.SuppressWarnings(""all"") B self();
      public abstract @java.lang.Override @java.lang.SuppressWarnings(""all"") C build();
      /**
       * @return {@code this}.
       */
      public @java.lang.SuppressWarnings(""all"") B foo(final String foo) {
        this.foo$value = foo;
        foo$set = true;
        return self();
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((((""SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder(super="" + super.toString()) + "", foo$value="") + this.foo$value) + "")"");
      }
    }
    private static final @java.lang.SuppressWarnings(""all"") class ChildBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<SuperBuilderWithDefaultsAndTargetTyping.Child, SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl> {
      private ChildBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Child(this);
      }
    }
    private @lombok.Builder.Default String foo;
    private static @java.lang.SuppressWarnings(""all"") String $default$foo() {
      return doSth(Arrays.asList(1), Arrays.asList('a'));
    }
    protected @java.lang.SuppressWarnings(""all"") Child(final SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> b) {
      super(b);
      if (b.foo$set)
          this.foo = b.foo$value;
      else
          this.foo = SuperBuilderWithDefaultsAndTargetTyping.Child.$default$foo();
    }
    public static @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> builder() {
      return new SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl();
    }
  }
  public SuperBuilderWithDefaultsAndTargetTyping() {
    super();
  }
  static String doSth(java.util.List<Integer> i, java.util.List<Character> c) {
    return null;
  }
}",0,439 334 2000 123 439 457 64 2001 46 2002 46 2003 334 2004 123 439 457 305 64 2005 46 2006 46 2007 40 648 41 334 2008 60 2009 378 2000 46 2004 44 2010 378 2000 46 2004 46 2008 60 2009 44 2010 641 123 437 64 2005 46 2006 46 2007 40 648 41 2011 2012 36 2013 59 437 64 2005 46 2006 46 2007 40 648 41 324 2012 36 2014 59 439 2008 40 41 123 463 40 41 59 125 438 305 64 2005 46 2006 46 2007 40 648 41 2010 2015 40 41 59 439 305 64 2005 46 2006 46 2007 40 648 41 2009 2016 40 41 59 618 439 64 2005 46 2006 46 2007 40 648 41 2010 2012 40 381 2011 2012 41 123 467 46 2012 36 2013 61 2012 59 2012 36 2014 61 473 59 450 2015 40 41 59 125 439 64 2005 46 2006 46 2017 64 2005 46 2006 46 2007 40 648 41 2005 46 2006 46 2011 2018 40 41 123 450 40 40 648 43 467 46 2012 36 2013 41 43 648 41 59 125 125 437 457 381 64 2005 46 2006 46 2007 40 648 41 334 2019 378 2000 46 2004 46 2008 60 2000 46 2004 44 2000 46 2004 46 2019 62 123 437 2019 40 41 123 463 40 41 59 125 438 64 2005 46 2006 46 2020 64 2005 46 2006 46 2007 40 648 41 2000 46 2004 46 2019 2021 40 41 123 450 467 59 125 439 64 2005 46 2006 46 2020 64 2005 46 2006 46 2007 40 648 41 2000 46 2004 2022 40 41 123 450 418 2000 46 2004 40 467 41 59 125 125 437 64 2001 46 2023 46 2024 2025 2026 59 437 457 64 2005 46 2006 46 2007 40 648 41 2025 36 349 36 2026 40 41 123 450 2027 40 2028 46 2029 40 1501 41 44 2028 46 2029 40 607 41 41 59 125 438 64 2005 46 2006 46 2007 40 648 41 2004 40 381 2000 46 2004 46 2008 60 63 44 63 62 2030 41 123 463 40 41 59 392 40 2030 46 2026 36 2031 41 467 46 2026 61 2030 46 2026 36 2032 59 360 467 46 2026 61 2000 46 2004 46 36 349 36 2026 40 41 59 125 439 457 64 2005 46 2006 46 2007 40 648 41 2000 46 2004 46 2008 60 63 44 63 62 2033 40 41 123 450 418 2000 46 2004 46 2019 40 41 59 125 125 439 457 64 2001 46 2002 46 2003 334 2034 378 2004 123 439 457 305 64 2035 46 2036 46 2037 40 648 41 334 2038 60 2039 378 2000 46 2034 44 2040 378 2000 46 2034 46 2038 60 2039 44 2040 641 378 2004 46 2041 60 2039 44 2040 62 123 437 64 2035 46 2036 46 2037 40 648 41 2042 2043 36 2044 59 437 64 2035 46 2036 46 2037 40 648 41 324 2043 36 2045 59 439 2038 40 41 123 463 40 41 59 125 438 305 64 2035 46 2036 46 2046 64 2035 46 2036 46 2037 40 648 41 2040 2047 40 41 59 439 305 64 2035 46 2036 46 2046 64 2035 46 2036 46 2037 40 648 41 2039 2048 40 41 59 618 439 64 2035 46 2036 46 2037 40 648 41 2040 2043 40 381 2042 2043 41 123 467 46 2043 36 2044 61 2043 59 2043 36 2045 61 473 59 450 2047 40 41 59 125 439 64 2035 46 2036 46 2046 64 2035 46 2036 46 2037 40 648 41 2035 46 2036 46 2042 2049 40 41 123 450 40 40 40 40 648 43 463 46 2049 40 41 41 43 648 41 43 467 46 2043 36 2044 41 43 648 41 59 125 125 437 457 381 64 2035 46 2036 46 2037 40 648 41 334 2050 378 2000 46 2034 46 2038 60 2000 46 2034 44 2000 46 2034 46 2050 62 123 437 2050 40 41 123 463 40 41 59 125 438 64 2035 46 2036 46 2051 64 2035 46 2036 46 2037 40 648 41 2000 46 2034 46 2050 2052 40 41 123 450 467 59 125 439 64 2035 46 2036 46 2051 64 2035 46 2036 46 2037 40 648 41 2000 46 2034 2053 40 41 123 450 418 2000 46 2034 40 467 41 59 125 125 437 64 2001 46 2054 46 2055 2056 2057 59 437 457 64 2035 46 2036 46 2037 40 648 41 2056 36 349 36 2057 40 41 123 450 2058 40 2059 46 2060 40 1501 41 44 2059 46 2060 40 607 41 41 59 125 438 64 2035 46 2036 46 2037 40 648 41 2034 40 381 2000 46 2034 46 2038 60 63 44 63 62 2061 41 123 463 40 2061 41 59 392 40 2061 46 2057 36 2062 41 467 46 2057 61 2061 46 2057 36 2063 59 360 467 46 2057 61 2000 46 2034 46 36 349 36 2057 40 41 59 125 439 457 64 2035 46 2036 46 2037 40 648 41 2000 46 2034 46 2038 60 63 44 63 62 2064 40 41 123 450 418 2000 46 2034 46 2050 40 41 59 125 125 439 2000 40 41 123 463 40 41 59 125 457 2065 2066 40 2067 46 2068 46 2069 60 2070 62 2071 44 2067 46 2068 46 2069 60 2072 62 2073 41 123 450 424 59 125 125 
29526,Java,"  public static @java.lang.SuppressWarnings(""all"") class BuilderDefaultsTargetTypingBuilder {
    private @java.lang.SuppressWarnings(""all"") String foo$value;
    private @java.lang.SuppressWarnings(""all"") boolean foo$set;
    @java.lang.SuppressWarnings(""all"") BuilderDefaultsTargetTypingBuilder() {
      super();
    }
    /**
     * @return {@code this}.
     */
    public @java.lang.SuppressWarnings(""all"") BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder foo(final String foo) {
      this.foo$value = foo;
      foo$set = true;
      return this;
    }
    public @java.lang.SuppressWarnings(""all"") BuilderDefaultsTargetTyping build() {
      String foo$value = this.foo$value;
      if ((! this.foo$set))
          foo$value = BuilderDefaultsTargetTyping.$default$foo();
      return new BuilderDefaultsTargetTyping(foo$value);
    }
    public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
      return ((""BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder(foo$value="" + this.foo$value) + "")"");
    }
  }",0,439 457 64 2000 46 2001 46 2002 40 648 41 334 2003 123 437 64 2000 46 2001 46 2002 40 648 41 2004 2005 36 2006 59 437 64 2000 46 2001 46 2002 40 648 41 324 2005 36 2007 59 64 2000 46 2001 46 2002 40 648 41 2003 40 41 123 463 40 41 59 125 618 439 64 2000 46 2001 46 2002 40 648 41 2008 46 2003 2005 40 381 2004 2005 41 123 467 46 2005 36 2006 61 2005 59 2005 36 2007 61 473 59 450 467 59 125 439 64 2000 46 2001 46 2002 40 648 41 2008 2009 40 41 123 2004 2005 36 2006 61 467 46 2005 36 2006 59 392 40 40 33 467 46 2005 36 2007 41 41 2005 36 2006 61 2008 46 36 349 36 2005 40 41 59 450 418 2008 40 2005 36 2006 41 59 125 439 64 2000 46 2001 46 2010 64 2000 46 2001 46 2002 40 648 41 2000 46 2001 46 2004 2011 40 41 123 450 40 40 648 43 467 46 2005 36 2006 41 43 648 41 59 125 125 
29527,Java,"public @Builder class BuilderDefaultsTargetTyping {
  public static @java.lang.SuppressWarnings(""all"") class BuilderDefaultsTargetTypingBuilder {
    private @java.lang.SuppressWarnings(""all"") String foo$value;
    private @java.lang.SuppressWarnings(""all"") boolean foo$set;
    @java.lang.SuppressWarnings(""all"") BuilderDefaultsTargetTypingBuilder() {
      super();
    }
    /**
     * @return {@code this}.
     */
    public @java.lang.SuppressWarnings(""all"") BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder foo(final String foo) {
      this.foo$value = foo;
      foo$set = true;
      return this;
    }
    public @java.lang.SuppressWarnings(""all"") BuilderDefaultsTargetTyping build() {
      String foo$value = this.foo$value;
      if ((! this.foo$set))
          foo$value = BuilderDefaultsTargetTyping.$default$foo();
      return new BuilderDefaultsTargetTyping(foo$value);
    }
    public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
      return ((""BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder(foo$value="" + this.foo$value) + "")"");
    }
  }
  @Builder.Default String foo;
  static String doSth(java.util.List<Integer> i, java.util.List<Character> c) {
    return null;
  }
  private static @java.lang.SuppressWarnings(""all"") String $default$foo() {
    return doSth(Arrays.asList(1), Arrays.asList('a'));
  }
  @java.lang.SuppressWarnings(""all"") BuilderDefaultsTargetTyping(final String foo) {
    super();
    this.foo = foo;
  }
  public static @java.lang.SuppressWarnings(""all"") BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder builder() {
    return new BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder();
  }
}",0,439 64 2000 334 2001 123 439 457 64 2002 46 2003 46 2004 40 648 41 334 2005 123 437 64 2002 46 2003 46 2004 40 648 41 2006 2007 36 2008 59 437 64 2002 46 2003 46 2004 40 648 41 324 2007 36 2009 59 64 2002 46 2003 46 2004 40 648 41 2005 40 41 123 463 40 41 59 125 618 439 64 2002 46 2003 46 2004 40 648 41 2001 46 2005 2007 40 381 2006 2007 41 123 467 46 2007 36 2008 61 2007 59 2007 36 2009 61 473 59 450 467 59 125 439 64 2002 46 2003 46 2004 40 648 41 2001 2010 40 41 123 2006 2007 36 2008 61 467 46 2007 36 2008 59 392 40 40 33 467 46 2007 36 2009 41 41 2007 36 2008 61 2001 46 36 349 36 2007 40 41 59 450 418 2001 40 2007 36 2008 41 59 125 439 64 2002 46 2003 46 2011 64 2002 46 2003 46 2004 40 648 41 2002 46 2003 46 2006 2012 40 41 123 450 40 40 648 43 467 46 2007 36 2008 41 43 648 41 59 125 125 64 2000 46 2013 2014 2015 59 457 2014 2016 40 2002 46 2017 46 2018 60 2019 62 2020 44 2002 46 2017 46 2018 60 2021 62 2022 41 123 450 424 59 125 437 457 64 2002 46 2003 46 2004 40 648 41 2014 36 349 36 2015 40 41 123 450 2016 40 2023 46 2024 40 1501 41 44 2023 46 2024 40 607 41 41 59 125 64 2002 46 2003 46 2004 40 648 41 2001 40 381 2014 2015 41 123 463 40 41 59 467 46 2015 61 2015 59 125 439 457 64 2002 46 2003 46 2004 40 648 41 2001 46 2005 2025 40 41 123 450 418 2001 46 2005 40 41 59 125 125 
30695,Java,"		@java.lang.SuppressWarnings(""all"")
		public static abstract class ChildBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Child, B extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
			@java.lang.SuppressWarnings(""all"")
			private boolean foo$set;
			@java.lang.SuppressWarnings(""all"")
			private String foo$value;

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected abstract B self();

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public abstract C build();

			/**
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings(""all"")
			public B foo(final String foo) {
				this.foo$value = foo;
				foo$set = true;
				return self();
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder(super="" + super.toString() + "", foo$value="" + this.foo$value + "")"";
			}
		}",0,64 2000 46 2001 46 2002 40 648 41 439 457 305 334 2003 60 2004 378 2005 46 2006 44 2007 378 2005 46 2006 46 2003 60 2004 44 2007 641 378 2008 46 2009 60 2004 44 2007 62 123 64 2000 46 2001 46 2002 40 648 41 437 324 2010 36 2011 59 64 2000 46 2001 46 2002 40 648 41 437 2012 2010 36 2013 59 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 438 305 2007 2015 40 41 59 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 439 305 2004 2016 40 41 59 618 64 2000 46 2001 46 2002 40 648 41 439 2007 2010 40 381 2012 2010 41 123 467 46 2010 36 2013 61 2010 59 2010 36 2011 61 473 59 450 2015 40 41 59 125 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 439 2000 46 2001 46 2012 2017 40 41 123 450 648 43 463 46 2017 40 41 43 648 43 467 46 2010 36 2013 43 648 59 125 125 
30698,Java,"		@java.lang.SuppressWarnings(""all"")
		public static abstract class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
			@java.lang.SuppressWarnings(""all"")
			private boolean foo$set;
			@java.lang.SuppressWarnings(""all"")
			private String foo$value;

			@java.lang.SuppressWarnings(""all"")
			protected abstract B self();

			@java.lang.SuppressWarnings(""all"")
			public abstract C build();

			/**
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings(""all"")
			public B foo(final String foo) {
				this.foo$value = foo;
				foo$set = true;
				return self();
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value + "")"";
			}
		}",0,64 2000 46 2001 46 2002 40 648 41 439 457 305 334 2003 60 2004 378 2005 46 2006 44 2007 378 2005 46 2006 46 2003 60 2004 44 2007 641 123 64 2000 46 2001 46 2002 40 648 41 437 324 2008 36 2009 59 64 2000 46 2001 46 2002 40 648 41 437 2010 2008 36 2011 59 64 2000 46 2001 46 2002 40 648 41 438 305 2007 2012 40 41 59 64 2000 46 2001 46 2002 40 648 41 439 305 2004 2013 40 41 59 618 64 2000 46 2001 46 2002 40 648 41 439 2007 2008 40 381 2010 2008 41 123 467 46 2008 36 2011 61 2008 59 2008 36 2009 61 473 59 450 2012 40 41 59 125 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 439 2000 46 2001 46 2010 2015 40 41 123 450 648 43 467 46 2008 36 2011 43 648 59 125 125 
30699,Java,"		@java.lang.SuppressWarnings(""all"")
		private static final class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
			@java.lang.SuppressWarnings(""all"")
			private ParentBuilderImpl() {
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
				return this;
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
				return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
			}
		}",0,64 2000 46 2001 46 2002 40 648 41 437 457 381 334 2003 378 2004 46 2005 46 2006 60 2004 46 2005 44 2004 46 2005 46 2003 62 123 64 2000 46 2001 46 2002 40 648 41 437 2003 40 41 123 125 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 438 2004 46 2005 46 2003 2008 40 41 123 450 467 59 125 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 439 2004 46 2005 2009 40 41 123 450 418 2004 46 2005 40 467 41 59 125 125 
30701,Java,"public class SuperBuilderWithDefaultsAndTargetTyping {

	public static class Parent {
		private String foo;

		@java.lang.SuppressWarnings(""all"")
		private static String $default$foo() {
			return doSth(Arrays.asList(1), Arrays.asList('a'));
		}


		@java.lang.SuppressWarnings(""all"")
		public static abstract class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
			@java.lang.SuppressWarnings(""all"")
			private boolean foo$set;
			@java.lang.SuppressWarnings(""all"")
			private String foo$value;

			@java.lang.SuppressWarnings(""all"")
			protected abstract B self();

			@java.lang.SuppressWarnings(""all"")
			public abstract C build();

			/**
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings(""all"")
			public B foo(final String foo) {
				this.foo$value = foo;
				foo$set = true;
				return self();
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value + "")"";
			}
		}


		@java.lang.SuppressWarnings(""all"")
		private static final class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
			@java.lang.SuppressWarnings(""all"")
			private ParentBuilderImpl() {
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
				return this;
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
				return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
			}
		}

		@java.lang.SuppressWarnings(""all"")
		protected Parent(final SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> b) {
			if (b.foo$set) this.foo = b.foo$value;
			 else this.foo = SuperBuilderWithDefaultsAndTargetTyping.Parent.$default$foo();
		}

		@java.lang.SuppressWarnings(""all"")
		public static SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> builder() {
			return new SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl();
		}
	}


	public static class Child extends Parent {
		private String foo;

		@java.lang.SuppressWarnings(""all"")
		private static String $default$foo() {
			return doSth(Arrays.asList(1), Arrays.asList('a'));
		}


		@java.lang.SuppressWarnings(""all"")
		public static abstract class ChildBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Child, B extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
			@java.lang.SuppressWarnings(""all"")
			private boolean foo$set;
			@java.lang.SuppressWarnings(""all"")
			private String foo$value;

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected abstract B self();

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public abstract C build();

			/**
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings(""all"")
			public B foo(final String foo) {
				this.foo$value = foo;
				foo$set = true;
				return self();
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder(super="" + super.toString() + "", foo$value="" + this.foo$value + "")"";
			}
		}


		@java.lang.SuppressWarnings(""all"")
		private static final class ChildBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<SuperBuilderWithDefaultsAndTargetTyping.Child, SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl> {
			@java.lang.SuppressWarnings(""all"")
			private ChildBuilderImpl() {
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl self() {
				return this;
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public SuperBuilderWithDefaultsAndTargetTyping.Child build() {
				return new SuperBuilderWithDefaultsAndTargetTyping.Child(this);
			}
		}

		@java.lang.SuppressWarnings(""all"")
		protected Child(final SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> b) {
			super(b);
			if (b.foo$set) this.foo = b.foo$value;
			 else this.foo = SuperBuilderWithDefaultsAndTargetTyping.Child.$default$foo();
		}

		@java.lang.SuppressWarnings(""all"")
		public static SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> builder() {
			return new SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl();
		}
	}

	static String doSth(java.util.List<Integer> i, java.util.List<Character> c) {
		return null;
	}
}",0,439 334 2000 123 439 457 334 2001 123 437 2002 2003 59 64 2004 46 2005 46 2006 40 648 41 437 457 2002 36 349 36 2003 40 41 123 450 2007 40 2008 46 2009 40 1501 41 44 2008 46 2009 40 607 41 41 59 125 64 2004 46 2005 46 2006 40 648 41 439 457 305 334 2010 60 2011 378 2000 46 2001 44 2012 378 2000 46 2001 46 2010 60 2011 44 2012 641 123 64 2004 46 2005 46 2006 40 648 41 437 324 2003 36 2013 59 64 2004 46 2005 46 2006 40 648 41 437 2002 2003 36 2014 59 64 2004 46 2005 46 2006 40 648 41 438 305 2012 2015 40 41 59 64 2004 46 2005 46 2006 40 648 41 439 305 2011 2016 40 41 59 618 64 2004 46 2005 46 2006 40 648 41 439 2012 2003 40 381 2002 2003 41 123 467 46 2003 36 2014 61 2003 59 2003 36 2013 61 473 59 450 2015 40 41 59 125 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 439 2004 46 2005 46 2002 2018 40 41 123 450 648 43 467 46 2003 36 2014 43 648 59 125 125 64 2004 46 2005 46 2006 40 648 41 437 457 381 334 2019 378 2000 46 2001 46 2010 60 2000 46 2001 44 2000 46 2001 46 2019 62 123 64 2004 46 2005 46 2006 40 648 41 437 2019 40 41 123 125 64 2004 46 2005 46 2020 64 2004 46 2005 46 2006 40 648 41 438 2000 46 2001 46 2019 2021 40 41 123 450 467 59 125 64 2004 46 2005 46 2020 64 2004 46 2005 46 2006 40 648 41 439 2000 46 2001 2022 40 41 123 450 418 2000 46 2001 40 467 41 59 125 125 64 2004 46 2005 46 2006 40 648 41 438 2001 40 381 2000 46 2001 46 2010 60 63 44 63 62 2023 41 123 392 40 2023 46 2003 36 2024 41 467 46 2003 61 2023 46 2003 36 2025 59 360 467 46 2003 61 2000 46 2001 46 36 349 36 2003 40 41 59 125 64 2004 46 2005 46 2006 40 648 41 439 457 2000 46 2001 46 2010 60 63 44 63 62 2026 40 41 123 450 418 2000 46 2001 46 2019 40 41 59 125 125 439 457 334 2027 378 2001 123 437 2028 2029 59 64 2030 46 2031 46 2032 40 648 41 437 457 2028 36 349 36 2029 40 41 123 450 2033 40 2034 46 2035 40 1501 41 44 2034 46 2035 40 607 41 41 59 125 64 2030 46 2031 46 2032 40 648 41 439 457 305 334 2036 60 2037 378 2000 46 2027 44 2038 378 2000 46 2027 46 2036 60 2037 44 2038 641 378 2001 46 2039 60 2037 44 2038 62 123 64 2030 46 2031 46 2032 40 648 41 437 324 2029 36 2040 59 64 2030 46 2031 46 2032 40 648 41 437 2028 2029 36 2041 59 64 2030 46 2031 46 2042 64 2030 46 2031 46 2032 40 648 41 438 305 2038 2043 40 41 59 64 2030 46 2031 46 2042 64 2030 46 2031 46 2032 40 648 41 439 305 2037 2044 40 41 59 618 64 2030 46 2031 46 2032 40 648 41 439 2038 2029 40 381 2028 2029 41 123 467 46 2029 36 2041 61 2029 59 2029 36 2040 61 473 59 450 2043 40 41 59 125 64 2030 46 2031 46 2042 64 2030 46 2031 46 2032 40 648 41 439 2030 46 2031 46 2028 2045 40 41 123 450 648 43 463 46 2045 40 41 43 648 43 467 46 2029 36 2041 43 648 59 125 125 64 2030 46 2031 46 2032 40 648 41 437 457 381 334 2046 378 2000 46 2027 46 2036 60 2000 46 2027 44 2000 46 2027 46 2046 62 123 64 2030 46 2031 46 2032 40 648 41 437 2046 40 41 123 125 64 2030 46 2031 46 2047 64 2030 46 2031 46 2032 40 648 41 438 2000 46 2027 46 2046 2048 40 41 123 450 467 59 125 64 2030 46 2031 46 2047 64 2030 46 2031 46 2032 40 648 41 439 2000 46 2027 2049 40 41 123 450 418 2000 46 2027 40 467 41 59 125 125 64 2030 46 2031 46 2032 40 648 41 438 2027 40 381 2000 46 2027 46 2036 60 63 44 63 62 2050 41 123 463 40 2050 41 59 392 40 2050 46 2029 36 2051 41 467 46 2029 61 2050 46 2029 36 2052 59 360 467 46 2029 61 2000 46 2027 46 36 349 36 2029 40 41 59 125 64 2030 46 2031 46 2032 40 648 41 439 457 2000 46 2027 46 2036 60 63 44 63 62 2053 40 41 123 450 418 2000 46 2027 46 2046 40 41 59 125 125 457 2054 2055 40 2056 46 2057 46 2058 60 2059 62 2060 44 2056 46 2057 46 2058 60 2061 62 2062 41 123 450 424 59 125 125 
30645,Java,"	@Provides
	public static class HandleAllArgsConstructor extends EclipseAnnotationHandler<AllArgsConstructor> {
		private static final String NAME = AllArgsConstructor.class.getSimpleName();

		private HandleConstructor handleConstructor = new HandleConstructor();
		
		@Override public void handle(AnnotationValues<AllArgsConstructor> annotation, Annotation ast, EclipseNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.ALL_ARGS_CONSTRUCTOR_FLAG_USAGE, ""@AllArgsConstructor"", ConfigurationKeys.ANY_CONSTRUCTOR_FLAG_USAGE, ""any @xArgsConstructor"");
			
			EclipseNode typeNode = annotationNode.up();
			if (!checkLegality(typeNode, annotationNode, NAME)) return;
			AllArgsConstructor ann = annotation.getInstance();
			AccessLevel level = ann.access();
			if (level == AccessLevel.NONE) return;
			String staticName = ann.staticName();
			if (annotation.isExplicit(""suppressConstructorProperties"")) {
				annotationNode.addError(""This deprecated feature is no longer supported. Remove it; you can create a lombok.config file with 'lombok.anyConstructor.suppressConstructorProperties = true'."");
			}
			
			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, ""onConstructor"", ""@AllArgsConstructor(onConstructor"", annotationNode);
			
			handleConstructor.generateConstructor(
				typeNode, level, findAllFields(typeNode), false, staticName, SkipIfConstructorExists.NO,
				onConstructor, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 2003 46 334 46 2006 40 41 59 437 2007 2008 61 418 2007 40 41 59 64 2009 439 492 2010 40 2011 60 2003 62 2012 44 2013 2014 44 2015 2016 41 123 2017 40 2016 44 2018 46 2019 44 648 44 2018 46 2020 44 648 41 59 2015 2021 61 2016 46 2022 40 41 59 392 40 33 2023 40 2021 44 2016 44 2005 41 41 450 59 2003 2024 61 2012 46 2025 40 41 59 2026 2027 61 2024 46 2028 40 41 59 392 40 2027 614 2026 46 2029 41 450 59 2004 2030 61 2024 46 2030 40 41 59 392 40 2012 46 2031 40 648 41 41 123 2016 46 2032 40 648 41 59 125 2033 60 2013 62 2034 61 2035 40 2014 44 648 44 648 44 2016 41 59 2008 46 2036 40 2021 44 2027 44 2037 40 2021 41 44 380 44 2030 44 2038 46 2039 44 2034 44 2016 41 59 125 125 
30647,Java,"	@Provides
	public static class HandleRequiredArgsConstructor extends EclipseAnnotationHandler<RequiredArgsConstructor> {
		private static final String NAME = RequiredArgsConstructor.class.getSimpleName();
		private HandleConstructor handleConstructor = new HandleConstructor();
		
		@Override public void handle(AnnotationValues<RequiredArgsConstructor> annotation, Annotation ast, EclipseNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.REQUIRED_ARGS_CONSTRUCTOR_FLAG_USAGE, ""@RequiredArgsConstructor"", ConfigurationKeys.ANY_CONSTRUCTOR_FLAG_USAGE, ""any @xArgsConstructor"");
			
			EclipseNode typeNode = annotationNode.up();
			if (!checkLegality(typeNode, annotationNode, NAME)) return;
			RequiredArgsConstructor ann = annotation.getInstance();
			AccessLevel level = ann.access();
			if (level == AccessLevel.NONE) return;
			String staticName = ann.staticName();
			if (annotation.isExplicit(""suppressConstructorProperties"")) {
				annotationNode.addError(""This deprecated feature is no longer supported. Remove it; you can create a lombok.config file with 'lombok.anyConstructor.suppressConstructorProperties = true'."");
			}
			
			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, ""onConstructor"", ""@RequiredArgsConstructor(onConstructor"", annotationNode);
			
			handleConstructor.generateConstructor(
				typeNode, level, findRequiredFields(typeNode), false, staticName, SkipIfConstructorExists.NO,
				onConstructor, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 2003 46 334 46 2006 40 41 59 437 2007 2008 61 418 2007 40 41 59 64 2009 439 492 2010 40 2011 60 2003 62 2012 44 2013 2014 44 2015 2016 41 123 2017 40 2016 44 2018 46 2019 44 648 44 2018 46 2020 44 648 41 59 2015 2021 61 2016 46 2022 40 41 59 392 40 33 2023 40 2021 44 2016 44 2005 41 41 450 59 2003 2024 61 2012 46 2025 40 41 59 2026 2027 61 2024 46 2028 40 41 59 392 40 2027 614 2026 46 2029 41 450 59 2004 2030 61 2024 46 2030 40 41 59 392 40 2012 46 2031 40 648 41 41 123 2016 46 2032 40 648 41 59 125 2033 60 2013 62 2034 61 2035 40 2014 44 648 44 648 44 2016 41 59 2008 46 2036 40 2021 44 2027 44 2037 40 2021 41 44 380 44 2030 44 2038 46 2039 44 2034 44 2016 41 59 125 125 
30831,Java,"		GETTER {
			@Override public String apply(final EclipseNode node) {
				String javadoc = getDocComment(node);
				// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.
				String out = getJavadocSection(javadoc, ""GETTER"");
				final boolean sectionBased = out != null;
				if (!sectionBased) {
					out = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);
				}
				return out;
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 41 123 2002 2006 61 2007 40 2005 41 59 621 2002 430 61 2008 40 2006 44 648 41 59 381 324 2009 61 430 631 424 59 392 40 33 2009 41 123 430 61 2010 40 2011 40 2006 41 44 2012 46 2013 41 59 125 450 430 59 125 125 44 
29377,Java,"	private static final class FieldId<J> {
		private final Class<?> owner;
		private final String name;
		private final Class<J> fieldType;
		
		FieldId(Class<?> owner, String name, Class<J> fieldType) {
			this.owner = owner;
			this.name = name;
			this.fieldType = fieldType;
		}
	}",0,437 457 381 334 2000 60 2001 62 123 437 381 2002 60 63 62 2003 59 437 381 2004 2005 59 437 381 2002 60 2001 62 2006 59 2000 40 2002 60 63 62 2003 44 2004 2005 44 2002 60 2001 62 2006 41 123 467 46 2003 61 2003 59 467 46 2005 61 2005 59 467 46 2006 61 2006 59 125 125 
29379,Java,"	private static class SchroedingerType {
		final Object value;
		
		private SchroedingerType(Object value) {
			this.value = value;
		}
		
		@Override public int hashCode() {
			return value == null ? -1 : value.hashCode();
		}
		
		@Override public boolean equals(Object obj) {
			if (obj instanceof SchroedingerType) {
				Object other = ((SchroedingerType) obj).value;
				return value == null ? other == null : value.equals(other);
			}
			return false;
		}
		
		static Object getFieldCached(ConcurrentMap<String, Object> cache, String className, String fieldName) {
			Object value = cache.get(fieldName);
			if (value != null) return value;
			try {
				value = Permit.getField(Class.forName(className), fieldName).get(null);
			} catch (NoSuchFieldException e) {
				throw Javac.sneakyThrow(e);
			} catch (IllegalAccessException e) {
				throw Javac.sneakyThrow(e);
			} catch (ClassNotFoundException e) {
				throw Javac.sneakyThrow(e);
			}
			
			cache.putIfAbsent(fieldName, value);
			return value;
		}
		
		private static Field NOSUCHFIELDEX_MARKER;
		static {
			try {
				NOSUCHFIELDEX_MARKER = Permit.getField(SchroedingerType.class, ""NOSUCHFIELDEX_MARKER"");
			} catch (NoSuchFieldException e) {
				throw Javac.sneakyThrow(e);
			}
		}
		
		static Object getFieldCached(ConcurrentMap<Class<?>, Field> cache, Object ref, String fieldName) throws NoSuchFieldException {
			Class<?> c = ref.getClass();
			Field field = cache.get(c);
			if (field == null) {
				try {
					field = Permit.getField(c, fieldName);
				} catch (NoSuchFieldException e) {
					cache.putIfAbsent(c, NOSUCHFIELDEX_MARKER);
					throw Javac.sneakyThrow(e);
				}
				Permit.setAccessible(field);
				Field old = cache.putIfAbsent(c, field);
				if (old != null) field = old;
			}
			
			if (field == NOSUCHFIELDEX_MARKER) throw new NoSuchFieldException(fieldName);
			try {
				return field.get(ref);
			} catch (IllegalAccessException e) {
				throw Javac.sneakyThrow(e);
			}
		}
	}",0,437 457 334 2000 123 381 2001 2002 59 437 2000 40 2001 2002 41 123 467 46 2002 61 2002 59 125 64 2003 439 404 2004 40 41 123 450 2002 614 424 63 45 1501 58 2002 46 2004 40 41 59 125 64 2003 439 324 2005 40 2001 2006 41 123 392 40 2006 402 2000 41 123 2001 2007 61 40 40 2000 41 2006 41 46 2002 59 450 2002 614 424 63 2007 614 424 58 2002 46 2005 40 2007 41 59 125 450 380 59 125 457 2001 2008 40 2009 60 2010 44 2001 62 2011 44 2010 2012 44 2010 2013 41 123 2001 2002 61 2011 46 2014 40 2013 41 59 392 40 2002 631 424 41 450 2002 59 474 123 2002 61 2015 46 2016 40 2017 46 2018 40 2012 41 44 2013 41 46 2014 40 424 41 59 125 329 40 2019 2020 41 123 469 2021 46 2022 40 2020 41 59 125 329 40 2023 2020 41 123 469 2024 46 2025 40 2020 41 59 125 329 40 2026 2020 41 123 469 2027 46 2028 40 2020 41 59 125 2011 46 2029 40 2013 44 2002 41 59 450 2002 59 125 437 457 2030 2031 59 457 123 474 123 2031 61 2032 46 2033 40 2000 46 334 44 648 41 59 125 329 40 2034 2035 41 123 469 2036 46 2037 40 2035 41 59 125 125 457 2001 2008 40 2009 60 2038 60 63 62 44 2030 62 2011 44 2001 442 44 2010 2013 41 470 2039 123 2038 60 63 62 2040 61 442 46 2041 40 41 59 2030 2042 61 2011 46 2043 40 2040 41 59 392 40 2042 614 424 41 123 474 123 2042 61 2044 46 2045 40 2040 44 2013 41 59 125 329 40 2039 2046 41 123 2011 46 2047 40 2040 44 2031 41 59 469 2048 46 2049 40 2046 41 59 125 2050 46 2051 40 2042 41 59 2030 2052 61 2011 46 2053 40 2040 44 2042 41 59 392 40 2052 631 424 41 2042 61 2052 59 125 392 40 2042 614 2031 41 469 418 2039 40 2013 41 59 474 123 450 2042 46 2043 40 442 41 59 125 329 40 2054 2055 41 123 469 2056 46 2057 40 2055 41 59 125 125 125 
30815,Java,"	@Provides
	public static class HandleCustomLog extends JavacAnnotationHandler<lombok.CustomLog> {
		@Override public void handle(AnnotationValues<lombok.CustomLog> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_CUSTOM_FLAG_USAGE, ""@CustomLog"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			LogDeclaration logDeclaration = annotationNode.getAst().readConfiguration(ConfigurationKeys.LOG_CUSTOM_DECLARATION);
			if (logDeclaration == null) {
				annotationNode.addError(""The @CustomLog is not configured; please set lombok.log.custom.declaration in lombok.config."");
				return;
			}
			LoggingFramework framework = new LoggingFramework(lombok.CustomLog.class, logDeclaration);
			processAnnotation(framework, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 2004 62 123 64 2005 439 492 2006 40 2007 60 2003 46 2004 62 2008 44 2009 2010 44 2011 2012 41 123 2013 40 2012 44 2014 46 2015 44 648 44 2014 46 2016 44 648 41 59 2017 2018 61 2012 46 2019 40 41 46 2020 40 2014 46 2021 41 59 392 40 2018 614 424 41 123 2012 46 2022 40 648 41 59 450 59 125 2023 2024 61 418 2023 40 2003 46 2004 46 334 44 2018 41 59 2025 40 2024 44 2008 44 2012 41 59 125 125 
30472,Java,"	static class Extensions {
		public static <T, R> R map(T value, Function<T, R> mapper) {
			return mapper.apply(value);
		}
		
		public static String reverse(String string) {
			return new StringBuilder(string).reverse().toString();
		}

		@SafeVarargs
		public static <T> void consume(T o, Consumer<T>... consumer) {
			for (int i = 0; i < consumer.length; i++) {
				consumer[i].accept(o);
			}
		}
		
		public static <T> List<T> toList1(Stream<T> stream) {
			return (List<T>) stream.collect(Collectors.toList());
		}
		
		public static <T, U> List<U> toList2(Stream<T> stream) {
			return null;
		}
	}",0,457 334 2000 123 439 457 60 2001 44 2002 62 2002 2003 40 2001 2004 44 2005 60 2001 44 2002 62 2006 41 123 450 2006 46 2007 40 2004 41 59 125 439 457 2008 2009 40 2008 461 41 123 450 418 2010 40 461 41 46 2009 40 41 46 2011 40 41 59 125 64 2012 439 457 60 2001 62 492 2013 40 2001 2014 44 2015 60 2001 62 613 2016 41 123 385 40 404 2017 61 1500 59 2017 60 2016 46 2018 59 2017 637 41 123 2016 91 2017 93 46 2019 40 2014 41 59 125 125 439 457 60 2001 62 2020 60 2001 62 2021 40 2022 60 2001 62 2023 41 123 450 40 2020 60 2001 62 41 2023 46 2024 40 2025 46 2026 40 41 41 59 125 439 457 60 2001 44 2027 62 2020 60 2027 62 2028 40 2022 60 2001 62 2023 41 123 450 424 59 125 125 
30473,Java,"@ExtensionMethod(value = ExtensionMethodFunctional.Extensions.class, suppressBaseMethods = false)
class ExtensionMethodFunctional {
	public void test() {
		String test = ""test"";
		test = test.map(s -> s.reverse());
		
		test.consume(s -> System.out.println(""1: "" + s), s -> System.out.println(""2: "" + s));
		test.consume(System.out::println, System.out::println);
		
		Stream.of(""a"", ""b"", ""c"").map(String::toUpperCase).toList1();
		List<Integer> i2 = Stream.of(""a"", ""b"", ""c"").map(String::toUpperCase).toList2();
	}
	
	static class Extensions {
		public static <T, R> R map(T value, Function<T, R> mapper) {
			return mapper.apply(value);
		}
		
		public static String reverse(String string) {
			return new StringBuilder(string).reverse().toString();
		}

		@SafeVarargs
		public static <T> void consume(T o, Consumer<T>... consumer) {
			for (int i = 0; i < consumer.length; i++) {
				consumer[i].accept(o);
			}
		}
		
		public static <T> List<T> toList1(Stream<T> stream) {
			return (List<T>) stream.collect(Collectors.toList());
		}
		
		public static <T, U> List<U> toList2(Stream<T> stream) {
			return null;
		}
	}
}",0,64 2000 40 2001 61 2002 46 2003 46 334 44 2004 61 380 41 334 2002 123 439 492 2005 40 41 123 2006 2005 61 648 59 2005 61 2005 46 2007 40 2008 45 62 2008 46 2009 40 41 41 59 2005 46 2010 40 2008 45 62 2011 46 430 46 2012 40 648 43 2008 41 44 2008 45 62 2011 46 430 46 2012 40 648 43 2008 41 41 59 2005 46 2010 40 2011 46 430 58 58 2012 44 2011 46 430 58 58 2012 41 59 2013 46 2014 40 648 44 648 44 648 41 46 2007 40 2006 58 58 2015 41 46 2016 40 41 59 2017 60 2018 62 2019 61 2013 46 2014 40 648 44 648 44 648 41 46 2007 40 2006 58 58 2015 41 46 2020 40 41 59 125 457 334 2003 123 439 457 60 2021 44 2022 62 2022 2023 40 2021 2001 44 2024 60 2021 44 2022 62 2025 41 123 450 2025 46 2026 40 2001 41 59 125 439 457 2027 2028 40 2027 461 41 123 450 418 2029 40 461 41 46 2028 40 41 46 2030 40 41 59 125 64 2031 439 457 60 2021 62 492 2032 40 2021 2033 44 2034 60 2021 62 613 2035 41 123 385 40 404 2036 61 1500 59 2036 60 2035 46 2037 59 2036 637 41 123 2035 91 2036 93 46 2038 40 2033 41 59 125 125 439 457 60 2021 62 2039 60 2021 62 2040 40 2041 60 2021 62 2042 41 123 450 40 2039 60 2021 62 41 2042 46 2043 40 2044 46 2045 40 41 41 59 125 439 457 60 2021 44 2046 62 2039 60 2046 62 2047 40 2041 60 2021 62 2042 41 123 450 424 59 125 125 125 
31282,Java,"  static class Extensions {
    Extensions() {
      super();
    }
    public static <T, R>R map(T value, Function<T, R> mapper) {
      return mapper.apply(value);
    }
    public static String reverse(String string) {
      return new StringBuilder(string).reverse().toString();
    }
    public static @SafeVarargs <T>void consume(T o, Consumer<T>... consumer) {
      for (int i = 0;; (i < consumer.length); i ++) 
        {
          consumer[i].accept(o);
        }
    }",0,457 334 2000 123 2000 40 41 123 463 40 41 59 125 439 457 60 2001 44 2002 62 2002 2003 40 2001 2004 44 2005 60 2001 44 2002 62 2006 41 123 450 2006 46 2007 40 2004 41 59 125 439 457 2008 2009 40 2008 461 41 123 450 418 2010 40 461 41 46 2009 40 41 46 2011 40 41 59 125 439 457 64 2012 60 2001 62 492 2013 40 2001 2014 44 2015 60 2001 62 613 2016 41 123 385 40 404 2017 61 1500 59 59 40 2017 60 2016 46 2018 41 59 2017 637 41 123 2016 91 2017 93 46 2019 40 2014 41 59 125 125 
31283,Java,"@ExtensionMethod(value = ExtensionMethodFunctional.Extensions.class,suppressBaseMethods = false) class ExtensionMethodFunctional {
  static class Extensions {
    Extensions() {
      super();
    }
    public static <T, R>R map(T value, Function<T, R> mapper) {
      return mapper.apply(value);
    }
    public static String reverse(String string) {
      return new StringBuilder(string).reverse().toString();
    }
    public static @SafeVarargs <T>void consume(T o, Consumer<T>... consumer) {
      for (int i = 0;; (i < consumer.length); i ++) 
        {
          consumer[i].accept(o);
        }
    }
    public static <T>List<T> toList1(Stream<T> stream) {
      return (List<T>) stream.collect(Collectors.toList());
    }
    public static <T, U>List<U> toList2(Stream<T> stream) {
      return null;
    }
  }",0,64 2000 40 2001 61 2002 46 2003 46 334 44 2004 61 380 41 334 2002 123 457 334 2003 123 2003 40 41 123 463 40 41 59 125 439 457 60 2005 44 2006 62 2006 2007 40 2005 2001 44 2008 60 2005 44 2006 62 2009 41 123 450 2009 46 2010 40 2001 41 59 125 439 457 2011 2012 40 2011 461 41 123 450 418 2013 40 461 41 46 2012 40 41 46 2014 40 41 59 125 439 457 64 2015 60 2005 62 492 2016 40 2005 2017 44 2018 60 2005 62 613 2019 41 123 385 40 404 2020 61 1500 59 59 40 2020 60 2019 46 2021 41 59 2020 637 41 123 2019 91 2020 93 46 2022 40 2017 41 59 125 125 439 457 60 2005 62 2023 60 2005 62 2024 40 2025 60 2005 62 2026 41 123 450 40 2023 60 2005 62 41 2026 46 2027 40 2028 46 2029 40 41 41 59 125 439 457 60 2005 44 2030 62 2023 60 2030 62 2031 40 2025 60 2005 62 2026 41 123 450 424 59 125 125 
30923,Java,"	static class Extensions {
		public static <T, R> R map(T value, Function<T, R> mapper) {
			return mapper.apply(value);
		}

		public static String reverse(String string) {
			return new StringBuilder(string).reverse().toString();
		}

		@SafeVarargs
		public static <T> void consume(T o, Consumer<T>... consumer) {
			for (int i = 0; i < consumer.length; i++) {
				consumer[i].accept(o);
			}
		}
		
		public static <T> List<T> toList1(Stream<T> stream) {
			return (List<T>) stream.collect(Collectors.toList());
		}

		public static <T, U> List<U> toList2(Stream<T> stream) {
			return null;
		}
	}",0,457 334 2000 123 439 457 60 2001 44 2002 62 2002 2003 40 2001 2004 44 2005 60 2001 44 2002 62 2006 41 123 450 2006 46 2007 40 2004 41 59 125 439 457 2008 2009 40 2008 461 41 123 450 418 2010 40 461 41 46 2009 40 41 46 2011 40 41 59 125 64 2012 439 457 60 2001 62 492 2013 40 2001 2014 44 2015 60 2001 62 613 2016 41 123 385 40 404 2017 61 1500 59 2017 60 2016 46 2018 59 2017 637 41 123 2016 91 2017 93 46 2019 40 2014 41 59 125 125 439 457 60 2001 62 2020 60 2001 62 2021 40 2022 60 2001 62 2023 41 123 450 40 2020 60 2001 62 41 2023 46 2024 40 2025 46 2026 40 41 41 59 125 439 457 60 2001 44 2027 62 2020 60 2027 62 2028 40 2022 60 2001 62 2023 41 123 450 424 59 125 125 
29558,Java,"	private static class PostponedNonStaticAccessToStaticMethodError implements PostponedError {
		private final ProblemReporter problemReporter;
		private ASTNode location;
		private MethodBinding method;
		private ReferenceContext referenceContext;
		
		PostponedNonStaticAccessToStaticMethodError(ProblemReporter problemReporter, ASTNode location, MethodBinding method) {
			this.problemReporter = problemReporter;
			this.location = location;
			this.method = method;
			this.referenceContext = problemReporter.referenceContext;
		}

		public void fire() {
			problemReporter.referenceContext = this.referenceContext;
			problemReporter.nonStaticAccessToStaticMethod(location, method);
		}
	}",0,437 457 334 2000 395 2001 123 437 381 2002 2003 59 437 2004 2005 59 437 2006 2007 59 437 2008 2009 59 2000 40 2002 2003 44 2004 2005 44 2006 2007 41 123 467 46 2003 61 2003 59 467 46 2005 61 2005 59 467 46 2007 61 2007 59 467 46 2009 61 2003 46 2009 59 125 439 492 2010 40 41 123 2003 46 2009 61 467 46 2009 59 2003 46 2011 40 2005 44 2007 41 59 125 125 
30499,Java,"			node.getAst().cleanupTask(""javadocfilter-setter"", n, new CleanupTask() {
				@Override public void cleanup() {
					String javadoc = Javac.getDocComment(cu, n);
					if (javadoc == null || javadoc.isEmpty()) return;
					javadoc = stripSectionsFromJavadoc(javadoc);
					if (!sectionBased) {
						javadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);
					}
					Javac.setDocComment(cu, n, javadoc);
				}
			});",0,2000 46 2001 40 41 46 2002 40 648 44 2003 44 418 2004 40 41 123 64 2005 439 492 2006 40 41 123 2007 2008 61 2009 46 2010 40 2011 44 2003 41 59 392 40 2008 614 424 606 2008 46 2012 40 41 41 450 59 2008 61 2013 40 2008 41 59 392 40 33 2014 41 123 2008 61 2015 40 2013 40 2008 41 44 2016 46 2017 41 59 125 2009 46 2018 40 2011 44 2003 44 2008 41 59 125 125 41 59 
30836,Java,"	private static class GetterMethod {
		private final char[] name;
		private final TypeReference type;
		
		GetterMethod(char[] name, TypeReference type) {
			this.name = name;
			this.type = type;
		}
	}",0,437 457 334 2000 123 437 381 330 91 93 2001 59 437 381 2002 2003 59 2000 40 330 91 93 2001 44 2002 2003 41 123 467 46 2001 61 2001 59 467 46 2003 61 2003 59 125 125 
31507,Java,"abstract class EclipseJavaUtilListSetSingularizer extends EclipseJavaUtilSingularizer {
	@Override public List<char[]> listFieldsToBeGenerated(SingularData data, EclipseNode builderType) {
		if (useGuavaInstead(builderType)) {
			return guavaListSetSingularizer.listFieldsToBeGenerated(data, builderType);
		}
		
		return super.listFieldsToBeGenerated(data, builderType);
	}
	
	@Override public List<char[]> listMethodsToBeGenerated(SingularData data, EclipseNode builderType) {
		if (useGuavaInstead(builderType)) {
			return guavaListSetSingularizer.listMethodsToBeGenerated(data, builderType);
		}
		
		return super.listMethodsToBeGenerated(data, builderType);
	}
	
	@Override public List<EclipseNode> generateFields(SingularData data, EclipseNode builderType) {
		if (useGuavaInstead(builderType)) {
			return guavaListSetSingularizer.generateFields(data, builderType);
		}
		
		TypeReference type = new QualifiedTypeReference(JAVA_UTIL_ARRAYLIST, NULL_POSS);
		type = addTypeArgs(1, false, builderType, type, data.getTypeArgs());
		
		FieldDeclaration buildField = new FieldDeclaration(data.getPluralName(), 0, -1);
		buildField.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
		buildField.modifiers = ClassFileConstants.AccPrivate;
		buildField.declarationSourceEnd = -1;
		buildField.type = type;
		
		data.setGeneratedByRecursive(buildField);
		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
	}
	
	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, EclipseNode builderType, boolean fluent, TypeReferenceMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
		if (useGuavaInstead(builderType)) {
			guavaListSetSingularizer.generateMethods(cfv, data, deprecate, builderType, fluent, returnTypeMaker, returnStatementMaker, access);
			return;
		}
		
		generateSingularMethod(cfv, deprecate, returnTypeMaker.make(), returnStatementMaker.make(), data, builderType, fluent, access);
		generatePluralMethod(cfv, deprecate, returnTypeMaker.make(), returnStatementMaker.make(), data, builderType, fluent, access);
		generateClearMethod(cfv, deprecate, returnTypeMaker.make(), returnStatementMaker.make(), data, builderType, access);
	}
	
	private void generateClearMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeReference returnType, Statement returnStatement, SingularData data, EclipseNode builderType, AccessLevel access) {
		MethodDeclaration md = new MethodDeclaration(((CompilationUnitDeclaration) builderType.top().get()).compilationResult);
		md.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
		md.modifiers = toEclipseModifier(access);
		
		FieldReference thisDotField = new FieldReference(data.getPluralName(), 0L);
		thisDotField.receiver = new ThisReference(0, 0);
		FieldReference thisDotField2 = new FieldReference(data.getPluralName(), 0L);
		thisDotField2.receiver = new ThisReference(0, 0);
		md.selector = HandlerUtil.buildAccessorName(builderType, ""clear"", new String(data.getPluralName())).toCharArray();
		MessageSend clearMsg = new MessageSend();
		clearMsg.receiver = thisDotField2;
		clearMsg.selector = ""clear"".toCharArray();
		Statement clearStatement = new IfStatement(new EqualExpression(thisDotField, new NullLiteral(0, 0), OperatorIds.NOT_EQUAL), clearMsg, 0, 0);
		md.statements = returnStatement != null ? new Statement[] {clearStatement, returnStatement} : new Statement[] {clearStatement};
		md.returnType = returnType;
		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
		
		data.setGeneratedByRecursive(md);
		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
		injectMethod(builderType, md);
	}
	
	void generateSingularMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeReference returnType, Statement returnStatement, SingularData data, EclipseNode builderType, boolean fluent, AccessLevel access) {
		MethodDeclaration md = new MethodDeclaration(((CompilationUnitDeclaration) builderType.top().get()).compilationResult);
		md.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
		md.modifiers = toEclipseModifier(access);
		
		List<Statement> statements = new ArrayList<Statement>();
		statements.add(createConstructBuilderVarIfNeeded(data, builderType, false));
		
		FieldReference thisDotField = new FieldReference(data.getPluralName(), 0L);
		thisDotField.receiver = new ThisReference(0, 0);
		MessageSend thisDotFieldDotAdd = new MessageSend();
		thisDotFieldDotAdd.arguments = new Expression[] {new SingleNameReference(data.getSingularName(), 0L)};
		thisDotFieldDotAdd.receiver = thisDotField;
		thisDotFieldDotAdd.selector = ""add"".toCharArray();
		statements.add(thisDotFieldDotAdd);
		if (returnStatement != null) statements.add(returnStatement);
		
		md.statements = statements.toArray(new Statement[0]);
		TypeReference paramType = cloneParamType(0, data.getTypeArgs(), builderType);
		Annotation[] typeUseAnns = getTypeUseAnnotations(paramType);
		removeTypeUseAnnotations(paramType);
		Argument param = new Argument(data.getSingularName(), 0, paramType, ClassFileConstants.AccFinal);
		param.annotations = typeUseAnns;
		md.arguments = new Argument[] {param};
		md.returnType = returnType;
		char[] prefixedSingularName = data.getSetterPrefix().length == 0 ? data.getSingularName() : HandlerUtil.buildAccessorName(builderType, new String(data.getSetterPrefix()), new String(data.getSingularName())).toCharArray();
		md.selector = fluent ? prefixedSingularName : HandlerUtil.buildAccessorName(builderType, ""add"", new String(data.getSingularName())).toCharArray();
		Annotation[] selfReturnAnnotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
		Annotation[] copyToSetterAnnotations = copyAnnotations(md, findCopyableToBuilderSingularSetterAnnotations(data.getAnnotation().up()));
		md.annotations = concat(selfReturnAnnotations, copyToSetterAnnotations, Annotation.class);
		
		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
		data.setGeneratedByRecursive(md);
		HandleNonNull.INSTANCE.fix(injectMethod(builderType, md));
	}
	
	void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeReference returnType, Statement returnStatement, SingularData data, EclipseNode builderType, boolean fluent, AccessLevel access) {
		MethodDeclaration md = new MethodDeclaration(((CompilationUnitDeclaration) builderType.top().get()).compilationResult);
		md.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
		md.modifiers = toEclipseModifier(access);
		
		List<Statement> statements = new ArrayList<Statement>();
		statements.add(createConstructBuilderVarIfNeeded(data, builderType, false));
		
		FieldReference thisDotField = new FieldReference(data.getPluralName(), 0L);
		thisDotField.receiver = new ThisReference(0, 0);
		MessageSend thisDotFieldDotAddAll = new MessageSend();
		thisDotFieldDotAddAll.arguments = new Expression[] {new SingleNameReference(data.getPluralName(), 0L)};
		thisDotFieldDotAddAll.receiver = thisDotField;
		thisDotFieldDotAddAll.selector = ""addAll"".toCharArray();
		statements.add(thisDotFieldDotAddAll);
		
		TypeReference paramType = new QualifiedTypeReference(TypeConstants.JAVA_UTIL_COLLECTION, NULL_POSS);
		paramType = addTypeArgs(1, true, builderType, paramType, data.getTypeArgs());
		Argument param = new Argument(data.getPluralName(), 0, paramType, ClassFileConstants.AccFinal);
		
		nullBehaviorize(builderType, data, statements, param);
		if (returnStatement != null) statements.add(returnStatement);
		
		md.statements = statements.toArray(new Statement[0]);
		
		md.arguments = new Argument[] {param};
		md.returnType = returnType;
		char[] prefixedSelector = data.getSetterPrefix().length == 0 ? data.getPluralName() : HandlerUtil.buildAccessorName(builderType, new String(data.getSetterPrefix()), new String(data.getPluralName())).toCharArray();
		md.selector = fluent ? prefixedSelector : HandlerUtil.buildAccessorName(builderType, ""addAll"", new String(data.getPluralName())).toCharArray();
		Annotation[] selfReturnAnnotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
		Annotation[] copyToSetterAnnotations = copyAnnotations(md, findCopyableToSetterAnnotations(data.getAnnotation().up()));
		md.annotations = concat(selfReturnAnnotations, copyToSetterAnnotations, Annotation.class);
		
		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
		data.setGeneratedByRecursive(md);
		injectMethod(builderType, md);
	}
	
	@Override protected int getTypeArgumentsCount() {
		return 1;
	}
}",0,305 334 2000 378 2001 123 64 2002 439 2003 60 330 91 93 62 2004 40 2005 2006 44 2007 2008 41 123 392 40 2009 40 2008 41 41 123 450 2010 46 2004 40 2006 44 2008 41 59 125 450 463 46 2004 40 2006 44 2008 41 59 125 64 2002 439 2003 60 330 91 93 62 2011 40 2005 2006 44 2007 2008 41 123 392 40 2012 40 2008 41 41 123 450 2013 46 2011 40 2006 44 2008 41 59 125 450 463 46 2011 40 2006 44 2008 41 59 125 64 2002 439 2003 60 2007 62 2014 40 2005 2006 44 2007 2008 41 123 392 40 2015 40 2008 41 41 123 450 2016 46 2014 40 2006 44 2008 41 59 125 2017 2018 61 418 2019 40 2020 44 2021 41 59 2018 61 2022 40 1501 44 380 44 2008 44 2018 44 2006 46 2023 40 41 41 59 2024 2025 61 418 2024 40 2006 46 2026 40 41 44 1500 44 45 1501 41 59 2025 46 2027 635 2028 59 2025 46 2029 61 2030 46 2031 59 2025 46 2032 61 45 1501 59 2025 46 2018 61 2018 59 2006 46 2033 40 2025 41 59 450 2034 46 2035 40 2036 40 2008 44 2025 41 41 59 125 64 2002 439 492 2037 40 2038 2039 44 2005 2006 44 324 2040 44 2007 2008 44 324 2041 44 2042 2043 44 2044 2045 44 2046 2047 41 123 392 40 2048 40 2008 41 41 123 2049 46 2037 40 2039 44 2006 44 2040 44 2008 44 2041 44 2043 44 2045 44 2047 41 59 450 59 125 2050 40 2039 44 2040 44 2043 46 2051 40 41 44 2045 46 2051 40 41 44 2006 44 2008 44 2041 44 2047 41 59 2052 40 2039 44 2040 44 2043 46 2051 40 41 44 2045 46 2051 40 41 44 2006 44 2008 44 2041 44 2047 41 59 2053 40 2039 44 2040 44 2043 46 2051 40 41 44 2045 46 2051 40 41 44 2006 44 2008 44 2047 41 59 125 437 492 2054 40 2038 2039 44 324 2040 44 2055 2056 44 2057 2058 44 2005 2006 44 2007 2008 44 2046 2047 41 123 2059 2060 61 418 2059 40 40 40 2061 41 2008 46 2062 40 41 46 2063 40 41 41 46 2064 41 59 2060 46 2065 635 2066 59 2060 46 2067 61 2068 40 2047 41 59 2069 2070 61 418 2069 40 2006 46 2071 40 41 44 1500 41 59 2070 46 2072 61 418 2073 40 1500 44 1500 41 59 2069 2074 61 418 2069 40 2006 46 2071 40 41 44 1500 41 59 2074 46 2072 61 418 2073 40 1500 44 1500 41 59 2060 46 2075 61 2076 46 2077 40 2008 44 648 44 418 2078 40 2006 46 2071 40 41 41 41 46 2079 40 41 59 2080 2081 61 418 2080 40 41 59 2081 46 2072 61 2074 59 2081 46 2075 61 648 46 2079 40 41 59 2057 2082 61 418 2083 40 418 2084 40 2070 44 418 2085 40 1500 44 1500 41 44 2086 46 2087 41 44 2081 44 1500 44 1500 41 59 2060 46 2088 61 2058 631 424 63 418 2057 91 93 123 2082 44 2058 125 58 418 2057 91 93 123 2082 125 59 2060 46 2056 61 2056 59 2060 46 2089 61 2090 40 2040 44 2039 44 2006 46 2091 40 41 41 59 2006 46 2092 40 2060 41 59 392 40 2058 631 424 41 2093 40 2008 44 2060 41 59 2094 40 2008 44 2060 41 59 125 492 2095 40 2038 2039 44 324 2040 44 2055 2056 44 2057 2058 44 2005 2006 44 2007 2008 44 324 2041 44 2046 2047 41 123 2096 2097 61 418 2096 40 40 40 2098 41 2008 46 2099 40 41 46 2100 40 41 41 46 2101 41 59 2097 46 2102 635 2103 59 2097 46 2104 61 2105 40 2047 41 59 2003 60 2057 62 2106 61 418 2107 60 2057 62 40 41 59 2106 46 2108 40 2109 40 2006 44 2008 44 380 41 41 59 2110 2111 61 418 2110 40 2006 46 2112 40 41 44 1500 41 59 2111 46 2113 61 418 2114 40 1500 44 1500 41 59 2115 2116 61 418 2115 40 41 59 2116 46 2117 61 418 2118 91 93 123 418 2119 40 2006 46 2120 40 41 44 1500 41 125 59 2116 46 2113 61 2111 59 2116 46 2121 61 648 46 2122 40 41 59 2106 46 2108 40 2116 41 59 392 40 2058 631 424 41 2106 46 2108 40 2058 41 59 2097 46 2106 61 2106 46 2123 40 418 2057 91 1500 93 41 59 2055 2124 61 2125 40 1500 44 2006 46 2126 40 41 44 2008 41 59 2127 91 93 2128 61 2129 40 2124 41 59 2130 40 2124 41 59 2131 2132 61 418 2131 40 2006 46 2133 40 41 44 1500 44 2124 44 2134 46 2135 41 59 2132 46 2136 61 2128 59 2097 46 2117 61 418 2131 91 93 123 2132 125 59 2097 46 2056 61 2056 59 330 91 93 2137 61 2006 46 2138 40 41 46 2139 614 1500 63 2006 46 2133 40 41 58 2140 46 2141 40 2008 44 418 2142 40 2006 46 2138 40 41 41 44 418 2142 40 2006 46 2133 40 41 41 41 46 2122 40 41 59 2097 46 2121 61 2041 63 2137 58 2140 46 2141 40 2008 44 648 44 418 2142 40 2006 46 2133 40 41 41 41 46 2122 40 41 59 2127 91 93 2143 61 2144 40 2040 44 2039 44 2006 46 2145 40 41 41 59 2127 91 93 2146 61 2147 40 2097 44 2148 40 2006 46 2149 40 41 46 2150 40 41 41 41 59 2097 46 2136 61 2151 40 2143 44 2146 44 2127 46 334 41 59 392 40 2058 631 424 41 2152 40 2008 44 2097 41 59 2006 46 2153 40 2097 41 59 2154 46 2155 46 2156 40 2157 40 2008 44 2097 41 41 59 125 492 2158 40 2038 2039 44 324 2040 44 2055 2056 44 2057 2058 44 2005 2006 44 2007 2008 44 324 2041 44 2046 2047 41 123 2159 2160 61 418 2159 40 40 40 2161 41 2008 46 2162 40 41 46 2163 40 41 41 46 2164 41 59 2160 46 2165 635 2166 59 2160 46 2167 61 2168 40 2047 41 59 2003 60 2057 62 2169 61 418 2170 60 2057 62 40 41 59 2169 46 2171 40 2172 40 2006 44 2008 44 380 41 41 59 2173 2174 61 418 2173 40 2006 46 2175 40 41 44 1500 41 59 2174 46 2176 61 418 2177 40 1500 44 1500 41 59 2178 2179 61 418 2178 40 41 59 2179 46 2180 61 418 2181 91 93 123 418 2182 40 2006 46 2175 40 41 44 1500 41 125 59 2179 46 2176 61 2174 59 2179 46 2183 61 648 46 2184 40 41 59 2169 46 2171 40 2179 41 59 2055 2185 61 418 2186 40 2187 46 2188 44 2189 41 59 2185 61 2190 40 1501 44 473 44 2008 44 2185 44 2006 46 2191 40 41 41 59 2192 2193 61 418 2192 40 2006 46 2175 40 41 44 1500 44 2185 44 2194 46 2195 41 59 2196 40 2008 44 2006 44 2169 44 2193 41 59 392 40 2058 631 424 41 2169 46 2171 40 2058 41 59 2160 46 2169 61 2169 46 2197 40 418 2057 91 1500 93 41 59 2160 46 2180 61 418 2192 91 93 123 2193 125 59 2160 46 2056 61 2056 59 330 91 93 2198 61 2006 46 2199 40 41 46 2200 614 1500 63 2006 46 2175 40 41 58 2201 46 2202 40 2008 44 418 2203 40 2006 46 2199 40 41 41 44 418 2203 40 2006 46 2175 40 41 41 41 46 2184 40 41 59 2160 46 2183 61 2041 63 2198 58 2201 46 2202 40 2008 44 648 44 418 2203 40 2006 46 2175 40 41 41 41 46 2184 40 41 59 2204 91 93 2205 61 2206 40 2040 44 2039 44 2006 46 2207 40 41 41 59 2204 91 93 2208 61 2209 40 2160 44 2210 40 2006 46 2211 40 41 46 2212 40 41 41 41 59 2160 46 2213 61 2214 40 2205 44 2208 44 2204 46 334 41 59 392 40 2058 631 424 41 2215 40 2008 44 2160 41 59 2006 46 2216 40 2160 41 59 2217 40 2008 44 2160 41 59 125 64 2002 438 404 2218 40 41 123 450 1501 59 125 125 
29974,Java,"public class EclipseSingularsRecipes {
	public interface TypeReferenceMaker {
		TypeReference make();
	}
	
	public interface StatementMaker {
		Statement make();
	}
	
	private static final EclipseSingularsRecipes INSTANCE = new EclipseSingularsRecipes();
	private final Map<String, EclipseSingularizer> singularizers = new HashMap<String, EclipseSingularizer>();
	private final TypeLibrary singularizableTypes = new TypeLibrary();
	
	private EclipseSingularsRecipes() {
		try {
			loadAll(singularizableTypes, singularizers);
			singularizableTypes.lock();
		} catch (IOException e) {
			System.err.println(""Lombok's @Singularizable feature is broken due to misconfigured SPI files: "" + e);
		}
	}
	
	private static void loadAll(TypeLibrary library, Map<String, EclipseSingularizer> map) throws IOException {
		for (EclipseSingularizer handler : SpiLoadUtil.findServices(EclipseSingularizer.class, EclipseSingularizer.class.getClassLoader())) {
			for (String type : handler.getSupportedTypes()) {
				EclipseSingularizer existingSingularizer = map.get(type);
				if (existingSingularizer != null) {
					EclipseSingularizer toKeep = existingSingularizer.getClass().getName().compareTo(handler.getClass().getName()) > 0 ? handler : existingSingularizer;
					System.err.println(""Multiple singularizers found for type "" + type + ""; the alphabetically first class is used: "" + toKeep.getClass().getName());
					map.put(type, toKeep);
				} else {
					map.put(type, handler);
					library.addType(type);
				}
			}
		}
	}
	
	public static EclipseSingularsRecipes get() {
		return INSTANCE;
	}
	
	public String toQualified(String typeReference) {
		List<String> q = singularizableTypes.toQualifieds(typeReference);
		if (q.isEmpty()) return null;
		return q.get(0);
	}
	
	public EclipseSingularizer getSingularizer(String fqn) {
		return singularizers.get(fqn);
	}
	
	public static final class SingularData {
		private final EclipseNode annotation;
		private final char[] singularName;
		private final char[] pluralName;
		private final char[] setterPrefix;
		private final List<TypeReference> typeArgs;
		private final String targetFqn;
		private final EclipseSingularizer singularizer;
		private final boolean ignoreNullCollections;
		private final ASTNode source;
		
		public SingularData(EclipseNode annotation, char[] singularName, char[] pluralName, List<TypeReference> typeArgs, String targetFqn, EclipseSingularizer singularizer, ASTNode source, boolean ignoreNullCollections) {
			this(annotation, singularName, pluralName, typeArgs, targetFqn, singularizer, source, ignoreNullCollections, new char[0]);
		}
		
		public SingularData(EclipseNode annotation, char[] singularName, char[] pluralName, List<TypeReference> typeArgs, String targetFqn, EclipseSingularizer singularizer, ASTNode source, boolean ignoreNullCollections, char[] setterPrefix) {
			this.annotation = annotation;
			this.singularName = singularName;
			this.pluralName = pluralName;
			this.typeArgs = typeArgs;
			this.targetFqn = targetFqn;
			this.singularizer = singularizer;
			this.source = source;
			this.ignoreNullCollections = ignoreNullCollections;
			this.setterPrefix = setterPrefix;
		}
		
		public void setGeneratedByRecursive(ASTNode target) {
			SetGeneratedByVisitor visitor = new SetGeneratedByVisitor(source);
			
			if (target instanceof AbstractMethodDeclaration) {
				((AbstractMethodDeclaration) target).traverse(visitor, (ClassScope) null);
			} else if (target instanceof FieldDeclaration) {
				((FieldDeclaration) target).traverse(visitor, (MethodScope) null);
			} else {
				target.traverse(visitor, null);
			}
		}
		
		public ASTNode getSource() {
			return source;
		}
		
		public EclipseNode getAnnotation() {
			return annotation;
		}
		
		public char[] getSingularName() {
			return singularName;
		}
		
		public char[] getPluralName() {
			return pluralName;
		}
		
		public char[] getSetterPrefix() {
			return setterPrefix;
		}
		
		public List<TypeReference> getTypeArgs() {
			return typeArgs;
		}
		
		public String getTargetFqn() {
			return targetFqn;
		}
		
		public EclipseSingularizer getSingularizer() {
			return singularizer;
		}
		
		public boolean isIgnoreNullCollections() {
			return ignoreNullCollections;
		}
		
		public String getTargetSimpleType() {
			int idx = targetFqn.lastIndexOf(""."");
			return idx == -1 ? targetFqn : targetFqn.substring(idx + 1);
		}
	}
	
	public static abstract class EclipseSingularizer {
		protected static final long[] NULL_POSS = {0L};
		public abstract LombokImmutableList<String> getSupportedTypes();
		
		/** Checks if any of the to-be-generated nodes (fields, methods) already exist. If so, errors on these (singulars don't support manually writing some of it, and returns true). */
		public boolean checkForAlreadyExistingNodesAndGenerateError(EclipseNode builderType, SingularData data) {
			for (EclipseNode child : builderType.down()) {
				switch (child.getKind()) {
				case FIELD: {
					FieldDeclaration fd = (FieldDeclaration) child.get();
					char[] name = fd.name;
					if (name == null) continue;
					if (getGeneratedBy(fd) != null) continue;
					for (char[] fieldToBeGenerated : listFieldsToBeGenerated(data, builderType)) {
						if (!Arrays.equals(name, fieldToBeGenerated)) continue;
						child.addError(""Manually adding a field that @Singular @Builder would generate is not supported. If you want to manually manage the builder aspect for this field/parameter, don't use @Singular."");
						return true;
					}
					break;
				}
				case METHOD: {
					AbstractMethodDeclaration method = (AbstractMethodDeclaration) child.get();
					char[] name = method.selector;
					if (name == null) continue;
					if (getGeneratedBy(method) != null) continue;
					for (char[] methodToBeGenerated : listMethodsToBeGenerated(data, builderType)) {
						if (!Arrays.equals(name, methodToBeGenerated)) continue;
						child.addError(""Manually adding a method that @Singular @Builder would generate is not supported. If you want to manually manage the builder aspect for this field/parameter, don't use @Singular."");
						return true;
					}
					break;
				}}
			}
			
			return false;
		}
		
		public List<char[]> listFieldsToBeGenerated(SingularData data, EclipseNode builderType) {
			return Collections.singletonList(data.pluralName);
		}
		
		public List<char[]> listMethodsToBeGenerated(SingularData data, EclipseNode builderType) {
			char[] p = data.pluralName;
			char[] s = data.singularName;
			if (Arrays.equals(p, s)) return Collections.singletonList(p);
			return Arrays.asList(p, s);
		}
		
		public abstract List<EclipseNode> generateFields(SingularData data, EclipseNode builderType);
		
		/**
		 * Generates the singular, plural, and clear methods for the given {@link SingularData}.
		 * Uses the given {@code builderType} as return type if {@code chain == true}, {@code void} otherwise.
		 * If you need more control over the return type and value, use
		 * {@link #generateMethods(SingularData, boolean, EclipseNode, boolean, TypeReferenceMaker, StatementMaker)}.
		 */
		public void generateMethods(final BuilderJob job, SingularData data, boolean deprecate) {
			TypeReferenceMaker returnTypeMaker = new TypeReferenceMaker() {
				@Override public TypeReference make() {
					return job.oldChain ? cloneSelfType(job.builderType) : TypeReference.baseTypeReference(TypeIds.T_void, 0);
				}
			};
			
			StatementMaker returnStatementMaker = new StatementMaker() {
				@Override public ReturnStatement make() {
					return job.oldChain ? new ReturnStatement(new ThisReference(0, 0), 0, 0) : null;
				}
			};
			
			generateMethods(job.checkerFramework, data, deprecate, job.builderType, job.oldFluent, returnTypeMaker, returnStatementMaker, job.accessInners);
		}
		
		/**
		 * Generates the singular, plural, and clear methods for the given {@link SingularData}.
		 * Uses the given {@code returnTypeMaker} and {@code returnStatementMaker} for the generated methods.
		 */
		public abstract void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, EclipseNode builderType, boolean fluent, TypeReferenceMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access);
		
		public abstract void appendBuildCode(SingularData data, EclipseNode builderType, List<Statement> statements, char[] targetVariableName, String builderVariable);
		
		public boolean shadowedDuringBuild() {
			return true;
		}
		
		public boolean requiresCleaning() {
			try {
				return !getClass().getMethod(""appendCleaningCode"", SingularData.class, EclipseNode.class, List.class).getDeclaringClass().equals(EclipseSingularizer.class);
			} catch (NoSuchMethodException e) {
				return false;
			}
		}
		
		public void appendCleaningCode(SingularData data, EclipseNode builderType, List<Statement> statements) {
		}
		
		// -- Utility methods --
		
		protected Annotation[] generateSelfReturnAnnotations(boolean deprecate, CheckerFrameworkVersion cfv, ASTNode source) {
			Annotation deprecated = deprecate ? generateDeprecatedAnnotation(source) : null;
			Annotation returnsReceiver = cfv.generateReturnsReceiver() ? generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER) : null;
			if (deprecated == null && returnsReceiver == null) return null;
			if (deprecated == null) return new Annotation[] {returnsReceiver};
			if (returnsReceiver == null) return new Annotation[] {deprecated};
			return new Annotation[] {deprecated, returnsReceiver};
		}
		
		/**
		 * Adds the requested number of type arguments to the provided type, copying each argument in {@code typeArgs}. If typeArgs is too long, the extra elements are ignored.
		 * If {@code typeArgs} is null or too short, {@code java.lang.Object} will be substituted for each missing type argument.
		 * 
		 * @param count The number of type arguments requested.
		 * @param addExtends If {@code true}, all bounds are either '? extends X' or just '?'. If false, the reverse is applied, and '? extends Foo' is converted to Foo, '?' to Object, etc.
		 * @param node Some node in the same AST. Just used to obtain makers and contexts and such.
		 * @param type The type to add generics to.
		 * @param typeArgs the list of type args to clone.
		 * @param source The source annotation that is the root cause of this code generation.
		 */
		protected TypeReference addTypeArgs(int count, boolean addExtends, EclipseNode node, TypeReference type, List<TypeReference> typeArgs) {
			TypeReference[] clonedAndFixedArgs = createTypeArgs(count, addExtends, node, typeArgs);
			if (type instanceof SingleTypeReference) {
				type = new ParameterizedSingleTypeReference(((SingleTypeReference) type).token, clonedAndFixedArgs, 0, 0L);
			} else if (type instanceof QualifiedTypeReference) {
				QualifiedTypeReference qtr = (QualifiedTypeReference) type;
				TypeReference[][] trs = new TypeReference[qtr.tokens.length][];
				trs[qtr.tokens.length - 1] = clonedAndFixedArgs;
				type = new ParameterizedQualifiedTypeReference(((QualifiedTypeReference) type).tokens, trs, 0, NULL_POSS);
			} else {
				node.addError(""Don't know how to clone-and-parameterize type: "" + type);
			}
			
			return type;
		}
		
		protected TypeReference[] createTypeArgs(int count, boolean addExtends, EclipseNode node, List<TypeReference> typeArgs) {
			if (count < 0) throw new IllegalArgumentException(""count is negative"");
			if (count == 0) return null;
			List<TypeReference> arguments = new ArrayList<TypeReference>();
			
			if (typeArgs != null) for (TypeReference orig : typeArgs) {
				Wildcard wildcard = orig instanceof Wildcard ? (Wildcard) orig : null;
				if (!addExtends) {
					if (wildcard != null && (wildcard.kind == Wildcard.UNBOUND || wildcard.kind == Wildcard.SUPER)) {
						arguments.add(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, NULL_POSS));
					} else if (wildcard != null && wildcard.kind == Wildcard.EXTENDS) {
						try {
							arguments.add(copyType(wildcard.bound));
						} catch (Exception e) {
							arguments.add(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, NULL_POSS));
						}
					} else {
						arguments.add(copyType(orig));
					}
				} else {
					if (wildcard != null && (wildcard.kind == Wildcard.UNBOUND || wildcard.kind == Wildcard.SUPER)) {
						Wildcard w = new Wildcard(Wildcard.UNBOUND);
						arguments.add(w);
					} else if (wildcard != null && wildcard.kind == Wildcard.EXTENDS) {
						arguments.add(copyType(orig));
					} else {
						Wildcard w = new Wildcard(Wildcard.EXTENDS);
						w.bound = copyType(orig);
						arguments.add(w);
					}
				}
				if (--count == 0) break;
			}
			
			while (count-- > 0) {
				if (addExtends) {
					arguments.add(new Wildcard(Wildcard.UNBOUND));
				} else {
					arguments.add(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, NULL_POSS));
				}
			}
			
			if (arguments.isEmpty()) return null;
			return arguments.toArray(new TypeReference[0]);
		}
		
		private static final char[] SIZE_TEXT = new char[] {'s', 'i', 'z', 'e'};
		
		/** Generates 'this.<em>name</em>.size()' as an expression; if nullGuard is true, it's this.name == null ? 0 : this.name.size(). */
		protected Expression getSize(EclipseNode builderType, char[] name, boolean nullGuard, String builderVariable) {
			MessageSend invoke = new MessageSend();
			Reference thisRef = getBuilderReference(builderVariable);
			FieldReference thisDotName = new FieldReference(name, 0L);
			thisDotName.receiver = thisRef;
			invoke.receiver = thisDotName;
			invoke.selector = SIZE_TEXT;
			if (!nullGuard) return invoke;
			
			Reference cdnThisRef = getBuilderReference(builderVariable);
			FieldReference cdnThisDotName = new FieldReference(name, 0L);
			cdnThisDotName.receiver = cdnThisRef;
			NullLiteral nullLiteral = new NullLiteral(0, 0);
			EqualExpression isNull = new EqualExpression(cdnThisDotName, nullLiteral, OperatorIds.EQUAL_EQUAL);
			IntLiteral zeroLiteral = makeIntLiteral(new char[] {'0'}, null);
			ConditionalExpression conditional = new ConditionalExpression(isNull, zeroLiteral, invoke);
			return conditional;
		}
		
		protected TypeReference cloneParamType(int index, List<TypeReference> typeArgs, EclipseNode builderType) {
			if (typeArgs != null && typeArgs.size() > index) {
				TypeReference originalType = typeArgs.get(index);
				if (originalType instanceof Wildcard) {
					Wildcard wOriginalType = (Wildcard) originalType;
					if (wOriginalType.kind == Wildcard.EXTENDS) {
						try {
							return copyType(wOriginalType.bound);
						} catch (Exception e) {
							// fallthrough
						}
					}
				} else {
					return copyType(originalType);
				}
			}
			
			return new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, NULL_POSS);
		}
		
		/** @return a {@code SingleNameReference} to the builder in the variable <code>builderVariable</code>. If {@ code builderVariable == ""this""}, a {@code ThisReference} is returned. */
		protected static Reference getBuilderReference(String builderVariable) {
			if (""this"".equals(builderVariable)) {
				return new ThisReference(0, 0);
			} else {
				return new SingleNameReference(builderVariable.toCharArray(), 0);
			}
		}
		
		protected void nullBehaviorize(EclipseNode typeNode, SingularData data, List<Statement> statements, Argument arg) {
			boolean ignoreNullCollections = data.isIgnoreNullCollections();
			
			if (ignoreNullCollections) {
				Expression isNotNull = new EqualExpression(new SingleNameReference(data.getPluralName(), 0L), new NullLiteral(0, 0), OperatorIds.NOT_EQUAL);
				Block b = new Block(0);
				b.statements = statements.toArray(new Statement[statements.size()]);
				statements.clear();
				statements.add(new IfStatement(isNotNull, b, 0, 0));
				EclipseHandlerUtil.createRelevantNullableAnnotation(typeNode, arg);
				return;
			}
			
			EclipseHandlerUtil.createRelevantNonNullAnnotation(typeNode, arg);
			Statement nullCheck = EclipseHandlerUtil.generateNullCheck(null, data.getPluralName(), typeNode, ""%s cannot be null"");
			statements.add(0, nullCheck);
		}
		
		protected abstract int getTypeArgumentsCount();
		
		protected abstract char[][] getEmptyMakerReceiver(String targetFqn);
		protected abstract char[] getEmptyMakerSelector(String targetFqn);
		
		public MessageSend getEmptyExpression(String targetFqn, SingularData data, EclipseNode typeNode, ASTNode source) {
			MessageSend send = new MessageSend();
			send.receiver = generateQualifiedNameRef(source, getEmptyMakerReceiver(targetFqn));
			send.selector = getEmptyMakerSelector(targetFqn);
			send.typeArguments = createTypeArgs(getTypeArgumentsCount(), false, typeNode, data.getTypeArgs());
			return send;
		}
	}
}",0,439 334 2000 123 439 405 2001 123 2002 2003 40 41 59 125 439 405 2004 123 2005 2006 40 41 59 125 437 457 381 2000 2007 61 418 2000 40 41 59 437 381 2008 60 2009 44 2010 62 2011 61 418 2012 60 2009 44 2010 62 40 41 59 437 381 2013 2014 61 418 2013 40 41 59 437 2000 40 41 123 474 123 2015 40 2014 44 2011 41 59 2014 46 412 40 41 59 125 329 40 2016 2017 41 123 2018 46 2019 46 2020 40 648 43 2017 41 59 125 125 437 457 492 2021 40 2013 2022 44 2008 60 2009 44 2010 62 2023 41 470 2024 123 385 40 2010 2025 58 2026 46 2027 40 2010 46 334 44 2010 46 334 46 2028 40 41 41 41 123 385 40 2009 2029 58 2025 46 2030 40 41 41 123 2010 2031 61 2023 46 2032 40 2029 41 59 392 40 2031 631 424 41 123 2010 2033 61 2031 46 2034 40 41 46 2035 40 41 46 2036 40 2025 46 2034 40 41 46 2035 40 41 41 62 1500 63 2025 58 2031 59 2037 46 2038 46 2039 40 648 43 2029 43 648 43 2033 46 2034 40 41 46 2035 40 41 41 59 2023 46 2040 40 2029 44 2033 41 59 125 360 123 2023 46 2041 40 2029 44 2025 41 59 2022 46 2042 40 2029 41 59 125 125 125 125 439 457 2000 2043 40 41 123 450 2007 59 125 439 2009 2044 40 2009 2045 41 123 2046 60 2009 62 2047 61 2014 46 2048 40 2045 41 59 392 40 2047 46 2049 40 41 41 450 424 59 450 2047 46 2043 40 1500 41 59 125 439 2010 2050 40 2009 2051 41 123 450 2011 46 2043 40 2051 41 59 125 439 457 381 334 2052 123 437 381 2053 2054 59 437 381 330 91 93 2055 59 437 381 330 91 93 2056 59 437 381 330 91 93 2057 59 437 381 2058 60 2059 62 2060 59 437 381 2009 2061 59 437 381 2010 2062 59 437 381 324 2063 59 437 381 2064 2065 59 439 2052 40 2053 2054 44 330 91 93 2055 44 330 91 93 2056 44 2058 60 2059 62 2060 44 2009 2061 44 2010 2062 44 2064 2065 44 324 2063 41 123 467 40 2054 44 2055 44 2056 44 2060 44 2061 44 2062 44 2065 44 2063 44 418 330 91 1500 93 41 59 125 439 2052 40 2053 2054 44 330 91 93 2055 44 330 91 93 2056 44 2058 60 2059 62 2060 44 2009 2061 44 2010 2062 44 2064 2065 44 324 2063 44 330 91 93 2057 41 123 467 46 2054 61 2054 59 467 46 2055 61 2055 59 467 46 2056 61 2056 59 467 46 2060 61 2060 59 467 46 2061 61 2061 59 467 46 2062 61 2062 59 467 46 2065 61 2065 59 467 46 2063 61 2063 59 467 46 2057 61 2057 59 125 439 492 2066 40 2064 2067 41 123 2068 2069 61 418 2068 40 2065 41 59 392 40 2067 402 2070 41 123 40 40 2070 41 2067 41 46 2071 40 2069 44 40 2072 41 424 41 59 125 360 392 40 2067 402 2073 41 123 40 40 2073 41 2067 41 46 2074 40 2069 44 40 2075 41 424 41 59 125 360 123 2067 46 2076 40 2069 44 424 41 59 125 125 439 2064 2077 40 41 123 450 2065 59 125 439 2053 2078 40 41 123 450 2054 59 125 439 330 91 93 2079 40 41 123 450 2055 59 125 439 330 91 93 2080 40 41 123 450 2056 59 125 439 330 91 93 2081 40 41 123 450 2057 59 125 439 2058 60 2059 62 2082 40 41 123 450 2060 59 125 439 2009 2083 40 41 123 450 2061 59 125 439 2010 2050 40 41 123 450 2062 59 125 439 324 2084 40 41 123 450 2063 59 125 439 2009 2085 40 41 123 404 2086 61 2061 46 2087 40 648 41 59 450 2086 614 45 1501 63 2061 58 2061 46 2088 40 2086 43 1501 41 59 125 125 439 457 305 334 2010 123 438 457 381 413 91 93 2089 61 123 1500 125 59 439 305 2090 60 2009 62 2091 40 41 59 618 439 324 2092 40 2093 2094 44 2052 2095 41 123 385 40 2093 2096 58 2094 46 2097 40 41 41 123 464 40 2096 46 2098 40 41 41 123 328 2099 58 123 2100 2101 61 40 2100 41 2096 46 2043 40 41 59 330 91 93 2102 61 2101 46 2102 59 392 40 2102 614 424 41 344 59 392 40 2103 40 2101 41 631 424 41 344 59 385 40 330 91 93 2104 58 2105 40 2095 44 2094 41 41 123 392 40 33 2106 46 2107 40 2102 44 2104 41 41 344 59 2096 46 2108 40 648 41 59 450 473 59 125 325 59 125 328 2109 58 123 2110 2111 61 40 2110 41 2096 46 2043 40 41 59 330 91 93 2112 61 2111 46 2113 59 392 40 2112 614 424 41 344 59 392 40 2114 40 2111 41 631 424 41 344 59 385 40 330 91 93 2115 58 2116 40 2095 44 2094 41 41 123 392 40 33 2117 46 2118 40 2112 44 2115 41 41 344 59 2096 46 2119 40 648 41 59 450 473 59 125 325 59 125 125 125 450 380 59 125 439 2120 60 330 91 93 62 2121 40 2052 2095 44 2093 2094 41 123 450 2122 46 2123 40 2095 46 2124 41 59 125 439 2120 60 330 91 93 62 2125 40 2052 2095 44 2093 2094 41 123 330 91 93 2126 61 2095 46 2127 59 330 91 93 2128 61 2095 46 2129 59 392 40 2130 46 2131 40 2126 44 2128 41 41 450 2132 46 2133 40 2126 41 59 450 2130 46 2134 40 2126 44 2128 41 59 125 439 305 2120 60 2093 62 2135 40 2052 2095 44 2093 2094 41 59 618 439 492 2136 40 381 2137 2138 44 2052 2095 44 324 2139 41 123 2001 2140 61 418 2001 40 41 123 64 2141 439 2142 2143 40 41 123 450 2138 46 2144 63 2145 40 2138 46 2094 41 58 2142 46 2146 40 2147 46 2148 44 1500 41 59 125 125 59 2004 2149 61 418 2004 40 41 123 64 2150 439 2151 2152 40 41 123 450 2138 46 2153 63 418 2151 40 418 2154 40 1500 44 1500 41 44 1500 44 1500 41 58 424 59 125 125 59 2136 40 2138 46 2155 44 2095 44 2139 44 2138 46 2094 44 2138 46 2156 44 2140 44 2149 44 2138 46 2157 41 59 125 618 439 305 492 2136 40 2158 2159 44 2052 2095 44 324 2139 44 2093 2094 44 324 2160 44 2001 2161 44 2004 2162 44 2163 2164 41 59 439 305 492 2165 40 2052 2095 44 2093 2094 44 2120 60 2166 62 2167 44 330 91 93 2168 44 2009 2169 41 59 439 324 2170 40 41 123 450 473 59 125 439 324 2171 40 41 123 474 123 450 33 2172 40 41 46 2173 40 648 44 2052 46 334 44 2093 46 334 44 2120 46 334 41 46 2174 40 41 46 2175 40 2010 46 334 41 59 125 329 40 2176 2177 41 123 450 380 59 125 125 439 492 2178 40 2052 2095 44 2093 2094 44 2120 60 2166 62 2167 41 123 125 621 438 2179 91 93 2180 40 324 2139 44 2158 2159 44 2181 2182 41 123 2179 2183 61 2139 63 2184 40 2182 41 58 424 59 2179 2185 61 2159 46 2186 40 41 63 2187 40 2182 44 2158 46 2188 41 58 424 59 392 40 2183 614 424 605 2185 614 424 41 450 424 59 392 40 2183 614 424 41 450 418 2179 91 93 123 2185 125 59 392 40 2185 614 424 41 450 418 2179 91 93 123 2183 125 59 450 418 2179 91 93 123 2183 44 2185 125 59 125 618 438 2189 2190 40 404 2191 44 324 2192 44 2093 2193 44 2189 2194 44 2120 60 2189 62 2195 41 123 2189 91 93 2196 61 2197 40 2191 44 2192 44 2193 44 2195 41 59 392 40 2194 402 2198 41 123 2194 61 418 2199 40 40 40 2198 41 2194 41 46 2200 44 2196 44 1500 44 1500 41 59 125 360 392 40 2194 402 2201 41 123 2201 2202 61 40 2201 41 2194 59 2189 91 93 91 93 2203 61 418 2189 91 2202 46 2204 46 2205 93 91 93 59 2203 91 2202 46 2204 46 2205 45 1501 93 61 2196 59 2194 61 418 2206 40 40 40 2201 41 2194 41 46 2204 44 2203 44 1500 44 2089 41 59 125 360 123 2193 46 2207 40 648 43 2194 41 59 125 450 2194 59 125 438 2189 91 93 2208 40 404 2191 44 324 2192 44 2093 2193 44 2120 60 2189 62 2195 41 123 392 40 2191 60 1500 41 469 418 2209 40 648 41 59 392 40 2191 614 1500 41 450 424 59 2120 60 2189 62 2210 61 418 2211 60 2189 62 40 41 59 392 40 2195 631 424 41 385 40 2189 2212 58 2195 41 123 2213 2214 61 2212 402 2213 63 40 2213 41 2212 58 424 59 392 40 33 2192 41 123 392 40 2214 631 424 605 40 2214 46 2215 614 2213 46 2216 606 2214 46 2215 614 2213 46 2217 41 41 123 2210 46 2218 40 418 2219 40 2220 46 2221 44 2089 41 41 59 125 360 392 40 2214 631 424 605 2214 46 2215 614 2213 46 2222 41 123 474 123 2210 46 2223 40 2224 40 2214 46 2225 41 41 59 125 329 40 2226 2227 41 123 2210 46 2228 40 418 2229 40 2230 46 2231 44 2089 41 41 59 125 125 360 123 2210 46 2232 40 2233 40 2212 41 41 59 125 125 360 123 392 40 2214 631 424 605 40 2214 46 2234 614 2213 46 2235 606 2214 46 2234 614 2213 46 2236 41 41 123 2213 2237 61 418 2213 40 2213 46 2235 41 59 2210 46 2238 40 2237 41 59 125 360 392 40 2214 631 424 605 2214 46 2234 614 2213 46 2239 41 123 2210 46 2240 40 2241 40 2212 41 41 59 125 360 123 2213 2242 61 418 2213 40 2213 46 2239 41 59 2242 46 2243 61 2244 40 2212 41 59 2210 46 2245 40 2242 41 59 125 125 392 40 629 2191 614 1500 41 325 59 125 496 40 2191 629 62 1500 41 123 392 40 2192 41 123 2210 46 2246 40 418 2247 40 2247 46 2248 41 41 59 125 360 123 2210 46 2249 40 418 2250 40 2251 46 2252 44 2089 41 41 59 125 125 392 40 2210 46 2253 40 41 41 450 424 59 450 2210 46 2254 40 418 2189 91 1500 93 41 59 125 437 457 381 330 91 93 2255 61 418 330 91 93 123 607 44 607 44 607 44 607 125 59 618 438 2256 2257 40 2093 2094 44 330 91 93 2258 44 324 2259 44 2009 2169 41 123 2260 2261 61 418 2260 40 41 59 2262 2263 61 2264 40 2169 41 59 2265 2266 61 418 2265 40 2258 44 1500 41 59 2266 46 2267 61 2263 59 2261 46 2267 61 2266 59 2261 46 2268 61 2255 59 392 40 33 2259 41 450 2261 59 2262 2269 61 2264 40 2169 41 59 2265 2270 61 418 2265 40 2258 44 1500 41 59 2270 46 2267 61 2269 59 2271 2272 61 418 2271 40 1500 44 1500 41 59 2273 2274 61 418 2273 40 2270 44 2272 44 2275 46 2276 41 59 2277 2278 61 2279 40 418 330 91 93 123 607 125 44 424 41 59 2280 2281 61 418 2280 40 2274 44 2278 44 2261 41 59 450 2281 59 125 438 2189 2282 40 404 2283 44 2120 60 2189 62 2195 44 2093 2094 41 123 392 40 2195 631 424 605 2195 46 2284 40 41 62 2283 41 123 2189 2285 61 2195 46 2043 40 2283 41 59 392 40 2285 402 2286 41 123 2286 2287 61 40 2286 41 2285 59 392 40 2287 46 2288 614 2286 46 2289 41 123 474 123 450 2290 40 2287 46 2291 41 59 125 329 40 2292 2293 41 123 621 125 125 125 360 123 450 2294 40 2285 41 59 125 125 450 418 2295 40 2296 46 2297 44 2089 41 59 125 618 438 457 2298 2299 40 2009 2169 41 123 392 40 648 46 2300 40 2169 41 41 123 450 418 2301 40 1500 44 1500 41 59 125 360 123 450 418 2302 40 2169 46 2303 40 41 44 1500 41 59 125 125 438 492 2304 40 2093 2305 44 2052 2095 44 2120 60 2166 62 2167 44 2306 2307 41 123 324 2308 61 2095 46 2309 40 41 59 392 40 2308 41 123 2256 2310 61 418 2311 40 418 2312 40 2095 46 2313 40 41 44 1500 41 44 418 2314 40 1500 44 1500 41 44 2315 46 2316 41 59 2317 2318 61 418 2317 40 1500 41 59 2318 46 2167 61 2167 46 2319 40 418 2166 91 2167 46 2320 40 41 93 41 59 2167 46 2321 40 41 59 2167 46 2322 40 418 2323 40 2310 44 2318 44 1500 44 1500 41 41 59 2324 46 2325 40 2305 44 2307 41 59 450 59 125 2326 46 2327 40 2305 44 2307 41 59 2166 2328 61 2326 46 2329 40 424 44 2095 46 2330 40 41 44 2305 44 648 41 59 2167 46 2331 40 1500 44 2328 41 59 125 438 305 404 2332 40 41 59 438 305 330 91 93 91 93 2333 40 2009 2334 41 59 438 305 330 91 93 2335 40 2009 2334 41 59 439 2336 2337 40 2009 2334 44 2052 2095 44 2093 2305 44 2181 2182 41 123 2336 2338 61 418 2336 40 41 59 2338 46 2339 61 2340 40 2182 44 2333 40 2334 41 41 59 2338 46 2341 61 2335 40 2334 41 59 2338 46 2342 61 2208 40 2332 40 41 44 380 44 2305 44 2095 46 2343 40 41 41 59 450 2338 59 125 125 125 
30832,Java,"		SETTER {
			@Override public String apply(final EclipseNode node) {
				return applySetter(node, ""SETTER"");
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 41 123 450 2006 40 2005 44 648 41 59 125 125 44 
30837,Java,"			values.put(mName, new AnnotationValue(annotationNode, raws, expressionValues, guesses, true) {
				@Override public void setError(String message, int valueIdx) {
					Expression ex;
					if (valueIdx == -1) ex = rhs;
					else ex = exprs != null ? exprs[valueIdx] : null;
					
					if (ex == null) ex = annotation;
					
					int sourceStart = ex.sourceStart;
					int sourceEnd = ex.sourceEnd;
					
					annotationNode.addError(message, sourceStart, sourceEnd);
				}
				
				@Override public void setWarning(String message, int valueIdx) {
					Expression ex;
					if (valueIdx == -1) ex = rhs;
					else ex = exprs != null ? exprs[valueIdx] : null;
					
					if (ex == null) ex = annotation;
					
					int sourceStart = ex.sourceStart;
					int sourceEnd = ex.sourceEnd;
					
					annotationNode.addWarning(message, sourceStart, sourceEnd);
				}
			});",0,2000 46 2001 40 2002 44 418 2003 40 2004 44 2005 44 2006 44 2007 44 473 41 123 64 2008 439 492 2009 40 2010 2011 44 404 2012 41 123 2013 2014 59 392 40 2012 614 45 1501 41 2014 61 2015 59 360 2014 61 2016 631 424 63 2016 91 2012 93 58 424 59 392 40 2014 614 424 41 2014 61 2017 59 404 2018 61 2014 46 2018 59 404 2019 61 2014 46 2019 59 2004 46 2020 40 2011 44 2018 44 2019 41 59 125 64 2008 439 492 2021 40 2010 2011 44 404 2012 41 123 2022 2023 59 392 40 2012 614 45 1501 41 2023 61 2024 59 360 2023 61 2025 631 424 63 2025 91 2012 93 58 424 59 392 40 2023 614 424 41 2023 61 2026 59 404 2027 61 2023 46 2027 59 404 2028 61 2023 46 2028 59 2004 46 2029 40 2011 44 2027 44 2028 41 59 125 125 41 59 
30835,Java,"	static class EclipseReflectiveMembers {
		public static final Field STRING_LITERAL__LINE_NUMBER;
		public static final Field ANNOTATION__MEMBER_VALUE_PAIR_NAME;
		public static final Field TYPE_REFERENCE__ANNOTATIONS;
		public static final Class<?> INTERSECTION_BINDING1, INTERSECTION_BINDING2;
		public static final Field INTERSECTION_BINDING_TYPES1, INTERSECTION_BINDING_TYPES2;
		public static final Field TYPE_DECLARATION_RECORD_COMPONENTS;
		public static final Class<?> COMPILATION_UNIT;
		public static final Method COMPILATION_UNIT_ORIGINAL_FROM_CLONE;
		static {
			STRING_LITERAL__LINE_NUMBER = getField(StringLiteral.class, ""lineNumber"");
			ANNOTATION__MEMBER_VALUE_PAIR_NAME = getField(Annotation.class, ""memberValuePairName"");
			TYPE_REFERENCE__ANNOTATIONS = getField(TypeReference.class, ""annotations"");
			INTERSECTION_BINDING1 = getClass(""org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18"");
			INTERSECTION_BINDING2 = getClass(""org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding"");
			INTERSECTION_BINDING_TYPES1 = INTERSECTION_BINDING1 == null ? null : getField(INTERSECTION_BINDING1, ""intersectingTypes"");
			INTERSECTION_BINDING_TYPES2 = INTERSECTION_BINDING2 == null ? null : getField(INTERSECTION_BINDING2, ""intersectingTypes"");
			TYPE_DECLARATION_RECORD_COMPONENTS = getField(TypeDeclaration.class, ""recordComponents"");
			COMPILATION_UNIT = getClass(""org.eclipse.jdt.internal.core.CompilationUnit"");
			COMPILATION_UNIT_ORIGINAL_FROM_CLONE = COMPILATION_UNIT == null ? null : Permit.permissiveGetMethod(COMPILATION_UNIT, ""originalFromClone"");
		}
		
		public static int reflectInt(Field f, Object o) {
			try {
				return ((Number) f.get(o)).intValue();
			} catch (IllegalAccessException e) {
				throw new RuntimeException(e);
			}
		}
		
		public static void reflectSet(Field f, Object o, Object v) {
			try {
				f.set(o, v);
			} catch (IllegalAccessException e) {
				throw new RuntimeException(e);
			}
		}
		
		public static Object reflect(Field f, Object o) {
			try {
				return f.get(o);
			} catch (IllegalAccessException e) {
				throw new RuntimeException(e);
			}
		}
		
		private static Class<?> getClass(String fqn) {
			try {
				return Class.forName(fqn);
			} catch (Throwable t) {
				return null;
			}
		}
		
		private static Field getField(Class<?> c, String fName) {
			try {
				return Permit.getField(c, fName);
			} catch (Throwable t) {
				return null;
			}
		}
	}",0,457 334 2000 123 439 457 381 2001 2002 59 439 457 381 2001 2003 59 439 457 381 2001 2004 59 439 457 381 2005 60 63 62 2006 44 2007 59 439 457 381 2001 2008 44 2009 59 439 457 381 2001 2010 59 439 457 381 2005 60 63 62 2011 59 439 457 381 2012 2013 59 457 123 2002 61 2014 40 2015 46 334 44 648 41 59 2003 61 2014 40 2016 46 334 44 648 41 59 2004 61 2014 40 2017 46 334 44 648 41 59 2006 61 2018 40 648 41 59 2007 61 2018 40 648 41 59 2008 61 2006 614 424 63 424 58 2014 40 2006 44 648 41 59 2009 61 2007 614 424 63 424 58 2014 40 2007 44 648 41 59 2010 61 2014 40 2019 46 334 44 648 41 59 2011 61 2018 40 648 41 59 2013 61 2011 614 424 63 424 58 2020 46 2021 40 2011 44 648 41 59 125 439 457 404 2022 40 2001 2023 44 2024 2025 41 123 474 123 450 40 40 2026 41 2023 46 2027 40 2025 41 41 46 2028 40 41 59 125 329 40 2029 2030 41 123 469 418 2031 40 2030 41 59 125 125 439 457 492 2032 40 2001 2023 44 2024 2025 44 2024 2033 41 123 474 123 2023 46 2034 40 2025 44 2033 41 59 125 329 40 2035 2036 41 123 469 418 2037 40 2036 41 59 125 125 439 457 2024 2038 40 2001 2023 44 2024 2025 41 123 474 123 450 2023 46 2039 40 2025 41 59 125 329 40 2040 2041 41 123 469 418 2042 40 2041 41 59 125 125 437 457 2005 60 63 62 2043 40 2044 2045 41 123 474 123 450 2005 46 2046 40 2045 41 59 125 329 40 2047 2048 41 123 450 424 59 125 125 437 457 2001 2049 40 2005 60 63 62 2050 44 2044 2051 41 123 474 123 450 2052 46 2049 40 2050 44 2051 41 59 125 329 40 2053 2054 41 123 450 424 59 125 125 125 
30766,Java,"public class ValInvalidParameter {
  public ValInvalidParameter() {
    super();
  }
  public void val() {
    final @val java.lang.Object a = a(new NonExistingClass());
    final @val java.lang.Object b = a(a(new NonExistingClass()));
    final @val java.lang.Object c = nonExisitingMethod(b(1));
    final @val java.lang.Object d = nonExistingObject.nonExistingMethod();
    final @val java.lang.Object e = b(1).nonExistingMethod();
    final @val java.lang.Object f = ((1 > 2) ? a(new NonExistingClass()) : a(new NonExistingClass()));
    final @val java.lang.Object g = b2(1);
    final @val java.lang.Object h = b2(a(""a""), a(null));
    final @val java.lang.Object i = a(a(null));
  }
  public int a(String param) {
    return 0;
  }
  public int a(Integer param) {
    return 0;
  }
  public Integer b(int i) {
    return i;
  }
  public Integer b2(int i, int j) {
    return i;
  }
}",0,439 334 2000 123 439 2000 40 41 123 463 40 41 59 125 439 492 2001 40 41 123 381 64 2001 2002 46 2003 46 2004 2005 61 2005 40 418 2006 40 41 41 59 381 64 2001 2002 46 2003 46 2004 2007 61 2005 40 2005 40 418 2006 40 41 41 41 59 381 64 2001 2002 46 2003 46 2004 2008 61 2009 40 2007 40 1501 41 41 59 381 64 2001 2002 46 2003 46 2004 2010 61 2011 46 2012 40 41 59 381 64 2001 2002 46 2003 46 2004 2013 61 2007 40 1501 41 46 2012 40 41 59 381 64 2001 2002 46 2003 46 2004 2014 61 40 40 1501 62 1502 41 63 2005 40 418 2006 40 41 41 58 2005 40 418 2006 40 41 41 41 59 381 64 2001 2002 46 2003 46 2004 2015 61 2016 40 1501 41 59 381 64 2001 2002 46 2003 46 2004 2017 61 2016 40 2005 40 648 41 44 2005 40 424 41 41 59 381 64 2001 2002 46 2003 46 2004 2018 61 2005 40 2005 40 424 41 41 59 125 439 404 2019 40 2020 2021 41 123 450 1500 59 125 439 404 2019 40 2022 2021 41 123 450 1500 59 125 439 2022 2023 40 404 2024 41 123 450 2024 59 125 439 2022 2025 40 404 2024 44 404 2026 41 123 450 2024 59 125 125 
31235,Java,"		ECJ {
			@Override public int getVersion() {
				String javaVersionString = System.getProperty(""compiler.compliance.level"");
				return javaVersionString != null ? Integer.parseInt(javaVersionString) : Eclipse.getEcjCompilerVersion();
			}
		};",0,2000 123 64 2001 439 404 2002 40 41 123 2003 2004 61 2005 46 2006 40 648 41 59 450 2004 631 424 63 2007 46 2008 40 2004 41 58 2009 46 2010 40 41 59 125 125 59 
30054,Java,"public class ValInvalidParameter {
	public void val() {
		final java.lang.Object a = a(new NonExistingClass());
		final java.lang.Object b = a(a(new NonExistingClass()));
		final java.lang.Object c = nonExisitingMethod(b(1));
		final java.lang.Object d = nonExistingObject.nonExistingMethod();
		final java.lang.Object e = b(1).nonExistingMethod();
		final java.lang.Object f = 1 > 2 ? a(new NonExistingClass()) : a(new NonExistingClass());
		final java.lang.Object g = b2(1);
		final java.lang.Integer h = b2(a(""a""), a(null));
		final int i = a(a(null));
	}

	public int a(String param) {
		return 0;
	}

	public int a(Integer param) {
		return 0;
	}

	public Integer b(int i) {
		return i;
	}

	public Integer b2(int i, int j) {
		return i;
	}
}",0,439 334 2000 123 439 492 2001 40 41 123 381 2002 46 2003 46 2004 2005 61 2005 40 418 2006 40 41 41 59 381 2002 46 2003 46 2004 2007 61 2005 40 2005 40 418 2006 40 41 41 41 59 381 2002 46 2003 46 2004 2008 61 2009 40 2007 40 1501 41 41 59 381 2002 46 2003 46 2004 2010 61 2011 46 2012 40 41 59 381 2002 46 2003 46 2004 2013 61 2007 40 1501 41 46 2012 40 41 59 381 2002 46 2003 46 2004 2014 61 1501 62 1502 63 2005 40 418 2006 40 41 41 58 2005 40 418 2006 40 41 41 59 381 2002 46 2003 46 2004 2015 61 2016 40 1501 41 59 381 2002 46 2003 46 2017 2018 61 2016 40 2005 40 648 41 44 2005 40 424 41 41 59 381 404 2019 61 2005 40 2005 40 424 41 41 59 125 439 404 2020 40 2021 2022 41 123 450 1500 59 125 439 404 2020 40 2023 2022 41 123 450 1500 59 125 439 2023 2024 40 404 2025 41 123 450 2025 59 125 439 2023 2026 40 404 2025 44 404 2027 41 123 450 2025 59 125 125 
30729,Java,"	private static class EclipseDomConversion {
		static CompilationUnit toDomAst(CompilationUnitDeclaration cud, final char[] source) {
			Map<String, String> options = new HashMap<String, String>();
			options.put(JavaCore.COMPILER_SOURCE, ""11"");
			options.put(""org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures"", ""enabled"");
			
			org.eclipse.jdt.internal.core.CompilationUnit ccu = new org.eclipse.jdt.internal.core.CompilationUnit(null, null, null) {
				@Override public char[] getContents() {
					return source;
				}
			};
			return AST.convertCompilationUnit(4, cud, options, false, ccu, 0, null);
		}
	}",0,437 457 334 2000 123 457 2001 2002 40 2003 2004 44 381 330 91 93 2005 41 123 2006 60 2007 44 2007 62 2008 61 418 2009 60 2007 44 2007 62 40 41 59 2008 46 2010 40 2011 46 2012 44 648 41 59 2008 46 2010 40 648 44 648 41 59 2013 46 2014 46 2015 46 406 46 2016 46 2001 2017 61 418 2013 46 2014 46 2015 46 406 46 2016 46 2001 40 424 44 424 44 424 41 123 64 2018 439 330 91 93 2019 40 41 123 450 2005 59 125 125 59 450 2020 46 2021 40 1502 44 2004 44 2008 44 380 44 2017 44 1500 44 424 41 59 125 125 
30730,Java,"			org.eclipse.jdt.internal.core.CompilationUnit ccu = new org.eclipse.jdt.internal.core.CompilationUnit(null, null, null) {
				@Override public char[] getContents() {
					return source;
				}
			};",0,2000 46 2001 46 2002 46 406 46 2003 46 2004 2005 61 418 2000 46 2001 46 2002 46 406 46 2003 46 2004 40 424 44 424 44 424 41 123 64 2006 439 330 91 93 2007 40 41 123 450 2008 59 125 125 59 
30732,Java,"			RegistryFactory.setDefaultRegistryProvider(new IRegistryProvider() {
				private final ExtensionRegistry REG = new ExtensionRegistry(null, null, null);
				@Override public IExtensionRegistry getRegistry() {
					return REG;
				}
			});",0,2000 46 2001 40 418 2002 40 41 123 437 381 2003 2004 61 418 2003 40 424 44 424 44 424 41 59 64 2005 439 2006 2007 40 41 123 450 2004 59 125 125 41 59 
30733,Java,"	private static final class TestCompilationUnitEcj implements ICompilationUnit {
		private final char[] name, source, mainTypeName;
		
		TestCompilationUnitEcj(String name, String source) {
			this.source = source.toCharArray();
			this.name = name.toCharArray();
			
			char[] fileNameCharArray = getFileName();
			int start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;
			int end = CharOperation.lastIndexOf('.', fileNameCharArray);
			if (end == -1) {
				end = fileNameCharArray.length;
			}
			mainTypeName = CharOperation.subarray(fileNameCharArray, start, end);
		}
		
		@Override public char[] getFileName() {
			return name;
		}
		
		@Override public char[] getContents() {
			return source;
		}
		
		@Override public char[] getMainTypeName() {
			return mainTypeName;
		}
		
		@Override public char[][] getPackageName() {
			return null;
		}
	}",0,437 457 381 334 2000 395 2001 123 437 381 330 91 93 2002 44 2003 44 2004 59 2000 40 2005 2002 44 2005 2003 41 123 467 46 2003 61 2003 46 2006 40 41 59 467 46 2002 61 2002 46 2006 40 41 59 330 91 93 2007 61 2008 40 41 59 404 2009 61 2010 46 2011 40 2012 46 2013 44 2007 41 43 1501 59 404 2014 61 2010 46 2011 40 607 44 2007 41 59 392 40 2014 614 45 1501 41 123 2014 61 2007 46 2015 59 125 2004 61 2010 46 2016 40 2007 44 2009 44 2014 41 59 125 64 2017 439 330 91 93 2018 40 41 123 450 2002 59 125 64 2017 439 330 91 93 2019 40 41 123 450 2003 59 125 64 2017 439 330 91 93 2020 40 41 123 450 2004 59 125 64 2017 439 330 91 93 91 93 2021 40 41 123 450 424 59 125 125 
32927,Java,"                        new ThrowableAssert.ThrowingCallable() {
                            public void call() {
                                mock.add("""");
                            }
                        })",0,418 2000 46 2001 40 41 123 439 492 2002 40 41 123 2003 46 2004 40 648 41 59 125 125 41 
32929,Java,"                        new ThrowableAssert.ThrowingCallable() {
                            public void call() {
                                mock.clear();
                            }
                        })",0,418 2000 46 2001 40 41 123 439 492 2002 40 41 123 2003 46 2004 40 41 59 125 125 41 
30736,Java,"		return new IErrorHandlingPolicy() {
			public boolean stopOnFirstError() {
				return false;
			}
			
			public boolean proceedOnErrors() {
				return false;
			}
			
			@SuppressWarnings(""all"") // Added to the interface in later ecj version.
			public boolean ignoreAllErrors() {
				return false;
			}
		};",0,450 418 2000 40 41 123 439 324 2001 40 41 123 450 380 59 125 439 324 2002 40 41 123 450 380 59 125 64 2003 40 648 41 621 439 324 2004 40 41 123 450 380 59 125 125 59 
30738,Java,"		Compiler ecjCompiler = new Compiler(createFileSystem(file, minVersion), ecjErrorHandlingPolicy(), ecjCompilerOptions(), bitbucketRequestor, new DefaultProblemFactory(Locale.ENGLISH)) {
			@Override protected synchronized void addCompilationUnit(ICompilationUnit inUnit, CompilationUnitDeclaration parsedUnit) {
				if (inUnit == sourceUnit) compilationUnit_.set(parsedUnit);
				super.addCompilationUnit(inUnit, parsedUnit);
			}
		};",0,2000 2001 61 418 2000 40 2002 40 2003 44 2004 41 44 2005 40 41 44 2006 40 41 44 2007 44 418 2008 40 2009 46 2010 41 41 123 64 2011 438 465 492 2012 40 2013 2014 44 2015 2016 41 123 392 40 2014 614 2017 41 2018 46 2019 40 2016 41 59 463 46 2012 40 2014 44 2016 41 59 125 125 59 
31234,Java,"		JAVAC {
			@Override public int getVersion() {
				return DELOMBOK.getVersion();
			}
		},",0,2000 123 64 2001 439 404 2002 40 41 123 450 2003 46 2002 40 41 59 125 125 44 
30601,Java,"@Provides(EclipseSingularizer.class)
public class EclipseJavaUtilMapSingularizer extends EclipseJavaUtilSingularizer {
	@Override public LombokImmutableList<String> getSupportedTypes() {
		return LombokImmutableList.of(""java.util.Map"", ""java.util.SortedMap"", ""java.util.NavigableMap"");
	}
	
	private static final char[] EMPTY_SORTED_MAP = {'e', 'm', 'p', 't', 'y', 'S', 'o', 'r', 't', 'e', 'd', 'M', 'a', 'p'};
	private static final char[] EMPTY_NAVIGABLE_MAP = {'e', 'm', 'p', 't', 'y', 'N', 'a', 'v', 'i', 'g', 'a', 'b', 'l', 'e', 'M', 'a', 'p'};
	private static final char[] EMPTY_MAP = {'e', 'm', 'p', 't', 'y', 'M', 'a', 'p'};
	
	@Override protected char[][] getEmptyMakerReceiver(String targetFqn) {
		return JAVA_UTIL_COLLECTIONS;
	}
	
	@Override protected char[] getEmptyMakerSelector(String targetFqn) {
		if (targetFqn.endsWith(""SortedMap"")) return EMPTY_SORTED_MAP;
		if (targetFqn.endsWith(""NavigableMap"")) return EMPTY_NAVIGABLE_MAP;
		return EMPTY_MAP;
	}
	
	@Override public List<char[]> listFieldsToBeGenerated(SingularData data, EclipseNode builderType) {
		if (useGuavaInstead(builderType)) {
			return guavaMapSingularizer.listFieldsToBeGenerated(data, builderType);
		}
		
		char[] p = data.getPluralName();
		int len = p.length;
		char[] k = new char[len + 4];
		char[] v = new char[len + 6];
		System.arraycopy(p, 0, k, 0, len);
		System.arraycopy(p, 0, v, 0, len);
		k[len] = '$';
		k[len + 1] = 'k';
		k[len + 2] = 'e';
		k[len + 3] = 'y';
		v[len] = '$';
		v[len + 1] = 'v';
		v[len + 2] = 'a';
		v[len + 3] = 'l';
		v[len + 4] = 'u';
		v[len + 5] = 'e';
		return Arrays.asList(k, v);
	}
	
	@Override public List<char[]> listMethodsToBeGenerated(SingularData data, EclipseNode builderType) {
		if (useGuavaInstead(builderType)) {
			return guavaMapSingularizer.listFieldsToBeGenerated(data, builderType);
		} else {
			return super.listMethodsToBeGenerated(data, builderType);
		}
	}
	
	@Override public List<EclipseNode> generateFields(SingularData data, EclipseNode builderType) {
		if (useGuavaInstead(builderType)) {
			return guavaMapSingularizer.generateFields(data, builderType);
		}
		
		char[] keyName = (new String(data.getPluralName()) + ""$key"").toCharArray();
		char[] valueName = (new String(data.getPluralName()) + ""$value"").toCharArray();
		FieldDeclaration buildKeyField; {
			TypeReference type = new QualifiedTypeReference(JAVA_UTIL_ARRAYLIST, NULL_POSS);
			type = addTypeArgs(1, false, builderType, type, data.getTypeArgs());
			buildKeyField = new FieldDeclaration(keyName, 0, -1);
			buildKeyField.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
			buildKeyField.modifiers = ClassFileConstants.AccPrivate;
			buildKeyField.declarationSourceEnd = -1;
			buildKeyField.type = type;
		}
		FieldDeclaration buildValueField; {
			TypeReference type = new QualifiedTypeReference(JAVA_UTIL_ARRAYLIST, NULL_POSS);
			List<TypeReference> tArgs = data.getTypeArgs();
			if (tArgs != null && tArgs.size() > 1) tArgs = Collections.singletonList(tArgs.get(1));
			else tArgs = Collections.emptyList();
			type = addTypeArgs(1, false, builderType, type, tArgs);
			buildValueField = new FieldDeclaration(valueName, 0, -1);
			buildValueField.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
			buildValueField.modifiers = ClassFileConstants.AccPrivate;
			buildValueField.declarationSourceEnd = -1;
			buildValueField.type = type;
		}
		
		data.setGeneratedByRecursive(buildKeyField);
		data.setGeneratedByRecursive(buildValueField);
		EclipseNode keyFieldNode = injectFieldAndMarkGenerated(builderType, buildKeyField);
		EclipseNode valueFieldNode = injectFieldAndMarkGenerated(builderType, buildValueField);
		return Arrays.asList(keyFieldNode, valueFieldNode);
	}
	
	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, EclipseNode builderType, boolean fluent, TypeReferenceMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
		if (useGuavaInstead(builderType)) {
			guavaMapSingularizer.generateMethods(cfv, data, deprecate, builderType, fluent, returnTypeMaker, returnStatementMaker, access);
			return;
		}
		
		generateSingularMethod(cfv, deprecate, returnTypeMaker.make(), returnStatementMaker.make(), data, builderType, fluent, access);
		generatePluralMethod(cfv, deprecate, returnTypeMaker.make(), returnStatementMaker.make(), data, builderType, fluent, access);
		generateClearMethod(cfv, deprecate, returnTypeMaker.make(), returnStatementMaker.make(), data, builderType, access);
	}
	
	private void generateClearMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeReference returnType, Statement returnStatement, SingularData data, EclipseNode builderType, AccessLevel access) {
		MethodDeclaration md = new MethodDeclaration(((CompilationUnitDeclaration) builderType.top().get()).compilationResult);
		md.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
		md.modifiers = toEclipseModifier(access);
		
		String pN = new String(data.getPluralName());
		char[] keyFieldName = (pN + ""$key"").toCharArray();
		char[] valueFieldName = (pN + ""$value"").toCharArray();
		
		FieldReference thisDotField = new FieldReference(keyFieldName, 0L);
		thisDotField.receiver = new ThisReference(0, 0);
		FieldReference thisDotField2 = new FieldReference(keyFieldName, 0L);
		thisDotField2.receiver = new ThisReference(0, 0);
		FieldReference thisDotField3 = new FieldReference(valueFieldName, 0L);
		thisDotField3.receiver = new ThisReference(0, 0);
		md.selector = HandlerUtil.buildAccessorName(builderType, ""clear"", new String(data.getPluralName())).toCharArray();
		MessageSend clearMsg1 = new MessageSend();
		clearMsg1.receiver = thisDotField2;
		clearMsg1.selector = ""clear"".toCharArray();
		MessageSend clearMsg2 = new MessageSend();
		clearMsg2.receiver = thisDotField3;
		clearMsg2.selector = ""clear"".toCharArray();
		Block clearMsgs = new Block(2);
		clearMsgs.statements = new Statement[] {clearMsg1, clearMsg2};
		Statement clearStatement = new IfStatement(new EqualExpression(thisDotField, new NullLiteral(0, 0), OperatorIds.NOT_EQUAL), clearMsgs, 0, 0);
		md.statements = returnStatement != null ? new Statement[] {clearStatement, returnStatement} : new Statement[] {clearStatement};
		md.returnType = returnType;
		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
		
		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
		data.setGeneratedByRecursive(md);
		injectMethod(builderType, md);
	}
	
	private void generateSingularMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeReference returnType, Statement returnStatement, SingularData data, EclipseNode builderType, boolean fluent, AccessLevel access) {
		MethodDeclaration md = new MethodDeclaration(((CompilationUnitDeclaration) builderType.top().get()).compilationResult);
		md.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
		md.modifiers = toEclipseModifier(access);
		
		List<Statement> statements = new ArrayList<Statement>();
		statements.add(createConstructBuilderVarIfNeeded(data, builderType, true));
		
		String sN = new String(data.getSingularName());
		String pN = new String(data.getPluralName());
		char[] keyParamName = (sN + ""Key"").toCharArray();
		char[] valueParamName = (sN + ""Value"").toCharArray();
		char[] keyFieldName = (pN + ""$key"").toCharArray();
		char[] valueFieldName = (pN + ""$value"").toCharArray();
		
		/* this.pluralname$key.add(singularnameKey); */ {
			FieldReference thisDotKeyField = new FieldReference(keyFieldName, 0L);
			thisDotKeyField.receiver = new ThisReference(0, 0);
			MessageSend thisDotKeyFieldDotAdd = new MessageSend();
			thisDotKeyFieldDotAdd.arguments = new Expression[] {new SingleNameReference(keyParamName, 0L)};
			thisDotKeyFieldDotAdd.receiver = thisDotKeyField;
			thisDotKeyFieldDotAdd.selector = ""add"".toCharArray();
			statements.add(thisDotKeyFieldDotAdd);
		}
		
		/* this.pluralname$value.add(singularnameValue); */ {
			FieldReference thisDotValueField = new FieldReference(valueFieldName, 0L);
			thisDotValueField.receiver = new ThisReference(0, 0);
			MessageSend thisDotValueFieldDotAdd = new MessageSend();
			thisDotValueFieldDotAdd.arguments = new Expression[] {new SingleNameReference(valueParamName, 0L)};
			thisDotValueFieldDotAdd.receiver = thisDotValueField;
			thisDotValueFieldDotAdd.selector = ""add"".toCharArray();
			statements.add(thisDotValueFieldDotAdd);
		}
		if (returnStatement != null) statements.add(returnStatement);
		
		md.statements = statements.toArray(new Statement[0]);
		TypeReference keyParamType = cloneParamType(0, data.getTypeArgs(), builderType);
		TypeReference valueParamType = cloneParamType(1, data.getTypeArgs(), builderType);
		Annotation[] typeUseAnnsKey = getTypeUseAnnotations(keyParamType);
		Annotation[] typeUseAnnsValue = getTypeUseAnnotations(valueParamType);
		
		removeTypeUseAnnotations(keyParamType);
		removeTypeUseAnnotations(valueParamType);
		Argument keyParam = new Argument(keyParamName, 0, keyParamType, ClassFileConstants.AccFinal);
		Argument valueParam = new Argument(valueParamName, 0, valueParamType, ClassFileConstants.AccFinal);
		keyParam.annotations = typeUseAnnsKey;
		valueParam.annotations = typeUseAnnsValue;
		md.arguments = new Argument[] {keyParam, valueParam};
		md.returnType = returnType;
		
		String name = new String(data.getSingularName());
		String setterPrefix = data.getSetterPrefix().length > 0 ? new String(data.getSetterPrefix()) : fluent ? """" : ""put"";
		String setterName = HandlerUtil.buildAccessorName(builderType, setterPrefix, name);
		
		md.selector = setterName.toCharArray();
		Annotation[] selfReturnAnnotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
		Annotation[] copyToSetterAnnotations = copyAnnotations(md, findCopyableToBuilderSingularSetterAnnotations(data.getAnnotation().up()));
		md.annotations = concat(selfReturnAnnotations, copyToSetterAnnotations, Annotation.class);
		
		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
		data.setGeneratedByRecursive(md);
		HandleNonNull.INSTANCE.fix(injectMethod(builderType, md));
	}
	
	private void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeReference returnType, Statement returnStatement, SingularData data, EclipseNode builderType, boolean fluent, AccessLevel access) {
		MethodDeclaration md = new MethodDeclaration(((CompilationUnitDeclaration) builderType.top().get()).compilationResult);
		md.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
		md.modifiers = toEclipseModifier(access);
		
		String pN = new String(data.getPluralName());
		char[] keyFieldName = (pN + ""$key"").toCharArray();
		char[] valueFieldName = (pN + ""$value"").toCharArray();
		
		List<Statement> statements = new ArrayList<Statement>();
		statements.add(createConstructBuilderVarIfNeeded(data, builderType, true));
		
		char[] entryName = ""$lombokEntry"".toCharArray();
		
		TypeReference forEachType = new QualifiedTypeReference(JAVA_UTIL_MAP_ENTRY, NULL_POSS);
		forEachType = addTypeArgs(2, true, builderType, forEachType, data.getTypeArgs());
		
		MessageSend keyArg = new MessageSend();
		keyArg.receiver = new SingleNameReference(entryName, 0L);
		keyArg.selector = ""getKey"".toCharArray();
		MessageSend addKey = new MessageSend();
		FieldReference thisDotKeyField = new FieldReference(keyFieldName, 0L);
		thisDotKeyField.receiver = new ThisReference(0, 0);
		addKey.receiver = thisDotKeyField;
		addKey.selector = new char[] {'a', 'd', 'd'};
		addKey.arguments = new Expression[] {keyArg};
		
		MessageSend valueArg = new MessageSend();
		valueArg.receiver = new SingleNameReference(entryName, 0L);
		valueArg.selector = ""getValue"".toCharArray();
		MessageSend addValue = new MessageSend();
		FieldReference thisDotValueField = new FieldReference(valueFieldName, 0L);
		thisDotValueField.receiver = new ThisReference(0, 0);
		addValue.receiver = thisDotValueField;
		addValue.selector = new char[] {'a', 'd', 'd'};
		addValue.arguments = new Expression[] {valueArg};
		
		LocalDeclaration elementVariable = new LocalDeclaration(entryName, 0, 0);
		elementVariable.type = forEachType;
		ForeachStatement forEach = new ForeachStatement(elementVariable, 0);
		MessageSend invokeEntrySet = new MessageSend();
		invokeEntrySet.selector = new char[] { 'e', 'n', 't', 'r', 'y', 'S', 'e', 't'};
		invokeEntrySet.receiver = new SingleNameReference(data.getPluralName(), 0L);
		forEach.collection = invokeEntrySet;
		Block forEachContent = new Block(0);
		forEachContent.statements = new Statement[] {addKey, addValue};
		forEach.action = forEachContent;
		statements.add(forEach);
		
		TypeReference paramType = new QualifiedTypeReference(JAVA_UTIL_MAP, NULL_POSS);
		paramType = addTypeArgs(2, true, builderType, paramType, data.getTypeArgs());
		Argument param = new Argument(data.getPluralName(), 0, paramType, ClassFileConstants.AccFinal);
		
		nullBehaviorize(builderType, data, statements, param);
		
		if (returnStatement != null) statements.add(returnStatement);
		
		md.statements = statements.toArray(new Statement[0]);
		
		md.arguments = new Argument[] {param};
		md.returnType = returnType;
		
		String name = new String(data.getPluralName());
		String setterPrefix = data.getSetterPrefix().length > 0 ? new String(data.getSetterPrefix()) : fluent ? """" : ""put"";
		String setterName = HandlerUtil.buildAccessorName(builderType, setterPrefix, name);
		
		md.selector = setterName.toCharArray();
		Annotation[] selfReturnAnnotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
		Annotation[] copyToSetterAnnotations = copyAnnotations(md, findCopyableToSetterAnnotations(data.getAnnotation().up()));
		md.annotations = concat(selfReturnAnnotations, copyToSetterAnnotations, Annotation.class);
		
		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
		data.setGeneratedByRecursive(md);
		injectMethod(builderType, md);
	}
	
	@Override public void appendBuildCode(SingularData data, EclipseNode builderType, List<Statement> statements, char[] targetVariableName, String builderVariable) {
		if (useGuavaInstead(builderType)) {
			guavaMapSingularizer.appendBuildCode(data, builderType, statements, targetVariableName, builderVariable);
			return;
		}
		
		if (data.getTargetFqn().equals(""java.util.Map"")) {
			statements.addAll(createJavaUtilSetMapInitialCapacitySwitchStatements(data, builderType, true, ""emptyMap"", ""singletonMap"", ""LinkedHashMap"", builderVariable));
		} else {
			statements.addAll(createJavaUtilSimpleCreationAndFillStatements(data, builderType, true, true, false, true, ""TreeMap"", builderVariable));
		}
	}
	
	@Override protected int getTypeArgumentsCount() {
		return 2;
	}
}",0,64 2000 40 2001 46 334 41 439 334 2002 378 2003 123 64 2004 439 2005 60 2006 62 2007 40 41 123 450 2005 46 2008 40 648 44 648 44 648 41 59 125 437 457 381 330 91 93 2009 61 123 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 125 59 437 457 381 330 91 93 2010 61 123 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 125 59 437 457 381 330 91 93 2011 61 123 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 125 59 64 2004 438 330 91 93 91 93 2012 40 2006 2013 41 123 450 2014 59 125 64 2004 438 330 91 93 2015 40 2006 2013 41 123 392 40 2013 46 2016 40 648 41 41 450 2009 59 392 40 2013 46 2016 40 648 41 41 450 2010 59 450 2011 59 125 64 2004 439 2017 60 330 91 93 62 2018 40 2019 2020 44 2021 2022 41 123 392 40 2023 40 2022 41 41 123 450 2024 46 2018 40 2020 44 2022 41 59 125 330 91 93 2025 61 2020 46 2026 40 41 59 404 2027 61 2025 46 2028 59 330 91 93 2029 61 418 330 91 2027 43 1502 93 59 330 91 93 2030 61 418 330 91 2027 43 1502 93 59 2031 46 2032 40 2025 44 1500 44 2029 44 1500 44 2027 41 59 2031 46 2032 40 2025 44 1500 44 2030 44 1500 44 2027 41 59 2029 91 2027 93 61 607 59 2029 91 2027 43 1501 93 61 607 59 2029 91 2027 43 1502 93 61 607 59 2029 91 2027 43 1502 93 61 607 59 2030 91 2027 93 61 607 59 2030 91 2027 43 1501 93 61 607 59 2030 91 2027 43 1502 93 61 607 59 2030 91 2027 43 1502 93 61 607 59 2030 91 2027 43 1502 93 61 607 59 2030 91 2027 43 1502 93 61 607 59 450 2033 46 2034 40 2029 44 2030 41 59 125 64 2004 439 2017 60 330 91 93 62 2035 40 2019 2020 44 2021 2022 41 123 392 40 2036 40 2022 41 41 123 450 2037 46 2018 40 2020 44 2022 41 59 125 360 123 450 463 46 2035 40 2020 44 2022 41 59 125 125 64 2004 439 2017 60 2021 62 2038 40 2019 2020 44 2021 2022 41 123 392 40 2039 40 2022 41 41 123 450 2040 46 2038 40 2020 44 2022 41 59 125 330 91 93 2041 61 40 418 2006 40 2020 46 2042 40 41 41 43 648 41 46 2043 40 41 59 330 91 93 2044 61 40 418 2006 40 2020 46 2042 40 41 41 43 648 41 46 2043 40 41 59 2045 2046 59 123 2047 2048 61 418 2049 40 2050 44 2051 41 59 2048 61 2052 40 1501 44 380 44 2022 44 2048 44 2020 46 2053 40 41 41 59 2046 61 418 2045 40 2041 44 1500 44 45 1501 41 59 2046 46 2054 635 2055 59 2046 46 2056 61 2057 46 2058 59 2046 46 2059 61 45 1501 59 2046 46 2048 61 2048 59 125 2045 2060 59 123 2061 2062 61 418 2063 40 2064 44 2065 41 59 2017 60 2061 62 2066 61 2020 46 2067 40 41 59 392 40 2066 631 424 605 2066 46 2068 40 41 62 1501 41 2066 61 2069 46 2070 40 2066 46 2071 40 1501 41 41 59 360 2066 61 2069 46 2072 40 41 59 2062 61 2073 40 1501 44 380 44 2022 44 2062 44 2066 41 59 2060 61 418 2045 40 2044 44 1500 44 45 1501 41 59 2060 46 2074 635 2075 59 2060 46 2076 61 2077 46 2078 59 2060 46 2079 61 45 1501 59 2060 46 2062 61 2062 59 125 2020 46 2080 40 2046 41 59 2020 46 2080 40 2060 41 59 2021 2081 61 2082 40 2022 44 2046 41 59 2021 2083 61 2082 40 2022 44 2060 41 59 450 2084 46 2085 40 2081 44 2083 41 59 125 64 2004 439 492 2086 40 2087 2088 44 2019 2020 44 324 2089 44 2021 2022 44 324 2090 44 2091 2092 44 2093 2094 44 2095 2096 41 123 392 40 2097 40 2022 41 41 123 2098 46 2086 40 2088 44 2020 44 2089 44 2022 44 2090 44 2092 44 2094 44 2096 41 59 450 59 125 2099 40 2088 44 2089 44 2092 46 2100 40 41 44 2094 46 2100 40 41 44 2020 44 2022 44 2090 44 2096 41 59 2101 40 2088 44 2089 44 2092 46 2100 40 41 44 2094 46 2100 40 41 44 2020 44 2022 44 2090 44 2096 41 59 2102 40 2088 44 2089 44 2092 46 2100 40 41 44 2094 46 2100 40 41 44 2020 44 2022 44 2096 41 59 125 437 492 2103 40 2087 2088 44 324 2089 44 2104 2105 44 2106 2107 44 2019 2020 44 2021 2022 44 2095 2096 41 123 2108 2109 61 418 2108 40 40 40 2110 41 2022 46 2111 40 41 46 2112 40 41 41 46 2113 41 59 2109 46 2114 635 2115 59 2109 46 2116 61 2117 40 2096 41 59 2006 2118 61 418 2006 40 2020 46 2119 40 41 41 59 330 91 93 2120 61 40 2118 43 648 41 46 2121 40 41 59 330 91 93 2122 61 40 2118 43 648 41 46 2121 40 41 59 2123 2124 61 418 2123 40 2120 44 1500 41 59 2124 46 2125 61 418 2126 40 1500 44 1500 41 59 2123 2127 61 418 2123 40 2120 44 1500 41 59 2127 46 2125 61 418 2126 40 1500 44 1500 41 59 2123 2128 61 418 2123 40 2122 44 1500 41 59 2128 46 2125 61 418 2126 40 1500 44 1500 41 59 2109 46 2129 61 2130 46 2131 40 2022 44 648 44 418 2006 40 2020 46 2119 40 41 41 41 46 2121 40 41 59 2132 2133 61 418 2132 40 41 59 2133 46 2125 61 2127 59 2133 46 2129 61 648 46 2121 40 41 59 2132 2134 61 418 2132 40 41 59 2134 46 2125 61 2128 59 2134 46 2129 61 648 46 2121 40 41 59 2135 2136 61 418 2135 40 1502 41 59 2136 46 2137 61 418 2106 91 93 123 2133 44 2134 125 59 2106 2138 61 418 2139 40 418 2140 40 2124 44 418 2141 40 1500 44 1500 41 44 2142 46 2143 41 44 2136 44 1500 44 1500 41 59 2109 46 2137 61 2107 631 424 63 418 2106 91 93 123 2138 44 2107 125 58 418 2106 91 93 123 2138 125 59 2109 46 2105 61 2105 59 2109 46 2144 61 2145 40 2089 44 2088 44 2020 46 2146 40 41 41 59 392 40 2107 631 424 41 2147 40 2022 44 2109 41 59 2020 46 2148 40 2109 41 59 2149 40 2022 44 2109 41 59 125 437 492 2150 40 2087 2088 44 324 2089 44 2104 2105 44 2106 2107 44 2019 2020 44 2021 2022 44 324 2090 44 2095 2096 41 123 2151 2152 61 418 2151 40 40 40 2153 41 2022 46 2154 40 41 46 2155 40 41 41 46 2156 41 59 2152 46 2157 635 2158 59 2152 46 2159 61 2160 40 2096 41 59 2017 60 2106 62 2161 61 418 2162 60 2106 62 40 41 59 2161 46 2163 40 2164 40 2020 44 2022 44 473 41 41 59 2006 2165 61 418 2006 40 2020 46 2166 40 41 41 59 2006 2167 61 418 2006 40 2020 46 2168 40 41 41 59 330 91 93 2169 61 40 2165 43 648 41 46 2170 40 41 59 330 91 93 2171 61 40 2165 43 648 41 46 2170 40 41 59 330 91 93 2172 61 40 2167 43 648 41 46 2170 40 41 59 330 91 93 2173 61 40 2167 43 648 41 46 2170 40 41 59 604 123 2174 2175 61 418 2174 40 2172 44 1500 41 59 2175 46 2176 61 418 2177 40 1500 44 1500 41 59 2178 2179 61 418 2178 40 41 59 2179 46 2180 61 418 2181 91 93 123 418 2182 40 2169 44 1500 41 125 59 2179 46 2176 61 2175 59 2179 46 2183 61 648 46 2170 40 41 59 2161 46 2163 40 2179 41 59 125 604 123 2184 2185 61 418 2184 40 2173 44 1500 41 59 2185 46 2186 61 418 2187 40 1500 44 1500 41 59 2188 2189 61 418 2188 40 41 59 2189 46 2190 61 418 2191 91 93 123 418 2192 40 2171 44 1500 41 125 59 2189 46 2186 61 2185 59 2189 46 2193 61 648 46 2170 40 41 59 2161 46 2163 40 2189 41 59 125 392 40 2107 631 424 41 2161 46 2163 40 2107 41 59 2152 46 2161 61 2161 46 2194 40 418 2106 91 1500 93 41 59 2104 2195 61 2196 40 1500 44 2020 46 2197 40 41 44 2022 41 59 2104 2198 61 2196 40 1501 44 2020 46 2197 40 41 44 2022 41 59 2199 91 93 2200 61 2201 40 2195 41 59 2199 91 93 2202 61 2201 40 2198 41 59 2203 40 2195 41 59 2203 40 2198 41 59 2204 2205 61 418 2204 40 2169 44 1500 44 2195 44 2206 46 2207 41 59 2204 2208 61 418 2204 40 2171 44 1500 44 2198 44 2206 46 2207 41 59 2205 46 2209 61 2200 59 2208 46 2209 61 2202 59 2152 46 2210 61 418 2204 91 93 123 2205 44 2208 125 59 2152 46 2105 61 2105 59 2006 2211 61 418 2006 40 2020 46 2166 40 41 41 59 2006 2212 61 2020 46 2213 40 41 46 2214 62 1500 63 418 2006 40 2020 46 2213 40 41 41 58 2090 63 648 58 648 59 2006 2215 61 2216 46 2217 40 2022 44 2212 44 2211 41 59 2152 46 2218 61 2215 46 2170 40 41 59 2199 91 93 2219 61 2220 40 2089 44 2088 44 2020 46 2221 40 41 41 59 2199 91 93 2222 61 2223 40 2152 44 2224 40 2020 46 2225 40 41 46 2226 40 41 41 41 59 2152 46 2209 61 2227 40 2219 44 2222 44 2199 46 334 41 59 392 40 2107 631 424 41 2228 40 2022 44 2152 41 59 2020 46 2229 40 2152 41 59 2230 46 2231 46 2232 40 2233 40 2022 44 2152 41 41 59 125 437 492 2234 40 2087 2088 44 324 2089 44 2104 2105 44 2106 2107 44 2019 2020 44 2021 2022 44 324 2090 44 2095 2096 41 123 2235 2236 61 418 2235 40 40 40 2237 41 2022 46 2238 40 41 46 2239 40 41 41 46 2240 41 59 2236 46 2241 635 2242 59 2236 46 2243 61 2244 40 2096 41 59 2006 2245 61 418 2006 40 2020 46 2246 40 41 41 59 330 91 93 2247 61 40 2245 43 648 41 46 2248 40 41 59 330 91 93 2249 61 40 2245 43 648 41 46 2248 40 41 59 2017 60 2106 62 2250 61 418 2251 60 2106 62 40 41 59 2250 46 2252 40 2253 40 2020 44 2022 44 473 41 41 59 330 91 93 2254 61 648 46 2248 40 41 59 2104 2255 61 418 2256 40 2257 44 2258 41 59 2255 61 2259 40 1502 44 473 44 2022 44 2255 44 2020 46 2260 40 41 41 59 2261 2262 61 418 2261 40 41 59 2262 46 2263 61 418 2264 40 2254 44 1500 41 59 2262 46 2265 61 648 46 2248 40 41 59 2261 2266 61 418 2261 40 41 59 2267 2268 61 418 2267 40 2247 44 1500 41 59 2268 46 2263 61 418 2269 40 1500 44 1500 41 59 2266 46 2263 61 2268 59 2266 46 2265 61 418 330 91 93 123 607 44 607 44 607 125 59 2266 46 2270 61 418 2271 91 93 123 2262 125 59 2261 2272 61 418 2261 40 41 59 2272 46 2263 61 418 2264 40 2254 44 1500 41 59 2272 46 2265 61 648 46 2248 40 41 59 2261 2273 61 418 2261 40 41 59 2267 2274 61 418 2267 40 2249 44 1500 41 59 2274 46 2263 61 418 2269 40 1500 44 1500 41 59 2273 46 2263 61 2274 59 2273 46 2265 61 418 330 91 93 123 607 44 607 44 607 125 59 2273 46 2270 61 418 2271 91 93 123 2272 125 59 2275 2276 61 418 2275 40 2254 44 1500 44 1500 41 59 2276 46 2277 61 2255 59 2278 2279 61 418 2278 40 2276 44 1500 41 59 2261 2280 61 418 2261 40 41 59 2280 46 2265 61 418 330 91 93 123 607 44 607 44 607 44 607 44 607 44 607 44 607 44 607 125 59 2280 46 2263 61 418 2264 40 2020 46 2246 40 41 44 1500 41 59 2279 46 2281 61 2280 59 2282 2283 61 418 2282 40 1500 41 59 2283 46 2250 61 418 2106 91 93 123 2266 44 2273 125 59 2279 46 2284 61 2283 59 2250 46 2252 40 2279 41 59 2104 2285 61 418 2256 40 2286 44 2258 41 59 2285 61 2259 40 1502 44 473 44 2022 44 2285 44 2020 46 2260 40 41 41 59 2287 2288 61 418 2287 40 2020 46 2246 40 41 44 1500 44 2285 44 2289 46 2290 41 59 2291 40 2022 44 2020 44 2250 44 2288 41 59 392 40 2107 631 424 41 2250 46 2252 40 2107 41 59 2236 46 2250 61 2250 46 2292 40 418 2106 91 1500 93 41 59 2236 46 2270 61 418 2287 91 93 123 2288 125 59 2236 46 2105 61 2105 59 2006 2293 61 418 2006 40 2020 46 2246 40 41 41 59 2006 2294 61 2020 46 2295 40 41 46 2296 62 1500 63 418 2006 40 2020 46 2295 40 41 41 58 2090 63 648 58 648 59 2006 2297 61 2298 46 2299 40 2022 44 2294 44 2293 41 59 2236 46 2265 61 2297 46 2248 40 41 59 2300 91 93 2301 61 2302 40 2089 44 2088 44 2020 46 2303 40 41 41 59 2300 91 93 2304 61 2305 40 2236 44 2306 40 2020 46 2307 40 41 46 2308 40 41 41 41 59 2236 46 2309 61 2310 40 2301 44 2304 44 2300 46 334 41 59 392 40 2107 631 424 41 2311 40 2022 44 2236 41 59 2020 46 2312 40 2236 41 59 2313 40 2022 44 2236 41 59 125 64 2004 439 492 2314 40 2019 2020 44 2021 2022 44 2017 60 2106 62 2315 44 330 91 93 2316 44 2006 2317 41 123 392 40 2318 40 2022 41 41 123 2319 46 2314 40 2020 44 2022 44 2315 44 2316 44 2317 41 59 450 59 125 392 40 2020 46 2320 40 41 46 2321 40 648 41 41 123 2315 46 2322 40 2323 40 2020 44 2022 44 473 44 648 44 648 44 648 44 2317 41 41 59 125 360 123 2315 46 2324 40 2325 40 2020 44 2022 44 473 44 473 44 380 44 473 44 648 44 2317 41 41 59 125 125 64 2004 438 404 2326 40 41 123 450 1502 59 125 125 
31259,Java,"			TypeReferenceMaker returnTypeMaker = new TypeReferenceMaker() {
				@Override public TypeReference make() {
					return job.oldChain ? cloneSelfType(job.builderType) : TypeReference.baseTypeReference(TypeIds.T_void, 0);
				}
			};",0,2000 2001 61 418 2000 40 41 123 64 2002 439 2003 2004 40 41 123 450 2005 46 2006 63 2007 40 2005 46 2008 41 58 2003 46 2009 40 2010 46 2011 44 1500 41 59 125 125 59 
31260,Java,"			StatementMaker returnStatementMaker = new StatementMaker() {
				@Override public ReturnStatement make() {
					return job.oldChain ? new ReturnStatement(new ThisReference(0, 0), 0, 0) : null;
				}
			};",0,2000 2001 61 418 2000 40 41 123 64 2002 439 2003 2004 40 41 123 450 2005 46 2006 63 418 2003 40 418 2007 40 1500 44 1500 41 44 1500 44 1500 41 58 424 59 125 125 59 
30834,Java,"		WITH_BY {
			@Override public String apply( final EclipseNode node) {
				return applySetter(node, ""WITHBY|WITH_BY"");
			}
		};",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 41 123 450 2006 40 2005 44 648 41 59 125 125 59 
29378,Java,"	private static final class MethodId<J> {
		private final Class<?> owner;
		private final String name;
		private final Class<J> returnType;
		private final Class<?>[] paramTypes;
		
		MethodId(Class<?> owner, String name, Class<J> returnType, Class<?>... types) {
			this.owner = owner;
			this.name = name;
			this.paramTypes = types;
			this.returnType = returnType;
		}
		
		@Override public String toString() {
			StringBuilder out = new StringBuilder();
			out.append(returnType.getName()).append("" "").append(owner.getName()).append(""."").append(name).append(""("");
			boolean f = true;
			for (Class<?> p : paramTypes) {
				if (f) f = false;
				else out.append("", "");
				out.append(p.getName());
			}
			return out.append("")"").toString();
		}
	}",0,437 457 381 334 2000 60 2001 62 123 437 381 2002 60 63 62 2003 59 437 381 2004 2005 59 437 381 2002 60 2001 62 2006 59 437 381 2002 60 63 62 91 93 2007 59 2000 40 2002 60 63 62 2003 44 2004 2005 44 2002 60 2001 62 2006 44 2002 60 63 62 613 2008 41 123 467 46 2003 61 2003 59 467 46 2005 61 2005 59 467 46 2007 61 2008 59 467 46 2006 61 2006 59 125 64 2009 439 2004 2010 40 41 123 2011 430 61 418 2011 40 41 59 430 46 2012 40 2006 46 2013 40 41 41 46 2012 40 648 41 46 2012 40 2003 46 2013 40 41 41 46 2012 40 648 41 46 2012 40 2005 41 46 2012 40 648 41 59 324 2014 61 473 59 385 40 2002 60 63 62 2015 58 2007 41 123 392 40 2014 41 2014 61 380 59 360 430 46 2012 40 648 41 59 430 46 2012 40 2015 46 2013 40 41 41 59 125 450 430 46 2012 40 648 41 46 2010 40 41 59 125 125 
29380,Java,"	public static class TreeTag extends SchroedingerType {
		private static final ConcurrentMap<String, Object> TREE_TAG_CACHE = new ConcurrentHashMap<String, Object>();
		private static final Field TAG_FIELD;
		private static final Method TAG_METHOD;
		private static final MethodId<Integer> OP_PREC = MethodId(TreeInfo.class, ""opPrec"", int.class, TreeTag.class);
		
		static {
			Method m = null;
			try {
				m = Permit.getMethod(JCTree.class, ""getTag"");
			} catch (NoSuchMethodException e) {}
			
			if (m != null) {
				TAG_FIELD = null;
				TAG_METHOD = m;
			} else {
				Field f = null;
				try {
					f = Permit.getField(JCTree.class, ""tag"");
				} catch (NoSuchFieldException e) {}
				TAG_FIELD = f;
				TAG_METHOD = null;
			}
		}
		
		private TreeTag(Object value) {
			super(value);
		}
		
		public static TreeTag treeTag(JCTree o) {
			try {
				if (TAG_METHOD != null) return new TreeTag(TAG_METHOD.invoke(o));
				else return new TreeTag(TAG_FIELD.get(o));
			} catch (InvocationTargetException e) {
				throw Javac.sneakyThrow(e.getCause());
			} catch (IllegalAccessException e) {
				throw Javac.sneakyThrow(e);
			}
		}
		
		public static TreeTag treeTag(String identifier) {
			return new TreeTag(getFieldCached(TREE_TAG_CACHE, Javac.getJavaCompilerVersion() < 8 ? ""com.sun.tools.javac.tree.JCTree"" : ""com.sun.tools.javac.tree.JCTree$Tag"", identifier));
		}
		
		public int getOperatorPrecedenceLevel() {
			return invokeAny(null, OP_PREC, value);
		}
		
		public boolean isPrefixUnaryOp() {
			return Javac.CTC_NEG.equals(this) || Javac.CTC_POS.equals(this) || Javac.CTC_NOT.equals(this) || Javac.CTC_COMPL.equals(this) || Javac.CTC_PREDEC.equals(this) || Javac.CTC_PREINC.equals(this);
		}
	}",0,439 457 334 2000 378 2001 123 437 457 381 2002 60 2003 44 2004 62 2005 61 418 2006 60 2003 44 2004 62 40 41 59 437 457 381 2007 2008 59 437 457 381 2009 2010 59 437 457 381 2011 60 2012 62 2013 61 2011 40 2014 46 334 44 648 44 404 46 334 44 2000 46 334 41 59 457 123 2009 2015 61 424 59 474 123 2015 61 2016 46 2017 40 2018 46 334 44 648 41 59 125 329 40 2019 2020 41 123 125 392 40 2015 631 424 41 123 2008 61 424 59 2010 61 2015 59 125 360 123 2007 2021 61 424 59 474 123 2021 61 2022 46 2023 40 2024 46 334 44 648 41 59 125 329 40 2025 2020 41 123 125 2008 61 2021 59 2010 61 424 59 125 125 437 2000 40 2004 2026 41 123 463 40 2026 41 59 125 439 457 2000 2027 40 2028 2029 41 123 474 123 392 40 2010 631 424 41 450 418 2000 40 2010 46 2030 40 2029 41 41 59 360 450 418 2000 40 2008 46 2031 40 2029 41 41 59 125 329 40 2032 2033 41 123 469 2034 46 2035 40 2033 46 2036 40 41 41 59 125 329 40 2037 2033 41 123 469 2038 46 2039 40 2033 41 59 125 125 439 457 2000 2027 40 2003 2040 41 123 450 418 2000 40 2041 40 2005 44 2042 46 2043 40 41 60 1502 63 648 58 648 44 2040 41 41 59 125 439 404 2044 40 41 123 450 2045 40 424 44 2013 44 2026 41 59 125 439 324 2046 40 41 123 450 2047 46 2048 46 2049 40 467 41 606 2047 46 2050 46 2049 40 467 41 606 2047 46 2051 46 2049 40 467 41 606 2047 46 2052 46 2049 40 467 41 606 2047 46 2053 46 2049 40 467 41 606 2047 46 2054 46 2049 40 467 41 59 125 125 
30496,Java,"		SETTER {
			@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {
				return applySetter(cu, node, ""SETTER"");
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 44 381 2006 2007 41 123 450 2008 40 2005 44 2007 44 648 41 59 125 125 44 
30498,Java,"		WITH_BY {
			@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {
				return applySetter(cu, node, ""WITHBY|WITH_BY"");
			}
		};",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 44 381 2006 2007 41 123 450 2008 40 2005 44 2007 44 648 41 59 125 125 59 
30502,Java,"	static class JCAnnotatedTypeReflect {
		private static Class<?> TYPE;
		private static Constructor<?> CONSTRUCTOR;
		private static Field ANNOTATIONS, UNDERLYING_TYPE;
		
		private static void initByLoader(ClassLoader classLoader) {
			if (TYPE != null) return;
			Class<?> c;
			try {
				c = classLoader.loadClass(""com.sun.tools.javac.tree.JCTree$JCAnnotatedType"");
			} catch (Exception e) {
				return;
			}
			init(c);
		}
		
		private static void init(Class<?> in) {
			if (TYPE != null) return;
			if (!in.getName().equals(""com.sun.tools.javac.tree.JCTree$JCAnnotatedType"")) return;
			try {
				CONSTRUCTOR = Permit.getConstructor(in, List.class, JCExpression.class);
				ANNOTATIONS = Permit.getField(in, ""annotations"");
				UNDERLYING_TYPE = Permit.getField(in, ""underlyingType"");
				TYPE = in;
			} catch (Exception ignore) {}
		}
		
		static boolean is(JCTree obj) {
			if (obj == null) return false;
			init(obj.getClass());
			return obj.getClass() == TYPE;
		}
		
		@SuppressWarnings(""unchecked"")
		static List<JCAnnotation> getAnnotations(JCTree obj) {
			init(obj.getClass());
			try {
				return (List<JCAnnotation>) ANNOTATIONS.get(obj);
			} catch (Exception e) {
				return List.nil();
			}
		}
		
		static void setAnnotations(JCTree obj, List<JCAnnotation> anns) {
			init(obj.getClass());
			try {
				ANNOTATIONS.set(obj, anns);
			} catch (Exception e) {}
		}
		
		static JCExpression getUnderlyingType(JCTree obj) {
			init(obj.getClass());
			try {
				return (JCExpression) UNDERLYING_TYPE.get(obj);
			} catch (Exception e) {
				return null;
			}
		}
		
		static JCExpression create(List<JCAnnotation> annotations, JCExpression underlyingType) {
			initByLoader(underlyingType.getClass().getClassLoader());
			try {
				return (JCExpression) CONSTRUCTOR.newInstance(annotations, underlyingType);
			} catch (Exception e) {
				return underlyingType;
			}
		}
	}",0,457 334 2000 123 437 457 2001 60 63 62 2002 59 437 457 2003 60 63 62 2004 59 437 457 2005 2006 44 2007 59 437 457 492 2008 40 2009 2010 41 123 392 40 2002 631 424 41 450 59 2001 60 63 62 2011 59 474 123 2011 61 2010 46 2012 40 648 41 59 125 329 40 2013 2014 41 123 450 59 125 2015 40 2011 41 59 125 437 457 492 2016 40 2001 60 63 62 398 41 123 392 40 2002 631 424 41 450 59 392 40 33 398 46 2017 40 41 46 2018 40 648 41 41 450 59 474 123 2004 61 2019 46 2020 40 398 44 2021 46 334 44 2022 46 334 41 59 2006 61 2019 46 2023 40 398 44 648 41 59 2007 61 2019 46 2023 40 398 44 648 41 59 2002 61 398 59 125 329 40 2024 2025 41 123 125 125 457 324 407 40 2026 2027 41 123 392 40 2027 614 424 41 450 380 59 2016 40 2027 46 2028 40 41 41 59 450 2027 46 2028 40 41 614 2002 59 125 64 2029 40 648 41 457 2030 60 2031 62 2032 40 2026 2027 41 123 2016 40 2027 46 2033 40 41 41 59 474 123 450 40 2030 60 2031 62 41 2006 46 2034 40 2027 41 59 125 329 40 2035 2036 41 123 450 2030 46 2037 40 41 59 125 125 457 492 2038 40 2026 2027 44 2030 60 2031 62 2039 41 123 2016 40 2027 46 2040 40 41 41 59 474 123 2006 46 2041 40 2027 44 2039 41 59 125 329 40 2042 2043 41 123 125 125 457 2044 2045 40 2026 2027 41 123 2016 40 2027 46 2046 40 41 41 59 474 123 450 40 2044 41 2007 46 2047 40 2027 41 59 125 329 40 2048 2049 41 123 450 424 59 125 125 457 2044 2050 40 2030 60 2031 62 2051 44 2044 2052 41 123 2008 40 2052 46 2053 40 41 46 2054 40 41 41 59 474 123 450 40 2044 41 2004 46 2055 40 2051 44 2052 41 59 125 329 40 2056 2057 41 123 450 2052 59 125 125 125 
30494,Java,"		GETTER {
			@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {
				final JCTree n = node.get();
				String javadoc = Javac.getDocComment(cu, n);
				// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.
				String out = getJavadocSection(javadoc, ""GETTER"");
				final boolean sectionBased = out != null;
				if (!sectionBased) {
					out = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);
				}
				node.getAst().cleanupTask(""javadocfilter-getter"", n, new CleanupTask() {
					@Override public void cleanup() {
						String javadoc = Javac.getDocComment(cu, n);
						if (javadoc == null || javadoc.isEmpty()) return;
						javadoc = stripSectionsFromJavadoc(javadoc);
						if (!sectionBased) {
							javadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);
						}
						Javac.setDocComment(cu, n, javadoc);
					}
				});
				return out;
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 44 381 2006 2007 41 123 381 2008 2009 61 2007 46 2010 40 41 59 2002 2011 61 2012 46 2013 40 2005 44 2009 41 59 621 2002 430 61 2014 40 2011 44 648 41 59 381 324 2015 61 430 631 424 59 392 40 33 2015 41 123 430 61 2016 40 2017 40 2011 41 44 2018 46 2019 41 59 125 2007 46 2020 40 41 46 2021 40 648 44 2009 44 418 2022 40 41 123 64 2001 439 492 2023 40 41 123 2002 2011 61 2012 46 2013 40 2005 44 2009 41 59 392 40 2011 614 424 606 2011 46 2024 40 41 41 450 59 2011 61 2025 40 2011 41 59 392 40 33 2015 41 123 2011 61 2026 40 2025 40 2011 41 44 2027 46 2028 41 59 125 2012 46 2029 40 2005 44 2009 44 2011 41 59 125 125 41 59 450 430 59 125 125 44 
30495,Java,"				node.getAst().cleanupTask(""javadocfilter-getter"", n, new CleanupTask() {
					@Override public void cleanup() {
						String javadoc = Javac.getDocComment(cu, n);
						if (javadoc == null || javadoc.isEmpty()) return;
						javadoc = stripSectionsFromJavadoc(javadoc);
						if (!sectionBased) {
							javadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);
						}
						Javac.setDocComment(cu, n, javadoc);
					}
				});",0,2000 46 2001 40 41 46 2002 40 648 44 2003 44 418 2004 40 41 123 64 2005 439 492 2006 40 41 123 2007 2008 61 2009 46 2010 40 2011 44 2003 41 59 392 40 2008 614 424 606 2008 46 2012 40 41 41 450 59 2008 61 2013 40 2008 41 59 392 40 33 2014 41 123 2008 61 2015 40 2013 40 2008 41 44 2016 46 2017 41 59 125 2009 46 2018 40 2011 44 2003 44 2008 41 59 125 125 41 59 
30744,Java,"      public static @java.lang.SuppressWarnings(""all"") class TestBuilderBuilder {
        private @java.lang.SuppressWarnings(""all"") String field;
        @java.lang.SuppressWarnings(""all"") TestBuilderBuilder() {
          super();
        }
        /**
         * @return {@code this}.
         */
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder field(final String field) {
          this.field = field;
          return this;
        }
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder build() {
          return new BuilderNestedInEnum.TestEnum.TestBuilder(this.field);
        }
        public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
          return ((""BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder(field="" + this.field) + "")"");
        }
      }",0,439 457 64 2000 46 2001 46 2002 40 648 41 334 2003 123 437 64 2000 46 2001 46 2002 40 648 41 2004 2005 59 64 2000 46 2001 46 2002 40 648 41 2003 40 41 123 463 40 41 59 125 618 439 64 2000 46 2001 46 2002 40 648 41 2006 46 2007 46 2008 46 2003 2005 40 381 2004 2005 41 123 467 46 2005 61 2005 59 450 467 59 125 439 64 2000 46 2001 46 2002 40 648 41 2006 46 2007 46 2008 2009 40 41 123 450 418 2006 46 2007 46 2008 40 467 46 2005 41 59 125 439 64 2000 46 2001 46 2010 64 2000 46 2001 46 2002 40 648 41 2000 46 2001 46 2004 2011 40 41 123 450 40 40 648 43 467 46 2005 41 43 648 41 59 125 125 
31351,Java,"			@java.lang.SuppressWarnings(""all"")
			public static class TestBuilderBuilder {
				@java.lang.SuppressWarnings(""all"")
				private String field;
				@java.lang.SuppressWarnings(""all"")
				TestBuilderBuilder() {
				}
				/**
				 * @return {@code this}.
				 */
				@java.lang.SuppressWarnings(""all"")
				public BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder field(final String field) {
					this.field = field;
					return this;
				}
				@java.lang.SuppressWarnings(""all"")
				public BuilderNestedInEnum.TestEnum.TestBuilder build() {
					return new BuilderNestedInEnum.TestEnum.TestBuilder(this.field);
				}
				@java.lang.Override
				@java.lang.SuppressWarnings(""all"")
				public java.lang.String toString() {
					return ""BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder(field="" + this.field + "")"";
				}
			}",0,64 2000 46 2001 46 2002 40 648 41 439 457 334 2003 123 64 2000 46 2001 46 2002 40 648 41 437 2004 2005 59 64 2000 46 2001 46 2002 40 648 41 2003 40 41 123 125 618 64 2000 46 2001 46 2002 40 648 41 439 2006 46 2007 46 2008 46 2003 2005 40 381 2004 2005 41 123 467 46 2005 61 2005 59 450 467 59 125 64 2000 46 2001 46 2002 40 648 41 439 2006 46 2007 46 2008 2009 40 41 123 450 418 2006 46 2007 46 2008 40 467 46 2005 41 59 125 64 2000 46 2001 46 2010 64 2000 46 2001 46 2002 40 648 41 439 2000 46 2001 46 2004 2011 40 41 123 450 648 43 467 46 2005 43 648 59 125 125 
32924,Java,"    public class NaughtyException extends RuntimeException {
        public NaughtyException() {
            throw new RuntimeException(""boo!"");
        }
    }",0,439 334 2000 378 2001 123 439 2000 40 41 123 469 418 2001 40 648 41 59 125 125 
33698,Java,"    class Dog {

        public String bark() {
            return ""woof"";
        }
    }",0,334 2000 123 439 2001 2002 40 41 123 450 648 59 125 125 
33699,Java,"    static class Person {

        void ride(Bike bike) {}

        void drive(Car car) {}
    }",0,457 334 2000 123 492 2001 40 2002 2003 41 123 125 492 2004 40 2005 2006 41 123 125 125 
33700,Java,"    static class Police {

        void chase(Car car) {}
    }",0,457 334 2000 123 492 2001 40 2002 2003 41 123 125 125 
33702,Java,"                        new Answer<String>() {
                            public String answer(InvocationOnMock invocation) throws Throwable {
                                return invocation.getArgument(0);
                            }
                        })",0,418 2000 60 2001 62 40 41 123 439 2001 2002 40 2003 2004 41 470 2005 123 450 2004 46 2006 40 1500 41 59 125 125 41 
33098,Java,"        return new Answer<Object>() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                return null;
            }
        };",0,450 418 2000 60 2001 62 40 41 123 64 2002 439 2001 2003 40 2004 2005 41 470 2006 123 450 424 59 125 125 59 
32579,Java,"@SuppressWarnings(""unchecked"")
public class BDDMockito extends Mockito {

    /**
     * See original {@link OngoingStubbing}
     * @since 1.8.0
     */
    public interface BDDMyOngoingStubbing<T> {

        /**
         * See original {@link OngoingStubbing#thenAnswer(Answer)}
         * @since 1.8.0
         */
        BDDMyOngoingStubbing<T> willAnswer(Answer<?> answer);

        /**
         * See original {@link OngoingStubbing#then(Answer)}
         * @since 1.9.0
         */
        BDDMyOngoingStubbing<T> will(Answer<?> answer);

        /**
         * See original {@link OngoingStubbing#thenReturn(Object)}
         * @since 1.8.0
         */
        BDDMyOngoingStubbing<T> willReturn(T value);

        /**
         * See original {@link OngoingStubbing#thenReturn(Object, Object[])}
         * @since 1.8.0
         */
        @SuppressWarnings({""unchecked"", ""varargs""})
        BDDMyOngoingStubbing<T> willReturn(T value, T... values);

        /**
         * See original {@link OngoingStubbing#thenThrow(Throwable...)}
         * @since 1.8.0
         */
        BDDMyOngoingStubbing<T> willThrow(Throwable... throwables);

        /**
         * See original {@link OngoingStubbing#thenThrow(Class)}
         * @since 2.1.0
         */
        BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable> throwableType);

        /**
         * See original {@link OngoingStubbing#thenThrow(Class, Class[])}
         * @since 2.1.0
         */
        // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array
        // creation
        @SuppressWarnings({""unchecked"", ""varargs""})
        BDDMyOngoingStubbing<T> willThrow(
                Class<? extends Throwable> throwableType,
                Class<? extends Throwable>... throwableTypes);

        /**
         * See original {@link OngoingStubbing#thenCallRealMethod()}
         * @since 1.9.0
         */
        BDDMyOngoingStubbing<T> willCallRealMethod();

        /**
         * See original {@link OngoingStubbing#getMock()}
         * @since 1.9.0
         */
        <M> M getMock();
    }

    private static class BDDOngoingStubbingImpl<T> implements BDDMyOngoingStubbing<T> {

        private final OngoingStubbing<T> mockitoOngoingStubbing;

        public BDDOngoingStubbingImpl(OngoingStubbing<T> ongoingStubbing) {
            this.mockitoOngoingStubbing = ongoingStubbing;
        }

        public BDDMyOngoingStubbing<T> willAnswer(Answer<?> answer) {
            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenAnswer(answer));
        }

        public BDDMyOngoingStubbing<T> will(Answer<?> answer) {
            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.then(answer));
        }

        public BDDMyOngoingStubbing<T> willReturn(T value) {
            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenReturn(value));
        }

        public BDDMyOngoingStubbing<T> willReturn(T value, T... values) {
            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenReturn(value, values));
        }

        public BDDMyOngoingStubbing<T> willThrow(Throwable... throwables) {
            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwables));
        }

        public BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable> throwableType) {
            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwableType));
        }

        public BDDMyOngoingStubbing<T> willThrow(
                Class<? extends Throwable> throwableType,
                Class<? extends Throwable>... throwableTypes) {
            return new BDDOngoingStubbingImpl<T>(
                    mockitoOngoingStubbing.thenThrow(throwableType, throwableTypes));
        }

        public BDDMyOngoingStubbing<T> willCallRealMethod() {
            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenCallRealMethod());
        }

        public <M> M getMock() {
            return (M) mockitoOngoingStubbing.getMock();
        }
    }

    /**
     * see original {@link Mockito#when(Object)}
     * @since 1.8.0
     */
    public static <T> BDDMyOngoingStubbing<T> given(T methodCall) {
        return new BDDOngoingStubbingImpl<T>(Mockito.when(methodCall));
    }

    /**
     * Bdd style verification of mock behavior.
     *
     * <pre class=""code""><code class=""java"">
     *   person.ride(bike);
     *   person.ride(bike);
     *
     *   then(person).should(times(2)).ride(bike);
     * </code></pre>
     *
     * @see #verify(Object)
     * @see #verify(Object, VerificationMode)
     * @since 1.10.0
     */
    public static <T> Then<T> then(T mock) {
        return new ThenImpl<T>(mock);
    }

    /**
     * Provides fluent way of mock verification.
     *
     * @param <T> type of the mock
     *
     * @since 1.10.5
     */
    public interface Then<T> {

        /**
         * @see #verify(Object)
         * @since 1.10.5
         */
        T should();

        /**
         * @see #verify(Object, VerificationMode)
         * @since 1.10.5
         */
        T should(VerificationMode mode);

        /**
         * @see InOrder#verify(Object)
         * @since 2.1.0
         */
        T should(InOrder inOrder);

        /**
         * @see InOrder#verify(Object, VerificationMode)
         * @since 2.1.0
         */
        T should(InOrder inOrder, VerificationMode mode);

        /**
         * @see #verifyNoMoreInteractions(Object...)
         * @since 2.1.0
         */
        void shouldHaveNoMoreInteractions();

        /**
         * @see #verifyNoInteractions(Object...)
         * @since 3.0.1
         */
        void shouldHaveNoInteractions();
    }

    private static class ThenImpl<T> implements Then<T> {

        private final T mock;

        ThenImpl(T mock) {
            this.mock = mock;
        }

        /**
         * @see #verify(Object)
         * @since 1.10.5
         */
        public T should() {
            return verify(mock);
        }

        /**
         * @see #verify(Object, VerificationMode)
         * @since 1.10.5
         */
        public T should(VerificationMode mode) {
            return verify(mock, mode);
        }

        /**
         * @see InOrder#verify(Object)
         * @since 2.1.0
         */
        public T should(InOrder inOrder) {
            return inOrder.verify(mock);
        }

        /**
         * @see InOrder#verify(Object, VerificationMode)
         * @since 2.1.0
         */
        public T should(InOrder inOrder, VerificationMode mode) {
            return inOrder.verify(mock, mode);
        }

        /**
         * @see #verifyNoMoreInteractions(Object...)
         * @since 2.1.0
         */
        public void shouldHaveNoMoreInteractions() {
            verifyNoMoreInteractions(mock);
        }

        /**
         * @see #verifyNoInteractions(Object...)
         * @since 3.0.1
         */
        public void shouldHaveNoInteractions() {
            verifyNoInteractions(mock);
        }
    }

    /**
     * See original {@link Stubber}
     * @since 1.8.0
     */
    public interface BDDStubber {
        /**
         * See original {@link Stubber#doAnswer(Answer)}
         * @since 1.8.0
         */
        BDDStubber willAnswer(Answer<?> answer);

        /**
         * See original {@link Stubber#doAnswer(Answer)}
         * @since 1.8.0
         */
        BDDStubber will(Answer<?> answer);

        /**
         * See original {@link Stubber#doNothing()}
         * @since 1.10.20
         */
        BDDStubber willDoNothing();

        /**
         * See original {@link Stubber#doReturn(Object)}
         * @since 2.1.0
         */
        BDDStubber willReturn(Object toBeReturned);

        /**
         * See original {@link Stubber#doReturn(Object)}
         * @since 2.1.0
         */
        @SuppressWarnings({""unchecked"", ""varargs""})
        BDDStubber willReturn(Object toBeReturned, Object... nextToBeReturned);

        /**
         * See original {@link Stubber#doThrow(Throwable...)}
         * @since 1.8.0
         */
        BDDStubber willThrow(Throwable... toBeThrown);

        /**
         * See original {@link Stubber#doThrow(Class)}
         * @since 2.1.0
         */
        BDDStubber willThrow(Class<? extends Throwable> toBeThrown);

        /**
         * See original {@link Stubber#doThrow(Class, Class[])}
         * @since 2.1.0
         */
        @SuppressWarnings({""unchecked"", ""varargs""})
        BDDStubber willThrow(
                Class<? extends Throwable> toBeThrown,
                Class<? extends Throwable>... nextToBeThrown);

        /**
         * See original {@link Stubber#doCallRealMethod()}
         * @since 1.9.0
         */
        BDDStubber willCallRealMethod();

        /**
         * See original {@link Stubber#when(Object)}
         * @since 1.8.0
         */
        <T> T given(T mock);
    }

    private static class BDDStubberImpl implements BDDStubber {

        private final Stubber mockitoStubber;

        public BDDStubberImpl(Stubber mockitoStubber) {
            this.mockitoStubber = mockitoStubber;
        }

        public <T> T given(T mock) {
            return mockitoStubber.when(mock);
        }

        public BDDStubber willAnswer(Answer<?> answer) {
            return new BDDStubberImpl(mockitoStubber.doAnswer(answer));
        }

        public BDDStubber will(Answer<?> answer) {
            return new BDDStubberImpl(mockitoStubber.doAnswer(answer));
        }

        public BDDStubber willDoNothing() {
            return new BDDStubberImpl(mockitoStubber.doNothing());
        }

        public BDDStubber willReturn(Object toBeReturned) {
            return new BDDStubberImpl(mockitoStubber.doReturn(toBeReturned));
        }

        public BDDStubber willReturn(Object toBeReturned, Object... nextToBeReturned) {
            return new BDDStubberImpl(
                    mockitoStubber.doReturn(toBeReturned).doReturn(nextToBeReturned));
        }

        public BDDStubber willThrow(Throwable... toBeThrown) {
            return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown));
        }

        public BDDStubber willThrow(Class<? extends Throwable> toBeThrown) {
            return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown));
        }

        public BDDStubber willThrow(
                Class<? extends Throwable> toBeThrown,
                Class<? extends Throwable>... nextToBeThrown) {
            return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown, nextToBeThrown));
        }

        public BDDStubber willCallRealMethod() {
            return new BDDStubberImpl(mockitoStubber.doCallRealMethod());
        }
    }

    /**
     * see original {@link Mockito#doThrow(Throwable[])}
     * @since 2.1.0
     */
    public static BDDStubber willThrow(Throwable... toBeThrown) {
        return new BDDStubberImpl(Mockito.doThrow(toBeThrown));
    }

    /**
     * see original {@link Mockito#doThrow(Class)}
     * @since 1.9.0
     */
    public static BDDStubber willThrow(Class<? extends Throwable> toBeThrown) {
        return new BDDStubberImpl(Mockito.doThrow(toBeThrown));
    }

    /**
     * see original {@link Mockito#doThrow(Class)}
     * @since 1.9.0
     */
    public static BDDStubber willThrow(
            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... throwableTypes) {
        return new BDDStubberImpl(Mockito.doThrow(toBeThrown, throwableTypes));
    }

    /**
     * see original {@link Mockito#doAnswer(Answer)}
     * @since 1.8.0
     */
    public static BDDStubber willAnswer(Answer<?> answer) {
        return new BDDStubberImpl(Mockito.doAnswer(answer));
    }

    /**
     * see original {@link Mockito#doAnswer(Answer)}
     * @since 2.1.0
     */
    public static BDDStubber will(Answer<?> answer) {
        return new BDDStubberImpl(Mockito.doAnswer(answer));
    }

    /**
     * see original {@link Mockito#doNothing()}
     * @since 1.8.0
     */
    public static BDDStubber willDoNothing() {
        return new BDDStubberImpl(Mockito.doNothing());
    }

    /**
     * see original {@link Mockito#doReturn(Object)}
     * @since 1.8.0
     */
    public static BDDStubber willReturn(Object toBeReturned) {
        return new BDDStubberImpl(Mockito.doReturn(toBeReturned));
    }

    /**
     * see original {@link Mockito#doReturn(Object, Object...)}
     * @since 2.1.0
     */
    @SuppressWarnings({""unchecked"", ""varargs""})
    public static BDDStubber willReturn(Object toBeReturned, Object... toBeReturnedNext) {
        return new BDDStubberImpl(Mockito.doReturn(toBeReturned, toBeReturnedNext));
    }

    /**
     * see original {@link Mockito#doCallRealMethod()}
     * @since 1.8.0
     */
    public static BDDStubber willCallRealMethod() {
        return new BDDStubberImpl(Mockito.doCallRealMethod());
    }
}",0,64 2000 40 648 41 439 334 2001 378 2002 123 618 439 405 2003 60 2004 62 123 618 2003 60 2004 62 2005 40 2006 60 63 62 2007 41 59 618 2003 60 2004 62 2008 40 2006 60 63 62 2007 41 59 618 2003 60 2004 62 2009 40 2004 2010 41 59 618 64 2000 40 123 648 44 648 125 41 2003 60 2004 62 2009 40 2004 2010 44 2004 613 2011 41 59 618 2003 60 2004 62 2012 40 2013 613 2014 41 59 618 2003 60 2004 62 2012 40 2015 60 63 378 2013 62 2016 41 59 618 621 621 64 2000 40 123 648 44 648 125 41 2003 60 2004 62 2012 40 2015 60 63 378 2013 62 2016 44 2015 60 63 378 2013 62 613 2017 41 59 618 2003 60 2004 62 2018 40 41 59 618 60 2019 62 2019 2020 40 41 59 125 437 457 334 2021 60 2004 62 395 2003 60 2004 62 123 437 381 2022 60 2004 62 2023 59 439 2021 40 2022 60 2004 62 2024 41 123 467 46 2023 61 2024 59 125 439 2003 60 2004 62 2025 40 2026 60 63 62 2027 41 123 450 418 2021 60 2004 62 40 2023 46 2028 40 2027 41 41 59 125 439 2003 60 2004 62 2029 40 2026 60 63 62 2027 41 123 450 418 2021 60 2004 62 40 2023 46 2030 40 2027 41 41 59 125 439 2003 60 2004 62 2031 40 2004 2032 41 123 450 418 2021 60 2004 62 40 2023 46 2033 40 2032 41 41 59 125 439 2003 60 2004 62 2031 40 2004 2032 44 2004 613 2034 41 123 450 418 2021 60 2004 62 40 2023 46 2035 40 2032 44 2034 41 41 59 125 439 2003 60 2004 62 2036 40 2037 613 2038 41 123 450 418 2021 60 2004 62 40 2023 46 2039 40 2038 41 41 59 125 439 2003 60 2004 62 2036 40 2040 60 63 378 2037 62 2041 41 123 450 418 2021 60 2004 62 40 2023 46 2042 40 2041 41 41 59 125 439 2003 60 2004 62 2036 40 2040 60 63 378 2037 62 2041 44 2040 60 63 378 2037 62 613 2043 41 123 450 418 2021 60 2004 62 40 2023 46 2044 40 2041 44 2043 41 41 59 125 439 2003 60 2004 62 2045 40 41 123 450 418 2021 60 2004 62 40 2023 46 2046 40 41 41 59 125 439 60 2047 62 2047 2048 40 41 123 450 40 2047 41 2023 46 2048 40 41 59 125 125 618 439 457 60 2004 62 2003 60 2004 62 2049 40 2004 2050 41 123 450 418 2021 60 2004 62 40 2002 46 2051 40 2050 41 41 59 125 618 439 457 60 2004 62 2052 60 2004 62 2053 40 2004 2054 41 123 450 418 2055 60 2004 62 40 2054 41 59 125 618 439 405 2052 60 2004 62 123 618 2004 2056 40 41 59 618 2004 2056 40 2057 2058 41 59 618 2004 2056 40 2059 2060 41 59 618 2004 2056 40 2059 2060 44 2057 2058 41 59 618 492 2061 40 41 59 618 492 2062 40 41 59 125 437 457 334 2063 60 2004 62 395 2052 60 2004 62 123 437 381 2004 2054 59 2063 40 2004 2054 41 123 467 46 2054 61 2054 59 125 618 439 2004 2064 40 41 123 450 2065 40 2054 41 59 125 618 439 2004 2064 40 2066 2067 41 123 450 2068 40 2054 44 2067 41 59 125 618 439 2004 2064 40 2069 2070 41 123 450 2070 46 2071 40 2054 41 59 125 618 439 2004 2064 40 2069 2070 44 2066 2067 41 123 450 2070 46 2072 40 2054 44 2067 41 59 125 618 439 492 2073 40 41 123 2074 40 2054 41 59 125 618 439 492 2075 40 41 123 2076 40 2054 41 59 125 125 618 439 405 2077 123 618 2077 2078 40 2079 60 63 62 2080 41 59 618 2077 2081 40 2079 60 63 62 2080 41 59 618 2077 2082 40 41 59 618 2077 2083 40 2084 2085 41 59 618 64 2000 40 123 648 44 648 125 41 2077 2083 40 2084 2085 44 2084 613 2086 41 59 618 2077 2087 40 2088 613 2089 41 59 618 2077 2087 40 2090 60 63 378 2088 62 2089 41 59 618 64 2000 40 123 648 44 648 125 41 2077 2087 40 2090 60 63 378 2088 62 2089 44 2090 60 63 378 2088 62 613 2091 41 59 618 2077 2092 40 41 59 618 60 2004 62 2004 2049 40 2004 2054 41 59 125 437 457 334 2093 395 2077 123 437 381 2094 2095 59 439 2093 40 2094 2095 41 123 467 46 2095 61 2095 59 125 439 60 2004 62 2004 2049 40 2004 2054 41 123 450 2095 46 2096 40 2054 41 59 125 439 2077 2097 40 2098 60 63 62 2099 41 123 450 418 2093 40 2095 46 2100 40 2099 41 41 59 125 439 2077 2101 40 2098 60 63 62 2099 41 123 450 418 2093 40 2095 46 2102 40 2099 41 41 59 125 439 2077 2103 40 41 123 450 418 2093 40 2095 46 2104 40 41 41 59 125 439 2077 2105 40 2106 2107 41 123 450 418 2093 40 2095 46 2108 40 2107 41 41 59 125 439 2077 2105 40 2106 2107 44 2106 613 2109 41 123 450 418 2093 40 2095 46 2110 40 2107 41 46 2110 40 2109 41 41 59 125 439 2077 2111 40 2112 613 2113 41 123 450 418 2093 40 2095 46 2114 40 2113 41 41 59 125 439 2077 2111 40 2115 60 63 378 2112 62 2113 41 123 450 418 2093 40 2095 46 2116 40 2113 41 41 59 125 439 2077 2111 40 2115 60 63 378 2112 62 2113 44 2115 60 63 378 2112 62 613 2117 41 123 450 418 2093 40 2095 46 2118 40 2113 44 2117 41 41 59 125 439 2077 2119 40 41 123 450 418 2093 40 2095 46 2120 40 41 41 59 125 125 618 439 457 2077 2121 40 2122 613 2123 41 123 450 418 2093 40 2002 46 2124 40 2123 41 41 59 125 618 439 457 2077 2121 40 2125 60 63 378 2122 62 2123 41 123 450 418 2093 40 2002 46 2126 40 2123 41 41 59 125 618 439 457 2077 2121 40 2125 60 63 378 2122 62 2123 44 2125 60 63 378 2122 62 613 2127 41 123 450 418 2093 40 2002 46 2128 40 2123 44 2127 41 41 59 125 618 439 457 2077 2129 40 2130 60 63 62 2131 41 123 450 418 2093 40 2002 46 2132 40 2131 41 41 59 125 618 439 457 2077 2133 40 2130 60 63 62 2131 41 123 450 418 2093 40 2002 46 2134 40 2131 41 41 59 125 618 439 457 2077 2135 40 41 123 450 418 2093 40 2002 46 2136 40 41 41 59 125 618 439 457 2077 2137 40 2138 2139 41 123 450 418 2093 40 2002 46 2140 40 2139 41 41 59 125 618 64 2000 40 123 648 44 648 125 41 439 457 2077 2137 40 2138 2139 44 2138 613 2141 41 123 450 418 2093 40 2002 46 2142 40 2139 44 2141 41 41 59 125 618 439 457 2077 2143 40 41 123 450 418 2093 40 2002 46 2144 40 41 41 59 125 125 
32260,Java,"    public static class LookupI implements LInstruction{
        public int dest;
        public int from;
        public ContentType type;

        public LookupI(int dest, int from, ContentType type){
            this.dest = dest;
            this.from = from;
            this.type = type;
        }

        public LookupI(){
        }

        @Override
        public void run(LExecutor exec){
            exec.setobj(dest, constants.lookupContent(type, exec.numi(from)));
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 59 439 404 388 59 439 2003 2004 59 439 2000 40 404 2002 44 404 388 44 2003 2004 41 123 467 46 2002 61 2002 59 467 46 388 61 388 59 467 46 2004 61 2004 59 125 439 2000 40 41 123 125 64 2005 439 492 2006 40 2007 2008 41 123 2008 46 2009 40 2002 44 2010 46 2011 40 2004 44 2008 46 2012 40 388 41 41 41 59 125 125 
32262,Java,"    public static class PrintFlushI implements LInstruction{
        public int target;

        public PrintFlushI(int target){
            this.target = target;
        }

        public PrintFlushI(){
        }

        @Override
        public void run(LExecutor exec){

            if(exec.building(target) instanceof MessageBuild d && d.team == exec.team){

                d.message.setLength(0);
                d.message.append(exec.textBuffer, 0, Math.min(exec.textBuffer.length(), maxTextBuffer));

                exec.textBuffer.setLength(0);
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 59 439 2000 40 404 2002 41 123 467 46 2002 61 2002 59 125 439 2000 40 41 123 125 64 2003 439 492 2004 40 2005 2006 41 123 392 40 2006 46 2007 40 2002 41 402 2008 2009 605 2009 46 2010 614 2006 46 2010 41 123 2009 46 2011 46 2012 40 1500 41 59 2009 46 2011 46 2013 40 2006 46 2014 44 1500 44 2015 46 2016 40 2006 46 2014 46 2017 40 41 44 2018 41 41 59 2006 46 2014 46 2012 40 1500 41 59 125 125 125 
32255,Java,"    public static class ControlI implements LInstruction{
        public int target;
        public LAccess type = LAccess.enabled;
        public int p1, p2, p3, p4;

        public ControlI(LAccess type, int target, int p1, int p2, int p3, int p4){
            this.type = type;
            this.target = target;
            this.p1 = p1;
            this.p2 = p2;
            this.p3 = p3;
            this.p4 = p4;
        }

        ControlI(){}

        @Override
        public void run(LExecutor exec){
            Object obj = exec.obj(target);
            if(obj instanceof Building b && b.team == exec.team && exec.linkIds.contains(b.id)){
                if(type.isObj && exec.var(p1).isobj){
                    b.control(type, exec.obj(p1), exec.num(p2), exec.num(p3), exec.num(p4));
                }else{
                    b.control(type, exec.num(p1), exec.num(p2), exec.num(p3), exec.num(p4));
                }
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 59 439 2003 2004 61 2003 46 2005 59 439 404 2006 44 2007 44 2008 44 2009 59 439 2000 40 2003 2004 44 404 2002 44 404 2006 44 404 2007 44 404 2008 44 404 2009 41 123 467 46 2004 61 2004 59 467 46 2002 61 2002 59 467 46 2006 61 2006 59 467 46 2007 61 2007 59 467 46 2008 61 2008 59 467 46 2009 61 2009 59 125 2000 40 41 123 125 64 2010 439 492 2011 40 2012 2013 41 123 2014 2015 61 2013 46 2015 40 2002 41 59 392 40 2015 402 2016 2017 605 2017 46 2018 614 2013 46 2018 605 2013 46 2019 46 2020 40 2017 46 2021 41 41 123 392 40 2004 46 2022 605 2013 46 490 40 2006 41 46 2023 41 123 2017 46 2024 40 2004 44 2013 46 2015 40 2006 41 44 2013 46 2025 40 2007 41 44 2013 46 2025 40 2008 41 44 2013 46 2025 40 2009 41 41 59 125 360 123 2017 46 2026 40 2004 44 2013 46 2027 40 2006 41 44 2013 46 2027 40 2007 41 44 2013 46 2027 40 2008 41 44 2013 46 2027 40 2009 41 41 59 125 125 125 125 
32261,Java,"    public static class OpI implements LInstruction{
        public LogicOp op = LogicOp.add;
        public int a, b, dest;

        public OpI(LogicOp op, int a, int b, int dest){
            this.op = op;
            this.a = a;
            this.b = b;
            this.dest = dest;
        }

        OpI(){}

        @Override
        public void run(LExecutor exec){
            if(op == LogicOp.strictEqual){
                Var v = exec.var(a), v2 = exec.var(b);
                exec.setnum(dest, v.isobj == v2.isobj && ((v.isobj && v.objval == v2.objval) || (!v.isobj && v.numval == v2.numval)) ? 1 : 0);
            }else if(op.unary){
                exec.setnum(dest, op.function1.get(exec.num(a)));
            }else{
                Var va = exec.var(a);
                Var vb = exec.var(b);

                if(op.objFunction2 != null && va.isobj && vb.isobj){
                    //use object function if both are objects
                    exec.setnum(dest, op.objFunction2.get(exec.obj(a), exec.obj(b)));
                }else{
                    //otherwise use the numeric function
                    exec.setnum(dest, op.function2.get(exec.num(a), exec.num(b)));
                }

            }
        }
    }",0,439 457 334 2000 395 2001 123 439 2002 2003 61 2002 46 2004 59 439 404 2005 44 2006 44 2007 59 439 2000 40 2002 2003 44 404 2005 44 404 2006 44 404 2007 41 123 467 46 2003 61 2003 59 467 46 2005 61 2005 59 467 46 2006 61 2006 59 467 46 2007 61 2007 59 125 2000 40 41 123 125 64 2008 439 492 2009 40 2010 2011 41 123 392 40 2003 614 2002 46 2012 41 123 2013 2014 61 2011 46 490 40 2005 41 44 2015 61 2011 46 490 40 2006 41 59 2011 46 2016 40 2007 44 2014 46 2017 614 2015 46 2017 605 40 40 2014 46 2017 605 2014 46 2018 614 2015 46 2018 41 606 40 33 2014 46 2017 605 2014 46 2019 614 2015 46 2019 41 41 63 1501 58 1500 41 59 125 360 392 40 2003 46 2020 41 123 2011 46 2021 40 2007 44 2003 46 2022 46 2023 40 2011 46 2024 40 2005 41 41 41 59 125 360 123 2025 2026 61 2011 46 490 40 2005 41 59 2025 2027 61 2011 46 490 40 2006 41 59 392 40 2003 46 2028 631 424 605 2026 46 2029 605 2027 46 2029 41 123 621 2011 46 2030 40 2007 44 2003 46 2028 46 2031 40 2011 46 2032 40 2005 41 44 2011 46 2032 40 2006 41 41 41 59 125 360 123 621 2011 46 2033 40 2007 44 2003 46 2034 46 2035 40 2011 46 2036 40 2005 41 44 2011 46 2036 40 2006 41 41 41 59 125 125 125 125 
32264,Java,"    public static class ReadI implements LInstruction{
        public int target, position, output;

        public ReadI(int target, int position, int output){
            this.target = target;
            this.position = position;
            this.output = output;
        }

        public ReadI(){
        }

        @Override
        public void run(LExecutor exec){
            int address = exec.numi(position);
            Building from = exec.building(target);

            if(from instanceof MemoryBuild mem && from.team == exec.team){

                exec.setnum(output, address < 0 || address >= mem.memory.length ? 0 : mem.memory[address]);
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 44 2003 44 2004 59 439 2000 40 404 2002 44 404 2003 44 404 2004 41 123 467 46 2002 61 2002 59 467 46 2003 61 2003 59 467 46 2004 61 2004 59 125 439 2000 40 41 123 125 64 2005 439 492 2006 40 2007 2008 41 123 404 2009 61 2008 46 2010 40 2003 41 59 2011 388 61 2008 46 2012 40 2002 41 59 392 40 388 402 2013 2014 605 388 46 2015 614 2008 46 2015 41 123 2008 46 2016 40 2004 44 2009 60 1500 606 2009 615 2014 46 2017 46 2018 63 1500 58 2014 46 2017 91 2009 93 41 59 125 125 125 
32266,Java,"    public static class SetI implements LInstruction{
        public int from, to;

        public SetI(int from, int to){
            this.from = from;
            this.to = to;
        }

        SetI(){}

        @Override
        public void run(LExecutor exec){
            Var v = exec.var(to);
            Var f = exec.var(from);

            if(!v.constant){
                if(f.isobj){
                    v.objval = f.objval;
                    v.isobj = true;
                }else{
                    v.numval = invalid(f.numval) ? 0 : f.numval;
                    v.isobj = false;
                }
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 388 44 2002 59 439 2000 40 404 388 44 404 2002 41 123 467 46 388 61 388 59 467 46 2002 61 2002 59 125 2000 40 41 123 125 64 2003 439 492 2004 40 2005 2006 41 123 2007 2008 61 2006 46 490 40 2002 41 59 2007 2009 61 2006 46 490 40 388 41 59 392 40 33 2008 46 2010 41 123 392 40 2009 46 2011 41 123 2008 46 2012 61 2009 46 2012 59 2008 46 2011 61 473 59 125 360 123 2008 46 2013 61 2014 40 2009 46 2013 41 63 1500 58 2009 46 2013 59 2008 46 2011 61 380 59 125 125 125 125 
32267,Java,"    public static class UnitBindI implements LInstruction{
        public int type;

        public UnitBindI(int type){
            this.type = type;
        }

        public UnitBindI(){
        }

        @Override
        public void run(LExecutor exec){

            if(exec.binds == null || exec.binds.length != content.units().size){
                exec.binds = new int[content.units().size];
            }

            //binding to `null` was previously possible, but was too powerful and exploitable
            if(exec.obj(type) instanceof UnitType type){
                Seq<Unit> seq = exec.team.data().unitCache(type);

                if(seq != null && seq.any()){
                    exec.binds[type.id] %= seq.size;
                    if(exec.binds[type.id] < seq.size){
                        //bind to the next unit
                        exec.setconst(varUnit, seq.get(exec.binds[type.id]));
                    }
                    exec.binds[type.id] ++;
                }else{
                    //no units of this type found
                    exec.setconst(varUnit, null);
                }
            }else if(exec.obj(type) instanceof Unit u && u.team == exec.team){
                //bind to specific unit object
                exec.setconst(varUnit, u);
            }else{
                exec.setconst(varUnit, null);
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 59 439 2000 40 404 2002 41 123 467 46 2002 61 2002 59 125 439 2000 40 41 123 125 64 2003 439 492 2004 40 2005 2006 41 123 392 40 2006 46 2007 614 424 606 2006 46 2007 46 2008 631 2009 46 2010 40 41 46 2011 41 123 2006 46 2007 61 418 404 91 2009 46 2010 40 41 46 2011 93 59 125 621 392 40 2006 46 2012 40 2002 41 402 2013 2002 41 123 2014 60 2015 62 2016 61 2006 46 2017 46 2018 40 41 46 2019 40 2002 41 59 392 40 2016 631 424 605 2016 46 2020 40 41 41 123 2006 46 2007 91 2002 46 2021 93 630 2016 46 2011 59 392 40 2006 46 2007 91 2002 46 2021 93 60 2016 46 2011 41 123 621 2006 46 2022 40 2023 44 2016 46 2024 40 2006 46 2007 91 2002 46 2021 93 41 41 59 125 2006 46 2007 91 2002 46 2021 93 637 59 125 360 123 621 2006 46 2025 40 2026 44 424 41 59 125 125 360 392 40 2006 46 2012 40 2002 41 402 2027 2028 605 2028 46 2029 614 2006 46 2029 41 123 621 2006 46 2030 40 2031 44 2028 41 59 125 360 123 2006 46 2032 40 2033 44 424 41 59 125 125 125 
32271,Java,"    public static class WriteI implements LInstruction{
        public int target, position, value;

        public WriteI(int target, int position, int value){
            this.target = target;
            this.position = position;
            this.value = value;
        }

        public WriteI(){
        }

        @Override
        public void run(LExecutor exec){
            int address = exec.numi(position);
            Building from = exec.building(target);

            if(from instanceof MemoryBuild mem && from.team == exec.team){

                if(address >= 0 && address < mem.memory.length){
                    mem.memory[address] = exec.num(value);
                }

            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 44 2003 44 2004 59 439 2000 40 404 2002 44 404 2003 44 404 2004 41 123 467 46 2002 61 2002 59 467 46 2003 61 2003 59 467 46 2004 61 2004 59 125 439 2000 40 41 123 125 64 2005 439 492 2006 40 2007 2008 41 123 404 2009 61 2008 46 2010 40 2003 41 59 2011 388 61 2008 46 2012 40 2002 41 59 392 40 388 402 2013 2014 605 388 46 2015 614 2008 46 2015 41 123 392 40 2009 615 1500 605 2009 60 2014 46 2016 46 2017 41 123 2014 46 2016 91 2009 93 61 2008 46 2018 40 2004 41 59 125 125 125 125 
32330,Java,"    public static class EndI implements LInstruction{

        @Override
        public void run(LExecutor exec){
            exec.var(varCounter).numval = exec.instructions.length;
        }
    }",0,439 457 334 2000 395 2001 123 64 2002 439 492 2003 40 2004 2005 41 123 2005 46 490 40 2006 41 46 2007 61 2005 46 2008 46 2009 59 125 125 
32104,Java,"    public static class Var{
        public final String name;

        public boolean isobj, constant;

        public Object objval;
        public double numval;

        public Var(String name){
            this.name = name;
        }
    }",0,439 457 334 2000 123 439 381 2001 2002 59 439 324 2003 44 2004 59 439 2005 2006 59 439 356 2007 59 439 2000 40 2001 2002 41 123 467 46 2002 61 2002 59 125 125 
47126,Java,"    @SuppressLint(""HandlerLeak"")
    class MainThreadHandler extends Handler {

        final byte[] mReceiveBuffer = new byte[4 * 1024];

        @Override
        public void handleMessage(Message msg) {
            int bytesRead = mProcessToTerminalIOQueue.read(mReceiveBuffer, false);
            if (bytesRead > 0) {
                mEmulator.append(mReceiveBuffer, bytesRead);
                notifyScreenUpdate();
            }

            if (msg.what == MSG_PROCESS_EXITED) {
                int exitCode = (Integer) msg.obj;
                cleanupResources(exitCode);

                String exitDescription = ""\r\n[Process completed"";
                if (exitCode > 0) {
                    // Non-zero process exit.
                    exitDescription += "" (code "" + exitCode + "")"";
                } else if (exitCode < 0) {
                    // Negated signal.
                    exitDescription += "" (signal "" + (-exitCode) + "")"";
                }
                exitDescription += "" - press Enter]"";

                byte[] bytesToWrite = exitDescription.getBytes(StandardCharsets.UTF_8);
                mEmulator.append(bytesToWrite, bytesToWrite.length);
                notifyScreenUpdate();

                mClient.onSessionFinished(TerminalSession.this);
            }
        }

    }",0,64 2000 40 648 41 334 2001 378 2002 123 381 326 91 93 2003 61 418 326 91 1502 42 1505 93 59 64 2004 439 492 2005 40 2006 2007 41 123 404 2008 61 2009 46 2010 40 2003 44 380 41 59 392 40 2008 62 1500 41 123 2011 46 2012 40 2003 44 2008 41 59 2013 40 41 59 125 392 40 2007 46 2014 614 2015 41 123 404 2016 61 40 2017 41 2007 46 2018 59 2019 40 2016 41 59 2020 2021 61 648 59 392 40 2016 62 1500 41 123 621 2021 636 648 43 2016 43 648 59 125 360 392 40 2016 60 1500 41 123 621 2021 636 648 43 40 45 2016 41 43 648 59 125 2021 636 648 59 326 91 93 2022 61 2021 46 2023 40 2024 46 2025 41 59 2026 46 2027 40 2022 44 2022 46 2028 41 59 2029 40 41 59 2030 46 2031 40 2032 46 467 41 59 125 125 125 
17305,Java,"  private class PlayerErrorMessageProvider implements ErrorMessageProvider<PlaybackException> {

    @Override
    public Pair<Integer, String> getErrorMessage(PlaybackException e) {
      String errorString = getString(R.string.error_generic);
      Throwable cause = e.getCause();
      if (cause instanceof DecoderInitializationException) {
        // Special case for decoder initialization failures.
        DecoderInitializationException decoderInitializationException =
            (DecoderInitializationException) cause;
        if (decoderInitializationException.codecInfo == null) {
          if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
            errorString = getString(R.string.error_querying_decoders);
          } else if (decoderInitializationException.secureDecoderRequired) {
            errorString =
                getString(
                    R.string.error_no_secure_decoder, decoderInitializationException.mimeType);
          } else {
            errorString =
                getString(R.string.error_no_decoder, decoderInitializationException.mimeType);
          }
        } else {
          errorString =
              getString(
                  R.string.error_instantiating_decoder,
                  decoderInitializationException.codecInfo.name);
        }
      }
      return Pair.create(0, errorString);
    }
  }",0,437 334 2000 395 2001 60 2002 62 123 64 2003 439 2004 60 2005 44 2006 62 2007 40 2002 2008 41 123 2006 2009 61 2010 40 2011 46 461 46 2012 41 59 2013 2014 61 2008 46 2015 40 41 59 392 40 2014 402 2016 41 123 621 2016 2017 61 40 2016 41 2014 59 392 40 2017 46 2018 614 424 41 123 392 40 2017 46 2015 40 41 402 2019 41 123 2009 61 2010 40 2011 46 461 46 2020 41 59 125 360 392 40 2017 46 2021 41 123 2009 61 2010 40 2011 46 461 46 2022 44 2017 46 2023 41 59 125 360 123 2009 61 2010 40 2011 46 461 46 2024 44 2017 46 2025 41 59 125 125 360 123 2009 61 2010 40 2011 46 461 46 2026 44 2017 46 2018 46 2027 41 59 125 125 450 2004 46 2028 40 1500 44 2009 41 59 125 125 
17306,Java,"  private class PlayerEventListener implements Player.Listener {

    @Override
    public void onPlaybackStateChanged(@Player.State int playbackState) {
      if (playbackState == Player.STATE_ENDED) {
        showControls();
      }
      updateButtonVisibility();
    }

    @Override
    public void onPlayerError(PlaybackException error) {
      if (error.errorCode == PlaybackException.ERROR_CODE_BEHIND_LIVE_WINDOW) {
        player.seekToDefaultPosition();
        player.prepare();
      } else {
        updateButtonVisibility();
        showControls();
      }
    }

    @Override
    @SuppressWarnings(""ReferenceEquality"")
    public void onTracksInfoChanged(TracksInfo tracksInfo) {
      updateButtonVisibility();
      if (tracksInfo == lastSeenTracksInfo) {
        return;
      }
      if (!tracksInfo.isTypeSupportedOrEmpty(C.TRACK_TYPE_VIDEO)) {
        showToast(R.string.error_unsupported_video);
      }
      if (!tracksInfo.isTypeSupportedOrEmpty(C.TRACK_TYPE_AUDIO)) {
        showToast(R.string.error_unsupported_audio);
      }
      lastSeenTracksInfo = tracksInfo;
    }
  }",0,437 334 2000 395 2001 46 2002 123 64 2003 439 492 2004 40 64 2001 46 2005 404 2006 41 123 392 40 2006 614 2001 46 2007 41 123 2008 40 41 59 125 2009 40 41 59 125 64 2003 439 492 2010 40 2011 371 41 123 392 40 371 46 2012 614 2011 46 2013 41 123 2014 46 2015 40 41 59 2014 46 2016 40 41 59 125 360 123 2017 40 41 59 2018 40 41 59 125 125 64 2003 64 2019 40 648 41 439 492 2020 40 2021 2022 41 123 2023 40 41 59 392 40 2022 614 2024 41 123 450 59 125 392 40 33 2022 46 2025 40 2026 46 2027 41 41 123 2028 40 2029 46 461 46 2030 41 59 125 392 40 33 2022 46 2025 40 2026 46 2031 41 41 123 2032 40 2033 46 461 46 2034 41 59 125 2024 61 2022 59 125 125 
17779,Java,"  private static class SampleInfo {
    public final byte[] data;
    @C.BufferFlags public final int flags;
    public final long timeUs;

    public SampleInfo(byte[] data, @C.BufferFlags int flags, long timeUs) {
      this.data = Arrays.copyOf(data, data.length);
      this.flags = flags;
      this.timeUs = timeUs;
    }
  }",0,437 457 334 2000 123 439 381 326 91 93 2001 59 64 2002 46 2003 439 381 404 2004 59 439 381 413 2005 59 439 2000 40 326 91 93 2001 44 64 2002 46 2003 404 2004 44 413 2005 41 123 467 46 2001 61 2006 46 2007 40 2001 44 2001 46 2008 41 59 467 46 2004 61 2004 59 467 46 2005 61 2005 59 125 125 
18105,Java,"  public final class EmbeddedSampleStream implements SampleStream {

    public final ChunkSampleStream<T> parent;

    private final SampleQueue sampleQueue;
    private final int index;

    private boolean notifiedDownstreamFormat;

    public EmbeddedSampleStream(ChunkSampleStream<T> parent, SampleQueue sampleQueue, int index) {
      this.parent = parent;
      this.sampleQueue = sampleQueue;
      this.index = index;
    }

    @Override
    public boolean isReady() {
      return !isPendingReset() && sampleQueue.isReady(loadingFinished);
    }

    @Override
    public int skipData(long positionUs) {
      if (isPendingReset()) {
        return 0;
      }
      int skipCount = sampleQueue.getSkipCount(positionUs, loadingFinished);
      if (canceledMediaChunk != null) {
        // Don't skip into chunk that's going to be discarded.
        // TODO: Support splicing to allow this. See [internal b/161130873].
        int maxSkipCount =
            canceledMediaChunk.getFirstSampleIndex(/* trackIndex= */ 1 + index)
                - sampleQueue.getReadIndex();
        skipCount = min(skipCount, maxSkipCount);
      }
      sampleQueue.skip(skipCount);
      if (skipCount > 0) {
        maybeNotifyDownstreamFormat();
      }
      return skipCount;
    }

    @Override
    public void maybeThrowError() {
      // Do nothing. Errors will be thrown from the primary stream.
    }

    @Override
    public int readData(
        FormatHolder formatHolder, DecoderInputBuffer buffer, @ReadFlags int readFlags) {
      if (isPendingReset()) {
        return C.RESULT_NOTHING_READ;
      }
      if (canceledMediaChunk != null
          && canceledMediaChunk.getFirstSampleIndex(/* trackIndex= */ 1 + index)
              <= sampleQueue.getReadIndex()) {
        // Don't read into chunk that's going to be discarded.
        // TODO: Support splicing to allow this. See [internal b/161130873].
        return C.RESULT_NOTHING_READ;
      }
      maybeNotifyDownstreamFormat();
      return sampleQueue.read(formatHolder, buffer, readFlags, loadingFinished);
    }

    public void release() {
      Assertions.checkState(embeddedTracksSelected[index]);
      embeddedTracksSelected[index] = false;
    }

    private void maybeNotifyDownstreamFormat() {
      if (!notifiedDownstreamFormat) {
        mediaSourceEventDispatcher.downstreamFormatChanged(
            embeddedTrackTypes[index],
            embeddedTrackFormats[index],
            C.SELECTION_REASON_UNKNOWN,
            /* trackSelectionData= */ null,
            lastSeekPositionUs);
        notifiedDownstreamFormat = true;
      }
    }
  }",0,439 381 334 2000 395 2001 123 439 381 2002 60 2003 62 2004 59 437 381 2005 2006 59 437 381 404 2007 59 437 324 2008 59 439 2000 40 2002 60 2003 62 2004 44 2005 2006 44 404 2007 41 123 467 46 2004 61 2004 59 467 46 2006 61 2006 59 467 46 2007 61 2007 59 125 64 2009 439 324 2010 40 41 123 450 33 2011 40 41 605 2006 46 2010 40 2012 41 59 125 64 2009 439 404 2013 40 413 2014 41 123 392 40 2015 40 41 41 123 450 1500 59 125 404 2016 61 2006 46 2017 40 2014 44 2018 41 59 392 40 2019 631 424 41 123 621 621 404 2020 61 2019 46 2021 40 604 1501 43 2007 41 45 2006 46 2022 40 41 59 2016 61 2023 40 2016 44 2020 41 59 125 2006 46 2024 40 2016 41 59 392 40 2016 62 1500 41 123 2025 40 41 59 125 450 2016 59 125 64 2009 439 492 2026 40 41 123 621 125 64 2009 439 404 2027 40 2028 2029 44 2030 2031 44 64 2032 404 2033 41 123 392 40 2034 40 41 41 123 450 2035 46 2036 59 125 392 40 2037 631 424 605 2037 46 2038 40 604 1501 43 2007 41 620 2006 46 2039 40 41 41 123 621 621 450 2040 46 2041 59 125 2042 40 41 59 450 2006 46 2043 40 2029 44 2031 44 2033 44 2044 41 59 125 439 492 2045 40 41 123 2046 46 2047 40 2048 91 2007 93 41 59 2048 91 2007 93 61 380 59 125 437 492 2049 40 41 123 392 40 33 2008 41 123 2050 46 2051 40 2052 91 2007 93 44 2053 91 2007 93 44 2054 46 2055 44 604 424 44 2056 41 59 2008 61 473 59 125 125 125 
17674,Java,"  private final class ForegroundNotificationUpdater {

    private final int notificationId;
    private final long updateInterval;
    private final Handler handler;

    private boolean periodicUpdatesStarted;
    private boolean notificationDisplayed;

    public ForegroundNotificationUpdater(int notificationId, long updateInterval) {
      this.notificationId = notificationId;
      this.updateInterval = updateInterval;
      this.handler = new Handler(Looper.getMainLooper());
    }

    public void startPeriodicUpdates() {
      periodicUpdatesStarted = true;
      update();
    }

    public void stopPeriodicUpdates() {
      periodicUpdatesStarted = false;
      handler.removeCallbacksAndMessages(null);
    }

    public void showNotificationIfNotAlready() {
      if (!notificationDisplayed) {
        update();
      }
    }

    public void invalidate() {
      if (notificationDisplayed) {
        update();
      }
    }

    private void update() {
      DownloadManager downloadManager =
          Assertions.checkNotNull(downloadManagerHelper).downloadManager;
      List<Download> downloads = downloadManager.getCurrentDownloads();
      @RequirementFlags int notMetRequirements = downloadManager.getNotMetRequirements();
      Notification notification = getForegroundNotification(downloads, notMetRequirements);
      if (!notificationDisplayed) {
        startForeground(notificationId, notification);
        notificationDisplayed = true;
      } else {
        // Update the notification via NotificationManager rather than by repeatedly calling
        // startForeground, since the latter can cause ActivityManager log spam.
        ((NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE))
            .notify(notificationId, notification);
      }
      if (periodicUpdatesStarted) {
        handler.removeCallbacksAndMessages(null);
        handler.postDelayed(this::update, updateInterval);
      }
    }
  }",0,437 381 334 2000 123 437 381 404 2001 59 437 381 413 2002 59 437 381 2003 2004 59 437 324 2005 59 437 324 2006 59 439 2000 40 404 2001 44 413 2002 41 123 467 46 2001 61 2001 59 467 46 2002 61 2002 59 467 46 2004 61 418 2003 40 2007 46 2008 40 41 41 59 125 439 492 2009 40 41 123 2005 61 473 59 2010 40 41 59 125 439 492 2011 40 41 123 2005 61 380 59 2004 46 2012 40 424 41 59 125 439 492 2013 40 41 123 392 40 33 2006 41 123 2014 40 41 59 125 125 439 492 2015 40 41 123 392 40 2006 41 123 2016 40 41 59 125 125 437 492 2017 40 41 123 2018 2019 61 2020 46 2021 40 2022 41 46 2019 59 2023 60 2024 62 2025 61 2019 46 2026 40 41 59 64 2027 404 2028 61 2019 46 2029 40 41 59 2030 2031 61 2032 40 2025 44 2028 41 59 392 40 33 2006 41 123 2033 40 2001 44 2031 41 59 2006 61 473 59 125 360 123 621 621 40 40 2034 41 2035 40 2036 46 2037 41 41 46 2038 40 2001 44 2031 41 59 125 392 40 2005 41 123 2004 46 2039 40 424 41 59 2004 46 2040 40 467 58 58 2017 44 2002 41 59 125 125 125 
17673,Java,"  private static final class DownloadManagerHelper implements DownloadManager.Listener {

    private final Context context;
    private final DownloadManager downloadManager;
    private final boolean foregroundAllowed;
    @Nullable private final Scheduler scheduler;
    private final Class<? extends DownloadService> serviceClass;

    @Nullable private DownloadService downloadService;
    private @MonotonicNonNull Requirements scheduledRequirements;

    private DownloadManagerHelper(
        Context context,
        DownloadManager downloadManager,
        boolean foregroundAllowed,
        @Nullable Scheduler scheduler,
        Class<? extends DownloadService> serviceClass) {
      this.context = context;
      this.downloadManager = downloadManager;
      this.foregroundAllowed = foregroundAllowed;
      this.scheduler = scheduler;
      this.serviceClass = serviceClass;
      downloadManager.addListener(this);
      updateScheduler();
    }

    public void attachService(DownloadService downloadService) {
      Assertions.checkState(this.downloadService == null);
      this.downloadService = downloadService;
      if (downloadManager.isInitialized()) {
        // The call to DownloadService.notifyDownloads is posted to avoid it being called directly
        // from DownloadService.onCreate. This is a good idea because it may in turn call
        // DownloadService.getForegroundNotification, and concrete subclass implementations may
        // not anticipate the possibility of this method being called before their onCreate
        // implementation has finished executing.
        Util.createHandlerForCurrentOrMainLooper()
            .postAtFrontOfQueue(
                () -> downloadService.notifyDownloads(downloadManager.getCurrentDownloads()));
      }
    }

    public void detachService(DownloadService downloadService) {
      Assertions.checkState(this.downloadService == downloadService);
      this.downloadService = null;
    }

    /**
     * Schedules or cancels restarting the service, as needed for the current state.
     *
     * @return True if the DownloadManager is not waiting for requirements, or if it is waiting for
     *     requirements and the service has been successfully scheduled to be restarted when they
     *     are met. False if the DownloadManager is waiting for requirements and the service has not
     *     been scheduled for restart.
     */
    public boolean updateScheduler() {
      boolean waitingForRequirements = downloadManager.isWaitingForRequirements();
      if (scheduler == null) {
        return !waitingForRequirements;
      }

      if (!waitingForRequirements) {
        cancelScheduler();
        return true;
      }

      Requirements requirements = downloadManager.getRequirements();
      Requirements supportedRequirements = scheduler.getSupportedRequirements(requirements);
      if (!supportedRequirements.equals(requirements)) {
        cancelScheduler();
        return false;
      }

      if (!schedulerNeedsUpdate(requirements)) {
        return true;
      }

      String servicePackage = context.getPackageName();
      if (scheduler.schedule(requirements, servicePackage, ACTION_RESTART)) {
        scheduledRequirements = requirements;
        return true;
      } else {
        Log.w(TAG, ""Failed to schedule restart"");
        cancelScheduler();
        return false;
      }
    }

    // DownloadManager.Listener implementation.

    @Override
    public void onInitialized(DownloadManager downloadManager) {
      if (downloadService != null) {
        downloadService.notifyDownloads(downloadManager.getCurrentDownloads());
      }
    }

    @Override
    public void onDownloadChanged(
        DownloadManager downloadManager, Download download, @Nullable Exception finalException) {
      if (downloadService != null) {
        downloadService.notifyDownloadChanged(download);
      }
      if (serviceMayNeedRestart() && needsStartedService(download.state)) {
        // This shouldn't happen unless (a) application code is changing the downloads by calling
        // the DownloadManager directly rather than sending actions through the service, or (b) if
        // the service is background only and a previous attempt to start it was prevented. Try and
        // restart the service to robust against such cases.
        Log.w(TAG, ""DownloadService wasn't running. Restarting."");
        restartService();
      }
    }

    @Override
    public void onDownloadRemoved(DownloadManager downloadManager, Download download) {
      if (downloadService != null) {
        downloadService.notifyDownloadRemoved();
      }
    }

    @Override
    public final void onIdle(DownloadManager downloadManager) {
      if (downloadService != null) {
        downloadService.onIdle();
      }
    }

    @Override
    public void onRequirementsStateChanged(
        DownloadManager downloadManager,
        Requirements requirements,
        @RequirementFlags int notMetRequirements) {
      updateScheduler();
    }

    @Override
    public void onWaitingForRequirementsChanged(
        DownloadManager downloadManager, boolean waitingForRequirements) {
      if (!waitingForRequirements
          && !downloadManager.getDownloadsPaused()
          && serviceMayNeedRestart()) {
        // We're no longer waiting for requirements and downloads aren't paused, meaning the manager
        // will be able to resume downloads that are currently queued. If there exist queued
        // downloads then we should ensure the service is started.
        List<Download> downloads = downloadManager.getCurrentDownloads();
        for (int i = 0; i < downloads.size(); i++) {
          if (downloads.get(i).state == Download.STATE_QUEUED) {
            restartService();
            return;
          }
        }
      }
    }

    // Internal methods.

    private boolean schedulerNeedsUpdate(Requirements requirements) {
      return !Util.areEqual(scheduledRequirements, requirements);
    }

    @RequiresNonNull(""scheduler"")
    private void cancelScheduler() {
      Requirements canceledRequirements = new Requirements(/* requirements= */ 0);
      if (schedulerNeedsUpdate(canceledRequirements)) {
        scheduler.cancel();
        scheduledRequirements = canceledRequirements;
      }
    }

    private boolean serviceMayNeedRestart() {
      return downloadService == null || downloadService.isStopped();
    }

    private void restartService() {
      if (foregroundAllowed) {
        try {
          Intent intent = getIntent(context, serviceClass, DownloadService.ACTION_RESTART);
          Util.startForegroundService(context, intent);
        } catch (IllegalStateException e) {
          // The process is running in the background, and is not allowed to start a foreground
          // service due to foreground service launch restrictions
          // (https://developer.android.com/about/versions/12/foreground-services).
          Log.w(TAG, ""Failed to restart (foreground launch restriction)"");
        }
      } else {
        // The service is background only. Use ACTION_INIT rather than ACTION_RESTART because
        // ACTION_RESTART is handled as though KEY_FOREGROUND is set to true.
        try {
          Intent intent = getIntent(context, serviceClass, DownloadService.ACTION_INIT);
          context.startService(intent);
        } catch (IllegalStateException e) {
          // The process is classed as idle by the platform. Starting a background service is not
          // allowed in this state.
          Log.w(TAG, ""Failed to restart (process is idle)"");
        }
      }
    }
  }",0,437 457 381 334 2000 395 2001 46 2002 123 437 381 2003 2004 59 437 381 2001 2005 59 437 381 324 2006 59 64 2007 437 381 2008 2009 59 437 381 2010 60 63 378 2011 62 2012 59 64 2007 437 2011 2013 59 437 64 2014 2015 2016 59 437 2000 40 2003 2004 44 2001 2005 44 324 2006 44 64 2007 2008 2009 44 2010 60 63 378 2011 62 2012 41 123 467 46 2004 61 2004 59 467 46 2005 61 2005 59 467 46 2006 61 2006 59 467 46 2009 61 2009 59 467 46 2012 61 2012 59 2005 46 2017 40 467 41 59 2018 40 41 59 125 439 492 2019 40 2011 2013 41 123 2020 46 2021 40 467 46 2013 614 424 41 59 467 46 2013 61 2013 59 392 40 2005 46 2022 40 41 41 123 621 621 621 621 621 2023 46 2024 40 41 46 2025 40 40 41 45 62 2013 46 2026 40 2005 46 2027 40 41 41 41 59 125 125 439 492 2028 40 2011 2013 41 123 2029 46 2030 40 467 46 2013 614 2013 41 59 467 46 2013 61 424 59 125 618 439 324 2031 40 41 123 324 2032 61 2005 46 2033 40 41 59 392 40 2009 614 424 41 123 450 33 2032 59 125 392 40 33 2032 41 123 2034 40 41 59 450 473 59 125 2015 2035 61 2005 46 2036 40 41 59 2015 2037 61 2009 46 2038 40 2035 41 59 392 40 33 2037 46 2039 40 2035 41 41 123 2040 40 41 59 450 380 59 125 392 40 33 2041 40 2035 41 41 123 450 473 59 125 2042 2043 61 2004 46 2044 40 41 59 392 40 2009 46 2045 40 2035 44 2043 44 2046 41 41 123 2016 61 2035 59 450 473 59 125 360 123 2047 46 2048 40 2049 44 648 41 59 2050 40 41 59 450 380 59 125 125 621 64 2051 439 492 2052 40 2001 2005 41 123 392 40 2013 631 424 41 123 2013 46 2053 40 2005 46 2054 40 41 41 59 125 125 64 2051 439 492 2055 40 2001 2005 44 2056 2057 44 64 2007 2058 2059 41 123 392 40 2013 631 424 41 123 2013 46 2060 40 2057 41 59 125 392 40 2061 40 41 605 2062 40 2057 46 2063 41 41 123 621 621 621 621 2064 46 2065 40 2066 44 648 41 59 2067 40 41 59 125 125 64 2051 439 492 2068 40 2001 2005 44 2056 2057 41 123 392 40 2013 631 424 41 123 2013 46 2069 40 41 59 125 125 64 2051 439 381 492 2070 40 2001 2005 41 123 392 40 2013 631 424 41 123 2013 46 2070 40 41 59 125 125 64 2051 439 492 2071 40 2001 2005 44 2015 2072 44 64 2073 404 2074 41 123 2031 40 41 59 125 64 2051 439 492 2075 40 2001 2005 44 324 2076 41 123 392 40 33 2076 605 33 2005 46 2077 40 41 605 2078 40 41 41 123 621 621 621 2079 60 2056 62 2080 61 2005 46 2081 40 41 59 385 40 404 2082 61 1500 59 2082 60 2080 46 2083 40 41 59 2082 637 41 123 392 40 2080 46 2084 40 2082 41 46 2085 614 2056 46 2086 41 123 2087 40 41 59 450 59 125 125 125 125 621 437 324 2088 40 2015 2072 41 123 450 33 2089 46 2090 40 2016 44 2072 41 59 125 64 2091 40 648 41 437 492 2092 40 41 123 2015 2093 61 418 2015 40 604 1500 41 59 392 40 2088 40 2093 41 41 123 2009 46 2094 40 41 59 2016 61 2093 59 125 125 437 324 2095 40 41 123 450 2013 614 424 606 2013 46 2096 40 41 59 125 437 492 2097 40 41 123 392 40 2006 41 123 474 123 2098 2099 61 2100 40 2004 44 2012 44 2011 46 2101 41 59 2102 46 2103 40 2004 44 2099 41 59 125 329 40 2104 2105 41 123 621 621 621 2106 46 2107 40 2108 44 648 41 59 125 125 360 123 621 621 474 123 2109 2110 61 2111 40 2004 44 2012 44 2011 46 2112 41 59 2004 46 2113 40 2110 41 59 125 329 40 2114 2115 41 123 621 621 2116 46 2117 40 2118 44 648 41 59 125 125 125 125 
2473,Java,"public final class GameEventHandler implements IEventBus, Helper {

    private final Baritone baritone;

    private final List<IGameEventListener> listeners = new CopyOnWriteArrayList<>();

    public GameEventHandler(Baritone baritone) {
        this.baritone = baritone;
    }

    @Override
    public final void onTick(TickEvent event) {
        if (event.getType() == TickEvent.Type.IN) {
            try {
                baritone.bsi = new BlockStateInterface(baritone.getPlayerContext(), true);
            } catch (Exception ex) {
                baritone.bsi = null;
            }
        } else {
            baritone.bsi = null;
        }
        listeners.forEach(l -> l.onTick(event));
    }

    @Override
    public final void onPlayerUpdate(PlayerUpdateEvent event) {
        listeners.forEach(l -> l.onPlayerUpdate(event));
    }

    @Override
    public final void onSendChatMessage(ChatEvent event) {
        listeners.forEach(l -> l.onSendChatMessage(event));
    }

    @Override
    public void onPreTabComplete(TabCompleteEvent event) {
        listeners.forEach(l -> l.onPreTabComplete(event));
    }

    @Override
    public final void onChunkEvent(ChunkEvent event) {
        EventState state = event.getState();
        ChunkEvent.Type type = event.getType();

        boolean isPostPopulate = state == EventState.POST
                && (type == ChunkEvent.Type.POPULATE_FULL || type == ChunkEvent.Type.POPULATE_PARTIAL);

        World world = baritone.getPlayerContext().world();

        // Whenever the server sends us to another dimension, chunks are unloaded
        // technically after the new world has been loaded, so we perform a check
        // to make sure the chunk being unloaded is already loaded.
        boolean isPreUnload = state == EventState.PRE
                && type == ChunkEvent.Type.UNLOAD
                && world.getChunkProvider().isChunkGeneratedAt(event.getX(), event.getZ());

        if (isPostPopulate || isPreUnload) {
            baritone.getWorldProvider().ifWorldLoaded(worldData -> {
                Chunk chunk = world.getChunk(event.getX(), event.getZ());
                worldData.getCachedWorld().queueForPacking(chunk);
            });
        }


        listeners.forEach(l -> l.onChunkEvent(event));
    }

    @Override
    public final void onRenderPass(RenderEvent event) {
        listeners.forEach(l -> l.onRenderPass(event));
    }

    @Override
    public final void onWorldEvent(WorldEvent event) {
        WorldProvider cache = baritone.getWorldProvider();

        if (event.getState() == EventState.POST) {
            cache.closeWorld();
            if (event.getWorld() != null) {
                cache.initWorld(event.getWorld().provider.getDimensionType().getId());
            }
        }

        listeners.forEach(l -> l.onWorldEvent(event));
    }

    @Override
    public final void onSendPacket(PacketEvent event) {
        listeners.forEach(l -> l.onSendPacket(event));
    }

    @Override
    public final void onReceivePacket(PacketEvent event) {
        listeners.forEach(l -> l.onReceivePacket(event));
    }

    @Override
    public void onPlayerRotationMove(RotationMoveEvent event) {
        listeners.forEach(l -> l.onPlayerRotationMove(event));
    }

    @Override
    public void onPlayerSprintState(SprintStateEvent event) {
        listeners.forEach(l -> l.onPlayerSprintState(event));
    }

    @Override
    public void onBlockInteract(BlockInteractEvent event) {
        listeners.forEach(l -> l.onBlockInteract(event));
    }

    @Override
    public void onPlayerDeath() {
        listeners.forEach(IGameEventListener::onPlayerDeath);
    }

    @Override
    public void onPathEvent(PathEvent event) {
        listeners.forEach(l -> l.onPathEvent(event));
    }

    @Override
    public final void registerEventListener(IGameEventListener listener) {
        this.listeners.add(listener);
    }
}",0,439 381 334 2000 395 2001 44 2002 123 437 381 2003 2004 59 437 381 2005 60 2006 62 2007 61 418 2008 60 62 40 41 59 439 2000 40 2003 2004 41 123 467 46 2004 61 2004 59 125 64 2009 439 381 492 2010 40 2011 373 41 123 392 40 373 46 2012 40 41 614 2011 46 2013 46 2014 41 123 474 123 2004 46 2015 61 418 2016 40 2004 46 2017 40 41 44 473 41 59 125 329 40 2018 2019 41 123 2004 46 2020 61 424 59 125 125 360 123 2004 46 2021 61 424 59 125 2007 46 2022 40 2023 45 62 2023 46 2010 40 373 41 41 59 125 64 2009 439 381 492 2024 40 2025 373 41 123 2007 46 2026 40 2027 45 62 2027 46 2024 40 373 41 41 59 125 64 2009 439 381 492 2028 40 2029 373 41 123 2007 46 2030 40 2031 45 62 2031 46 2028 40 373 41 41 59 125 64 2009 439 492 2032 40 2033 373 41 123 2007 46 2034 40 2035 45 62 2035 46 2032 40 373 41 41 59 125 64 2009 439 381 492 2036 40 2037 373 41 123 2038 2039 61 373 46 2040 40 41 59 2037 46 2041 2042 61 373 46 2043 40 41 59 324 2044 61 2039 614 2038 46 2045 605 40 2042 614 2037 46 2041 46 2046 606 2042 614 2037 46 2041 46 2047 41 59 2048 2049 61 2004 46 2050 40 41 46 2049 40 41 59 621 621 621 324 2051 61 2039 614 2038 46 2052 605 2042 614 2037 46 2041 46 2053 605 2049 46 2054 40 41 46 2055 40 373 46 2056 40 41 44 373 46 2057 40 41 41 59 392 40 2044 606 2051 41 123 2004 46 2058 40 41 46 2059 40 2060 45 62 123 2061 2062 61 2049 46 2063 40 373 46 2056 40 41 44 373 46 2057 40 41 41 59 2060 46 2064 40 41 46 2065 40 2062 41 59 125 41 59 125 2007 46 2066 40 2067 45 62 2067 46 2036 40 373 41 41 59 125 64 2009 439 381 492 2068 40 2069 373 41 123 2007 46 2070 40 2071 45 62 2071 46 2068 40 373 41 41 59 125 64 2009 439 381 492 2072 40 2073 373 41 123 2074 2075 61 2004 46 2076 40 41 59 392 40 373 46 2077 40 41 614 2078 46 2079 41 123 2075 46 2080 40 41 59 392 40 373 46 2081 40 41 631 424 41 123 2075 46 2082 40 373 46 2081 40 41 46 2083 46 2084 40 41 46 2085 40 41 41 59 125 125 2007 46 2086 40 2087 45 62 2087 46 2072 40 373 41 41 59 125 64 2009 439 381 492 2088 40 2089 373 41 123 2007 46 2090 40 2091 45 62 2091 46 2088 40 373 41 41 59 125 64 2009 439 381 492 2092 40 2089 373 41 123 2007 46 2093 40 2094 45 62 2094 46 2092 40 373 41 41 59 125 64 2009 439 492 2095 40 2096 373 41 123 2007 46 2097 40 2098 45 62 2098 46 2095 40 373 41 41 59 125 64 2009 439 492 2099 40 2100 373 41 123 2007 46 2101 40 2102 45 62 2102 46 2099 40 373 41 41 59 125 64 2009 439 492 2103 40 2104 373 41 123 2007 46 2105 40 2106 45 62 2106 46 2103 40 373 41 41 59 125 64 2009 439 492 2107 40 41 123 2007 46 2108 40 2006 58 58 2107 41 59 125 64 2009 439 492 2109 40 2110 373 41 123 2007 46 2111 40 2112 45 62 2112 46 2109 40 373 41 41 59 125 64 2009 439 381 492 2113 40 2006 2114 41 123 467 46 2007 46 2115 40 2114 41 59 125 125 
2595,Java,"            PathNode pn = new PathNode(0, 0, 0, new Goal() {
                @Override
                public boolean isInGoal(int x, int y, int z) {
                    return false;
                }

                @Override
                public double heuristic(int x, int y, int z) {
                    return 0;
                }
            });",0,2000 2001 61 418 2000 40 1500 44 1500 44 1500 44 418 2002 40 41 123 64 2003 439 324 2004 40 404 2005 44 404 2006 44 404 2007 41 123 450 380 59 125 64 2003 439 356 2008 40 404 2005 44 404 2006 44 404 2007 41 123 450 1500 59 125 125 41 59 
2827,Java,"        return new ListCell<>() {
            @Override
            protected void updateItem(PriceFeedComboBoxItem item, boolean empty) {
                super.updateItem(item, empty);

                if (!empty && item != null) {
                    textProperty().bind(item.displayStringProperty);
                } else {
                    textProperty().unbind();
                }
            }
        };",0,450 418 2000 60 62 40 41 123 64 2001 438 492 2002 40 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 33 362 605 2004 631 424 41 123 2005 40 41 46 2006 40 2004 46 2007 41 59 125 360 123 2008 40 41 46 2009 40 41 59 125 125 125 59 
2829,Java,"        reservedBalanceBox.first.tooltipProperty().bind(new ObjectBinding<>() {
            {
                bind(model.getReservedBalance());
                bind(model.getMarketPrice());
            }

            @Override
            protected Tooltip computeValue() {
                String tooltipText = Res.get(""mainView.balance.reserved"");
                try {
                    String preferredTradeCurrency = model.getPreferences().getPreferredTradeCurrency().getCode();
                    double reservedBalance = Double.parseDouble(
                            model.getReservedBalance().getValue().replace(""BTC"", """"));
                    double marketPrice = Double.parseDouble(model.getMarketPrice(preferredTradeCurrency).getValue());
                    tooltipText += ""\n"" + currencyFormat.format(reservedBalance * marketPrice) +
                            "" "" + preferredTradeCurrency;
                } catch (NullPointerException | NumberFormatException e) {
                    // Either the balance or market price is not available yet
                }
                return new Tooltip(tooltipText);
            }
        });",0,2000 46 2001 46 2002 40 41 46 2003 40 418 2004 60 62 40 41 123 123 2003 40 2005 46 2006 40 41 41 59 2003 40 2005 46 2007 40 41 41 59 125 64 2008 438 2009 2010 40 41 123 2011 2012 61 2013 46 2014 40 648 41 59 474 123 2011 2015 61 2016 46 2017 40 41 46 2018 40 41 46 2019 40 41 59 356 2020 61 2021 46 2022 40 2016 46 2023 40 41 46 2024 40 41 46 2025 40 648 44 648 41 41 59 356 2026 61 2021 46 2022 40 2016 46 2027 40 2015 41 46 2024 40 41 41 59 2012 636 648 43 2028 46 2029 40 2020 42 2026 41 43 648 43 2015 59 125 329 40 2030 124 2031 2032 41 123 621 125 450 418 2009 40 2012 41 59 125 125 41 59 
2874,Java,"public class PopOverWrapper {

    private PopOver popover;
    private Supplier<PopOver> popoverSupplier;
    private boolean hidePopover;
    private PopOverState state = PopOverState.HIDDEN;

    enum PopOverState {
        HIDDEN, SHOWING, SHOWN, HIDING
    }

    public void showPopOver(Supplier<PopOver> popoverSupplier) {
        this.popoverSupplier = popoverSupplier;
        hidePopover = false;

        if (state == PopOverState.HIDDEN) {
            state = PopOverState.SHOWING;
            popover = popoverSupplier.get();

            UserThread.runAfter(() -> {
                state = PopOverState.SHOWN;
                if (hidePopover) {
                    // For some reason, this can result in a brief flicker when invoked
                    // from a 'runAfter' callback, rather than directly. So make the delay
                    // very short (25ms) so that we don't reach here often:
                    hidePopOver();
                }
            }, 25, TimeUnit.MILLISECONDS);
        }
    }

    public void hidePopOver() {
        hidePopover = true;

        if (state == PopOverState.SHOWN) {
            state = PopOverState.HIDING;
            popover.hide();

            UserThread.runAfter(() -> {
                state = PopOverState.HIDDEN;
                if (!hidePopover) {
                    showPopOver(popoverSupplier);
                }
            }, 250, TimeUnit.MILLISECONDS);
        }
    }
}",0,439 334 2000 123 437 2001 2002 59 437 2003 60 2001 62 2004 59 437 324 2005 59 437 2006 2007 61 2006 46 2008 59 370 2006 123 2008 44 2009 44 2010 44 2011 125 439 492 2012 40 2003 60 2001 62 2004 41 123 467 46 2004 61 2004 59 2005 61 380 59 392 40 2007 614 2006 46 2008 41 123 2007 61 2006 46 2013 59 2002 61 2004 46 2014 40 41 59 2015 46 2016 40 40 41 45 62 123 2007 61 2006 46 2017 59 392 40 2005 41 123 621 621 621 2018 40 41 59 125 125 44 1503 44 2019 46 2020 41 59 125 125 439 492 2021 40 41 123 2005 61 473 59 392 40 2007 614 2006 46 2022 41 123 2007 61 2006 46 2023 59 2002 46 2024 40 41 59 2025 46 2026 40 40 41 45 62 123 2007 61 2006 46 2008 59 392 40 33 2005 41 123 2012 40 2004 41 59 125 125 44 1504 44 2027 46 2028 41 59 125 125 125 
3254,Java,"                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getCycle());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3258,Java,"                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getNumVotesAsString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3259,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getNumVotesAsString());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3264,Java,"                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(DisplayUtils.formatDateTime(item.getProposal().getCreationDateAsDate()));
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2010 46 2011 40 2008 46 2012 40 41 46 2013 40 41 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3265,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(DisplayUtils.formatDateTime(item.getProposal().getCreationDateAsDate()));
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2006 46 2007 40 2004 46 2008 40 41 46 2009 40 41 41 41 59 360 2005 40 648 41 59 125 125 59 
3266,Java,"                new Callback<>() {

                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(TableColumn<ProposalListItem,
                            ProposalListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon field;

                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    Proposal proposal = item.getProposal();
                                    String link = proposal.getLink();
                                    String proposalOwnerName = item.getProposalOwnerName();
                                    String[] tokens = link.split(""/"");
                                    String nameLink = proposalOwnerName;
                                    if (tokens.length > 0) {
                                        String proposalNr = tokens[tokens.length - 1];
                                        nameLink += "" (#"" + proposalNr + "")"";
                                    }

                                    field = new ExternalHyperlink(nameLink);
                                    field.setOnAction(event -> GUIUtil.openWebPage(link));
                                    field.setTooltip(new Tooltip(proposalOwnerName + "" ("" + link + "")""));
                                    setGraphic(field);
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2014 2015 61 2012 46 2016 40 41 59 2014 2017 61 2010 46 2018 40 41 59 2014 91 93 2019 61 2015 46 2020 40 648 41 59 2014 2021 61 2017 59 392 40 2019 46 2022 62 1500 41 123 2014 2023 61 2019 91 2019 46 2022 45 1501 93 59 2021 636 648 43 2023 43 648 59 125 2008 61 418 2024 40 2021 41 59 2008 46 2025 40 373 45 62 2026 46 2027 40 2015 41 41 59 2008 46 2028 40 418 2029 40 2017 43 648 43 2015 43 648 41 41 59 2030 40 2008 41 59 125 360 123 2031 40 424 41 59 392 40 2008 631 424 41 2008 46 2032 40 424 41 59 125 125 125 59 125 125 41 59 
3268,Java,"                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getProposal().getType().getShortDisplayName());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 46 2011 40 41 46 2012 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3269,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getProposal().getType().getShortDisplayName());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 46 2007 40 41 46 2008 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3271,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getDetails());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3274,Java,"                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getThresholdAsString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3275,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getThresholdAsString());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3279,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProposalListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            Label icon = new Label();
                            AwesomeDude.setIcon(icon, item.getIcon());
                            icon.getStyleClass().add(item.getColorStyleClass());
                            setGraphic(icon);
                        } else {
                            setGraphic(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 2006 61 418 2005 40 41 59 2007 46 2008 40 2006 44 2004 46 2009 40 41 41 59 2006 46 2010 40 41 46 2011 40 2004 46 2012 40 41 41 59 2013 40 2006 41 59 125 360 123 2014 40 424 41 59 125 125 125 59 
3298,Java,"                new Callback<>() {
                    @Override
                    public TableCell<VoteListItem, VoteListItem> call(
                            TableColumn<VoteListItem, VoteListItem> column) {
                        return new TableCell<>() {
                            private Label icon;

                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    Tuple2<AwesomeIcon, String> iconStyleTuple = item.getIconStyleTuple();
                                    icon = new Label();
                                    AwesomeDude.setIcon(icon, iconStyleTuple.first);
                                    icon.getStyleClass().add(iconStyleTuple.second);
                                    setGraphic(icon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 60 2012 44 2013 62 2014 61 2010 46 2015 40 41 59 2008 61 418 2007 40 41 59 2016 46 2017 40 2008 44 2014 46 2018 41 59 2008 46 2019 40 41 46 2020 40 2014 46 2021 41 59 2022 40 2008 41 59 125 360 123 2023 40 424 41 59 125 125 125 59 125 125 41 59 
3301,Java,"                        return new TableCell<>() {

                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String transactionId = item.getBlindVoteTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> openTxInBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 59 2002 61 418 2010 40 2008 41 59 2002 46 2011 40 373 45 62 2012 40 2006 41 41 59 2002 46 2013 40 418 2014 40 2015 46 2016 40 648 44 2008 41 41 41 59 2017 40 2002 41 59 125 360 123 2018 40 424 41 59 392 40 2002 631 424 41 2002 46 2019 40 424 41 59 125 125 125 59 
3303,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getMerit());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3305,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getStake());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3306,Java,"                new Callback<>() {
                    @Override
                    public TableCell<VoteListItem, VoteListItem> call(
                            TableColumn<VoteListItem, VoteListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getMeritAndStake());
                                else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 41 2009 40 2008 46 2010 40 41 41 59 360 2009 40 648 41 59 125 125 59 125 125 41 59 
3307,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getMeritAndStake());
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 41 2005 40 2004 46 2006 40 41 41 59 360 2005 40 648 41 59 125 125 59 
3442,Java,"        paymentMethodComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(PaymentMethod paymentMethod) {
                return paymentMethod != null ? Res.get(paymentMethod.getId()) : """";
            }

            @Override
            public PaymentMethod fromString(String s) {
                return null;
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 450 2007 631 424 63 2008 46 2009 40 2007 46 2010 40 41 41 58 648 59 125 64 2003 439 2006 2011 40 2004 2012 41 123 450 424 59 125 125 41 59 
3551,Java,"            tradeWalletService.broadcastTx(tx, new TxBroadcaster.Callback() {
                @Override
                public void onSuccess(Transaction transaction) {
                    resultHandler.handleResult();
                }

                @Override
                public void onFailure(TxBroadcastException exception) {
                    log.error(""TxBroadcastException at doPayout"", exception);
                    new Popup().error(exception.toString()).show();
                }
            });",0,2000 46 2001 40 2002 44 418 2003 46 2004 40 41 123 64 2005 439 492 2006 40 2007 2008 41 123 2009 46 2010 40 41 59 125 64 2005 439 492 2011 40 2012 2013 41 123 2014 46 371 40 648 44 2013 41 59 418 2015 40 41 46 371 40 2013 46 2016 40 41 41 46 2017 40 41 59 125 125 41 59 
3549,Java,"        txConfidenceListener = new TxConfidenceListener(txId) {
            @Override
            public void onTransactionConfidenceChanged(TransactionConfidence confidence) {
                updateConfidence(confidence);
            }
        };",0,2000 61 418 2001 40 2002 41 123 64 2003 439 492 2004 40 2005 2006 41 123 2007 40 2006 41 59 125 125 59 
3569,Java,"            p2PService.addP2PServiceListener(new BootstrapListener() {
                @Override
                public void onUpdatedDataReceived() {
                    initPersistedTrades();
                }
            });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 41 123 2005 40 41 59 125 125 41 59 
3641,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmountAsString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
3643,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getDateAsString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
3645,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getHashAsHex());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
3648,Java,"        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                    ProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPubKey());
                        } else
                            setText("""");
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
3653,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmountAsString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
3655,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPubKey());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
3659,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getDateAsString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
3661,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPreImage());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
3664,Java,"                new Callback<>() {
                    @Override
                    public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                            MyProofOfBurnListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(item.getTxId(), preferences));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 621 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 46 2017 40 2010 46 2013 40 41 44 2018 41 41 59 2008 46 2019 40 418 2020 40 2021 46 2022 40 648 44 2012 41 41 41 59 2023 40 2008 41 59 125 360 123 2024 40 424 41 59 392 40 2008 631 424 41 2008 46 2025 40 424 41 59 125 125 125 59 125 125 41 59 
3759,Java,"            p2PService.addP2PServiceListener(new BootstrapListener() {
                @Override
                public void onUpdatedDataReceived() {
                    onBootstrapComplete();
                }
            });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 41 123 2005 40 41 59 125 125 41 59 
3828,Java,"        p2PService.addP2PServiceListener(new P2PServiceListener() {
            @Override
            public void onDataReceived() {
            }

            @Override
            public void onNoSeedNodeAvailable() {
            }

            @Override
            public void onNoPeersAvailable() {
            }

            @Override
            public void onUpdatedDataReceived() {
                // We should have received all data at that point and if the filters were not set we
                // clean up the persisted banned nodes in the options file as it might be that we missed the filter
                // remove message if we have not been online.
                if (filterProperty.get() == null) {
                    clearBannedNodes();
                }
            }

            @Override
            public void onTorNodeReady() {
            }

            @Override
            public void onHiddenServicePublished() {
            }

            @Override
            public void onSetupFailed(Throwable throwable) {
            }

            @Override
            public void onRequestCustomBridges() {
            }
        });",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 41 123 125 64 2003 439 492 2005 40 41 123 125 64 2003 439 492 2006 40 41 123 125 64 2003 439 492 2007 40 41 123 621 621 621 392 40 2008 46 2009 40 41 614 424 41 123 2010 40 41 59 125 125 64 2003 439 492 2011 40 41 123 125 64 2003 439 492 2012 40 41 123 125 64 2003 439 492 2013 40 2014 2015 41 123 125 64 2003 439 492 2016 40 41 123 125 125 41 59 
3859,Java,"                assetComboBox.setConverter(new StringConverter<>() {
                    @Override
                    public String toString(Asset asset) {
                        return asset != null ? CurrencyUtil.getNameAndCode(asset.getTickerSymbol()) : """";
                    }

                    @Override
                    public Asset fromString(String string) {
                        return null;
                    }
                });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 2005 40 2006 2007 41 123 450 2007 631 424 63 2008 46 2009 40 2007 46 2010 40 41 41 58 648 59 125 64 2003 439 2006 2011 40 2004 461 41 123 450 424 59 125 125 41 59 
4033,Java,"                new Callback<>() {

                    @Override
                    public TableCell<ReservedListItem, ReservedListItem> call(TableColumn<ReservedListItem,
                            ReservedListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final ReservedListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String address = item.getAddressString();
                                    hyperlinkWithIcon = new ExternalHyperlink(address);
                                    hyperlinkWithIcon.setOnAction(event -> openBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", address)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 40 2010 41 41 59 2008 46 2017 40 418 2018 40 2019 46 2020 40 648 44 2012 41 41 41 59 2021 40 2008 41 59 125 360 123 2022 40 424 41 59 392 40 2008 631 424 41 2008 46 2023 40 424 41 59 125 125 125 59 125 125 41 59 
4034,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final ReservedListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String address = item.getAddressString();
                                    hyperlinkWithIcon = new ExternalHyperlink(address);
                                    hyperlinkWithIcon.setOnAction(event -> openBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", address)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 59 2002 61 418 2010 40 2008 41 59 2002 46 2011 40 373 45 62 2012 40 2006 41 41 59 2002 46 2013 40 418 2014 40 2015 46 2016 40 648 44 2008 41 41 41 59 2017 40 2002 41 59 125 360 123 2018 40 424 41 59 392 40 2002 631 424 41 2002 46 2019 40 424 41 59 125 125 125 59 
4036,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ReservedListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic((item != null && !empty) ? item.getBalanceLabel() : null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 40 2004 631 424 605 33 362 41 63 2004 46 2006 40 41 58 424 41 59 125 125 59 
4093,Java,"                new Callback<>() {
                    @Override
                    public TableCell<RolesListItem, RolesListItem> call(TableColumn<RolesListItem,
                            RolesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setText(item.getRole().getName());
                                } else
                                    setText("""");
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 2008 46 2010 40 41 46 2011 40 41 41 59 125 360 2012 40 648 41 59 125 125 59 125 125 41 59 
4094,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setText(item.getRole().getName());
                                } else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 46 2007 40 41 41 59 125 360 2008 40 648 41 59 125 125 59 
4095,Java,"                new Callback<>() {
                    @Override
                    public TableCell<RolesListItem, RolesListItem> call(TableColumn<RolesListItem,
                            RolesListItem> column) {
                        return new TableCell<>() {
                            AutoTooltipButton button;

                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty && item.isButtonVisible()) {
                                    if (button == null) {
                                        button = new AutoTooltipButton(item.getButtonText());
                                        button.setMinWidth(70);
                                        button.setOnAction(e -> {
                                            if (item.getBondState() == BondState.READY_FOR_LOCKUP) {
                                                bondingViewUtils.lockupBondForBondedRole(item.getRole(),
                                                        txId -> {
                                                        });
                                            } else if (item.getBondState() == BondState.LOCKUP_TX_CONFIRMED) {
                                                bondingViewUtils.unLock(item.getLockupTxId(),
                                                        txId -> {
                                                        });
                                            }
                                        });
                                        setGraphic(button);
                                    }
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 605 2010 46 2011 40 41 41 123 392 40 2008 614 424 41 123 2008 61 418 2007 40 2010 46 2012 40 41 41 59 2008 46 2013 40 1503 41 59 2008 46 2014 40 2015 45 62 123 392 40 2010 46 2016 40 41 614 2017 46 2018 41 123 2019 46 2020 40 2010 46 2021 40 41 44 2022 45 62 123 125 41 59 125 360 392 40 2010 46 2016 40 41 614 2017 46 2023 41 123 2024 46 2025 40 2010 46 2026 40 41 44 2027 45 62 123 125 41 59 125 125 41 59 2028 40 2008 41 59 125 125 360 123 2029 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2030 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
4099,Java,"                new Callback<>() {
                    @Override
                    public TableCell<RolesListItem, RolesListItem> call(TableColumn<RolesListItem,
                            RolesListItem> column) {
                        return new TableCell<>() {
                            private Hyperlink hyperlink;

                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    BondedRoleType bondedRoleType = item.getRole().getBondedRoleType();
                                    String type = bondedRoleType.getDisplayString();
                                    hyperlink = new Hyperlink(type);
                                    hyperlink.setOnAction(event -> {
                                        Optional<RoleProposal> roleProposal = bondingViewUtils.getAcceptedBondedRoleProposal(item.getRole());
                                        new RoleDetailsWindow(bondedRoleType, roleProposal, daoFacade, bsqFormatter).show();
                                    });
                                    hyperlink.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"", type)));
                                    setGraphic(hyperlink);
                                } else {
                                    setGraphic(null);
                                    if (hyperlink != null)
                                        hyperlink.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 46 2014 40 41 59 2015 2016 61 2012 46 2017 40 41 59 2008 61 418 2007 40 2016 41 59 2008 46 2018 40 373 45 62 123 2019 60 2020 62 2021 61 2022 46 2023 40 2010 46 2013 40 41 41 59 418 2024 40 2012 44 2021 44 2025 44 2026 41 46 2027 40 41 59 125 41 59 2008 46 2028 40 418 2029 40 2030 46 2031 40 648 44 2016 41 41 41 59 2032 40 2008 41 59 125 360 123 2033 40 424 41 59 392 40 2008 631 424 41 2008 46 2034 40 424 41 59 125 125 125 59 125 125 41 59 
4100,Java,"                        return new TableCell<>() {
                            private Hyperlink hyperlink;

                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    BondedRoleType bondedRoleType = item.getRole().getBondedRoleType();
                                    String type = bondedRoleType.getDisplayString();
                                    hyperlink = new Hyperlink(type);
                                    hyperlink.setOnAction(event -> {
                                        Optional<RoleProposal> roleProposal = bondingViewUtils.getAcceptedBondedRoleProposal(item.getRole());
                                        new RoleDetailsWindow(bondedRoleType, roleProposal, daoFacade, bsqFormatter).show();
                                    });
                                    hyperlink.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"", type)));
                                    setGraphic(hyperlink);
                                } else {
                                    setGraphic(null);
                                    if (hyperlink != null)
                                        hyperlink.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 46 2010 40 41 59 2011 2012 61 2008 46 2013 40 41 59 2002 61 418 2001 40 2012 41 59 2002 46 2014 40 373 45 62 123 2015 60 2016 62 2017 61 2018 46 2019 40 2006 46 2009 40 41 41 59 418 2020 40 2008 44 2017 44 2021 44 2022 41 46 2023 40 41 59 125 41 59 2002 46 2024 40 418 2025 40 2026 46 2027 40 648 44 2012 41 41 41 59 2028 40 2002 41 59 125 360 123 2029 40 424 41 59 392 40 2002 631 424 41 2002 46 2030 40 424 41 59 125 125 125 59 
4101,Java,"                new Callback<>() {
                    @Override
                    public TableCell<RolesListItem, RolesListItem> call(TableColumn<RolesListItem,
                            RolesListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;
                            private Label label;

                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String transactionId = item.getBondedRole().getLockupTxId();
                                    if (transactionId != null) {
                                        hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                        hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(transactionId, preferences));
                                        hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                        setGraphic(hyperlinkWithIcon);
                                    } else {
                                        label = new Label(""-"");
                                        setGraphic(label);
                                    }
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                    if (label != null)
                                        label = null;
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 437 2009 2010 59 64 2001 439 492 2011 40 381 2003 2012 44 324 362 41 123 463 46 2011 40 2012 44 362 41 59 392 40 2012 631 424 605 33 362 41 123 2013 2014 61 2012 46 2015 40 41 46 2016 40 41 59 392 40 2014 631 424 41 123 2008 61 418 2017 40 2014 41 59 2008 46 2018 40 373 45 62 2019 46 2020 40 2014 44 2021 41 41 59 2008 46 2022 40 418 2023 40 2024 46 2025 40 648 44 2014 41 41 41 59 2026 40 2008 41 59 125 360 123 2010 61 418 2009 40 648 41 59 2027 40 2010 41 59 125 125 360 123 2028 40 424 41 59 392 40 2008 631 424 41 2008 46 2029 40 424 41 59 392 40 2010 631 424 41 2010 61 424 59 125 125 125 59 125 125 41 59 
4104,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final RolesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setText(item.getBondStateString());
                                } else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4165,Java,"                new Callback<>() {

                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (newItem != null && !empty) {
                                    final Offer offer = newItem.getOffer();
                                    final NodeAddress makersNodeAddress = offer.getOwnerNodeAddress();
                                    String role = Res.get(""peerInfoIcon.tooltip.maker"");
                                    int numTrades = model.getNumTrades(offer);
                                    PeerInfoIconTrading peerInfoIcon = new PeerInfoIconTrading(makersNodeAddress,
                                            role,
                                            numTrades,
                                            privateNotificationManager,
                                            offer,
                                            model.preferences,
                                            model.accountAgeWitnessService,
                                            useDevPrivilegeKeys);
                                    setGraphic(peerInfoIcon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 381 2009 2010 61 2008 46 2011 40 41 59 381 2012 2013 61 2010 46 2014 40 41 59 2015 2016 61 2017 46 2018 40 648 41 59 404 2019 61 2020 46 2021 40 2010 41 59 2022 2023 61 418 2022 40 2013 44 2016 44 2019 44 2024 44 2010 44 2020 46 2025 44 2020 46 2026 44 2027 41 59 2028 40 2023 41 59 125 360 123 2029 40 424 41 59 125 125 125 59 125 125 41 59 
4167,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(
                            TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    var isSellOffer = item.getOffer().getDirection() == OfferDirection.SELL;
                                    var deposit = isSellOffer ? item.getOffer().getBuyerSecurityDeposit() :
                                            item.getOffer().getSellerSecurityDeposit();
                                    if (deposit == null) {
                                        setText(Res.get(""shared.na""));
                                        setGraphic(null);
                                    } else {
                                        setText("""");
                                        setGraphic(new ColoredDecimalPlacesWithZerosText(model.formatDepositString(
                                                deposit, item.getOffer().getAmount().getValue()),
                                                GUIUtil.AMOUNT_DECIMALS_WITH_ZEROS));
                                    }
                                } else {
                                    setText("""");
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 490 2009 61 2008 46 2010 40 41 46 2011 40 41 614 2012 46 2013 59 490 2014 61 2009 63 2008 46 2010 40 41 46 2015 40 41 58 2008 46 2010 40 41 46 2016 40 41 59 392 40 2014 614 424 41 123 2017 40 2018 46 2019 40 648 41 41 59 2020 40 424 41 59 125 360 123 2021 40 648 41 59 2022 40 418 2023 40 2024 46 2025 40 2014 44 2008 46 2010 40 41 46 2026 40 41 46 2027 40 41 41 44 2028 46 2029 41 41 59 125 125 360 123 2030 40 648 41 59 2031 40 424 41 59 125 125 125 59 125 125 41 59 
4170,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty)
                                    setText(CurrencyUtil.getCurrencyPair(item.getOffer().getCurrencyCode()));
                                else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 2005 40 2006 46 2007 40 2004 46 2008 40 41 46 2009 40 41 41 41 59 360 2005 40 648 41 59 125 125 59 
4176,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final OfferBookListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            var witnessAgeData = item.getWitnessAgeData(accountAgeWitnessService, signedWitnessService);
                            var label = witnessAgeData.isSigningRequired()
                                    ? new AccountStatusTooltipLabel(witnessAgeData, formatter)
                                    : new InfoAutoTooltipLabel(witnessAgeData.getDisplayString(), witnessAgeData.getIcon(), ContentDisplay.RIGHT, witnessAgeData.getInfo());
                            setGraphic(label);
                        } else {
                            setGraphic(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 490 2005 61 2004 46 2006 40 2007 44 2008 41 59 490 2009 61 2005 46 2010 40 41 63 418 2011 40 2005 44 2012 41 58 418 2013 40 2005 46 2014 40 41 44 2005 46 2015 40 41 44 2016 46 2017 44 2005 46 2018 40 41 41 59 2019 40 2009 41 59 125 360 123 2020 40 424 41 59 125 125 125 59 
4413,Java,"                return new TableCell<>() {

                    @Override
                    public void updateItem(final BsqTxListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            TxType txType = item.getTxType();

                            String bsqAmount = Res.get(""shared.na"");

                            if (item.getConfirmations() > 0) {
                                if (isValidType(txType))
                                    bsqAmount = item.getAmountAsString();
                                else if (item.isWithdrawalToBTCWallet())
                                    bsqAmount = bsqFormatter.formatBSQSatoshis(0L);
                            }

                            setText(bsqAmount);
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 2006 61 2004 46 2007 40 41 59 2008 2009 61 2010 46 2011 40 648 41 59 392 40 2004 46 2012 40 41 62 1500 41 123 392 40 2013 40 2006 41 41 2009 61 2004 46 2014 40 41 59 360 392 40 2004 46 2015 40 41 41 2009 61 2016 46 2017 40 1500 41 59 125 2018 40 2009 41 59 125 360 2019 40 648 41 59 125 125 59 
4414,Java,"        column.setCellFactory(new Callback<>() {

            @Override
            public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                    BsqTxListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final BsqTxListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setGraphic(item.getTxConfidenceIndicator());
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2000 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2008 40 381 2005 2009 44 324 362 41 123 463 46 2008 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2010 40 2009 46 2011 40 41 41 59 125 360 123 2012 40 424 41 59 125 125 125 59 125 125 41 59 
4418,Java,"                new Callback<>() {

                    @Override
                    public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                            BsqTxListItem> column) {
                        return new TableCell<>() {

                            private AddressWithIconAndDirection field;

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    TxType txType = item.getTxType();
                                    String labelString = Res.get(""dao.tx.type.enum."" + txType.name());
                                    Label label;
                                    if (item.getConfirmations() > 0 && isValidType(txType)) {
                                        if (item.getOptionalBsqTrade().isPresent()) {
                                            if (field != null)
                                                field.setOnAction(null);

                                            BsqSwapTrade bsqSwapTrade = item.getOptionalBsqTrade().get();
                                            String text = Res.get(""dao.tx.bsqSwapTrade"", bsqSwapTrade.getShortId());
                                            HyperlinkWithIcon hyperlinkWithIcon = new HyperlinkWithIcon(text, AwesomeIcon.INFO_SIGN);
                                            hyperlinkWithIcon.setOnAction(e -> bsqTradeDetailsWindow.show(bsqSwapTrade));
                                            hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                            setGraphic(hyperlinkWithIcon);
                                        } else if (txType == TxType.COMPENSATION_REQUEST &&
                                                daoFacade.isIssuanceTx(item.getTxId(), IssuanceType.COMPENSATION)) {
                                            if (field != null)
                                                field.setOnAction(null);

                                            labelString = Res.get(""dao.tx.issuanceFromCompReq"");
                                            label = new AutoTooltipLabel(labelString);
                                            setGraphic(label);
                                        } else if (txType == TxType.REIMBURSEMENT_REQUEST &&
                                                daoFacade.isIssuanceTx(item.getTxId(), IssuanceType.REIMBURSEMENT)) {
                                            if (field != null)
                                                field.setOnAction(null);

                                            labelString = Res.get(""dao.tx.issuanceFromReimbursement"");
                                            label = new AutoTooltipLabel(labelString);
                                            setGraphic(label);
                                        } else if (item.isBurnedBsqTx() || item.getAmount().isZero()) {
                                            if (field != null)
                                                field.setOnAction(null);

                                            if (txType == TxType.TRANSFER_BSQ &&
                                                    item.getAmount().isZero() &&
                                                    item.getTxType() != TxType.UNLOCK) {
                                                labelString = Res.get(""funds.tx.direction.self"");
                                            }

                                            label = new AutoTooltipLabel(labelString);
                                            setGraphic(label);
                                        } else {
                                            // Received
                                            String addressString = item.getAddress();
                                            field = new AddressWithIconAndDirection(item.getDirection(), addressString,
                                                    item.isReceived());
                                            field.setOnAction(event -> openAddressInBlockExplorer(item));
                                            field.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", addressString)));
                                            setGraphic(field);
                                        }
                                    } else {
                                        if (item.isWithdrawalToBTCWallet())
                                            labelString = Res.get(""dao.tx.withdrawnFromWallet"");

                                        label = new AutoTooltipLabel(labelString);
                                        setGraphic(label);
                                    }
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2014 2015 61 2016 46 2017 40 648 43 2012 46 2018 40 41 41 59 2019 2020 59 392 40 2010 46 2021 40 41 62 1500 605 2022 40 2012 41 41 123 392 40 2010 46 2023 40 41 46 2024 40 41 41 123 392 40 2008 631 424 41 2008 46 2025 40 424 41 59 2026 2027 61 2010 46 2023 40 41 46 2017 40 41 59 2014 2028 61 2016 46 2017 40 648 44 2027 46 2029 40 41 41 59 2030 2031 61 418 2030 40 2028 44 2032 46 2033 41 59 2031 46 2025 40 2034 45 62 2035 46 2036 40 2027 41 41 59 2031 46 2037 40 418 2038 40 2016 46 2017 40 648 41 41 41 59 2039 40 2031 41 59 125 360 392 40 2012 614 2011 46 2040 605 2041 46 2042 40 2010 46 2043 40 41 44 2044 46 2045 41 41 123 392 40 2008 631 424 41 2008 46 2046 40 424 41 59 2015 61 2016 46 2017 40 648 41 59 2020 61 418 2047 40 2015 41 59 2048 40 2020 41 59 125 360 392 40 2012 614 2011 46 2049 605 2041 46 2042 40 2010 46 2043 40 41 44 2044 46 2050 41 41 123 392 40 2008 631 424 41 2008 46 2051 40 424 41 59 2015 61 2016 46 2017 40 648 41 59 2020 61 418 2052 40 2015 41 59 2053 40 2020 41 59 125 360 392 40 2010 46 2054 40 41 606 2010 46 2055 40 41 46 2056 40 41 41 123 392 40 2008 631 424 41 2008 46 2057 40 424 41 59 392 40 2012 614 2011 46 2058 605 2010 46 2055 40 41 46 2056 40 41 605 2010 46 2013 40 41 631 2011 46 2059 41 123 2015 61 2016 46 2017 40 648 41 59 125 2020 61 418 2060 40 2015 41 59 2061 40 2020 41 59 125 360 123 621 2014 2062 61 2010 46 2063 40 41 59 2008 61 418 2007 40 2010 46 2064 40 41 44 2062 44 2010 46 2065 40 41 41 59 2008 46 2066 40 373 45 62 2067 40 2010 41 41 59 2008 46 2068 40 418 2069 40 2016 46 2017 40 648 44 2062 41 41 41 59 2070 40 2008 41 59 125 125 360 123 392 40 2010 46 2071 40 41 41 2015 61 2016 46 2017 40 648 41 59 2020 61 418 2072 40 2015 41 59 2073 40 2020 41 59 125 125 360 123 2074 40 424 41 59 392 40 2008 631 424 41 2008 46 2075 40 424 41 59 125 125 125 59 125 125 41 59 
4420,Java,"                new Callback<>() {

                    @Override
                    public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                            BsqTxListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> openTxInBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 621 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 40 2010 41 41 59 2008 46 2017 40 418 2018 40 2019 46 2020 40 648 44 2012 41 41 41 59 2021 40 2008 41 59 125 360 123 2022 40 424 41 59 392 40 2008 631 424 41 2008 46 2023 40 424 41 59 125 125 125 59 125 125 41 59 
4668,Java,"                new SendMailboxMessageListener() {
                    @Override
                    public void onArrived() {
                        log.info(""{} arrived at peer {}. tradeId={}, disputeResultMessage.uid={}, "" +
                                        ""chatMessage.uid={}"",
                                disputeResultMessage.getClass().getSimpleName(), peersNodeAddress,
                                disputeResultMessage.getTradeId(), disputeResultMessage.getUid(),
                                chatMessage.getUid());

                        // We use the chatMessage wrapped inside the disputeResultMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setArrived(true);
                        requestPersistence();
                    }

                    @Override
                    public void onStoredInMailbox() {
                        log.info(""{} stored in mailbox for peer {}. tradeId={}, disputeResultMessage.uid={}, "" +
                                        ""chatMessage.uid={}"",
                                disputeResultMessage.getClass().getSimpleName(), peersNodeAddress,
                                disputeResultMessage.getTradeId(), disputeResultMessage.getUid(),
                                chatMessage.getUid());

                        // We use the chatMessage wrapped inside the disputeResultMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setStoredInMailbox(true);
                        requestPersistence();
                    }

                    @Override
                    public void onFault(String errorMessage) {
                        log.error(""{} failed: Peer {}. tradeId={}, disputeResultMessage.uid={}, "" +
                                        ""chatMessage.uid={}, errorMessage={}"",
                                disputeResultMessage.getClass().getSimpleName(), peersNodeAddress,
                                disputeResultMessage.getTradeId(), disputeResultMessage.getUid(),
                                chatMessage.getUid(), errorMessage);

                        // We use the chatMessage wrapped inside the disputeResultMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setSendMessageError(errorMessage);
                        requestPersistence();
                    }
                }",0,418 2000 40 41 123 64 2001 439 492 2002 40 41 123 2003 46 2004 40 648 43 648 44 2005 46 2006 40 41 46 2007 40 41 44 2008 44 2005 46 2009 40 41 44 2005 46 2010 40 41 44 2011 46 2010 40 41 41 59 621 621 2011 46 2012 40 473 41 59 2013 40 41 59 125 64 2001 439 492 2014 40 41 123 2015 46 2016 40 648 43 648 44 2017 46 2018 40 41 46 2019 40 41 44 2020 44 2017 46 2021 40 41 44 2017 46 2022 40 41 44 2023 46 2022 40 41 41 59 621 621 2023 46 2024 40 473 41 59 2025 40 41 59 125 64 2001 439 492 2026 40 2027 2028 41 123 2029 46 371 40 648 43 648 44 2030 46 2031 40 41 46 2032 40 41 44 2033 44 2030 46 2034 40 41 44 2030 46 2035 40 41 44 2036 46 2035 40 41 44 2028 41 59 621 621 2036 46 2037 40 2028 41 59 2038 40 41 59 125 125 
4716,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getTotalFeesPaidAsString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4718,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getNameAndCode());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4722,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getTradedVolumeAsString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4724,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final AssetListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLookBackPeriodInDays());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4755,Java,"        txConfidenceListener = new TxConfidenceListener(txId) {
            @Override
            public void onTransactionConfidenceChanged(TransactionConfidence confidence) {
                GUIUtil.updateConfidence(confidence, lazy().tooltip, lazy().txConfidenceIndicator);
                confirmations = confidence.getDepthInBlocks();
            }
        };",0,2000 61 418 2001 40 2002 41 123 64 2003 439 492 2004 40 2005 2006 41 123 2007 46 2008 40 2006 44 2009 40 41 46 2010 44 2009 40 41 46 2011 41 59 2012 61 2006 46 2013 40 41 59 125 125 59 
4854,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmount());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4856,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getSalt());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4858,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getHash());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4860,Java,"                        return new TableCell<>() {
                            AutoTooltipButton button;

                            @Override
                            public void updateItem(final MyReputationListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty && item.isShowButton()) {
                                    button = new AutoTooltipButton(item.getButtonText());
                                    button.setOnAction(e -> {
                                        if (item.getBondState() == BondState.LOCKUP_TX_CONFIRMED) {
                                            bondingViewUtils.unLock(item.getLockupTxId(),
                                                    txId -> {
                                                    });
                                        }
                                    });
                                    setGraphic(button);
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 605 2006 46 2007 40 41 41 123 2002 61 418 2001 40 2006 46 2008 40 41 41 59 2002 46 2009 40 2010 45 62 123 392 40 2006 46 2011 40 41 614 2012 46 2013 41 123 2014 46 2015 40 2006 46 2016 40 41 44 2017 45 62 123 125 41 59 125 125 41 59 2018 40 2002 41 59 125 360 123 2019 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2020 40 424 41 59 2002 61 424 59 125 125 125 125 59 
4864,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(MyReputationListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setText(item.getBondStateString());
                                } else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4866,Java,"                return new TableCell<>() {

                    @Override
                    public void updateItem(final MyReputationListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLockupDateString());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
4868,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final MyReputationListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(item.getTxId(), preferences));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 621 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 59 2002 61 418 2010 40 2008 41 59 2002 46 2011 40 373 45 62 2012 46 2013 40 2006 46 2009 40 41 44 2014 41 41 59 2002 46 2015 40 418 2016 40 2017 46 2018 40 648 44 2008 41 41 41 59 2019 40 2002 41 59 125 360 123 2020 40 424 41 59 392 40 2002 631 424 41 2002 46 2021 40 424 41 59 125 125 125 59 
4985,Java,"@Slf4j
@ToString
/*
 * Holds a List of refund dispute objects.
 *
 * Calls to the List are delegated because this class intercepts the add/remove calls so changes
 * can be saved to disc.
 */
public final class RefundDisputeList extends DisputeList<Dispute> {

    RefundDisputeList() {
        super();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // PROTO BUFFER
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected RefundDisputeList(Collection<Dispute> collection) {
        super(collection);
    }

    @Override
    public Message toProtoMessage() {
        forEach(dispute -> checkArgument(dispute.getSupportType().equals(SupportType.REFUND), ""Support type has to be REFUND""));

        return protobuf.PersistableEnvelope.newBuilder().setRefundDisputeList(protobuf.RefundDisputeList.newBuilder()
                .addAllDispute(ProtoUtil.collectionToProto(getList(), protobuf.Dispute.class))).build();
    }

    public static RefundDisputeList fromProto(protobuf.RefundDisputeList proto,
                                              CoreProtoResolver coreProtoResolver) {
        List<Dispute> list = proto.getDisputeList().stream()
                .map(disputeProto -> Dispute.fromProto(disputeProto, coreProtoResolver))
                .filter(e -> e.getSupportType().equals(SupportType.REFUND))
                .collect(Collectors.toList());
        return new RefundDisputeList(list);
    }
}",0,64 2000 64 2001 604 439 381 334 2002 378 2003 60 2004 62 123 2002 40 41 123 463 40 41 59 125 621 621 621 438 2002 40 2005 60 2004 62 2006 41 123 463 40 2006 41 59 125 64 2007 439 2008 2009 40 41 123 2010 40 2011 45 62 2012 40 2011 46 2013 40 41 46 2014 40 2015 46 2016 41 44 648 41 41 59 450 2017 46 2018 46 2019 40 41 46 2020 40 2017 46 2002 46 2019 40 41 46 2021 40 2022 46 2023 40 2024 40 41 44 2017 46 2004 46 334 41 41 41 46 2025 40 41 59 125 439 457 2002 2026 40 2027 46 2002 2028 44 2029 2030 41 123 2031 60 2004 62 411 61 2028 46 2032 40 41 46 2033 40 41 46 2034 40 2035 45 62 2004 46 2026 40 2035 44 2030 41 41 46 2036 40 2037 45 62 2037 46 2038 40 41 46 2039 40 2040 46 2041 41 41 46 2042 40 2043 46 2044 40 41 41 59 450 418 2002 40 411 41 59 125 125 
4993,Java,"                return new TableCell<>() {

                    @Override
                    public void updateItem(final DepositListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            if (textProperty().isBound())
                                textProperty().unbind();

                            textProperty().bind(item.balanceProperty());
                        } else {
                            textProperty().unbind();
                            setText("""");
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 392 40 2005 40 41 46 2006 40 41 41 2005 40 41 46 2007 40 41 59 2005 40 41 46 2008 40 2004 46 2009 40 41 41 59 125 360 123 2010 40 41 46 2011 40 41 59 2012 40 648 41 59 125 125 125 59 
4996,Java,"        usageColumn.setCellFactory(new Callback<>() {

            @Override
            public TableCell<DepositListItem, DepositListItem> call(TableColumn<DepositListItem,
                    DepositListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final DepositListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setGraphic(new AutoTooltipLabel(item.getUsage()));
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 44 2005 62 2006 40 2007 60 2005 44 2005 62 2008 41 123 450 418 2004 60 62 40 41 123 64 2003 439 492 2009 40 381 2005 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 40 418 2012 40 2010 46 2013 40 41 41 41 59 125 360 123 2014 40 424 41 59 125 125 125 59 125 125 41 59 
4997,Java,"                return new TableCell<>() {

                    @Override
                    public void updateItem(final DepositListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setGraphic(new AutoTooltipLabel(item.getUsage()));
                        } else {
                            setGraphic(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 418 2006 40 2004 46 2007 40 41 41 41 59 125 360 123 2008 40 424 41 59 125 125 125 59 
5038,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(item.getTxConfidenceIndicator());
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 123 2007 40 424 41 59 125 125 125 59 
5040,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(item.getDateString()));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 418 2006 40 2004 46 2007 40 41 41 41 59 125 360 123 2008 40 424 41 59 125 125 125 59 
5042,Java,"                        return new TableCell<>() {

                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final TransactionsListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (item.getDetailsAvailable()) {
                                        hyperlinkWithIcon = new HyperlinkWithIcon(item.getDetails(), AwesomeIcon.INFO_SIGN);
                                        hyperlinkWithIcon.setOnAction(event -> openDetailPopup(item));
                                        hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                        setGraphic(hyperlinkWithIcon);
                                        // If details are available its a trade tx and we don't expect any dust attack tx
                                    } else {
                                        if (item.isDustAttackTx()) {
                                            hyperlinkWithIcon = new HyperlinkWithIcon(item.getDetails(), AwesomeIcon.WARNING_SIGN);
                                            hyperlinkWithIcon.setOnAction(event -> new Popup().warning(Res.get(""funds.tx.dustAttackTx.popup"")).show());
                                            setGraphic(hyperlinkWithIcon);
                                        } else {
                                            setGraphic(new AutoTooltipLabel(item.getDetails()));
                                        }
                                    }
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 392 40 2006 46 2007 40 41 41 123 2002 61 418 2001 40 2006 46 2008 40 41 44 2009 46 2010 41 59 2002 46 2011 40 373 45 62 2012 40 2006 41 41 59 2002 46 2013 40 418 2014 40 2015 46 2016 40 648 41 41 41 59 2017 40 2002 41 59 621 125 360 123 392 40 2006 46 2018 40 41 41 123 2002 61 418 2001 40 2006 46 2019 40 41 44 2020 46 2021 41 59 2002 46 2022 40 373 45 62 418 2023 40 41 46 494 40 2024 46 2025 40 648 41 41 46 2026 40 41 41 59 2027 40 2002 41 59 125 360 123 2028 40 418 2029 40 2006 46 2030 40 41 41 41 59 125 125 125 360 123 2031 40 424 41 59 392 40 2002 631 424 41 2002 46 2032 40 424 41 59 125 125 125 59 
5121,Java,"        balanceListener = new BalanceListener() {
            @Override
            public void onBalanceChanged(Coin balance, Transaction tx) {
                updateList();
            }
        };",0,2000 61 418 2001 40 41 123 64 2002 439 492 2003 40 2004 2005 44 2006 2007 41 123 2008 40 41 59 125 125 59 
5123,Java,"                new Callback<>() {

                    @Override
                    public TableCell<WithdrawalListItem, WithdrawalListItem> call(TableColumn<WithdrawalListItem,
                            WithdrawalListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String address = item.getAddressString();
                                    hyperlinkWithIcon = new ExternalHyperlink(address);
                                    hyperlinkWithIcon.setOnAction(event -> openBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", address)));
                                    setAlignment(Pos.CENTER);
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 40 2010 41 41 59 2008 46 2017 40 418 2018 40 2019 46 2020 40 648 44 2012 41 41 41 59 2021 40 2022 46 2023 41 59 2024 40 2008 41 59 125 360 123 2025 40 424 41 59 392 40 2008 631 424 41 2008 46 2026 40 424 41 59 125 125 125 59 125 125 41 59 
5124,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String address = item.getAddressString();
                                    hyperlinkWithIcon = new ExternalHyperlink(address);
                                    hyperlinkWithIcon.setOnAction(event -> openBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", address)));
                                    setAlignment(Pos.CENTER);
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 59 2002 61 418 2010 40 2008 41 59 2002 46 2011 40 373 45 62 2012 40 2006 41 41 59 2002 46 2013 40 418 2014 40 2015 46 2016 40 648 44 2008 41 41 41 59 2017 40 2018 46 2019 41 59 2020 40 2002 41 59 125 360 123 2021 40 424 41 59 392 40 2002 631 424 41 2002 46 2022 40 424 41 59 125 125 125 59 
5126,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic((item != null && !empty) ? item.getBalanceLabel() : null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 40 2004 631 424 605 33 362 41 63 2004 46 2006 40 41 58 424 41 59 125 125 59 
5247,Java,"                new Callback<>() {

                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    final Trade trade = newItem.getTrade();
                                    final NodeAddress tradingPeerNodeAddress = trade.getTradingPeerNodeAddress();
                                    int numPastTrades = model.getNumPastTrades(trade);
                                    String role = Res.get(""peerInfoIcon.tooltip.tradePeer"");
                                    Node peerInfoIcon = new PeerInfoIconTrading(tradingPeerNodeAddress,
                                            role,
                                            numPastTrades,
                                            privateNotificationManager,
                                            trade,
                                            preferences,
                                            model.accountAgeWitnessService,
                                            useDevPrivilegeKeys);
                                    setPadding(new Insets(1, 0, 0, 0));
                                    setGraphic(peerInfoIcon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 33 362 605 2008 631 424 41 123 381 2009 2010 61 2008 46 2011 40 41 59 381 2012 2013 61 2010 46 2014 40 41 59 404 2015 61 2016 46 2017 40 2010 41 59 2018 2019 61 2020 46 2021 40 648 41 59 2022 2023 61 418 2024 40 2013 44 2019 44 2015 44 2025 44 2010 44 2026 44 2016 46 2027 44 2028 41 59 2029 40 418 2030 40 1501 44 1500 44 1500 44 1500 41 41 59 2031 40 2023 41 59 125 360 123 2032 40 424 41 59 125 125 125 59 125 125 41 59 
5246,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(formatter.formatCoin(item.getTrade().getAmount())));
                                else
                                    setGraphic(null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 2005 40 418 2006 40 2007 46 2008 40 2004 46 2009 40 41 46 2010 40 41 41 41 41 59 360 2005 40 424 41 59 125 125 59 
5252,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(DisplayUtils.formatDateTime(item.getTrade().getDate())));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 418 2006 40 2007 46 2008 40 2004 46 2009 40 41 46 2010 40 41 41 41 41 59 125 360 123 2011 40 424 41 59 125 125 125 59 
5254,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 418 2006 40 2007 46 2008 40 2004 41 41 41 59 125 125 59 
5258,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(FormattingUtils.formatPrice(item.getPrice())));
                                else
                                    setGraphic(null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 2005 40 418 2006 40 2007 46 2008 40 2004 46 2009 40 41 41 41 41 59 360 2005 40 424 41 59 125 125 59 
5256,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getPaymentMethod(item)));
                                else
                                    setGraphic(null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 2005 40 418 2006 40 2007 46 2008 40 2004 41 41 41 59 360 2005 40 424 41 59 125 125 59 
5262,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getMyRole(item)));
                                else
                                    setGraphic(null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 2005 40 418 2006 40 2007 46 2008 40 2004 41 41 41 59 360 2005 40 424 41 59 125 125 59 
5327,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");
                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getDate(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5328,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            final ImageView iconView = new ImageView();
                            AutoTooltipSlideToggleButton checkBox;

                            private void updateState(@NotNull OpenOffer openOffer) {
                                checkBox.setSelected(!openOffer.isDeactivated());
                            }

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    OpenOffer openOffer = item.getOpenOffer();
                                    if (checkBox == null) {
                                        checkBox = new AutoTooltipSlideToggleButton();
                                        checkBox.setPadding(new Insets(-7, 0, -7, 0));
                                        checkBox.setGraphic(iconView);
                                    }
                                    checkBox.setDisable(model.dataModel.wasTriggered(openOffer));
                                    checkBox.setOnAction(event -> {
                                        if (openOffer.isDeactivated()) {
                                            onActivateOpenOffer(openOffer);
                                        } else {
                                            onDeactivateOpenOffer(openOffer);
                                        }
                                        updateState(openOffer);
                                        tableView.refresh();
                                    });
                                    updateState(openOffer);
                                    setGraphic(checkBox);
                                } else {
                                    setGraphic(null);
                                    if (checkBox != null) {
                                        checkBox.setOnAction(null);
                                        checkBox = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 381 2007 2008 61 418 2007 40 41 59 2009 2010 59 437 492 2011 40 64 2012 2013 2014 41 123 2010 46 2015 40 33 2014 46 2016 40 41 41 59 125 64 2001 439 492 2017 40 381 2003 2018 44 324 362 41 123 463 46 2017 40 2018 44 362 41 59 392 40 2018 631 424 605 33 362 41 123 2013 2014 61 2018 46 2019 40 41 59 392 40 2010 614 424 41 123 2010 61 418 2009 40 41 59 2010 46 2020 40 418 2021 40 45 1502 44 1500 44 45 1502 44 1500 41 41 59 2010 46 2022 40 2008 41 59 125 2010 46 2023 40 2024 46 2025 46 2026 40 2014 41 41 59 2010 46 2027 40 373 45 62 123 392 40 2014 46 2028 40 41 41 123 2029 40 2014 41 59 125 360 123 2030 40 2014 41 59 125 2011 40 2014 41 59 2031 46 2032 40 41 59 125 41 59 2011 40 2014 41 59 2033 40 2010 41 59 125 360 123 2034 40 424 41 59 392 40 2010 631 424 41 123 2010 46 2035 40 424 41 59 2010 61 424 59 125 125 125 125 59 125 125 41 59 
5329,Java,"                        return new TableCell<>() {
                            final ImageView iconView = new ImageView();
                            AutoTooltipSlideToggleButton checkBox;

                            private void updateState(@NotNull OpenOffer openOffer) {
                                checkBox.setSelected(!openOffer.isDeactivated());
                            }

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    OpenOffer openOffer = item.getOpenOffer();
                                    if (checkBox == null) {
                                        checkBox = new AutoTooltipSlideToggleButton();
                                        checkBox.setPadding(new Insets(-7, 0, -7, 0));
                                        checkBox.setGraphic(iconView);
                                    }
                                    checkBox.setDisable(model.dataModel.wasTriggered(openOffer));
                                    checkBox.setOnAction(event -> {
                                        if (openOffer.isDeactivated()) {
                                            onActivateOpenOffer(openOffer);
                                        } else {
                                            onDeactivateOpenOffer(openOffer);
                                        }
                                        updateState(openOffer);
                                        tableView.refresh();
                                    });
                                    updateState(openOffer);
                                    setGraphic(checkBox);
                                } else {
                                    setGraphic(null);
                                    if (checkBox != null) {
                                        checkBox.setOnAction(null);
                                        checkBox = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 381 2001 2002 61 418 2001 40 41 59 2003 2004 59 437 492 2005 40 64 2006 2007 2008 41 123 2004 46 2009 40 33 2008 46 2010 40 41 41 59 125 64 2011 439 492 2012 40 381 2013 2014 44 324 362 41 123 463 46 2012 40 2014 44 362 41 59 392 40 2014 631 424 605 33 362 41 123 2007 2008 61 2014 46 2015 40 41 59 392 40 2004 614 424 41 123 2004 61 418 2003 40 41 59 2004 46 2016 40 418 2017 40 45 1502 44 1500 44 45 1502 44 1500 41 41 59 2004 46 2018 40 2002 41 59 125 2004 46 2019 40 2020 46 2021 46 2022 40 2008 41 41 59 2004 46 2023 40 373 45 62 123 392 40 2008 46 2024 40 41 41 123 2025 40 2008 41 59 125 360 123 2026 40 2008 41 59 125 2005 40 2008 41 59 2027 46 2028 40 41 59 125 41 59 2005 40 2008 41 59 2029 40 2004 41 59 125 360 123 2030 40 424 41 59 392 40 2004 631 424 41 123 2004 46 2031 40 424 41 59 2004 61 424 59 125 125 125 125 59 
5334,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = getRegularIconButton(MaterialDesignIcon.CONTENT_COPY);
                                        button.setTooltip(new Tooltip(Res.get(""shared.duplicateOffer"")));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(event -> onDuplicateOffer(item.getOffer()));
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2008 614 424 41 123 2008 61 2011 40 2012 46 2013 41 59 2008 46 2014 40 418 2015 40 2016 46 2017 40 648 41 41 41 59 2018 40 2008 41 59 125 2008 46 2019 40 373 45 62 2020 40 2010 46 2021 40 41 41 41 59 125 360 123 2022 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2023 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
5333,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getDirectionLabel(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5337,Java,"                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (item.getOffer().isBsqSwapOffer()) {
                                        if (button != null) {
                                            button.setOnAction(null);
                                            button = null;
                                        }
                                        if (item.getOpenOffer().isBsqSwapOfferHasMissingFunds()) {
                                            Label label = new Label();
                                            Text icon = getRegularIconForLabel(MaterialDesignIcon.EYE_OFF, label);
                                            Tooltip.install(icon, new Tooltip(Res.get(""openOffer.bsqSwap.missingFunds"")));
                                            setGraphic(icon);
                                        } else {
                                            setGraphic(null);
                                        }
                                    } else {
                                        if (button == null) {
                                            button = getRegularIconButton(MaterialDesignIcon.PENCIL);
                                            button.setTooltip(new Tooltip(Res.get(""shared.editOffer"")));
                                            button.setOnAction(event -> onEditOpenOffer(item.getOpenOffer()));
                                            setGraphic(button);
                                        }
                                    }
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 392 40 2006 46 2007 40 41 46 2008 40 41 41 123 392 40 2002 631 424 41 123 2002 46 2009 40 424 41 59 2002 61 424 59 125 392 40 2006 46 2010 40 41 46 2011 40 41 41 123 2012 2013 61 418 2012 40 41 59 2014 2015 61 2016 40 2017 46 2018 44 2013 41 59 2019 46 2020 40 2015 44 418 2019 40 2021 46 2022 40 648 41 41 41 59 2023 40 2015 41 59 125 360 123 2024 40 424 41 59 125 125 360 123 392 40 2002 614 424 41 123 2002 61 2025 40 2026 46 2027 41 59 2002 46 2028 40 418 2029 40 2030 46 2031 40 648 41 41 41 59 2002 46 2032 40 373 45 62 2033 40 2006 46 2034 40 41 41 41 59 2035 40 2002 41 59 125 125 125 360 123 2036 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2037 40 424 41 59 2002 61 424 59 125 125 125 125 59 
5339,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5340,Java,"                new Callback<>() {

                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(TableColumn<OpenOfferListItem,
                            OpenOfferListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon field;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    field = new HyperlinkWithIcon(model.getOfferId(item));
                                    field.setOnAction(event -> {
                                        if (item.getOffer().isBsqSwapOffer()) {
                                            bsqSwapOfferDetailsWindow.show(item.getOffer());
                                        } else {
                                            offerDetailsWindow.show(item.getOffer());
                                        }
                                    });

                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                    setGraphic(field);
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2008 61 418 2007 40 2011 46 2012 40 2010 41 41 59 2008 46 2013 40 373 45 62 123 392 40 2010 46 2014 40 41 46 2015 40 41 41 123 2016 46 2017 40 2010 46 2014 40 41 41 59 125 360 123 2018 46 2019 40 2010 46 2014 40 41 41 59 125 125 41 59 2008 46 2020 40 418 2021 40 2022 46 2023 40 648 41 41 41 59 2024 40 2008 41 59 125 360 123 2025 40 424 41 59 392 40 2008 631 424 41 2008 46 2026 40 424 41 59 125 125 125 59 125 125 41 59 
5343,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getPaymentMethod(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5344,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getPrice(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
5345,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getPrice(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5347,Java,"                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = getRegularIconButton(MaterialDesignIcon.DELETE_FOREVER, ""delete"");
                                        button.setTooltip(new Tooltip(Res.get(""shared.removeOffer"")));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(event -> onRemoveOpenOffer(item.getOpenOffer()));
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 392 40 2002 614 424 41 123 2002 61 2007 40 2008 46 2009 44 648 41 59 2002 46 2010 40 418 2011 40 2012 46 2013 40 648 41 41 41 59 2014 40 2002 41 59 125 2002 46 2015 40 373 45 62 2016 40 2006 46 2017 40 41 41 41 59 125 360 123 2018 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2019 40 424 41 59 2002 61 424 59 125 125 125 125 59 
5348,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = getRegularIconButton(MaterialDesignIcon.SHIELD_HALF_FULL);
                                        boolean triggerPriceSet = item.getOpenOffer().getTriggerPrice() > 0;
                                        button.setVisible(triggerPriceSet);

                                        if (model.dataModel.wasTriggered(item.getOpenOffer())) {
                                            button.getGraphic().getStyleClass().add(""warning"");
                                            button.setTooltip(new Tooltip(Res.get(""openOffer.triggered"")));
                                        } else {
                                            button.getGraphic().getStyleClass().remove(""warning"");
                                            button.setTooltip(new Tooltip(Res.get(""openOffer.triggerPrice"", model.getTriggerPrice(item))));
                                        }
                                        setGraphic(button);
                                    }
                                    button.setOnAction(event -> onEditOpenOffer(item.getOpenOffer()));
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2008 614 424 41 123 2008 61 2011 40 2012 46 2013 41 59 324 2014 61 2010 46 2015 40 41 46 2016 40 41 62 1500 59 2008 46 2017 40 2014 41 59 392 40 2018 46 2019 46 2020 40 2010 46 2015 40 41 41 41 123 2008 46 2021 40 41 46 2022 40 41 46 2023 40 648 41 59 2008 46 2024 40 418 2025 40 2026 46 2027 40 648 41 41 41 59 125 360 123 2008 46 2028 40 41 46 2029 40 41 46 2030 40 648 41 59 2008 46 2031 40 418 2032 40 2033 46 2034 40 648 44 2018 46 2016 40 2010 41 41 41 41 59 125 2035 40 2008 41 59 125 2008 46 2036 40 373 45 62 2037 40 2010 46 2038 40 41 41 41 59 125 360 123 2039 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2040 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
5349,Java,"                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = getRegularIconButton(MaterialDesignIcon.SHIELD_HALF_FULL);
                                        boolean triggerPriceSet = item.getOpenOffer().getTriggerPrice() > 0;
                                        button.setVisible(triggerPriceSet);

                                        if (model.dataModel.wasTriggered(item.getOpenOffer())) {
                                            button.getGraphic().getStyleClass().add(""warning"");
                                            button.setTooltip(new Tooltip(Res.get(""openOffer.triggered"")));
                                        } else {
                                            button.getGraphic().getStyleClass().remove(""warning"");
                                            button.setTooltip(new Tooltip(Res.get(""openOffer.triggerPrice"", model.getTriggerPrice(item))));
                                        }
                                        setGraphic(button);
                                    }
                                    button.setOnAction(event -> onEditOpenOffer(item.getOpenOffer()));
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 392 40 2002 614 424 41 123 2002 61 2007 40 2008 46 2009 41 59 324 2010 61 2006 46 2011 40 41 46 2012 40 41 62 1500 59 2002 46 2013 40 2010 41 59 392 40 2014 46 2015 46 2016 40 2006 46 2011 40 41 41 41 123 2002 46 2017 40 41 46 2018 40 41 46 2019 40 648 41 59 2002 46 2020 40 418 2021 40 2022 46 2023 40 648 41 41 41 59 125 360 123 2002 46 2024 40 41 46 2025 40 41 46 2026 40 648 41 59 2002 46 2027 40 418 2028 40 2029 46 2030 40 648 44 2014 46 2012 40 2006 41 41 41 41 59 125 2031 40 2002 41 59 125 2002 46 2032 40 373 45 62 2033 40 2006 46 2034 40 41 41 41 59 125 360 123 2035 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2036 40 424 41 59 2002 61 424 59 125 125 125 125 59 
5352,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getVolume(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
5478,Java,"        walletsManager.publishAndCommitBsqTx(transaction, TxType.ASSET_LISTING_FEE, new TxBroadcaster.Callback() {
            @Override
            public void onSuccess(Transaction transaction) {
                log.info(""Asset listing fee tx has been published. TxId={}"", transaction.getTxId().toString());
                resultHandler.handleResult();
            }

            @Override
            public void onFailure(TxBroadcastException exception) {
                errorMessageHandler.handleErrorMessage(exception.getMessage());
            }
        });",0,2000 46 2001 40 2002 44 2003 46 2004 44 418 2005 46 2006 40 41 123 64 2007 439 492 2008 40 2009 2002 41 123 2010 46 2011 40 648 44 2002 46 2012 40 41 46 2013 40 41 41 59 2014 46 2015 40 41 59 125 64 2007 439 492 2016 40 2017 2018 41 123 2019 46 2020 40 2018 46 2021 40 41 41 59 125 125 41 59 
5486,Java,"                new Callback<>() {

                    @Override
                    public TableCell<LockedListItem, LockedListItem> call(TableColumn<LockedListItem,
                            LockedListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final LockedListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String address = item.getAddressString();
                                    hyperlinkWithIcon = new ExternalHyperlink(address);
                                    hyperlinkWithIcon.setOnAction(event -> openBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", address)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 2012 61 2010 46 2013 40 41 59 2008 61 418 2014 40 2012 41 59 2008 46 2015 40 373 45 62 2016 40 2010 41 41 59 2008 46 2017 40 418 2018 40 2019 46 2020 40 648 44 2012 41 41 41 59 2021 40 2008 41 59 125 360 123 2022 40 424 41 59 392 40 2008 631 424 41 2008 46 2023 40 424 41 59 125 125 125 59 125 125 41 59 
5487,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final LockedListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String address = item.getAddressString();
                                    hyperlinkWithIcon = new ExternalHyperlink(address);
                                    hyperlinkWithIcon.setOnAction(event -> openBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", address)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2007 2008 61 2006 46 2009 40 41 59 2002 61 418 2010 40 2008 41 59 2002 46 2011 40 373 45 62 2012 40 2006 41 41 59 2002 46 2013 40 418 2014 40 2015 46 2016 40 648 44 2008 41 41 41 59 2017 40 2002 41 59 125 360 123 2018 40 424 41 59 392 40 2002 631 424 41 2002 46 2019 40 424 41 59 125 125 125 59 
5491,Java,"                return new TableCell<>() {

                    @Override
                    public void updateItem(final LockedListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            if (getTradable(item).isPresent())
                                setGraphic(new AutoTooltipLabel(item.getDateString()));
                            else
                                setGraphic(new AutoTooltipLabel(item.getDateString()));
                        } else {
                            setGraphic(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 392 40 2005 40 2004 41 46 2006 40 41 41 2007 40 418 2008 40 2004 46 2009 40 41 41 41 59 360 2007 40 418 2008 40 2004 46 2009 40 41 41 41 59 125 360 123 2010 40 424 41 59 125 125 125 59 
5591,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmount());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
5597,Java,"                return new TableCell<>() {
                    @Override
                    public void updateItem(final BondListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getLockTime());
                        } else
                            setText("""");
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
5599,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final BondListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setText(item.getBondStateString());
                                } else
                                    setText("""");
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 41 59 125 360 2007 40 648 41 59 125 125 59 
5608,Java,"                    addOfferBookChangedListener(new OfferBookChangedListener() {
                        @Override
                        public void onAdded(Offer offer) {
                            doDumpStatistics();
                        }

                        @Override
                        public void onRemoved(Offer offer) {
                            doDumpStatistics();
                        }
                    });",0,2000 40 418 2001 40 41 123 64 2002 439 492 2003 40 2004 2005 41 123 2006 40 41 59 125 64 2002 439 492 2007 40 2004 2005 41 123 2008 40 41 59 125 125 41 59 
18540,Java,"  /* package */ static final class SourceLoadable implements Loadable {

    public final long loadTaskId;
    public final DataSpec dataSpec;

    private final StatsDataSource dataSource;

    @Nullable private byte[] sampleData;

    public SourceLoadable(DataSpec dataSpec, DataSource dataSource) {
      this.loadTaskId = LoadEventInfo.getNewId();
      this.dataSpec = dataSpec;
      this.dataSource = new StatsDataSource(dataSource);
    }

    @Override
    public void cancelLoad() {
      // Never happens.
    }

    @Override
    public void load() throws IOException {
      // We always load from the beginning, so reset bytesRead to 0.
      dataSource.resetBytesRead();
      try {
        // Create and open the input.
        dataSource.open(dataSpec);
        // Load the sample data.
        int result = 0;
        while (result != C.RESULT_END_OF_INPUT) {
          int sampleSize = (int) dataSource.getBytesRead();
          if (sampleData == null) {
            sampleData = new byte[INITIAL_SAMPLE_SIZE];
          } else if (sampleSize == sampleData.length) {
            sampleData = Arrays.copyOf(sampleData, sampleData.length * 2);
          }
          result = dataSource.read(sampleData, sampleSize, sampleData.length - sampleSize);
        }
      } finally {
        DataSourceUtil.closeQuietly(dataSource);
      }
    }
  }",0,604 457 381 334 2000 395 2001 123 439 381 413 2002 59 439 381 2003 2004 59 437 381 2005 2006 59 64 2007 437 326 91 93 2008 59 439 2000 40 2003 2004 44 2009 2006 41 123 467 46 2002 61 2010 46 2011 40 41 59 467 46 2004 61 2004 59 467 46 2006 61 418 2005 40 2006 41 59 125 64 2012 439 492 2013 40 41 123 621 125 64 2012 439 492 2014 40 41 470 2015 123 621 2006 46 2016 40 41 59 474 123 621 2006 46 2017 40 2004 41 59 621 404 2018 61 1500 59 496 40 2018 631 2019 46 2020 41 123 404 2021 61 40 404 41 2006 46 2022 40 41 59 392 40 2008 614 424 41 123 2008 61 418 326 91 2023 93 59 125 360 392 40 2021 614 2008 46 2024 41 123 2008 61 2025 46 2026 40 2008 44 2008 46 2024 42 1502 41 59 125 2018 61 2006 46 2027 40 2008 44 2021 44 2008 46 2024 45 2021 41 59 125 125 382 123 2028 46 2029 40 2006 41 59 125 125 125 
