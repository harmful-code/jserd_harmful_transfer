id,language,text,smell,tokens
98650,C++,"class VRTGroup final: public GDALGroup
{
public:
    struct Ref
    {
        VRTGroup* m_ptr;
        explicit Ref(VRTGroup* ptr): m_ptr(ptr) {}
        Ref(const Ref&) = delete;
        Ref& operator=(const Ref&) = delete;
    };

private:
    std::shared_ptr<Ref> m_poSharedRefRootGroup{};
    std::weak_ptr<Ref> m_poWeakRefRootGroup{};
    std::shared_ptr<Ref> m_poRefSelf{};

    std::string m_osFilename{};
    mutable bool m_bDirty = false;
    std::string m_osVRTPath{};
    std::map<std::string, std::shared_ptr<VRTGroup>> m_oMapGroups{};
    std::map<std::string, std::shared_ptr<VRTMDArray>> m_oMapMDArrays{};
    std::map<std::string, std::shared_ptr<VRTAttribute>> m_oMapAttributes{};
    std::map<std::string, std::shared_ptr<VRTDimension>> m_oMapDimensions{};

    std::shared_ptr<VRTGroup> OpenGroupInternal(const std::string& osName) const;
    void SetRootGroupRef(const std::weak_ptr<Ref>& rgRef);
    std::weak_ptr<Ref> GetRootGroupRef() const;

public:

    VRTGroup(const std::string& osParentName, const std::string& osName);
    ~VRTGroup();

    bool XMLInit(const std::shared_ptr<VRTGroup>& poRoot,
                 const std::shared_ptr<VRTGroup>& poThisGroup,
                 const CPLXMLNode* psNode,
                 const char* pszVRTPath);

    std::vector<std::string> GetMDArrayNames(CSLConstList papszOptions) const override;
    std::shared_ptr<GDALMDArray> OpenMDArray(const std::string& osName,
                                             CSLConstList papszOptions = nullptr) const override;

    std::vector<std::string> GetGroupNames(CSLConstList papszOptions) const override;
    std::shared_ptr<GDALGroup> OpenGroup(const std::string& osName,
                                         CSLConstList) const override
    {
        return OpenGroupInternal(osName);
    }

    std::vector<std::shared_ptr<GDALDimension>> GetDimensions(CSLConstList) const override;

    std::vector<std::shared_ptr<GDALAttribute>> GetAttributes(CSLConstList) const override;

    std::shared_ptr<VRTDimension> GetDimension(const std::string& name) const {
        auto oIter = m_oMapDimensions.find(name);
        return oIter == m_oMapDimensions.end() ? nullptr : oIter->second;
    }
    std::shared_ptr<VRTDimension> GetDimensionFromFullName(const std::string& name,
                                                           bool bEmitError) const;

    std::shared_ptr<GDALGroup> CreateGroup(const std::string& osName,
                                           CSLConstList papszOptions = nullptr) override;

    std::shared_ptr<GDALDimension> CreateDimension(const std::string& osName,
                                                           const std::string& osType,
                                                           const std::string& osDirection,
                                                           GUInt64 nSize,
                                                           CSLConstList papszOptions = nullptr) override;

    std::shared_ptr<GDALAttribute> CreateAttribute(
        const std::string& osName,
        const std::vector<GUInt64>& anDimensions,
        const GDALExtendedDataType& oDataType,
        CSLConstList papszOptions = nullptr) override;

    std::shared_ptr<GDALMDArray> CreateMDArray(const std::string& osName,
                                                       const std::vector<std::shared_ptr<GDALDimension>>& aoDimensions,
                                                       const GDALExtendedDataType& oDataType,
                                                       CSLConstList papszOptions) override;

    void SetIsRootGroup();

    const std::shared_ptr<Ref>& GetRef() const { return m_poRefSelf; }
    VRTGroup* GetRootGroup() const;

    const std::string& GetVRTPath() const { return m_osVRTPath; }
    void SetDirty();
    void SetFilename(const std::string& osFilename) { m_osFilename = osFilename; }
    const std::string& GetFilename() const { return m_osFilename; }
    void Serialize() const;
    CPLXMLNode* SerializeToXML( const char *pszVRTPathIn ) const;
    void Serialize(CPLXMLNode* psParent, const char *pszVRTPathIn) const;
};",1,334 2000 381 58 439 2001 123 439 58 462 2002 123 2000 42 2003 59 376 2002 40 2000 42 2004 41 58 2003 40 2004 41 123 125 2002 40 341 2002 38 41 61 353 59 2002 38 427 61 40 341 2002 38 41 61 353 59 125 59 437 58 2005 646 2006 60 2002 62 2007 123 125 59 2005 646 2008 60 2002 62 2009 123 125 59 2005 646 2006 60 2002 62 2010 123 125 59 2005 646 461 2011 123 125 59 415 323 2012 61 380 59 2005 646 461 2013 123 125 59 2005 646 2014 60 2005 646 461 44 2005 646 2006 60 2000 640 2015 123 125 59 2005 646 2014 60 2005 646 461 44 2005 646 2006 60 2016 640 2017 123 125 59 2005 646 2014 60 2005 646 461 44 2005 646 2006 60 2018 640 2019 123 125 59 2005 646 2014 60 2005 646 461 44 2005 646 2006 60 2020 640 2021 123 125 59 2005 646 2006 60 2000 62 2022 40 341 2005 646 461 38 2023 41 341 59 492 2024 40 341 2005 646 2008 60 2002 62 38 2025 41 59 2005 646 2008 60 2002 62 2026 40 41 341 59 439 58 2000 40 341 2005 646 461 38 2027 44 341 2005 646 461 38 2023 41 59 126 2000 40 41 59 323 2028 40 341 2005 646 2006 60 2000 62 38 2029 44 341 2005 646 2006 60 2000 62 38 2030 44 341 2031 42 2032 44 341 330 42 2033 41 59 2005 646 2034 60 2005 646 461 62 2035 40 2036 2037 41 341 431 59 2005 646 2006 60 2038 62 2039 40 341 2005 646 461 38 2023 44 2036 2037 61 425 41 341 431 59 2005 646 2034 60 2005 646 461 62 2040 40 2036 2037 41 341 431 59 2005 646 2006 60 2001 62 2041 40 341 2005 646 461 38 2023 44 2036 41 341 431 123 450 2022 40 2023 41 59 125 2005 646 2034 60 2005 646 2006 60 2042 640 2043 40 2036 41 341 431 59 2005 646 2034 60 2005 646 2006 60 2044 640 2045 40 2036 41 341 431 59 2005 646 2006 60 2020 62 2046 40 341 2005 646 461 38 2047 41 341 123 318 2048 61 2021 46 2049 40 2047 41 59 450 2048 614 2021 46 2050 40 41 63 425 58 2048 624 2051 59 125 2005 646 2006 60 2020 62 2052 40 341 2005 646 461 38 2047 44 323 2053 41 341 59 2005 646 2006 60 2001 62 2054 40 341 2005 646 461 38 2023 44 2036 2037 61 425 41 431 59 2005 646 2006 60 2042 62 2055 40 341 2005 646 461 38 2023 44 341 2005 646 461 38 2056 44 341 2005 646 461 38 2057 44 2058 2059 44 2036 2037 61 425 41 431 59 2005 646 2006 60 2044 62 2060 40 341 2005 646 461 38 2023 44 341 2005 646 2034 60 2058 62 38 2061 44 341 2062 38 2063 44 2036 2037 61 425 41 431 59 2005 646 2006 60 2038 62 2064 40 341 2005 646 461 38 2023 44 341 2005 646 2034 60 2005 646 2006 60 2042 640 38 2065 44 341 2062 38 2063 44 2036 2037 41 431 59 492 2066 40 41 59 341 2005 646 2006 60 2002 62 38 2067 40 41 341 123 450 2010 59 125 2000 42 2068 40 41 341 59 341 2005 646 461 38 2069 40 41 341 123 450 2013 59 125 492 2070 40 41 59 492 2071 40 341 2005 646 461 38 2072 41 123 2011 61 2072 59 125 341 2005 646 461 38 2073 40 41 341 123 450 2011 59 125 492 2074 40 41 341 59 2031 42 2075 40 341 330 42 2076 41 341 59 492 2074 40 2031 42 2077 44 341 330 42 2076 41 341 59 125 59 
98660,C++,"class CPL_DLL VRTRasterBand CPL_NON_FINAL: public GDALRasterBand
{
  protected:
    friend class VRTDataset;

    int            m_bIsMaskBand;

    int            m_bNoDataValueSet;
    // If set to true, will not report the existence of nodata.
    int            m_bHideNoDataValue;
    double         m_dfNoDataValue;

    std::unique_ptr<GDALColorTable> m_poColorTable{};

    GDALColorInterp m_eColorInterp;

    char           *m_pszUnitType;
    char           **m_papszCategoryNames;

    double         m_dfOffset;
    double         m_dfScale;

    CPLXMLNode    *m_psSavedHistograms;

    void           Initialize( int nXSize, int nYSize );

    std::vector<VRTOverviewInfo> m_aoOverviewInfos{};

    VRTRasterBand *m_poMaskBand;

    std::unique_ptr<GDALRasterAttributeTable> m_poRAT{};

    CPL_DISALLOW_COPY_ASSIGN(VRTRasterBand)

  public:

                    VRTRasterBand();
    virtual        ~VRTRasterBand();

    virtual CPLErr         XMLInit( CPLXMLNode *, const char *,
                                    std::map<CPLString, GDALDataset*>& );
    virtual CPLXMLNode *   SerializeToXML( const char *pszVRTPath );

    virtual CPLErr SetNoDataValue( double ) override;
    virtual double GetNoDataValue( int *pbSuccess = nullptr ) override;
    virtual CPLErr DeleteNoDataValue() override;

    virtual CPLErr SetColorTable( GDALColorTable * ) override;
    virtual GDALColorTable *GetColorTable() override;

    virtual GDALRasterAttributeTable *GetDefaultRAT() override;
    virtual CPLErr SetDefaultRAT( const GDALRasterAttributeTable * poRAT ) override;

    virtual CPLErr SetColorInterpretation( GDALColorInterp ) override;
    virtual GDALColorInterp GetColorInterpretation() override;

    virtual const char *GetUnitType() override;
    CPLErr SetUnitType( const char * ) override;

    virtual char **GetCategoryNames() override;
    virtual CPLErr SetCategoryNames( char ** ) override;

    virtual CPLErr SetMetadata( char **papszMD, const char *pszDomain = """" ) override;
    virtual CPLErr SetMetadataItem( const char *pszName, const char *pszValue,
                                    const char *pszDomain = """" ) override;

    virtual double GetOffset( int *pbSuccess = nullptr ) override;
    CPLErr SetOffset( double ) override;
    virtual double GetScale( int *pbSuccess = nullptr ) override;
    CPLErr SetScale( double ) override;

    virtual int GetOverviewCount() override;
    virtual GDALRasterBand *GetOverview(int) override;

    virtual CPLErr  GetHistogram( double dfMin, double dfMax,
                                  int nBuckets, GUIntBig * panHistogram,
                                  int bIncludeOutOfRange, int bApproxOK,
                                  GDALProgressFunc, void *pProgressData ) override;

    virtual CPLErr GetDefaultHistogram( double *pdfMin, double *pdfMax,
                                        int *pnBuckets, GUIntBig ** ppanHistogram,
                                        int bForce,
                                        GDALProgressFunc, void *pProgressData) override;

    virtual CPLErr SetDefaultHistogram( double dfMin, double dfMax,
                                        int nBuckets, GUIntBig *panHistogram ) override;

    CPLErr         CopyCommonInfoFrom( GDALRasterBand * );

    virtual void   GetFileList(char*** ppapszFileList, int *pnSize,
                               int *pnMaxSize, CPLHashSet* hSetFiles);

    virtual void   SetDescription( const char * ) override;

    virtual GDALRasterBand *GetMaskBand() override;
    virtual int             GetMaskFlags() override;

    virtual CPLErr          CreateMaskBand( int nFlagsIn ) override;

    void SetMaskBand(VRTRasterBand* poMaskBand);

    void SetIsMaskBand();

    CPLErr UnsetNoDataValue();

    virtual int         CloseDependentDatasets();

    virtual int         IsSourcedRasterBand() { return FALSE; }
    virtual int         IsPansharpenRasterBand() { return FALSE; }
};",1,334 2000 2001 2002 58 439 2003 123 438 58 387 334 2004 59 404 2005 59 404 2006 59 621 404 2007 59 356 2008 59 2009 646 2010 60 2011 62 2012 123 125 59 2013 2014 59 330 42 2015 59 330 42 42 2016 59 356 2017 59 356 2018 59 2019 42 2020 59 492 2021 40 404 2022 44 404 2023 41 59 2009 646 2024 60 2025 62 2026 123 125 59 2001 42 2027 59 2009 646 2010 60 2028 62 2029 123 125 59 2030 40 2001 41 439 58 2001 40 41 59 491 126 2001 40 41 59 491 2031 2032 40 2019 42 44 341 330 42 44 2009 646 2033 60 2034 44 2035 42 62 38 41 59 491 2019 42 2036 40 341 330 42 2037 41 59 491 2031 2038 40 356 41 431 59 491 356 2039 40 404 42 2040 61 425 41 431 59 491 2031 2041 40 41 431 59 491 2031 2042 40 2011 42 41 431 59 491 2011 42 2043 40 41 431 59 491 2028 42 2044 40 41 431 59 491 2031 2045 40 341 2028 42 2046 41 431 59 491 2031 2047 40 2013 41 431 59 491 2013 2048 40 41 431 59 491 341 330 42 2049 40 41 431 59 2031 2050 40 341 330 42 41 431 59 491 330 42 42 2051 40 41 431 59 491 2031 2052 40 330 42 42 41 431 59 491 2031 2053 40 330 42 42 2054 44 341 330 42 2055 61 648 41 431 59 491 2031 2056 40 341 330 42 2057 44 341 330 42 2058 44 341 330 42 2055 61 648 41 431 59 491 356 2059 40 404 42 2040 61 425 41 431 59 2031 2060 40 356 41 431 59 491 356 2061 40 404 42 2040 61 425 41 431 59 2031 2062 40 356 41 431 59 491 404 2063 40 41 431 59 491 2003 42 2064 40 404 41 431 59 491 2031 2065 40 356 2066 44 356 2067 44 404 2068 44 2069 42 2070 44 404 2071 44 404 2072 44 2073 44 492 42 2074 41 431 59 491 2031 2075 40 356 42 2076 44 356 42 2077 44 404 42 2078 44 2069 42 42 2079 44 404 2080 44 2073 44 492 42 2074 41 431 59 491 2031 2081 40 356 2066 44 356 2067 44 404 2068 44 2069 42 2070 41 431 59 2031 2082 40 2003 42 41 59 491 492 2083 40 330 42 42 42 2084 44 404 42 2085 44 404 42 2086 44 2087 42 2088 41 59 491 492 2089 40 341 330 42 41 431 59 491 2003 42 2090 40 41 431 59 491 404 2091 40 41 431 59 491 2031 2092 40 404 2093 41 431 59 492 2094 40 2001 42 2095 41 59 492 2096 40 41 59 2031 2097 40 41 59 491 404 2098 40 41 59 491 404 2099 40 41 123 450 2100 59 125 491 404 2101 40 41 123 450 2102 59 125 125 59 
98664,C++,"class CPL_DLL VRTSourcedRasterBand CPL_NON_FINAL: public VRTRasterBand
{
  private:
    CPLString      m_osLastLocationInfo{};
    char         **m_papszSourceList = nullptr;
    int            m_nSkipBufferInitialization = -1;

    bool           CanUseSourcesMinMaxImplementations();

    CPL_DISALLOW_COPY_ASSIGN(VRTSourcedRasterBand)

  protected:
    bool           SkipBufferInitialization();

  public:
    int            nSources = 0;
    VRTSource    **papoSources = nullptr;

                   VRTSourcedRasterBand( GDALDataset *poDS, int nBand );
                   VRTSourcedRasterBand( GDALDataType eType,
                                         int nXSize, int nYSize );
                   VRTSourcedRasterBand( GDALDataset *poDS, int nBand,
                                         GDALDataType eType,
                                         int nXSize, int nYSize );
                   VRTSourcedRasterBand( GDALDataset *poDS, int nBand,
                                         GDALDataType eType,
                                         int nXSize, int nYSize,
                                         int nBlockXSizeIn, int nBlockYSizeIn );
    virtual        ~VRTSourcedRasterBand();

    virtual CPLErr IRasterIO( GDALRWFlag, int, int, int, int,
                              void *, int, int, GDALDataType,
                              GSpacing nPixelSpace, GSpacing nLineSpace,
                              GDALRasterIOExtraArg* psExtraArg) override;

    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,
                                        int nXSize, int nYSize,
                                        int nMaskFlagStop,
                                        double* pdfDataPct) override;

    virtual char      **GetMetadataDomainList() override;
    virtual const char *GetMetadataItem( const char * pszName,
                                         const char * pszDomain = """" ) override;
    virtual char      **GetMetadata( const char * pszDomain = """" ) override;
    virtual CPLErr      SetMetadata( char ** papszMetadata,
                                     const char * pszDomain = """" ) override;
    virtual CPLErr      SetMetadataItem( const char * pszName,
                                         const char * pszValue,
                                         const char * pszDomain = """" ) override;

    virtual CPLErr         XMLInit( CPLXMLNode *, const char *,
                                    std::map<CPLString, GDALDataset*>& ) override;
    virtual CPLXMLNode *   SerializeToXML( const char *pszVRTPath ) override;

    virtual double GetMinimum( int *pbSuccess = nullptr ) override;
    virtual double GetMaximum(int *pbSuccess = nullptr ) override;
    virtual CPLErr ComputeRasterMinMax( int bApproxOK, double* adfMinMax ) override;
    virtual CPLErr ComputeStatistics( int bApproxOK,
                                      double *pdfMin, double *pdfMax,
                                      double *pdfMean, double *pdfStdDev,
                                      GDALProgressFunc pfnProgress,
                                      void *pProgressData ) override;
    virtual CPLErr  GetHistogram( double dfMin, double dfMax,
                                  int nBuckets, GUIntBig * panHistogram,
                                  int bIncludeOutOfRange, int bApproxOK,
                                  GDALProgressFunc pfnProgress,
                                  void *pProgressData ) override;

    CPLErr         AddSource( VRTSource * );

    CPLErr         AddSimpleSource( const char* pszFilename,
                                    int nBand,
                                    double dfSrcXOff=-1, double dfSrcYOff=-1,
                                    double dfSrcXSize=-1, double dfSrcYSize=-1,
                                    double dfDstXOff=-1, double dfDstYOff=-1,
                                    double dfDstXSize=-1, double dfDstYSize=-1,
                                    const char *pszResampling = ""near"",
                                    double dfNoDataValue = VRT_NODATA_UNSET);

    CPLErr         AddSimpleSource( GDALRasterBand *poSrcBand,
                                    double dfSrcXOff=-1, double dfSrcYOff=-1,
                                    double dfSrcXSize=-1, double dfSrcYSize=-1,
                                    double dfDstXOff=-1, double dfDstYOff=-1,
                                    double dfDstXSize=-1, double dfDstYSize=-1,
                                    const char *pszResampling = ""near"",
                                    double dfNoDataValue = VRT_NODATA_UNSET);

    CPLErr         AddComplexSource( const char* pszFilename,
                                     int nBand,
                                     double dfSrcXOff=-1, double dfSrcYOff=-1,
                                     double dfSrcXSize=-1, double dfSrcYSize=-1,
                                     double dfDstXOff=-1, double dfDstYOff=-1,
                                     double dfDstXSize=-1, double dfDstYSize=-1,
                                     double dfScaleOff=0.0,
                                     double dfScaleRatio=1.0,
                                     double dfNoDataValue = VRT_NODATA_UNSET,
                                     int nColorTableComponent = 0);

    CPLErr         AddComplexSource( GDALRasterBand *poSrcBand,
                                     double dfSrcXOff=-1, double dfSrcYOff=-1,
                                     double dfSrcXSize=-1, double dfSrcYSize=-1,
                                     double dfDstXOff=-1, double dfDstYOff=-1,
                                     double dfDstXSize=-1, double dfDstYSize=-1,
                                     double dfScaleOff=0.0,
                                     double dfScaleRatio=1.0,
                                     double dfNoDataValue = VRT_NODATA_UNSET,
                                     int nColorTableComponent = 0);

    CPLErr         AddMaskBandSource( GDALRasterBand *poSrcBand,
                                      double dfSrcXOff=-1, double dfSrcYOff=-1,
                                      double dfSrcXSize=-1,
                                      double dfSrcYSize=-1,
                                      double dfDstXOff=-1, double dfDstYOff=-1,
                                      double dfDstXSize=-1,
                                      double dfDstYSize=-1 );

    CPLErr         AddFuncSource( VRTImageReadFunc pfnReadFunc, void *hCBData,
                                  double dfNoDataValue = VRT_NODATA_UNSET );

    void           ConfigureSource(VRTSimpleSource *poSimpleSource,
                                   GDALRasterBand *poSrcBand,
                                   int bAddAsMaskBand,
                                   double dfSrcXOff, double dfSrcYOff,
                                   double dfSrcXSize, double dfSrcYSize,
                                   double dfDstXOff, double dfDstYOff,
                                   double dfDstXSize, double dfDstYSize );

    void RemoveCoveredSources(CSLConstList papszOptions = nullptr);

    virtual CPLErr IReadBlock( int, int, void * ) override;

    virtual void   GetFileList(char*** ppapszFileList, int *pnSize,
                               int *pnMaxSize, CPLHashSet* hSetFiles) override;

    virtual int         CloseDependentDatasets() override;

    virtual int         IsSourcedRasterBand() override { return TRUE; }

    virtual CPLErr      FlushCache(bool bAtClosing) override;
};",1,334 2000 2001 2002 58 439 2003 123 437 58 2004 2005 123 125 59 330 42 42 2006 61 425 59 404 2007 61 45 1501 59 323 2008 40 41 59 2009 40 2001 41 438 58 323 2010 40 41 59 439 58 404 2011 61 1500 59 2012 42 42 2013 61 425 59 2001 40 2014 42 2015 44 404 2016 41 59 2001 40 2017 2018 44 404 2019 44 404 2020 41 59 2001 40 2014 42 2015 44 404 2016 44 2017 2018 44 404 2019 44 404 2020 41 59 2001 40 2014 42 2015 44 404 2016 44 2017 2018 44 404 2019 44 404 2020 44 404 2021 44 404 2022 41 59 491 126 2001 40 41 59 491 2023 2024 40 2025 44 404 44 404 44 404 44 404 44 492 42 44 404 44 404 44 2017 44 2026 2027 44 2026 2028 44 2029 42 2030 41 431 59 491 404 2031 40 404 2032 44 404 2033 44 404 2019 44 404 2020 44 404 2034 44 356 42 2035 41 431 59 491 330 42 42 2036 40 41 431 59 491 341 330 42 2037 40 341 330 42 2038 44 341 330 42 2039 61 648 41 431 59 491 330 42 42 2040 40 341 330 42 2039 61 648 41 431 59 491 2023 2041 40 330 42 42 2042 44 341 330 42 2039 61 648 41 431 59 491 2023 2043 40 341 330 42 2038 44 341 330 42 2044 44 341 330 42 2039 61 648 41 431 59 491 2023 2045 40 2046 42 44 341 330 42 44 2047 646 2048 60 2004 44 2014 42 62 38 41 431 59 491 2046 42 2049 40 341 330 42 2050 41 431 59 491 356 2051 40 404 42 2052 61 425 41 431 59 491 356 2053 40 404 42 2052 61 425 41 431 59 491 2023 2054 40 404 2055 44 356 42 2056 41 431 59 491 2023 2057 40 404 2055 44 356 42 2058 44 356 42 2059 44 356 42 2060 44 356 42 2061 44 2062 2063 44 492 42 2064 41 431 59 491 2023 2065 40 356 2066 44 356 2067 44 404 2068 44 2069 42 2070 44 404 2071 44 404 2055 44 2062 2063 44 492 42 2064 41 431 59 2023 2072 40 2012 42 41 59 2023 2073 40 341 330 42 2074 44 404 2016 44 356 2075 61 45 1501 44 356 2076 61 45 1501 44 356 2077 61 45 1501 44 356 2078 61 45 1501 44 356 2079 61 45 1501 44 356 2080 61 45 1501 44 356 2081 61 45 1501 44 356 2082 61 45 1501 44 341 330 42 2083 61 648 44 356 2084 61 2085 41 59 2023 2073 40 2086 42 2087 44 356 2075 61 45 1501 44 356 2076 61 45 1501 44 356 2077 61 45 1501 44 356 2078 61 45 1501 44 356 2079 61 45 1501 44 356 2080 61 45 1501 44 356 2081 61 45 1501 44 356 2082 61 45 1501 44 341 330 42 2083 61 648 44 356 2084 61 2085 41 59 2023 2088 40 341 330 42 2074 44 404 2016 44 356 2075 61 45 1501 44 356 2076 61 45 1501 44 356 2077 61 45 1501 44 356 2078 61 45 1501 44 356 2079 61 45 1501 44 356 2080 61 45 1501 44 356 2081 61 45 1501 44 356 2082 61 45 1501 44 356 2089 61 1500 44 356 2090 61 1501 44 356 2084 61 2085 44 404 2091 61 1500 41 59 2023 2088 40 2086 42 2087 44 356 2075 61 45 1501 44 356 2076 61 45 1501 44 356 2077 61 45 1501 44 356 2078 61 45 1501 44 356 2079 61 45 1501 44 356 2080 61 45 1501 44 356 2081 61 45 1501 44 356 2082 61 45 1501 44 356 2089 61 1500 44 356 2090 61 1501 44 356 2084 61 2085 44 404 2091 61 1500 41 59 2023 2092 40 2086 42 2087 44 356 2075 61 45 1501 44 356 2076 61 45 1501 44 356 2077 61 45 1501 44 356 2078 61 45 1501 44 356 2079 61 45 1501 44 356 2080 61 45 1501 44 356 2081 61 45 1501 44 356 2082 61 45 1501 41 59 2023 2093 40 2094 2095 44 492 42 2096 44 356 2084 61 2085 41 59 492 2097 40 2098 42 2099 44 2086 42 2087 44 404 2100 44 356 2075 44 356 2076 44 356 2077 44 356 2078 44 356 2079 44 356 2080 44 356 2081 44 356 2082 41 59 492 2101 40 2102 2103 61 425 41 59 491 2023 2104 40 404 44 404 44 492 42 41 431 59 491 492 2105 40 330 42 42 42 2106 44 404 42 2107 44 404 42 2108 44 2109 42 2110 41 431 59 491 404 2111 40 41 431 59 491 404 2112 40 41 431 123 450 2113 59 125 491 2023 2114 40 323 2115 41 431 59 125 59 
98914,C++,"class OGRCSVLayer final: public OGRLayer
{
  public:

    enum class StringQuoting
    {
        IF_NEEDED,
        IF_AMBIGUOUS,
        ALWAYS
    };

  private:
    OGRFeatureDefn     *poFeatureDefn;
    std::set<CPLString> m_oSetFields;

    VSILFILE           *fpCSV;

    int                 nNextFID;

    bool                bHasFieldNames;

    OGRFeature         *GetNextUnfilteredFeature();

    bool                bNew;
    bool                bInWriteMode;
    bool                bUseCRLF;
    bool                bNeedRewindBeforeRead;
    OGRCSVGeometryFormat eGeometryFormat;

    char               *pszFilename;
    bool                bCreateCSVT;
    bool                bWriteBOM;
    char                szDelimiter[2] = {0};

    int                 nCSVFieldCount;
    int                *panGeomFieldIndex;
    bool                bFirstFeatureAppendedDuringSession;
    bool                bHiddenWKTColumn;

    // http://www.faa.gov/airports/airport_safety/airportdata_5010/menu/index.cfm
    // specific
    int                 iNfdcLongitudeS;
    int                 iNfdcLatitudeS;
    bool                bHonourStrings;

    int                 iLongitudeField;
    int                 iLatitudeField;
    int                 iZField;
    CPLString           osXField;
    CPLString           osYField;
    CPLString           osZField;

    bool                bIsEurostatTSV;
    int                 nEurostatDims;

    GIntBig             nTotalFeatures;

    char              **AutodetectFieldTypes(char **papszOpenOptions,
                                             int nFieldCount);

    bool                bWarningBadTypeOrWidth;
    bool                bKeepSourceColumns;
    bool                bKeepGeomColumns;

    bool                bMergeDelimiter;

    bool                bEmptyStringNull;

    StringQuoting       m_eStringQuoting = StringQuoting::IF_AMBIGUOUS;

    char              **GetNextLineTokens();

    static bool         Matches( const char *pszFieldName,
                                 char **papszPossibleNames );

  public:

    OGRCSVLayer( const char *pszName, VSILFILE *fp, const char *pszFilename,
                 int bNew, int bInWriteMode, char chDelimiter );
    virtual ~OGRCSVLayer() GDAL_OVERRIDE;

    const char         *GetFilename() const { return pszFilename; }
    char                GetDelimiter() const { return szDelimiter[0]; }
    bool                GetCRLF() const { return bUseCRLF; }
    bool                GetCreateCSVT() const { return bCreateCSVT; }
    bool                GetWriteBOM() const { return bWriteBOM; }
    OGRCSVGeometryFormat GetGeometryFormat() const { return eGeometryFormat; }
    bool                HasHiddenWKTColumn() const { return bHiddenWKTColumn; }
    GIntBig             GetTotalFeatureCount() const { return nTotalFeatures; }
    const CPLString    &GetXField() const { return osXField; }
    const CPLString    &GetYField() const { return osYField; }
    const CPLString    &GetZField() const { return osZField; }

    void                BuildFeatureDefn(
                            const char *pszNfdcGeomField = nullptr,
                            const char *pszGeonamesGeomFieldPrefix = nullptr,
                            char **papszOpenOptions = nullptr );

    void                ResetReading() override;
    OGRFeature         *GetNextFeature() override;
    virtual OGRFeature *GetFeature( GIntBig nFID ) override;

    OGRFeatureDefn     *GetLayerDefn() override { return poFeatureDefn; }

    int                 TestCapability( const char * ) override;

    virtual OGRErr      CreateField( OGRFieldDefn *poField,
                                     int bApproxOK = TRUE ) override;

    static
    OGRCSVCreateFieldAction PreCreateField( OGRFeatureDefn *poFeatureDefn,
                                            const std::set<CPLString>& oSetFields,
                                            OGRFieldDefn *poNewField,
                                            int bApproxOK );
    virtual OGRErr      CreateGeomField( OGRGeomFieldDefn *poGeomField,
                                         int bApproxOK = TRUE ) override;

    virtual OGRErr      ICreateFeature( OGRFeature *poFeature ) override;

    void                SetCRLF( bool bNewValue );
    void                SetWriteGeometry(OGRwkbGeometryType eGType,
                                         OGRCSVGeometryFormat eGeometryFormat,
                                         const char *pszGeomCol = nullptr);
    void                SetCreateCSVT( bool bCreateCSVT );
    void                SetWriteBOM( bool bWriteBOM );

    void                SetStringQuoting( StringQuoting eVal ) { m_eStringQuoting = eVal; }
    StringQuoting       GetStringQuoting() const { return m_eStringQuoting; }

    virtual GIntBig     GetFeatureCount( int bForce = TRUE ) override;
    virtual OGRErr      SyncToDisk() override;

    OGRErr              WriteHeader();
};",1,334 2000 381 58 439 2001 123 439 58 370 334 2002 123 2003 44 2004 44 2005 125 59 437 58 2006 42 2007 59 2008 646 2009 60 2010 62 2011 59 2012 42 2013 59 404 2014 59 323 2015 59 2016 42 2017 40 41 59 323 2018 59 323 2019 59 323 2020 59 323 2021 59 2022 2023 59 330 42 2024 59 323 2025 59 323 2026 59 330 2027 91 1502 93 61 123 1500 125 59 404 2028 59 404 42 2029 59 323 2030 59 323 2031 59 621 621 404 2032 59 404 2033 59 323 2034 59 404 2035 59 404 2036 59 404 2037 59 2010 2038 59 2010 2039 59 2010 2040 59 323 2041 59 404 2042 59 2043 2044 59 330 42 42 2045 40 330 42 42 2046 44 404 2047 41 59 323 2048 59 323 2049 59 323 2050 59 323 2051 59 323 2052 59 2002 2053 61 2002 646 2054 59 330 42 42 2055 40 41 59 457 323 2056 40 341 330 42 2057 44 330 42 42 2058 41 59 439 58 2000 40 341 330 42 2059 44 2012 42 2060 44 341 330 42 2024 44 404 2018 44 404 2019 44 330 2061 41 59 491 126 2000 40 41 2062 59 341 330 42 2063 40 41 341 123 450 2024 59 125 330 2064 40 41 341 123 450 2027 91 1500 93 59 125 323 2065 40 41 341 123 450 2020 59 125 323 2066 40 41 341 123 450 2025 59 125 323 2067 40 41 341 123 450 2026 59 125 2022 2068 40 41 341 123 450 2023 59 125 323 2069 40 41 341 123 450 2031 59 125 2043 2070 40 41 341 123 450 2044 59 125 341 2010 38 2071 40 41 341 123 450 2038 59 125 341 2010 38 2072 40 41 341 123 450 2039 59 125 341 2010 38 2073 40 41 341 123 450 2040 59 125 492 2074 40 341 330 42 2075 61 425 44 341 330 42 2076 61 425 44 330 42 42 2046 61 425 41 59 492 2077 40 41 431 59 2016 42 2078 40 41 431 59 491 2016 42 2079 40 2043 2080 41 431 59 2006 42 2081 40 41 431 123 450 2007 59 125 404 2082 40 341 330 42 41 431 59 491 2083 2084 40 2085 42 2086 44 404 2087 61 2088 41 431 59 457 2089 2090 40 2006 42 2007 44 341 2008 646 2009 60 2010 62 38 2091 44 2085 42 2092 44 404 2087 41 59 491 2083 2093 40 2094 42 2095 44 404 2087 61 2088 41 431 59 491 2083 2096 40 2016 42 2097 41 431 59 492 2098 40 323 2099 41 59 492 2100 40 2101 2102 44 2022 2023 44 341 330 42 2103 61 425 41 59 492 2104 40 323 2025 41 59 492 2105 40 323 2026 41 59 492 2106 40 2002 2107 41 123 2053 61 2107 59 125 2002 2108 40 41 341 123 450 2053 59 125 491 2043 2109 40 404 2110 61 2088 41 431 59 491 2083 2111 40 41 431 59 2083 2112 40 41 59 125 59 
99894,C++,"class HDF5ImageDataset final: public HDF5Dataset
{
    typedef enum { UNKNOWN_PRODUCT = 0, CSK_PRODUCT } Hdf5ProductType;

    typedef enum
    {
        PROD_UNKNOWN = 0,
        PROD_CSK_L0,
        PROD_CSK_L1A,
        PROD_CSK_L1B,
        PROD_CSK_L1C,
        PROD_CSK_L1D
    } HDF5CSKProductEnum;

    friend class HDF5ImageRasterBand;

    char        *pszProjection;
    char        *pszGCPProjection;
    GDAL_GCP    *pasGCPList;
    int         nGCPCount;
    OGRSpatialReference oSRS;

    hsize_t      *dims;
    hsize_t      *maxdims;
    HDF5GroupObjects *poH5Objects;
    int          ndims;
    int          dimensions;
    hid_t        dataset_id;
    hid_t        dataspace_id;
    hsize_t      size;
    hid_t        datatype;
    hid_t        native;
    Hdf5ProductType    iSubdatasetType;
    HDF5CSKProductEnum iCSKProductType;
    double       adfGeoTransform[6];
    bool         bHasGeoTransform;

    CPLErr CreateODIMH5Projection();

public:
    HDF5ImageDataset();
    virtual ~HDF5ImageDataset();

    CPLErr CreateProjections();
    static GDALDataset  *Open( GDALOpenInfo * );
    static int           Identify( GDALOpenInfo * );

    const char          *_GetProjectionRef() override;
    const OGRSpatialReference* GetSpatialRef() const override {
        return GetSpatialRefFromOldGetProjectionRef();
    }
    virtual int         GetGCPCount() override;
    virtual const char  *_GetGCPProjection() override;
        const OGRSpatialReference* GetGCPSpatialRef() const override {
        return GetGCPSpatialRefFromOldGetGCPProjection();
    }
    virtual const GDAL_GCP *GetGCPs() override;
    virtual CPLErr GetGeoTransform( double *padfTransform ) override;

    Hdf5ProductType GetSubdatasetType() const { return iSubdatasetType; }
    HDF5CSKProductEnum GetCSKProductType() const { return iCSKProductType; }

    int     IsComplexCSKL1A() const
    {
        return GetSubdatasetType() == CSK_PRODUCT &&
               GetCSKProductType() == PROD_CSK_L1A &&
               ndims == 3;
    }
    int GetYIndex() const { return IsComplexCSKL1A() ? 0 : ndims - 2; }
    int GetXIndex() const { return IsComplexCSKL1A() ? 1 : ndims - 1; }

    /**
     * Identify if the subdataset has a known product format
     * It stores a product identifier in iSubdatasetType,
     * UNKNOWN_PRODUCT, if it isn't a recognizable format.
     */
    void IdentifyProductType();

    /**
     * Captures Geolocation information from a COSMO-SKYMED
     * file.
     * The geoid will always be WGS84
     * The projection type may be UTM or UPS, depending on the
     * latitude from the center of the image.
     * @param iProductType type of HDF5 subproduct, see HDF5CSKProduct
     */
    void CaptureCSKGeolocation(int iProductType);

    /**
    * Get Geotransform information for COSMO-SKYMED files
    * In case of success it stores the transformation
    * in adfGeoTransform. In case of failure it doesn't
    * modify adfGeoTransform
    * @param iProductType type of HDF5 subproduct, see HDF5CSKProduct
    */
    void CaptureCSKGeoTransform(int iProductType);

    /**
     * @param iProductType type of HDF5 subproduct, see HDF5CSKProduct
     */
    void CaptureCSKGCPs(int iProductType);
};",1,334 2000 381 58 439 2001 123 475 370 123 2002 61 1500 44 2003 125 2004 59 475 370 123 2005 61 1500 44 2006 44 2007 44 2008 44 2009 44 2010 125 2011 59 387 334 2012 59 330 42 2013 59 330 42 2014 59 2015 42 2016 59 404 2017 59 2018 2019 59 2020 42 2021 59 2020 42 2022 59 2023 42 2024 59 404 2025 59 404 2026 59 2027 2028 59 2027 2029 59 2020 2030 59 2027 2031 59 2027 417 59 2004 2032 59 2011 2033 59 356 2034 91 1502 93 59 323 2035 59 2036 2037 40 41 59 439 58 2000 40 41 59 491 126 2000 40 41 59 2036 2038 40 41 59 457 2039 42 2040 40 2041 42 41 59 457 404 2042 40 2041 42 41 59 341 330 42 2043 40 41 431 59 341 2018 42 2044 40 41 341 431 123 450 2045 40 41 59 125 491 404 2046 40 41 431 59 491 341 330 42 2047 40 41 431 59 341 2018 42 2048 40 41 341 431 123 450 2049 40 41 59 125 491 341 2015 42 2050 40 41 431 59 491 2036 2051 40 356 42 2052 41 431 59 2004 2053 40 41 341 123 450 2032 59 125 2011 2054 40 41 341 123 450 2033 59 125 404 2055 40 41 341 123 450 2053 40 41 614 2056 605 2054 40 41 614 2057 605 2025 614 1502 59 125 404 2058 40 41 341 123 450 2055 40 41 63 1500 58 2025 45 1502 59 125 404 2059 40 41 341 123 450 2055 40 41 63 1501 58 2025 45 1501 59 125 618 492 2060 40 41 59 618 492 2061 40 404 2062 41 59 618 492 2063 40 404 2062 41 59 618 492 2064 40 404 2062 41 59 125 59 
101947,C++,"class BrowserSettings
{
public:
    explicit BrowserSettings() = default;
    static BrowserSettings* instance();

    bool isEnabled();
    void setEnabled(bool enabled);

    bool showNotification(); // TODO!!
    void setShowNotification(bool showNotification);
    bool bestMatchOnly();
    void setBestMatchOnly(bool bestMatchOnly);
    bool unlockDatabase();
    void setUnlockDatabase(bool unlockDatabase);
    bool matchUrlScheme();
    void setMatchUrlScheme(bool matchUrlScheme);
    bool alwaysAllowAccess();
    void setAlwaysAllowAccess(bool alwaysAllowAccess);
    bool alwaysAllowUpdate();
    void setAlwaysAllowUpdate(bool alwaysAllowUpdate);
    bool searchInAllDatabases();
    void setSearchInAllDatabases(bool searchInAllDatabases);
    bool httpAuthPermission();
    void setHttpAuthPermission(bool httpAuthPermission);
    bool supportKphFields();
    void setSupportKphFields(bool supportKphFields);
    bool noMigrationPrompt();
    void setNoMigrationPrompt(bool prompt);

    bool useCustomProxy();
    void setUseCustomProxy(bool enabled);
    QString customProxyLocation();
    void setCustomProxyLocation(const QString& location);
    QString proxyLocation();
#ifdef QT_DEBUG
    QString customExtensionId();
    void setCustomExtensionId(const QString& id);
#endif
    bool updateBinaryPath();
    void setUpdateBinaryPath(bool enabled);
    bool allowExpiredCredentials();
    void setAllowExpiredCredentials(bool enabled);

    bool browserSupport(BrowserShared::SupportedBrowsers browser);
    void setBrowserSupport(BrowserShared::SupportedBrowsers browser, bool enabled);
    bool customBrowserSupport();
    void setCustomBrowserSupport(bool enabled);
    int customBrowserType();
    void setCustomBrowserType(int type);
    QString customBrowserLocation();
    void setCustomBrowserLocation(const QString& location);
    void updateBinaryPaths();
    QString replaceHomePath(QString location);
    QString replaceTildeHomePath(QString location);

private:
    static BrowserSettings* m_instance;

    NativeMessageInstaller m_nativeMessageInstaller;
};",1,334 2000 123 439 58 376 2000 40 41 61 349 59 457 2000 42 2001 40 41 59 323 2002 40 41 59 492 2003 40 323 2004 41 59 323 2005 40 41 59 621 492 2006 40 323 2005 41 59 323 2007 40 41 59 492 2008 40 323 2007 41 59 323 2009 40 41 59 492 2010 40 323 2009 41 59 323 2011 40 41 59 492 2012 40 323 2011 41 59 323 2013 40 41 59 492 2014 40 323 2013 41 59 323 2015 40 41 59 492 2016 40 323 2015 41 59 323 2017 40 41 59 492 2018 40 323 2017 41 59 323 2019 40 41 59 492 2020 40 323 2019 41 59 323 2021 40 41 59 492 2022 40 323 2021 41 59 323 2023 40 41 59 492 2024 40 323 2025 41 59 323 2026 40 41 59 492 2027 40 323 2004 41 59 2028 2029 40 41 59 492 2030 40 341 2028 38 2031 41 59 2028 2032 40 41 59 35 393 2033 2028 2034 40 41 59 492 2035 40 341 2028 38 2036 41 59 35 366 323 2037 40 41 59 492 2038 40 323 2004 41 59 323 2039 40 41 59 492 2040 40 323 2004 41 59 323 2041 40 2042 646 2043 2044 41 59 492 2045 40 2042 646 2043 2044 44 323 2004 41 59 323 2046 40 41 59 492 2047 40 323 2004 41 59 404 2048 40 41 59 492 2049 40 404 2050 41 59 2028 2051 40 41 59 492 2052 40 341 2028 38 2031 41 59 492 2053 40 41 59 2028 2054 40 2028 2031 41 59 2028 2055 40 2028 2031 41 59 437 58 457 2000 42 2056 59 2057 2058 59 125 59 
117562,C++,"class Mavlink final : public ModuleParams
{

public:
	/**
	 * Constructor
	 */
	Mavlink();

	/**
	 * Destructor, also kills the mavlinks task.
	 */
	~Mavlink();

	/**
	* Start the mavlink task.
	 *
	 * @return OK on success.
	 */
	static int		start(int argc, char *argv[]);

	bool running() const { return _task_running.load(); }
	bool should_exit() const { return _task_should_exit.load(); }
	void request_stop()
	{
		_task_should_exit.store(true);
		_receiver.request_stop();
	}

	/**
	 * Display the mavlink status.
	 */
	void			display_status();

	/**
	 * Display the status of all enabled streams.
	 */
	void			display_status_streams();

	static int		stop_command(int argc, char *argv[]);
	static int		stream_command(int argc, char *argv[]);

	static int		instance_count();

	static Mavlink		*new_instance();

	static Mavlink 		*get_instance_for_device(const char *device_name);

	mavlink_message_t 	*get_buffer() { return &_mavlink_buffer; }

	mavlink_status_t 	*get_status() { return &_mavlink_status; }

	/**
	 * Set the MAVLink version
	 *
	 * Currently supporting v1 and v2
	 *
	 * @param version MAVLink version
	 */
	void			set_proto_version(unsigned version);

	static int		destroy_all_instances();

	static int		get_status_all_instances(bool show_streams_status);

	static bool		serial_instance_exists(const char *device_name, Mavlink *self);

	static bool		component_was_seen(int system_id, int component_id, Mavlink *self = nullptr);

	static void		forward_message(const mavlink_message_t *msg, Mavlink *self);

	bool			check_events() const { return _should_check_events.load(); }
	void			check_events_enable() { _should_check_events.store(true); }
	void			check_events_disable() { _should_check_events.store(false); }

	int			get_uart_fd() const { return _uart_fd; }

	/**
	 * Get the MAVLink system id.
	 *
	 * @return The system ID of this vehicle
	 */
	int			get_system_id() const { return mavlink_system.sysid; }

	/**
	 * Get the MAVLink component id.
	 *
	 * @return The component ID of this vehicle
	 */
	int			get_component_id() const { return mavlink_system.compid; }

	const char *_device_name{DEFAULT_DEVICE_NAME};

	enum MAVLINK_MODE {
		MAVLINK_MODE_NORMAL = 0,
		MAVLINK_MODE_CUSTOM,
		MAVLINK_MODE_ONBOARD,
		MAVLINK_MODE_OSD,
		MAVLINK_MODE_MAGIC,
		MAVLINK_MODE_CONFIG,
		MAVLINK_MODE_IRIDIUM,
		MAVLINK_MODE_MINIMAL,
		MAVLINK_MODE_EXTVISION,
		MAVLINK_MODE_EXTVISIONMIN,
		MAVLINK_MODE_GIMBAL,
		MAVLINK_MODE_ONBOARD_LOW_BANDWIDTH,
		MAVLINK_MODE_COUNT
	};

	enum BROADCAST_MODE {
		BROADCAST_MODE_OFF = 0,
		BROADCAST_MODE_ON,
		BROADCAST_MODE_MULTICAST
	};

	enum FLOW_CONTROL_MODE {
		FLOW_CONTROL_OFF = 0,
		FLOW_CONTROL_AUTO,
		FLOW_CONTROL_ON
	};

	static const char *mavlink_mode_str(enum MAVLINK_MODE mode)
	{
		switch (mode) {
		case MAVLINK_MODE_NORMAL:
			return ""Normal"";

		case MAVLINK_MODE_CUSTOM:
			return ""Custom"";

		case MAVLINK_MODE_ONBOARD:
			return ""Onboard"";

		case MAVLINK_MODE_OSD:
			return ""OSD"";

		case MAVLINK_MODE_MAGIC:
			return ""Magic"";

		case MAVLINK_MODE_CONFIG:
			return ""Config"";

		case MAVLINK_MODE_IRIDIUM:
			return ""Iridium"";

		case MAVLINK_MODE_MINIMAL:
			return ""Minimal"";

		case MAVLINK_MODE_EXTVISION:
			return ""ExtVision"";

		case MAVLINK_MODE_EXTVISIONMIN:
			return ""ExtVisionMin"";

		case MAVLINK_MODE_GIMBAL:
			return ""Gimbal"";

		case MAVLINK_MODE_ONBOARD_LOW_BANDWIDTH:
			return ""OnboardLowBandwidth"";

		default:
			return ""Unknown"";
		}
	}

	enum MAVLINK_MODE	get_mode() { return _mode; }

	bool			get_hil_enabled() { return _hil_enabled; }

	bool			get_use_hil_gps() { return _param_mav_usehilgps.get(); }

	bool			get_forward_externalsp() { return _param_mav_fwdextsp.get(); }

	bool			get_flow_control_enabled() { return _flow_control_mode; }

	bool			get_forwarding_on() { return _forwarding_on; }

	bool			is_connected() { return _tstatus.heartbeat_type_gcs; }

#if defined(MAVLINK_UDP)
	static Mavlink 		*get_instance_for_network_port(unsigned long port);

	bool			broadcast_enabled() { return _mav_broadcast == BROADCAST_MODE_ON; }

	bool			multicast_enabled() { return _mav_broadcast == BROADCAST_MODE_MULTICAST; }
#endif // MAVLINK_UDP

	/**
	 * Set the boot complete flag on all instances
	 *
	 * Setting the flag unblocks parameter transmissions, which are gated
	 * beforehand to ensure that the system is fully initialized.
	 */
	static void		set_boot_complete();

	/**
	 * Get the free space in the transmit buffer
	 *
	 * @return free space in the UART TX buffer
	 */
	unsigned		get_free_tx_buf();

	static int		start_helper(int argc, char *argv[]);

	/**
	 * Enable / disable Hardware in the Loop simulation mode.
	 *
	 * @param hil_enabled	The new HIL enable/disable state.
	 * @return		OK if the HIL state changed, ERROR if the
	 *			requested change could not be made or was
	 *			redundant.
	 */
	int			set_hil_enabled(bool hil_enabled);

	/**
	 * Set communication protocol for this mavlink instance
	 */
	void 			set_protocol(Protocol p) { _protocol = p; }

	/**
	 * This is the beginning of a MAVLINK_START_UART_SEND/MAVLINK_END_UART_SEND transaction
	 */
	void 			send_start(int length);

	/**
	 * Buffer bytes to send out on the link.
	 */
	void			send_bytes(const uint8_t *buf, unsigned packet_len);

	/**
	 * Flush the transmit buffer and send one MAVLink packet
	 */
	void             	send_finish();

	/**
	 * Resend message as is, don't change sequence number and CRC.
	 */
	void			resend_message(mavlink_message_t *msg) { _mavlink_resend_uart(_channel, msg); }

	void			handle_message(const mavlink_message_t *msg);

	int			get_instance_id() const { return _instance_id; }

	/**
	 * Enable / disable hardware flow control.
	 *
	 * @param enabled	True if hardware flow control should be enabled
	 */
	int			setup_flow_control(enum FLOW_CONTROL_MODE enabled);

	mavlink_channel_t	get_channel() const { return _channel; }

	void			configure_stream_threadsafe(const char *stream_name, float rate = -1.0f);

	orb_advert_t		*get_mavlink_log_pub() { return &_mavlink_log_pub; }

	/**
	 * Send a status text with loglevel INFO
	 *
	 * @param string the message to send (will be capped by mavlink max string length)
	 */
	void			send_statustext_info(const char *string);

	/**
	 * Send a status text with loglevel CRITICAL
	 *
	 * @param string the message to send (will be capped by mavlink max string length)
	 */
	void			send_statustext_critical(const char *string);

	/**
	 * Send a status text with loglevel EMERGENCY
	 *
	 * @param string the message to send (will be capped by mavlink max string length)
	 */
	void			send_statustext_emergency(const char *string);

	/**
	 * Send a status text with loglevel, the difference from mavlink_log_xxx() is that message sent
	 * only on this mavlink connection. Useful for reporting communication specific, not system-wide info
	 * only to client interested in it. Message will be not sent immediately but queued in buffer as
	 * for mavlink_log_xxx().
	 *
	 * @param string the message to send (will be capped by mavlink max string length)
	 * @param severity the log level
	 */
	void			send_statustext(unsigned char severity, const char *string);

	/**
	 * Send the capabilities of this autopilot in terms of the MAVLink spec
	 */
	bool 			send_autopilot_capabilities();

	/**
	 * Send the protocol version of MAVLink
	 */
	void			send_protocol_version();

	List<MavlinkStream *> &get_streams() { return _streams; }

	float			get_rate_mult() const { return _rate_mult; }

	float			get_baudrate() { return _baudrate; }

	/* Functions for waiting to start transmission until message received. */
	void			set_has_received_messages(bool received_messages) { _received_messages = received_messages; }
	bool			get_has_received_messages() { return _received_messages; }
	void			set_wait_to_transmit(bool wait) { _wait_to_transmit = wait; }
	bool			get_wait_to_transmit() { return _wait_to_transmit; }
	bool			should_transmit() { return (_transmitting_enabled && (!_wait_to_transmit || (_wait_to_transmit && _received_messages))); }

	bool			message_buffer_write(const void *ptr, int size);

	void			lockMessageBufferMutex(void) { pthread_mutex_lock(&_message_buffer_mutex); }
	void			unlockMessageBufferMutex(void) { pthread_mutex_unlock(&_message_buffer_mutex); }

	/**
	 * Count transmitted bytes
	 */
	void			count_txbytes(unsigned n) { _bytes_tx += n; };

	/**
	 * Count bytes not transmitted because of errors
	 */
	void			count_txerrbytes(unsigned n) { _bytes_txerr += n; };

	/**
	 * Count received bytes
	 */
	void			count_rxbytes(unsigned n) { _bytes_rx += n; };

	/**
	 * Get the receive status of this MAVLink link
	 */
	telemetry_status_s	&telemetry_status() { return _tstatus; }
	void                    telemetry_status_updated() { _tstatus_updated = true; }

	void			set_telemetry_status_type(uint8_t type) { _tstatus.type = type; }

	void			update_radio_status(const radio_status_s &radio_status);

	unsigned		get_system_type() { return _param_mav_type.get(); }

	Protocol 		get_protocol() const { return _protocol; }

	int 			get_socket_fd() { return _socket_fd; };

#if defined(MAVLINK_UDP)
	unsigned short		get_network_port() { return _network_port; }

	unsigned short		get_remote_port() { return _remote_port; }

	const in_addr		query_netmask_addr(const int socket_fd, const ifreq &ifreq);

	const in_addr		compute_broadcast_addr(const in_addr &host_addr, const in_addr &netmask_addr);

	struct sockaddr_in 	&get_client_source_address() { return _src_addr; }

	void			set_client_source_initialized() { _src_addr_initialized = true; }

	bool			get_client_source_initialized() { return _src_addr_initialized; }
#endif

	uint64_t		get_start_time() { return _mavlink_start_time; }

	static bool		boot_complete() { return _boot_complete; }

	bool			is_usb_uart() { return _is_usb_uart; }

	int			get_data_rate()		{ return _datarate; }
	void			set_data_rate(int rate) { if (rate > 0) { _datarate = rate; } }

	unsigned		get_main_loop_delay() const { return _main_loop_delay; }

	/** get the Mavlink shell. Create a new one if there isn't one. It is *always* created via MavlinkReceiver thread.
	 *  Returns nullptr if shell cannot be created */
	MavlinkShell		*get_shell();
	/** close the Mavlink shell if it is open */
	void			close_shell();

	/** get ulog streaming if active, nullptr otherwise */
	MavlinkULog		*get_ulog_streaming() { return _mavlink_ulog; }
	void			try_start_ulog_streaming(uint8_t target_system, uint8_t target_component)
	{
		if (_mavlink_ulog) { return; }

		_mavlink_ulog = MavlinkULog::try_start(_datarate, 0.7f, target_system, target_component);
	}

	const events::SendProtocol &get_events_protocol() const { return _events; };
	bool ftp_enabled() const { return _ftp_on; }

	bool hash_check_enabled() const { return _param_mav_hash_chk_en.get(); }
	bool forward_heartbeats_enabled() const { return _param_mav_hb_forw_en.get(); }
	bool odometry_loopback_enabled() const { return _param_mav_odom_lp.get(); }

	bool failure_injection_enabled() const { return _param_sys_failure_injection_enabled.get(); }

	struct ping_statistics_s {
		uint64_t last_ping_time;
		uint32_t last_ping_seq;
		uint32_t dropped_packets;
		float last_rtt;
		float mean_rtt;
		float max_rtt;
		float min_rtt;
	};

	/**
	 * Get the ping statistics of this MAVLink link
	 */
	struct ping_statistics_s &get_ping_statistics() { return _ping_stats; }

	static hrt_abstime &get_first_start_time() { return _first_start_time; }

	bool radio_status_critical() const { return _radio_status_critical; }

private:
	MavlinkReceiver 	_receiver;

	int			_instance_id{-1};
	int			_task_id{-1};

	px4::atomic_bool	_task_should_exit{false};
	px4::atomic_bool	_task_running{false};

	bool			_transmitting_enabled{true};
	bool			_transmitting_enabled_commanded{false};
	bool			_first_heartbeat_sent{false};

	orb_advert_t		_mavlink_log_pub{nullptr};

	uORB::Publication<vehicle_command_ack_s> _vehicle_command_ack_pub{ORB_ID(vehicle_command_ack)};
	uORB::PublicationMulti<telemetry_status_s> _telemetry_status_pub{ORB_ID(telemetry_status)};

	uORB::Subscription _event_sub{ORB_ID(event)};
	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};
	uORB::Subscription _vehicle_command_sub{ORB_ID(vehicle_command)};
	uORB::Subscription _vehicle_command_ack_sub{ORB_ID(vehicle_command_ack)};
	uORB::Subscription _vehicle_status_sub{ORB_ID(vehicle_status)};

	static bool		_boot_complete;

	static constexpr int	MAVLINK_MIN_INTERVAL{1500};
	static constexpr int	MAVLINK_MAX_INTERVAL{10000};
	static constexpr float	MAVLINK_MIN_MULTIPLIER{0.0005f};

	mavlink_message_t	_mavlink_buffer {};
	mavlink_status_t	_mavlink_status {};

	/* states */
	bool			_hil_enabled{false};		/**< Hardware In the Loop mode */
	bool			_is_usb_uart{false};		/**< Port is USB */
	bool			_wait_to_transmit{false};  	/**< Wait to transmit until received messages. */
	bool			_received_messages{false};	/**< Whether we've received valid mavlink messages. */

	px4::atomic_bool	_should_check_events{false};    /**< Events subscription: only one MAVLink instance should check */

	unsigned		_main_loop_delay{1000};	/**< mainloop delay, depends on data rate */

	List<MavlinkStream *>		_streams;

	MavlinkShell		*_mavlink_shell{nullptr};
	MavlinkULog		*_mavlink_ulog{nullptr};
	static events::EventBuffer	*_event_buffer;
	events::SendProtocol		_events{*_event_buffer, *this};

	MAVLINK_MODE 		_mode{MAVLINK_MODE_NORMAL};

	mavlink_channel_t	_channel{MAVLINK_COMM_0};

	bool			_forwarding_on{false};
	bool			_ftp_on{false};
	bool			_use_software_mav_throttling{false};

	int			_uart_fd{-1};

	int			_baudrate{57600};
	int			_datarate{1000};		///< data rate for normal streams (attitude, position, etc.)
	float			_rate_mult{1.0f};

	bool			_radio_status_available{false};
	bool			_radio_status_critical{false};
	float			_radio_status_mult{1.0f};

	/**
	 * If the queue index is not at 0, the queue sending
	 * logic will send parameters from the current index
	 * to len - 1, the end of the param list.
	 */
	unsigned int		_mavlink_param_queue_index{0};

	bool			_mavlink_link_termination_allowed{false};

	char			*_subscribe_to_stream{nullptr};
	float			_subscribe_to_stream_rate{0.0f};  ///< rate of stream to subscribe to (0=disable, -1=unlimited, -2=default)
	bool			_udp_initialised{false};

	FLOW_CONTROL_MODE	_flow_control_mode{Mavlink::FLOW_CONTROL_OFF};

	uint64_t		_last_write_success_time{0};
	uint64_t		_last_write_try_time{0};
	uint64_t		_mavlink_start_time{0};
	int32_t			_protocol_version_switch{-1};
	int32_t			_protocol_version{0};

	unsigned		_bytes_tx{0};
	unsigned		_bytes_txerr{0};
	unsigned		_bytes_rx{0};
	hrt_abstime		_bytes_timestamp{0};

#if defined(MAVLINK_UDP)
	BROADCAST_MODE		_mav_broadcast {BROADCAST_MODE_OFF};

	sockaddr_in		_myaddr {};
	sockaddr_in		_src_addr {};
	sockaddr_in		_bcast_addr {};

	bool			_src_addr_initialized{false};
	bool			_broadcast_address_found{false};
	bool			_broadcast_address_not_found_warned{false};
	bool			_broadcast_failed_warned{false};

	unsigned short		_network_port{14556};
	unsigned short		_remote_port{DEFAULT_REMOTE_PORT_UDP};
#endif // MAVLINK_UDP

	uint8_t			_buf[MAVLINK_MAX_PACKET_LEN] {};
	unsigned		_buf_fill{0};

	bool			_tx_buffer_low{false};

	const char 		*_interface_name{nullptr};

	int			_socket_fd{-1};
	Protocol		_protocol{Protocol::SERIAL};

	radio_status_s		_rstatus {};
	telemetry_status_s	_tstatus {};
	bool                    _tstatus_updated{false};

	ping_statistics_s	_ping_stats {};

	struct mavlink_message_buffer {
		int write_ptr;
		int read_ptr;
		int size;
		char *data;
	};

	mavlink_message_buffer	_message_buffer {};

	pthread_mutex_t		_message_buffer_mutex {};
	pthread_mutex_t		_send_mutex {};
	pthread_mutex_t         _radio_status_mutex {};

	DEFINE_PARAMETERS(
		(ParamInt<px4::params::MAV_SYS_ID>) _param_mav_sys_id,
		(ParamInt<px4::params::MAV_COMP_ID>) _param_mav_comp_id,
		(ParamInt<px4::params::MAV_PROTO_VER>) _param_mav_proto_ver,
		(ParamInt<px4::params::MAV_SIK_RADIO_ID>) _param_sik_radio_id,
		(ParamInt<px4::params::MAV_TYPE>) _param_mav_type,
		(ParamBool<px4::params::MAV_USEHILGPS>) _param_mav_usehilgps,
		(ParamBool<px4::params::MAV_FWDEXTSP>) _param_mav_fwdextsp,
		(ParamBool<px4::params::MAV_HASH_CHK_EN>) _param_mav_hash_chk_en,
		(ParamBool<px4::params::MAV_HB_FORW_EN>) _param_mav_hb_forw_en,
		(ParamBool<px4::params::MAV_ODOM_LP>) _param_mav_odom_lp,
		(ParamInt<px4::params::MAV_RADIO_TOUT>)      _param_mav_radio_timeout,
		(ParamInt<px4::params::SYS_HITL>) _param_sys_hitl,
		(ParamBool<px4::params::SYS_FAILURE_EN>) _param_sys_failure_injection_enabled
	)

	perf_counter_t _loop_perf{perf_alloc(PC_ELAPSED, MODULE_NAME"": tx run elapsed"")};                      /**< loop performance counter */
	perf_counter_t _loop_interval_perf{perf_alloc(PC_INTERVAL, MODULE_NAME"": tx run interval"")};           /**< loop interval performance counter */
	perf_counter_t _send_byte_error_perf{perf_alloc(PC_COUNT, MODULE_NAME"": send_bytes error"")};           /**< send bytes error count */

	void			mavlink_update_parameters();

	int mavlink_open_uart(const int baudrate = DEFAULT_BAUD_RATE,
			      const char *uart_name = DEFAULT_DEVICE_NAME,
			      const FLOW_CONTROL_MODE flow_control = FLOW_CONTROL_AUTO);

	static constexpr unsigned RADIO_BUFFER_CRITICAL_LOW_PERCENTAGE = 25;
	static constexpr unsigned RADIO_BUFFER_LOW_PERCENTAGE = 35;
	static constexpr unsigned RADIO_BUFFER_HALF_PERCENTAGE = 50;

	static hrt_abstime _first_start_time;

	/**
	 * Configure a single stream.
	 * @param stream_name
	 * @param rate streaming rate in Hz, -1 = unlimited rate
	 * @return 0 on success, <0 on error
	 */
	int configure_stream(const char *stream_name, const float rate = -1.0f);

	/**
	 * Configure default streams according to _mode for either all streams or only a single
	 * stream.
	 * @param configure_single_stream: if nullptr, configure all streams, else only a single stream
	 * @return 0 on success, <0 on error
	 */
	int configure_streams_to_default(const char *configure_single_stream = nullptr);

	int message_buffer_init(int size);

	void message_buffer_destroy();

	int message_buffer_count();

	int message_buffer_is_empty() const { return (_message_buffer.read_ptr == _message_buffer.write_ptr); }

	int message_buffer_get_ptr(void **ptr, bool *is_part);

	void message_buffer_mark_read(int n) { _message_buffer.read_ptr = (_message_buffer.read_ptr + n) % _message_buffer.size; }

	void pass_message(const mavlink_message_t *msg);

	void publish_telemetry_status();

	void check_requested_subscriptions();

	/**
	 * Reconfigure a SiK radio if requested by MAV_SIK_RADIO_ID
	 *
	 * This convenience function allows to re-configure a connected
	 * SiK radio without removing it from the main system harness.
	 */
	void configure_sik_radio();

	/**
	 * Update rate mult so total bitrate will be equal to _datarate.
	 */
	void update_rate_mult();

#if defined(MAVLINK_UDP)
	void find_broadcast_address();

	void init_udp();
#endif // MAVLINK_UDP


	void set_channel();

	bool set_instance_id();

	/**
	 * Main mavlink task.
	 */
	int task_main(int argc, char *argv[]);

	// Disallow copy construction and move assignment.
	Mavlink(const Mavlink &) = delete;
	Mavlink operator=(const Mavlink &) = delete;
};",1,334 2000 381 58 439 2001 123 439 58 618 2000 40 41 59 618 126 2000 40 41 59 618 457 404 2002 40 404 2003 44 330 42 2004 91 93 41 59 323 2005 40 41 341 123 450 2006 46 2007 40 41 59 125 323 2008 40 41 341 123 450 2009 46 2010 40 41 59 125 492 2011 40 41 123 2012 46 2013 40 473 41 59 2014 46 2011 40 41 59 125 618 492 2015 40 41 59 618 492 2016 40 41 59 457 404 2017 40 404 2003 44 330 42 2004 91 93 41 59 457 404 2018 40 404 2003 44 330 42 2004 91 93 41 59 457 404 2019 40 41 59 457 2000 42 2020 40 41 59 457 2000 42 2021 40 341 330 42 2022 41 59 2023 42 2024 40 41 123 450 38 2025 59 125 2026 42 2027 40 41 123 450 38 2028 59 125 618 492 2029 40 486 2030 41 59 457 404 2031 40 41 59 457 404 2032 40 323 2033 41 59 457 323 2034 40 341 330 42 2022 44 2000 42 2035 41 59 457 323 2036 40 404 2037 44 404 2038 44 2000 42 2035 61 425 41 59 457 492 2039 40 341 2023 42 2040 44 2000 42 2035 41 59 323 2041 40 41 341 123 450 2042 46 2043 40 41 59 125 492 2044 40 41 123 2045 46 2046 40 473 41 59 125 492 2047 40 41 123 2048 46 2049 40 380 41 59 125 404 2050 40 41 341 123 450 2051 59 125 618 404 2052 40 41 341 123 450 2053 46 2054 59 125 618 404 2055 40 41 341 123 450 2056 46 2057 59 125 341 330 42 2058 123 2059 125 59 370 2060 123 2061 61 1500 44 2062 44 2063 44 2064 44 2065 44 2066 44 2067 44 2068 44 2069 44 2070 44 2071 44 2072 44 2073 125 59 370 2074 123 2075 61 1500 44 2076 44 2077 125 59 370 2078 123 2079 61 1500 44 2080 44 2081 125 59 457 341 330 42 2082 40 370 2060 2083 41 123 464 40 2083 41 123 328 2084 58 450 648 59 328 2085 58 450 648 59 328 2086 58 450 648 59 328 2087 58 450 648 59 328 2088 58 450 648 59 328 2089 58 450 648 59 328 2090 58 450 648 59 328 2091 58 450 648 59 328 2092 58 450 648 59 328 2093 58 450 648 59 328 2094 58 450 648 59 328 2095 58 450 648 59 349 58 450 648 59 125 125 370 2060 2096 40 41 123 450 2097 59 125 323 2098 40 41 123 450 2099 59 125 323 2100 40 41 123 450 2101 46 2102 40 41 59 125 323 2103 40 41 123 450 2104 46 2105 40 41 59 125 323 2106 40 41 123 450 2107 59 125 323 2108 40 41 123 450 2109 59 125 323 2110 40 41 123 450 2111 46 2112 59 125 35 392 2113 40 2114 41 457 2000 42 2115 40 486 413 2116 41 59 323 2117 40 41 123 450 2118 614 2119 59 125 323 2120 40 41 123 450 2121 614 2122 59 125 35 366 621 618 457 492 2123 40 41 59 618 486 2124 40 41 59 457 404 2125 40 404 2003 44 330 42 2004 91 93 41 59 618 404 2126 40 323 2127 41 59 618 492 2128 40 2129 2130 41 123 2131 61 2130 59 125 618 492 2132 40 404 2133 41 59 618 492 2134 40 341 2135 42 2136 44 486 2137 41 59 618 492 2138 40 41 59 618 492 2139 40 2023 42 2040 41 123 2140 40 2141 44 2040 41 59 125 492 2142 40 341 2023 42 2040 41 59 404 2143 40 41 341 123 450 2144 59 125 618 404 2145 40 370 2078 2146 41 59 2147 2148 40 41 341 123 450 2149 59 125 492 2150 40 341 330 42 2151 44 384 2152 61 45 1501 41 59 2153 42 2154 40 41 123 450 38 2155 59 125 618 492 2156 40 341 330 42 461 41 59 618 492 2157 40 341 330 42 461 41 59 618 492 2158 40 341 330 42 461 41 59 618 492 2159 40 486 330 2160 44 341 330 42 461 41 59 618 323 2161 40 41 59 618 492 2162 40 41 59 2163 60 2164 42 62 38 2165 40 41 123 450 2166 59 125 384 2167 40 41 341 123 450 2168 59 125 384 2169 40 41 123 450 2170 59 125 604 492 2171 40 323 2172 41 123 2173 61 2172 59 125 323 2174 40 41 123 450 2175 59 125 492 2176 40 323 2177 41 123 2178 61 2177 59 125 323 2179 40 41 123 450 2180 59 125 323 2181 40 41 123 450 40 2182 605 40 33 2183 606 40 2183 605 2184 41 41 41 59 125 323 2185 40 341 492 42 2186 44 404 2187 41 59 492 2188 40 492 41 123 2189 40 38 2190 41 59 125 492 2191 40 492 41 123 2192 40 38 2193 41 59 125 618 492 2194 40 486 2195 41 123 2196 636 2195 59 125 59 618 492 2197 40 486 2195 41 123 2198 636 2195 59 125 59 618 492 2199 40 486 2195 41 123 2200 636 2195 59 125 59 618 2201 38 2202 40 41 123 450 2203 59 125 492 2204 40 41 123 2205 61 473 59 125 492 2206 40 2135 2207 41 123 2208 46 2207 61 2207 59 125 492 2209 40 341 2210 38 2211 41 59 486 2212 40 41 123 450 2213 46 2214 40 41 59 125 2129 2215 40 41 341 123 450 2216 59 125 404 2217 40 41 123 450 2218 59 125 59 35 392 2113 40 2114 41 486 453 2219 40 41 123 450 2220 59 125 486 453 2221 40 41 123 450 2222 59 125 341 2223 2224 40 341 404 2225 44 341 2226 38 2226 41 59 341 2223 2227 40 341 2223 38 2228 44 341 2223 38 2229 41 59 462 2230 38 2231 40 41 123 450 2232 59 125 492 2233 40 41 123 2234 61 473 59 125 323 2235 40 41 123 450 2236 59 125 35 366 2237 2238 40 41 123 450 2239 59 125 457 323 2240 40 41 123 450 2241 59 125 323 2242 40 41 123 450 2243 59 125 404 2244 40 41 123 450 2245 59 125 492 2246 40 404 2152 41 123 392 40 2152 62 1500 41 123 2247 61 2152 59 125 125 486 2248 40 41 341 123 450 2249 59 125 618 2250 42 2251 40 41 59 618 492 2252 40 41 59 618 2253 42 2254 40 41 123 450 2255 59 125 492 2256 40 2135 2257 44 2135 2258 41 123 392 40 2259 41 123 450 59 125 2259 61 2253 646 2260 40 2261 44 1499 44 2257 44 2258 41 59 125 341 2262 646 2263 38 2264 40 41 341 123 450 2265 59 125 59 323 2266 40 41 341 123 450 2267 59 125 323 2268 40 41 341 123 450 2269 46 2270 40 41 59 125 323 2271 40 41 341 123 450 2272 46 2273 40 41 59 125 323 2274 40 41 341 123 450 2275 46 2276 40 41 59 125 323 2277 40 41 341 123 450 2278 46 2279 40 41 59 125 462 2280 123 2237 2281 59 2282 2283 59 2282 2284 59 384 2285 59 384 2286 59 384 2287 59 384 2288 59 125 59 618 462 2280 38 2289 40 41 123 450 2290 59 125 457 2291 38 2292 40 41 123 450 2293 59 125 323 2294 40 41 341 123 450 2295 59 125 437 58 2296 2297 59 404 2298 123 45 1501 125 59 404 2299 123 45 1501 125 59 2300 646 2301 2302 123 380 125 59 2300 646 2301 2303 123 380 125 59 323 2304 123 473 125 59 323 2305 123 380 125 59 323 2306 123 380 125 59 2153 2307 123 425 125 59 2308 646 2309 60 2310 62 2311 123 2312 40 2313 41 125 59 2308 646 2314 60 2201 62 2315 123 2316 40 2202 41 125 59 2308 646 2317 2318 123 2319 40 373 41 125 59 2308 646 2320 2321 123 2322 40 2323 41 44 1501 125 59 2308 646 2317 2324 123 2325 40 2326 41 125 59 2308 646 2317 2327 123 2328 40 2329 41 125 59 2308 646 2317 2330 123 2331 40 2332 41 125 59 457 323 2333 59 457 343 404 2334 123 1505 125 59 457 343 404 2335 123 1505 125 59 457 343 384 2336 123 1496 125 59 2023 2337 123 125 59 2026 2338 123 125 59 604 323 2339 123 380 125 59 618 323 2340 123 380 125 59 618 323 2341 123 380 125 59 618 323 2342 123 380 125 59 618 2300 646 2301 2343 123 380 125 59 618 486 2344 123 1504 125 59 618 2163 60 2164 42 62 2345 59 2250 42 2346 123 425 125 59 2253 42 2347 123 425 125 59 457 2262 646 2348 42 2349 59 2262 646 2263 2350 123 42 2349 44 42 467 125 59 2060 2351 123 2352 125 59 2147 2353 123 2354 125 59 323 2355 123 380 125 59 323 2356 123 380 125 59 323 2357 123 380 125 59 404 2358 123 45 1501 125 59 404 2359 123 1506 125 59 404 2360 123 1504 125 59 621 384 2361 123 1501 125 59 323 2362 123 380 125 59 323 2363 123 380 125 59 384 2364 123 1501 125 59 618 486 404 2365 123 1500 125 59 323 2366 123 380 125 59 330 42 2367 123 425 125 59 384 2368 123 1500 125 59 621 323 2369 123 380 125 59 2078 2370 123 2000 646 2371 125 59 2237 2372 123 1500 125 59 2237 2373 123 1500 125 59 2237 2374 123 1500 125 59 2375 2376 123 45 1501 125 59 2375 2377 123 1500 125 59 486 2378 123 1500 125 59 486 2379 123 1500 125 59 486 2380 123 1500 125 59 2291 2381 123 1500 125 59 35 392 2113 40 2114 41 2074 2382 123 2383 125 59 2230 2384 123 125 59 2230 2385 123 125 59 2230 2386 123 125 59 323 2387 123 380 125 59 323 2388 123 380 125 59 323 2389 123 380 125 59 323 2390 123 380 125 59 486 453 2391 123 1506 125 59 486 453 2392 123 2393 125 59 35 366 621 2135 2394 91 2395 93 123 125 59 486 2396 123 1500 125 59 323 2397 123 380 125 59 341 330 42 2398 123 425 125 59 404 2399 123 45 1501 125 59 2129 2400 123 2129 646 2401 125 59 2210 2402 123 125 59 2201 2403 123 125 59 323 2404 123 380 125 59 2280 2405 123 125 59 462 2406 123 404 2407 59 404 2408 59 404 2187 59 330 42 2409 59 125 59 2406 2410 123 125 59 2411 2412 123 125 59 2411 2413 123 125 59 2411 2414 123 125 59 2415 40 40 2416 60 2300 646 433 646 2417 62 41 2418 44 40 2416 60 2300 646 433 646 2419 62 41 2420 44 40 2416 60 2300 646 433 646 2421 62 41 2422 44 40 2416 60 2300 646 433 646 2423 62 41 2424 44 40 2416 60 2300 646 433 646 2425 62 41 2426 44 40 2427 60 2300 646 433 646 2428 62 41 2429 44 40 2427 60 2300 646 433 646 2430 62 41 2431 44 40 2427 60 2300 646 433 646 2432 62 41 2433 44 40 2427 60 2300 646 433 646 2434 62 41 2435 44 40 2427 60 2300 646 433 646 2436 62 41 2437 44 40 2416 60 2300 646 433 646 2438 62 41 2439 44 40 2416 60 2300 646 433 646 2440 62 41 2441 44 40 2427 60 2300 646 433 646 2442 62 41 2443 41 2444 2445 123 2446 40 2447 44 2448 648 41 125 59 618 2444 2449 123 2450 40 2451 44 2452 648 41 125 59 618 2444 2453 123 2454 40 2455 44 2456 648 41 125 59 618 492 2457 40 41 59 404 2458 40 341 404 2459 61 2460 44 341 330 42 2461 61 2462 44 341 2078 2463 61 2464 41 59 457 343 486 2465 61 1503 59 457 343 486 2466 61 1503 59 457 343 486 2467 61 1503 59 457 2291 2468 59 618 404 2469 40 341 330 42 2151 44 341 384 2152 61 45 1501 41 59 618 404 2470 40 341 330 42 2471 61 425 41 59 404 2472 40 404 2187 41 59 492 2473 40 41 59 404 2474 40 41 59 404 2475 40 41 341 123 450 40 2410 46 2476 614 2410 46 2477 41 59 125 404 2478 40 492 42 42 2186 44 323 42 2479 41 59 492 2480 40 404 2195 41 123 2410 46 2481 61 40 2410 46 2481 43 2195 41 37 2410 46 2187 59 125 492 2482 40 341 2023 42 2040 41 59 492 2483 40 41 59 492 2484 40 41 59 618 492 2485 40 41 59 618 492 2486 40 41 59 35 392 2113 40 2114 41 492 2487 40 41 59 492 2488 40 41 59 35 366 621 492 2489 40 41 59 323 2490 40 41 59 618 404 2491 40 404 2003 44 330 42 2004 91 93 41 59 621 2000 40 341 2000 38 41 61 353 59 2000 427 61 40 341 2000 38 41 61 353 59 125 59 
118521,C++,"class ChatLine
{
public:
    using Ptr = std::shared_ptr<ChatLine>;

    ChatLine();
    virtual ~ChatLine();

    QRectF sceneBoundingRect() const;

    void replaceContent(int col, ChatLineContent* lineContent);
    void layout(qreal width, QPointF scenePos);
    void moveBy(qreal deltaY);
    void removeFromScene();
    void addToScene(QGraphicsScene* scene);
    void setVisible(bool visible);
    void selectionCleared();
    void selectionFocusChanged(bool focusIn);
    void fontChanged(const QFont& font);
    void reloadTheme();

    int getColumnCount();

    ChatLineContent* getContent(int col) const;
    ChatLineContent* getContent(QPointF scenePos) const;

    bool isOverSelection(QPointF scenePos);

    // comparators
    static bool lessThanBSRectTop(const ChatLine::Ptr& lhs, const qreal& rhs);
    static bool lessThanBSRectBottom(const ChatLine::Ptr& lhs, const qreal& rhs);

protected:
    friend class ChatWidget;

    QPointF mapToContent(ChatLineContent* c, QPointF pos);

    void addColumn(ChatLineContent* item, ColumnFormat fmt);
    void updateBBox();
    void visibilityChanged(bool visible);

private:
    int row = -1;
    QVector<ChatLineContent*> content;
    QVector<ColumnFormat> format;
    qreal width = 100.0;
    qreal columnSpacing = 15.0;
    QRectF bbox;
    bool isVisible = false;
};",1,334 2000 123 439 58 489 2001 61 2002 646 2003 60 2000 62 59 2000 40 41 59 491 126 2000 40 41 59 2004 2005 40 41 341 59 492 2006 40 404 2007 44 2008 42 2009 41 59 492 2010 40 2011 2012 44 2013 2014 41 59 492 2015 40 2011 2016 41 59 492 2017 40 41 59 492 2018 40 2019 42 2020 41 59 492 2021 40 323 2022 41 59 492 2023 40 41 59 492 2024 40 323 2025 41 59 492 2026 40 341 2027 38 2028 41 59 492 2029 40 41 59 404 2030 40 41 59 2008 42 2031 40 404 2007 41 341 59 2008 42 2031 40 2013 2014 41 341 59 323 2032 40 2013 2014 41 59 621 457 323 2033 40 341 2000 646 2001 38 2034 44 341 2011 38 2035 41 59 457 323 2036 40 341 2000 646 2001 38 2034 44 341 2011 38 2035 41 59 438 58 387 334 2037 59 2013 2038 40 2008 42 2039 44 2013 2040 41 59 492 2041 40 2008 42 2042 44 2043 2044 41 59 492 2045 40 41 59 492 2046 40 323 2022 41 59 437 58 404 2047 61 45 1501 59 2048 60 2008 42 62 2049 59 2048 60 2043 62 2050 59 2011 2012 61 1503 59 2011 2051 61 1503 59 2004 2052 59 323 2053 61 380 59 125 59 
98892,C++,"class OGRSQLiteTableLayer final: public OGRSQLiteLayer
{
    bool                m_bIsTable = true;

    bool                m_bLaunderColumnNames = true;
    bool                m_bSpatialite2D = false;
    bool                m_bStrict = false;

    CPLString           m_osWHERE{};
    CPLString           m_osQuery{};
    bool                m_bDeferredSpatialIndexCreation = false;

    char               *m_pszTableName = nullptr;
    char               *m_pszEscapedTableName = nullptr;

    bool                m_bLayerDefnError = false;

    sqlite3_stmt       *m_hInsertStmt = nullptr;
    CPLString           m_osLastInsertStmt{};

    bool                m_bHasCheckedTriggers = false;
    bool                m_bHasTriedDetectingFID64 = false;

    bool                m_bStatisticsNeedsToBeFlushed = false;
    GIntBig             m_nFeatureCount = -1; /* if -1, means not up-to-date */

    int                 m_bDeferredCreation = false;

    char               *m_pszCreationGeomFormat = nullptr;
    int                 m_iFIDAsRegularColumnIndex = -1;

    void                ClearInsertStmt();

    void                BuildWhere();

    virtual OGRErr      ResetStatement() override;

    OGRErr              RecomputeOrdinals();

    void                AddColumnDef(char* pszNewFieldList, size_t nBufLen,
                                     OGRFieldDefn* poFldDefn);

    void                InitFieldListForRecrerate(char* & pszNewFieldList,
                                                  char* & pszFieldListForSelect,
                                                  size_t& nBufLenOut,
                                                  int nExtraSpace = 0);
    OGRErr              RecreateTable(const char* pszFieldListForSelect,
                                      const char* pszNewFieldList,
                                      const char* pszGenericErrorMessage);
    OGRErr              BindValues( OGRFeature *poFeature,
                                    sqlite3_stmt* hStmt,
                                    bool bBindUnsetAsNull );

    bool                CheckSpatialIndexTable(int iGeomCol);

    CPLErr              EstablishFeatureDefn(const char* pszGeomCol);

    void                LoadStatistics();
    void                LoadStatisticsSpatialite4DB();

    CPLString           FieldDefnToSQliteFieldDefn( OGRFieldDefn* poFieldDefn );

    OGRErr              RunAddGeometryColumn( const OGRSQLiteGeomFieldDefn *poGeomField,
                                              bool bAddColumnsForNonSpatialite );

  public:
    explicit            OGRSQLiteTableLayer( OGRSQLiteDataSource * );
                        virtual ~OGRSQLiteTableLayer();

    CPLErr              Initialize( const char *pszTableName,
                                    bool bIsTable,
                                    bool bIsVirtualShapeIn,
                                    bool bDeferredCreation);
    void                SetCreationParameters( const char *pszFIDColumnName,
                                               OGRwkbGeometryType eGeomType,
                                               const char *pszGeomFormat,
                                               const char *pszGeometryName,
                                               OGRSpatialReference *poSRS,
                                               int nSRSId );
    virtual const char* GetName() override;

    virtual GIntBig     GetFeatureCount( int ) override;
    virtual OGRErr      GetExtent(OGREnvelope *psExtent, int bForce) override;
    virtual OGRErr      GetExtent(int iGeomField, OGREnvelope *psExtent, int bForce) override;

    virtual OGRFeatureDefn *GetLayerDefn() override;
    bool                HasLayerDefnError() { GetLayerDefn(); return m_bLayerDefnError; }

    virtual void        SetSpatialFilter( OGRGeometry * ) override;
    virtual void        SetSpatialFilter( int iGeomField, OGRGeometry * ) override;
    virtual OGRErr      SetAttributeFilter( const char * ) override;
    virtual OGRErr      ISetFeature( OGRFeature *poFeature ) override;
    virtual OGRErr      DeleteFeature( GIntBig nFID ) override;
    virtual OGRErr      ICreateFeature( OGRFeature *poFeature ) override;

    virtual OGRErr      CreateField( OGRFieldDefn *poField,
                                     int bApproxOK = TRUE ) override;
    virtual OGRErr      CreateGeomField( OGRGeomFieldDefn *poGeomFieldIn,
                                         int bApproxOK = TRUE ) override;
    virtual OGRErr      DeleteField( int iField ) override;
    virtual OGRErr      ReorderFields( int* panMap ) override;
    virtual OGRErr      AlterFieldDefn( int iField, OGRFieldDefn* poNewFieldDefn, int nFlags ) override;

    virtual OGRFeature *GetNextFeature() override;
    virtual OGRFeature *GetFeature( GIntBig nFeatureId ) override;

    virtual int         TestCapability( const char * ) override;

    virtual char      **GetMetadata( const char * pszDomain = """" ) override;
    virtual const char *GetMetadataItem( const char * pszName,
                                         const char * pszDomain = """" ) override;

    // follow methods are not base class overrides
    void                SetLaunderFlag( bool bFlag )
                                { m_bLaunderColumnNames = bFlag; }
    void                SetUseCompressGeom( bool bFlag )
                                { m_bUseComprGeom = bFlag; }
    void                SetDeferredSpatialIndexCreation( bool bFlag )
                                { m_bDeferredSpatialIndexCreation = bFlag; }
    void                SetCompressedColumns( const char* pszCompressedColumns );
    void                SetStrictFlag( bool bFlag ) { m_bStrict = bFlag; }

    int                 CreateSpatialIndex(int iGeomCol);

    void                CreateSpatialIndexIfNecessary();

    void                InitFeatureCount();
    bool                DoStatisticsNeedToBeFlushed();
    void                ForceStatisticsToBeFlushed();
    bool                AreStatisticsValid();
    int                 SaveStatistics();

    virtual void        InvalidateCachedFeatureCountAndExtent() override;

    virtual bool         IsTableLayer() override { return true; }

    virtual bool         HasSpatialIndex(int iGeomField) override;
    virtual bool         HasFastSpatialFilter(int iGeomCol) override;
    virtual CPLString    GetSpatialWhere(int iGeomCol,
                                         OGRGeometry* poFilterGeom) override;

    OGRErr               RunDeferredCreationIfNecessary();
};",1,334 2000 381 58 439 2001 123 323 2002 61 473 59 323 2003 61 473 59 323 2004 61 380 59 323 2005 61 380 59 2006 2007 123 125 59 2006 2008 123 125 59 323 2009 61 380 59 330 42 2010 61 425 59 330 42 2011 61 425 59 323 2012 61 380 59 2013 42 2014 61 425 59 2006 2015 123 125 59 323 2016 61 380 59 323 2017 61 380 59 323 2018 61 380 59 2019 2020 61 45 1501 59 604 404 2021 61 380 59 330 42 2022 61 425 59 404 2023 61 45 1501 59 492 2024 40 41 59 492 2025 40 41 59 491 2026 2027 40 41 431 59 2026 2028 40 41 59 492 2029 40 330 42 2030 44 2031 2032 44 2033 42 2034 41 59 492 2035 40 330 42 38 2030 44 330 42 38 2036 44 2031 38 2037 44 404 2038 61 1500 41 59 2026 2039 40 341 330 42 2036 44 341 330 42 2030 44 341 330 42 2040 41 59 2026 2041 40 2042 42 2043 44 2013 42 2044 44 323 2045 41 59 323 2046 40 404 2047 41 59 2048 2049 40 341 330 42 2050 41 59 492 2051 40 41 59 492 2052 40 41 59 2006 2053 40 2033 42 2054 41 59 2026 2055 40 341 2056 42 2057 44 323 2058 41 59 439 58 376 2000 40 2059 42 41 59 491 126 2000 40 41 59 2048 2060 40 341 330 42 2061 44 323 2062 44 323 2063 44 323 2064 41 59 492 2065 40 341 330 42 2066 44 2067 2068 44 341 330 42 2069 44 341 330 42 2070 44 2071 42 2072 44 404 2073 41 59 491 341 330 42 2074 40 41 431 59 491 2019 2075 40 404 41 431 59 491 2026 2076 40 2077 42 2078 44 404 2079 41 431 59 491 2026 2076 40 404 2080 44 2077 42 2078 44 404 2079 41 431 59 491 2081 42 2082 40 41 431 59 323 2083 40 41 123 2082 40 41 59 450 2012 59 125 491 492 2084 40 2085 42 41 431 59 491 492 2084 40 404 2080 44 2085 42 41 431 59 491 2026 2086 40 341 330 42 41 431 59 491 2026 2087 40 2042 42 2043 41 431 59 491 2026 2088 40 2019 2089 41 431 59 491 2026 2090 40 2042 42 2043 41 431 59 491 2026 2091 40 2033 42 2092 44 404 2093 61 2094 41 431 59 491 2026 2095 40 2096 42 2097 44 404 2093 61 2094 41 431 59 491 2026 2098 40 404 2099 41 431 59 491 2026 2100 40 404 42 2101 41 431 59 491 2026 2102 40 404 2099 44 2033 42 2103 44 404 2104 41 431 59 491 2042 42 2105 40 41 431 59 491 2042 42 2106 40 2019 2107 41 431 59 491 404 2108 40 341 330 42 41 431 59 491 330 42 42 2109 40 341 330 42 2110 61 648 41 431 59 491 341 330 42 2111 40 341 330 42 2112 44 341 330 42 2110 61 648 41 431 59 621 492 2113 40 323 2114 41 123 2003 61 2114 59 125 492 2115 40 323 2114 41 123 2116 61 2114 59 125 492 2117 40 323 2114 41 123 2009 61 2114 59 125 492 2118 40 341 330 42 2119 41 59 492 2120 40 323 2114 41 123 2005 61 2114 59 125 404 2121 40 404 2047 41 59 492 2122 40 41 59 492 2123 40 41 59 323 2124 40 41 59 492 2125 40 41 59 323 2126 40 41 59 404 2127 40 41 59 491 492 2128 40 41 431 59 491 323 2129 40 41 431 123 450 473 59 125 491 323 2130 40 404 2080 41 431 59 491 323 2131 40 404 2047 41 431 59 491 2006 2132 40 404 2047 44 2085 42 2133 41 431 59 2026 2134 40 41 59 125 59 
102141,C++,"class BrowserService : public QObject
{
    Q_OBJECT

public:
    explicit BrowserService();
    static BrowserService* instance();

    void setEnabled(bool enabled);

    QString getKey(const QString& id);
    QString storeKey(const QString& key);
    QString getDatabaseHash(bool legacy = false);

    bool isDatabaseOpened() const;
    bool openDatabase(bool triggerUnlock);
    void lockDatabase();

    QJsonObject getDatabaseGroups();
    QJsonObject createNewGroup(const QString& groupName);
    QString getCurrentTotp(const QString& uuid);
    void showPasswordGenerator(const QJsonObject& errorMessage, const QString& nonce);
    void sendPassword(const QJsonObject& message);

    void addEntry(const QString& dbid,
                  const QString& login,
                  const QString& password,
                  const QString& siteUrlStr,
                  const QString& formUrlStr,
                  const QString& realm,
                  const QString& group,
                  const QString& groupUuid,
                  const bool downloadFavicon,
                  const QSharedPointer<Database>& selectedDb = {});
    bool updateEntry(const QString& dbid,
                     const QString& uuid,
                     const QString& login,
                     const QString& password,
                     const QString& siteUrlStr,
                     const QString& formUrlStr);
    bool deleteEntry(const QString& uuid);

    QJsonArray findMatchingEntries(const QString& dbid,
                                   const QString& siteUrlStr,
                                   const QString& formUrlStr,
                                   const QString& realm,
                                   const StringPairList& keyList,
                                   const bool httpAuth = false);

    void requestGlobalAutoType(const QString& search);
    static void convertAttributesToCustomData(QSharedPointer<Database> db);

    static const QString KEEPASSXCBROWSER_NAME;
    static const QString KEEPASSXCBROWSER_OLD_NAME;
    static const QString OPTION_SKIP_AUTO_SUBMIT;
    static const QString OPTION_HIDE_ENTRY;
    static const QString OPTION_ONLY_HTTP_AUTH;
    static const QString OPTION_NOT_HTTP_AUTH;
    static const QString ADDITIONAL_URL;

signals:
    void requestUnlock();
    void passwordGenerated(const QString& password, const QString& nonce);

public slots:
    void databaseLocked(DatabaseWidget* dbWidget);
    void databaseUnlocked(DatabaseWidget* dbWidget);
    void activeDatabaseChanged(DatabaseWidget* dbWidget);

private slots:
    void processClientMessage(const QJsonObject& message);

private:
    enum Access
    {
        Denied,
        Unknown,
        Allowed
    };

    enum WindowState
    {
        Normal,
        Minimized,
        Hidden
    };

    QList<Entry*>
    searchEntries(const QSharedPointer<Database>& db, const QString& siteUrlStr, const QString& formUrlStr);
    QList<Entry*> searchEntries(const QString& siteUrlStr, const QString& formUrlStr, const StringPairList& keyList);
    QList<Entry*> sortEntries(QList<Entry*>& pwEntries, const QString& siteUrlStr, const QString& formUrlStr);
    QList<Entry*> confirmEntries(QList<Entry*>& pwEntriesToConfirm,
                                 const QString& siteUrlStr,
                                 const QString& siteHost,
                                 const QString& formUrlStr,
                                 const QString& realm,
                                 const bool httpAuth);
    QJsonObject prepareEntry(const Entry* entry);
    QJsonArray getChildrenFromGroup(Group* group);
    Access checkAccess(const Entry* entry, const QString& siteHost, const QString& formHost, const QString& realm);
    Group* getDefaultEntryGroup(const QSharedPointer<Database>& selectedDb = {});
    int sortPriority(const QStringList& urls, const QString& siteUrlStr, const QString& formUrlStr);
    bool schemeFound(const QString& url);
    bool isIpAddress(const QString& host) const;
    bool removeFirstDomain(QString& hostname);
    bool handleEntry(Entry* entry, const QString& url, const QString& submitUrl);
    bool handleURL(const QString& entryUrl, const QString& siteUrlStr, const QString& formUrlStr);
    QString getTopLevelDomainFromUrl(const QString& url) const;
    QString baseDomain(const QString& hostname) const;
    QSharedPointer<Database> getDatabase();
    QSharedPointer<Database> selectedDatabase();
    QString getDatabaseRootUuid();
    QString getDatabaseRecycleBinUuid();
    bool checkLegacySettings(QSharedPointer<Database> db);
    QStringList getEntryURLs(const Entry* entry);
    void hideWindow() const;
    void raiseWindow(const bool force = false);

    void updateWindowState();

    static bool moveSettingsToCustomData(Entry* entry, const QString& name);
    static int moveKeysToCustomData(Entry* entry, QSharedPointer<Database> db);

    QPointer<BrowserHost> m_browserHost;
    QHash<QString, QSharedPointer<BrowserAction>> m_browserClients;

    bool m_dialogActive;
    bool m_bringToFrontRequested;
    WindowState m_prevWindowState;
    QUuid m_keepassBrowserUUID;

    QPointer<DatabaseWidget> m_currentDatabaseWidget;
    QScopedPointer<PasswordGeneratorWidget> m_passwordGenerator;

    Q_DISABLE_COPY(BrowserService);

    friend class TestBrowser;
};",1,334 2000 58 439 2001 123 2002 439 58 376 2000 40 41 59 457 2000 42 2003 40 41 59 492 2004 40 323 2005 41 59 2006 2007 40 341 2006 38 2008 41 59 2006 2009 40 341 2006 38 2010 41 59 2006 2011 40 323 2012 61 380 41 59 323 2013 40 41 341 59 323 2014 40 323 2015 41 59 492 2016 40 41 59 2017 2018 40 41 59 2017 2019 40 341 2006 38 2020 41 59 2006 2021 40 341 2006 38 2022 41 59 492 2023 40 341 2017 38 2024 44 341 2006 38 2025 41 59 492 2026 40 341 2017 38 2027 41 59 492 2028 40 341 2006 38 2029 44 341 2006 38 2030 44 341 2006 38 2031 44 341 2006 38 2032 44 341 2006 38 2033 44 341 2006 38 2034 44 341 2006 38 2035 44 341 2006 38 2036 44 341 323 2037 44 341 2038 60 2039 62 38 2040 61 123 125 41 59 323 2041 40 341 2006 38 2029 44 341 2006 38 2022 44 341 2006 38 2030 44 341 2006 38 2031 44 341 2006 38 2032 44 341 2006 38 2033 41 59 323 2042 40 341 2006 38 2022 41 59 2043 2044 40 341 2006 38 2029 44 341 2006 38 2032 44 341 2006 38 2033 44 341 2006 38 2034 44 341 2045 38 2046 44 341 323 2047 61 380 41 59 492 2048 40 341 2006 38 2049 41 59 457 492 2050 40 2038 60 2039 62 2051 41 59 457 341 2006 2052 59 457 341 2006 2053 59 457 341 2006 2054 59 457 341 2006 2055 59 457 341 2006 2056 59 457 341 2006 2057 59 457 341 2006 2058 59 2059 58 492 2060 40 41 59 492 2061 40 341 2006 38 2031 44 341 2006 38 2025 41 59 439 2062 58 492 2063 40 2064 42 2065 41 59 492 2066 40 2064 42 2065 41 59 492 2067 40 2064 42 2065 41 59 437 2062 58 492 2068 40 341 2017 38 2027 41 59 437 58 370 2069 123 2070 44 2071 44 2072 125 59 370 2073 123 2074 44 2075 44 2076 125 59 2077 60 2078 42 62 2079 40 341 2038 60 2039 62 38 2051 44 341 2006 38 2032 44 341 2006 38 2033 41 59 2077 60 2078 42 62 2079 40 341 2006 38 2032 44 341 2006 38 2033 44 341 2045 38 2046 41 59 2077 60 2078 42 62 2080 40 2077 60 2078 42 62 38 2081 44 341 2006 38 2032 44 341 2006 38 2033 41 59 2077 60 2078 42 62 2082 40 2077 60 2078 42 62 38 2083 44 341 2006 38 2032 44 341 2006 38 2084 44 341 2006 38 2033 44 341 2006 38 2034 44 341 323 2047 41 59 2017 2085 40 341 2078 42 2086 41 59 2043 2087 40 2088 42 2035 41 59 2069 2089 40 341 2078 42 2086 44 341 2006 38 2084 44 341 2006 38 2090 44 341 2006 38 2034 41 59 2088 42 2091 40 341 2038 60 2039 62 38 2040 61 123 125 41 59 404 2092 40 341 2093 38 2094 44 341 2006 38 2032 44 341 2006 38 2033 41 59 323 2095 40 341 2006 38 2096 41 59 323 2097 40 341 2006 38 2098 41 341 59 323 2099 40 2006 38 2100 41 59 323 2101 40 2078 42 2086 44 341 2006 38 2096 44 341 2006 38 2102 41 59 323 2103 40 341 2006 38 2104 44 341 2006 38 2032 44 341 2006 38 2033 41 59 2006 2105 40 341 2006 38 2096 41 341 59 2006 2106 40 341 2006 38 2100 41 341 59 2038 60 2039 62 2107 40 41 59 2038 60 2039 62 2108 40 41 59 2006 2109 40 41 59 2006 2110 40 41 59 323 2111 40 2038 60 2039 62 2051 41 59 2093 2112 40 341 2078 42 2086 41 59 492 2113 40 41 341 59 492 2114 40 341 323 2115 61 380 41 59 492 2116 40 41 59 457 323 2117 40 2078 42 2086 44 341 2006 38 2118 41 59 457 404 2119 40 2078 42 2086 44 2038 60 2039 62 2051 41 59 2120 60 2121 62 2122 59 2123 60 2006 44 2038 60 2124 640 2125 59 323 2126 59 323 2127 59 2073 2128 59 2129 2130 59 2120 60 2064 62 2131 59 2132 60 2133 62 2134 59 2135 40 2000 41 59 387 334 2136 59 125 59 
118436,C++,"class Core : public QObject,
             public ICoreFriendMessageSender,
             public ICoreIdHandler,
             public ICoreGroupMessageSender,
             public ICoreGroupQuery
{
    Q_OBJECT
public:
    enum class ToxCoreErrors
    {
        BAD_PROXY,
        INVALID_SAVE,
        FAILED_TO_START,
        ERROR_ALLOC
    };

    static ToxCorePtr makeToxCore(const QByteArray& savedata, const ICoreSettings* const settings,
                                  IBootstrapListGenerator& bootstrapNodes, ToxCoreErrors* err = nullptr);
    const CoreAV* getAv() const;
    CoreAV* getAv();
    void setAv(CoreAV* coreAv);

    CoreFile* getCoreFile() const;
    Tox* getTox() const;
    CompatibleRecursiveMutex& getCoreLoopLock() const;

    const CoreExt* getExt() const;
    CoreExt* getExt();
    ~Core();

    static const QString TOX_EXT;
    uint64_t getMaxMessageSize() const;
    QString getPeerName(const ToxPk& id) const;
    QVector<uint32_t> getFriendList() const;
    GroupId getGroupPersistentId(uint32_t groupNumber) const override;
    uint32_t getGroupNumberPeers(int groupId) const override;
    QString getGroupPeerName(int groupId, int peerId) const override;
    ToxPk getGroupPeerPk(int groupId, int peerId) const override;
    QStringList getGroupPeerNames(int groupId) const override;
    bool getGroupAvEnabled(int groupId) const override;
    ToxPk getFriendPublicKey(uint32_t friendNumber) const;
    QString getFriendUsername(uint32_t friendNumber) const;

    bool isFriendOnline(uint32_t friendId) const;
    bool hasFriendWithPublicKey(const ToxPk& publicKey) const;
    uint32_t joinGroupchat(const GroupInvite& inviteInfo);
    void quitGroupChat(int groupId) const;

    QString getUsername() const override;
    Status::Status getStatus() const;
    QString getStatusMessage() const;
    ToxId getSelfId() const override;
    ToxPk getSelfPublicKey() const override;
    QPair<QByteArray, QByteArray> getKeypair() const;

    void sendFile(uint32_t friendId, QString filename, QString filePath, long long filesize);

public slots:
    void start();

    QByteArray getToxSaveData();

    void acceptFriendRequest(const ToxPk& friendPk);
    void requestFriendship(const ToxId& friendAddress, const QString& message);
    void groupInviteFriend(uint32_t friendId, int groupId);
    int createGroup(uint8_t type = TOX_CONFERENCE_TYPE_AV);

    void removeFriend(uint32_t friendId);
    void removeGroup(int groupId);

    void setStatus(Status::Status status);
    void setUsername(const QString& username);
    void setStatusMessage(const QString& message);

    bool sendMessage(uint32_t friendId, const QString& message, ReceiptNum& receipt) override;
    void sendGroupMessage(int groupId, const QString& message) override;
    void sendGroupAction(int groupId, const QString& message) override;
    void changeGroupTitle(int groupId, const QString& title);
    bool sendAction(uint32_t friendId, const QString& action, ReceiptNum& receipt) override;
    void sendTyping(uint32_t friendId, bool typing);

    void setNospam(uint32_t nospam);

signals:
    void connected();
    void disconnected();

    void friendRequestReceived(const ToxPk& friendPk, const QString& message);
    void friendAvatarChanged(const ToxPk& friendPk, const QByteArray& pic);
    void friendAvatarRemoved(const ToxPk& friendPk);

    void requestSent(const ToxPk& friendPk, const QString& message);
    void failedToAddFriend(const ToxPk& friendPk, const QString& errorInfo = QString());

    void usernameSet(const QString& username);
    void statusMessageSet(const QString& message);
    void statusSet(Status::Status status);
    void idSet(const ToxId& id);

    void failedToSetUsername(const QString& username);
    void failedToSetStatusMessage(const QString& message);
    void failedToSetStatus(Status::Status status);
    void failedToSetTyping(bool typing);

    void saveRequest();

    /**
     * @deprecated prefer signals using ToxPk
     */

    void fileAvatarOfferReceived(uint32_t friendId, uint32_t fileId, const QByteArray& avatarHash);

    void friendMessageReceived(uint32_t friendId, const QString& message, bool isAction);
    void friendAdded(uint32_t friendId, const ToxPk& friendPk);

    void friendStatusChanged(uint32_t friendId, Status::Status status);
    void friendStatusMessageChanged(uint32_t friendId, const QString& message);
    void friendUsernameChanged(uint32_t friendId, const QString& username);
    void friendTypingChanged(uint32_t friendId, bool isTyping);

    void friendRemoved(uint32_t friendId);
    void friendLastSeenChanged(uint32_t friendId, const QDateTime& dateTime);

    void emptyGroupCreated(int groupnumber, const GroupId groupId, const QString& title = QString());
    void groupInviteReceived(const GroupInvite& inviteInfo);
    void groupMessageReceived(int groupnumber, int peernumber, const QString& message, bool isAction);
    void groupNamelistChanged(int groupnumber, int peernumber, uint8_t change);
    void groupPeerlistChanged(int groupnumber);
    void groupPeerNameChanged(int groupnumber, const ToxPk& peerPk, const QString& newName);
    void groupTitleChanged(int groupnumber, const QString& author, const QString& title);
    void groupPeerAudioPlaying(int groupnumber, ToxPk peerPk);
    void groupSentFailed(int groupId);
    void groupJoined(int groupnumber, GroupId groupId);
    void actionSentResult(uint32_t friendId, const QString& action, int success);

    void receiptRecieved(int friedId, ReceiptNum receipt);

    void failedToRemoveFriend(uint32_t friendId);

private:
    Core(QThread* coreThread, IBootstrapListGenerator& _bootstrapNodes);

    static void onFriendRequest(Tox* tox, const uint8_t* cUserId, const uint8_t* cMessage,
                                size_t cMessageSize, void* core);
    static void onFriendMessage(Tox* tox, uint32_t friendId, Tox_Message_Type type,
                                const uint8_t* cMessage, size_t cMessageSize, void* core);
    static void onFriendNameChange(Tox* tox, uint32_t friendId, const uint8_t* cName,
                                   size_t cNameSize, void* core);
    static void onFriendTypingChange(Tox* tox, uint32_t friendId, bool isTyping, void* core);
    static void onStatusMessageChanged(Tox* tox, uint32_t friendId, const uint8_t* cMessage,
                                       size_t cMessageSize, void* core);
    static void onUserStatusChanged(Tox* tox, uint32_t friendId, Tox_User_Status userstatus,
                                    void* core);
    static void onConnectionStatusChanged(Tox* tox, uint32_t friendId, Tox_Connection status,
                                          void* vCore);
    static void onGroupInvite(Tox* tox, uint32_t friendId, Tox_Conference_Type type,
                              const uint8_t* cookie, size_t length, void* vCore);
    static void onGroupMessage(Tox* tox, uint32_t groupId, uint32_t peerId, Tox_Message_Type type,
                               const uint8_t* cMessage, size_t length, void* vCore);
    static void onGroupPeerListChange(Tox*, uint32_t groupId, void* core);
    static void onGroupPeerNameChange(Tox*, uint32_t groupId, uint32_t peerId, const uint8_t* name,
                                      size_t length, void* core);
    static void onGroupTitleChange(Tox* tox, uint32_t groupId, uint32_t peerId,
                                   const uint8_t* cTitle, size_t length, void* vCore);

    static void onLosslessPacket(Tox* tox, uint32_t friendId,
                                   const uint8_t* data, size_t length, void* core);
    static void onReadReceiptCallback(Tox* tox, uint32_t friendId, uint32_t receipt, void* core);

    void sendGroupMessageWithType(int groupId, const QString& message, Tox_Message_Type type);
    bool sendMessageWithType(uint32_t friendId, const QString& message, Tox_Message_Type type, ReceiptNum& receipt);
    bool checkConnection();

    void makeTox(QByteArray savedata, ICoreSettings* s);
    void loadFriends();
    void loadGroups();
    void bootstrapDht();

    void checkLastOnline(uint32_t friendId);

    QString getFriendRequestErrorMessage(const ToxId& friendId, const QString& message) const;
    static void registerCallbacks(Tox* tox);

private slots:
    void process();
    void onStarted();

private:
    struct ToxDeleter
    {
        void operator()(Tox* tox)
        {
            tox_kill(tox);
        }
    };

    using ToxPtr = std::unique_ptr<Tox, ToxDeleter>;
    ToxPtr tox;

    std::unique_ptr<CoreFile> file;
    CoreAV* av = nullptr;
    std::unique_ptr<CoreExt> ext;
    QTimer* toxTimer = nullptr;
    // recursive, since we might call our own functions
    mutable CompatibleRecursiveMutex coreLoopLock;

    std::unique_ptr<QThread> coreThread;
    IBootstrapListGenerator& bootstrapNodes;
};",1,334 2000 58 439 2001 44 439 2002 44 439 2003 44 439 2004 44 439 2005 123 2006 439 58 370 334 2007 123 2008 44 2009 44 2010 44 2011 125 59 457 2012 2013 40 341 2014 38 2015 44 341 2016 42 341 2017 44 2018 38 2019 44 2007 42 2020 61 425 41 59 341 2021 42 2022 40 41 341 59 2021 42 2022 40 41 59 492 2023 40 2021 42 2024 41 59 2025 42 2026 40 41 341 59 2027 42 2028 40 41 341 59 2029 38 2030 40 41 341 59 341 2031 42 2032 40 41 341 59 2031 42 2032 40 41 59 126 2000 40 41 59 457 341 2033 2034 59 2035 2036 40 41 341 59 2033 2037 40 341 2038 38 2039 41 341 59 2040 60 2041 62 2042 40 41 341 59 2043 2044 40 2041 2045 41 341 431 59 2041 2046 40 404 2047 41 341 431 59 2033 2048 40 404 2047 44 404 2049 41 341 431 59 2038 2050 40 404 2047 44 404 2049 41 341 431 59 2051 2052 40 404 2047 41 341 431 59 323 2053 40 404 2047 41 341 431 59 2038 2054 40 2041 2055 41 341 59 2033 2056 40 2041 2055 41 341 59 323 2057 40 2041 2058 41 341 59 323 2059 40 341 2038 38 2060 41 341 59 2041 2061 40 341 2062 38 2063 41 59 492 2064 40 404 2047 41 341 59 2033 2065 40 41 341 431 59 2066 646 2066 2067 40 41 341 59 2033 2068 40 41 341 59 2069 2070 40 41 341 431 59 2038 2071 40 41 341 431 59 2072 60 2014 44 2014 62 2073 40 41 341 59 492 2074 40 2041 2058 44 2033 2075 44 2033 2076 44 413 413 2077 41 59 439 2078 58 492 2079 40 41 59 2014 2080 40 41 59 492 2081 40 341 2038 38 2082 41 59 492 2083 40 341 2069 38 2084 44 341 2033 38 2085 41 59 492 2086 40 2041 2058 44 404 2047 41 59 404 2087 40 2088 2089 61 2090 41 59 492 2091 40 2041 2058 41 59 492 2092 40 404 2047 41 59 492 2093 40 2066 646 2066 2094 41 59 492 2095 40 341 2033 38 2096 41 59 492 2097 40 341 2033 38 2085 41 59 323 2098 40 2041 2058 44 341 2033 38 2085 44 2099 38 2100 41 431 59 492 2101 40 404 2047 44 341 2033 38 2085 41 431 59 492 2102 40 404 2047 44 341 2033 38 2085 41 431 59 492 2103 40 404 2047 44 341 2033 38 2104 41 59 323 2105 40 2041 2058 44 341 2033 38 2106 44 2099 38 2100 41 431 59 492 2107 40 2041 2058 44 323 2108 41 59 492 2109 40 2041 2110 41 59 2111 58 492 2112 40 41 59 492 2113 40 41 59 492 2114 40 341 2038 38 2082 44 341 2033 38 2085 41 59 492 2115 40 341 2038 38 2082 44 341 2014 38 2116 41 59 492 2117 40 341 2038 38 2082 41 59 492 2118 40 341 2038 38 2082 44 341 2033 38 2085 41 59 492 2119 40 341 2038 38 2082 44 341 2033 38 2120 61 2033 40 41 41 59 492 2121 40 341 2033 38 2096 41 59 492 2122 40 341 2033 38 2085 41 59 492 2123 40 2066 646 2066 2094 41 59 492 2124 40 341 2069 38 2039 41 59 492 2125 40 341 2033 38 2096 41 59 492 2126 40 341 2033 38 2085 41 59 492 2127 40 2066 646 2066 2094 41 59 492 2128 40 323 2108 41 59 492 2129 40 41 59 618 492 2130 40 2041 2058 44 2041 2131 44 341 2014 38 2132 41 59 492 2133 40 2041 2058 44 341 2033 38 2085 44 323 2134 41 59 492 2135 40 2041 2058 44 341 2038 38 2082 41 59 492 2136 40 2041 2058 44 2066 646 2066 2094 41 59 492 2137 40 2041 2058 44 341 2033 38 2085 41 59 492 2138 40 2041 2058 44 341 2033 38 2096 41 59 492 2139 40 2041 2058 44 323 2140 41 59 492 2141 40 2041 2058 41 59 492 2142 40 2041 2058 44 341 2143 38 2144 41 59 492 2145 40 404 2146 44 341 2043 2047 44 341 2033 38 2104 61 2033 40 41 41 59 492 2147 40 341 2062 38 2063 41 59 492 2148 40 404 2146 44 404 2149 44 341 2033 38 2085 44 323 2134 41 59 492 2150 40 404 2146 44 404 2149 44 2088 2151 41 59 492 2152 40 404 2146 41 59 492 2153 40 404 2146 44 341 2038 38 2154 44 341 2033 38 2155 41 59 492 2156 40 404 2146 44 341 2033 38 2157 44 341 2033 38 2104 41 59 492 2158 40 404 2146 44 2038 2154 41 59 492 2159 40 404 2047 41 59 492 2160 40 404 2146 44 2043 2047 41 59 492 2161 40 2041 2058 44 341 2033 38 2106 44 404 2162 41 59 492 2163 40 404 2164 44 2099 2100 41 59 492 2165 40 2041 2058 41 59 437 58 2000 40 2166 42 2167 44 2018 38 2168 41 59 457 492 2169 40 2027 42 2170 44 341 2088 42 2171 44 341 2088 42 2172 44 2173 2174 44 492 42 2175 41 59 457 492 2176 40 2027 42 2170 44 2041 2058 44 2177 2089 44 341 2088 42 2172 44 2173 2174 44 492 42 2175 41 59 457 492 2178 40 2027 42 2170 44 2041 2058 44 341 2088 42 2179 44 2173 2180 44 492 42 2175 41 59 457 492 2181 40 2027 42 2170 44 2041 2058 44 323 2140 44 492 42 2175 41 59 457 492 2182 40 2027 42 2170 44 2041 2058 44 341 2088 42 2172 44 2173 2174 44 492 42 2175 41 59 457 492 2183 40 2027 42 2170 44 2041 2058 44 2184 2185 44 492 42 2175 41 59 457 492 2186 40 2027 42 2170 44 2041 2058 44 2187 2094 44 492 42 2188 41 59 457 492 2189 40 2027 42 2170 44 2041 2058 44 2190 2089 44 341 2088 42 2191 44 2173 2192 44 492 42 2188 41 59 457 492 2193 40 2027 42 2170 44 2041 2047 44 2041 2049 44 2177 2089 44 341 2088 42 2172 44 2173 2192 44 492 42 2188 41 59 457 492 2194 40 2027 42 44 2041 2047 44 492 42 2175 41 59 457 492 2195 40 2027 42 44 2041 2047 44 2041 2049 44 341 2088 42 2196 44 2173 2192 44 492 42 2175 41 59 457 492 2197 40 2027 42 2170 44 2041 2047 44 2041 2049 44 341 2088 42 2198 44 2173 2192 44 492 42 2188 41 59 457 492 2199 40 2027 42 2170 44 2041 2058 44 341 2088 42 2200 44 2173 2192 44 492 42 2175 41 59 457 492 2201 40 2027 42 2170 44 2041 2058 44 2041 2100 44 492 42 2175 41 59 492 2202 40 404 2047 44 341 2033 38 2085 44 2177 2089 41 59 323 2203 40 2041 2058 44 341 2033 38 2085 44 2177 2089 44 2099 38 2100 41 59 323 2204 40 41 59 492 2205 40 2014 2015 44 2016 42 2206 41 59 492 2207 40 41 59 492 2208 40 41 59 492 2209 40 41 59 492 2210 40 2041 2058 41 59 2033 2211 40 341 2069 38 2058 44 341 2033 38 2085 41 341 59 457 492 2212 40 2027 42 2170 41 59 437 2078 58 492 2213 40 41 59 492 2214 40 41 59 437 58 462 2215 123 492 427 40 41 40 2027 42 2170 41 123 2216 40 2170 41 59 125 125 59 489 2217 61 2218 646 2219 60 2027 44 2215 62 59 2217 2170 59 2218 646 2219 60 2025 62 2220 59 2021 42 2221 61 425 59 2218 646 2219 60 2031 62 2222 59 2223 42 2224 61 425 59 621 415 2029 2225 59 2218 646 2219 60 2166 62 2167 59 2018 38 2019 59 125 59 
118602,C++,"class RawDatabase : QObject
{
    Q_OBJECT

public:
    class Query
    {
    public:
        Query(QString query, QVector<QByteArray> blobs = {},
              const std::function<void(RowId)>& insertCallback = {})
            : query{query.toUtf8()}
            , blobs{blobs}
            , insertCallback{insertCallback}
        {
        }
        Query(QString query, const std::function<void(RowId)>& insertCallback)
            : query{query.toUtf8()}
            , insertCallback{insertCallback}
        {
        }
        Query(QString query, const std::function<void(const QVector<QVariant>&)>& rowCallback)
            : query{query.toUtf8()}
            , rowCallback{rowCallback}
        {
        }
        Query() = default;

    private:
        QByteArray query;
        QVector<QByteArray> blobs;
        std::function<void(RowId)> insertCallback;
        std::function<void(const QVector<QVariant>&)> rowCallback;
        QVector<sqlite3_stmt*> statements;

        friend class RawDatabase;
    };

public:
    enum class SqlCipherParams {
        // keep these sorted in upgrade order
        p3_0, // SQLCipher 3.0 default encryption params
        // SQLCipher 4.0 default params where SQLCipher 3.0 supports them, but 3.0 params where not possible.
        // We accidentally got to this state when attemption to update all databases to 4.0 defaults even when using
        // SQLCipher 3.x, but might as well keep using these for people with SQLCipher 3.x.
        halfUpgradedTo4,
        p4_0 // SQLCipher 4.0 default encryption params
    };

    RawDatabase(const QString& path, const QString& password, const QByteArray& salt);
    ~RawDatabase();
    bool isOpen();

    bool execNow(const QString& statement);
    bool execNow(const Query& statement);
    bool execNow(const QVector<Query>& statements);

    void execLater(const QString& statement);
    void execLater(const Query& statement);
    void execLater(const QVector<Query>& statements);

    void sync();

    static QString toString(SqlCipherParams params)
    {
        switch (params)
        {
        case SqlCipherParams::p3_0:
            return ""3.0 default"";
        case SqlCipherParams::halfUpgradedTo4:
            return ""3.x max compatible"";
        case SqlCipherParams::p4_0:
            return ""4.0 default"";
        }
        assert(false);
        return {};
    }

public slots:
    bool setPassword(const QString& password);
    bool rename(const QString& newPath);
    bool remove();

protected slots:
    bool open(const QString& path, const QString& hexKey = {});
    void close();
    void process();

private:
    QString anonymizeQuery(const QByteArray& query);
    bool openEncryptedDatabaseAtLatestSupportedVersion(const QString& hexKey);
    bool updateSavedCipherParameters(const QString& hexKey, SqlCipherParams newParams);
    bool setCipherParameters(SqlCipherParams params, const QString& database = {});
    SqlCipherParams highestSupportedParams();
    SqlCipherParams readSavedCipherParams(const QString& hexKey, SqlCipherParams newParams);
    bool setKey(const QString& hexKey);
    int getUserVersion();
    bool encryptDatabase(const QString& newHexKey);
    bool decryptDatabase();
    bool commitDbSwap(const QString& hexKey);
    bool testUsable();

protected:
    static QString deriveKey(const QString& password, const QByteArray& salt);
    static QString deriveKey(const QString& password);
    static QVariant extractData(sqlite3_stmt* stmt, int col);
    static void regexpInsensitive(sqlite3_context* ctx, int argc, sqlite3_value** argv);
    static void regexpSensitive(sqlite3_context* ctx, int argc, sqlite3_value** argv);

private:
    static void regexp(sqlite3_context* ctx, int argc, sqlite3_value** argv, const QRegularExpression::PatternOptions cs);

    struct Transaction
    {
        QVector<Query> queries;
        std::atomic_bool* success = nullptr;
        std::atomic_bool* done = nullptr;
    };

private:
    sqlite3* sqlite;
    std::unique_ptr<QThread> workerThread;
    QQueue<Transaction> pendingTransactions;
    QMutex transactionsMutex;
    QString path;
    QByteArray currentSalt;
    QString currentHexKey;
};",1,334 2000 58 2001 123 2002 439 58 334 2003 123 439 58 2003 40 2004 2005 44 2006 60 2007 62 2008 61 123 125 44 341 2009 646 389 60 492 40 2010 41 62 38 2011 61 123 125 41 58 2005 123 2005 46 2012 40 41 125 44 2008 123 2008 125 44 2011 123 2011 125 123 125 2003 40 2004 2005 44 341 2009 646 389 60 492 40 2010 41 62 38 2011 41 58 2005 123 2005 46 2013 40 41 125 44 2011 123 2011 125 123 125 2003 40 2004 2005 44 341 2009 646 389 60 492 40 341 2006 60 2014 62 38 41 62 38 2015 41 58 2005 123 2005 46 2016 40 41 125 44 2015 123 2015 125 123 125 2003 40 41 61 349 59 437 58 2007 2005 59 2006 60 2007 62 2008 59 2009 646 389 60 492 40 2010 41 62 2011 59 2009 646 389 60 492 40 341 2006 60 2014 62 38 41 62 2015 59 2006 60 2017 42 62 2018 59 387 334 2000 59 125 59 439 58 370 334 2019 123 621 2020 44 621 621 621 621 2021 44 2022 621 125 59 2000 40 341 2023 38 2024 44 341 2023 38 2025 44 341 2026 38 2027 41 59 126 2000 40 41 59 323 2028 40 41 59 323 2029 40 341 2023 38 2030 41 59 323 2029 40 341 2003 38 2030 41 59 323 2029 40 341 2031 60 2003 62 38 2032 41 59 492 2033 40 341 2023 38 2030 41 59 492 2033 40 341 2003 38 2030 41 59 492 2033 40 341 2031 60 2003 62 38 2032 41 59 492 2034 40 41 59 457 2023 2035 40 2019 433 41 123 464 40 433 41 123 328 2019 646 2036 58 450 648 59 328 2019 646 2037 58 450 648 59 328 2019 646 2038 58 450 648 59 125 313 40 380 41 59 450 123 125 59 125 439 2039 58 323 2040 40 341 2023 38 2025 41 59 323 2041 40 341 2023 38 2042 41 59 323 2043 40 41 59 438 2039 58 323 2044 40 341 2023 38 2024 44 341 2023 38 2045 61 123 125 41 59 492 2046 40 41 59 492 2047 40 41 59 437 58 2023 2048 40 341 2026 38 2049 41 59 323 2050 40 341 2023 38 2045 41 59 323 2051 40 341 2023 38 2045 44 2019 2052 41 59 323 2053 40 2019 433 44 341 2023 38 2054 61 123 125 41 59 2019 2055 40 41 59 2019 2056 40 341 2023 38 2045 44 2019 2052 41 59 323 2057 40 341 2023 38 2045 41 59 404 2058 40 41 59 323 2059 40 341 2023 38 2060 41 59 323 2061 40 41 59 323 2062 40 341 2023 38 2045 41 59 323 2063 40 41 59 438 58 457 2023 2064 40 341 2023 38 2025 44 341 2026 38 2027 41 59 457 2023 2064 40 341 2023 38 2025 41 59 457 2065 2066 40 2067 42 2068 44 404 2069 41 59 457 492 2070 40 2071 42 2072 44 404 2073 44 2074 42 42 2075 41 59 457 492 2076 40 2071 42 2072 44 404 2073 44 2074 42 42 2075 41 59 437 58 457 492 2077 40 2071 42 2072 44 404 2073 44 2074 42 42 2075 44 341 2078 646 2079 2080 41 59 462 2081 123 2031 60 2003 62 2082 59 2083 646 2084 42 2085 61 425 59 2083 646 2084 42 2086 61 425 59 125 59 437 58 2087 42 2088 59 2089 646 2090 60 2091 62 2092 59 2093 60 2081 62 2094 59 2095 2096 59 2023 2024 59 2026 2097 59 2023 2098 59 125 59 
117560,C++,"class LandDetector : public ModuleBase<LandDetector>, ModuleParams, px4::ScheduledWorkItem
{
public:
	LandDetector();
	virtual ~LandDetector();

	/** @see ModuleBase */
	static int custom_command(int argc, char *argv[])
	{
		return print_usage(""unknown command"");
	}

	/** @see ModuleBase */
	static int print_usage(const char *reason = nullptr);

	/** @see ModuleBase::print_status() */
	int print_status() override;

	/**
	 * Get the work queue going.
	 */
	void start();

	static int task_spawn(int argc, char *argv[]);

protected:

	/**
	 * Updates parameters.
	 */
	virtual void _update_params() {};

	/**
	 * Updates subscribed uORB topics.
	 */
	virtual void _update_topics() {};

	/**
	 * @return true if UAV is in a landed state.
	 */
	virtual bool _get_landed_state() = 0;

	/**
	 * @return true if UAV is in almost landed state
	 */
	virtual bool _get_maybe_landed_state() { return false; }

	/**
	 * @return true if UAV is touching ground but not landed
	 */
	virtual bool _get_ground_contact_state() { return false; }

	/**
	 * @return true if UAV is in free-fall state.
	 */
	virtual bool _get_freefall_state() { return false; }

	/**
	 *  @return maximum altitude that can be reached
	 */
	virtual float _get_max_altitude() { return INFINITY; }

	/**
	 *  @return true if vehicle could be in ground effect (close to ground)
	 */
	virtual bool _get_ground_effect_state() { return false; }

	virtual bool _get_in_descend() { return false; }
	virtual bool _get_has_low_throttle() { return false; }
	virtual bool _get_horizontal_movement() { return false; }
	virtual bool _get_vertical_movement() { return false; }
	virtual bool _get_close_to_ground_or_skipped_check() {  return false; }
	virtual void _set_hysteresis_factor(const int factor) = 0;

	systemlib::Hysteresis _freefall_hysteresis{false};
	systemlib::Hysteresis _landed_hysteresis{true};
	systemlib::Hysteresis _maybe_landed_hysteresis{true};
	systemlib::Hysteresis _ground_contact_hysteresis{true};
	systemlib::Hysteresis _ground_effect_hysteresis{false};

	vehicle_local_position_s _vehicle_local_position{};
	vehicle_status_s         _vehicle_status{};

	matrix::Vector3f _acceleration{};

	bool _armed{false};
	bool _previous_armed_state{false};	///< stores the previous actuator_armed.armed state
	bool _dist_bottom_is_observable{false};

private:
	void Run() override;

	vehicle_land_detected_s _land_detected = {
		.timestamp = 0,
		.alt_max = -1.0f,
		.freefall = false,
		.ground_contact = true,
		.maybe_landed = true,
		.landed = true,
	};

	hrt_abstime _takeoff_time{0};
	hrt_abstime _total_flight_time{0};	///< total vehicle flight time in microseconds

	perf_counter_t _cycle_perf{perf_alloc(PC_ELAPSED, MODULE_NAME"": cycle"")};

	uORB::Publication<vehicle_land_detected_s> _vehicle_land_detected_pub{ORB_ID(vehicle_land_detected)};

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};

	uORB::Subscription _actuator_armed_sub{ORB_ID(actuator_armed)};
	uORB::Subscription _vehicle_acceleration_sub{ORB_ID(vehicle_acceleration)};
	uORB::Subscription _vehicle_status_sub{ORB_ID(vehicle_status)};

	uORB::SubscriptionCallbackWorkItem _vehicle_local_position_sub{this, ORB_ID(vehicle_local_position)};

	DEFINE_PARAMETERS_CUSTOM_PARENT(
		ModuleParams,
		(ParamInt<px4::params::LND_FLIGHT_T_HI>) _param_total_flight_time_high,
		(ParamInt<px4::params::LND_FLIGHT_T_LO>) _param_total_flight_time_low
	);
};",1,334 2000 58 439 2001 60 2000 62 44 2002 44 2003 646 2004 123 439 58 2000 40 41 59 491 126 2000 40 41 59 618 457 404 2005 40 404 2006 44 330 42 2007 91 93 41 123 450 2008 40 648 41 59 125 618 457 404 2009 40 341 330 42 2010 61 425 41 59 618 404 2011 40 41 431 59 618 492 2012 40 41 59 457 404 2013 40 404 2006 44 330 42 2007 91 93 41 59 438 58 618 491 492 2014 40 41 123 125 59 618 491 492 2015 40 41 123 125 59 618 491 323 2016 40 41 61 1500 59 618 491 323 2017 40 41 123 450 380 59 125 618 491 323 2018 40 41 123 450 380 59 125 618 491 323 2019 40 41 123 450 380 59 125 618 491 384 2020 40 41 123 450 2021 59 125 618 491 323 2022 40 41 123 450 380 59 125 491 323 2023 40 41 123 450 380 59 125 491 323 2024 40 41 123 450 380 59 125 491 323 2025 40 41 123 450 380 59 125 491 323 2026 40 41 123 450 380 59 125 491 323 2027 40 41 123 450 380 59 125 491 492 2028 40 341 404 2029 41 61 1500 59 2030 646 2031 2032 123 380 125 59 2030 646 2031 2033 123 473 125 59 2030 646 2031 2034 123 473 125 59 2030 646 2031 2035 123 473 125 59 2030 646 2031 2036 123 380 125 59 2037 2038 123 125 59 2039 2040 123 125 59 2041 646 2042 2043 123 125 59 323 2044 123 380 125 59 323 2045 123 380 125 59 621 323 2046 123 380 125 59 437 58 492 2047 40 41 431 59 2048 2049 61 123 46 2050 61 1500 44 46 2051 61 45 1501 44 46 2052 61 380 44 46 2053 61 473 44 46 2054 61 473 44 46 2055 61 473 44 125 59 2056 2057 123 1500 125 59 2056 2058 123 1500 125 59 621 2059 2060 123 2061 40 2062 44 2063 648 41 125 59 2064 646 2065 60 2048 62 2066 123 2067 40 2068 41 125 59 2064 646 2069 2070 123 2071 40 2072 41 44 1501 125 59 2064 646 2073 2074 123 2075 40 2076 41 125 59 2064 646 2073 2077 123 2078 40 2079 41 125 59 2064 646 2073 2080 123 2081 40 2082 41 125 59 2064 646 2083 2084 123 467 44 2085 40 2086 41 125 59 2087 40 2002 44 40 2088 60 2003 646 433 646 2089 62 41 2090 44 40 2088 60 2003 646 433 646 2091 62 41 2092 41 59 125 59 
117563,C++,"class MavlinkStream : public ListNode<MavlinkStream *>
{

public:

	MavlinkStream(Mavlink *mavlink);
	virtual ~MavlinkStream() = default;

	// no copy, assignment, move, move assignment
	MavlinkStream(const MavlinkStream &) = delete;
	MavlinkStream &operator=(const MavlinkStream &) = delete;
	MavlinkStream(MavlinkStream &&) = delete;
	MavlinkStream &operator=(MavlinkStream &&) = delete;

	/**
	 * Get the interval
	 *
	 * @param interval the interval in microseconds (us) between messages
	 */
	void set_interval(const int interval) { _interval = interval; }

	/**
	 * Get the interval
	 *
	 * @return the inveral in microseconds (us) between messages
	 */
	int get_interval() { return _interval; }

	/**
	 * @return 0 if updated / sent, -1 if unchanged
	 */
	int update(const hrt_abstime &t);
	virtual const char *get_name() const = 0;
	virtual uint16_t get_id() = 0;

	/**
	 * @return true if steam rate shouldn't be adjusted
	 */
	virtual bool const_rate() { return false; }

	/**
	 * Get maximal total messages size on update
	 */
	virtual unsigned get_size() = 0;

	/**
	 * This function is called in response to a MAV_CMD_REQUEST_MESSAGE command.
	 */
	virtual bool request_message(float param2 = 0.0, float param3 = 0.0, float param4 = 0.0,
				     float param5 = 0.0, float param6 = 0.0, float param7 = 0.0)
	{
		return send();
	}

	/**
	 * Get the average message size
	 *
	 * For a normal stream this equals the message size,
	 * for something like a parameter or mission message
	 * this equals usually zero, as no bandwidth
	 * needs to be reserved
	 */
	virtual unsigned get_size_avg() { return get_size(); }

	/**
	 * @return true if the first message of this stream has been sent
	 */
	bool first_message_sent() const { return _first_message_sent; }

	/**
	 * Reset the time of last sent to 0. Can be used if a message over this
	 * stream needs to be sent immediately.
	 */
	void reset_last_sent() { _last_sent = 0; }

protected:
	Mavlink      *const _mavlink;
	int _interval{1000000};		///< if set to negative value = unlimited rate

	virtual bool send() = 0;

	/**
	 * Function to collect/update data for the streams at a high rate independant of
	 * actual stream rate.
	 *
	 * This function is called at every iteration of the mavlink module.
	 */
	virtual void update_data() { }

private:
	hrt_abstime _last_sent{0};
	bool _first_message_sent{false};
};",1,334 2000 58 439 2001 60 2000 42 62 123 439 58 2000 40 2002 42 2003 41 59 491 126 2000 40 41 61 349 59 621 2000 40 341 2000 38 41 61 353 59 2000 38 427 61 40 341 2000 38 41 61 353 59 2000 40 2000 605 41 61 353 59 2000 38 427 61 40 2000 605 41 61 353 59 618 492 2004 40 341 404 2005 41 123 2006 61 2005 59 125 618 404 2007 40 41 123 450 2008 59 125 618 404 2009 40 341 2010 38 2011 41 59 491 341 330 42 2012 40 41 341 61 1500 59 491 2013 2014 40 41 61 1500 59 618 491 323 2015 40 41 123 450 380 59 125 618 491 486 2016 40 41 61 1500 59 618 491 323 2017 40 384 2018 61 1500 44 384 2019 61 1500 44 384 2020 61 1500 44 384 2021 61 1500 44 384 2022 61 1500 44 384 2023 61 1500 41 123 450 2024 40 41 59 125 618 491 486 2025 40 41 123 450 2016 40 41 59 125 618 323 2026 40 41 341 123 450 2027 59 125 618 492 2028 40 41 123 2029 61 1500 59 125 438 58 2002 42 341 2030 59 404 2031 123 1507 125 59 621 491 323 2032 40 41 61 1500 59 618 491 492 2033 40 41 123 125 437 58 2010 2034 123 1500 125 59 323 2035 123 380 125 59 125 59 
117641,C++,"class RoverPositionControl final : public ModuleBase<RoverPositionControl>, public ModuleParams, public px4::WorkItem
{
public:
	RoverPositionControl();
	~RoverPositionControl();
	RoverPositionControl(const RoverPositionControl &) = delete;
	RoverPositionControl operator=(const RoverPositionControl &other) = delete;

	/** @see ModuleBase */
	static int task_spawn(int argc, char *argv[]);

	/** @see ModuleBase */
	static int custom_command(int argc, char *argv[]);

	/** @see ModuleBase */
	static int print_usage(const char *reason = nullptr);

	bool init();

private:
	void Run() override;

	uORB::SubscriptionCallbackWorkItem _vehicle_angular_velocity_sub{this, ORB_ID(vehicle_angular_velocity)};

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};

	uORB::Publication<vehicle_attitude_setpoint_s>	_attitude_sp_pub{ORB_ID(vehicle_attitude_setpoint)};
	uORB::Publication<position_controller_status_s>	_pos_ctrl_status_pub{ORB_ID(position_controller_status)};  /**< navigation capabilities publication */
	uORB::Publication<actuator_controls_s>		_actuator_controls_pub{ORB_ID(actuator_controls_0)};  /**< actuator controls publication */

	uORB::Subscription _control_mode_sub{ORB_ID(vehicle_control_mode)}; /**< control mode subscription */
	uORB::Subscription _global_pos_sub{ORB_ID(vehicle_global_position)};
	uORB::Subscription _local_pos_sub{ORB_ID(vehicle_local_position)};
	uORB::Subscription _manual_control_setpoint_sub{ORB_ID(manual_control_setpoint)}; /**< notification of manual control updates */
	uORB::Subscription _pos_sp_triplet_sub{ORB_ID(position_setpoint_triplet)};
	uORB::Subscription _att_sub{ORB_ID(vehicle_attitude)};
	uORB::Subscription _att_sp_sub{ORB_ID(vehicle_attitude_setpoint)};
	uORB::Subscription _trajectory_setpoint_sub{ORB_ID(trajectory_setpoint)};

	manual_control_setpoint_s		_manual_control_setpoint{};			    /**< r/c channel data */
	position_setpoint_triplet_s		_pos_sp_triplet{};		/**< triplet of mission items */
	vehicle_attitude_setpoint_s		_att_sp{};			/**< attitude setpoint > */
	vehicle_control_mode_s			_control_mode{};		/**< control mode */
	vehicle_global_position_s		_global_pos{};			/**< global vehicle position */
	vehicle_local_position_s		_local_pos{};			/**< global vehicle position */
	actuator_controls_s				_act_controls{};		/**< direct control of actuators */
	vehicle_attitude_s				_vehicle_att{};
	vehicle_local_position_setpoint_s       _trajectory_setpoint{};

	uORB::SubscriptionData<vehicle_acceleration_s>		_vehicle_acceleration_sub{ORB_ID(vehicle_acceleration)};

	perf_counter_t	_loop_perf;			/**< loop performance counter */

	hrt_abstime _control_position_last_called{0}; 	/**<last call of control_position  */
	hrt_abstime _manual_setpoint_last_called{0};

	MapProjection _global_local_proj_ref{};
	float                      _global_local_alt0{NAN};

	/* Pid controller for the speed. Here we assume we can control airspeed but the control variable is actually on
	 the throttle. For now just assuming a proportional scaler between controlled airspeed and throttle output.*/
	PID_t _speed_ctrl{};

	// estimator reset counters
	uint8_t _pos_reset_counter{0};		// captures the number of times the estimator has reset the horizontal position

	ECL_L1_Pos_Controller				_gnd_control;

	enum UGV_POSCTRL_MODE {
		UGV_POSCTRL_MODE_AUTO,
		UGV_POSCTRL_MODE_OTHER
	} _control_mode_current{UGV_POSCTRL_MODE_OTHER};			///< used to check the mode in the last control loop iteration. Use to check if the last iteration was in the same mode.


	enum POS_CTRLSTATES {
		GOTO_WAYPOINT,
		STOPPING
	} _pos_ctrl_state {STOPPING};			/// Position control state machine

	/* previous waypoint */
	matrix::Vector2d _prev_wp{0, 0};

	enum class VelocityFrame {
		NED,
		BODY,
	} _velocity_frame{VelocityFrame::NED};

	float _manual_yaw_sp{0.0};
	bool _reset_yaw_sp{true};

	DEFINE_PARAMETERS(
		(ParamFloat<px4::params::GND_L1_PERIOD>) _param_l1_period,
		(ParamFloat<px4::params::GND_L1_DAMPING>) _param_l1_damping,
		(ParamFloat<px4::params::GND_L1_DIST>) _param_l1_distance,

		(ParamFloat<px4::params::GND_SPEED_TRIM>) _param_gndspeed_trim,
		(ParamFloat<px4::params::GND_SPEED_MAX>) _param_gndspeed_max,

		(ParamInt<px4::params::GND_SP_CTRL_MODE>) _param_speed_control_mode,
		(ParamFloat<px4::params::GND_SPEED_P>) _param_speed_p,
		(ParamFloat<px4::params::GND_SPEED_I>) _param_speed_i,
		(ParamFloat<px4::params::GND_SPEED_D>) _param_speed_d,
		(ParamFloat<px4::params::GND_SPEED_IMAX>) _param_speed_imax,
		(ParamFloat<px4::params::GND_SPEED_THR_SC>) _param_throttle_speed_scaler,

		(ParamFloat<px4::params::GND_THR_MIN>) _param_throttle_min,
		(ParamFloat<px4::params::GND_THR_MAX>) _param_throttle_max,
		(ParamFloat<px4::params::GND_THR_CRUISE>) _param_throttle_cruise,

		(ParamFloat<px4::params::GND_WHEEL_BASE>) _param_wheel_base,
		(ParamFloat<px4::params::GND_MAX_ANG>) _param_max_turn_angle,
		(ParamFloat<px4::params::GND_MAN_Y_MAX>) _param_gnd_man_y_max,
		(ParamFloat<px4::params::NAV_LOITER_RAD>) _param_nav_loiter_rad	/**< loiter radius for Rover */
	)

	/**
	 * Update our local parameter cache.
	 */
	void parameters_update(bool force = false);

	void		position_setpoint_triplet_poll();
	void		attitude_setpoint_poll();
	void		vehicle_control_mode_poll();
	void 		vehicle_attitude_poll();
	void		manual_control_setpoint_poll();

	/**
	 * Control position.
	 */
	bool		control_position(const matrix::Vector2d &global_pos, const matrix::Vector3f &ground_speed,
					 const position_setpoint_triplet_s &_pos_sp_triplet);
	void		control_velocity(const matrix::Vector3f &current_velocity);
	void		control_attitude(const vehicle_attitude_s &att, const vehicle_attitude_setpoint_s &att_sp);

};",1,334 2000 381 58 439 2001 60 2000 62 44 439 2002 44 439 2003 646 2004 123 439 58 2000 40 41 59 126 2000 40 41 59 2000 40 341 2000 38 41 61 353 59 2000 427 61 40 341 2000 38 2005 41 61 353 59 618 457 404 2006 40 404 2007 44 330 42 2008 91 93 41 59 618 457 404 2009 40 404 2007 44 330 42 2008 91 93 41 59 618 457 404 2010 40 341 330 42 2011 61 425 41 59 323 2012 40 41 59 437 58 492 2013 40 41 431 59 2014 646 2015 2016 123 467 44 2017 40 2018 41 125 59 2014 646 2019 2020 123 2021 40 2022 41 44 1501 125 59 2014 646 2023 60 2024 62 2025 123 2026 40 2027 41 125 59 2014 646 2023 60 2028 62 2029 123 2030 40 2031 41 125 59 618 2014 646 2023 60 2032 62 2033 123 2034 40 2035 41 125 59 618 2014 646 2036 2037 123 2038 40 2039 41 125 59 618 2014 646 2036 2040 123 2041 40 2042 41 125 59 2014 646 2036 2043 123 2044 40 2045 41 125 59 2014 646 2036 2046 123 2047 40 2048 41 125 59 618 2014 646 2036 2049 123 2050 40 2051 41 125 59 2014 646 2036 2052 123 2053 40 2054 41 125 59 2014 646 2036 2055 123 2056 40 2057 41 125 59 2014 646 2036 2058 123 2059 40 2060 41 125 59 2061 2062 123 125 59 618 2063 2064 123 125 59 618 2024 2065 123 125 59 618 2066 2067 123 125 59 618 2068 2069 123 125 59 618 2070 2071 123 125 59 618 2032 2072 123 125 59 618 2073 2074 123 125 59 2075 2076 123 125 59 2014 646 2077 60 2078 62 2079 123 2080 40 2081 41 125 59 2082 2083 59 618 2084 2085 123 1500 125 59 618 2084 2086 123 1500 125 59 2087 2088 123 125 59 384 2089 123 2090 125 59 604 2091 2092 123 125 59 621 2093 2094 123 1500 125 59 621 2095 2096 59 370 2097 123 2098 44 2099 125 2100 123 2101 125 59 621 370 2102 123 2103 44 2104 125 2105 123 2106 125 59 621 604 2107 646 2108 2109 123 1500 44 1500 125 59 370 334 2110 123 2111 44 2112 44 125 2113 123 2110 646 2114 125 59 384 2115 123 1500 125 59 323 2116 123 473 125 59 2117 40 40 2118 60 2003 646 433 646 2119 62 41 2120 44 40 2118 60 2003 646 433 646 2121 62 41 2122 44 40 2118 60 2003 646 433 646 2123 62 41 2124 44 40 2118 60 2003 646 433 646 2125 62 41 2126 44 40 2118 60 2003 646 433 646 2127 62 41 2128 44 40 2129 60 2003 646 433 646 2130 62 41 2131 44 40 2118 60 2003 646 433 646 2132 62 41 2133 44 40 2118 60 2003 646 433 646 2134 62 41 2135 44 40 2118 60 2003 646 433 646 2136 62 41 2137 44 40 2118 60 2003 646 433 646 2138 62 41 2139 44 40 2118 60 2003 646 433 646 2140 62 41 2141 44 40 2118 60 2003 646 433 646 2142 62 41 2143 44 40 2118 60 2003 646 433 646 2144 62 41 2145 44 40 2118 60 2003 646 433 646 2146 62 41 2147 44 40 2118 60 2003 646 433 646 2148 62 41 2149 44 40 2118 60 2003 646 433 646 2150 62 41 2151 44 40 2118 60 2003 646 433 646 2152 62 41 2153 44 40 2118 60 2003 646 433 646 2154 62 41 2155 618 41 618 492 2156 40 323 2157 61 380 41 59 492 2158 40 41 59 492 2159 40 41 59 492 2160 40 41 59 492 2161 40 41 59 492 2162 40 41 59 618 323 2163 40 341 2107 646 2108 38 2164 44 341 2107 646 2165 38 2166 44 341 2063 38 2064 41 59 492 2167 40 341 2107 646 2165 38 2168 41 59 492 2169 40 341 2073 38 2170 44 341 2024 38 2171 41 59 125 59 
117544,C++,"class Magnetometer
{
public:
	static constexpr int MAX_SENSOR_COUNT = 4;

	static constexpr uint8_t DEFAULT_PRIORITY = 50;
	static constexpr uint8_t DEFAULT_EXTERNAL_PRIORITY = 75;

	static constexpr const char *SensorString() { return ""MAG""; }

	Magnetometer();
	explicit Magnetometer(uint32_t device_id, bool external = false);

	~Magnetometer() = default;

	void PrintStatus();

	void set_calibration_index(uint8_t calibration_index) { _calibration_index = calibration_index; }
	void set_device_id(uint32_t device_id, bool external = false);
	void set_external(bool external = true);
	bool set_offset(const matrix::Vector3f &offset);
	bool set_scale(const matrix::Vector3f &scale);
	bool set_offdiagonal(const matrix::Vector3f &offdiagonal);
	void set_rotation(Rotation rotation);
	void set_temperature(float temperature) { _temperature = temperature; };

	bool calibrated() const { return (_device_id != 0) && (_calibration_index >= 0); }
	uint8_t calibration_count() const { return _calibration_count; }
	int8_t calibration_index() const { return _calibration_index; }
	uint32_t device_id() const { return _device_id; }
	bool enabled() const { return (_priority > 0); }
	bool external() const { return _external; }
	const matrix::Vector3f &offset() const { return _offset; }
	const int32_t &priority() const { return _priority; }
	const matrix::Dcmf &rotation() const { return _rotation; }
	const Rotation &rotation_enum() const { return _rotation_enum; }
	const matrix::Matrix3f &scale() const { return _scale; }

	// apply offsets and scale
	// rotate corrected measurements from sensor to body frame
	inline matrix::Vector3f Correct(const matrix::Vector3f &data) const
	{
		return _rotation * (_scale * ((data + _power * _power_compensation) - _offset));
	}

	// Compute sensor offset from bias (board frame)
	matrix::Vector3f BiasCorrectedSensorOffset(const matrix::Vector3f &bias) const
	{
		return _scale.I() * _rotation.I() * bias + _offset;
	}

	bool ParametersSave();
	void ParametersUpdate();

	void Reset();

	void UpdatePower(float power) { _power = power; }

private:
	static constexpr float TEMPERATURE_INVALID = -1000.f;

	Rotation _rotation_enum{ROTATION_NONE};

	matrix::Dcmf _rotation;
	matrix::Vector3f _offset;
	matrix::Matrix3f _scale;
	matrix::Vector3f _power_compensation;
	float _power{0.f};
	float _temperature{NAN};

	int8_t _calibration_index{-1};
	uint32_t _device_id{0};
	int32_t _priority{-1};

	bool _external{false};

	uint8_t _calibration_count{0};
};",1,334 2000 123 439 58 457 343 404 2001 61 1502 59 457 343 2002 2003 61 1503 59 457 343 2002 2004 61 1503 59 457 343 341 330 42 2005 40 41 123 450 648 59 125 2000 40 41 59 376 2000 40 2006 2007 44 323 2008 61 380 41 59 126 2000 40 41 61 349 59 492 2009 40 41 59 492 2010 40 2002 2011 41 123 2012 61 2011 59 125 492 2013 40 2006 2007 44 323 2008 61 380 41 59 492 2014 40 323 2008 61 473 41 59 323 2015 40 341 2016 646 2017 38 2018 41 59 323 2019 40 341 2016 646 2017 38 2020 41 59 323 2021 40 341 2016 646 2017 38 2022 41 59 492 2023 40 2024 2025 41 59 492 2026 40 384 2027 41 123 2028 61 2027 59 125 59 323 2029 40 41 341 123 450 40 2030 631 1500 41 605 40 2031 615 1500 41 59 125 2002 2032 40 41 341 123 450 2033 59 125 2034 2011 40 41 341 123 450 2035 59 125 2006 2007 40 41 341 123 450 2036 59 125 323 2037 40 41 341 123 450 40 2038 62 1500 41 59 125 323 2008 40 41 341 123 450 2039 59 125 341 2016 646 2017 38 2018 40 41 341 123 450 2040 59 125 341 2041 38 2042 40 41 341 123 450 2043 59 125 341 2016 646 2044 38 2025 40 41 341 123 450 2045 59 125 341 2024 38 2046 40 41 341 123 450 2047 59 125 341 2016 646 2048 38 2020 40 41 341 123 450 2049 59 125 621 621 401 2016 646 2017 2050 40 341 2016 646 2017 38 2051 41 341 123 450 2052 42 40 2053 42 40 40 2051 43 2054 42 2055 41 45 2056 41 41 59 125 621 2016 646 2017 2057 40 341 2016 646 2017 38 2058 41 341 123 450 2059 46 2060 40 41 42 2061 46 2060 40 41 42 2058 43 2062 59 125 323 2063 40 41 59 492 2064 40 41 59 492 2065 40 41 59 492 2066 40 384 2067 41 123 2068 61 2067 59 125 437 58 457 343 384 2069 61 45 1504 59 2024 2070 123 2071 125 59 2016 646 2044 2072 59 2016 646 2017 2073 59 2016 646 2048 2074 59 2016 646 2017 2075 59 384 2076 123 1500 125 59 384 2077 123 2078 125 59 2034 2079 123 45 1501 125 59 2006 2080 123 1500 125 59 2041 2081 123 45 1501 125 59 323 2082 123 380 125 59 2002 2083 123 1500 125 59 125 59 
118460,C++,"class GroupInviteForm : public QWidget
{
    Q_OBJECT
public:
    GroupInviteForm();
    ~GroupInviteForm();

    void show(ContentLayout* contentLayout);
    bool addGroupInvite(const GroupInvite& inviteInfo);
    bool isShown() const;

signals:
    void groupCreate(uint8_t type);
    void groupInviteAccepted(const GroupInvite& inviteInfo);
    void groupInvitesSeen();

protected:
    void showEvent(QShowEvent* event) final;

private:
    void retranslateUi();
    void deleteInviteWidget(const GroupInvite& inviteInfo);

private:
    QWidget* headWidget;
    QLabel* headLabel;
    QPushButton* createButton;
    QGroupBox* inviteBox;
    QList<GroupInviteWidget*> invites;
    QScrollArea* scroll;
};",1,334 2000 58 439 2001 123 2002 439 58 2000 40 41 59 126 2000 40 41 59 492 2003 40 2004 42 2005 41 59 323 2006 40 341 2007 38 2008 41 59 323 2009 40 41 341 59 2010 58 492 2011 40 2012 2013 41 59 492 2014 40 341 2007 38 2008 41 59 492 2015 40 41 59 438 58 492 2016 40 2017 42 373 41 381 59 437 58 492 2018 40 41 59 492 2019 40 341 2007 38 2008 41 59 437 58 2001 42 2020 59 2021 42 2022 59 2023 42 2024 59 2025 42 2026 59 2027 60 2028 42 62 2029 59 2030 42 2031 59 125 59 
118522,C++,"class ChatMessage : public ChatLine
{
public:
    using Ptr = std::shared_ptr<ChatMessage>;

    enum SystemMessageType
    {
        INFO,
        ERROR,
        TYPING,
    };

    enum MessageType
    {
        NORMAL,
        ACTION,
        ALERT,
    };

    ChatMessage();
    ~ChatMessage();
    ChatMessage(const ChatMessage&) = default;
    ChatMessage& operator=(const ChatMessage&) = default;
    ChatMessage(ChatMessage&&) = default;

    static ChatMessage::Ptr createChatMessage(const QString& sender, const QString& rawMessage,
                                              MessageType type, bool isMe, MessageState state,
                                              const QDateTime& date, bool colorizeName = false);
    static ChatMessage::Ptr createChatInfoMessage(const QString& rawMessage, SystemMessageType type,
                                                  const QDateTime& date);
    static ChatMessage::Ptr createFileTransferMessage(const QString& sender, CoreFile& coreFile,
                                                      ToxFile file, bool isMe, const QDateTime& date);
    static ChatMessage::Ptr createTypingNotification();
    static ChatMessage::Ptr createBusyNotification();

    void markAsDelivered(const QDateTime& time);
    void markAsBroken();
    QString toString() const;
    bool isAction() const;
    void setAsAction();
    void hideSender();
    void hideDate();

protected:
    static QString detectQuotes(const QString& str, MessageType type);
    static QString wrapDiv(const QString& str, const QString& div);

private:
    bool action = false;
};",1,334 2000 58 439 2001 123 439 58 489 2002 61 2003 646 2004 60 2000 62 59 370 2005 123 2006 44 2007 44 2008 44 125 59 370 2009 123 2010 44 2011 44 2012 44 125 59 2000 40 41 59 126 2000 40 41 59 2000 40 341 2000 38 41 61 349 59 2000 38 427 61 40 341 2000 38 41 61 349 59 2000 40 2000 605 41 61 349 59 457 2000 646 2002 2013 40 341 2014 38 2015 44 341 2014 38 2016 44 2009 2017 44 323 2018 44 2019 2020 44 341 2021 38 2022 44 323 2023 61 380 41 59 457 2000 646 2002 2024 40 341 2014 38 2016 44 2005 2017 44 341 2021 38 2022 41 59 457 2000 646 2002 2025 40 341 2014 38 2015 44 2026 38 2027 44 2028 2029 44 323 2018 44 341 2021 38 2022 41 59 457 2000 646 2002 2030 40 41 59 457 2000 646 2002 2031 40 41 59 492 2032 40 341 2021 38 2033 41 59 492 2034 40 41 59 2014 2035 40 41 341 59 323 2036 40 41 341 59 492 2037 40 41 59 492 2038 40 41 59 492 2039 40 41 59 438 58 457 2014 2040 40 341 2014 38 2041 44 2009 2017 41 59 457 2014 2042 40 341 2014 38 2041 44 341 2014 38 2043 41 59 437 58 323 2044 61 380 59 125 59 
118514,C++,"class AddFriendForm : public QObject
{
    Q_OBJECT
public:
    enum Mode
    {
        AddFriend = 0,
        ImportContacts = 1,
        FriendRequest = 2
    };

    AddFriendForm(ToxId _ownId);
    AddFriendForm(const AddFriendForm&) = delete;
    AddFriendForm& operator=(const AddFriendForm&) = delete;
    ~AddFriendForm();

    bool isShown() const;
    void show(ContentLayout* contentLayout);
    void setMode(Mode mode);

    bool addFriendRequest(const QString& friendAddress, const QString& message);

signals:
    void friendRequested(const ToxId& friendAddress, const QString& message);
    void friendRequestAccepted(const ToxPk& friendAddress);
    void friendRequestsSeen();

public slots:
    void onUsernameSet(const QString& userName);

private slots:
    void onSendTriggered();
    void onIdChanged(const QString& id);
    void onImportSendClicked();
    void onImportOpenClicked();
    void onFriendRequestAccepted();
    void onFriendRequestRejected();
    void onCurrentChanged(int index);

private:
    void addFriend(const QString& idText);
    void retranslateUi();
    void addFriendRequestWidget(const QString& friendAddress, const QString& message);
    void removeFriendRequestWidget(QWidget* friendWidget);
    void retranslateAcceptButton(QPushButton* acceptButton);
    void retranslateRejectButton(QPushButton* rejectButton);
    void deleteFriendRequest(const ToxId& toxId);
    void setIdFromClipboard();
    QString getMessage() const;
    QString getImportMessage() const;

private:
    QLabel headLabel;
    QLabel toxIdLabel;
    QLabel messageLabel;
    QLabel importFileLabel;
    QLabel importMessageLabel;

    QPushButton sendButton;
    QPushButton importFileButton;
    QPushButton importSendButton;
    QLineEdit toxId;
    QTextEdit message;
    QTextEdit importMessage;
    QVBoxLayout layout;
    QVBoxLayout headLayout;
    QVBoxLayout importContactsLayout;
    QHBoxLayout importFileLine;
    QWidget* head;
    QWidget* main;
    QWidget* importContacts;
    QString lastUsername;
    QTabWidget* tabWidget;
    QVBoxLayout* requestsLayout;
    QList<QPushButton*> acceptButtons;
    QList<QPushButton*> rejectButtons;
    QList<QString> contactsToImport;

    ToxId ownId;
};",1,334 2000 58 439 2001 123 2002 439 58 370 2003 123 2004 61 1500 44 2005 61 1501 44 2006 61 1502 125 59 2000 40 2007 2008 41 59 2000 40 341 2000 38 41 61 353 59 2000 38 427 61 40 341 2000 38 41 61 353 59 126 2000 40 41 59 323 2009 40 41 341 59 492 2010 40 2011 42 2012 41 59 492 2013 40 2003 2014 41 59 323 2015 40 341 2016 38 2017 44 341 2016 38 2018 41 59 2019 58 492 2020 40 341 2007 38 2017 44 341 2016 38 2018 41 59 492 2021 40 341 2022 38 2017 41 59 492 2023 40 41 59 439 2024 58 492 2025 40 341 2016 38 2026 41 59 437 2024 58 492 2027 40 41 59 492 2028 40 341 2016 38 2029 41 59 492 2030 40 41 59 492 2031 40 41 59 492 2032 40 41 59 492 2033 40 41 59 492 2034 40 404 2035 41 59 437 58 492 2036 40 341 2016 38 2037 41 59 492 2038 40 41 59 492 2039 40 341 2016 38 2017 44 341 2016 38 2018 41 59 492 2040 40 2041 42 2042 41 59 492 2043 40 2044 42 2045 41 59 492 2046 40 2044 42 2047 41 59 492 2048 40 341 2007 38 2049 41 59 492 2050 40 41 59 2016 2051 40 41 341 59 2016 2052 40 41 341 59 437 58 2053 2054 59 2053 2055 59 2053 2056 59 2053 2057 59 2053 2058 59 2044 2059 59 2044 2060 59 2044 2061 59 2062 2049 59 2063 2018 59 2063 2064 59 2065 2066 59 2065 2067 59 2065 2068 59 2069 2070 59 2041 42 2071 59 2041 42 2072 59 2041 42 2073 59 2016 2074 59 2075 42 2076 59 2065 42 2077 59 2078 60 2044 42 62 2079 59 2078 60 2044 42 62 2080 59 2078 60 2016 62 2081 59 2007 2082 59 125 59 
118596,C++,"class ChatForm : public GenericChatForm
{
    Q_OBJECT
public:
    ChatForm(Profile& profile, Friend* chatFriend, IChatLog& chatLog, IMessageDispatcher& messageDispatcher);
    ~ChatForm() override;
    void setStatusMessage(const QString& newMessage);

    void setFriendTyping(bool isTyping);

    void show(ContentLayout* contentLayout) final;

    static const QString ACTION_PREFIX;

signals:

    void incomingNotification(uint32_t friendId);
    void outgoingNotification();
    void stopNotification();
    void endCallNotification();
    void rejectCall(uint32_t friendId);
    void acceptCall(uint32_t friendId);
    void updateFriendActivity(Friend& frnd);

public slots:
    void onAvInvite(uint32_t friendId, bool video);
    void onAvStart(uint32_t friendId, bool video);
    void onAvEnd(uint32_t friendId, bool error);
    void onAvatarChanged(const ToxPk& friendPk, const QPixmap& pic);
    void onFileNameChanged(const ToxPk& friendPk);
    void onExtensionSupportChanged(ExtensionSet extensions);
    void clearChatArea();
    void onShowMessagesClicked();
    void onSplitterMoved(int pos, int index);
    void reloadTheme() final;

private slots:
    void updateFriendActivityForFile(const ToxFile& file);
    void onAttachClicked() override;
    void onScreenshotClicked() override;

    void onTextEditChanged();
    void onCallTriggered();
    void onVideoCallTriggered();
    void onAnswerCallTriggered(bool video);
    void onRejectCallTriggered();
    void onMicMuteToggle();
    void onVolMuteToggle();

    void onFriendStatusChanged(const ToxPk& friendPk, Status::Status status);
    void onFriendTypingChanged(quint32 friendId, bool isTyping);
    void onFriendNameChanged(const QString& name);
    void onStatusMessage(const QString& message);
    void onUpdateTime();
    void previewImage(const QPixmap& pixmap);
    void cancelImagePreview();
    void sendImageFromPreview();
    void doScreenshot();
    void onCopyStatusMessage();

    void callUpdateFriendActivity();

private:
    void updateMuteMicButton();
    void updateMuteVolButton();
    void retranslateUi();
    void showOutgoingCall(bool video);
    void startCounter();
    void stopCounter(bool error = false);
    void updateCallButtons();
    void showNetcam();
    void hideNetcam();

protected:
    std::unique_ptr<NetCamView> createNetcam();
    void dragEnterEvent(QDragEnterEvent* ev) final;
    void dropEvent(QDropEvent* ev) final;
    void hideEvent(QHideEvent* event) final;
    void showEvent(QShowEvent* event) final;

private:
    Core& core;
    Friend* f;
    CroppingLabel* statusMessageLabel;
    QMenu statusMessageMenu;
    QLabel* callDuration;
    QTimer* callDurationTimer;
    QTimer typingTimer;
    QElapsedTimer timeElapsed;
    QAction* copyStatusAction;
    QPixmap imagePreviewSource;
    ImagePreviewButton* imagePreview;
    bool isTyping;
    bool lastCallIsVideo;
    std::unique_ptr<NetCamView> netcam;
};",1,334 2000 58 439 2001 123 2002 439 58 2000 40 2003 38 2004 44 2005 42 2006 44 2007 38 2008 44 2009 38 2010 41 59 126 2000 40 41 431 59 492 2011 40 341 2012 38 2013 41 59 492 2014 40 323 2015 41 59 492 2016 40 2017 42 2018 41 381 59 457 341 2012 2019 59 2020 58 492 2021 40 2022 2023 41 59 492 2024 40 41 59 492 2025 40 41 59 492 2026 40 41 59 492 2027 40 2022 2023 41 59 492 2028 40 2022 2023 41 59 492 2029 40 2005 38 2030 41 59 439 2031 58 492 2032 40 2022 2023 44 323 2033 41 59 492 2034 40 2022 2023 44 323 2033 41 59 492 2035 40 2022 2023 44 323 2036 41 59 492 2037 40 341 2038 38 2039 44 341 2040 38 2041 41 59 492 2042 40 341 2038 38 2039 41 59 492 2043 40 2044 2045 41 59 492 2046 40 41 59 492 2047 40 41 59 492 2048 40 404 2049 44 404 2050 41 59 492 2051 40 41 381 59 437 2031 58 492 2052 40 341 2053 38 2054 41 59 492 2055 40 41 431 59 492 2056 40 41 431 59 492 2057 40 41 59 492 2058 40 41 59 492 2059 40 41 59 492 2060 40 323 2033 41 59 492 2061 40 41 59 492 2062 40 41 59 492 2063 40 41 59 492 2064 40 341 2038 38 2039 44 2065 646 2065 2066 41 59 492 2067 40 2068 2023 44 323 2015 41 59 492 2069 40 341 2012 38 2070 41 59 492 2071 40 341 2012 38 2072 41 59 492 2073 40 41 59 492 2074 40 341 2040 38 2075 41 59 492 2076 40 41 59 492 2077 40 41 59 492 2078 40 41 59 492 2079 40 41 59 492 2080 40 41 59 437 58 492 2081 40 41 59 492 2082 40 41 59 492 2083 40 41 59 492 2084 40 323 2033 41 59 492 2085 40 41 59 492 2086 40 323 2036 61 380 41 59 492 2087 40 41 59 492 2088 40 41 59 492 2089 40 41 59 438 58 2090 646 2091 60 2092 62 2093 40 41 59 492 2094 40 2095 42 2096 41 381 59 492 2097 40 2098 42 2096 41 381 59 492 2099 40 2100 42 373 41 381 59 492 2101 40 2102 42 373 41 381 59 437 58 2103 38 2104 59 2005 42 2105 59 2106 42 2107 59 2108 2109 59 2110 42 2111 59 2112 42 2113 59 2112 2114 59 2115 2116 59 2117 42 2118 59 2040 2119 59 2120 42 2121 59 323 2015 59 323 2122 59 2090 646 2091 60 2092 62 2123 59 125 59 
118446,C++,"class Group : public Contact
{
    Q_OBJECT
public:
    Group(int groupId, const GroupId persistentGroupId, const QString& name, bool isAvGroupchat,
          const QString& selfName, ICoreGroupQuery& groupQuery, ICoreIdHandler& idHandler);
    bool isAvGroupchat() const;
    uint32_t getId() const override;
    const GroupId& getPersistentId() const override;
    int getPeersCount() const;
    void regeneratePeerList();
    const QMap<ToxPk, QString>& getPeerList() const;
    bool peerHasNickname(ToxPk pk);

    void setEventFlag(bool f) override;
    bool getEventFlag() const override;

    void setMentionedFlag(bool f);
    bool getMentionedFlag() const;

    void updateUsername(ToxPk pk, const QString newName);
    void setName(const QString& newTitle) override;
    void setTitle(const QString& author, const QString& newTitle);
    QString getName() const;
    QString getDisplayedName() const override;
    QString resolveToxId(const ToxPk& id) const;
    void setSelfName(const QString& name);
    QString getSelfName() const;

signals:
    void titleChangedByUser(const QString& title);
    void titleChanged(const QString& author, const QString& title);
    void userJoined(const ToxPk& user, const QString& name);
    void userLeft(const ToxPk& user, const QString& name);
    void numPeersChanged(int numPeers);
    void peerNameChanged(const ToxPk& peer, const QString& oldName, const QString& newName);

private:
    ICoreGroupQuery& groupQuery;
    ICoreIdHandler& idHandler;
    QString selfName;
    QString title;
    QMap<ToxPk, QString> peerDisplayNames;
    bool hasNewMessages;
    bool userWasMentioned;
    int toxGroupNum;
    const GroupId groupId;
    bool avGroupchat;
};",1,334 2000 58 439 2001 123 2002 439 58 2000 40 404 2003 44 341 2004 2005 44 341 2006 38 2007 44 323 2008 44 341 2006 38 2009 44 2010 38 2011 44 2012 38 2013 41 59 323 2008 40 41 341 59 2014 2015 40 41 341 431 59 341 2004 38 2016 40 41 341 431 59 404 2017 40 41 341 59 492 2018 40 41 59 341 2019 60 2020 44 2006 62 38 2021 40 41 341 59 323 2022 40 2020 2023 41 59 492 2024 40 323 2025 41 431 59 323 2026 40 41 341 431 59 492 2027 40 323 2025 41 59 323 2028 40 41 341 59 492 2029 40 2020 2023 44 341 2006 2030 41 59 492 2031 40 341 2006 38 2032 41 431 59 492 2033 40 341 2006 38 2034 44 341 2006 38 2032 41 59 2006 2035 40 41 341 59 2006 2036 40 41 341 431 59 2006 2037 40 341 2020 38 2038 41 341 59 492 2039 40 341 2006 38 2007 41 59 2006 2040 40 41 341 59 2041 58 492 2042 40 341 2006 38 2043 41 59 492 2044 40 341 2006 38 2034 44 341 2006 38 2043 41 59 492 2045 40 341 2020 38 2046 44 341 2006 38 2007 41 59 492 2047 40 341 2020 38 2046 44 341 2006 38 2007 41 59 492 2048 40 404 2049 41 59 492 2050 40 341 2020 38 2051 44 341 2006 38 2052 44 341 2006 38 2030 41 59 437 58 2010 38 2011 59 2012 38 2013 59 2006 2009 59 2006 2043 59 2019 60 2020 44 2006 62 2053 59 323 2054 59 323 2055 59 404 2056 59 341 2004 2003 59 323 2057 59 125 59 
118405,C++,"class Friend : public Contact
{
    Q_OBJECT
public:
    Friend(uint32_t friendId, const ToxPk& friendPk, const QString& userAlias = {}, const QString &userName = {});
    Friend(const Friend& other) = delete;
    Friend& operator=(const Friend& other) = delete;

    void setName(const QString& name) override;
    void setAlias(const QString& name);
    QString getDisplayedName() const override;
    bool hasAlias() const;
    QString getUserName() const;
    void setStatusMessage(const QString& message);
    QString getStatusMessage() const;

    void setEventFlag(bool f) override;
    bool getEventFlag() const override;

    const ToxPk& getPublicKey() const;
    uint32_t getId() const override;
    const ContactId& getPersistentId() const override;

    void finishNegotiation();
    void setStatus(Status::Status s);
    Status::Status getStatus() const;

    void setExtendedMessageSupport(bool supported);
    ExtensionSet getSupportedExtensions() const;

signals:
    void nameChanged(const ToxPk& friendId, const QString& name);
    void aliasChanged(const ToxPk& friendId, QString alias);
    void statusChanged(const ToxPk& friendId, Status::Status status);
    void onlineOfflineChanged(const ToxPk& friendId, bool isOnline);
    void statusMessageChanged(const ToxPk& friendId, const QString& message);
    void extensionSupportChanged(ExtensionSet extensions);
    void loadChatHistory();

public slots:
    void onNegotiationComplete();
private:
    QString userName;
    QString userAlias;
    QString statusMessage;
    ToxPk friendPk;
    uint32_t friendId;
    bool hasNewEvents;
    Status::Status friendStatus;
    bool isNegotiating;
    ExtensionSet supportedExtensions;
};",1,334 2000 58 439 2001 123 2002 439 58 2000 40 2003 2004 44 341 2005 38 2006 44 341 2007 38 2008 61 123 125 44 341 2007 38 2009 61 123 125 41 59 2000 40 341 2000 38 2010 41 61 353 59 2000 38 427 61 40 341 2000 38 2010 41 61 353 59 492 2011 40 341 2007 38 2012 41 431 59 492 2013 40 341 2007 38 2012 41 59 2007 2014 40 41 341 431 59 323 2015 40 41 341 59 2007 2016 40 41 341 59 492 2017 40 341 2007 38 2018 41 59 2007 2019 40 41 341 59 492 2020 40 323 2021 41 431 59 323 2022 40 41 341 431 59 341 2005 38 2023 40 41 341 59 2003 2024 40 41 341 431 59 341 2025 38 2026 40 41 341 431 59 492 2027 40 41 59 492 2028 40 2029 646 2029 2030 41 59 2029 646 2029 2031 40 41 341 59 492 2032 40 323 2033 41 59 2034 2035 40 41 341 59 2036 58 492 2037 40 341 2005 38 2004 44 341 2007 38 2012 41 59 492 2038 40 341 2005 38 2004 44 2007 2039 41 59 492 2040 40 341 2005 38 2004 44 2029 646 2029 2041 41 59 492 2042 40 341 2005 38 2004 44 323 2043 41 59 492 2044 40 341 2005 38 2004 44 341 2007 38 2018 41 59 492 2045 40 2034 2046 41 59 492 2047 40 41 59 439 2048 58 492 2049 40 41 59 437 58 2007 2009 59 2007 2008 59 2007 2050 59 2005 2006 59 2003 2004 59 323 2051 59 2029 646 2029 2052 59 323 2053 59 2034 2054 59 125 59 
118398,C++,"class Text : public ChatLineContent
{
    Q_OBJECT

public:
    enum TextType
    {
        NORMAL,
        ACTION,
        CUSTOM
    };

    Text(const QString& txt = """", const QFont& font = QFont(), bool enableElide = false,
         const QString& rawText = QString(), const TextType& type = NORMAL, const QColor& custom = Style::getColor(Style::MainText));
    virtual ~Text();

    void setText(const QString& txt);
    void selectText(const QString& txt, const std::pair<int, int>& point);
    void selectText(const QRegularExpression& exp, const std::pair<int, int>& point);
    void deselectText();

    void setWidth(qreal width) final;

    void selectionMouseMove(QPointF scenePos) final;
    void selectionStarted(QPointF scenePos) final;
    void selectionCleared() final;
    void selectionDoubleClick(QPointF scenePos) final;
    void selectionTripleClick(QPointF scenePos) final;
    void selectionFocusChanged(bool focusIn) final;
    bool isOverSelection(QPointF scenePos) const final;
    QString getSelectedText() const final;
    void fontChanged(const QFont& font) final;

    QRectF boundingRect() const final;
    void paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget) final;

    void visibilityChanged(bool keepInMemory) final;
    void reloadTheme() final;

    qreal getAscent() const final;
    void mousePressEvent(QGraphicsSceneMouseEvent* event) final;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) final;
    void hoverMoveEvent(QGraphicsSceneHoverEvent* event) final;

    QString getText() const final;
    QString getLinkAt(QPointF scenePos) const;

protected:
    // dynamic resource management
    void regenerate();
    void freeResources();

    virtual QSizeF idealSize();
    int cursorFromPos(QPointF scenePos, bool fuzzy = true) const;
    int getSelectionEnd() const;
    int getSelectionStart() const;
    bool hasSelection() const;
    QString extractSanitizedText(int from, int to) const;
    QString extractImgTooltip(int pos) const;

    QTextDocument* doc = nullptr;
    QSizeF size;
    qreal width = 0.0;

private:
    void selectText(QTextCursor& cursor, const std::pair<int, int>& point);
    QColor textColor() const;

    QString text;
    QString rawText;
    QString selectedText;
    bool keepInMemory = false;
    bool elide = false;
    bool dirty = false;
    bool selectionHasFocus = true;
    int selectionEnd = -1;
    int selectionAnchor = -1;
    qreal ascent = 0.0;
    QFont defFont;
    QString defStyleSheet;
    TextType textType;
    QColor color;
    QColor customColor;
};",1,334 2000 58 439 2001 123 2002 439 58 370 2003 123 2004 44 2005 44 2006 125 59 2000 40 341 2007 38 2008 61 648 44 341 2009 38 2010 61 2009 40 41 44 323 2011 61 380 44 341 2007 38 2012 61 2007 40 41 44 341 2003 38 2013 61 2014 44 341 2015 38 2016 61 2017 646 2018 40 2017 646 2019 41 41 59 491 126 2000 40 41 59 492 2020 40 341 2007 38 2008 41 59 492 2021 40 341 2007 38 2008 44 341 2022 646 2023 60 404 44 404 62 38 2024 41 59 492 2021 40 341 2025 38 2026 44 341 2022 646 2023 60 404 44 404 62 38 2024 41 59 492 2027 40 41 59 492 2028 40 2029 2030 41 381 59 492 2031 40 2032 2033 41 381 59 492 2034 40 2032 2033 41 381 59 492 2035 40 41 381 59 492 2036 40 2032 2033 41 381 59 492 2037 40 2032 2033 41 381 59 492 2038 40 323 2039 41 381 59 323 2040 40 2032 2033 41 341 381 59 2007 2041 40 41 341 381 59 492 2042 40 341 2009 38 2010 41 381 59 2043 2044 40 41 341 381 59 492 2045 40 2046 42 2047 44 341 2048 42 2049 44 2050 42 2051 41 381 59 492 2052 40 323 2053 41 381 59 492 2054 40 41 381 59 2029 2055 40 41 341 381 59 492 2056 40 2057 42 373 41 381 59 492 2058 40 2057 42 373 41 381 59 492 2059 40 2060 42 373 41 381 59 2007 2061 40 41 341 381 59 2007 2062 40 2032 2033 41 341 59 438 58 621 492 2063 40 41 59 492 2064 40 41 59 491 2065 2066 40 41 59 404 2067 40 2032 2033 44 323 2068 61 473 41 341 59 404 2069 40 41 341 59 404 2070 40 41 341 59 323 2071 40 41 341 59 2007 2072 40 404 388 44 404 2073 41 341 59 2007 2074 40 404 2075 41 341 59 2076 42 2077 61 425 59 2065 2078 59 2029 2030 61 1500 59 437 58 492 2021 40 2079 38 2080 44 341 2022 646 2023 60 404 44 404 62 38 2024 41 59 2015 2081 40 41 341 59 2007 2082 59 2007 2012 59 2007 2083 59 323 2053 61 380 59 323 2084 61 380 59 323 2085 61 380 59 323 2086 61 473 59 404 2087 61 45 1501 59 404 2088 61 45 1501 59 2029 2089 61 1500 59 2009 2090 59 2007 2091 59 2003 2092 59 2015 2093 59 2015 2094 59 125 59 
118421,C++,"class ChatWidget : public QGraphicsView
{
    Q_OBJECT
public:
    explicit ChatWidget(IChatLog& chatLog, const Core& core, QWidget* parent = nullptr);
    virtual ~ChatWidget();

    void insertChatlines(std::map<ChatLogIdx, ChatLine::Ptr> chatLines);
    void clearSelection();
    void clear();
    void copySelectedText(bool toSelectionBuffer = false) const;
    void setTypingNotificationVisible(bool visible);
    void setTypingNotificationName(const QString& displayName);
    void scrollToLine(ChatLine::Ptr line);
    void selectAll();
    void fontChanged(const QFont& font);

    QString getSelectedText() const;

    bool isEmpty() const;
    bool hasTextToBeCopied() const;
    ChatLineContent* getContentFromGlobalPos(QPoint pos) const;
    const uint repNameAfter = 5 * 60;

    void setColorizedNames(bool enable) { colorizeNames = enable; };
    void jumpToDate(QDate date);
    void jumpToIdx(ChatLogIdx idx);

signals:
    void selectionChanged();
    void firstVisibleLineChanged(const ChatLine::Ptr& prevLine, const ChatLine::Ptr& firstLine);

    void messageNotFoundShow(SearchDirection direction);
    void renderFinished();
public slots:
    void forceRelayout();
    void reloadTheme();

    void startSearch(const QString& phrase, const ParameterSearch& parameter);
    void onSearchUp(const QString& phrase, const ParameterSearch& parameter);
    void onSearchDown(const QString& phrase, const ParameterSearch& parameter);
    void handleSearchResult(SearchResult result, SearchDirection direction);
    void removeSearchPhrase();

private slots:
    void onSelectionTimerTimeout();
    void onWorkerTimeout();
    void onMultiClickTimeout();

    void onMessageUpdated(ChatLogIdx idx);
    void renderMessage(ChatLogIdx idx);
    void renderMessages(ChatLogIdx begin, ChatLogIdx end);

    void setRenderedWindowStart(ChatLogIdx start);
    void setRenderedWindowEnd(ChatLogIdx end);

    void onRenderFinished();
    void onScrollValueChanged(int value);
protected:
    QRectF calculateSceneRect() const;
    QRect getVisibleRect() const;
    ChatLineContent* getContentFromPos(QPointF scenePos) const;

    void layout(int start, int end, qreal width);
    bool isOverSelection(QPointF scenePos) const;
    bool stickToBottom() const;

    qreal useableWidth() const;

    void updateSceneRect();
    void checkVisibility();
    void scrollToBottom();
    void startResizeWorker();

    void mouseDoubleClickEvent(QMouseEvent* ev) final;
    void mousePressEvent(QMouseEvent* ev) final;
    void mouseReleaseEvent(QMouseEvent* ev) final;
    void mouseMoveEvent(QMouseEvent* ev) final;
    void scrollContentsBy(int dx, int dy) final;
    void resizeEvent(QResizeEvent* ev) final;
    void showEvent(QShowEvent*) final;
    void hideEvent(QHideEvent* event) final;
    void focusInEvent(QFocusEvent* ev) final;
    void focusOutEvent(QFocusEvent* ev) final;
    void wheelEvent(QWheelEvent *event) final;

    void updateMultiSelectionRect();
    void updateTypingNotification();
    void updateBusyNotification();

    ChatLine::Ptr findLineByPosY(qreal yPos) const;

    void removeLines(ChatLogIdx being, ChatLogIdx end);

private:
    void retranslateUi();
    bool isActiveFileTransfer(ChatLine::Ptr l);
    void handleMultiClickEvent();
    void moveSelectionRectUpIfSelected(int offset);
    void moveSelectionRectDownIfSelected(int offset);
    void movePreciseSelectionDown(int offset);
    void movePreciseSelectionUp(int offset);
    void moveMultiSelectionUp(int offset);
    void moveMultiSelectionDown(int offset);
    void setTypingNotification();

    void renderItem(const ChatLogItem &item, bool hideName, bool colorizeNames, ChatLine::Ptr &chatMessage);
    void renderFile(QString displayName, ToxFile file, bool isSelf, QDateTime timestamp, ChatLine::Ptr &chatMessage);
    bool needsToHideName(ChatLogIdx idx, bool prevIdxRendered) const;
    bool shouldRenderMessage(ChatLogIdx idx) const;
    void disableSearchText();
private:
    enum class SelectionMode
    {
        None,
        Precise,
        Multi,
    };

    enum class AutoScrollDirection
    {
        NoDirection,
        Up,
        Down,
    };

    QAction* copyAction = nullptr;
    QAction* selectAllAction = nullptr;
    QGraphicsScene* scene = nullptr;
    QGraphicsScene* busyScene = nullptr;
    QList<ChatLine::Ptr> visibleLines;
    ChatLine::Ptr typingNotification;
    ChatLine::Ptr busyNotification;

    // selection

    // For the time being we store these selection indexes as ChatLine::Ptrs. In
    // order to do multi-selection we do an O(n) search in the chatline storage
    // to determine the index. This is inefficient but correct with the moving
    // window of storage. If this proves to cause performance issues we can move
    // this responsibility into ChatlineStorage and have it coordinate the
    // shifting of indexes
    ChatLine::Ptr selClickedRow; // These 4 are only valid while selectionMode != None
    int selClickedCol = -1;
    ChatLine::Ptr selFirstRow;
    ChatLine::Ptr selLastRow;
    QColor selectionRectColor = Style::getColor(Style::SelectText);
    SelectionMode selectionMode = SelectionMode::None;
    QPointF clickPos;
    QGraphicsRectItem* selGraphItem = nullptr;
    QTimer* selectionTimer = nullptr;
    QTimer* workerTimer = nullptr;
    QTimer* multiClickTimer = nullptr;
    AutoScrollDirection selectionScrollDir = AutoScrollDirection::NoDirection;
    int clickCount = 0;
    QPoint lastClickPos;
    Qt::MouseButton lastClickButton;

    // worker vars
    size_t workerLastIndex = 0;
    bool workerStb = false;
    ChatLine::Ptr workerAnchorLine;

    // layout
    QMargins margins = QMargins(10, 10, 10, 10);
    qreal lineSpacing = 5.0f;

    IChatLog& chatLog;
    bool colorizeNames = false;
    SearchPos searchPos;
    const Core& core;
    bool scrollMonitoringEnabled = true;

    std::unique_ptr<ChatLineStorage> chatLineStorage;

    std::vector<std::function<void(void)>> renderCompletionFns;
};",1,334 2000 58 439 2001 123 2002 439 58 376 2000 40 2003 38 2004 44 341 2005 38 2006 44 2007 42 2008 61 425 41 59 491 126 2000 40 41 59 492 2009 40 2010 646 2011 60 2012 44 2013 646 2014 62 2015 41 59 492 2016 40 41 59 492 2017 40 41 59 492 2018 40 323 2019 61 380 41 341 59 492 2020 40 323 2021 41 59 492 2022 40 341 2023 38 2024 41 59 492 2025 40 2013 646 2014 2026 41 59 492 2027 40 41 59 492 2028 40 341 2029 38 2030 41 59 2023 2031 40 41 341 59 323 2032 40 41 341 59 323 2033 40 41 341 59 2034 42 2035 40 2036 2037 41 341 59 341 479 2038 61 1502 42 1503 59 492 2039 40 323 2040 41 123 2041 61 2040 59 125 59 492 2042 40 2043 2044 41 59 492 2045 40 2012 2046 41 59 2047 58 492 2048 40 41 59 492 2049 40 341 2013 646 2014 38 2050 44 341 2013 646 2014 38 2051 41 59 492 2052 40 2053 2054 41 59 492 2055 40 41 59 439 2056 58 492 2057 40 41 59 492 2058 40 41 59 492 2059 40 341 2023 38 2060 44 341 2061 38 2062 41 59 492 2063 40 341 2023 38 2060 44 341 2061 38 2062 41 59 492 2064 40 341 2023 38 2060 44 341 2061 38 2062 41 59 492 2065 40 2066 2067 44 2053 2054 41 59 492 2068 40 41 59 437 2056 58 492 2069 40 41 59 492 2070 40 41 59 492 2071 40 41 59 492 2072 40 2012 2046 41 59 492 2073 40 2012 2046 41 59 492 2074 40 2012 2075 44 2012 2076 41 59 492 2077 40 2012 2078 41 59 492 2079 40 2012 2076 41 59 492 2080 40 41 59 492 2081 40 404 2082 41 59 438 58 2083 2084 40 41 341 59 2085 2086 40 41 341 59 2034 42 2087 40 2088 2089 41 341 59 492 2090 40 404 2078 44 404 2076 44 2091 2092 41 59 323 2093 40 2088 2089 41 341 59 323 2094 40 41 341 59 2091 2095 40 41 341 59 492 2096 40 41 59 492 2097 40 41 59 492 2098 40 41 59 492 2099 40 41 59 492 2100 40 2101 42 2102 41 381 59 492 2103 40 2101 42 2102 41 381 59 492 2104 40 2101 42 2102 41 381 59 492 2105 40 2101 42 2102 41 381 59 492 2106 40 404 2107 44 404 2108 41 381 59 492 2109 40 2110 42 2102 41 381 59 492 2111 40 2112 42 41 381 59 492 2113 40 2114 42 373 41 381 59 492 2115 40 2116 42 2102 41 381 59 492 2117 40 2116 42 2102 41 381 59 492 2118 40 2119 42 373 41 381 59 492 2120 40 41 59 492 2121 40 41 59 492 2122 40 41 59 2013 646 2014 2123 40 2091 2124 41 341 59 492 2125 40 2012 2126 44 2012 2076 41 59 437 58 492 2127 40 41 59 323 2128 40 2013 646 2014 2129 41 59 492 2130 40 41 59 492 2131 40 404 2132 41 59 492 2133 40 404 2132 41 59 492 2134 40 404 2132 41 59 492 2135 40 404 2132 41 59 492 2136 40 404 2132 41 59 492 2137 40 404 2132 41 59 492 2138 40 41 59 492 2139 40 341 2140 38 2141 44 323 2142 44 323 2143 44 2013 646 2014 38 2144 41 59 492 2145 40 2023 2024 44 2146 2147 44 323 2148 44 2149 2150 44 2013 646 2014 38 2144 41 59 323 2151 40 2012 2046 44 323 2152 41 341 59 323 2153 40 2012 2046 41 341 59 492 2154 40 41 59 437 58 370 334 2155 123 303 44 2156 44 2157 44 125 59 370 334 2158 123 2159 44 2160 44 2161 44 125 59 2162 42 2163 61 425 59 2162 42 2164 61 425 59 2165 42 2166 61 425 59 2165 42 2167 61 425 59 2168 60 2013 646 2014 62 2169 59 2013 646 2014 2170 59 2013 646 2014 2171 59 621 621 621 621 621 621 621 2013 646 2014 2172 59 621 404 2173 61 45 1501 59 2013 646 2014 2174 59 2013 646 2014 2175 59 2176 2177 61 2178 646 2179 40 2178 646 2180 41 59 2155 2181 61 2155 646 303 59 2088 2182 59 2183 42 2184 61 425 59 2185 42 2186 61 425 59 2185 42 2187 61 425 59 2185 42 2188 61 425 59 2158 2189 61 2158 646 2190 59 404 2191 61 1500 59 2036 2192 59 2193 646 2194 2195 59 621 2196 2197 61 1500 59 323 2198 61 380 59 2013 646 2014 2199 59 621 2200 2201 61 2200 40 1502 44 1502 44 1502 44 1502 41 59 2091 2202 61 1502 59 2003 38 2004 59 323 2143 61 380 59 2203 2204 59 341 2005 38 2006 59 323 2205 61 473 59 2010 646 2206 60 2207 62 2208 59 2010 646 2209 60 2010 646 389 60 492 40 492 41 640 2210 59 125 59 
117618,C++,"class PX4Accelerometer
{
public:
	PX4Accelerometer(uint32_t device_id, enum Rotation rotation = ROTATION_NONE);
	~PX4Accelerometer();

	uint32_t get_device_id() const { return _device_id; }

	int32_t get_max_rate_hz() const { return math::constrain(_imu_gyro_rate_max, static_cast<int32_t>(100), static_cast<int32_t>(4000)); }

	void set_device_id(uint32_t device_id) { _device_id = device_id; }
	void set_device_type(uint8_t devtype);
	void set_error_count(uint32_t error_count) { _error_count = error_count; }
	void increase_error_count() { _error_count++; }
	void set_range(float range) { _range = range; UpdateClipLimit(); }
	void set_scale(float scale);
	void set_temperature(float temperature) { _temperature = temperature; }

	void update(const hrt_abstime &timestamp_sample, float x, float y, float z);

	void updateFIFO(sensor_accel_fifo_s &sample);

	int get_instance() { return _sensor_pub.get_instance(); };

private:
	void UpdateClipLimit();

	uORB::PublicationMulti<sensor_accel_s> _sensor_pub{ORB_ID(sensor_accel)};
	uORB::PublicationMulti<sensor_accel_fifo_s>  _sensor_fifo_pub{ORB_ID(sensor_accel_fifo)};

	uint32_t		_device_id{0};
	const enum Rotation	_rotation;

	int32_t			_imu_gyro_rate_max{0}; // match gyro max rate

	float			_range{16 * CONSTANTS_ONE_G};
	float			_scale{1.f};
	float			_temperature{NAN};

	float			_clip_limit{_range / _scale};

	uint32_t		_error_count{0};

	int16_t			_last_sample[3] {};
};",1,334 2000 123 439 58 2000 40 2001 2002 44 370 2003 2004 61 2005 41 59 126 2000 40 41 59 2001 2006 40 41 341 123 450 2007 59 125 2008 2009 40 41 341 123 450 2010 646 2011 40 2012 44 459 60 2008 62 40 1503 41 44 459 60 2008 62 40 1505 41 41 59 125 492 2013 40 2001 2002 41 123 2014 61 2002 59 125 492 2015 40 2016 2017 41 59 492 2018 40 2001 2019 41 123 2020 61 2019 59 125 492 2021 40 41 123 2022 637 59 125 492 2023 40 384 2024 41 123 2025 61 2024 59 2026 40 41 59 125 492 2027 40 384 2028 41 59 492 2029 40 384 2030 41 123 2031 61 2030 59 125 492 2032 40 341 2033 38 2034 44 384 2035 44 384 2036 44 384 2037 41 59 492 2038 40 2039 38 2040 41 59 404 2041 40 41 123 450 2042 46 2041 40 41 59 125 59 437 58 492 2043 40 41 59 2044 646 2045 60 2046 62 2047 123 2048 40 2049 41 125 59 2044 646 2045 60 2039 62 2050 123 2051 40 2052 41 125 59 2001 2053 123 1500 125 59 341 370 2003 2054 59 2008 2055 123 1500 125 59 621 384 2056 123 1503 42 2057 125 59 384 2058 123 1501 125 59 384 2059 123 2060 125 59 384 2061 123 2056 47 2058 125 59 2001 2062 123 1500 125 59 2063 2064 91 1502 93 123 125 59 125 59 
117663,C++,"class Gyroscope
{
public:
	static constexpr int MAX_SENSOR_COUNT = 4;

	static constexpr uint8_t DEFAULT_PRIORITY = 50;
	static constexpr uint8_t DEFAULT_EXTERNAL_PRIORITY = 25;

	static constexpr const char *SensorString() { return ""GYRO""; }

	Gyroscope();
	explicit Gyroscope(uint32_t device_id, bool external = false);

	~Gyroscope() = default;

	void PrintStatus();

	void set_calibration_index(uint8_t calibration_index) { _calibration_index = calibration_index; }
	void set_device_id(uint32_t device_id, bool external = false);
	void set_external(bool external = true);
	bool set_offset(const matrix::Vector3f &offset);
	void set_rotation(Rotation rotation);
	void set_temperature(float temperature) { _temperature = temperature; };

	uint8_t calibration_count() const { return _calibration_count; }
	uint32_t device_id() const { return _device_id; }
	bool enabled() const { return (_priority > 0); }
	bool external() const { return _external; }
	const matrix::Vector3f &offset() const { return _offset; }
	const int32_t &priority() const { return _priority; }
	const matrix::Dcmf &rotation() const { return _rotation; }
	const Rotation &rotation_enum() const { return _rotation_enum; }
	const matrix::Vector3f &thermal_offset() const { return _thermal_offset; }

	// apply offsets and scale
	// rotate corrected measurements from sensor to body frame
	inline matrix::Vector3f Correct(const matrix::Vector3f &data) const
	{
		return _rotation * matrix::Vector3f{data - _thermal_offset - _offset};
	}

	inline matrix::Vector3f Uncorrect(const matrix::Vector3f &corrected_data) const
	{
		return (_rotation.I() * corrected_data) + _thermal_offset + _offset;
	}

	// Compute sensor offset from bias (board frame)
	matrix::Vector3f BiasCorrectedSensorOffset(const matrix::Vector3f &bias) const
	{
		return (_rotation.I() * bias) + _thermal_offset + _offset;
	}

	bool ParametersSave();
	void ParametersUpdate();

	void Reset();

	void SensorCorrectionsUpdate(bool force = false);

private:
	static constexpr float TEMPERATURE_INVALID = -1000.f;

	uORB::Subscription _sensor_correction_sub{ORB_ID(sensor_correction)};

	Rotation _rotation_enum{ROTATION_NONE};

	matrix::Dcmf _rotation;
	matrix::Vector3f _offset;
	matrix::Vector3f _thermal_offset;
	float _temperature{NAN};

	int8_t _calibration_index{-1};
	uint32_t _device_id{0};
	int32_t _priority{-1};

	bool _external{false};

	uint8_t _calibration_count{0};
};",1,334 2000 123 439 58 457 343 404 2001 61 1502 59 457 343 2002 2003 61 1503 59 457 343 2002 2004 61 1503 59 457 343 341 330 42 2005 40 41 123 450 648 59 125 2000 40 41 59 376 2000 40 2006 2007 44 323 2008 61 380 41 59 126 2000 40 41 61 349 59 492 2009 40 41 59 492 2010 40 2002 2011 41 123 2012 61 2011 59 125 492 2013 40 2006 2007 44 323 2008 61 380 41 59 492 2014 40 323 2008 61 473 41 59 323 2015 40 341 2016 646 2017 38 2018 41 59 492 2019 40 2020 2021 41 59 492 2022 40 384 2023 41 123 2024 61 2023 59 125 59 2002 2025 40 41 341 123 450 2026 59 125 2006 2007 40 41 341 123 450 2027 59 125 323 2028 40 41 341 123 450 40 2029 62 1500 41 59 125 323 2008 40 41 341 123 450 2030 59 125 341 2016 646 2017 38 2018 40 41 341 123 450 2031 59 125 341 2032 38 2033 40 41 341 123 450 2034 59 125 341 2016 646 2035 38 2021 40 41 341 123 450 2036 59 125 341 2020 38 2037 40 41 341 123 450 2038 59 125 341 2016 646 2017 38 2039 40 41 341 123 450 2040 59 125 621 621 401 2016 646 2017 2041 40 341 2016 646 2017 38 2042 41 341 123 450 2043 42 2016 646 2017 123 2042 45 2044 45 2045 125 59 125 401 2016 646 2017 2046 40 341 2016 646 2017 38 2047 41 341 123 450 40 2048 46 2049 40 41 42 2047 41 43 2050 43 2051 59 125 621 2016 646 2017 2052 40 341 2016 646 2017 38 2053 41 341 123 450 40 2054 46 2055 40 41 42 2053 41 43 2056 43 2057 59 125 323 2058 40 41 59 492 2059 40 41 59 492 2060 40 41 59 492 2061 40 323 2062 61 380 41 59 437 58 457 343 384 2063 61 45 1504 59 2064 646 2065 2066 123 2067 40 2068 41 125 59 2020 2069 123 2070 125 59 2016 646 2035 2071 59 2016 646 2017 2072 59 2016 646 2017 2073 59 384 2074 123 2075 125 59 2076 2077 123 45 1501 125 59 2006 2078 123 1500 125 59 2032 2079 123 45 1501 125 59 323 2080 123 380 125 59 2002 2081 123 1500 125 59 125 59 
117612,C++,"class Accelerometer
{
public:
	static constexpr int MAX_SENSOR_COUNT = 4;

	static constexpr uint8_t DEFAULT_PRIORITY = 50;
	static constexpr uint8_t DEFAULT_EXTERNAL_PRIORITY = 25;

	static constexpr const char *SensorString() { return ""ACC""; }

	Accelerometer();
	explicit Accelerometer(uint32_t device_id, bool external = false);

	~Accelerometer() = default;

	void PrintStatus();

	void set_calibration_index(uint8_t calibration_index) { _calibration_index = calibration_index; }
	void set_device_id(uint32_t device_id, bool external = false);
	void set_external(bool external = true);
	bool set_offset(const matrix::Vector3f &offset);
	bool set_scale(const matrix::Vector3f &scale);
	void set_rotation(Rotation rotation);
	void set_temperature(float temperature) { _temperature = temperature; };

	uint8_t calibration_count() const { return _calibration_count; }
	uint32_t device_id() const { return _device_id; }
	bool enabled() const { return (_priority > 0); }
	bool external() const { return _external; }
	const matrix::Vector3f &offset() const { return _offset; }
	const int32_t &priority() const { return _priority; }
	const matrix::Dcmf &rotation() const { return _rotation; }
	const Rotation &rotation_enum() const { return _rotation_enum; }
	const matrix::Vector3f &scale() const { return _scale; }

	// apply offsets and scale
	// rotate corrected measurements from sensor to body frame
	inline matrix::Vector3f Correct(const matrix::Vector3f &data) const
	{
		return _rotation * matrix::Vector3f{(data - _thermal_offset - _offset).emult(_scale)};
	}

	// Compute sensor offset from bias (board frame)
	matrix::Vector3f BiasCorrectedSensorOffset(const matrix::Vector3f &bias) const
	{
		return (_rotation.I() * bias).edivide(_scale) + _thermal_offset + _offset;
	}

	bool ParametersSave();
	void ParametersUpdate();

	void Reset();

	void SensorCorrectionsUpdate(bool force = false);

private:
	static constexpr float TEMPERATURE_INVALID = -1000.f;

	uORB::Subscription _sensor_correction_sub{ORB_ID(sensor_correction)};

	Rotation _rotation_enum{ROTATION_NONE};

	matrix::Dcmf _rotation;
	matrix::Vector3f _offset;
	matrix::Vector3f _scale;
	matrix::Vector3f _thermal_offset;
	float _temperature{NAN};

	int8_t _calibration_index{-1};
	uint32_t _device_id{0};
	int32_t _priority{-1};

	bool _external{false};

	uint8_t _calibration_count{0};
};",1,334 2000 123 439 58 457 343 404 2001 61 1502 59 457 343 2002 2003 61 1503 59 457 343 2002 2004 61 1503 59 457 343 341 330 42 2005 40 41 123 450 648 59 125 2000 40 41 59 376 2000 40 2006 2007 44 323 2008 61 380 41 59 126 2000 40 41 61 349 59 492 2009 40 41 59 492 2010 40 2002 2011 41 123 2012 61 2011 59 125 492 2013 40 2006 2007 44 323 2008 61 380 41 59 492 2014 40 323 2008 61 473 41 59 323 2015 40 341 2016 646 2017 38 2018 41 59 323 2019 40 341 2016 646 2017 38 2020 41 59 492 2021 40 2022 2023 41 59 492 2024 40 384 2025 41 123 2026 61 2025 59 125 59 2002 2027 40 41 341 123 450 2028 59 125 2006 2007 40 41 341 123 450 2029 59 125 323 2030 40 41 341 123 450 40 2031 62 1500 41 59 125 323 2008 40 41 341 123 450 2032 59 125 341 2016 646 2017 38 2018 40 41 341 123 450 2033 59 125 341 2034 38 2035 40 41 341 123 450 2036 59 125 341 2016 646 2037 38 2023 40 41 341 123 450 2038 59 125 341 2022 38 2039 40 41 341 123 450 2040 59 125 341 2016 646 2017 38 2020 40 41 341 123 450 2041 59 125 621 621 401 2016 646 2017 2042 40 341 2016 646 2017 38 2043 41 341 123 450 2044 42 2016 646 2017 123 40 2043 45 2045 45 2046 41 46 2047 40 2048 41 125 59 125 621 2016 646 2017 2049 40 341 2016 646 2017 38 2050 41 341 123 450 40 2051 46 2052 40 41 42 2050 41 46 2053 40 2054 41 43 2055 43 2056 59 125 323 2057 40 41 59 492 2058 40 41 59 492 2059 40 41 59 492 2060 40 323 2061 61 380 41 59 437 58 457 343 384 2062 61 45 1504 59 2063 646 2064 2065 123 2066 40 2067 41 125 59 2022 2068 123 2069 125 59 2016 646 2037 2070 59 2016 646 2017 2071 59 2016 646 2017 2072 59 2016 646 2017 2073 59 384 2074 123 2075 125 59 2076 2077 123 45 1501 125 59 2006 2078 123 1500 125 59 2034 2079 123 45 1501 125 59 323 2080 123 380 125 59 2002 2081 123 1500 125 59 125 59 
98645,C++,"class CPL_DLL VRTDerivedRasterBand CPL_NON_FINAL: public VRTSourcedRasterBand
{
    VRTDerivedRasterBandPrivateData* m_poPrivate;
    bool InitializePython();

    CPL_DISALLOW_COPY_ASSIGN(VRTDerivedRasterBand)

 public:
    char *pszFuncName;
    GDALDataType eSourceTransferType;

    using PixelFunc = std::function<CPLErr(void**, int, void*, int, int, GDALDataType, GDALDataType, int, int, CSLConstList)>;

    VRTDerivedRasterBand( GDALDataset *poDS, int nBand );
    VRTDerivedRasterBand( GDALDataset *poDS, int nBand,
                          GDALDataType eType, int nXSize, int nYSize );
    virtual        ~VRTDerivedRasterBand();

    virtual CPLErr IRasterIO( GDALRWFlag, int, int, int, int,
                              void *, int, int, GDALDataType,
                              GSpacing nPixelSpace, GSpacing nLineSpace,
                              GDALRasterIOExtraArg* psExtraArg ) override;

    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,
                                        int nXSize, int nYSize,
                                        int nMaskFlagStop,
                                        double* pdfDataPct) override;

    static CPLErr AddPixelFunction( const char *pszFuncName,
                                    GDALDerivedPixelFunc pfnPixelFunc );
    static CPLErr AddPixelFunction( const char *pszFuncName,
                                    GDALDerivedPixelFuncWithArgs pfnPixelFunc,
                                    const char *pszMetadata);

    static PixelFunc* GetPixelFunction( const char *pszFuncName );

    void SetPixelFunctionName( const char *pszFuncName );
    void SetSourceTransferType( GDALDataType eDataType );
    void SetPixelFunctionLanguage( const char* pszLanguage );

    virtual CPLErr         XMLInit( CPLXMLNode *, const char *,
                                    std::map<CPLString, GDALDataset*>& ) override;
    virtual CPLXMLNode *   SerializeToXML( const char *pszVRTPath ) override;

    virtual double GetMinimum( int *pbSuccess = nullptr ) override;
    virtual double GetMaximum(int *pbSuccess = nullptr ) override;
    virtual CPLErr ComputeRasterMinMax( int bApproxOK, double* adfMinMax ) override;
    virtual CPLErr ComputeStatistics( int bApproxOK,
                                      double *pdfMin, double *pdfMax,
                                      double *pdfMean, double *pdfStdDev,
                                      GDALProgressFunc pfnProgress,
                                      void *pProgressData ) override;
    virtual CPLErr  GetHistogram( double dfMin, double dfMax,
                                  int nBuckets, GUIntBig * panHistogram,
                                  int bIncludeOutOfRange, int bApproxOK,
                                  GDALProgressFunc pfnProgress,
                                  void *pProgressData ) override;

    static void Cleanup();
};",1,334 2000 2001 2002 58 439 2003 123 2004 42 2005 59 323 2006 40 41 59 2007 40 2001 41 439 58 330 42 2008 59 2009 2010 59 489 2011 61 2012 646 389 60 2013 40 492 42 42 44 404 44 492 42 44 404 44 404 44 2009 44 2009 44 404 44 404 44 2014 41 62 59 2001 40 2015 42 2016 44 404 2017 41 59 2001 40 2015 42 2016 44 404 2017 44 2009 2018 44 404 2019 44 404 2020 41 59 491 126 2001 40 41 59 491 2013 2021 40 2022 44 404 44 404 44 404 44 404 44 492 42 44 404 44 404 44 2009 44 2023 2024 44 2023 2025 44 2026 42 2027 41 431 59 491 404 2028 40 404 2029 44 404 2030 44 404 2019 44 404 2020 44 404 2031 44 356 42 2032 41 431 59 457 2013 2033 40 341 330 42 2008 44 2034 2035 41 59 457 2013 2033 40 341 330 42 2008 44 2036 2035 44 341 330 42 2037 41 59 457 2011 42 2038 40 341 330 42 2008 41 59 492 2039 40 341 330 42 2008 41 59 492 2040 40 2009 2041 41 59 492 2042 40 341 330 42 2043 41 59 491 2013 2044 40 2045 42 44 341 330 42 44 2012 646 2046 60 2047 44 2015 42 62 38 41 431 59 491 2045 42 2048 40 341 330 42 2049 41 431 59 491 356 2050 40 404 42 2051 61 425 41 431 59 491 356 2052 40 404 42 2051 61 425 41 431 59 491 2013 2053 40 404 2054 44 356 42 2055 41 431 59 491 2013 2056 40 404 2054 44 356 42 2057 44 356 42 2058 44 356 42 2059 44 356 42 2060 44 2061 2062 44 492 42 2063 41 431 59 491 2013 2064 40 356 2065 44 356 2066 44 404 2067 44 2068 42 2069 44 404 2070 44 404 2054 44 2061 2062 44 492 42 2063 41 431 59 457 492 2071 40 41 59 125 59 
99001,C++,"class OGRODSDataSource final: public GDALDataset
{
    char*               pszName;
    bool                bUpdatable;
    bool                bUpdated;
    bool                bAnalysedFile;

    int                 nLayers;
    OGRLayer          **papoLayers;

    VSILFILE*           fpSettings;
    std::string         osCurrentConfigTableName;
    std::string         osConfigName;
    int                 nFlags;
    std::set<std::string> osSetLayerHasSplitter;
    void                AnalyseSettings();

    VSILFILE*           fpContent;
    void                AnalyseFile();

    bool                bFirstLineIsHeaders;
    int                 bAutodetectTypes;

    XML_Parser          oParser;
    bool                bStopParsing;
    int                 nWithoutEventCounter;
    int                 nDataHandlerCounter;
    int                 nCurLine;
    int                 nEmptyRowsAccumulated;
    int                 nRowsRepeated;
    int                 nCurCol;
    int                 nCellsRepeated;
    // Accumulated memory allocations related to repeated cells.
    size_t              m_nAccRepeatedMemory = 0;
    bool                bEndTableParsing;

    OGRODSLayer        *poCurLayer;

    int                 nStackDepth;
    int                 nDepth;
    HandlerState        stateStack[STACK_SIZE];

    CPLString           osValueType;
    CPLString           osValue;
    std::string         osFormula;

    std::vector<std::string>  apoFirstLineValues;
    std::vector<std::string>  apoFirstLineTypes;
    std::vector<std::string>  apoCurLineValues;
    std::vector<std::string>  apoCurLineTypes;

    void                PushState(HandlerStateEnum eVal);
    void                startElementDefault(const char *pszName, const char **ppszAttr);
    void                startElementTable(const char *pszName, const char **ppszAttr);
    void                endElementTable(const char *pszName);
    void                startElementRow(const char *pszName, const char **ppszAttr);
    void                endElementRow(const char *pszName);
    void                startElementCell(const char *pszName, const char **ppszAttr);
    void                endElementCell(const char *pszName);
    void                dataHandlerTextP(const char *data, int nLen);

    void                DetectHeaderLine();

    OGRFieldType        GetOGRFieldType(const char* pszValue,
                                        const char* pszValueType,
                                        OGRFieldSubType& eSubType);

    void                DeleteLayer( const char *pszLayerName );

    void                FillRepeatedCells(bool wasLastCell);

  public:
                        OGRODSDataSource();
                        virtual ~OGRODSDataSource();

    int                 Open( const char * pszFilename,
                              VSILFILE* fpContentIn,
                              VSILFILE* fpSettingsIn,
                              int bUpdatableIn );
    int                 Create( const char * pszName, char **papszOptions );

    virtual int                 GetLayerCount() override;
    virtual OGRLayer*           GetLayer( int ) override;

    virtual int                 TestCapability( const char * ) override;

    virtual OGRLayer* ICreateLayer( const char * pszLayerName,
                                OGRSpatialReference *poSRS,
                                OGRwkbGeometryType eType,
                                char ** papszOptions ) override;
    virtual OGRErr      DeleteLayer(int iLayer) override;

    virtual void        FlushCache(bool bAtClosing) override;

    void startElementCbk(const char *pszName, const char **ppszAttr);
    void endElementCbk(const char *pszName);
    void dataHandlerCbk(const char *data, int nLen);

    void startElementStylesCbk(const char *pszName, const char **ppszAttr);
    void endElementStylesCbk(const char *pszName);
    void dataHandlerStylesCbk(const char *data, int nLen);

    bool                GetUpdatable() { return bUpdatable; }
    void                SetUpdated() { bUpdated = true; }
};",1,334 2000 381 58 439 2001 123 330 42 2002 59 323 2003 59 323 2004 59 323 2005 59 404 2006 59 2007 42 42 2008 59 2009 42 2010 59 2011 646 461 2012 59 2011 646 461 2013 59 404 2014 59 2011 646 2015 60 2011 646 461 62 2016 59 492 2017 40 41 59 2009 42 2018 59 492 2019 40 41 59 323 2020 59 404 2021 59 2022 2023 59 323 2024 59 404 2025 59 404 2026 59 404 2027 59 404 2028 59 404 2029 59 404 2030 59 404 2031 59 621 2032 2033 61 1500 59 323 2034 59 2035 42 2036 59 404 2037 59 404 2038 59 2039 2040 91 2041 93 59 2042 2043 59 2042 2044 59 2011 646 461 2045 59 2011 646 2046 60 2011 646 461 62 2047 59 2011 646 2046 60 2011 646 461 62 2048 59 2011 646 2046 60 2011 646 461 62 2049 59 2011 646 2046 60 2011 646 461 62 2050 59 492 2051 40 2052 2053 41 59 492 2054 40 341 330 42 2002 44 341 330 42 42 2055 41 59 492 2056 40 341 330 42 2002 44 341 330 42 42 2055 41 59 492 2057 40 341 330 42 2002 41 59 492 2058 40 341 330 42 2002 44 341 330 42 42 2055 41 59 492 2059 40 341 330 42 2002 41 59 492 2060 40 341 330 42 2002 44 341 330 42 42 2055 41 59 492 2061 40 341 330 42 2002 41 59 492 2062 40 341 330 42 2063 44 404 2064 41 59 492 2065 40 41 59 2066 2067 40 341 330 42 2068 44 341 330 42 2069 44 2070 38 2071 41 59 492 2072 40 341 330 42 2073 41 59 492 2074 40 323 2075 41 59 439 58 2000 40 41 59 491 126 2000 40 41 59 404 2076 40 341 330 42 2077 44 2009 42 2078 44 2009 42 2079 44 404 2080 41 59 404 2081 40 341 330 42 2002 44 330 42 42 2082 41 59 491 404 2083 40 41 431 59 491 2007 42 2084 40 404 41 431 59 491 404 2085 40 341 330 42 41 431 59 491 2007 42 2086 40 341 330 42 2073 44 2087 42 2088 44 2089 2090 44 330 42 42 2082 41 431 59 491 2091 2072 40 404 2092 41 431 59 491 492 2093 40 323 2094 41 431 59 492 2095 40 341 330 42 2002 44 341 330 42 42 2055 41 59 492 2096 40 341 330 42 2002 41 59 492 2097 40 341 330 42 2063 44 404 2064 41 59 492 2098 40 341 330 42 2002 44 341 330 42 42 2055 41 59 492 2099 40 341 330 42 2002 41 59 492 2100 40 341 330 42 2063 44 404 2064 41 59 323 2101 40 41 123 450 2003 59 125 492 2102 40 41 123 2004 61 473 59 125 125 59 
98661,C++,"class CPL_DLL VRTRawRasterBand CPL_NON_FINAL: public VRTRasterBand
{
    RawRasterBand  *m_poRawRaster;

    char           *m_pszSourceFilename;
    int            m_bRelativeToVRT;

    CPL_DISALLOW_COPY_ASSIGN(VRTRawRasterBand)

  public:
                   VRTRawRasterBand( GDALDataset *poDS, int nBand,
                                     GDALDataType eType = GDT_Unknown );
    virtual        ~VRTRawRasterBand();

    virtual CPLErr         XMLInit( CPLXMLNode *, const char *,
                                    std::map<CPLString, GDALDataset*>& ) override;
    virtual CPLXMLNode *   SerializeToXML( const char *pszVRTPath ) override;

    virtual CPLErr IRasterIO( GDALRWFlag, int, int, int, int,
                              void *, int, int, GDALDataType,
                              GSpacing nPixelSpace, GSpacing nLineSpace,
                              GDALRasterIOExtraArg* psExtraArg ) override;

    virtual CPLErr IReadBlock( int, int, void * ) override;
    virtual CPLErr IWriteBlock( int, int, void * ) override;

    CPLErr         SetRawLink( const char *pszFilename,
                               const char *pszVRTPath,
                               int bRelativeToVRT,
                               vsi_l_offset nImageOffset,
                               int nPixelOffset, int nLineOffset,
                               const char *pszByteOrder );

    void           ClearRawLink();

    CPLVirtualMem *GetVirtualMemAuto( GDALRWFlag eRWFlag,
                                      int *pnPixelSpace,
                                      GIntBig *pnLineSpace,
                                      char **papszOptions ) override;

    virtual void   GetFileList( char*** ppapszFileList, int *pnSize,
                                int *pnMaxSize, CPLHashSet* hSetFiles ) override;
};",1,334 2000 2001 2002 58 439 2003 123 2004 42 2005 59 330 42 2006 59 404 2007 59 2008 40 2001 41 439 58 2001 40 2009 42 2010 44 404 2011 44 2012 2013 61 2014 41 59 491 126 2001 40 41 59 491 2015 2016 40 2017 42 44 341 330 42 44 2018 646 2019 60 2020 44 2009 42 62 38 41 431 59 491 2017 42 2021 40 341 330 42 2022 41 431 59 491 2015 2023 40 2024 44 404 44 404 44 404 44 404 44 492 42 44 404 44 404 44 2012 44 2025 2026 44 2025 2027 44 2028 42 2029 41 431 59 491 2015 2030 40 404 44 404 44 492 42 41 431 59 491 2015 2031 40 404 44 404 44 492 42 41 431 59 2015 2032 40 341 330 42 2033 44 341 330 42 2022 44 404 2034 44 2035 2036 44 404 2037 44 404 2038 44 341 330 42 2039 41 59 492 2040 40 41 59 2041 42 2042 40 2024 2043 44 404 42 2044 44 2045 42 2046 44 330 42 42 2047 41 431 59 491 492 2048 40 330 42 42 42 2049 44 404 42 2050 44 404 42 2051 44 2052 42 2053 41 431 59 125 59 
98889,C++,"class OGRSQLiteDataSource final : public OGRSQLiteBaseDataSource
{
    OGRSQLiteLayer    **m_papoLayers = nullptr;
    int                 m_nLayers = 0;

    // We maintain a list of known SRID to reduce the number of trips to
    // the database to get SRSes.
    int                 m_nKnownSRID = 0;
    int                *m_panSRID = nullptr;
    OGRSpatialReference **m_papoSRS = nullptr;

    void                AddSRIDToCache(int nId, OGRSpatialReference * poSRS );

    bool                m_bHaveGeometryColumns = false;
    bool                m_bIsSpatiaLiteDB = false;
    bool                m_bSpatialite4Layout = false;

    int                 m_nUndefinedSRID = -1;

    virtual void        DeleteLayer( const char *pszLayer );

    const char*         GetSRTEXTColName();

    bool                InitWithEPSG();

    bool                OpenVirtualTable(const char* pszName, const char* pszSQL);

    GIntBig             m_nFileTimestamp = 0;
    bool                m_bLastSQLCommandIsUpdateLayerStatistics = false;

    std::map< CPLString, std::set<CPLString> > m_aoMapTableToSetOfGeomCols{};

    void                SaveStatistics();

    std::vector<OGRLayer*> m_apoInvisibleLayers{};

#ifdef HAVE_RASTERLITE2
    void               *m_hRL2Ctxt = nullptr;
    bool                InitRasterLite2();
    void                FinishRasterLite2();

    CPLString           m_osCoverageName{};
    GIntBig             m_nSectionId = -1;
    rl2CoveragePtr      m_pRL2Coverage = nullptr;
    bool                m_bRL2MixedResolutions = false;
#endif
    CPLStringList       m_aosSubDatasets{};
    bool                m_bGeoTransformValid = false;
    double              m_adfGeoTransform[6];
    CPLString           m_osProjection{};
    bool                m_bPromote1BitAs8Bit = false;
    bool                OpenRaster();
    bool                OpenRasterSubDataset(const char* pszConnectionId);
    OGRSQLiteDataSource* m_poParentDS = nullptr;
    std::vector<OGRSQLiteDataSource*> m_apoOverviewDS{};

#ifdef HAVE_RASTERLITE2
    void                ListOverviews();
    void                CreateRL2OverviewDatasetIfNeeded(double dfXRes,
                                                      double dfYRes);
#endif

  public:
                        OGRSQLiteDataSource();
                        virtual ~OGRSQLiteDataSource();

    bool                Open( GDALOpenInfo* poOpenInfo );
    bool                Create( const char *, char **papszOptions );

    bool                OpenTable( const char *pszTableName,
                                   bool IsTable,
                                   bool bIsVirtualShape );
    bool                OpenView( const char *pszViewName,
                                   const char *pszViewGeometry,
                                   const char *pszViewRowid,
                                   const char *pszTableName,
                                   const char *pszGeometryColumn);

    virtual int         GetLayerCount() override { return m_nLayers; }
    virtual OGRLayer   *GetLayer( int ) override;
    virtual OGRLayer   *GetLayerByName( const char* ) override;
    virtual bool        IsLayerPrivate( int ) const override;
    OGRLayer           *GetLayerByNameNotVisible( const char* );
    virtual std::pair<OGRLayer*, IOGRSQLiteGetSpatialWhere*> GetLayerWithGetSpatialWhereByName( const char* pszName ) override;

    virtual OGRLayer    *ICreateLayer( const char *pszLayerName,
                                      OGRSpatialReference *poSRS,
                                      OGRwkbGeometryType eType,
                                      char **papszOptions ) override;
    virtual OGRErr      DeleteLayer(int) override;

    virtual int         TestCapability( const char * ) override;

    virtual OGRLayer *  ExecuteSQL( const char *pszSQLCommand,
                                    OGRGeometry *poSpatialFilter,
                                    const char *pszDialect ) override;
    virtual void        ReleaseResultSet( OGRLayer * poLayer ) override;

    virtual void        FlushCache(bool bAtClosing) override;

    virtual OGRErr      CommitTransaction() override;
    virtual OGRErr      RollbackTransaction() override;

    virtual char**      GetMetadata(const char* pszDomain = """") override;

    virtual CPLErr      GetGeoTransform( double* padfGeoTransform ) override;
    virtual const char* _GetProjectionRef() override;
    const OGRSpatialReference* GetSpatialRef() const override {
        return GetSpatialRefFromOldGetProjectionRef();
    }

    char               *LaunderName( const char * );
    int                 FetchSRSId( const OGRSpatialReference * poSRS );
    OGRSpatialReference*FetchSRS( int nSRID );

    void                DisableUpdate() { eAccess = GA_ReadOnly; }

    void                SetName(const char* pszNameIn);

    const std::set<CPLString>& GetGeomColsForTable(const char* pszTableName)
            { return m_aoMapTableToSetOfGeomCols[pszTableName]; }

    GIntBig             GetFileTimestamp() const { return m_nFileTimestamp; }

    bool                IsSpatialiteLoaded();
    int                 GetSpatialiteVersionNumber();

    bool                IsSpatialiteDB() const { return m_bIsSpatiaLiteDB; }
    bool                HasSpatialite4Layout() const { return m_bSpatialite4Layout; }

    int                 GetUndefinedSRID() const { return m_nUndefinedSRID; }
    bool                HasGeometryColumns() const { return m_bHaveGeometryColumns; }

    void                ReloadLayers();

#ifdef HAVE_RASTERLITE2
    void*               GetRL2Context() const { return m_hRL2Ctxt; }
    rl2CoveragePtr      GetRL2CoveragePtr() const { return m_pRL2Coverage; }
    GIntBig             GetSectionId() const { return m_nSectionId; }
    const double*       GetGeoTransform() const { return m_adfGeoTransform; }
    bool                IsRL2MixedResolutions() const { return m_bRL2MixedResolutions; }

    virtual CPLErr IBuildOverviews( const char *, int, int *,
                                    int, int *, GDALProgressFunc, void * ) override;

#endif
    OGRSQLiteDataSource* GetParentDS() const { return m_poParentDS; }
    const std::vector<OGRSQLiteDataSource*>& GetOverviews() const { return m_apoOverviewDS; }
    bool                 HasPromote1BitAS8Bit() const { return m_bPromote1BitAs8Bit; }
};",1,334 2000 381 58 439 2001 123 2002 42 42 2003 61 425 59 404 2004 61 1500 59 621 621 404 2005 61 1500 59 404 42 2006 61 425 59 2007 42 42 2008 61 425 59 492 2009 40 404 2010 44 2007 42 2011 41 59 323 2012 61 380 59 323 2013 61 380 59 323 2014 61 380 59 404 2015 61 45 1501 59 491 492 2016 40 341 330 42 2017 41 59 341 330 42 2018 40 41 59 323 2019 40 41 59 323 2020 40 341 330 42 2021 44 341 330 42 2022 41 59 2023 2024 61 1500 59 323 2025 61 380 59 2026 646 2027 60 2028 44 2026 646 2029 60 2028 62 62 2030 123 125 59 492 2031 40 41 59 2026 646 2032 60 2033 42 62 2034 123 125 59 35 393 2035 492 42 2036 61 425 59 323 2037 40 41 59 492 2038 40 41 59 2028 2039 123 125 59 2023 2040 61 45 1501 59 2041 2042 61 425 59 323 2043 61 380 59 35 366 2044 2045 123 125 59 323 2046 61 380 59 356 2047 91 1502 93 59 2028 2048 123 125 59 323 2049 61 380 59 323 2050 40 41 59 323 2051 40 341 330 42 2052 41 59 2000 42 2053 61 425 59 2026 646 2032 60 2000 42 62 2054 123 125 59 35 393 2035 492 2055 40 41 59 492 2056 40 356 2057 44 356 2058 41 59 35 366 439 58 2000 40 41 59 491 126 2000 40 41 59 323 2059 40 2060 42 2061 41 59 323 2062 40 341 330 42 44 330 42 42 2063 41 59 323 2064 40 341 330 42 2065 44 323 2066 44 323 2067 41 59 323 2068 40 341 330 42 2069 44 341 330 42 2070 44 341 330 42 2071 44 341 330 42 2065 44 341 330 42 2072 41 59 491 404 2073 40 41 431 123 450 2004 59 125 491 2033 42 2074 40 404 41 431 59 491 2033 42 2075 40 341 330 42 41 431 59 491 323 2076 40 404 41 341 431 59 2033 42 2077 40 341 330 42 41 59 491 2026 646 2078 60 2033 42 44 2079 42 62 2080 40 341 330 42 2021 41 431 59 491 2033 42 2081 40 341 330 42 2082 44 2007 42 2011 44 2083 2084 44 330 42 42 2063 41 431 59 491 2085 2016 40 404 41 431 59 491 404 2086 40 341 330 42 41 431 59 491 2033 42 2087 40 341 330 42 2088 44 2089 42 2090 44 341 330 42 2091 41 431 59 491 492 2092 40 2033 42 2093 41 431 59 491 492 2094 40 323 2095 41 431 59 491 2085 2096 40 41 431 59 491 2085 2097 40 41 431 59 491 330 42 42 2098 40 341 330 42 2099 61 648 41 431 59 491 2100 2101 40 356 42 2102 41 431 59 491 341 330 42 2103 40 41 431 59 341 2007 42 2104 40 41 341 431 123 450 2105 40 41 59 125 330 42 2106 40 341 330 42 41 59 404 2107 40 341 2007 42 2011 41 59 2007 42 2108 40 404 2109 41 59 492 2110 40 41 123 2111 61 2112 59 125 492 2113 40 341 330 42 2114 41 59 341 2026 646 2029 60 2028 62 38 2115 40 341 330 42 2065 41 123 450 2030 91 2065 93 59 125 2023 2116 40 41 341 123 450 2024 59 125 323 2117 40 41 59 404 2118 40 41 59 323 2119 40 41 341 123 450 2013 59 125 323 2120 40 41 341 123 450 2014 59 125 404 2121 40 41 341 123 450 2015 59 125 323 2122 40 41 341 123 450 2012 59 125 492 2123 40 41 59 35 393 2035 492 42 2124 40 41 341 123 450 2036 59 125 2041 2125 40 41 341 123 450 2042 59 125 2023 2126 40 41 341 123 450 2040 59 125 341 356 42 2101 40 41 341 123 450 2047 59 125 323 2127 40 41 341 123 450 2043 59 125 491 2100 2128 40 341 330 42 44 404 44 404 42 44 404 44 404 42 44 2129 44 492 42 41 431 59 35 366 2000 42 2130 40 41 341 123 450 2053 59 125 341 2026 646 2032 60 2000 42 62 38 2131 40 41 341 123 450 2054 59 125 323 2132 40 41 341 123 450 2049 59 125 125 59 
98908,C++,"class VSIPDFFileStream final: public BaseStream
{
    public:
        VSIPDFFileStream(VSILFILE* f, const char* pszFilename,
                         makeSubStream_object_type dictA);
        VSIPDFFileStream(VSIPDFFileStream* poParent,
                         vsi_l_offset startA, GBool limitedA,
                         vsi_l_offset lengthA,
                         makeSubStream_object_type dictA);
        virtual ~VSIPDFFileStream();

        virtual BaseStream* copy() override;

        virtual Stream *   makeSubStream(makeSubStream_offset_type startA, GBool limitedA,
                                         makeSubStream_offset_type lengthA, makeSubStream_object_type dictA) override;
        virtual getPos_ret_type      getPos() override;
        virtual getStart_ret_type    getStart() override;

        virtual void       setPos(setPos_offset_type pos, int dir = 0) override;
        virtual void       moveStart(moveStart_delta_type delta) override;

        virtual StreamKind getKind()
#if POPPLER_MAJOR_VERSION >= 1 || POPPLER_MINOR_VERSION >= 83
            const
#endif
            override;

        virtual GooString *getFileName() override;

        virtual int        getChar() override;
        virtual int        getUnfilteredChar () override;
        virtual int        lookChar() override;

        virtual void       reset() override;
        virtual void       unfilteredReset () override;
        virtual void       close() override;

        bool               FoundLinearizedHint() const { return bFoundLinearizedHint; }

    private:
        virtual GBool hasGetChars() override;
        virtual int getChars(int nChars, Guchar *buffer) override;

        VSIPDFFileStream  *poParent;
        GooString         *poFilename;
        VSILFILE          *f;
        vsi_l_offset       nStart;
        GBool              bLimited;
        vsi_l_offset       nLength;

        vsi_l_offset       nCurrentPos;
        int                bHasSavedPos;
        vsi_l_offset       nSavedPos;

        GByte              abyBuffer[BUFFER_SIZE];
        int                nPosInBuffer;
        int                nBufferLength;

        bool               bFoundLinearizedHint = false;

        int                FillBuffer();
};",1,334 2000 381 58 439 2001 123 439 58 2000 40 2002 42 2003 44 341 330 42 2004 44 2005 2006 41 59 2000 40 2000 42 2007 44 2008 2009 44 2010 2011 44 2008 2012 44 2005 2006 41 59 491 126 2000 40 41 59 491 2001 42 2013 40 41 431 59 491 2014 42 2015 40 2016 2009 44 2010 2011 44 2016 2012 44 2005 2006 41 431 59 491 2017 2018 40 41 431 59 491 2019 2020 40 41 431 59 491 492 2021 40 2022 2023 44 404 2024 61 1500 41 431 59 491 492 2025 40 2026 2027 41 431 59 491 2028 2029 40 41 35 392 2030 615 1501 606 2031 615 1503 341 35 366 431 59 491 2032 42 2033 40 41 431 59 491 404 2034 40 41 431 59 491 404 2035 40 41 431 59 491 404 2036 40 41 431 59 491 492 2037 40 41 431 59 491 492 2038 40 41 431 59 491 492 2039 40 41 431 59 323 2040 40 41 341 123 450 2041 59 125 437 58 491 2010 2042 40 41 431 59 491 404 2043 40 404 2044 44 2045 42 2046 41 431 59 2000 42 2007 59 2032 42 2047 59 2002 42 2003 59 2008 2048 59 2010 2049 59 2008 2050 59 2008 2051 59 404 2052 59 2008 2053 59 2054 2055 91 2056 93 59 404 2057 59 404 2058 59 323 2059 61 380 59 404 2060 40 41 59 125 59 
98879,C++,"class OGRGeoJSONBaseReader
{
  public:
      OGRGeoJSONBaseReader();

    void SetPreserveGeometryType( bool bPreserve );
    void SetSkipAttributes( bool bSkip );
    void SetFlattenNestedAttributes( bool bFlatten, char chSeparator );
    void SetStoreNativeData( bool bStoreNativeData );
    void SetArrayAsString( bool bArrayAsString );
    void SetDateAsString( bool bDateAsString );

    bool GenerateFeatureDefn( std::map<std::string, int>& oMapFieldNameToIdx,
                              std::vector<std::unique_ptr<OGRFieldDefn>>& apoFieldDefn,
                              gdal::DirectedAcyclicGraph<int, std::string>& dag,
                              OGRLayer* poLayer, json_object* poObj );
    void FinalizeLayerDefn( OGRLayer* poLayer, CPLString& osFIDColumn );

    OGRGeometry* ReadGeometry( json_object* poObj, OGRSpatialReference* poLayerSRS );
    OGRFeature* ReadFeature( OGRLayer* poLayer, json_object* poObj,
                             const char* pszSerializedObj );
  protected:
    bool bGeometryPreserve_ = true;
    bool bAttributesSkip_ = false;
    bool bFlattenNestedAttributes_ = false;
    char chNestedAttributeSeparator_ = 0;
    bool bStoreNativeData_ = false;
    bool bArrayAsString_ = false;
    bool bDateAsString_ = false;

  private:

    std::set<int> aoSetUndeterminedTypeFields_;

    // bFlatten... is a tri-state boolean with -1 being unset.
    int bFlattenGeocouchSpatiallistFormat = -1;

    bool bFoundGeocouchId = false;
    bool bFoundRev = false;
    bool bFoundTypeFeature = false;
    bool bIsGeocouchSpatiallistFormat = false;
    bool bFeatureLevelIdAsAttribute_ = false;
    bool bFeatureLevelIdAsFID_ = false;
    bool m_bNeedFID64 = false;

    bool m_bDetectLayerGeomType = true;
    bool m_bFirstGeometry = true;
    OGRwkbGeometryType m_eLayerGeomType = wkbUnknown;

    CPL_DISALLOW_COPY_ASSIGN(OGRGeoJSONBaseReader)
};",1,334 2000 123 439 58 2000 40 41 59 492 2001 40 323 2002 41 59 492 2003 40 323 2004 41 59 492 2005 40 323 2006 44 330 2007 41 59 492 2008 40 323 2009 41 59 492 2010 40 323 2011 41 59 492 2012 40 323 2013 41 59 323 2014 40 2015 646 2016 60 2015 646 461 44 404 62 38 2017 44 2015 646 2018 60 2015 646 2019 60 2020 640 38 2021 44 2022 646 2023 60 404 44 2015 646 461 62 38 2024 44 2025 42 2026 44 2027 42 2028 41 59 492 2029 40 2025 42 2026 44 2030 38 2031 41 59 2032 42 2033 40 2027 42 2028 44 2034 42 2035 41 59 2036 42 2037 40 2025 42 2026 44 2027 42 2028 44 341 330 42 2038 41 59 438 58 323 2039 61 473 59 323 2040 61 380 59 323 2041 61 380 59 330 2042 61 1500 59 323 2043 61 380 59 323 2044 61 380 59 323 2045 61 380 59 437 58 2015 646 2046 60 404 62 2047 59 621 404 2048 61 45 1501 59 323 2049 61 380 59 323 2050 61 380 59 323 2051 61 380 59 323 2052 61 380 59 323 2053 61 380 59 323 2054 61 380 59 323 2055 61 380 59 323 2056 61 473 59 323 2057 61 473 59 2058 2059 61 2060 59 2061 40 2000 41 125 59 
98880,C++,"class OGRGeoJSONReader: public OGRGeoJSONBaseReader
{
  public:
    OGRGeoJSONReader();
    ~OGRGeoJSONReader();

    OGRErr Parse( const char* pszText );
    void ReadLayers( OGRGeoJSONDataSource* poDS );
    void ReadLayer( OGRGeoJSONDataSource* poDS,
                    const char* pszName,
                    json_object* poObj );
    bool FirstPassReadLayer( OGRGeoJSONDataSource* poDS, VSILFILE* fp,
                             bool& bTryStandardReading );

    json_object* GetJSonObject() { return poGJObject_; }

    void ResetReading();
    OGRFeature* GetNextFeature(OGRGeoJSONLayer* poLayer);
    OGRFeature* GetFeature(OGRGeoJSONLayer* poLayer, GIntBig nFID);
    bool IngestAll(OGRGeoJSONLayer* poLayer);

    VSILFILE* GetFP() { return fp_; }
    bool CanEasilyAppend() const { return bCanEasilyAppend_; }
    bool FCHasBBOX() const { return bFCHasBBOX_; }

  private:
    friend class OGRGeoJSONReaderStreamingParser;

    json_object* poGJObject_;
    OGRGeoJSONReaderStreamingParser* poStreamingParser_;
    bool bFirstSeg_;
    bool bJSonPLikeWrapper_;
    VSILFILE* fp_;
    bool bCanEasilyAppend_;
    bool bFCHasBBOX_;

    size_t nBufferSize_;
    GByte* pabyBuffer_;

    GIntBig nTotalFeatureCount_;
    GUIntBig nTotalOGRFeatureMemEstimate_;

    std::map<GIntBig, std::pair<vsi_l_offset, vsi_l_offset>> oMapFIDToOffsetSize_;
    //
    // Copy operations not supported.
    //
    CPL_DISALLOW_COPY_ASSIGN(OGRGeoJSONReader)

    //
    // Translation utilities.
    //
    bool GenerateLayerDefn( OGRGeoJSONLayer* poLayer, json_object* poGJObject );

    static bool AddFeature( OGRGeoJSONLayer* poLayer, OGRGeometry* poGeometry );
    static bool AddFeature( OGRGeoJSONLayer* poLayer, OGRFeature* poFeature );

    void ReadFeatureCollection( OGRGeoJSONLayer* poLayer, json_object* poObj );
    size_t SkipPrologEpilogAndUpdateJSonPLikeWrapper( size_t nRead );
};",1,334 2000 58 439 2001 123 439 58 2000 40 41 59 126 2000 40 41 59 2002 2003 40 341 330 42 2004 41 59 492 2005 40 2006 42 2007 41 59 492 2008 40 2006 42 2007 44 341 330 42 2009 44 2010 42 2011 41 59 323 2012 40 2006 42 2007 44 2013 42 2014 44 323 38 2015 41 59 2010 42 2016 40 41 123 450 2017 59 125 492 2018 40 41 59 2019 42 2020 40 2021 42 2022 41 59 2019 42 2023 40 2021 42 2022 44 2024 2025 41 59 323 2026 40 2021 42 2022 41 59 2013 42 2027 40 41 123 450 2028 59 125 323 2029 40 41 341 123 450 2030 59 125 323 2031 40 41 341 123 450 2032 59 125 437 58 387 334 2033 59 2010 42 2034 59 2033 42 2035 59 323 2036 59 323 2037 59 2013 42 2038 59 323 2039 59 323 2040 59 2041 2042 59 2043 42 2044 59 2024 2045 59 2046 2047 59 2048 646 2049 60 2024 44 2048 646 2050 60 2051 44 2051 640 2052 59 621 621 621 2053 40 2000 41 621 621 621 323 2054 40 2021 42 2022 44 2010 42 2055 41 59 457 323 2056 40 2021 42 2022 44 2057 42 2058 41 59 457 323 2056 40 2021 42 2022 44 2019 42 2059 41 59 492 2060 40 2021 42 2022 44 2010 42 2011 41 59 2041 2061 40 2041 2062 41 59 125 59 
99744,C++,"class CPL_DLL CPLJSonStreamingParser
{
        CPL_DISALLOW_COPY_ASSIGN(CPLJSonStreamingParser)

        enum State
        {
            INIT,
            OBJECT,
            ARRAY,
            STRING,
            NUMBER,
            STATE_TRUE,
            STATE_FALSE,
            STATE_NULL
        };

        bool m_bExceptionOccurred = false;
        bool m_bElementFound = false;
        int m_nLastChar = 0;
        int m_nLineCounter = 1;
        int m_nCharCounter = 1;
        std::vector<State> m_aState{};
        std::string m_osToken{};
        enum class ArrayState
        {
            INIT,
            AFTER_COMMA,
            AFTER_VALUE
        };
        std::vector<ArrayState> m_abArrayState{};
        bool m_bInStringEscape = false;
        bool m_bInUnicode = false;
        std::string m_osUnicodeHex{};
        size_t m_nMaxDepth = 1024;
        size_t m_nMaxStringSize = 10000000;

        enum MemberState
        {
            WAITING_KEY,
            IN_KEY,
            KEY_FINISHED,
            IN_VALUE
        };
        std::vector<MemberState> m_aeObjectState{};

        enum State currentState() { return m_aState.back(); }
        void SkipSpace(const char*& pStr, size_t& nLength);
        void AdvanceChar(const char*& pStr, size_t& nLength);
        bool EmitException(const char* pszMessage);
        bool EmitUnexpectedChar(char ch, const char* pszExpecting = nullptr);
        bool StartNewToken(const char*& pStr, size_t& nLength);
        bool CheckAndEmitTrueFalseOrNull(char ch);
        bool CheckStackEmpty();
        void DecodeUnicode();

    public:
        CPLJSonStreamingParser();
        virtual ~CPLJSonStreamingParser();

        void SetMaxDepth(size_t nVal);
        void SetMaxStringSize(size_t nVal);
        bool ExceptionOccurred() const { return m_bExceptionOccurred; }

        static std::string GetSerializedString(const char* pszStr);

        virtual void Reset();
        virtual bool Parse(const char* pStr, size_t nLength, bool bFinished);

        virtual void String(const char* /*pszValue*/, size_t /*nLength*/) {}
        virtual void Number(const char* /*pszValue*/, size_t /*nLength*/) {}
        virtual void Boolean(bool /*b*/) {}
        virtual void Null() {}

        virtual void StartObject() {}
        virtual void EndObject() {}
        virtual void StartObjectMember(const char* /*pszKey*/, size_t /*nLength*/) {}

        virtual void StartArray() {}
        virtual void EndArray() {}
        virtual void StartArrayMember() {}

        virtual void Exception(const char* /*pszMessage*/) {}
};",1,334 2000 2001 123 2002 40 2001 41 370 2003 123 2004 44 2005 44 2006 44 2007 44 2008 44 2009 44 2010 44 2011 125 59 323 2012 61 380 59 323 2013 61 380 59 404 2014 61 1500 59 404 2015 61 1501 59 404 2016 61 1501 59 2017 646 2018 60 2003 62 2019 123 125 59 2017 646 461 2020 123 125 59 370 334 2021 123 2022 44 2023 44 2024 125 59 2017 646 2018 60 2021 62 2025 123 125 59 323 2026 61 380 59 323 2027 61 380 59 2017 646 461 2028 123 125 59 2029 2030 61 1505 59 2029 2031 61 1508 59 370 2032 123 2033 44 2034 44 2035 44 2036 125 59 2017 646 2018 60 2032 62 2037 123 125 59 370 2003 2038 40 41 123 450 2019 46 2039 40 41 59 125 492 2040 40 341 330 42 38 2041 44 2029 38 2042 41 59 492 2043 40 341 330 42 38 2041 44 2029 38 2042 41 59 323 2044 40 341 330 42 2045 41 59 323 2046 40 330 2047 44 341 330 42 2048 61 425 41 59 323 2049 40 341 330 42 38 2041 44 2029 38 2042 41 59 323 2050 40 330 2047 41 59 323 2051 40 41 59 492 2052 40 41 59 439 58 2001 40 41 59 491 126 2001 40 41 59 492 2053 40 2029 2054 41 59 492 2055 40 2029 2054 41 59 323 2056 40 41 341 123 450 2012 59 125 457 2017 646 461 2057 40 341 330 42 2058 41 59 491 492 2059 40 41 59 491 323 2060 40 341 330 42 2041 44 2029 2042 44 323 2061 41 59 491 492 2062 40 341 330 42 604 44 2029 604 41 123 125 491 492 2063 40 341 330 42 604 44 2029 604 41 123 125 491 492 2064 40 323 604 41 123 125 491 492 2065 40 41 123 125 491 492 2066 40 41 123 125 491 492 2067 40 41 123 125 491 492 2068 40 341 330 42 604 44 2029 604 41 123 125 491 492 2069 40 41 123 125 491 492 2070 40 41 123 125 491 492 2071 40 41 123 125 491 492 2072 40 341 330 42 604 41 123 125 125 59 
98859,C++,"class OGRGeoPackageLayer CPL_NON_FINAL: public OGRLayer, public IOGRSQLiteGetSpatialWhere
{
  protected:
    GDALGeoPackageDataset *m_poDS;

    OGRFeatureDefn*      m_poFeatureDefn;
    int                  iNextShapeId;

    sqlite3_stmt        *m_poQueryStatement;
    bool                 bDoStep;
    bool                 m_bEOF = false;

    char                *m_pszFidColumn;

    int                 iFIDCol;
    int                 iGeomCol;
    int                *panFieldOrdinals;

    void                ClearStatement();
    virtual OGRErr      ResetStatement() = 0;

    void                BuildFeatureDefn( const char *pszLayerName,
                                           sqlite3_stmt *hStmt );

    OGRFeature*         TranslateFeature(sqlite3_stmt* hStmt);

  public:

    explicit            OGRGeoPackageLayer(GDALGeoPackageDataset* poDS);
                        virtual ~OGRGeoPackageLayer();
    /************************************************************************/
    /* OGR API methods */

    OGRFeature*         GetNextFeature() override;
    const char*         GetFIDColumn() override;
    void                ResetReading() override;
    int                 TestCapability( const char * ) override;
    OGRFeatureDefn*     GetLayerDefn() override { return m_poFeatureDefn; }

    virtual bool         HasFastSpatialFilter(int /*iGeomCol*/) override { return false; }
    virtual CPLString    GetSpatialWhere(int /*iGeomCol*/,
                                         OGRGeometry* /*poFilterGeom*/) override { return """"; }
};",1,334 2000 2001 58 439 2002 44 439 2003 123 438 58 2004 42 2005 59 2006 42 2007 59 404 2008 59 2009 42 2010 59 323 2011 59 323 2012 61 380 59 330 42 2013 59 404 2014 59 404 2015 59 404 42 2016 59 492 2017 40 41 59 491 2018 2019 40 41 61 1500 59 492 2020 40 341 330 42 2021 44 2009 42 2022 41 59 2023 42 2024 40 2009 42 2022 41 59 439 58 376 2000 40 2004 42 2025 41 59 491 126 2000 40 41 59 618 604 2023 42 2026 40 41 431 59 341 330 42 2027 40 41 431 59 492 2028 40 41 431 59 404 2029 40 341 330 42 41 431 59 2006 42 2030 40 41 431 123 450 2007 59 125 491 323 2031 40 404 604 41 431 123 450 380 59 125 491 2032 2033 40 404 604 44 2034 42 604 41 431 123 450 648 59 125 125 59 
98860,C++,"class OGRGeoPackageSelectLayer final : public OGRGeoPackageLayer, public IOGRSQLiteSelectLayer
{
    CPL_DISALLOW_COPY_ASSIGN(OGRGeoPackageSelectLayer)

    OGRSQLiteSelectLayerCommonBehaviour* poBehavior;

    virtual OGRErr      ResetStatement() override;

  public:
                        OGRGeoPackageSelectLayer( GDALGeoPackageDataset *,
                                              const CPLString& osSQL,
                                              sqlite3_stmt *,
                                              bool bUseStatementForGetNextFeature,
                                              bool bEmptyLayer );
                       virtual ~OGRGeoPackageSelectLayer();

    virtual void        ResetReading() override;

    virtual OGRFeature *GetNextFeature() override;
    virtual GIntBig     GetFeatureCount( int ) override;

    virtual void        SetSpatialFilter( OGRGeometry * poGeom ) override { SetSpatialFilter(0, poGeom); }
    virtual void        SetSpatialFilter( int iGeomField, OGRGeometry * ) override;
    virtual OGRErr      SetAttributeFilter( const char * ) override;

    virtual int         TestCapability( const char * ) override;

    virtual OGRErr      GetExtent(OGREnvelope *psExtent, int bForce = TRUE) override { return GetExtent(0, psExtent, bForce); }
    virtual OGRErr      GetExtent(int iGeomField, OGREnvelope *psExtent, int bForce = TRUE) override;

    virtual OGRFeatureDefn *     GetLayerDefn() override { return OGRGeoPackageLayer::GetLayerDefn(); }
    virtual char*&               GetAttrQueryString() override { return m_pszAttrQueryString; }
    virtual OGRFeatureQuery*&    GetFeatureQuery() override { return m_poAttrQuery; }
    virtual OGRGeometry*&        GetFilterGeom() override { return m_poFilterGeom; }
    virtual int&                 GetIGeomFieldFilter() override { return m_iGeomFieldFilter; }
    virtual OGRSpatialReference* GetSpatialRef() override { return OGRGeoPackageLayer::GetSpatialRef(); }
    virtual int                  InstallFilter( OGRGeometry * poGeomIn ) override { return OGRGeoPackageLayer::InstallFilter(poGeomIn); }
    virtual int                  HasReadFeature() override { return iNextShapeId > 0; }
    virtual void                 BaseResetReading() override { OGRGeoPackageLayer::ResetReading(); }
    virtual OGRFeature          *BaseGetNextFeature() override { return OGRGeoPackageLayer::GetNextFeature(); }
    virtual OGRErr               BaseSetAttributeFilter(const char* pszQuery) override { return OGRGeoPackageLayer::SetAttributeFilter(pszQuery); }
    virtual GIntBig              BaseGetFeatureCount(int bForce) override { return OGRGeoPackageLayer::GetFeatureCount(bForce); }
    virtual int                  BaseTestCapability( const char *pszCap ) override { return OGRGeoPackageLayer::TestCapability(pszCap); }
    virtual OGRErr               BaseGetExtent(OGREnvelope *psExtent, int bForce) override { return OGRGeoPackageLayer::GetExtent(psExtent, bForce); }
    virtual OGRErr               BaseGetExtent(int iGeomField, OGREnvelope *psExtent, int bForce) override { return OGRGeoPackageLayer::GetExtent(iGeomField, psExtent, bForce); }
};",1,334 2000 381 58 439 2001 44 439 2002 123 2003 40 2000 41 2004 42 2005 59 491 2006 2007 40 41 431 59 439 58 2000 40 2008 42 44 341 2009 38 2010 44 2011 42 44 323 2012 44 323 2013 41 59 491 126 2000 40 41 59 491 492 2014 40 41 431 59 491 2015 42 2016 40 41 431 59 491 2017 2018 40 404 41 431 59 491 492 2019 40 2020 42 2021 41 431 123 2019 40 1500 44 2021 41 59 125 491 492 2019 40 404 2022 44 2020 42 41 431 59 491 2006 2023 40 341 330 42 41 431 59 491 404 2024 40 341 330 42 41 431 59 491 2006 2025 40 2026 42 2027 44 404 2028 61 2029 41 431 123 450 2025 40 1500 44 2027 44 2028 41 59 125 491 2006 2025 40 404 2022 44 2026 42 2027 44 404 2028 61 2029 41 431 59 491 2030 42 2031 40 41 431 123 450 2001 646 2031 40 41 59 125 491 330 42 38 2032 40 41 431 123 450 2033 59 125 491 2034 42 38 2035 40 41 431 123 450 2036 59 125 491 2020 42 38 2037 40 41 431 123 450 2038 59 125 491 404 38 2039 40 41 431 123 450 2040 59 125 491 2041 42 2042 40 41 431 123 450 2001 646 2042 40 41 59 125 491 404 2043 40 2020 42 2044 41 431 123 450 2001 646 2043 40 2044 41 59 125 491 404 2045 40 41 431 123 450 2046 62 1500 59 125 491 492 2047 40 41 431 123 2001 646 2014 40 41 59 125 491 2015 42 2048 40 41 431 123 450 2001 646 2016 40 41 59 125 491 2006 2049 40 341 330 42 2050 41 431 123 450 2001 646 2023 40 2050 41 59 125 491 2017 2051 40 404 2028 41 431 123 450 2001 646 2018 40 2028 41 59 125 491 404 2052 40 341 330 42 2053 41 431 123 450 2001 646 2024 40 2053 41 59 125 491 2006 2054 40 2026 42 2027 44 404 2028 41 431 123 450 2001 646 2025 40 2027 44 2028 41 59 125 491 2006 2054 40 404 2022 44 2026 42 2027 44 404 2028 41 431 123 450 2001 646 2025 40 2022 44 2027 44 2028 41 59 125 125 59 
98991,C++,"class GDALGeoPackageDataset final : public OGRSQLiteBaseDataSource, public GDALGPKGMBTilesLikePseudoDataset
{
    friend class GDALGeoPackageRasterBand;
    friend class OGRGeoPackageLayer;
    friend class OGRGeoPackageTableLayer;

    GUInt32             m_nApplicationId;
    GUInt32             m_nUserVersion;
    OGRGeoPackageTableLayer** m_papoLayers;
    int                 m_nLayers;
    void                CheckUnknownExtensions(bool bCheckRasterTable = false);
#ifdef ENABLE_GPKG_OGR_CONTENTS
    bool                m_bHasGPKGOGRContents;
#endif
    bool                m_bHasGPKGGeometryColumns;
    bool                m_bHasDefinition12_063;
    bool                m_bHasEpochColumn = false; // whether gpkg_spatial_ref_sys has a epoch column

    CPLString           m_osIdentifier;
    bool                m_bIdentifierAsCO;
    CPLString           m_osDescription;
    bool                m_bDescriptionAsCO;
    bool                m_bGridCellEncodingAsCO = false;
    bool                m_bHasReadMetadataFromStorage;
    bool                m_bMetadataDirty;
    CPLStringList       m_aosSubDatasets{};
    OGRSpatialReference m_oSRS{};
    bool                m_bRecordInsertedInGPKGContent;
    bool                m_bGeoTransformValid;
    double              m_adfGeoTransform[6];
    int                 m_nSRID;
    double              m_dfTMSMinX;
    double              m_dfTMSMaxY;

    int                 m_nOverviewCount;
    GDALGeoPackageDataset** m_papoOverviewDS;
    bool                m_bZoomOther;

    bool                m_bInFlushCache;

    bool                m_bDateTimeWithTZ = true;

    CPLString           m_osTilingScheme;

        bool            ComputeTileAndPixelShifts();
        bool            AllocCachedTiles();
        bool            InitRaster ( GDALGeoPackageDataset* poParentDS,
                                     const char* pszTableName,
                                     double dfMinX,
                                     double dfMinY,
                                     double dfMaxX,
                                     double dfMaxY,
                                     const char* pszContentsMinX,
                                     const char* pszContentsMinY,
                                     const char* pszContentsMaxX,
                                     const char* pszContentsMaxY,
                                     char** papszOpenOptions,
                                     const SQLResult& oResult,
                                     int nIdxInResult );
        bool            InitRaster ( GDALGeoPackageDataset* poParentDS,
                                     const char* pszTableName,
                                     int nZoomLevel,
                                     int nBandCount,
                                     double dfTMSMinX,
                                     double dfTMSMaxY,
                                     double dfPixelXSize,
                                     double dfPixelYSize,
                                     int nTileWidth,
                                     int nTileHeight,
                                     int nTileMatrixWidth,
                                     int nTileMatrixHeight,
                                     double dfGDALMinX,
                                     double dfGDALMinY,
                                     double dfGDALMaxX,
                                     double dfGDALMaxY );

        bool    OpenRaster( const char* pszTableName,
                            const char* pszIdentifier,
                            const char* pszDescription,
                            int nSRSId,
                            double dfMinX,
                            double dfMinY,
                            double dfMaxX,
                            double dfMaxY,
                            const char* pszContentsMinX,
                            const char* pszContentsMinY,
                            const char* pszContentsMaxX,
                            const char* pszContentsMaxY,
                            bool bIsTiles,
                            char** papszOptions );
        CPLErr   FinalizeRasterRegistration();

        bool                    RegisterWebPExtension();
        bool                    RegisterZoomOtherExtension();
        void                    ParseCompressionOptions(char** papszOptions);

        bool                    HasMetadataTables() const;
        bool                    CreateMetadataTables();
        const char*             CheckMetadataDomain( const char* pszDomain );
        void                    WriteMetadata(CPLXMLNode* psXMLNode, /* will be destroyed by the method */
                                              const char* pszTableName);
        CPLErr                  FlushMetadata();

        int                     FindLayerIndex(const char* pszLayerName);

        bool                    HasGriddedCoverageAncillaryTable();
        bool                    CreateTileGriddedTable(char** papszOptions);

        void                    RemoveOGREmptyTable();

        std::map<CPLString, CPLString> m_oMapNameToType;
        const std::map<CPLString, CPLString>&
                                        GetNameTypeMapFromSQliteMaster();
        void RemoveTableFromSQLiteMasterCache(const char* pszTableName);

        bool                    m_bMapTableToExtensionsBuilt;
        std::map< CPLString, std::vector<GPKGExtensionDesc> > m_oMapTableToExtensions;
        const std::map< CPLString, std::vector<GPKGExtensionDesc> > &
                                        GetUnknownExtensionsTableSpecific();

        bool                    m_bMapTableToContentsBuilt;
        std::map< CPLString, GPKGContentsDesc > m_oMapTableToContents;
        const std::map< CPLString, GPKGContentsDesc > & GetContents();

        std::map<int, OGRSpatialReference*> m_oMapSrsIdToSrs;

        OGRErr              DeleteLayerCommon( const char* pszLayerName );
        OGRErr              DeleteRasterLayer( const char* pszLayerName );
        bool                DeleteVectorOrRasterLayer(
                                                const char* pszLayerName );

        bool                ConvertGpkgSpatialRefSysToExtensionWkt2();
        void                DetectSpatialRefSysColumns();

        std::map<int, bool> m_oSetGPKGLayerWarnings{};

        void                FixupWrongRTreeTrigger();
        void                FixupWrongMedataReferenceColumnNameUpdate();

    public:
                            GDALGeoPackageDataset();
                            virtual ~GDALGeoPackageDataset();

        virtual char **     GetMetadata( const char *pszDomain = """" ) override;
        virtual const char *GetMetadataItem( const char * pszName,
                                             const char * pszDomain = """" ) override;
        virtual char **     GetMetadataDomainList() override;
        virtual CPLErr      SetMetadata( char ** papszMetadata,
                                         const char * pszDomain = """" ) override;
        virtual CPLErr      SetMetadataItem( const char * pszName,
                                             const char * pszValue,
                                             const char * pszDomain = """" ) override;

        const OGRSpatialReference* GetSpatialRef() const override;
        CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override;

        virtual CPLErr      GetGeoTransform( double* padfGeoTransform ) override;
        virtual CPLErr      SetGeoTransform( double* padfGeoTransform ) override;

        virtual void        FlushCache(bool bAtClosing) override;
        virtual CPLErr      IBuildOverviews( const char *, int, int *,
                                             int, int *, GDALProgressFunc, void * ) override;

        virtual int         GetLayerCount() override { return m_nLayers; }
        int                 Open( GDALOpenInfo* poOpenInfo );
        int                 Create( const char * pszFilename,
                                    int nXSize,
                                    int nYSize,
                                    int nBands,
                                    GDALDataType eDT,
                                    char **papszOptions );
        OGRLayer*           GetLayer( int iLayer ) override;
        OGRErr              DeleteLayer( int iLayer ) override;
        OGRLayer*           ICreateLayer( const char * pszLayerName,
                                         OGRSpatialReference * poSpatialRef,
                                         OGRwkbGeometryType eGType,
                                         char **papszOptions ) override;
        int                 TestCapability( const char * ) override;

        const OGRFieldDomain* GetFieldDomain(const std::string& name) const override;
        bool                AddFieldDomain(std::unique_ptr<OGRFieldDomain>&& domain,
                                           std::string& failureReason) override;

        virtual std::pair<OGRLayer*, IOGRSQLiteGetSpatialWhere*> GetLayerWithGetSpatialWhereByName( const char* pszName ) override;

        virtual OGRLayer *  ExecuteSQL( const char *pszSQLCommand,
                                        OGRGeometry *poSpatialFilter,
                                        const char *pszDialect ) override;
        virtual void        ReleaseResultSet( OGRLayer * poLayer ) override;

        virtual OGRErr      CommitTransaction() override;
        virtual OGRErr      RollbackTransaction() override;

        inline bool         IsInTransaction() const { return nSoftTransactionLevel > 0; }

        int                 GetSrsId( const OGRSpatialReference& oSRS );
        const char*         GetSrsName( const OGRSpatialReference& oSRS );
        OGRSpatialReference* GetSpatialRef( int iSrsId, bool bFallbackToEPSG = false );
        OGRErr              CreateExtensionsTableIfNecessary();
        bool                HasExtensionsTable();
        void                SetMetadataDirty() { m_bMetadataDirty = true; }

        bool                    HasDataColumnsTable() const;
        bool                    HasDataColumnConstraintsTable() const;
        bool                CreateColumnsTableAndColumnConstraintsTablesIfNecessary();

        const char*         GetGeometryTypeString(OGRwkbGeometryType eType);

        void                ResetReadingAllLayers();
        OGRErr              UpdateGpkgContentsLastChange(
                                                const char* pszTableName);

        static GDALDataset* CreateCopy( const char *pszFilename,
                                                   GDALDataset *poSrcDS,
                                                   int bStrict,
                                                   char ** papszOptions,
                                                   GDALProgressFunc pfnProgress,
                                                   void * pProgressData );

        static std::string GetCurrentDateEscapedSQL();

    protected:
        // Coming from GDALGPKGMBTilesLikePseudoDataset

        virtual CPLErr                  IFlushCacheWithErrCode(bool bAtClosing) override;
        virtual int                     IGetRasterCount() override { return nBands; }
        virtual GDALRasterBand*         IGetRasterBand(int nBand) override { return GetRasterBand(nBand); }
        virtual sqlite3                *IGetDB() override { return GetDB(); }
        virtual bool                    IGetUpdate() override { return GetUpdate(); }
        virtual bool                    ICanIWriteBlock() override;
        virtual OGRErr                  IStartTransaction() override { return SoftStartTransaction(); }
        virtual OGRErr                  ICommitTransaction() override { return SoftCommitTransaction(); }
        virtual const char             *IGetFilename() override { return m_pszFilename; }
        virtual int                     GetRowFromIntoTopConvention(int nRow) override { return nRow; }

    private:

        OGRErr              PragmaCheck(const char * pszPragma, const char * pszExpected, int nRowsExpected);
        OGRErr              SetApplicationAndUserVersionId();
        bool                ReOpenDB();
        bool                OpenOrCreateDB( int flags );
        void                InstallSQLFunctions();
        bool                HasGDALAspatialExtension();
};",1,334 2000 381 58 439 2001 44 439 2002 123 387 334 2003 59 387 334 2004 59 387 334 2005 59 2006 2007 59 2006 2008 59 2005 42 42 2009 59 404 2010 59 492 2011 40 323 2012 61 380 41 59 35 393 2013 323 2014 59 35 366 323 2015 59 323 2016 59 323 2017 61 380 59 621 2018 2019 59 323 2020 59 2018 2021 59 323 2022 59 323 2023 61 380 59 323 2024 59 323 2025 59 2026 2027 123 125 59 2028 2029 123 125 59 323 2030 59 323 2031 59 356 2032 91 1502 93 59 404 2033 59 356 2034 59 356 2035 59 404 2036 59 2000 42 42 2037 59 323 2038 59 323 2039 59 323 2040 61 473 59 2018 2041 59 323 2042 40 41 59 323 2043 40 41 59 323 2044 40 2000 42 2045 44 341 330 42 2046 44 356 2047 44 356 2048 44 356 2049 44 356 2050 44 341 330 42 2051 44 341 330 42 2052 44 341 330 42 2053 44 341 330 42 2054 44 330 42 42 2055 44 341 2056 38 2057 44 404 2058 41 59 323 2044 40 2000 42 2045 44 341 330 42 2046 44 404 2059 44 404 2060 44 356 2061 44 356 2062 44 356 2063 44 356 2064 44 404 2065 44 404 2066 44 404 2067 44 404 2068 44 356 2069 44 356 2070 44 356 2071 44 356 2072 41 59 323 2073 40 341 330 42 2046 44 341 330 42 2074 44 341 330 42 2075 44 404 2076 44 356 2047 44 356 2048 44 356 2049 44 356 2050 44 341 330 42 2051 44 341 330 42 2052 44 341 330 42 2053 44 341 330 42 2054 44 323 2077 44 330 42 42 2078 41 59 2079 2080 40 41 59 323 2081 40 41 59 323 2082 40 41 59 492 2083 40 330 42 42 2078 41 59 323 2084 40 41 341 59 323 2085 40 41 59 341 330 42 2086 40 341 330 42 2087 41 59 492 2088 40 2089 42 2090 44 604 341 330 42 2046 41 59 2079 2091 40 41 59 404 2092 40 341 330 42 2093 41 59 323 2094 40 41 59 323 2095 40 330 42 42 2078 41 59 492 2096 40 41 59 2097 646 2098 60 2018 44 2018 62 2099 59 341 2097 646 2098 60 2018 44 2018 62 38 2100 40 41 59 492 2101 40 341 330 42 2046 41 59 323 2102 59 2097 646 2098 60 2018 44 2097 646 2103 60 2104 62 62 2105 59 341 2097 646 2098 60 2018 44 2097 646 2103 60 2104 62 62 38 2106 40 41 59 323 2107 59 2097 646 2098 60 2018 44 2108 62 2109 59 341 2097 646 2098 60 2018 44 2108 62 38 2110 40 41 59 2097 646 2098 60 404 44 2028 42 62 2111 59 2112 2113 40 341 330 42 2093 41 59 2112 2114 40 341 330 42 2093 41 59 323 2115 40 341 330 42 2093 41 59 323 2116 40 41 59 492 2117 40 41 59 2097 646 2098 60 404 44 323 62 2118 123 125 59 492 2119 40 41 59 492 2120 40 41 59 439 58 2000 40 41 59 491 126 2000 40 41 59 491 330 42 42 2121 40 341 330 42 2087 61 648 41 431 59 491 341 330 42 2122 40 341 330 42 2123 44 341 330 42 2087 61 648 41 431 59 491 330 42 42 2124 40 41 431 59 491 2079 2125 40 330 42 42 2126 44 341 330 42 2087 61 648 41 431 59 491 2079 2127 40 341 330 42 2123 44 341 330 42 2128 44 341 330 42 2087 61 648 41 431 59 341 2028 42 2129 40 41 341 431 59 2079 2130 40 341 2028 42 2131 41 431 59 491 2079 2132 40 356 42 2133 41 431 59 491 2079 2134 40 356 42 2133 41 431 59 491 492 2135 40 323 2136 41 431 59 491 2079 2137 40 341 330 42 44 404 44 404 42 44 404 44 404 42 44 2138 44 492 42 41 431 59 491 404 2139 40 41 431 123 450 2010 59 125 404 2140 40 2141 42 2142 41 59 404 2143 40 341 330 42 2144 44 404 2145 44 404 2146 44 404 2147 44 2148 2149 44 330 42 42 2078 41 59 2150 42 2151 40 404 2152 41 431 59 2112 2153 40 404 2152 41 431 59 2150 42 2154 40 341 330 42 2093 44 2028 42 2155 44 2156 2157 44 330 42 42 2078 41 431 59 404 2158 40 341 330 42 41 431 59 341 2159 42 2160 40 341 2097 646 461 38 2161 41 341 431 59 323 2162 40 2097 646 2163 60 2159 62 605 2164 44 2097 646 461 38 2165 41 431 59 491 2097 646 2166 60 2150 42 44 2167 42 62 2168 40 341 330 42 2123 41 431 59 491 2150 42 2169 40 341 330 42 2170 44 2171 42 2172 44 341 330 42 2173 41 431 59 491 492 2174 40 2150 42 2175 41 431 59 491 2112 2176 40 41 431 59 491 2112 2177 40 41 431 59 401 323 2178 40 41 341 123 450 2179 62 1500 59 125 404 2180 40 341 2028 38 2181 41 59 341 330 42 2182 40 341 2028 38 2181 41 59 2028 42 2129 40 404 2183 44 323 2184 61 380 41 59 2112 2185 40 41 59 323 2186 40 41 59 492 2187 40 41 123 2025 61 473 59 125 323 2188 40 41 341 59 323 2189 40 41 341 59 323 2190 40 41 59 341 330 42 2191 40 2156 2192 41 59 492 2193 40 41 59 2112 2194 40 341 330 42 2046 41 59 457 2195 42 2196 40 341 330 42 2144 44 2195 42 2197 44 404 2198 44 330 42 42 2078 44 2138 2199 44 492 42 2200 41 59 457 2097 646 461 2201 40 41 59 438 58 621 491 2079 2202 40 323 2136 41 431 59 491 404 2203 40 41 431 123 450 2147 59 125 491 2204 42 2205 40 404 2206 41 431 123 450 2207 40 2206 41 59 125 491 2208 42 2209 40 41 431 123 450 2210 40 41 59 125 491 323 2211 40 41 431 123 450 2212 40 41 59 125 491 323 2213 40 41 431 59 491 2112 2214 40 41 431 123 450 2215 40 41 59 125 491 2112 2216 40 41 431 123 450 2217 40 41 59 125 491 341 330 42 2218 40 41 431 123 450 2219 59 125 491 404 2220 40 404 2221 41 431 123 450 2221 59 125 437 58 2112 2222 40 341 330 42 2223 44 341 330 42 2224 44 404 2225 41 59 2112 2226 40 41 59 323 2227 40 41 59 323 2228 40 404 2229 41 59 492 2230 40 41 59 323 2231 40 41 59 125 59 
121179,C++,"class MainWindow : public Ui::RpWindow {
public:
	explicit MainWindow(not_null<Controller*> controller);
	virtual ~MainWindow();

	[[nodiscard]] Window::Controller &controller() const {
		return *_controller;
	}
	[[nodiscard]] Main::Account &account() const;
	[[nodiscard]] Window::SessionController *sessionController() const;

	bool hideNoQuit();

	void showFromTray();
	void quitFromTray();
	void activate();
	virtual void showFromTrayMenu() {
		showFromTray();
	}

	[[nodiscard]] QRect desktopRect() const;

	void init();

	void updateIsActive();

	[[nodiscard]] bool isActive() const {
		return _isActive;
	}
	[[nodiscard]] virtual bool isActiveForTrayMenu() {
		updateIsActive();
		return isActive();
	}

	bool positionInited() const {
		return _positionInited;
	}
	void positionUpdated();

	void reActivateWindow();

	void showRightColumn(object_ptr<TWidget> widget);
	int maximalExtendBy() const;
	bool canExtendNoMove(int extendBy) const;

	// Returns how much could the window get extended.
	int tryToExtendWidthBy(int addToWidth);

	virtual void updateTrayMenu() {
	}
	virtual void fixOrder() {
	}
	virtual void setInnerFocus() {
		setFocus();
	}

	Ui::RpWidget *bodyWidget() {
		return _body.data();
	}

	void launchDrag(std::unique_ptr<QMimeData> data, Fn<void()> &&callback);

	rpl::producer<> leaveEvents() const;

	virtual void updateWindowIcon();

	void clearWidgets();

	int computeMinWidth() const;
	int computeMinHeight() const;

	void recountGeometryConstraints();
	virtual void updateControlsGeometry();

	bool minimizeToTray();
	void updateGlobalMenu() {
		updateGlobalMenuHook();
	}

protected:
	void leaveEventHook(QEvent *e) override;

	void savePosition(Qt::WindowState state = Qt::WindowActive);
	void handleStateChanged(Qt::WindowState state);
	void handleActiveChanged();
	void handleVisibleChanged(bool visible);

	virtual void initHook() {
	}

	virtual void activeChangedHook() {
	}

	virtual void handleActiveChangedHook() {
	}

	virtual void handleVisibleChangedHook(bool visible) {
	}

	virtual void clearWidgetsHook() {
	}

	virtual void stateChangedHook(Qt::WindowState state) {
	}

	virtual void unreadCounterChangedHook() {
	}

	virtual void closeWithoutDestroy() {
		hide();
	}

	virtual void updateGlobalMenuHook() {
	}

	virtual void initTrayMenuHook() {
	}
	virtual bool hasTrayIcon() const {
		return false;
	}
	virtual void showTrayTooltip() {
	}

	virtual void workmodeUpdated(Core::Settings::WorkMode mode) {
	}

	virtual void createGlobalMenu() {
	}

	virtual bool initGeometryFromSystem() {
		return false;
	}

	// This one is overriden in Windows for historical reasons.
	virtual int32 screenNameChecksum(const QString &name) const;

	void setPositionInited();
	void attachToTrayIcon(not_null<QSystemTrayIcon*> icon);
	virtual void handleTrayIconActication(
		QSystemTrayIcon::ActivationReason reason) = 0;
	void updateUnreadCounter();

	virtual QRect computeDesktopRect() const;

private:
	void refreshTitleWidget();
	void updateMinimumSize();
	void updatePalette();

	[[nodiscard]] Core::WindowPosition positionFromSettings() const;
	[[nodiscard]] QRect countInitialGeometry(Core::WindowPosition position);
	void initGeometry();

	bool computeIsActive() const;

	not_null<Window::Controller*> _controller;

	base::Timer _positionUpdatedTimer;
	bool _positionInited = false;

	object_ptr<Ui::PlainShadow> _titleShadow = { nullptr };
	object_ptr<Ui::RpWidget> _outdated;
	object_ptr<Ui::RpWidget> _body;
	object_ptr<TWidget> _rightColumn = { nullptr };

	QIcon _icon;
	bool _usingSupportIcon = false;

	bool _isActive = false;

	rpl::event_stream<> _leaveEvents;

	bool _maximizedBeforeHide = false;

	mutable QRect _monitorRect;
	mutable crl::time _monitorLastGot = 0;

};",1,334 2000 58 439 2001 646 2002 123 439 58 376 2000 40 2003 60 2004 42 62 2005 41 59 491 126 2000 40 41 59 91 91 2006 93 93 2007 646 2004 38 2005 40 41 341 123 450 42 2008 59 125 91 91 2006 93 93 2009 646 2010 38 2011 40 41 341 59 91 91 2006 93 93 2007 646 2012 42 2013 40 41 341 59 323 2014 40 41 59 492 2015 40 41 59 492 2016 40 41 59 492 2017 40 41 59 491 492 2018 40 41 123 2015 40 41 59 125 91 91 2006 93 93 2019 2020 40 41 341 59 492 2021 40 41 59 492 2022 40 41 59 91 91 2006 93 93 323 2023 40 41 341 123 450 2024 59 125 91 91 2006 93 93 491 323 2025 40 41 123 2022 40 41 59 450 2023 40 41 59 125 323 2026 40 41 341 123 450 2027 59 125 492 2028 40 41 59 492 2029 40 41 59 492 2030 40 2031 60 2032 62 2033 41 59 404 2034 40 41 341 59 323 2035 40 404 2036 41 341 59 621 404 2037 40 404 2038 41 59 491 492 2039 40 41 123 125 491 492 2040 40 41 123 125 491 492 2041 40 41 123 2042 40 41 59 125 2001 646 2043 42 2044 40 41 123 450 2045 46 2046 40 41 59 125 492 2047 40 2048 646 2049 60 2050 62 2051 44 2052 60 492 40 41 62 605 2053 41 59 2054 646 2055 60 62 2056 40 41 341 59 491 492 2057 40 41 59 492 2058 40 41 59 404 2059 40 41 341 59 404 2060 40 41 341 59 492 2061 40 41 59 491 492 2062 40 41 59 323 2063 40 41 59 492 2064 40 41 123 2065 40 41 59 125 438 58 492 2066 40 2067 42 2068 41 431 59 492 2069 40 2070 646 2071 2072 61 2070 646 2073 41 59 492 2074 40 2070 646 2071 2072 41 59 492 2075 40 41 59 492 2076 40 323 2077 41 59 491 492 2078 40 41 123 125 491 492 2079 40 41 123 125 491 492 2080 40 41 123 125 491 492 2081 40 323 2077 41 123 125 491 492 2082 40 41 123 125 491 492 2083 40 2070 646 2071 2072 41 123 125 491 492 2084 40 41 123 125 491 492 2085 40 41 123 2086 40 41 59 125 491 492 2087 40 41 123 125 491 492 2088 40 41 123 125 491 323 2089 40 41 341 123 450 380 59 125 491 492 2090 40 41 123 125 491 492 2091 40 2092 646 2093 646 2094 2095 41 123 125 491 492 2096 40 41 123 125 491 323 2097 40 41 123 450 380 59 125 621 491 2098 2099 40 341 2100 38 2101 41 341 59 492 2102 40 41 59 492 2103 40 2003 60 2104 42 62 2105 41 59 491 492 2106 40 2104 646 2107 2108 41 61 1500 59 492 2109 40 41 59 491 2019 2110 40 41 341 59 437 58 492 2111 40 41 59 492 2112 40 41 59 492 2113 40 41 59 91 91 2006 93 93 2092 646 2114 2115 40 41 341 59 91 91 2006 93 93 2019 2116 40 2092 646 2114 2117 41 59 492 2118 40 41 59 323 2119 40 41 341 59 2003 60 2007 646 2004 42 62 2120 59 320 646 2121 2122 59 323 2123 61 380 59 2031 60 2001 646 2124 62 2125 61 123 425 125 59 2031 60 2001 646 2043 62 2126 59 2031 60 2001 646 2043 62 2127 59 2031 60 2032 62 2128 61 123 425 125 59 2129 2130 59 323 2131 61 380 59 323 2132 61 380 59 2054 646 2133 60 62 2134 59 323 2135 61 380 59 415 2019 2136 59 415 2137 646 2138 2139 61 1500 59 125 59 
121141,C++,"class MainWindow : public Platform::MainWindow {
public:
	explicit MainWindow(not_null<Window::Controller*> controller);
	~MainWindow();

	void finishFirstShow();

	void preventOrInvoke(Fn<void()> callback);

	void setupPasscodeLock();
	void clearPasscodeLock();
	void setupIntro(Intro::EnterPoint point);
	void setupMain();

	void showSettings();

	void setInnerFocus() override;

	MainWidget *sessionContent() const;

	[[nodiscard]] bool doWeMarkAsRead();


	bool takeThirdSectionFromLayer();

	void checkHistoryActivation();

	void sendPaths();

	bool contentOverlapped(const QRect &globalRect);
	bool contentOverlapped(QWidget *w, QPaintEvent *e) {
		return contentOverlapped(QRect(w->mapToGlobal(e->rect().topLeft()), e->rect().size()));
	}
	bool contentOverlapped(QWidget *w, const QRegion &r) {
		return contentOverlapped(QRect(w->mapToGlobal(r.boundingRect().topLeft()), r.boundingRect().size()));
	}

	void showMainMenu();
	void updateTrayMenu() override;
	void fixOrder() override;

	void showLayer(
		std::unique_ptr<Ui::LayerWidget> &&layer,
		Ui::LayerOptions options,
		anim::type animated);
	void showSpecialLayer(
		object_ptr<Ui::LayerWidget> layer,
		anim::type animated);
	bool showSectionInExistingLayer(
		not_null<Window::SectionMemento*> memento,
		const Window::SectionShow &params);
	void ui_showBox(
		object_ptr<Ui::BoxContent> box,
		Ui::LayerOptions options,
		anim::type animated);
	void ui_hideSettingsAndLayer(anim::type animated);
	void ui_removeLayerBlackout();
	bool ui_isLayerShown();
	bool showMediaPreview(
		Data::FileOrigin origin,
		not_null<DocumentData*> document);
	bool showMediaPreview(
		Data::FileOrigin origin,
		not_null<PhotoData*> photo);
	void hideMediaPreview();

	void updateControlsGeometry() override;

protected:
	bool eventFilter(QObject *o, QEvent *e) override;
	void closeEvent(QCloseEvent *e) override;

	void initHook() override;
	void activeChangedHook() override;
	void clearWidgetsHook() override;

private:
	[[nodiscard]] bool skipTrayClick() const;

	void createTrayIconMenu();
	void handleTrayIconActication(
		QSystemTrayIcon::ActivationReason reason) override;

	void applyInitialWorkMode();
	void ensureLayerCreated();
	void destroyLayer();

	void showBoxOrLayer(
		std::variant<
			v::null_t,
			object_ptr<Ui::BoxContent>,
			std::unique_ptr<Ui::LayerWidget>> &&layer,
		Ui::LayerOptions options,
		anim::type animated);

	void themeUpdated(const Window::Theme::BackgroundUpdate &data);

	void toggleDisplayNotifyFromTray();

	QPixmap grabInner();

	std::unique_ptr<Media::SystemMediaControlsManager> _mediaControlsManager;

	crl::time _lastTrayClickTime = 0;
	QPoint _lastMousePosition;
	bool _activeForTrayIconAction = true;

	object_ptr<Window::PasscodeLockWidget> _passcodeLock = { nullptr };
	object_ptr<Intro::Widget> _intro = { nullptr };
	object_ptr<MainWidget> _main = { nullptr };
	base::unique_qptr<Ui::LayerStackWidget> _layer;
	object_ptr<Window::MediaPreviewWidget> _mediaPreview = { nullptr };

	object_ptr<Window::Theme::WarningWidget> _testingThemeWarning = { nullptr };

	rpl::event_stream<> _updateTrayMenuTextActions;

};",1,334 2000 58 439 2001 646 2000 123 439 58 376 2000 40 2002 60 2003 646 2004 42 62 2005 41 59 126 2000 40 41 59 492 2006 40 41 59 492 2007 40 2008 60 492 40 41 62 2009 41 59 492 2010 40 41 59 492 2011 40 41 59 492 2012 40 2013 646 2014 2015 41 59 492 2016 40 41 59 492 2017 40 41 59 492 2018 40 41 431 59 2019 42 2020 40 41 341 59 91 91 2021 93 93 323 2022 40 41 59 323 2023 40 41 59 492 2024 40 41 59 492 2025 40 41 59 323 2026 40 341 2027 38 2028 41 59 323 2026 40 2029 42 2030 44 2031 42 2032 41 123 450 2026 40 2027 40 2030 624 2033 40 2032 624 2034 40 41 46 2035 40 41 41 44 2032 624 2034 40 41 46 2036 40 41 41 41 59 125 323 2026 40 2029 42 2030 44 341 2037 38 2038 41 123 450 2026 40 2027 40 2030 624 2039 40 2038 46 2040 40 41 46 2041 40 41 41 44 2038 46 2040 40 41 46 2042 40 41 41 41 59 125 492 2043 40 41 59 492 2044 40 41 431 59 492 2045 40 41 431 59 492 2046 40 2047 646 2048 60 2049 646 2050 62 605 2051 44 2049 646 2052 2053 44 2054 646 2055 2056 41 59 492 2057 40 2058 60 2049 646 2050 62 2051 44 2054 646 2055 2056 41 59 323 2059 40 2002 60 2003 646 2060 42 62 2061 44 341 2003 646 2062 38 433 41 59 492 2063 40 2058 60 2049 646 2064 62 2065 44 2049 646 2052 2053 44 2054 646 2055 2056 41 59 492 2066 40 2054 646 2055 2056 41 59 492 2067 40 41 59 323 2068 40 41 59 323 2069 40 2070 646 2071 2072 44 2002 60 2073 42 62 2074 41 59 323 2069 40 2070 646 2071 2072 44 2002 60 2075 42 62 2076 41 59 492 2077 40 41 59 492 2078 40 41 431 59 438 58 323 2079 40 2080 42 2081 44 2082 42 2032 41 431 59 492 2083 40 2084 42 2032 41 431 59 492 2085 40 41 431 59 492 2086 40 41 431 59 492 2087 40 41 431 59 437 58 91 91 2021 93 93 323 2088 40 41 341 59 492 2089 40 41 59 492 2090 40 2091 646 2092 2093 41 431 59 492 2094 40 41 59 492 2095 40 41 59 492 2096 40 41 59 492 2097 40 2047 646 2098 60 2099 646 2100 44 2058 60 2049 646 2064 62 44 2047 646 2048 60 2049 646 2050 640 605 2051 44 2049 646 2052 2053 44 2054 646 2055 2056 41 59 492 2101 40 341 2003 646 2102 646 2103 38 2104 41 59 492 2105 40 41 59 2106 2107 40 41 59 2047 646 2048 60 2108 646 2109 62 2110 59 2111 646 2112 2113 61 1500 59 2114 2115 59 323 2116 61 473 59 2058 60 2003 646 2117 62 2118 61 123 425 125 59 2058 60 2013 646 2119 62 2120 61 123 425 125 59 2058 60 2019 62 2121 61 123 425 125 59 320 646 2122 60 2049 646 2123 62 2124 59 2058 60 2003 646 2125 62 2126 61 123 425 125 59 2058 60 2003 646 2102 646 2127 62 2128 61 123 425 125 59 2129 646 2130 60 62 2131 59 125 59 
99575,C++,"class TABSeamless final : public IMapInfoFile
{
    CPL_DISALLOW_COPY_ASSIGN(TABSeamless)

  private:
    char        *m_pszFname;
    char        *m_pszPath;
    TABAccess   m_eAccessMode;
    OGRFeatureDefn *m_poFeatureDefnRef;

    TABFile     *m_poIndexTable;
    int         m_nTableNameField;
    int         m_nCurBaseTableId;
    TABFile     *m_poCurBaseTable;
    GBool       m_bEOF;

    ///////////////
    // Private Read access specific stuff
    //
    int         OpenForRead(const char *pszFname,
                            GBool bTestOpenNoError = FALSE );
    int         OpenBaseTable(TABFeature *poIndexFeature,
                              GBool bTestOpenNoError = FALSE);
    int         OpenBaseTable(int nTableId, GBool bTestOpenNoError = FALSE);
    int         OpenNextBaseTable(GBool bTestOpenNoError =FALSE);
    static GIntBig     EncodeFeatureId(int nTableId, int nBaseFeatureId);
    static int         ExtractBaseTableId(GIntBig nEncodedFeatureId);
    static int         ExtractBaseFeatureId(GIntBig nEncodedFeatureId);

  public:
    TABSeamless();
    virtual ~TABSeamless();

    virtual TABFileClass GetFileClass() override {return TABFC_TABSeamless;}

    virtual int Open(const char *pszFname, const char* pszAccess,
                     GBool bTestOpenNoError = FALSE,
                     const char* pszCharset = nullptr ) override { return IMapInfoFile::Open(pszFname, pszAccess, bTestOpenNoError, pszCharset); }
    virtual int Open(const char *pszFname, TABAccess eAccess,
                     GBool bTestOpenNoError = FALSE,
                     const char* pszCharset = nullptr ) override;
    virtual int Close() override;

    virtual const char *GetTableName() override
           {return m_poFeatureDefnRef?m_poFeatureDefnRef->GetName():"""";}

    virtual void        SetSpatialFilter( OGRGeometry * ) override;
    virtual void        SetSpatialFilter( int iGeomField, OGRGeometry *poGeom ) override
                { OGRLayer::SetSpatialFilter(iGeomField, poGeom); }

    virtual void        ResetReading() override;
    virtual int         TestCapability( const char * pszCap ) override;
    virtual GIntBig     GetFeatureCount (int bForce) override;
    virtual OGRErr      GetExtent(OGREnvelope *psExtent, int bForce) override;
    virtual OGRErr      GetExtent(int iGeomField, OGREnvelope *psExtent, int bForce) override
                { return OGRLayer::GetExtent(iGeomField, psExtent, bForce); }

    ///////////////
    // Read access specific stuff
    //

    virtual GIntBig GetNextFeatureId(GIntBig nPrevId) override;
    virtual TABFeature *GetFeatureRef(GIntBig nFeatureId) override;
    virtual OGRFeatureDefn *GetLayerDefn() override;

    virtual TABFieldType GetNativeFieldType(int nFieldId) override;

    virtual int GetBounds(double &dXMin, double &dYMin,
                          double &dXMax, double &dYMax,
                          GBool bForce = TRUE ) override;

    virtual OGRSpatialReference *GetSpatialRef() override;

    virtual int GetFeatureCountByType(int &numPoints, int &numLines,
                                      int &numRegions, int &numTexts,
                                      GBool bForce = TRUE) override;

    virtual GBool IsFieldIndexed(int nFieldId) override;
    virtual GBool IsFieldUnique(int nFieldId) override;

    ///////////////
    // Write access specific stuff
    //
    virtual int SetBounds(CPL_UNUSED double dXMin, CPL_UNUSED double dYMin,
                          CPL_UNUSED double dXMax, CPL_UNUSED double dYMax) override   {return -1;}
    virtual int SetFeatureDefn(CPL_UNUSED OGRFeatureDefn *poFeatureDefn,
                               CPL_UNUSED TABFieldType *paeMapInfoNativeFieldTypes=nullptr) override
                                                        {return -1;}
    virtual int AddFieldNative(CPL_UNUSED const char *pszName,
                               CPL_UNUSED TABFieldType eMapInfoType,
                               CPL_UNUSED int nWidth=0,
                               CPL_UNUSED int nPrecision=0,
                               CPL_UNUSED GBool bIndexed=FALSE,
                               CPL_UNUSED GBool bUnique=FALSE,
                               CPL_UNUSED int bApproxOK = TRUE) override {return -1;}

    virtual int SetSpatialRef(CPL_UNUSED OGRSpatialReference *poSpatialRef) override {return -1;}

    virtual OGRErr CreateFeature(CPL_UNUSED TABFeature *poFeature) override
                                        {return OGRERR_UNSUPPORTED_OPERATION;}

    virtual int SetFieldIndexed(CPL_UNUSED int nFieldId) override {return -1;}

    ///////////////
    // semi-private.
    virtual int  GetProjInfo(TABProjInfo *poPI) override
            { return m_poIndexTable?m_poIndexTable->GetProjInfo(poPI):-1; }
    virtual int SetProjInfo(CPL_UNUSED TABProjInfo *poPI) override         { return -1; }
    virtual int SetMIFCoordSys(const char * /*pszMIFCoordSys*/) override {return -1;}

#ifdef DEBUG
    virtual void Dump(FILE *fpOut = nullptr) override;
#endif
};",1,334 2000 381 58 439 2001 123 2002 40 2000 41 437 58 330 42 2003 59 330 42 2004 59 2005 2006 59 2007 42 2008 59 2009 42 2010 59 404 2011 59 404 2012 59 2009 42 2013 59 2014 2015 59 621 621 621 404 2016 40 341 330 42 2017 44 2014 2018 61 2019 41 59 404 2020 40 2021 42 2022 44 2014 2018 61 2019 41 59 404 2020 40 404 2023 44 2014 2018 61 2019 41 59 404 2024 40 2014 2018 61 2019 41 59 457 2025 2026 40 404 2023 44 404 2027 41 59 457 404 2028 40 2025 2029 41 59 457 404 2030 40 2025 2029 41 59 439 58 2000 40 41 59 491 126 2000 40 41 59 491 2031 2032 40 41 431 123 450 2033 59 125 491 404 2034 40 341 330 42 2017 44 341 330 42 2035 44 2014 2018 61 2019 44 341 330 42 2036 61 425 41 431 123 450 2001 646 2034 40 2017 44 2035 44 2018 44 2036 41 59 125 491 404 2034 40 341 330 42 2017 44 2005 2037 44 2014 2018 61 2019 44 341 330 42 2036 61 425 41 431 59 491 404 2038 40 41 431 59 491 341 330 42 2039 40 41 431 123 450 2008 63 2008 624 2040 40 41 58 648 59 125 491 492 2041 40 2042 42 41 431 59 491 492 2041 40 404 2043 44 2042 42 2044 41 431 123 2045 646 2041 40 2043 44 2044 41 59 125 491 492 2046 40 41 431 59 491 404 2047 40 341 330 42 2048 41 431 59 491 2025 2049 40 404 2050 41 431 59 491 2051 2052 40 2053 42 2054 44 404 2050 41 431 59 491 2051 2052 40 404 2043 44 2053 42 2054 44 404 2050 41 431 123 450 2055 646 2052 40 2043 44 2054 44 2050 41 59 125 621 621 621 491 2025 2056 40 2025 2057 41 431 59 491 2021 42 2058 40 2025 2059 41 431 59 491 2007 42 2060 40 41 431 59 491 2061 2062 40 404 2063 41 431 59 491 404 2064 40 356 38 2065 44 356 38 2066 44 356 38 2067 44 356 38 2068 44 2014 2050 61 2069 41 431 59 491 2070 42 2071 40 41 431 59 491 404 2072 40 404 38 2073 44 404 38 2074 44 404 38 2075 44 404 38 2076 44 2014 2050 61 2069 41 431 59 491 2014 2077 40 404 2063 41 431 59 491 2014 2078 40 404 2063 41 431 59 621 621 621 491 404 2079 40 2080 356 2065 44 2080 356 2066 44 2080 356 2067 44 2080 356 2068 41 431 123 450 45 1501 59 125 491 404 2081 40 2080 2007 42 2082 44 2080 2061 42 2083 61 425 41 431 123 450 45 1501 59 125 491 404 2084 40 2080 341 330 42 2085 44 2080 2061 2086 44 2080 404 2087 61 1500 44 2080 404 2088 61 1500 44 2080 2014 2089 61 2019 44 2080 2014 2090 61 2019 44 2080 404 2091 61 2069 41 431 123 450 45 1501 59 125 491 404 2092 40 2080 2070 42 2093 41 431 123 450 45 1501 59 125 491 2051 2094 40 2080 2021 42 2095 41 431 123 450 2096 59 125 491 404 2097 40 2080 404 2063 41 431 123 450 45 1501 59 125 621 621 491 404 2098 40 2099 42 2100 41 431 123 450 2010 63 2010 624 2098 40 2100 41 58 45 1501 59 125 491 404 2101 40 2080 2099 42 2100 41 431 123 450 45 1501 59 125 491 404 2102 40 341 330 42 604 41 431 123 450 45 1501 59 125 35 393 2103 491 492 2104 40 2105 42 2106 61 425 41 431 59 35 366 125 59 
98753,C++,"class ISCEDataset final: public RawDataset
{
    friend class ISCERasterBand;

    VSILFILE    *fpImage;

    char        *pszXMLFilename;

    enum Scheme eScheme;

    CPL_DISALLOW_COPY_ASSIGN(ISCEDataset)

  public:
    ISCEDataset();
    ~ISCEDataset() override;

    void FlushCache(bool bAtClosing) override;
    char **GetFileList() override;

    static int          Identify( GDALOpenInfo *poOpenInfo );
    static GDALDataset *Open( GDALOpenInfo *poOpenInfo );
    static GDALDataset *Open( GDALOpenInfo *poOpenInfo, bool bFileSizeCheck );
    static GDALDataset *Create( const char *pszFilename,
                                int nXSize, int nYSize, int nBands,
                                GDALDataType eType, char **papszOptions );
};",1,334 2000 381 58 439 2001 123 387 334 2002 59 2003 42 2004 59 330 42 2005 59 370 2006 2007 59 2008 40 2000 41 439 58 2000 40 41 59 126 2000 40 41 431 59 492 2009 40 323 2010 41 431 59 330 42 42 2011 40 41 431 59 457 404 2012 40 2013 42 2014 41 59 457 2015 42 2016 40 2013 42 2014 41 59 457 2015 42 2016 40 2013 42 2014 44 323 2017 41 59 457 2015 42 2018 40 341 330 42 2019 44 404 2020 44 404 2021 44 404 2022 44 2023 2024 44 330 42 42 2025 41 59 125 59 
99492,C++,"class EHdrDataset final: public RawDataset
{
    friend class EHdrRasterBand;

    VSILFILE   *fpImage;  // image data file.

    CPLString   osHeaderExt{};

    bool        bGotTransform{};
    double      adfGeoTransform[6]{0,1,0,0,0,1};
    char       *pszProjection{};

    bool        bHDRDirty{};
    char      **papszHDR{};

    bool        bCLRDirty{};
    std::shared_ptr<GDALColorTable> m_poColorTable{};
    std::shared_ptr<GDALRasterAttributeTable> m_poRAT{};


    CPLErr      ReadSTX() const;
    CPLErr      RewriteSTX() const;
    CPLErr      RewriteHDR();
    void        ResetKeyValue( const char *pszKey, const char *pszValue );
    const char *GetKeyValue( const char *pszKey, const char *pszDefault = """" );
    void        RewriteCLR(GDALRasterBand*) const;

    CPL_DISALLOW_COPY_ASSIGN(EHdrDataset)

  public:
    EHdrDataset();
    ~EHdrDataset() override;

    CPLErr GetGeoTransform( double *padfTransform ) override;
    CPLErr SetGeoTransform( double *padfTransform ) override;
    const char *_GetProjectionRef() override;
    CPLErr _SetProjection( const char * ) override;
    const OGRSpatialReference* GetSpatialRef() const override {
        return GetSpatialRefFromOldGetProjectionRef();
    }
    CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override {
        return OldSetProjectionFromSetSpatialRef(poSRS);
    }

    char **GetFileList() override;

    static GDALDataset *Open( GDALOpenInfo * );
    static GDALDataset *Open( GDALOpenInfo *, bool bFileSizeCheck );
    static GDALDataset *Create( const char *pszFilename,
                                int nXSize, int nYSize, int nBands,
                                GDALDataType eType, char **papszParamList );
    static GDALDataset *CreateCopy( const char *pszFilename,
                                    GDALDataset *poSrcDS,
                                    int bStrict, char **papszOptions,
                                    GDALProgressFunc pfnProgress,
                                    void *pProgressData );
    static CPLString GetImageRepFilename(const char *pszFilename);
};",1,334 2000 381 58 439 2001 123 387 334 2002 59 2003 42 2004 59 621 2005 2006 123 125 59 323 2007 123 125 59 356 2008 91 1502 93 123 1500 44 1501 44 1500 44 1500 44 1500 44 1501 125 59 330 42 2009 123 125 59 323 2010 123 125 59 330 42 42 2011 123 125 59 323 2012 123 125 59 2013 646 2014 60 2015 62 2016 123 125 59 2013 646 2014 60 2017 62 2018 123 125 59 2019 2020 40 41 341 59 2019 2021 40 41 341 59 2019 2022 40 41 59 492 2023 40 341 330 42 2024 44 341 330 42 2025 41 59 341 330 42 2026 40 341 330 42 2024 44 341 330 42 2027 61 648 41 59 492 2028 40 2029 42 41 341 59 2030 40 2000 41 439 58 2000 40 41 59 126 2000 40 41 431 59 2019 2031 40 356 42 2032 41 431 59 2019 2033 40 356 42 2032 41 431 59 341 330 42 2034 40 41 431 59 2019 2035 40 341 330 42 41 431 59 341 2036 42 2037 40 41 341 431 123 450 2038 40 41 59 125 2019 2039 40 341 2036 42 2040 41 431 123 450 2041 40 2040 41 59 125 330 42 42 2042 40 41 431 59 457 2043 42 2044 40 2045 42 41 59 457 2043 42 2044 40 2045 42 44 323 2046 41 59 457 2043 42 2047 40 341 330 42 2048 44 404 2049 44 404 2050 44 404 2051 44 2052 2053 44 330 42 42 2054 41 59 457 2043 42 2055 40 341 330 42 2048 44 2043 42 2056 44 404 2057 44 330 42 42 2058 44 2059 2060 44 492 42 2061 41 59 457 2005 2062 40 341 330 42 2048 41 59 125 59 
98665,C++,"class CPL_DLL VRTWarpedDataset final: public VRTDataset
{
    int               m_nBlockXSize;
    int               m_nBlockYSize;
    GDALWarpOperation *m_poWarper;

    int               m_nOverviewCount;
    VRTWarpedDataset **m_papoOverviews;
    int               m_nSrcOvrLevel;

    void              CreateImplicitOverviews();

    friend class VRTWarpedRasterBand;

    CPL_DISALLOW_COPY_ASSIGN(VRTWarpedDataset)

  protected:
    virtual int         CloseDependentDatasets() override;

public:
                      VRTWarpedDataset( int nXSize, int nYSize );
    virtual ~VRTWarpedDataset();

    virtual void  FlushCache(bool bAtClosing) override;

    CPLErr            Initialize( /* GDALWarpOptions */ void * );

    virtual CPLErr IBuildOverviews( const char *, int, int *,
                                    int, int *, GDALProgressFunc, void * ) override;

    virtual CPLErr SetMetadataItem( const char *pszName, const char *pszValue,
                                    const char *pszDomain = """" ) override;

    virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath ) override;
    virtual CPLErr    XMLInit( CPLXMLNode *, const char * ) override;

    virtual CPLErr AddBand( GDALDataType eType,
                            char **papszOptions=nullptr ) override;

    virtual char      **GetFileList() override;

    CPLErr            ProcessBlock( int iBlockX, int iBlockY );

    void              GetBlockSize( int *, int * ) const;
};",1,334 2000 2001 381 58 439 2002 123 404 2003 59 404 2004 59 2005 42 2006 59 404 2007 59 2001 42 42 2008 59 404 2009 59 492 2010 40 41 59 387 334 2011 59 2012 40 2001 41 438 58 491 404 2013 40 41 431 59 439 58 2001 40 404 2014 44 404 2015 41 59 491 126 2001 40 41 59 491 492 2016 40 323 2017 41 431 59 2018 2019 40 604 492 42 41 59 491 2018 2020 40 341 330 42 44 404 44 404 42 44 404 44 404 42 44 2021 44 492 42 41 431 59 491 2018 2022 40 341 330 42 2023 44 341 330 42 2024 44 341 330 42 2025 61 648 41 431 59 491 2026 42 2027 40 341 330 42 2028 41 431 59 491 2018 2029 40 2026 42 44 341 330 42 41 431 59 491 2018 2030 40 2031 2032 44 330 42 42 2033 61 425 41 431 59 491 330 42 42 2034 40 41 431 59 2018 2035 40 404 2036 44 404 2037 41 59 492 2038 40 404 42 44 404 42 41 341 59 125 59 
98965,C++,"template<class DataType, class EqualityTest> class GDALRasterPolygonEnumeratorT

{
private:
    void     MergePolygon( int nSrcId, int nDstId );
    int      NewPolygon( DataType nValue );

    CPL_DISALLOW_COPY_ASSIGN(GDALRasterPolygonEnumeratorT)

public:  // these are intended to be readonly.

    GInt32   *panPolyIdMap = nullptr;
    DataType   *panPolyValue = nullptr;

    int      nNextPolygonId = 0;
    int      nPolyAlloc = 0;

    int      nConnectedness = 0;

public:
    explicit GDALRasterPolygonEnumeratorT( int nConnectedness=4 );
            ~GDALRasterPolygonEnumeratorT();

    void     ProcessLine( DataType *panLastLineVal, DataType *panThisLineVal,
                          GInt32 *panLastLineId,  GInt32 *panThisLineId,
                          int nXSize );

    void     CompleteMerges();

    void     Clear();
};",1,466 60 334 2000 44 334 2001 62 334 2002 123 437 58 492 2003 40 404 2004 44 404 2005 41 59 404 2006 40 2000 2007 41 59 2008 40 2002 41 439 58 621 2009 42 2010 61 425 59 2000 42 2011 61 425 59 404 2012 61 1500 59 404 2013 61 1500 59 404 2014 61 1500 59 439 58 376 2002 40 404 2014 61 1502 41 59 126 2002 40 41 59 492 2015 40 2000 42 2016 44 2000 42 2017 44 2009 42 2018 44 2009 42 2019 44 404 2020 41 59 492 2021 40 41 59 492 2022 40 41 59 125 59 
99842,C++,"class OGRDXFLayer final: public OGRLayer
{
    friend class OGRDXFBlocksLayer;

    OGRDXFDataSource   *poDS;

    OGRFeatureDefn     *poFeatureDefn;
    GIntBig             iNextFID;

    std::set<CPLString> oIgnoredEntities;

    OGRDXFFeatureQueue  apoPendingFeatures;

    struct InsertState
    {
        OGRDXFInsertTransformer m_oTransformer{};
        CPLString               m_osBlockName{};
        CPLStringList           m_aosAttribs{};
        int                     m_nColumnCount = 0;
        int                     m_nRowCount = 0;
        int                     m_iCurCol = 0;
        int                     m_iCurRow = 0;
        double                  m_dfColumnSpacing = 0.0;
        double                  m_dfRowSpacing = 0.0;
        std::vector<std::unique_ptr<OGRDXFFeature>> m_apoAttribs{};
        std::unique_ptr<OGRDXFFeature> m_poTemplateFeature{};
    };
    InsertState         m_oInsertState{};

    void                ClearPendingFeatures();

    void                TranslateGenericProperty( OGRDXFFeature *poFeature,
                                                  int nCode, char *pszValue );

    void                PrepareFeatureStyle( OGRDXFFeature* const poFeature,
                            OGRDXFFeature* const poBlockFeature = nullptr );
    void                PrepareBrushStyle( OGRDXFFeature* const poFeature,
                            OGRDXFFeature* const poBlockFeature = nullptr );
    void                PrepareLineStyle( OGRDXFFeature* const poFeature,
                            OGRDXFFeature* const poBlockFeature = nullptr );

    OGRDXFFeature *     TranslatePOINT();
    OGRDXFFeature *     TranslateLINE();
    OGRDXFFeature *     TranslatePOLYLINE();
    OGRDXFFeature *     TranslateLWPOLYLINE();
    OGRDXFFeature *     TranslateMLINE();
    OGRDXFFeature *     TranslateCIRCLE();
    OGRDXFFeature *     TranslateELLIPSE();
    OGRDXFFeature *     TranslateARC();
    OGRDXFFeature *     TranslateSPLINE();
    OGRDXFFeature *     Translate3DFACE();
    bool                TranslateINSERT();
    OGRDXFFeature *     TranslateMTEXT();
    OGRDXFFeature *     TranslateTEXT( const bool bIsAttribOrAttdef );
    OGRDXFFeature *     TranslateDIMENSION();
    OGRDXFFeature *     TranslateHATCH();
    OGRDXFFeature *     TranslateSOLID();
    OGRDXFFeature *     TranslateLEADER();
    OGRDXFFeature *     TranslateMLEADER();
    OGRDXFFeature *     TranslateASMEntity();

    bool                GenerateINSERTFeatures();
    std::unique_ptr<OGRLineString> InsertSplineWithChecks( const int nDegree,
                                                std::vector<double>& adfControlPoints,
                                                int nControlPoints,
                                                std::vector<double>& adfKnots,
                                                int nKnots,
                                                std::vector<double>& adfWeights );
    static OGRGeometry *SimplifyBlockGeometry( OGRGeometryCollection * );
    OGRDXFFeature *     InsertBlockInline( GUInt32 nInitialErrorCounter,
                                           const CPLString& osBlockName,
                                           OGRDXFInsertTransformer oTransformer,
                                           OGRDXFFeature* const poFeature,
                                           OGRDXFFeatureQueue& apoExtraFeatures,
                                           const bool bInlineNestedBlocks,
                                           const bool bMergeGeometry );
    OGRDXFFeature *     InsertBlockReference( const CPLString& osBlockName,
                                              const OGRDXFInsertTransformer& oTransformer,
                                              OGRDXFFeature* const poFeature );
    static void         FormatDimension( CPLString &osText, const double dfValue,
                                         int nPrecision );
    void                InsertArrowhead( OGRDXFFeature* const poFeature,
                                         const CPLString& osBlockName,
                                         OGRLineString* const poLine,
                                         const double dfArrowheadSize,
                                         const bool bReverse = false );
    OGRErr              CollectBoundaryPath( OGRGeometryCollection *poGC,
                                             const double dfElevation );
    OGRErr              CollectPolylinePath( OGRGeometryCollection *poGC,
                                             const double dfElevation );

    CPLString           TextRecode( const char * );
    CPLString           TextUnescape( const char *, bool );

  public:
    explicit OGRDXFLayer( OGRDXFDataSource *poDS );
    ~OGRDXFLayer();

    void                ResetReading() override;
    OGRFeature *        GetNextFeature() override;

    OGRFeatureDefn *    GetLayerDefn() override { return poFeatureDefn; }

    int                 TestCapability( const char * ) override;

    OGRDXFFeature *     GetNextUnfilteredFeature();
};",1,334 2000 381 58 439 2001 123 387 334 2002 59 2003 42 2004 59 2005 42 2006 59 2007 2008 59 2009 646 2010 60 2011 62 2012 59 2013 2014 59 462 2015 123 2016 2017 123 125 59 2011 2018 123 125 59 2019 2020 123 125 59 404 2021 61 1500 59 404 2022 61 1500 59 404 2023 61 1500 59 404 2024 61 1500 59 356 2025 61 1500 59 356 2026 61 1500 59 2009 646 2027 60 2009 646 2028 60 2029 640 2030 123 125 59 2009 646 2028 60 2029 62 2031 123 125 59 125 59 2015 2032 123 125 59 492 2033 40 41 59 492 2034 40 2035 42 2036 44 404 2037 44 330 42 2038 41 59 492 2039 40 2035 42 341 2036 44 2035 42 341 2040 61 425 41 59 492 2041 40 2035 42 341 2036 44 2035 42 341 2040 61 425 41 59 492 2042 40 2035 42 341 2036 44 2035 42 341 2040 61 425 41 59 2035 42 2043 40 41 59 2035 42 2044 40 41 59 2035 42 2045 40 41 59 2035 42 2046 40 41 59 2035 42 2047 40 41 59 2035 42 2048 40 41 59 2035 42 2049 40 41 59 2035 42 2050 40 41 59 2035 42 2051 40 41 59 2035 42 2052 40 41 59 323 2053 40 41 59 2035 42 2054 40 41 59 2035 42 2055 40 341 323 2056 41 59 2035 42 2057 40 41 59 2035 42 2058 40 41 59 2035 42 2059 40 41 59 2035 42 2060 40 41 59 2035 42 2061 40 41 59 2035 42 2062 40 41 59 323 2063 40 41 59 2009 646 2064 60 2065 62 2066 40 341 404 2067 44 2009 646 2068 60 356 62 38 2069 44 404 2070 44 2009 646 2068 60 356 62 38 2071 44 404 2072 44 2009 646 2068 60 356 62 38 2073 41 59 457 2074 42 2075 40 2076 42 41 59 2035 42 2077 40 2078 2079 44 341 2011 38 2080 44 2081 2082 44 2035 42 341 2036 44 2013 38 2083 44 341 323 2084 44 341 323 2085 41 59 2035 42 2086 40 341 2011 38 2080 44 341 2081 38 2082 44 2035 42 341 2036 41 59 457 492 2087 40 2011 38 2088 44 341 356 2089 44 404 2090 41 59 492 2091 40 2035 42 341 2036 44 341 2011 38 2080 44 2065 42 341 2092 44 341 356 2093 44 341 323 2094 61 380 41 59 2095 2096 40 2076 42 2097 44 341 356 2098 41 59 2095 2099 40 2076 42 2097 44 341 356 2098 41 59 2011 2100 40 341 330 42 41 59 2011 2101 40 341 330 42 44 323 41 59 439 58 376 2000 40 2003 42 2004 41 59 126 2000 40 41 59 492 2102 40 41 431 59 2103 42 2104 40 41 431 59 2005 42 2105 40 41 431 123 450 2006 59 125 404 2106 40 341 330 42 41 431 59 2035 42 2107 40 41 59 125 59 
98836,C++,"class OGRDXFDataSource final: public OGRDataSource
{
    VSILFILE           *fp;

    CPLString           osName;
    std::vector<OGRLayer*> apoLayers;

    int                 iEntitiesOffset;
    int                 iEntitiesLineNumber;

    std::map<CPLString,DXFBlockDefinition> oBlockMap;
    std::map<CPLString,CPLString> oBlockRecordHandles;
    std::map<CPLString,CPLString> oHeaderVariables;

    CPLString           osEncoding;

    // indexed by layer name, then by property name.
    std::map< CPLString, std::map<CPLString,CPLString> >
                        oLayerTable;

    // indexed by style name, then by property name.
    std::map< CPLString, std::map<CPLString,CPLString> >
                        oTextStyleTable;
    std::map<CPLString,CPLString> oTextStyleHandles;

    // indexed by dimstyle name, then by DIM... variable name
    std::map< CPLString, std::map<CPLString,CPLString> >
                        oDimStyleTable;

    std::map<CPLString, std::vector<double> > oLineTypeTable;

    bool                bInlineBlocks;
    bool                bMergeBlockGeometries;
    bool                bTranslateEscapeSequences;
    bool                bIncludeRawCodeValues;

    bool                b3DExtensibleMode;
    bool                bHaveReadSolidData;
    std::map<CPLString, std::vector<GByte>> oSolidBinaryData;

    OGRDXFReader        oReader;

    std::vector<CPLString> aosBlockInsertionStack;

  public:
                        OGRDXFDataSource();
                        ~OGRDXFDataSource();

    int                 Open( const char * pszFilename, int bHeaderOnly=FALSE );

    const char          *GetName() override { return osName; }

    int                 GetLayerCount() override { return static_cast<int>(apoLayers.size()); }
    OGRLayer            *GetLayer( int ) override;

    int                 TestCapability( const char * ) override;

    // The following is only used by OGRDXFLayer

    bool                InlineBlocks() const { return bInlineBlocks; }
    bool                ShouldMergeBlockGeometries() const { return bMergeBlockGeometries; }
    bool                ShouldTranslateEscapes() const { return bTranslateEscapeSequences; }
    bool                ShouldIncludeRawCodeValues() const { return bIncludeRawCodeValues; }
    bool                In3DExtensibleMode() const { return b3DExtensibleMode; }
    static void         AddStandardFields( OGRFeatureDefn *poDef,
                                           const int nFieldModes );

    // Implemented in ogrdxf_blockmap.cpp
    bool                ReadBlocksSection();
    DXFBlockDefinition *LookupBlock( const char *pszName );
    CPLString           GetBlockNameByRecordHandle( const char *pszID );
    std::map<CPLString,DXFBlockDefinition> &GetBlockMap() { return oBlockMap; }

    bool                PushBlockInsertion( const CPLString& osBlockName );
    void                PopBlockInsertion() { aosBlockInsertionStack.pop_back(); }

    // Layer and other Table Handling (ogrdatasource.cpp)
    bool                ReadTablesSection();
    bool                ReadLayerDefinition();
    bool                ReadLineTypeDefinition();
    bool                ReadTextStyleDefinition();
    bool                ReadDimStyleDefinition();
    const char         *LookupLayerProperty( const char *pszLayer,
                                             const char *pszProperty );
    const char         *LookupTextStyleProperty( const char *pszTextStyle,
                                                 const char *pszProperty,
                                                 const char *pszDefault );
    bool                LookupDimStyle( const char *pszDimstyle,
                         std::map<CPLString, CPLString>& oDimStyleProperties );
    const std::map<CPLString, std::vector<double>>& GetLineTypeTable() const
    { return oLineTypeTable; }
    std::vector<double> LookupLineType( const char *pszName );
    bool                TextStyleExists( const char *pszTextStyle );
    CPLString           GetTextStyleNameByHandle( const char *pszID );
    static void         PopulateDefaultDimStyleProperties(
                         std::map<CPLString, CPLString>& oDimStyleProperties );
    size_t              GetEntryFromAcDsDataSection( const char* pszEntityHandle,
                                                     const GByte** pabyBuffer );

    // Header variables.
    bool                ReadHeaderSection();
    const char         *GetVariable(const char *pszName,
                                    const char *pszDefault=nullptr );

    const char         *GetEncoding() { return osEncoding; }

    // reader related.
    int  GetLineNumber() { return oReader.nLineNumber; }
    int  ReadValue( char *pszValueBuffer, int nValueBufferSize = 81 )
        { return oReader.ReadValue( pszValueBuffer, nValueBufferSize ); }
    void RestartEntities()
        { oReader.ResetReadPointer( iEntitiesOffset, iEntitiesLineNumber ); }
    void UnreadValue()
        { oReader.UnreadValue(); }
    void ResetReadPointer( int iNewOffset )
        { oReader.ResetReadPointer( iNewOffset ); }
};",1,334 2000 381 58 439 2001 123 2002 42 2003 59 2004 2005 59 2006 646 2007 60 2008 42 62 2009 59 404 2010 59 404 2011 59 2006 646 2012 60 2004 44 2013 62 2014 59 2006 646 2012 60 2004 44 2004 62 2015 59 2006 646 2012 60 2004 44 2004 62 2016 59 2004 2017 59 621 2006 646 2012 60 2004 44 2006 646 2012 60 2004 44 2004 62 62 2018 59 621 2006 646 2012 60 2004 44 2006 646 2012 60 2004 44 2004 62 62 2019 59 2006 646 2012 60 2004 44 2004 62 2020 59 621 2006 646 2012 60 2004 44 2006 646 2012 60 2004 44 2004 62 62 2021 59 2006 646 2012 60 2004 44 2006 646 2007 60 356 62 62 2022 59 323 2023 59 323 2024 59 323 2025 59 323 2026 59 323 2027 59 323 2028 59 2006 646 2012 60 2004 44 2006 646 2007 60 2029 640 2030 59 2031 2032 59 2006 646 2007 60 2004 62 2033 59 439 58 2000 40 41 59 126 2000 40 41 59 404 2034 40 341 330 42 2035 44 404 2036 61 2037 41 59 341 330 42 2038 40 41 431 123 450 2005 59 125 404 2039 40 41 431 123 450 459 60 404 62 40 2009 46 2040 40 41 41 59 125 2008 42 2041 40 404 41 431 59 404 2042 40 341 330 42 41 431 59 621 323 2043 40 41 341 123 450 2023 59 125 323 2044 40 41 341 123 450 2024 59 125 323 2045 40 41 341 123 450 2025 59 125 323 2046 40 41 341 123 450 2026 59 125 323 2047 40 41 341 123 450 2027 59 125 457 492 2048 40 2049 42 2050 44 341 404 2051 41 59 621 323 2052 40 41 59 2013 42 2053 40 341 330 42 2054 41 59 2004 2055 40 341 330 42 2056 41 59 2006 646 2012 60 2004 44 2013 62 38 2057 40 41 123 450 2014 59 125 323 2058 40 341 2004 38 2059 41 59 492 2060 40 41 123 2033 46 2061 40 41 59 125 621 323 2062 40 41 59 323 2063 40 41 59 323 2064 40 41 59 323 2065 40 41 59 323 2066 40 41 59 341 330 42 2067 40 341 330 42 2068 44 341 330 42 2069 41 59 341 330 42 2070 40 341 330 42 2071 44 341 330 42 2069 44 341 330 42 2072 41 59 323 2073 40 341 330 42 2074 44 2006 646 2012 60 2004 44 2004 62 38 2075 41 59 341 2006 646 2012 60 2004 44 2006 646 2007 60 356 640 38 2076 40 41 341 123 450 2022 59 125 2006 646 2007 60 356 62 2077 40 341 330 42 2054 41 59 323 2078 40 341 330 42 2071 41 59 2004 2079 40 341 330 42 2056 41 59 457 492 2080 40 2006 646 2012 60 2004 44 2004 62 38 2075 41 59 2081 2082 40 341 330 42 2083 44 341 2029 42 42 2084 41 59 621 323 2085 40 41 59 341 330 42 2086 40 341 330 42 2054 44 341 330 42 2072 61 425 41 59 341 330 42 2087 40 41 123 450 2017 59 125 621 404 2088 40 41 123 450 2032 46 2089 59 125 404 2090 40 330 42 2091 44 404 2092 61 1503 41 123 450 2032 46 2090 40 2091 44 2092 41 59 125 492 2093 40 41 123 2032 46 2094 40 2010 44 2011 41 59 125 492 2095 40 41 123 2032 46 2095 40 41 59 125 492 2096 40 404 2097 41 123 2032 46 2096 40 2097 41 59 125 125 59 
98837,C++,"class OGRDXFWriterDS final: public OGRDataSource
{
    friend class OGRDXFWriterLayer;

    int                 nNextFID;

    CPLString           osName;
    OGRDXFWriterLayer  *poLayer;
    OGRDXFBlocksWriterLayer *poBlocksLayer;
    VSILFILE           *fp;
    CPLString           osTrailerFile;

    CPLString           osTempFilename;
    VSILFILE           *fpTemp;

    CPLString           osHeaderFile;
    OGRDXFDataSource    oHeaderDS;
    char               **papszLayersToCreate;

    vsi_l_offset        nHANDSEEDOffset;

    std::vector<int>    anDefaultLayerCode;
    std::vector<CPLString> aosDefaultLayerText;

    std::set<CPLString> aosUsedEntities;
    void                ScanForEntities( const char *pszFilename,
                                         const char *pszTarget );

    bool                WriteNewLineTypeRecords( VSILFILE *fp );
    bool                WriteNewTextStyleRecords( VSILFILE *fp );
    bool                WriteNewBlockRecords( VSILFILE * );
    bool                WriteNewBlockDefinitions( VSILFILE * );
    bool                WriteNewLayerDefinitions( VSILFILE * );
    bool                TransferUpdateHeader( VSILFILE * );
    bool                TransferUpdateTrailer( VSILFILE * );
    bool                FixupHANDSEED( VSILFILE * );

    OGREnvelope         oGlobalEnvelope;

  public:
                        OGRDXFWriterDS();
                        ~OGRDXFWriterDS();

    int                 Open( const char * pszFilename,
                              char **papszOptions );

    const char          *GetName() override { return osName; }

    int                 GetLayerCount() override;
    OGRLayer            *GetLayer( int ) override;

    int                 TestCapability( const char * ) override;

    OGRLayer           *ICreateLayer( const char *pszName,
                                     OGRSpatialReference *poSpatialRef = nullptr,
                                     OGRwkbGeometryType eGType = wkbUnknown,
                                     char ** papszOptions = nullptr ) override;

    bool                CheckEntityID( const char *pszEntityID );
    long                WriteEntityID( VSILFILE * fp,
                                       long nPreferredFID = OGRNullFID );

    void                UpdateExtent( OGREnvelope* psEnvelope );
};",1,334 2000 381 58 439 2001 123 387 334 2002 59 404 2003 59 2004 2005 59 2002 42 2006 59 2007 42 2008 59 2009 42 2010 59 2004 2011 59 2004 2012 59 2009 42 2013 59 2004 2014 59 2015 2016 59 330 42 42 2017 59 2018 2019 59 2020 646 2021 60 404 62 2022 59 2020 646 2021 60 2004 62 2023 59 2020 646 2024 60 2004 62 2025 59 492 2026 40 341 330 42 2027 44 341 330 42 2028 41 59 323 2029 40 2009 42 2010 41 59 323 2030 40 2009 42 2010 41 59 323 2031 40 2009 42 41 59 323 2032 40 2009 42 41 59 323 2033 40 2009 42 41 59 323 2034 40 2009 42 41 59 323 2035 40 2009 42 41 59 323 2036 40 2009 42 41 59 2037 2038 59 439 58 2000 40 41 59 126 2000 40 41 59 404 2039 40 341 330 42 2027 44 330 42 42 2040 41 59 341 330 42 2041 40 41 431 123 450 2005 59 125 404 2042 40 41 431 59 2043 42 2044 40 404 41 431 59 404 2045 40 341 330 42 41 431 59 2043 42 2046 40 341 330 42 2047 44 2048 42 2049 61 425 44 2050 2051 61 2052 44 330 42 42 2040 61 425 41 431 59 323 2053 40 341 330 42 2054 41 59 413 2055 40 2009 42 2010 44 413 2056 61 2057 41 59 492 2058 40 2037 42 2059 41 59 125 59 
98826,C++,"class TABDATFile
{
    CPL_DISALLOW_COPY_ASSIGN(TABDATFile)

  private:
    char        *m_pszFname;
    VSILFILE    *m_fp;
    TABAccess   m_eAccessMode;
    TABTableType m_eTableType;

    TABRawBinBlock *m_poHeaderBlock;
    int         m_numFields;
    TABDATFieldDef *m_pasFieldDef;

    TABRawBinBlock *m_poRecordBlock;
    int         m_nBlockSize;
    int         m_nRecordSize;
    int         m_nCurRecordId;
    GBool       m_bCurRecordDeletedFlag;

    GInt32      m_numRecords;
    GInt32      m_nFirstRecordPtr;
    GBool       m_bWriteHeaderInitialized;
    GBool       m_bWriteEOF;

    int         m_bUpdated;
    CPLString   m_osEncoding;

    int         InitWriteHeader();
    int         WriteHeader();

    // We know that character strings are limited to 254 chars in MapInfo
    // Using a buffer pr. class instance to avoid threading issues with the library
    char        m_szBuffer[256];

   public:
    explicit TABDATFile( const char* pszEncoding );
    ~TABDATFile();

    int         Open(const char *pszFname, const char* pszAccess,
                     TABTableType eTableType =TABTableNative);
    int         Open(const char *pszFname, TABAccess eAccess,
                     TABTableType eTableType =TABTableNative);
    int         Close();

    int         GetNumFields();
    TABFieldType GetFieldType(int nFieldId);
    int         GetFieldWidth(int nFieldId);
    int         GetFieldPrecision(int nFieldId);
    int         ValidateFieldInfoFromTAB(int iField, const char *pszName,
                                         TABFieldType eType,
                                         int nWidth, int nPrecision);

    int         AddField(const char *pszName, TABFieldType eType,
                         int nWidth, int nPrecision=0);

    int         DeleteField( int iField );
    int         ReorderFields( int* panMap );
    int         AlterFieldDefn( int iField, OGRFieldDefn* poNewFieldDefn, int nFlags );

    int         SyncToDisk();

    GInt32      GetNumRecords();
    TABRawBinBlock *GetRecordBlock(int nRecordId);
    GBool       IsCurrentRecordDeleted() { return m_bCurRecordDeletedFlag;}
    int         CommitRecordToFile();

    int         MarkAsDeleted();
    int         MarkRecordAsExisting();

    const char  *ReadCharField(int nWidth);
    GInt32      ReadIntegerField(int nWidth);
    GInt16      ReadSmallIntField(int nWidth);
    double      ReadFloatField(int nWidth);
    double      ReadDecimalField(int nWidth);
    const char  *ReadLogicalField(int nWidth);
    const char  *ReadDateField(int nWidth);
    int         ReadDateField(int nWidth, int *nYear, int *nMonth, int *nDay);
    const char  *ReadTimeField(int nWidth);
    int         ReadTimeField(int nWidth, int *nHour, int *nMinute,
                              int *nSecond, int *nMS);
    const char  *ReadDateTimeField(int nWidth);
    int         ReadDateTimeField(int nWidth, int *nYear, int *nMonth, int *nDay,
                                 int *nHour, int *nMinute, int *nSecond, int *nMS);

    int         WriteCharField(const char *pszValue, int nWidth,
                               TABINDFile *poINDFile, int nIndexNo);
    int         WriteIntegerField(GInt32 nValue,
                                  TABINDFile *poINDFile, int nIndexNo);
    int         WriteSmallIntField(GInt16 nValue,
                                   TABINDFile *poINDFile, int nIndexNo);
    int         WriteFloatField(double dValue,
                                TABINDFile *poINDFile, int nIndexNo);
    int         WriteDecimalField(double dValue, int nWidth, int nPrecision,
                                  TABINDFile *poINDFile, int nIndexNo);
    int         WriteLogicalField(const char *pszValue,
                                  TABINDFile *poINDFile, int nIndexNo);
    int         WriteDateField(const char *pszValue,
                               TABINDFile *poINDFile, int nIndexNo);
    int         WriteDateField(int nYear, int nMonth, int nDay,
                               TABINDFile *poINDFile, int nIndexNo);
    int         WriteTimeField(const char *pszValue,
                               TABINDFile *poINDFile, int nIndexNo);
    int         WriteTimeField(int nHour, int nMinute, int nSecond, int nMS,
                               TABINDFile *poINDFile, int nIndexNo);
    int         WriteDateTimeField(const char *pszValue,
                               TABINDFile *poINDFile, int nIndexNo);
    int         WriteDateTimeField(int nYear, int nMonth, int nDay,
                                   int nHour, int nMinute, int nSecond, int nMS,
                                   TABINDFile *poINDFile, int nIndexNo);

    const CPLString& GetEncoding() const;
    void SetEncoding( const CPLString& );

#ifdef DEBUG
    void Dump(FILE *fpOut = nullptr);
#endif
};",1,334 2000 123 2001 40 2000 41 437 58 330 42 2002 59 2003 42 2004 59 2005 2006 59 2007 2008 59 2009 42 2010 59 404 2011 59 2012 42 2013 59 2009 42 2014 59 404 2015 59 404 2016 59 404 2017 59 2018 2019 59 2020 2021 59 2020 2022 59 2018 2023 59 2018 2024 59 404 2025 59 2026 2027 59 404 2028 40 41 59 404 2029 40 41 59 621 621 330 2030 91 1504 93 59 439 58 376 2000 40 341 330 42 2031 41 59 126 2000 40 41 59 404 2032 40 341 330 42 2033 44 341 330 42 2034 44 2007 2035 61 2036 41 59 404 2032 40 341 330 42 2033 44 2005 2037 44 2007 2035 61 2036 41 59 404 2038 40 41 59 404 2039 40 41 59 2040 2041 40 404 2042 41 59 404 2043 40 404 2042 41 59 404 2044 40 404 2042 41 59 404 2045 40 404 2046 44 341 330 42 2047 44 2040 2048 44 404 2049 44 404 2050 41 59 404 2051 40 341 330 42 2047 44 2040 2048 44 404 2049 44 404 2050 61 1500 41 59 404 2052 40 404 2046 41 59 404 2053 40 404 42 2054 41 59 404 2055 40 404 2046 44 2056 42 2057 44 404 2058 41 59 404 2059 40 41 59 2020 2060 40 41 59 2009 42 2061 40 404 2062 41 59 2018 2063 40 41 123 450 2019 59 125 404 2064 40 41 59 404 2065 40 41 59 404 2066 40 41 59 341 330 42 2067 40 404 2049 41 59 2020 2068 40 404 2049 41 59 2069 2070 40 404 2049 41 59 356 2071 40 404 2049 41 59 356 2072 40 404 2049 41 59 341 330 42 2073 40 404 2049 41 59 341 330 42 2074 40 404 2049 41 59 404 2074 40 404 2049 44 404 42 2075 44 404 42 2076 44 404 42 2077 41 59 341 330 42 2078 40 404 2049 41 59 404 2078 40 404 2049 44 404 42 2079 44 404 42 2080 44 404 42 2081 44 404 42 2082 41 59 341 330 42 2083 40 404 2049 41 59 404 2083 40 404 2049 44 404 42 2075 44 404 42 2076 44 404 42 2077 44 404 42 2079 44 404 42 2080 44 404 42 2081 44 404 42 2082 41 59 404 2084 40 341 330 42 2085 44 404 2049 44 2086 42 2087 44 404 2088 41 59 404 2089 40 2020 2090 44 2086 42 2087 44 404 2088 41 59 404 2091 40 2069 2090 44 2086 42 2087 44 404 2088 41 59 404 2092 40 356 2093 44 2086 42 2087 44 404 2088 41 59 404 2094 40 356 2093 44 404 2049 44 404 2050 44 2086 42 2087 44 404 2088 41 59 404 2095 40 341 330 42 2085 44 2086 42 2087 44 404 2088 41 59 404 2096 40 341 330 42 2085 44 2086 42 2087 44 404 2088 41 59 404 2096 40 404 2075 44 404 2076 44 404 2077 44 2086 42 2087 44 404 2088 41 59 404 2097 40 341 330 42 2085 44 2086 42 2087 44 404 2088 41 59 404 2097 40 404 2079 44 404 2080 44 404 2081 44 404 2082 44 2086 42 2087 44 404 2088 41 59 404 2098 40 341 330 42 2085 44 2086 42 2087 44 404 2088 41 59 404 2098 40 404 2075 44 404 2076 44 404 2077 44 404 2079 44 404 2080 44 404 2081 44 404 2082 44 2086 42 2087 44 404 2088 41 59 341 2026 38 2099 40 41 341 59 492 2100 40 341 2026 38 41 59 35 393 2101 492 2102 40 2103 42 2104 61 425 41 59 35 366 125 59 
98913,C++,"class OGRCSVDataSource final: public OGRDataSource
{
    char                *pszName;

    OGRLayer          **papoLayers;
    int                 nLayers;

    bool                bUpdate;

    CPLString           osDefaultCSVName;

    bool                bEnableGeometryFields;

  public:
                        OGRCSVDataSource();
                        virtual ~OGRCSVDataSource() GDAL_OVERRIDE;

    int                 Open( const char *pszFilename,
                              int bUpdate, int bForceAccept,
                              char **papszOpenOptions = nullptr );
    bool                OpenTable(
                            const char *pszFilename,
                            char **papszOpenOptions,
                            const char *pszNfdcRunwaysGeomField = nullptr,
                            const char *pszGeonamesGeomFieldPrefix = nullptr );

    const char          *GetName() override { return pszName; }

    int                 GetLayerCount() override { return nLayers; }
    OGRLayer            *GetLayer( int ) override;

    virtual OGRLayer   *ICreateLayer( const char *pszName,
                                     OGRSpatialReference *poSpatialRef = nullptr,
                                     OGRwkbGeometryType eGType = wkbUnknown,
                                     char ** papszOptions = nullptr ) override;

    virtual OGRErr      DeleteLayer(int) override;

    int                 TestCapability( const char * ) override;

    void                CreateForSingleFile( const char *pszDirname,
                                             const char *pszFilename );

    void                EnableGeometryFields() { bEnableGeometryFields = true; }

    static CPLString    GetRealExtension(CPLString osFilename);
};",1,334 2000 381 58 439 2001 123 330 42 2002 59 2003 42 42 2004 59 404 2005 59 323 2006 59 2007 2008 59 323 2009 59 439 58 2000 40 41 59 491 126 2000 40 41 2010 59 404 2011 40 341 330 42 2012 44 404 2006 44 404 2013 44 330 42 42 2014 61 425 41 59 323 2015 40 341 330 42 2012 44 330 42 42 2014 44 341 330 42 2016 61 425 44 341 330 42 2017 61 425 41 59 341 330 42 2018 40 41 431 123 450 2002 59 125 404 2019 40 41 431 123 450 2005 59 125 2003 42 2020 40 404 41 431 59 491 2003 42 2021 40 341 330 42 2002 44 2022 42 2023 61 425 44 2024 2025 61 2026 44 330 42 42 2027 61 425 41 431 59 491 2028 2029 40 404 41 431 59 404 2030 40 341 330 42 41 431 59 492 2031 40 341 330 42 2032 44 341 330 42 2012 41 59 492 2033 40 41 123 2009 61 473 59 125 457 2007 2034 40 2007 2035 41 59 125 59 
116896,C++,"class Distributed {
 public:
  /// Default constructor
  Distributed() {}

  /// Retrieve queued queries from a remote server
  Status pullUpdates();

  /// Get the number of queries which are waiting to be executed
  size_t getPendingQueryCount();

  /// Get the number of results which are waiting to be flushed
  size_t getCompletedCount();

  /// Serialize result data into a JSON string and clear the results
  Status serializeResults(std::string& json);

  /// Process and execute queued queries
  Status runQueries();

  // Getter for ID of currently executing request
  static std::string getCurrentRequestId();

 protected:
  /**
   * @brief Process several queries from a distributed plugin
   *
   * Given a response from a distributed plugin, parse the results and enqueue
   * them in the internal state of the class
   *
   * @param work is the string from DistributedPlugin::getQueries
   * @return a Status indicating the success or failure of the operation
   */
  Status acceptWork(const std::string& work);

  /**
   * @brief Pop a request object off of the queries_ member
   *
   * @return a DistributedQueryRequest object which needs to be executed
   */
  DistributedQueryRequest popRequest();

  /**
   * @brief Queue a result to be batch sent to the server
   *
   * @param result is a DistributedQueryResult object to be sent to the server
   */
  void addResult(const DistributedQueryResult& result);

  /**
   * @brief Flush all of the collected results to the server
   */
  Status flushCompleted();

  // Setter for ID of currently executing request
  static void setCurrentRequestId(const std::string& cReqId);

  std::vector<DistributedQueryResult> results_;

  // ID of the currently executing query
  static std::string currentRequestId_;

 private:
  friend class DistributedTests;
  FRIEND_TEST(DistributedTests, test_workflow);
};",1,334 2000 123 439 58 621 2000 40 41 123 125 621 2001 2002 40 41 59 621 2003 2004 40 41 59 621 2003 2005 40 41 59 621 2001 2006 40 2007 646 461 38 2008 41 59 621 2001 2009 40 41 59 621 457 2007 646 461 2010 40 41 59 438 58 618 2001 2011 40 341 2007 646 461 38 2012 41 59 618 2013 2014 40 41 59 618 492 2015 40 341 2016 38 2017 41 59 618 2001 2018 40 41 59 621 457 492 2019 40 341 2007 646 461 38 2020 41 59 2007 646 2021 60 2016 62 2022 59 621 457 2007 646 461 2023 59 437 58 387 334 2024 59 2025 40 2024 44 2026 41 59 125 59 
121345,C++,"class Application final : public QObject {
public:
	struct ProxyChange {
		MTP::ProxyData was;
		MTP::ProxyData now;
	};

	Application(not_null<Launcher*> launcher);
	Application(const Application &other) = delete;
	Application &operator=(const Application &other) = delete;
	~Application();

	[[nodiscard]] not_null<Launcher*> launcher() const {
		return _launcher;
	}

	void run();

	[[nodiscard]] Ui::Animations::Manager &animationManager() const {
		return *_animationsManager;
	}
	[[nodiscard]] Window::Notifications::System &notifications() const {
		Expects(_notifications != nullptr);

		return *_notifications;
	}

	// Windows interface.
	bool hasActiveWindow(not_null<Main::Session*> session) const;
	void saveCurrentDraftsToHistories();
	[[nodiscard]] Window::Controller *activeWindow() const;
	bool closeActiveWindow();
	bool minimizeActiveWindow();
	[[nodiscard]] QWidget *getFileDialogParent();
	void notifyFileDialogShown(bool shown);
	void checkSystemDarkMode();

	// Media view interface.
	void checkMediaViewActivation();
	bool hideMediaView();

	[[nodiscard]] QPoint getPointForCallPanelCenter() const;

	void startSettingsAndBackground();
	[[nodiscard]] Settings &settings() {
		return _settings;
	}
	void saveSettingsDelayed(crl::time delay = kDefaultSaveDelay);
	void saveSettings();

	// Fallback config and proxy.
	[[nodiscard]] MTP::Config &fallbackProductionConfig() const;
	void refreshFallbackProductionConfig(const MTP::Config &config);
	void constructFallbackProductionConfig(const QByteArray &serialized);
	void setCurrentProxy(
		const MTP::ProxyData &proxy,
		MTP::ProxyData::Settings settings);
	[[nodiscard]] rpl::producer<ProxyChange> proxyChanges() const;
	void badMtprotoConfigurationError();

	// Databases.
	[[nodiscard]] Storage::Databases &databases() {
		return *_databases;
	}

	// Domain component.
	[[nodiscard]] Main::Domain &domain() const {
		return *_domain;
	}
	[[nodiscard]] Main::Account &activeAccount() const;
	[[nodiscard]] bool someSessionExists() const;
	[[nodiscard]] Export::Manager &exportManager() const {
		return *_exportManager;
	}
	[[nodiscard]] bool exportPreventsQuit();

	// Main::Session component.
	Main::Session *maybeActiveSession() const;
	[[nodiscard]] int unreadBadge() const;
	[[nodiscard]] bool unreadBadgeMuted() const;
	[[nodiscard]] rpl::producer<> unreadBadgeChanges() const;

	// Media component.
	[[nodiscard]] Media::Audio::Instance &audio() {
		return *_audio;
	}

	// Langpack and emoji keywords.
	[[nodiscard]] Lang::Instance &langpack() {
		return *_langpack;
	}
	[[nodiscard]] Lang::CloudManager *langCloudManager() {
		return _langCloudManager.get();
	}
	[[nodiscard]] bool offerLegacyLangPackSwitch() const;
	[[nodiscard]] bool canApplyLangPackWithoutRestart() const;
	[[nodiscard]] ChatHelpers::EmojiKeywords &emojiKeywords() {
		return *_emojiKeywords;
	}
	[[nodiscard]] auto emojiImageLoader() const
	-> const crl::object_on_queue<Stickers::EmojiImageLoader> & {
		return _emojiImageLoader;
	}

	// Internal links.
	void checkStartUrl();
	bool openLocalUrl(const QString &url, QVariant context);
	bool openInternalUrl(const QString &url, QVariant context);
	[[nodiscard]] QString changelogLink() const;

	// Float player.
	void setDefaultFloatPlayerDelegate(
		not_null<Media::Player::FloatDelegate*> delegate);
	void replaceFloatPlayerDelegate(
		not_null<Media::Player::FloatDelegate*> replacement);
	void restoreFloatPlayerDelegate(
		not_null<Media::Player::FloatDelegate*> replacement);
	[[nodiscard]] rpl::producer<FullMsgId> floatPlayerClosed() const;

	// Calls.
	Calls::Instance &calls() const {
		return *_calls;
	}

	void logout(Main::Account *account = nullptr);
	void forceLogOut(
		not_null<Main::Account*> account,
		const TextWithEntities &explanation);
	void checkLocalTime();
	void lockByPasscode();
	void unlockPasscode();
	[[nodiscard]] bool passcodeLocked() const;
	rpl::producer<bool> passcodeLockChanges() const;
	rpl::producer<bool> passcodeLockValue() const;

	void checkAutoLock(crl::time lastNonIdleTime = 0);
	void checkAutoLockIn(crl::time time);
	void localPasscodeChanged();

	[[nodiscard]] crl::time lastNonIdleTime() const;
	void updateNonIdle();

	void registerLeaveSubscription(not_null<QWidget*> widget);
	void unregisterLeaveSubscription(not_null<QWidget*> widget);

	// Sandbox interface.
	void postponeCall(FnMut<void()> &&callable);
	void refreshGlobalProxy();

	void quitPreventFinished();

	void handleAppActivated();
	void handleAppDeactivated();
	[[nodiscard]] rpl::producer<bool> appDeactivatedValue() const;

	void switchDebugMode();
	void switchFreeType();
	void writeInstallBetaVersionsSetting();

	void preventOrInvoke(Fn<void()> &&callback);

	void call_handleObservables();

	// Global runtime variables.
	void setScreenIsLocked(bool locked);
	bool screenIsLocked() const;

	static void RegisterUrlScheme();

protected:
	bool eventFilter(QObject *object, QEvent *event) override;

private:
	static constexpr auto kDefaultSaveDelay = crl::time(1000);

	friend bool IsAppLaunched();
	friend Application &App();

	void clearEmojiSourceImages();
	[[nodiscard]] auto prepareEmojiSourceImages()
		-> std::shared_ptr<Ui::Emoji::UniversalImages>;
	void startLocalStorage();
	void startShortcuts();
	void startDomain();
	void startEmojiImageLoader();
	void startSystemDarkModeViewer();

	friend void App::quit();
	static void QuitAttempt();
	void quitDelayed();
	[[nodiscard]] bool readyToQuit();

	void showOpenGLCrashNotification();
	void clearPasscodeLock();

	bool openCustomUrl(
		const QString &protocol,
		const std::vector<LocalUrlHandler> &handlers,
		const QString &url,
		const QVariant &context);

	static Application *Instance;
	struct InstanceSetter {
		InstanceSetter(not_null<Application*> instance) {
			Expects(Instance == nullptr);

			Instance = instance;
		}
	};",1,334 2000 381 58 439 2001 123 439 58 462 2002 123 2003 646 2004 2005 59 2003 646 2004 2006 59 125 59 2000 40 2007 60 2008 42 62 2009 41 59 2000 40 341 2000 38 2010 41 61 353 59 2000 38 427 61 40 341 2000 38 2010 41 61 353 59 126 2000 40 41 59 91 91 2011 93 93 2007 60 2008 42 62 2009 40 41 341 123 450 2012 59 125 492 2013 40 41 59 91 91 2011 93 93 2014 646 2015 646 2016 38 2017 40 41 341 123 450 42 2018 59 125 91 91 2011 93 93 2019 646 2020 646 2021 38 2022 40 41 341 123 2023 40 2024 631 425 41 59 450 42 2024 59 125 621 323 2025 40 2007 60 2026 646 2027 42 62 2028 41 341 59 492 2029 40 41 59 91 91 2011 93 93 2019 646 2030 42 2031 40 41 341 59 323 2032 40 41 59 323 2033 40 41 59 91 91 2011 93 93 2034 42 2035 40 41 59 492 2036 40 323 2037 41 59 492 2038 40 41 59 621 492 2039 40 41 59 323 2040 40 41 59 91 91 2011 93 93 2041 2042 40 41 341 59 492 2043 40 41 59 91 91 2011 93 93 2044 38 2045 40 41 123 450 2046 59 125 492 2047 40 2048 646 2049 2050 61 2051 41 59 492 2052 40 41 59 621 91 91 2011 93 93 2053 646 2054 38 2055 40 41 341 59 492 2056 40 341 2053 646 2054 38 2057 41 59 492 2058 40 341 2059 38 2060 41 59 492 2061 40 341 2053 646 2062 38 2063 44 2053 646 2062 646 2044 2045 41 59 91 91 2011 93 93 2064 646 2065 60 2002 62 2066 40 41 341 59 492 2067 40 41 59 621 91 91 2011 93 93 2068 646 2069 38 2070 40 41 123 450 42 2071 59 125 621 91 91 2011 93 93 2026 646 2072 38 2073 40 41 341 123 450 42 2074 59 125 91 91 2011 93 93 2026 646 2075 38 2076 40 41 341 59 91 91 2011 93 93 323 2077 40 41 341 59 91 91 2011 93 93 2078 646 2016 38 2079 40 41 341 123 450 42 2080 59 125 91 91 2011 93 93 323 2081 40 41 59 621 2026 646 2027 42 2082 40 41 341 59 91 91 2011 93 93 404 2083 40 41 341 59 91 91 2011 93 93 323 2084 40 41 341 59 91 91 2011 93 93 2064 646 2065 60 62 2085 40 41 341 59 621 91 91 2011 93 93 2086 646 2087 646 2088 38 2089 40 41 123 450 42 2090 59 125 621 91 91 2011 93 93 2091 646 2088 38 2092 40 41 123 450 42 2093 59 125 91 91 2011 93 93 2091 646 2094 42 2095 40 41 123 450 2096 46 2097 40 41 59 125 91 91 2011 93 93 323 2098 40 41 341 59 91 91 2011 93 93 323 2099 40 41 341 59 91 91 2011 93 93 2100 646 2101 38 2102 40 41 123 450 42 2103 59 125 91 91 2011 93 93 318 2104 40 41 341 624 341 2048 646 2105 60 2106 646 2107 62 38 123 450 2108 59 125 621 492 2109 40 41 59 323 2110 40 341 2111 38 2112 44 2113 2114 41 59 323 2115 40 341 2111 38 2112 44 2113 2114 41 59 91 91 2011 93 93 2111 2116 40 41 341 59 621 492 2117 40 2007 60 2086 646 2118 646 2119 42 62 352 41 59 492 2120 40 2007 60 2086 646 2118 646 2119 42 62 2121 41 59 492 2122 40 2007 60 2086 646 2118 646 2119 42 62 2121 41 59 91 91 2011 93 93 2064 646 2065 60 2123 62 2124 40 41 341 59 621 2125 646 2088 38 2126 40 41 341 123 450 42 2127 59 125 492 2128 40 2026 646 2075 42 2129 61 425 41 59 492 2130 40 2007 60 2026 646 2075 42 62 2129 44 341 2131 38 2132 41 59 492 2133 40 41 59 492 2134 40 41 59 492 2135 40 41 59 91 91 2011 93 93 323 2136 40 41 341 59 2064 646 2065 60 323 62 2137 40 41 341 59 2064 646 2065 60 323 62 2138 40 41 341 59 492 2139 40 2048 646 2049 2140 61 1500 41 59 492 2141 40 2048 646 2049 2049 41 59 492 2142 40 41 59 91 91 2011 93 93 2048 646 2049 2140 40 41 341 59 492 2143 40 41 59 492 2144 40 2007 60 2034 42 62 2145 41 59 492 2146 40 2007 60 2034 42 62 2145 41 59 621 492 2147 40 2148 60 492 40 41 62 605 327 41 59 492 2149 40 41 59 492 2150 40 41 59 492 2151 40 41 59 492 2152 40 41 59 91 91 2011 93 93 2064 646 2065 60 323 62 2153 40 41 341 59 492 2154 40 41 59 492 2155 40 41 59 492 2156 40 41 59 492 2157 40 2158 60 492 40 41 62 605 2159 41 59 492 2160 40 41 59 621 492 2161 40 323 2162 41 59 323 2163 40 41 341 59 457 492 2164 40 41 59 438 58 323 2165 40 2001 42 426 44 2166 42 373 41 431 59 437 58 457 343 318 2051 61 2048 646 2049 40 1504 41 59 387 323 2167 40 41 59 387 2000 38 2168 40 41 59 492 2169 40 41 59 91 91 2011 93 93 318 2170 40 41 624 2171 646 2172 60 2014 646 2173 646 2174 62 59 492 2175 40 41 59 492 2176 40 41 59 492 2177 40 41 59 492 2178 40 41 59 492 2179 40 41 59 387 492 2168 646 2180 40 41 59 457 492 2181 40 41 59 492 2182 40 41 59 91 91 2011 93 93 323 2183 40 41 59 492 2184 40 41 59 492 2185 40 41 59 323 2186 40 341 2111 38 2187 44 341 2171 646 2188 60 2189 62 38 2190 44 341 2111 38 2112 44 341 2113 38 2114 41 59 457 2000 42 2088 59 462 2191 123 2191 40 2007 60 2000 42 62 2192 41 123 2193 40 2088 614 425 41 59 2088 61 2192 59 125 125 59 
102003,C++,"    class CreateCollectionPrompt : public PromptBase
    {
        Q_OBJECT
        friend class PromptBase;

        explicit CreateCollectionPrompt(Service* parent, QVariantMap properties, QString alias);

        PromptResult promptSync(const DBusClientPtr& client, const QString& windowId) override;
        QVariant currentResult() const override;

        QVariantMap m_properties;
        QString m_alias;
        Collection* m_coll{};
    };",1,334 2000 58 439 2001 123 2002 387 334 2001 59 376 2000 40 2003 42 2004 44 2005 2006 44 2007 2008 41 59 2009 2010 40 341 2011 38 2012 44 341 2007 38 2013 41 431 59 2014 2015 40 41 341 431 59 2005 2016 59 2007 2017 59 2018 42 2019 123 125 59 125 59 
101967,C++,"class PasswordGeneratorWidget : public QWidget
{
    Q_OBJECT

public:
    enum GeneratorTypes
    {
        Password = 0,
        Diceware = 1
    };

    explicit PasswordGeneratorWidget(QWidget* parent = nullptr);
    ~PasswordGeneratorWidget();

    void loadSettings();
    void saveSettings();
    void setPasswordLength(int length);
    void setStandaloneMode(bool standalone);
    QString getGeneratedPassword();
    bool isPasswordVisible() const;

    static PasswordGeneratorWidget* popupGenerator(QWidget* parent = nullptr);

public slots:
    void regeneratePassword();
    void applyPassword();
    void copyPassword();
    void setPasswordVisible(bool visible);
    void deleteWordList();
    void addWordList();

signals:
    void appliedPassword(const QString& password);
    void closed();

private slots:
    void updateButtonsEnabled(const QString& password);
    void updatePasswordStrength(const QString& password);
    void setAdvancedMode(bool advanced);
    void excludeHexChars();

    void passwordLengthChanged(int length);
    void passphraseLengthChanged(int length);
    void colorStrengthIndicator(const PasswordHealth& health);

    void updateGenerator();

private:
    bool m_standalone = false;
    int m_firstCustomWordlistIndex;

    void closeEvent(QCloseEvent* event);
    PasswordGenerator::CharClasses charClasses();
    PasswordGenerator::GeneratorFlags generatorFlags();

    const QScopedPointer<PasswordGenerator> m_passwordGenerator;
    const QScopedPointer<PassphraseGenerator> m_dicewareGenerator;
    const QScopedPointer<Ui::PasswordGeneratorWidget> m_ui;
};",1,334 2000 58 439 2001 123 2002 439 58 370 2003 123 2004 61 1500 44 2005 61 1501 125 59 376 2000 40 2001 42 2006 61 425 41 59 126 2000 40 41 59 492 2007 40 41 59 492 2008 40 41 59 492 2009 40 404 2010 41 59 492 2011 40 323 2012 41 59 2013 2014 40 41 59 323 2015 40 41 341 59 457 2000 42 2016 40 2001 42 2006 61 425 41 59 439 2017 58 492 2018 40 41 59 492 2019 40 41 59 492 2020 40 41 59 492 2021 40 323 2022 41 59 492 2023 40 41 59 492 2024 40 41 59 2025 58 492 2026 40 341 2013 38 2027 41 59 492 2028 40 41 59 437 2017 58 492 2029 40 341 2013 38 2027 41 59 492 2030 40 341 2013 38 2027 41 59 492 2031 40 323 2032 41 59 492 2033 40 41 59 492 2034 40 404 2010 41 59 492 2035 40 404 2010 41 59 492 2036 40 341 2037 38 2038 41 59 492 2039 40 41 59 437 58 323 2040 61 380 59 404 2041 59 492 2042 40 2043 42 373 41 59 2044 646 2045 2046 40 41 59 2044 646 2047 2048 40 41 59 341 2049 60 2044 62 2050 59 341 2049 60 2051 62 2052 59 341 2049 60 2053 646 2000 62 2054 59 125 59 
101887,C++,"class DatabaseWidget : public QStackedWidget
{
    Q_OBJECT

public:
    friend class DatabaseOpenDialog;

    enum class Mode
    {
        None,
        ImportMode,
        ViewMode,
        EditMode,
        LockedMode
    };

    explicit DatabaseWidget(QSharedPointer<Database> db, QWidget* parent = nullptr);
    explicit DatabaseWidget(const QString& filePath, QWidget* parent = nullptr);
    ~DatabaseWidget() override;

    void setFocus(Qt::FocusReason reason);

    QSharedPointer<Database> database() const;

    DatabaseWidget::Mode currentMode() const;
    bool isLocked() const;
    bool isSaving() const;
    bool isSorted() const;
    bool isSearchActive() const;
    bool isEntryViewActive() const;
    bool isEntryEditActive() const;
    bool isGroupEditActive() const;

    QString getCurrentSearch();
    void refreshSearch();

    GroupView* groupView();
    EntryView* entryView();

    Group* currentGroup() const;
    bool canCloneCurrentGroup() const;
    bool canDeleteCurrentGroup() const;
    bool isGroupSelected() const;
    bool isRecycleBinSelected() const;
    int numberOfSelectedEntries() const;
    int currentEntryIndex() const;

    QStringList customEntryAttributes() const;
    bool isEditWidgetModified() const;
    void clearAllWidgets();
    Entry* currentSelectedEntry();
    bool currentEntryHasTitle();
    bool currentEntryHasUsername();
    bool currentEntryHasPassword();
    bool currentEntryHasUrl();
    bool currentEntryHasNotes();
    bool currentEntryHasTotp();
#ifdef WITH_XC_SSHAGENT
    bool currentEntryHasSshKey();
#endif

    QByteArray entryViewState() const;
    bool setEntryViewState(const QByteArray& state) const;
    QList<int> mainSplitterSizes() const;
    void setMainSplitterSizes(const QList<int>& sizes);
    QList<int> previewSplitterSizes() const;
    void setPreviewSplitterSizes(const QList<int>& sizes);
    void setSearchStringForAutoType(const QString& search);

signals:
    // relayed Database signals
    void databaseFilePathChanged(const QString& oldPath, const QString& newPath);
    void databaseModified();
    void databaseSaved();
    void databaseUnlocked();
    void databaseLockRequested();
    void databaseLocked();

    // Emitted in replaceDatabase, may be caused by lock, reload, unlock, load.
    void databaseReplaced(const QSharedPointer<Database>& oldDb, const QSharedPointer<Database>& newDb);

    void closeRequest();
    void currentModeChanged(DatabaseWidget::Mode mode);
    void groupChanged();
    void entrySelectionChanged();
    void
    requestOpenDatabase(const QString& filePath, bool inBackground, const QString& password, const QString& keyFile);
    void databaseMerged(QSharedPointer<Database> mergedDb);
    void groupContextMenuRequested(const QPoint& globalPos);
    void entryContextMenuRequested(const QPoint& globalPos);
    void listModeAboutToActivate();
    void listModeActivated();
    void searchModeAboutToActivate();
    void searchModeActivated();
    void mainSplitterSizesChanged();
    void previewSplitterSizesChanged();
    void entryViewStateChanged();
    void clearSearch();
    void requestGlobalAutoType(const QString& search);

public slots:
    bool lock();
    bool save();
    bool saveAs();
    bool saveBackup();

    void replaceDatabase(QSharedPointer<Database> db);
    void createEntry();
    void cloneEntry();
    void deleteSelectedEntries();
    void restoreSelectedEntries();
    void deleteEntries(QList<Entry*> entries, bool confirm = true);
    void focusOnEntries(bool editIfFocused = false);
    void focusOnGroups(bool editIfFocused = false);
    void moveEntryUp();
    void moveEntryDown();
    void copyTitle();
    void copyUsername();
    void copyPassword();
    void copyURL();
    void copyNotes();
    void copyAttribute(QAction* action);
    void showTotp();
    void showTotpKeyQrCode();
    void copyTotp();
    void setupTotp();
#ifdef WITH_XC_SSHAGENT
    void addToAgent();
    void removeFromAgent();
#endif
    void performAutoType(const QString& sequence = {});
    void performAutoTypeUsername();
    void performAutoTypeUsernameEnter();
    void performAutoTypePassword();
    void performAutoTypePasswordEnter();
    void performAutoTypeTOTP();
    void openUrl();
    void downloadSelectedFavicons();
    void downloadAllFavicons();
    void downloadFaviconInBackground(Entry* entry);
    void openUrlForEntry(Entry* entry);
    void createGroup();
    void cloneGroup();
    void deleteGroup();
    void switchToMainView(bool previousDialogAccepted = false);
    void switchToEntryEdit();
    void switchToGroupEdit();
    void sortGroupsAsc();
    void sortGroupsDesc();
    void switchToDatabaseSecurity();
    void switchToDatabaseReports();
    void switchToDatabaseSettings();
    void switchToOpenDatabase();
    void switchToOpenDatabase(const QString& filePath);
    void switchToOpenDatabase(const QString& filePath, const QString& password, const QString& keyFile);
    void switchToCsvImport(const QString& filePath);
    void performUnlockDatabase(const QString& password, const QString& keyfile = {});
    void csvImportFinished(bool accepted);
    void switchToImportKeepass1(const QString& filePath);
    void switchToImportOpVault(const QString& fileName);
    void emptyRecycleBin();

    // Search related slots
    void search(const QString& searchtext);
    void setSearchCaseSensitive(bool state);
    void setSearchLimitGroup(bool state);
    void endSearch();

    void showMessage(const QString& text,
                     MessageWidget::MessageType type,
                     bool showClosebutton = true,
                     int autoHideTimeout = MessageWidget::DefaultAutoHideTimeout);
    void showErrorMessage(const QString& errorMessage);
    void hideMessage();

protected:
    void closeEvent(QCloseEvent* event) override;
    void showEvent(QShowEvent* event) override;
    bool focusNextPrevChild(bool next) override;

private slots:
    void entryActivationSignalReceived(Entry* entry, EntryModel::ModelColumn column);
    void switchBackToEntryEdit();
    void switchToHistoryView(Entry* entry);
    void switchToEntryEdit(Entry*);
    void switchToEntryEdit(Entry* entry, bool create);
    void switchToGroupEdit(Group* entry, bool create);
    void emitGroupContextMenuRequested(const QPoint& pos);
    void emitEntryContextMenuRequested(const QPoint& pos);
    void onEntryChanged(Entry* entry);
    void onGroupChanged();
    void onDatabaseModified();
    void connectDatabaseSignals();
    void loadDatabase(bool accepted);
    void unlockDatabase(bool accepted);
    void mergeDatabase(bool accepted);
    void emitCurrentModeChanged();
    // Database autoreload slots
    void reloadDatabaseFile();
    void restoreGroupEntryFocus(const QUuid& groupUuid, const QUuid& EntryUuid);

private:
    int addChildWidget(QWidget* w);
    void setClipboardTextAndMinimize(const QString& text);
    void processAutoOpen();
    void openDatabaseFromEntry(const Entry* entry, bool inBackground = true);
    void performIconDownloads(const QList<Entry*>& entries, bool force = false, bool downloadInBackground = false);
    bool performSave(QString& errorMessage, const QString& fileName = {});

    QSharedPointer<Database> m_db;

    QPointer<QWidget> m_mainWidget;
    QPointer<QSplitter> m_mainSplitter;
    QPointer<MessageWidget> m_messageWidget;
    QPointer<EntryPreviewWidget> m_previewView;
    QPointer<QSplitter> m_previewSplitter;
    QPointer<QLabel> m_searchingLabel;
    QPointer<QLabel> m_shareLabel;
    QPointer<CsvImportWizard> m_csvImportWizard;
    QPointer<EditEntryWidget> m_editEntryWidget;
    QPointer<EditGroupWidget> m_editGroupWidget;
    QPointer<EditEntryWidget> m_historyEditEntryWidget;
    QPointer<ReportsDialog> m_reportsDialog;
    QPointer<DatabaseSettingsDialog> m_databaseSettingDialog;
    QPointer<DatabaseOpenWidget> m_databaseOpenWidget;
    QPointer<KeePass1OpenWidget> m_keepass1OpenWidget;
    QPointer<OpVaultOpenWidget> m_opVaultOpenWidget;
    QPointer<GroupView> m_groupView;
    QPointer<EntryView> m_entryView;

    QScopedPointer<Group> m_newGroup;
    QScopedPointer<Entry> m_newEntry;
    QPointer<Group> m_newParent;

    QUuid m_groupBeforeLock;
    QUuid m_entryBeforeLock;

    int m_saveAttempts;

    // Search state
    QScopedPointer<EntrySearcher> m_entrySearcher;
    QString m_lastSearchText;
    bool m_searchLimitGroup;

    // Autoreload
    bool m_blockAutoSave;

    // Auto-Type related
    QString m_searchStringForAutoType;
};",1,334 2000 58 439 2001 123 2002 439 58 387 334 2003 59 370 334 2004 123 303 44 2005 44 2006 44 2007 44 2008 125 59 376 2000 40 2009 60 2010 62 2011 44 2012 42 2013 61 425 41 59 376 2000 40 341 2014 38 2015 44 2012 42 2013 61 425 41 59 126 2000 40 41 431 59 492 2016 40 2017 646 2018 2019 41 59 2009 60 2010 62 2020 40 41 341 59 2000 646 2004 2021 40 41 341 59 323 2022 40 41 341 59 323 2023 40 41 341 59 323 2024 40 41 341 59 323 2025 40 41 341 59 323 2026 40 41 341 59 323 2027 40 41 341 59 323 2028 40 41 341 59 2014 2029 40 41 59 492 2030 40 41 59 2031 42 2032 40 41 59 2033 42 2034 40 41 59 2035 42 2036 40 41 341 59 323 2037 40 41 341 59 323 2038 40 41 341 59 323 2039 40 41 341 59 323 2040 40 41 341 59 404 2041 40 41 341 59 404 2042 40 41 341 59 2043 2044 40 41 341 59 323 2045 40 41 341 59 492 2046 40 41 59 2047 42 2048 40 41 59 323 2049 40 41 59 323 2050 40 41 59 323 2051 40 41 59 323 2052 40 41 59 323 2053 40 41 59 323 2054 40 41 59 35 393 2055 323 2056 40 41 59 35 366 2057 2058 40 41 341 59 323 2059 40 341 2057 38 2060 41 341 59 2061 60 404 62 2062 40 41 341 59 492 2063 40 341 2061 60 404 62 38 2064 41 59 2061 60 404 62 2065 40 41 341 59 492 2066 40 341 2061 60 404 62 38 2064 41 59 492 2067 40 341 2014 38 2068 41 59 2069 58 621 492 2070 40 341 2014 38 2071 44 341 2014 38 2072 41 59 492 2073 40 41 59 492 2074 40 41 59 492 2075 40 41 59 492 2076 40 41 59 492 2077 40 41 59 621 492 2078 40 341 2009 60 2010 62 38 2079 44 341 2009 60 2010 62 38 2080 41 59 492 2081 40 41 59 492 2082 40 2000 646 2004 2083 41 59 492 2084 40 41 59 492 2085 40 41 59 492 2086 40 341 2014 38 2015 44 323 2087 44 341 2014 38 2088 44 341 2014 38 2089 41 59 492 2090 40 2009 60 2010 62 2091 41 59 492 2092 40 341 2093 38 2094 41 59 492 2095 40 341 2093 38 2094 41 59 492 2096 40 41 59 492 2097 40 41 59 492 2098 40 41 59 492 2099 40 41 59 492 2100 40 41 59 492 2101 40 41 59 492 2102 40 41 59 492 2103 40 41 59 492 2104 40 341 2014 38 2068 41 59 439 2105 58 323 412 40 41 59 323 2106 40 41 59 323 2107 40 41 59 323 2108 40 41 59 492 2109 40 2009 60 2010 62 2011 41 59 492 2110 40 41 59 492 2111 40 41 59 492 2112 40 41 59 492 2113 40 41 59 492 2114 40 2061 60 2047 42 62 2115 44 323 2116 61 473 41 59 492 2117 40 323 2118 61 380 41 59 492 2119 40 323 2118 61 380 41 59 492 2120 40 41 59 492 2121 40 41 59 492 2122 40 41 59 492 2123 40 41 59 492 2124 40 41 59 492 2125 40 41 59 492 2126 40 41 59 492 2127 40 2128 42 2129 41 59 492 2130 40 41 59 492 2131 40 41 59 492 2132 40 41 59 492 2133 40 41 59 35 393 2055 492 2134 40 41 59 492 2135 40 41 59 35 366 492 2136 40 341 2014 38 2137 61 123 125 41 59 492 2138 40 41 59 492 2139 40 41 59 492 2140 40 41 59 492 2141 40 41 59 492 2142 40 41 59 492 2143 40 41 59 492 2144 40 41 59 492 2145 40 41 59 492 2146 40 2047 42 2147 41 59 492 2148 40 2047 42 2147 41 59 492 2149 40 41 59 492 2150 40 41 59 492 2151 40 41 59 492 2152 40 323 2153 61 380 41 59 492 2154 40 41 59 492 2155 40 41 59 492 2156 40 41 59 492 2157 40 41 59 492 2158 40 41 59 492 2159 40 41 59 492 2160 40 41 59 492 2161 40 41 59 492 2161 40 341 2014 38 2015 41 59 492 2161 40 341 2014 38 2015 44 341 2014 38 2088 44 341 2014 38 2089 41 59 492 2162 40 341 2014 38 2015 41 59 492 2163 40 341 2014 38 2088 44 341 2014 38 2164 61 123 125 41 59 492 2165 40 323 2166 41 59 492 2167 40 341 2014 38 2015 41 59 492 2168 40 341 2014 38 2169 41 59 492 2170 40 41 59 621 492 2068 40 341 2014 38 2171 41 59 492 2172 40 323 2060 41 59 492 2173 40 323 2060 41 59 492 2174 40 41 59 492 2175 40 341 2014 38 2176 44 2177 646 2178 2179 44 323 2180 61 473 44 404 2181 61 2177 646 2182 41 59 492 2183 40 341 2014 38 2184 41 59 492 2185 40 41 59 438 58 492 2186 40 2187 42 373 41 431 59 492 2188 40 2189 42 373 41 431 59 323 2190 40 323 2191 41 431 59 437 2105 58 492 2192 40 2047 42 2147 44 2193 646 2194 2195 41 59 492 2196 40 41 59 492 2197 40 2047 42 2147 41 59 492 2154 40 2047 42 41 59 492 2154 40 2047 42 2147 44 323 2198 41 59 492 2155 40 2035 42 2147 44 323 2198 41 59 492 2199 40 341 2093 38 2200 41 59 492 2201 40 341 2093 38 2200 41 59 492 2202 40 2047 42 2147 41 59 492 2203 40 41 59 492 2204 40 41 59 492 2205 40 41 59 492 2206 40 323 2166 41 59 492 2207 40 323 2166 41 59 492 2208 40 323 2166 41 59 492 2209 40 41 59 621 492 2210 40 41 59 492 2211 40 341 2212 38 2213 44 341 2212 38 2214 41 59 437 58 404 2215 40 2012 42 2216 41 59 492 2217 40 341 2014 38 2176 41 59 492 2218 40 41 59 492 2219 40 341 2047 42 2147 44 323 2087 61 473 41 59 492 2220 40 341 2061 60 2047 42 62 38 2115 44 323 2221 61 380 44 323 2222 61 380 41 59 323 2223 40 2014 38 2184 44 341 2014 38 2169 61 123 125 41 59 2009 60 2010 62 2224 59 2225 60 2012 62 2226 59 2225 60 2227 62 2228 59 2225 60 2177 62 2229 59 2225 60 2230 62 2231 59 2225 60 2227 62 2232 59 2225 60 2233 62 2234 59 2225 60 2233 62 2235 59 2225 60 2236 62 2237 59 2225 60 2238 62 2239 59 2225 60 2240 62 2241 59 2225 60 2238 62 2242 59 2225 60 2243 62 2244 59 2225 60 2245 62 2246 59 2225 60 2247 62 2248 59 2225 60 2249 62 2250 59 2225 60 2251 62 2252 59 2225 60 2031 62 2253 59 2225 60 2033 62 2254 59 2255 60 2035 62 2256 59 2255 60 2047 62 2257 59 2225 60 2035 62 2258 59 2212 2259 59 2212 2260 59 404 2261 59 621 2255 60 2262 62 2263 59 2014 2264 59 323 2265 59 621 323 2266 59 621 2014 2267 59 125 59 
102138,C++,"class TestGuiFdoSecrets : public QObject
{
    Q_OBJECT

public:
    ~TestGuiFdoSecrets() override;

private slots:
    void initTestCase();
    void init();
    void cleanup();
    void cleanupTestCase();

    void testServiceEnable();
    void testServiceEnableNoExposedDatabase();
    void testServiceSearch();
    void testServiceSearchBlockingUnlock();
    void testServiceSearchForce();
    void testServiceUnlock();
    void testServiceUnlockDatabaseConcurrent();
    void testServiceUnlockItems();
    void testServiceLock();
    void testServiceLockConcurrent();

    void testSessionOpen();
    void testSessionClose();

    void testCollectionCreate();
    void testCollectionDelete();
    void testCollectionDeleteConcurrent();
    void testCollectionChange();

    void testItemCreate();
    void testItemChange();
    void testItemReplace();
    void testItemReplaceExistingLocked();
    void testItemSecret();
    void testItemDelete();
    void testItemLockState();
    void testItemRejectSetReferenceFields();

    void testAlias();
    void testDefaultAliasAlwaysPresent();

    void testExposeSubgroup();
    void testModifyingExposedGroup();

    void testHiddenFilename();
    void testDuplicateName();

private:
    bool driveUnlockDialog();
    bool driveNewDatabaseWizard();
    bool driveAccessControlDialog(bool remember = true);
    bool waitForSignal(QSignalSpy& spy, int expectedCount);

    void processEvents();

    void lockDatabaseInBackend();
    void unlockDatabaseInBackend();
    QSharedPointer<ServiceProxy> enableService();
    QSharedPointer<SessionProxy> openSession(const QSharedPointer<ServiceProxy>& service, const QString& algo);
    QSharedPointer<CollectionProxy> getDefaultCollection(const QSharedPointer<ServiceProxy>& service);
    QSharedPointer<ItemProxy> getFirstItem(const QSharedPointer<CollectionProxy>& coll);
    QSharedPointer<ItemProxy> createItem(const QSharedPointer<SessionProxy>& sess,
                                         const QSharedPointer<CollectionProxy>& coll,
                                         const QString& label,
                                         const QString& pass,
                                         const FdoSecrets::wire::StringStringMap& attr,
                                         bool replace,
                                         bool expectPrompt = false);
    FdoSecrets::wire::Secret
    encryptPassword(QByteArray value, QString contentType, const QSharedPointer<SessionProxy>& sess);
    template <typename Proxy> QSharedPointer<Proxy> getProxy(const QDBusObjectPath& path) const
    {
        auto ret = QSharedPointer<Proxy>{
            new Proxy(QStringLiteral(""org.freedesktop.secrets""), path.path(), QDBusConnection::sessionBus())};
        if (!ret->isValid()) {
            return {};
        }
        return ret;
    }

    template <typename T> T getSignalVariantArgument(const QVariant& arg)
    {
        const auto& in = arg.value<QDBusVariant>().variant();
        return qdbus_cast<T>(in);
    }

private:
    QScopedPointer<MainWindow> m_mainWindow;
    QPointer<DatabaseTabWidget> m_tabWidget;
    QPointer<DatabaseWidget> m_dbWidget;
    QSharedPointer<Database> m_db;

    QPointer<FdoSecretsPlugin> m_plugin;
    QSharedPointer<FdoSecrets::DBusClient> m_client;

    QScopedPointer<FdoSecrets::DhIetf1024Sha256Aes128CbcPkcs7> m_clientCipher;

    QByteArray m_dbData;
    QScopedPointer<TemporaryFile> m_dbFile;
};",1,334 2000 58 439 2001 123 2002 439 58 126 2000 40 41 431 59 437 2003 58 492 2004 40 41 59 492 2005 40 41 59 492 2006 40 41 59 492 2007 40 41 59 492 2008 40 41 59 492 2009 40 41 59 492 2010 40 41 59 492 2011 40 41 59 492 2012 40 41 59 492 2013 40 41 59 492 2014 40 41 59 492 2015 40 41 59 492 2016 40 41 59 492 2017 40 41 59 492 2018 40 41 59 492 2019 40 41 59 492 2020 40 41 59 492 2021 40 41 59 492 2022 40 41 59 492 2023 40 41 59 492 2024 40 41 59 492 2025 40 41 59 492 2026 40 41 59 492 2027 40 41 59 492 2028 40 41 59 492 2029 40 41 59 492 2030 40 41 59 492 2031 40 41 59 492 2032 40 41 59 492 2033 40 41 59 492 2034 40 41 59 492 2035 40 41 59 492 2036 40 41 59 492 2037 40 41 59 437 58 323 2038 40 41 59 323 2039 40 41 59 323 2040 40 323 2041 61 473 41 59 323 2042 40 2043 38 2044 44 404 2045 41 59 492 2046 40 41 59 492 2047 40 41 59 492 2048 40 41 59 2049 60 2050 62 2051 40 41 59 2049 60 2052 62 2053 40 341 2049 60 2050 62 38 2054 44 341 2055 38 2056 41 59 2049 60 2057 62 2058 40 341 2049 60 2050 62 38 2054 41 59 2049 60 2059 62 2060 40 341 2049 60 2057 62 38 2061 41 59 2049 60 2059 62 2062 40 341 2049 60 2052 62 38 2063 44 341 2049 60 2057 62 38 2061 44 341 2055 38 2064 44 341 2055 38 434 44 341 2065 646 2066 646 2067 38 2068 44 323 2069 44 323 2070 61 380 41 59 2065 646 2066 646 2071 2072 40 2073 2074 44 2055 2075 44 341 2049 60 2052 62 38 2063 41 59 466 60 477 2076 62 2049 60 2076 62 2077 40 341 2078 38 2079 41 341 123 318 2080 61 2049 60 2076 62 123 418 2076 40 2081 40 648 41 44 2079 46 2079 40 41 44 2082 646 2083 40 41 41 125 59 392 40 33 2080 624 2084 40 41 41 123 450 123 125 59 125 450 2080 59 125 466 60 477 2085 62 2085 2086 40 341 2087 38 2088 41 123 341 318 38 398 61 2088 46 2074 60 2089 62 40 41 46 2090 40 41 59 450 2091 60 2085 62 40 398 41 59 125 437 58 2092 60 2093 62 2094 59 2095 60 2096 62 2097 59 2095 60 2098 62 2099 59 2049 60 2100 62 2101 59 2095 60 2102 62 2103 59 2049 60 2065 646 2104 62 2105 59 2092 60 2065 646 2106 62 2107 59 2073 2108 59 2092 60 2109 62 2110 59 125 59 
101910,C++,"    class Service : public DBusObject // clazy: exclude=ctor-missing-parent-argument
    {
        Q_OBJECT
        Q_CLASSINFO(""D-Bus Interface"", DBUS_INTERFACE_SECRET_SERVICE_LITERAL)

        explicit Service(FdoSecretsPlugin* plugin, QPointer<DatabaseTabWidget> dbTabs, QSharedPointer<DBusMgr> dbus);

    public:
        /**
         * @brief Create a new instance of `Service`. Its parent is set to `null`
         * @return pointer to newly created Service, or nullptr if error
         * This may be caused by
         *   - failed initialization
         */
        static QSharedPointer<Service>
        Create(FdoSecretsPlugin* plugin, QPointer<DatabaseTabWidget> dbTabs, QSharedPointer<DBusMgr> dbus);
        ~Service() override;

        Q_INVOKABLE DBusResult openSession(const DBusClientPtr& client,
                                           const QString& algorithm,
                                           const QVariant& input,
                                           QVariant& output,
                                           Session*& result);
        Q_INVOKABLE DBusResult createCollection(const QVariantMap& properties,
                                                const QString& alias,
                                                Collection*& collection,
                                                PromptBase*& prompt);
        Q_INVOKABLE DBusResult searchItems(const DBusClientPtr& client,
                                           const StringStringMap& attributes,
                                           QList<Item*>& unlocked,
                                           QList<Item*>& locked) const;

        Q_INVOKABLE DBusResult unlock(const DBusClientPtr& client,
                                      const QList<DBusObject*>& objects,
                                      QList<DBusObject*>& unlocked,
                                      PromptBase*& prompt);

        Q_INVOKABLE DBusResult lock(const QList<DBusObject*>& objects, QList<DBusObject*>& locked, PromptBase*& prompt);

        Q_INVOKABLE DBusResult getSecrets(const DBusClientPtr& client,
                                          const QList<Item*>& items,
                                          Session* session,
                                          ItemSecretMap& secrets) const;

        Q_INVOKABLE DBusResult readAlias(const QString& name, Collection*& collection) const;

        Q_INVOKABLE DBusResult setAlias(const QString& name, Collection* collection);

        /**
         * List of collections
         * @return
         */
        Q_INVOKABLE DBUS_PROPERTY DBusResult collections(QList<Collection*>& collections) const;

    signals:
        void collectionCreated(Collection* collection);
        void collectionDeleted(Collection* collection);
        void collectionChanged(Collection* collection);

        /**
         * Finish signal for async action doUnlockDatabaseInDialog
         * @param accepted If false, the action is cancelled by the user
         * @param dbWidget The dbWidget the action is on
         */
        void doneUnlockDatabaseInDialog(bool accepted, DatabaseWidget* dbWidget);

    public:
        /**
         * List of sessions
         * @return
         */
        QList<Session*> sessions() const;

        FdoSecretsPlugin* plugin() const
        {
            return m_plugin;
        }

    public slots:
        bool doLockDatabase(DatabaseWidget* dbWidget);
        bool doCloseDatabase(DatabaseWidget* dbWidget);
        Collection* doNewDatabase();
        void doSwitchToDatabaseSettings(DatabaseWidget* dbWidget);

        /**
         * Async, connect to signal doneUnlockDatabaseInDialog for finish notification
         * @param dbWidget
         */
        void doUnlockDatabaseInDialog(DatabaseWidget* dbWidget);

    private slots:
        void ensureDefaultAlias();

        void onDatabaseTabOpened(DatabaseWidget* dbWidget, bool emitSignal);
        void monitorDatabaseExposedGroup(DatabaseWidget* dbWidget);

        void onCollectionAliasAboutToAdd(const QString& alias);
        void onCollectionAliasAdded(const QString& alias);

        void onCollectionAliasRemoved(const QString& alias);

        void onDatabaseUnlockDialogFinished(bool accepted, DatabaseWidget* dbWidget);

    private:
        bool initialize();

        /**
         * Find collection by alias name
         * @param alias
         * @return the collection under alias
         */
        Collection* findCollection(const QString& alias) const;

        /**
         * Find collection by dbWidget
         * @param db
         * @return the collection corresponding to the db
         */
        Collection* findCollection(const DatabaseWidget* db) const;

    private:
        FdoSecretsPlugin* m_plugin{nullptr};
        QPointer<DatabaseTabWidget> m_databases{};

        QHash<QString, Collection*> m_aliases{};
        QList<Collection*> m_collections{};
        QHash<const DatabaseWidget*, Collection*> m_dbToCollection{};

        QList<Session*> m_sessions{};

        bool m_insideEnsureDefaultAlias{false};
        QSet<const DatabaseWidget*> m_unlockingDb{}; // list of db being unlocking
        QSet<const DatabaseWidget*> m_lockingDb{}; // list of db being locking
    };",1,334 2000 58 439 2001 621 123 2002 2003 40 648 44 2004 41 376 2000 40 2005 42 2006 44 2007 60 2008 62 2009 44 2010 60 2011 62 2012 41 59 439 58 618 457 2010 60 2000 62 2013 40 2005 42 2006 44 2007 60 2008 62 2009 44 2010 60 2011 62 2012 41 59 126 2000 40 41 431 59 2014 2015 2016 40 341 2017 38 2018 44 341 2019 38 2020 44 341 2021 38 2022 44 2021 38 2023 44 2024 42 38 2025 41 59 2014 2015 2026 40 341 2027 38 2028 44 341 2019 38 2029 44 2030 42 38 2031 44 2032 42 38 2033 41 59 2014 2015 2034 40 341 2017 38 2018 44 341 2035 38 2036 44 2037 60 2038 42 62 38 2039 44 2037 60 2038 42 62 38 2040 41 341 59 2014 2015 2041 40 341 2017 38 2018 44 341 2037 60 2001 42 62 38 2042 44 2037 60 2001 42 62 38 2039 44 2032 42 38 2033 41 59 2014 2015 412 40 341 2037 60 2001 42 62 38 2042 44 2037 60 2001 42 62 38 2040 44 2032 42 38 2033 41 59 2014 2015 2043 40 341 2017 38 2018 44 341 2037 60 2038 42 62 38 2044 44 2024 42 2045 44 2046 38 2047 41 341 59 2014 2015 2048 40 341 2019 38 2049 44 2030 42 38 2031 41 341 59 2014 2015 2050 40 341 2019 38 2049 44 2030 42 2031 41 59 618 2014 2051 2015 2052 40 2037 60 2030 42 62 38 2052 41 341 59 2053 58 492 2054 40 2030 42 2031 41 59 492 2055 40 2030 42 2031 41 59 492 2056 40 2030 42 2031 41 59 618 492 2057 40 323 2058 44 2059 42 2060 41 59 439 58 618 2037 60 2024 42 62 2061 40 41 341 59 2005 42 2006 40 41 341 123 450 2062 59 125 439 2063 58 323 2064 40 2059 42 2060 41 59 323 2065 40 2059 42 2060 41 59 2030 42 2066 40 41 59 492 2067 40 2059 42 2060 41 59 618 492 2068 40 2059 42 2060 41 59 437 2063 58 492 2069 40 41 59 492 2070 40 2059 42 2060 44 323 2071 41 59 492 2072 40 2059 42 2060 41 59 492 2073 40 341 2019 38 2029 41 59 492 2074 40 341 2019 38 2029 41 59 492 2075 40 341 2019 38 2029 41 59 492 2076 40 323 2058 44 2059 42 2060 41 59 437 58 323 2077 40 41 59 618 2030 42 2078 40 341 2019 38 2029 41 341 59 618 2030 42 2078 40 341 2059 42 2079 41 341 59 437 58 2005 42 2080 123 425 125 59 2007 60 2008 62 2081 123 125 59 2082 60 2019 44 2030 42 62 2083 123 125 59 2037 60 2030 42 62 2084 123 125 59 2082 60 341 2059 42 44 2030 42 62 2085 123 125 59 2037 60 2024 42 62 2086 123 125 59 323 2087 123 380 125 59 2088 60 341 2059 42 62 2089 123 125 59 621 2088 60 341 2059 42 62 2090 123 125 59 621 125 59 
101909,C++,"    class Collection : public DBusObject
    {
        Q_OBJECT
        Q_CLASSINFO(""D-Bus Interface"", DBUS_INTERFACE_SECRET_COLLECTION_LITERAL)

        explicit Collection(Service* parent, DatabaseWidget* backend);

    public:
        /**
         * @brief Create a new instance of `Collection`
         * @param parent the owning Service
         * @param backend the widget containing the database
         * @return pointer to created instance, or nullptr when error happens.
         * This may be caused by
         *   - DBus path registration error
         *   - database has no exposed group
         */
        static Collection* Create(Service* parent, DatabaseWidget* backend);

        Q_INVOKABLE DBUS_PROPERTY DBusResult items(QList<Item*>& items) const;

        Q_INVOKABLE DBUS_PROPERTY DBusResult label(QString& label) const;
        Q_INVOKABLE DBusResult setLabel(const QString& label);

        Q_INVOKABLE DBUS_PROPERTY DBusResult locked(bool& locked) const;

        Q_INVOKABLE DBUS_PROPERTY DBusResult created(qulonglong& created) const;

        Q_INVOKABLE DBUS_PROPERTY DBusResult modified(qulonglong& modified) const;

        Q_INVOKABLE DBusResult remove(PromptBase*& prompt);
        Q_INVOKABLE DBusResult searchItems(const DBusClientPtr& client,
                                           const StringStringMap& attributes,
                                           QList<Item*>& items);
        Q_INVOKABLE DBusResult
        createItem(const QVariantMap& properties, const Secret& secret, bool replace, Item*& item, PromptBase*& prompt);

    signals:
        void itemCreated(Item* item);
        void itemDeleted(Item* item);
        void itemChanged(Item* item);

        void collectionChanged();
        void collectionAboutToDelete();
        void collectionLockChanged(bool newLocked);

        void aliasAboutToAdd(const QString& alias);
        void aliasAdded(const QString& alias);
        void aliasRemoved(const QString& alias);

        void doneUnlockCollection(bool accepted);

    public:
        DBusResult setProperties(const QVariantMap& properties);

        bool isValid() const
        {
            return backend();
        }

        DBusResult removeAlias(QString alias);
        DBusResult addAlias(QString alias);
        const QSet<QString> aliases() const;

        /**
         * A human readable name of the collection, available even if the db is locked
         * @return
         */
        QString name() const;

        Group* exposedRootGroup() const;
        DatabaseWidget* backend() const;
        QString backendFilePath() const;
        Service* service() const;
        bool inRecycleBin(Group* group) const;
        bool inRecycleBin(Entry* entry) const;

        static EntrySearcher::SearchTerm attributeToTerm(const QString& key, const QString& value);

    public slots:
        // expose some methods for Prompt to use

        bool doLock();
        // actually only closes database tab in KPXC
        bool doDelete();
        // Async, finish signal doneUnlockCollection
        void doUnlock();

        bool doDeleteEntry(Entry* entry);
        Item* doNewItem(const DBusClientPtr& client, QString itemPath);

        // Only delete from dbus, will remove self. Do not affect database in KPXC
        void removeFromDBus();

        // force reload info from backend, potentially delete self
        bool reloadBackend();

    private slots:
        void onDatabaseLockChanged();
        void onDatabaseExposedGroupChanged();

        // calls reloadBackend, delete self when error
        void reloadBackendOrDelete();

    private:
        friend class DeleteCollectionPrompt;
        friend class CreateCollectionPrompt;

        void onEntryAdded(Entry* entry, bool emitSignal);
        void populateContents();
        void connectGroupSignalRecursive(Group* group);
        void cleanupConnections();

        bool backendLocked() const;

        /**
         * Check if the backend is a valid object, send error reply if not.
         * @return true if the backend is valid.
         */
        DBusResult ensureBackend() const;

        /**
         * Ensure the database is unlocked, send error reply if locked.
         * @return true if the database is locked
         */
        DBusResult ensureUnlocked() const;

        /**
         * Like mkdir -p, find or create the group by path, under m_exposedGroup
         * @param groupPath
         * @return created or found group
         */
        Group* findCreateGroupByPath(const QString& groupPath);

    private:
        QPointer<DatabaseWidget> m_backend;
        QString m_backendPath;
        QPointer<Group> m_exposedGroup;

        QSet<QString> m_aliases;
        QList<Item*> m_items;
        QMap<const Entry*, Item*> m_entryToItem;
    };",1,334 2000 58 439 2001 123 2002 2003 40 648 44 2004 41 376 2000 40 2005 42 2006 44 2007 42 2008 41 59 439 58 618 457 2000 42 2009 40 2005 42 2006 44 2007 42 2008 41 59 2010 2011 2012 2013 40 2014 60 2015 42 62 38 2013 41 341 59 2010 2011 2012 2016 40 2017 38 2016 41 341 59 2010 2012 2018 40 341 2017 38 2016 41 59 2010 2011 2012 2019 40 323 38 2019 41 341 59 2010 2011 2012 2020 40 2021 38 2020 41 341 59 2010 2011 2012 2022 40 2021 38 2022 41 341 59 2010 2012 2023 40 2024 42 38 2025 41 59 2010 2012 2026 40 341 2027 38 2028 44 341 2029 38 2030 44 2014 60 2015 42 62 38 2013 41 59 2010 2012 2031 40 341 2032 38 2033 44 341 2034 38 2035 44 323 2036 44 2015 42 38 2037 44 2024 42 38 2025 41 59 2038 58 492 2039 40 2015 42 2037 41 59 492 2040 40 2015 42 2037 41 59 492 2041 40 2015 42 2037 41 59 492 2042 40 41 59 492 2043 40 41 59 492 2044 40 323 2045 41 59 492 2046 40 341 2017 38 2047 41 59 492 2048 40 341 2017 38 2047 41 59 492 2049 40 341 2017 38 2047 41 59 492 2050 40 323 2051 41 59 439 58 2012 2052 40 341 2032 38 2033 41 59 323 2053 40 41 341 123 450 2008 40 41 59 125 2012 2054 40 2017 2047 41 59 2012 2055 40 2017 2047 41 59 341 2056 60 2017 62 2057 40 41 341 59 618 2017 2058 40 41 341 59 2059 42 2060 40 41 341 59 2007 42 2008 40 41 341 59 2017 2061 40 41 341 59 2005 42 2062 40 41 341 59 323 2063 40 2059 42 2064 41 341 59 323 2063 40 2065 42 2066 41 341 59 457 2067 646 2068 2069 40 341 2017 38 2070 44 341 2017 38 2071 41 59 439 2072 58 621 323 2073 40 41 59 621 323 2074 40 41 59 621 492 2075 40 41 59 323 2076 40 2065 42 2066 41 59 2015 42 2077 40 341 2027 38 2028 44 2017 2078 41 59 621 492 2079 40 41 59 621 323 2080 40 41 59 437 2072 58 492 2081 40 41 59 492 2082 40 41 59 621 492 2083 40 41 59 437 58 387 334 2084 59 387 334 2085 59 492 2086 40 2065 42 2066 44 323 2087 41 59 492 2088 40 41 59 492 2089 40 2059 42 2064 41 59 492 2090 40 41 59 323 2091 40 41 341 59 618 2012 2092 40 41 341 59 618 2012 2093 40 41 341 59 618 2059 42 2094 40 341 2017 38 2095 41 59 437 58 2096 60 2007 62 2097 59 2017 2098 59 2096 60 2059 62 2099 59 2056 60 2017 62 2100 59 2014 60 2015 42 62 2101 59 2102 60 341 2065 42 44 2015 42 62 2103 59 125 59 
101948,C++,"class TestBrowser : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase();
    void init();

    void testChangePublicKeys();
    void testEncryptMessage();
    void testDecryptMessage();
    void testGetBase64FromKey();
    void testIncrementNonce();

    void testTopLevelDomain();
    void testIsIpAddress();
    void testSortPriority();
    void testSortPriority_data();
    void testSearchEntries();
    void testSearchEntriesByPath();
    void testSearchEntriesByUUID();
    void testSearchEntriesWithPort();
    void testSearchEntriesWithAdditionalURLs();
    void testInvalidEntries();
    void testSubdomainsAndPaths();
    void testValidURLs();
    void testBestMatchingCredentials();
    void testBestMatchingWithAdditionalURLs();

private:
    QList<Entry*> createEntries(QStringList& urls, Group* root) const;
    void compareEntriesByPath(QSharedPointer<Database> db, QList<Entry*> entries, QString path);

    QScopedPointer<BrowserAction> m_browserAction;
    QPointer<BrowserService> m_browserService;
};",1,334 2000 58 439 2001 123 2002 437 2003 58 492 2004 40 41 59 492 2005 40 41 59 492 2006 40 41 59 492 2007 40 41 59 492 2008 40 41 59 492 2009 40 41 59 492 2010 40 41 59 492 2011 40 41 59 492 2012 40 41 59 492 2013 40 41 59 492 2014 40 41 59 492 2015 40 41 59 492 2016 40 41 59 492 2017 40 41 59 492 2018 40 41 59 492 2019 40 41 59 492 2020 40 41 59 492 2021 40 41 59 492 2022 40 41 59 492 2023 40 41 59 492 2024 40 41 59 437 58 2025 60 2026 42 62 2027 40 2028 38 2029 44 2030 42 2031 41 341 59 492 2032 40 2033 60 2034 62 2035 44 2025 60 2026 42 62 2036 44 2037 2038 41 59 2039 60 2040 62 2041 59 2042 60 2043 62 2044 59 125 59 
102128,C++,"class BrowserAction
{
public:
    explicit BrowserAction();
    ~BrowserAction() = default;

    QJsonObject processClientMessage(const QJsonObject& json);

private:
    QJsonObject handleAction(const QJsonObject& json);
    QJsonObject handleChangePublicKeys(const QJsonObject& json, const QString& action);
    QJsonObject handleGetDatabaseHash(const QJsonObject& json, const QString& action);
    QJsonObject handleAssociate(const QJsonObject& json, const QString& action);
    QJsonObject handleTestAssociate(const QJsonObject& json, const QString& action);
    QJsonObject handleGetLogins(const QJsonObject& json, const QString& action);
    QJsonObject handleGeneratePassword(const QJsonObject& json, const QString& action);
    QJsonObject handleSetLogin(const QJsonObject& json, const QString& action);
    QJsonObject handleLockDatabase(const QJsonObject& json, const QString& action);
    QJsonObject handleGetDatabaseGroups(const QJsonObject& json, const QString& action);
    QJsonObject handleCreateNewGroup(const QJsonObject& json, const QString& action);
    QJsonObject handleGetTotp(const QJsonObject& json, const QString& action);
    QJsonObject handleDeleteEntry(const QJsonObject& json, const QString& action);
    QJsonObject handleGlobalAutoType(const QJsonObject& json, const QString& action);

    QJsonObject buildMessage(const QString& nonce) const;
    QJsonObject buildResponse(const QString& action, const QJsonObject& message, const QString& nonce);
    QJsonObject getErrorReply(const QString& action, const int errorCode) const;
    QString getErrorMessage(const int errorCode) const;

    QString encryptMessage(const QJsonObject& message, const QString& nonce);
    QJsonObject decryptMessage(const QString& message, const QString& nonce);
    QString encrypt(const QString& plaintext, const QString& nonce);
    QByteArray decrypt(const QString& encrypted, const QString& nonce);

    QString getBase64FromKey(const uchar* array, const uint len);
    QByteArray getQByteArray(const uchar* array, const uint len) const;
    QJsonObject getJsonObject(const uchar* pArray, const uint len) const;
    QJsonObject getJsonObject(const QByteArray& ba) const;
    QByteArray base64Decode(const QString& str);
    QString incrementNonce(const QString& nonce);

private:
    static const int MaxUrlLength;

    QString m_clientPublicKey;
    QString m_publicKey;
    QString m_secretKey;
    bool m_associated = false;

    friend class TestBrowser;
};",1,334 2000 123 439 58 376 2000 40 41 59 126 2000 40 41 61 349 59 2001 2002 40 341 2001 38 2003 41 59 437 58 2001 2004 40 341 2001 38 2003 41 59 2001 2005 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2008 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2009 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2010 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2011 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2012 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2013 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2014 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2015 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2016 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2017 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2018 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2019 40 341 2001 38 2003 44 341 2006 38 2007 41 59 2001 2020 40 341 2006 38 2021 41 341 59 2001 2022 40 341 2006 38 2007 44 341 2001 38 2023 44 341 2006 38 2021 41 59 2001 2024 40 341 2006 38 2007 44 341 404 2025 41 341 59 2006 2026 40 341 404 2025 41 341 59 2006 2027 40 341 2001 38 2023 44 341 2006 38 2021 41 59 2001 2028 40 341 2006 38 2023 44 341 2006 38 2021 41 59 2006 2029 40 341 2006 38 2030 44 341 2006 38 2021 41 59 2031 2032 40 341 2006 38 2033 44 341 2006 38 2021 41 59 2006 2034 40 341 2035 42 310 44 341 479 2036 41 59 2031 2037 40 341 2035 42 310 44 341 479 2036 41 341 59 2001 2038 40 341 2035 42 2039 44 341 479 2036 41 341 59 2001 2038 40 341 2031 38 2040 41 341 59 2031 2041 40 341 2006 38 2042 41 59 2006 2043 40 341 2006 38 2021 41 59 437 58 457 341 404 2044 59 2006 2045 59 2006 2046 59 2006 2047 59 323 2048 61 380 59 387 334 2049 59 125 59 
