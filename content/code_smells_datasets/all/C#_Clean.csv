id,language,text,smell,tokens
79760,C#,"    public class MerkleTree
    {
        private readonly MerkleTreeNode root;

        /// <summary>
        /// The depth of the tree.
        /// </summary>
        public int Depth { get; }

        internal MerkleTree(UInt256[] hashes)
        {
            this.root = Build(hashes.Select(p => new MerkleTreeNode { Hash = p }).ToArray());
            if (root is null) return;
            int depth = 1;
            for (MerkleTreeNode i = root; i.LeftChild != null; i = i.LeftChild)
                depth++;
            this.Depth = depth;
        }

        private static MerkleTreeNode Build(MerkleTreeNode[] leaves)
        {
            if (leaves.Length == 0) return null;
            if (leaves.Length == 1) return leaves[0];

            Span<byte> buffer = stackalloc byte[64];
            MerkleTreeNode[] parents = new MerkleTreeNode[(leaves.Length + 1) / 2];
            for (int i = 0; i < parents.Length; i++)
            {
                parents[i] = new MerkleTreeNode
                {
                    LeftChild = leaves[i * 2]
                };
                leaves[i * 2].Parent = parents[i];
                if (i * 2 + 1 == leaves.Length)
                {
                    parents[i].RightChild = parents[i].LeftChild;
                }
                else
                {
                    parents[i].RightChild = leaves[i * 2 + 1];
                    leaves[i * 2 + 1].Parent = parents[i];
                }
                parents[i].Hash = Concat(buffer, parents[i].LeftChild.Hash, parents[i].RightChild.Hash);
            }
            return Build(parents); //TailCall
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static UInt256 Concat(Span<byte> buffer, UInt256 hash1, UInt256 hash2)
        {
            hash1.ToArray().CopyTo(buffer);
            hash2.ToArray().CopyTo(buffer[32..]);

            return new UInt256(Crypto.Hash256(buffer));
        }

        /// <summary>
        /// Computes the root of the hash tree.
        /// </summary>
        /// <param name=""hashes"">The leaves of the hash tree.</param>
        /// <returns>The root of the hash tree.</returns>
        public static UInt256 ComputeRoot(UInt256[] hashes)
        {
            if (hashes.Length == 0) return UInt256.Zero;
            if (hashes.Length == 1) return hashes[0];
            MerkleTree tree = new(hashes);
            return tree.root.Hash;
        }

        private static void DepthFirstSearch(MerkleTreeNode node, IList<UInt256> hashes)
        {
            if (node.LeftChild == null)
            {
                // if left is null, then right must be null
                hashes.Add(node.Hash);
            }
            else
            {
                DepthFirstSearch(node.LeftChild, hashes);
                DepthFirstSearch(node.RightChild, hashes);
            }
        }

        /// <summary>
        /// Gets all nodes of the hash tree in depth-first order.
        /// </summary>
        /// <returns>All nodes of the hash tree.</returns>
        public UInt256[] ToHashArray()
        {
            if (root is null) return Array.Empty<UInt256>();
            List<UInt256> hashes = new();
            DepthFirstSearch(root, hashes);
            return hashes.ToArray();
        }

        /// <summary>
        /// Trims the hash tree using the specified bit array.
        /// </summary>
        /// <param name=""flags"">The bit array to be used.</param>
        public void Trim(BitArray flags)
        {
            if (root is null) return;
            flags = new BitArray(flags)
            {
                Length = 1 << (Depth - 1)
            };
            Trim(root, 0, Depth, flags);
        }

        private static void Trim(MerkleTreeNode node, int index, int depth, BitArray flags)
        {
            if (depth == 1) return;
            if (node.LeftChild == null) return; // if left is null, then right must be null
            if (depth == 2)
            {
                if (!flags.Get(index * 2) && !flags.Get(index * 2 + 1))
                {
                    node.LeftChild = null;
                    node.RightChild = null;
                }
            }
            else
            {
                Trim(node.LeftChild, index * 2, depth - 1, flags);
                Trim(node.RightChild, index * 2 + 1, depth - 1, flags);
                if (node.LeftChild.LeftChild == null && node.RightChild.RightChild == null)
                {
                    node.LeftChild = null;
                    node.RightChild = null;
                }
            }
        }
    }",0,439 334 2000 123 437 441 2001 2002 59 612 439 404 2003 123 2004 59 125 406 2000 40 2005 91 93 2006 41 123 467 46 2002 61 2007 40 2006 46 2008 40 2009 619 418 2001 123 2010 61 2009 125 41 46 2011 40 41 41 59 392 40 2002 407 424 41 450 59 404 2012 61 1501 59 385 40 2001 2013 61 2002 59 2013 46 2014 631 424 59 2013 61 2013 46 2014 41 2012 637 59 467 46 2003 61 2012 59 125 437 457 2001 2015 40 2001 91 93 2016 41 123 392 40 2016 46 2017 614 1500 41 450 424 59 392 40 2016 46 2017 614 1501 41 450 2016 91 1500 93 59 2018 60 326 62 2019 61 456 326 91 1503 93 59 2001 91 93 2020 61 418 2001 91 40 2016 46 2017 43 1501 41 47 1502 93 59 385 40 404 2021 61 1500 59 2021 60 2020 46 2017 59 2021 637 41 123 2020 91 2021 93 61 418 2001 123 2022 61 2016 91 2021 42 1502 93 125 59 2016 91 2021 42 1502 93 46 2023 61 2020 91 2021 93 59 392 40 2021 42 1502 43 1501 614 2016 46 2017 41 123 2020 91 2021 93 46 2024 61 2020 91 2021 93 46 2025 59 125 360 123 2020 91 2021 93 46 2026 61 2016 91 2021 42 1502 43 1501 93 59 2016 91 2021 42 1502 43 1501 93 46 2023 61 2020 91 2021 93 59 125 2020 91 2021 93 46 2027 61 2028 40 2019 44 2020 91 2021 93 46 2029 46 2027 44 2020 91 2021 93 46 2030 46 2027 41 59 125 450 2015 40 2020 41 59 621 125 91 2031 40 2032 46 2033 41 93 437 457 2005 2034 40 2035 60 326 62 2036 44 2005 2037 44 2005 2038 41 123 2037 46 2039 40 41 46 2040 40 2036 41 59 2038 46 2039 40 41 46 2040 40 2036 91 1503 93 41 59 450 418 2005 40 2041 46 2042 40 2036 41 41 59 125 612 439 457 2005 2043 40 2005 91 93 2006 41 123 392 40 2006 46 2044 614 1500 41 450 2005 46 2045 59 392 40 2006 46 2044 614 1501 41 450 2006 91 1500 93 59 2000 2046 61 418 40 2006 41 59 450 2046 46 2002 46 2047 59 125 437 457 492 2048 40 2001 2049 44 2050 60 2005 62 2006 41 123 392 40 2049 46 2051 614 424 41 123 621 2006 46 2052 40 2049 46 2053 41 59 125 360 123 2048 40 2049 46 2051 44 2006 41 59 2048 40 2049 46 2054 44 2006 41 59 125 125 612 439 2005 91 93 2055 40 41 123 392 40 2002 407 424 41 450 2056 46 2057 60 2005 62 40 41 59 2058 60 2005 62 2006 61 418 40 41 59 2048 40 2002 44 2006 41 59 450 2006 46 2059 40 41 59 125 612 439 492 2060 40 2061 2062 41 123 392 40 2002 407 424 41 450 59 2062 61 418 2061 40 2062 41 123 2063 61 1501 622 40 2003 45 1501 41 125 59 2060 40 2002 44 1500 44 2003 44 2062 41 59 125 437 457 492 2060 40 2001 2049 44 404 2064 44 404 2065 44 2061 2062 41 123 392 40 2065 614 1501 41 450 59 392 40 2049 46 2066 614 424 41 450 59 621 392 40 2065 614 1502 41 123 392 40 33 2062 46 2067 40 2064 42 1502 41 605 33 2062 46 2067 40 2064 42 1502 43 1501 41 41 123 2049 46 2066 61 424 59 2049 46 2068 61 424 59 125 125 360 123 2060 40 2049 46 2066 44 2064 42 1502 44 2065 45 1501 44 2062 41 59 2060 40 2049 46 2069 44 2064 42 1502 43 1501 44 2065 45 1501 44 2062 41 59 392 40 2049 46 2066 46 2066 614 424 605 2049 46 2069 46 2069 614 424 41 123 2049 46 2066 61 424 59 2049 46 2069 61 424 59 125 125 125 125 
79807,C#,"    public sealed class Block : IEquatable<Block>, IInventory
    {
        /// <summary>
        /// The header of the block.
        /// </summary>
        public Header Header;

        /// <summary>
        /// The transaction list of the block.
        /// </summary>
        public Transaction[] Transactions;

        public UInt256 Hash => Header.Hash;

        /// <summary>
        /// The version of the block.
        /// </summary>
        public uint Version => Header.Version;

        /// <summary>
        /// The hash of the previous block.
        /// </summary>
        public UInt256 PrevHash => Header.PrevHash;

        /// <summary>
        /// The merkle root of the transactions.
        /// </summary>
        public UInt256 MerkleRoot => Header.MerkleRoot;

        /// <summary>
        /// The timestamp of the block.
        /// </summary>
        public ulong Timestamp => Header.Timestamp;

        /// <summary>
        /// The random number of the block.
        /// </summary>
        public ulong Nonce => Header.Nonce;

        /// <summary>
        /// The index of the block.
        /// </summary>
        public uint Index => Header.Index;

        /// <summary>
        /// The primary index of the consensus node that generated this block.
        /// </summary>
        public byte PrimaryIndex => Header.PrimaryIndex;

        /// <summary>
        /// The multi-signature address of the consensus nodes that generates the next block.
        /// </summary>
        public UInt160 NextConsensus => Header.NextConsensus;

        /// <summary>
        /// The witness of the block.
        /// </summary>
        public Witness Witness => Header.Witness;

        InventoryType IInventory.InventoryType => InventoryType.Block;
        public int Size => Header.Size + Transactions.GetVarSize();
        Witness[] IVerifiable.Witnesses { get => ((IVerifiable)Header).Witnesses; set => throw new NotSupportedException(); }

        public void Deserialize(BinaryReader reader)
        {
            Header = reader.ReadSerializable<Header>();
            Transactions = reader.ReadSerializableArray<Transaction>(ushort.MaxValue);
            if (Transactions.Distinct().Count() != Transactions.Length)
                throw new FormatException();
            if (MerkleTree.ComputeRoot(Transactions.Select(p => p.Hash).ToArray()) != Header.MerkleRoot)
                throw new FormatException();
        }

        void IVerifiable.DeserializeUnsigned(BinaryReader reader) => throw new NotSupportedException();

        public bool Equals(Block other)
        {
            if (ReferenceEquals(this, other)) return true;
            if (other is null) return false;
            return Hash.Equals(other.Hash);
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as Block);
        }

        public override int GetHashCode()
        {
            return Hash.GetHashCode();
        }

        UInt160[] IVerifiable.GetScriptHashesForVerifying(DataCache snapshot) => ((IVerifiable)Header).GetScriptHashesForVerifying(snapshot);

        public void Serialize(BinaryWriter writer)
        {
            writer.Write(Header);
            writer.Write(Transactions);
        }

        void IVerifiable.SerializeUnsigned(BinaryWriter writer) => ((IVerifiable)Header).SerializeUnsigned(writer);

        /// <summary>
        /// Converts the block to a JSON object.
        /// </summary>
        /// <param name=""settings"">The <see cref=""ProtocolSettings""/> used during the conversion.</param>
        /// <returns>The block represented by a JSON object.</returns>
        public JObject ToJson(ProtocolSettings settings)
        {
            JObject json = Header.ToJson(settings);
            json[""size""] = Size;
            json[""tx""] = Transactions.Select(p => p.ToJson(settings)).ToArray();
            return json;
        }

        internal bool Verify(ProtocolSettings settings, DataCache snapshot)
        {
            return Header.Verify(settings, snapshot);
        }

        internal bool Verify(ProtocolSettings settings, DataCache snapshot, HeaderCache headerCache)
        {
            return Header.Verify(settings, snapshot, headerCache);
        }
    }",0,439 452 334 2000 58 2001 60 2000 62 44 2002 123 612 439 2003 2003 59 612 439 2004 91 93 2005 59 439 2006 2007 619 2003 46 2007 59 612 439 479 2008 619 2003 46 2008 59 612 439 2006 2009 619 2003 46 2009 59 612 439 2006 2010 619 2003 46 2010 59 612 439 480 2011 619 2003 46 2011 59 612 439 480 2012 619 2003 46 2012 59 612 439 479 2013 619 2003 46 2013 59 612 439 326 2014 619 2003 46 2014 59 612 439 2015 2016 619 2003 46 2016 59 612 439 2017 2017 619 2003 46 2017 59 2018 2002 46 2018 619 2018 46 2000 59 439 404 2019 619 2003 46 2019 43 2005 46 2020 40 41 59 2017 91 93 2021 46 2022 123 2023 619 40 40 2021 41 2003 41 46 2022 59 2024 619 469 418 2025 40 41 59 125 439 492 2026 40 2027 2028 41 123 2003 61 2028 46 2029 60 2003 62 40 41 59 2005 61 2028 46 2030 60 2004 62 40 488 46 2031 41 59 392 40 2005 46 2032 40 41 46 2033 40 41 631 2005 46 2034 41 469 418 2035 40 41 59 392 40 2036 46 2037 40 2005 46 2038 40 2039 619 2039 46 2007 41 46 2040 40 41 41 631 2003 46 2010 41 469 418 2035 40 41 59 125 492 2021 46 2041 40 2027 2028 41 619 469 418 2042 40 41 59 439 323 2043 40 2000 2044 41 123 392 40 2045 40 467 44 2044 41 41 450 473 59 392 40 2044 407 424 41 450 380 59 450 2007 46 2043 40 2044 46 2007 41 59 125 439 431 323 2043 40 426 2046 41 123 450 2043 40 2046 311 2000 41 59 125 439 431 404 2047 40 41 123 450 2007 46 2047 40 41 59 125 2015 91 93 2021 46 2048 40 2049 2050 41 619 40 40 2021 41 2003 41 46 2048 40 2050 41 59 439 492 2051 40 2052 2053 41 123 2053 46 2054 40 2003 41 59 2053 46 2054 40 2005 41 59 125 492 2021 46 2055 40 2052 2053 41 619 40 40 2021 41 2003 41 46 2055 40 2053 41 59 612 439 2056 2057 40 2058 2059 41 123 2056 2060 61 2003 46 2057 40 2059 41 59 2060 91 648 93 61 2019 59 2060 91 648 93 61 2005 46 2061 40 2062 619 2062 46 2057 40 2059 41 41 46 2063 40 41 59 450 2060 59 125 406 323 2064 40 2058 2059 44 2049 2050 41 123 450 2003 46 2064 40 2059 44 2050 41 59 125 406 323 2064 40 2058 2059 44 2049 2050 44 2065 2066 41 123 450 2003 46 2064 40 2059 44 2050 44 2066 41 59 125 125 
79824,C#,"    public class LocalNode : Peer
    {
        /// <summary>
        /// Sent to <see cref=""LocalNode""/> to relay an <see cref=""IInventory""/>.
        /// </summary>
        public class RelayDirectly { public IInventory Inventory; }

        /// <summary>
        /// Sent to <see cref=""LocalNode""/> to send an <see cref=""IInventory""/>.
        /// </summary>
        public class SendDirectly { public IInventory Inventory; }

        /// <summary>
        /// Sent to <see cref=""LocalNode""/> to request for an instance of <see cref=""LocalNode""/>.
        /// </summary>
        public class GetInstance { }

        /// <summary>
        /// Indicates the protocol version of the local node.
        /// </summary>
        public const uint ProtocolVersion = 0;

        private const int MaxCountFromSeedList = 5;
        private readonly IPEndPoint[] SeedList;

        private readonly NeoSystem system;
        internal readonly ConcurrentDictionary<IActorRef, RemoteNode> RemoteNodes = new();

        /// <summary>
        /// Indicates the number of connected nodes.
        /// </summary>
        public int ConnectedCount => RemoteNodes.Count;

        /// <summary>
        /// Indicates the number of unconnected nodes. When the number of connections is not enough, it will automatically connect to these nodes.
        /// </summary>
        public int UnconnectedCount => UnconnectedPeers.Count;

        /// <summary>
        /// The random number used to identify the local node.
        /// </summary>
        public static readonly uint Nonce;

        /// <summary>
        /// The identifier of the client software of the local node.
        /// </summary>
        public static string UserAgent { get; set; }

        static LocalNode()
        {
            Random rand = new();
            Nonce = (uint)rand.Next();
            UserAgent = $""/{Assembly.GetExecutingAssembly().GetName().Name}:{Assembly.GetExecutingAssembly().GetVersion()}/"";
        }

        /// <summary>
        /// Initializes a new instance of the <see cref=""LocalNode""/> class.
        /// </summary>
        /// <param name=""system"">The <see cref=""NeoSystem""/> object that contains the <see cref=""LocalNode""/>.</param>
        public LocalNode(NeoSystem system)
        {
            this.system = system;
            this.SeedList = new IPEndPoint[system.Settings.SeedList.Length];

            // Start dns resolution in parallel
            string[] seedList = system.Settings.SeedList;
            for (int i = 0; i < seedList.Length; i++)
            {
                int index = i;
                Task.Run(() => SeedList[index] = GetIpEndPoint(seedList[index]));
            }
        }

        /// <summary>
        /// Packs a MessageCommand to a full Message with an optional ISerializable payload.
        /// Forwards it to <see cref=""BroadcastMessage(Message)""/>.
        /// </summary>
        /// <param name=""command"">The message command to be packed.</param>
        /// <param name=""payload"">Optional payload to be Serialized along the message.</param>
        private void BroadcastMessage(MessageCommand command, ISerializable payload = null)
        {
            BroadcastMessage(Message.Create(command, payload));
        }

        /// <summary>
        /// Broadcast a message to all connected nodes.
        /// </summary>
        /// <param name=""message"">The message to be broadcasted.</param>
        private void BroadcastMessage(Message message) => SendToRemoteNodes(message);

        /// <summary>
        /// Send message to all the RemoteNodes connected to other nodes, faster than ActorSelection.
        /// </summary>
        private void SendToRemoteNodes(object message)
        {
            foreach (var connection in RemoteNodes.Keys)
            {
                connection.Tell(message);
            }
        }

        private static IPEndPoint GetIPEndpointFromHostPort(string hostNameOrAddress, int port)
        {
            if (IPAddress.TryParse(hostNameOrAddress, out IPAddress ipAddress))
                return new IPEndPoint(ipAddress, port);
            IPHostEntry entry;
            try
            {
                entry = Dns.GetHostEntry(hostNameOrAddress);
            }
            catch (SocketException)
            {
                return null;
            }
            ipAddress = entry.AddressList.FirstOrDefault(p => p.AddressFamily == AddressFamily.InterNetwork || p.IsIPv6Teredo);
            if (ipAddress == null) return null;
            return new IPEndPoint(ipAddress, port);
        }

        internal static IPEndPoint GetIpEndPoint(string hostAndPort)
        {
            if (string.IsNullOrEmpty(hostAndPort)) return null;

            try
            {
                string[] p = hostAndPort.Split(':');
                return GetIPEndpointFromHostPort(p[0], int.Parse(p[1]));
            }
            catch { }

            return null;
        }

        /// <summary>
        /// Checks the new connection.
        /// If it is equal to the nonce of local or any remote node, it'll return false, else we'll return true and update the Listener address of the connected remote node.
        /// </summary>
        /// <param name=""actor"">Remote node actor.</param>
        /// <param name=""node"">Remote node object.</param>
        /// <returns><see langword=""true""/> if the new connection is allowed; otherwise, <see langword=""false""/>.</returns>
        public bool AllowNewConnection(IActorRef actor, RemoteNode node)
        {
            if (node.Version.Network != system.Settings.Network) return false;
            if (node.Version.Nonce == Nonce) return false;

            // filter duplicate connections
            foreach (var other in RemoteNodes.Values)
                if (other != node && other.Remote.Address.Equals(node.Remote.Address) && other.Version?.Nonce == node.Version.Nonce)
                    return false;

            if (node.Remote.Port != node.ListenerTcpPort && node.ListenerTcpPort != 0)
                ConnectedPeers.TryUpdate(actor, node.Listener, node.Remote);

            return true;
        }

        /// <summary>
        /// Gets the connected remote nodes.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<RemoteNode> GetRemoteNodes()
        {
            return RemoteNodes.Values;
        }

        /// <summary>
        /// Gets the unconnected nodes.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<IPEndPoint> GetUnconnectedPeers()
        {
            return UnconnectedPeers;
        }

        /// <summary>
        /// Performs a broadcast with the command <see cref=""MessageCommand.GetAddr""/>, which, eventually, tells all known connections.
        /// If there are no connected peers it will try with the default, respecting <see cref=""MaxCountFromSeedList""/> limit.
        /// </summary>
        /// <param name=""count"">Number of peers that are being requested.</param>
        protected override void NeedMorePeers(int count)
        {
            count = Math.Max(count, MaxCountFromSeedList);
            if (!ConnectedPeers.IsEmpty)
            {
                BroadcastMessage(MessageCommand.GetAddr);
            }
            else
            {
                // Will call AddPeers with default SeedList set cached on <see cref=""ProtocolSettings""/>.
                // It will try to add those, sequentially, to the list of currently unconnected ones.

                Random rand = new();
                AddPeers(SeedList.Where(u => u != null).OrderBy(p => rand.Next()).Take(count));
            }
        }

        protected override void OnReceive(object message)
        {
            base.OnReceive(message);
            switch (message)
            {
                case Message msg:
                    BroadcastMessage(msg);
                    break;
                case RelayDirectly relay:
                    OnRelayDirectly(relay.Inventory);
                    break;
                case SendDirectly send:
                    OnSendDirectly(send.Inventory);
                    break;
                case GetInstance _:
                    Sender.Tell(this);
                    break;
            }
        }

        private void OnRelayDirectly(IInventory inventory)
        {
            var message = new RemoteNode.Relay { Inventory = inventory };
            // When relaying a block, if the block's index is greater than 'LastBlockIndex' of the RemoteNode, relay the block;
            // otherwise, don't relay.
            if (inventory is Block block)
            {
                foreach (KeyValuePair<IActorRef, RemoteNode> kvp in RemoteNodes)
                {
                    if (block.Index > kvp.Value.LastBlockIndex)
                        kvp.Key.Tell(message);
                }
            }
            else
                SendToRemoteNodes(message);
        }

        private void OnSendDirectly(IInventory inventory) => SendToRemoteNodes(inventory);

        protected override void OnTcpConnected(IActorRef connection)
        {
            connection.Tell(new RemoteNode.StartProtocol());
        }

        /// <summary>
        /// Gets a <see cref=""Akka.Actor.Props""/> object used for creating the <see cref=""LocalNode""/> actor.
        /// </summary>
        /// <param name=""system"">The <see cref=""NeoSystem""/> object that contains the <see cref=""LocalNode""/>.</param>
        /// <returns>The <see cref=""Akka.Actor.Props""/> object used for creating the <see cref=""LocalNode""/> actor.</returns>
        public static Props Props(NeoSystem system)
        {
            return Akka.Actor.Props.Create(() => new LocalNode(system));
        }

        protected override Props ProtocolProps(object connection, IPEndPoint remote, IPEndPoint local)
        {
            return RemoteNode.Props(system, this, connection, remote, local);
        }
    }",0,439 334 2000 58 2001 123 612 439 334 2002 123 439 2003 2004 59 125 612 439 334 2005 123 439 2006 2007 59 125 612 439 334 2008 123 125 612 439 341 479 2009 61 1500 59 437 341 404 2010 61 1502 59 437 441 2011 91 93 2012 59 437 441 2013 2014 59 406 441 2015 60 2016 44 2017 62 2018 61 418 40 41 59 612 439 404 2019 619 2018 46 2020 59 612 439 404 2021 619 2022 46 2020 59 612 439 457 441 479 2023 59 612 439 457 461 2024 123 2025 59 2026 59 125 457 2000 40 41 123 2027 2028 61 418 40 41 59 2023 61 40 479 41 2028 46 2029 40 41 59 2024 61 36 648 59 125 612 439 2000 40 2013 2014 41 123 467 46 2014 61 2014 59 467 46 2012 61 418 2011 91 2014 46 2030 46 2012 46 2031 93 59 621 461 91 93 2032 61 2014 46 2030 46 2012 59 385 40 404 2033 61 1500 59 2033 60 2032 46 2031 59 2033 637 41 123 404 2034 61 2033 59 2035 46 2036 40 40 41 619 2012 91 2034 93 61 2037 40 2032 91 2034 93 41 41 59 125 125 612 437 492 2038 40 2039 2040 44 2041 2042 61 424 41 123 2038 40 2043 46 2044 40 2040 44 2042 41 41 59 125 612 437 492 2038 40 2045 2046 41 619 2047 40 2046 41 59 612 437 492 2047 40 426 2046 41 123 386 40 490 2048 398 2018 46 2049 41 123 2048 46 2050 40 2046 41 59 125 125 437 457 2011 2051 40 461 2052 44 404 2053 41 123 392 40 2054 46 2055 40 2052 44 430 2054 2056 41 41 450 418 2011 40 2056 44 2053 41 59 2057 2058 59 474 123 2058 61 2059 46 2060 40 2052 41 59 125 329 40 2061 41 123 450 424 59 125 2056 61 2058 46 2062 46 2063 40 2064 619 2064 46 2065 614 2065 46 2066 606 2064 46 2067 41 59 392 40 2056 614 424 41 450 424 59 450 418 2011 40 2056 44 2053 41 59 125 406 457 2011 2068 40 461 2069 41 123 392 40 461 46 2070 40 2069 41 41 450 424 59 474 123 461 91 93 2071 61 2069 46 2072 40 607 41 59 450 2051 40 2071 91 1500 93 44 404 46 2073 40 2071 91 1501 93 41 41 59 125 329 123 125 450 424 59 125 612 439 323 2074 40 2016 2075 44 2017 2076 41 123 392 40 2076 46 2077 46 2078 631 2014 46 2079 46 2078 41 450 380 59 392 40 2076 46 2077 46 2023 614 2023 41 450 380 59 621 386 40 490 2080 398 2018 46 2081 41 392 40 2080 631 2076 605 2080 46 2082 46 2083 46 2084 40 2076 46 2082 46 2083 41 605 2080 46 2077 634 2023 614 2076 46 2077 46 2023 41 450 380 59 392 40 2076 46 2082 46 2085 631 2076 46 2086 605 2076 46 2086 631 1500 41 2087 46 2088 40 2075 44 2076 46 2089 44 2076 46 2082 41 59 450 473 59 125 612 439 2090 60 2017 62 2091 40 41 123 450 2018 46 2092 59 125 612 439 2090 60 2011 62 2093 40 41 123 450 2022 59 125 612 438 431 492 2094 40 404 2095 41 123 2095 61 2096 46 2097 40 2095 44 2010 41 59 392 40 33 2098 46 2099 41 123 2038 40 2039 46 2100 41 59 125 360 123 621 621 2101 2102 61 418 40 41 59 2103 40 2012 46 2104 40 2105 619 2105 631 424 41 46 2106 40 2107 619 2102 46 2108 40 41 41 46 2109 40 2095 41 41 59 125 125 438 431 492 2110 40 426 2046 41 123 320 46 2110 40 2046 41 59 464 40 2046 41 123 328 2045 2111 58 2038 40 2111 41 59 325 59 328 2002 2112 58 2113 40 2112 46 2114 41 59 325 59 328 2005 2115 58 2116 40 2115 46 2114 41 59 325 59 328 2008 2117 58 2118 46 2119 40 467 41 59 325 59 125 125 437 492 2120 40 2121 2122 41 123 490 2046 61 418 2017 46 2123 123 2124 61 2122 125 59 621 621 392 40 2122 407 2125 2126 41 123 386 40 2127 60 2016 44 2017 62 2128 398 2018 41 123 392 40 2126 46 2129 62 2128 46 2130 46 2131 41 2128 46 2132 46 2133 40 2046 41 59 125 125 360 2047 40 2046 41 59 125 437 492 2134 40 2121 2122 41 619 2047 40 2122 41 59 438 431 492 2135 40 2016 2136 41 123 2136 46 2137 40 418 2017 46 2138 40 41 41 59 125 612 439 457 2139 2139 40 2013 2014 41 123 450 2140 46 2141 46 2139 46 2142 40 40 41 619 418 2000 40 2014 41 41 59 125 438 431 2139 2143 40 426 2136 44 2011 2144 44 2011 2145 41 123 450 2017 46 2139 40 2014 44 467 44 2136 44 2144 44 2145 41 59 125 125 
79832,C#,"    internal class WalletLocker : IDisposable
    {
        private readonly NEP6Wallet wallet;

        public WalletLocker(NEP6Wallet wallet)
        {
            this.wallet = wallet;
        }

        public void Dispose()
        {
            wallet.Lock();
        }
    }",0,406 334 2000 58 2001 123 437 441 2002 2003 59 439 2000 40 2002 2003 41 123 467 46 2003 61 2003 59 125 439 492 2004 40 41 123 2003 46 2005 40 41 59 125 125 
79835,C#,"    internal abstract class PriorityMailbox : MailboxType, IProducesMessageQueue<PriorityMessageQueue>
    {
        public PriorityMailbox(Akka.Actor.Settings settings, Config config)
            : base(settings, config)
        {
        }

        public override IMessageQueue Create(IActorRef owner, ActorSystem system)
        {
            return new PriorityMessageQueue(ShallDrop, IsHighPriority);
        }

        internal protected virtual bool IsHighPriority(object message) => false;
        internal protected virtual bool ShallDrop(object message, IEnumerable queue) => false;
    }",0,406 305 334 2000 58 2001 44 2002 60 2003 62 123 439 2000 40 2004 46 2005 46 2006 2007 44 2008 2009 41 58 320 40 2007 44 2009 41 123 125 439 431 2010 2011 40 2012 2013 44 2014 2015 41 123 450 418 2003 40 2016 44 2017 41 59 125 406 438 491 323 2018 40 426 2019 41 619 380 59 406 438 491 323 2020 40 426 2019 44 2021 2022 41 619 380 59 125 
79840,C#,"    public class UT_Helper
    {
        [TestMethod]
        public void GetSignData()
        {
            TestVerifiable verifiable = new();
            byte[] res = verifiable.GetSignData(ProtocolSettings.Default.Network);
            res.ToHexString().Should().Be(""4e454f3350b51da6bb366be3ea50140cda45ba7df575287c0371000b2037ed3898ff8bf5"");
        }

        [TestMethod]
        public void Sign()
        {
            TestVerifiable verifiable = new();
            byte[] res = verifiable.Sign(new KeyPair(TestUtils.GetByteArray(32, 0x42)), ProtocolSettings.Default.Network);
            res.Length.Should().Be(64);
        }

        [TestMethod]
        public void ToScriptHash()
        {
            byte[] testByteArray = TestUtils.GetByteArray(64, 0x42);
            UInt160 res = testByteArray.ToScriptHash();
            res.Should().Be(UInt160.Parse(""2d3b96ae1bcc5a585e075e3b81920210dec16302""));
        }

        [TestMethod]
        public void TestGetLowestSetBit()
        {
            var big1 = new BigInteger(0);
            big1.GetLowestSetBit().Should().Be(-1);

            var big2 = new BigInteger(512);
            big2.GetLowestSetBit().Should().Be(9);

            var big3 = new BigInteger(int.MinValue);
            big3.GetLowestSetBit().Should().Be(31);

            var big4 = new BigInteger(long.MinValue);
            big4.GetLowestSetBit().Should().Be(63);
        }

        [TestMethod]
        public void TestHexToBytes()
        {
            string nullStr = null;
            _ = nullStr.HexToBytes().ToHexString().Should().Be(Array.Empty<byte>().ToHexString());
            string emptyStr = """";
            emptyStr.HexToBytes().ToHexString().Should().Be(Array.Empty<byte>().ToHexString());
            string str1 = ""hab"";
            Action action = () => str1.HexToBytes();
            action.Should().Throw<FormatException>();
            string str2 = ""0102"";
            byte[] bytes = str2.HexToBytes();
            bytes.ToHexString().Should().Be(new byte[] { 0x01, 0x02 }.ToHexString());
        }

        [TestMethod]
        public void TestRemoveHashsetDictionary()
        {
            var a = new HashSet<int>
            {
                1,
                2,
                3
            };

            var b = new Dictionary<int, object>
            {
                [2] = null
            };

            a.Remove(b);

            CollectionAssert.AreEqual(new int[] { 1, 3 }, a.ToArray());

            b[4] = null;
            b[5] = null;
            b[1] = null;
            a.Remove(b);

            CollectionAssert.AreEqual(new int[] { 3 }, a.ToArray());
        }

        [TestMethod]
        public void TestRemoveHashsetSet()
        {
            var a = new HashSet<int>
            {
                1,
                2,
                3
            };

            var b = new SortedSet<int>()
            {
                2
            };

            a.Remove(b);

            CollectionAssert.AreEqual(new int[] { 1, 3 }, a.ToArray());

            b.Add(4);
            b.Add(5);
            b.Add(1);
            a.Remove(b);

            CollectionAssert.AreEqual(new int[] { 3 }, a.ToArray());
        }

        [TestMethod]
        public void TestRemoveHashsetHashSetCache()
        {
            var a = new HashSet<int>
            {
                1,
                2,
                3
            };

            var b = new HashSetCache<int>(10)
            {
                2
            };

            a.Remove(b);

            CollectionAssert.AreEqual(new int[] { 1, 3 }, a.ToArray());

            b.Add(4);
            b.Add(5);
            b.Add(1);
            a.Remove(b);

            CollectionAssert.AreEqual(new int[] { 3 }, a.ToArray());
        }

        [TestMethod]
        public void TestToHexString()
        {
            byte[] nullStr = null;
            Assert.ThrowsException<NullReferenceException>(() => nullStr.ToHexString());
            byte[] empty = Array.Empty<byte>();
            empty.ToHexString().Should().Be("""");
            empty.ToHexString(false).Should().Be("""");
            empty.ToHexString(true).Should().Be("""");

            byte[] str1 = new byte[] { (byte)'n', (byte)'e', (byte)'o' };
            str1.ToHexString().Should().Be(""6e656f"");
            str1.ToHexString(false).Should().Be(""6e656f"");
            str1.ToHexString(true).Should().Be(""6f656e"");
        }

        [TestMethod]
        public void TestGetVersion()
        {
            // assembly without version

            var asm = AppDomain.CurrentDomain.GetAssemblies()
                .Where(u => u.FullName == ""Anonymously Hosted DynamicMethods Assembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null"")
                .FirstOrDefault();
            string version = asm?.GetVersion() ?? """";
            version.Should().Be(""0.0.0"");
        }

        [TestMethod]
        public void TestToByteArrayStandard()
        {
            BigInteger number = BigInteger.Zero;
            Assert.AreEqual("""", number.ToByteArrayStandard().ToHexString());

            number = BigInteger.One;
            Assert.AreEqual(""01"", number.ToByteArrayStandard().ToHexString());
        }

        [TestMethod]
        public void TestNextBigIntegerForRandom()
        {
            Random ran = new();
            Action action1 = () => ran.NextBigInteger(-1);
            action1.Should().Throw<ArgumentException>();

            ran.NextBigInteger(0).Should().Be(0);
            ran.NextBigInteger(8).Should().NotBeNull();
            ran.NextBigInteger(9).Should().NotBeNull();
        }

        [TestMethod]
        public void TestUnmapForIPAddress()
        {
            var addr = new IPAddress(new byte[] { 127, 0, 0, 1 });
            addr.Unmap().Should().Be(addr);

            var addr2 = addr.MapToIPv6();
            addr2.Unmap().Should().Be(addr);
        }

        [TestMethod]
        public void TestUnmapForIPEndPoin()
        {
            var addr = new IPAddress(new byte[] { 127, 0, 0, 1 });
            var endPoint = new IPEndPoint(addr, 8888);
            endPoint.Unmap().Should().Be(endPoint);

            var addr2 = addr.MapToIPv6();
            var endPoint2 = new IPEndPoint(addr2, 8888);
            endPoint2.Unmap().Should().Be(endPoint);
        }
    }",0,439 334 2000 123 91 2001 93 439 492 2002 40 41 123 2003 2004 61 418 40 41 59 326 91 93 2005 61 2004 46 2002 40 2006 46 2007 46 2008 41 59 2005 46 2009 40 41 46 2010 40 41 46 2011 40 648 41 59 125 91 2001 93 439 492 2012 40 41 123 2013 2014 61 418 40 41 59 326 91 93 2015 61 2014 46 2012 40 418 2016 40 2017 46 2018 40 1503 44 1503 41 41 44 2019 46 2020 46 2021 41 59 2015 46 2022 46 2023 40 41 46 2024 40 1503 41 59 125 91 2001 93 439 492 2025 40 41 123 326 91 93 2026 61 2027 46 2028 40 1503 44 1503 41 59 2029 2030 61 2026 46 2025 40 41 59 2030 46 2031 40 41 46 2032 40 2029 46 2033 40 648 41 41 59 125 91 2001 93 439 492 2034 40 41 123 490 2035 61 418 2036 40 1500 41 59 2035 46 2037 40 41 46 2038 40 41 46 2039 40 45 1501 41 59 490 2040 61 418 2036 40 1504 41 59 2040 46 2037 40 41 46 2038 40 41 46 2039 40 1502 41 59 490 2041 61 418 2036 40 404 46 2042 41 59 2041 46 2037 40 41 46 2038 40 41 46 2039 40 1503 41 59 490 2043 61 418 2036 40 413 46 2042 41 59 2043 46 2037 40 41 46 2038 40 41 46 2039 40 1503 41 59 125 91 2001 93 439 492 2044 40 41 123 461 2045 61 424 59 2046 61 2045 46 2047 40 41 46 2048 40 41 46 2049 40 41 46 2050 40 2051 46 2052 60 326 62 40 41 46 2048 40 41 41 59 461 2053 61 648 59 2053 46 2047 40 41 46 2048 40 41 46 2049 40 41 46 2050 40 2051 46 2052 60 326 62 40 41 46 2048 40 41 41 59 461 2054 61 648 59 2055 2056 61 40 41 619 2054 46 2047 40 41 59 2056 46 2049 40 41 46 2057 60 2058 62 40 41 59 461 2059 61 648 59 326 91 93 2060 61 2059 46 2047 40 41 59 2060 46 2048 40 41 46 2049 40 41 46 2050 40 418 326 91 93 123 1501 44 1502 125 46 2048 40 41 41 59 125 91 2001 93 439 492 2061 40 41 123 490 2062 61 418 2063 60 404 62 123 1501 44 1502 44 1502 125 59 490 2064 61 418 2065 60 404 44 426 62 123 91 1502 93 61 424 125 59 2062 46 2066 40 2064 41 59 2067 46 2068 40 418 404 91 93 123 1501 44 1502 125 44 2062 46 2069 40 41 41 59 2064 91 1502 93 61 424 59 2064 91 1502 93 61 424 59 2064 91 1501 93 61 424 59 2062 46 2066 40 2064 41 59 2067 46 2068 40 418 404 91 93 123 1502 125 44 2062 46 2069 40 41 41 59 125 91 2001 93 439 492 2070 40 41 123 490 2071 61 418 2072 60 404 62 123 1501 44 1502 44 1502 125 59 490 2073 61 418 2074 60 404 62 40 41 123 1502 125 59 2071 46 2075 40 2073 41 59 2076 46 2077 40 418 404 91 93 123 1501 44 1502 125 44 2071 46 2078 40 41 41 59 2073 46 2079 40 1502 41 59 2073 46 2079 40 1502 41 59 2073 46 2079 40 1501 41 59 2071 46 2075 40 2073 41 59 2076 46 2077 40 418 404 91 93 123 1502 125 44 2071 46 2078 40 41 41 59 125 91 2001 93 439 492 2080 40 41 123 490 2081 61 418 2082 60 404 62 123 1501 44 1502 44 1502 125 59 490 2083 61 418 2084 60 404 62 40 1502 41 123 1502 125 59 2081 46 2085 40 2083 41 59 2086 46 2087 40 418 404 91 93 123 1501 44 1502 125 44 2081 46 2088 40 41 41 59 2083 46 2089 40 1502 41 59 2083 46 2089 40 1502 41 59 2083 46 2089 40 1501 41 59 2081 46 2085 40 2083 41 59 2086 46 2087 40 418 404 91 93 123 1502 125 44 2081 46 2088 40 41 41 59 125 91 2001 93 439 492 2090 40 41 123 326 91 93 2091 61 424 59 2092 46 2093 60 2094 62 40 40 41 619 2091 46 2095 40 41 41 59 326 91 93 362 61 2096 46 2097 60 326 62 40 41 59 362 46 2095 40 41 46 2098 40 41 46 2099 40 648 41 59 362 46 2095 40 380 41 46 2098 40 41 46 2099 40 648 41 59 362 46 2095 40 473 41 46 2098 40 41 46 2099 40 648 41 59 326 91 93 2100 61 418 326 91 93 123 40 326 41 607 44 40 326 41 607 44 40 326 41 607 125 59 2100 46 2095 40 41 46 2098 40 41 46 2099 40 648 41 59 2100 46 2095 40 380 41 46 2098 40 41 46 2099 40 648 41 59 2100 46 2095 40 473 41 46 2098 40 41 46 2099 40 648 41 59 125 91 2001 93 439 492 2101 40 41 123 621 490 312 61 2102 46 2103 46 2104 40 41 46 2105 40 2106 619 2106 46 2107 614 648 41 46 2108 40 41 59 461 2109 61 312 634 2110 40 41 633 648 59 2109 46 2111 40 41 46 2112 40 648 41 59 125 91 2001 93 439 492 2113 40 41 123 2114 2115 61 2114 46 2116 59 2117 46 2118 40 648 44 2115 46 2119 40 41 46 2120 40 41 41 59 2115 61 2114 46 2121 59 2117 46 2118 40 648 44 2115 46 2119 40 41 46 2120 40 41 41 59 125 91 2001 93 439 492 2122 40 41 123 2123 2124 61 418 40 41 59 2125 2126 61 40 41 619 2124 46 2127 40 45 1501 41 59 2126 46 2128 40 41 46 2129 60 2130 62 40 41 59 2124 46 2127 40 1500 41 46 2128 40 41 46 2131 40 1500 41 59 2124 46 2127 40 1502 41 46 2128 40 41 46 2132 40 41 59 2124 46 2127 40 1502 41 46 2128 40 41 46 2132 40 41 59 125 91 2001 93 439 492 2133 40 41 123 490 2134 61 418 2135 40 418 326 91 93 123 1504 44 1500 44 1500 44 1501 125 41 59 2134 46 2136 40 41 46 2137 40 41 46 2138 40 2134 41 59 490 2139 61 2134 46 2140 40 41 59 2139 46 2136 40 41 46 2137 40 41 46 2138 40 2134 41 59 125 91 2001 93 439 492 2141 40 41 123 490 2142 61 418 2143 40 418 326 91 93 123 1504 44 1500 44 1500 44 1501 125 41 59 490 2144 61 418 2145 40 2142 44 1505 41 59 2144 46 2146 40 41 46 2147 40 41 46 2148 40 2144 41 59 490 2149 61 2142 46 2150 40 41 59 490 2151 61 418 2145 40 2149 44 1505 41 59 2151 46 2146 40 41 46 2147 40 41 46 2148 40 2144 41 59 125 125 
79893,C#,"    public class MerkleBlockPayload : ISerializable
    {
        /// <summary>
        /// The header of the block.
        /// </summary>
        public Header Header;

        /// <summary>
        /// The number of the transactions in the block.
        /// </summary>
        public int TxCount;

        /// <summary>
        /// The nodes of the transactions hash tree.
        /// </summary>
        public UInt256[] Hashes;

        /// <summary>
        /// The data in the <see cref=""BloomFilter""/> that filtered the block.
        /// </summary>
        public byte[] Flags;

        public int Size => Header.Size + sizeof(int) + Hashes.GetVarSize() + Flags.GetVarSize();

        /// <summary>
        /// Creates a new instance of the <see cref=""MerkleBlockPayload""/> class.
        /// </summary>
        /// <param name=""block"">The original block.</param>
        /// <param name=""flags"">The data in the <see cref=""BloomFilter""/> that filtered the block.</param>
        /// <returns>The created payload.</returns>
        public static MerkleBlockPayload Create(Block block, BitArray flags)
        {
            MerkleTree tree = new(block.Transactions.Select(p => p.Hash).ToArray());
            tree.Trim(flags);
            byte[] buffer = new byte[(flags.Length + 7) / 8];
            flags.CopyTo(buffer, 0);
            return new MerkleBlockPayload
            {
                Header = block.Header,
                TxCount = block.Transactions.Length,
                Hashes = tree.ToHashArray(),
                Flags = buffer
            };
        }

        public void Deserialize(BinaryReader reader)
        {
            Header = reader.ReadSerializable<Header>();
            TxCount = (int)reader.ReadVarInt(ushort.MaxValue);
            Hashes = reader.ReadSerializableArray<UInt256>(TxCount);
            Flags = reader.ReadVarBytes((Math.Max(TxCount, 1) + 7) / 8);
        }

        public void Serialize(BinaryWriter writer)
        {
            writer.Write(Header);
            writer.WriteVarInt(TxCount);
            writer.Write(Hashes);
            writer.WriteVarBytes(Flags);
        }
    }",0,439 334 2000 58 2001 123 612 439 2002 2002 59 612 439 404 2003 59 612 439 2004 91 93 2005 59 612 439 326 91 93 2006 59 439 404 2007 619 2002 46 2007 43 455 40 404 41 43 2005 46 2008 40 41 43 2006 46 2008 40 41 59 612 439 457 2000 2009 40 2010 2011 44 2012 2013 41 123 2014 2015 61 418 40 2011 46 2016 46 2017 40 2018 619 2018 46 2019 41 46 2020 40 41 41 59 2015 46 2021 40 2013 41 59 326 91 93 2022 61 418 326 91 40 2013 46 2023 43 1502 41 47 1502 93 59 2013 46 2024 40 2022 44 1500 41 59 450 418 2000 123 2002 61 2011 46 2002 44 2003 61 2011 46 2016 46 2023 44 2005 61 2015 46 2025 40 41 44 2006 61 2022 125 59 125 439 492 2026 40 2027 2028 41 123 2002 61 2028 46 2029 60 2002 62 40 41 59 2003 61 40 404 41 2028 46 2030 40 488 46 2031 41 59 2005 61 2028 46 2032 60 2004 62 40 2003 41 59 2006 61 2028 46 2033 40 40 2034 46 2035 40 2003 44 1501 41 43 1502 41 47 1502 41 59 125 439 492 2036 40 2037 2038 41 123 2038 46 2039 40 2002 41 59 2038 46 2040 40 2003 41 59 2038 46 2039 40 2005 41 59 2038 46 2041 40 2006 41 59 125 125 
79895,C#,"    public class HeadersPayload : ISerializable
    {
        /// <summary>
        /// Indicates the maximum number of headers sent each time.
        /// </summary>
        public const int MaxHeadersCount = 2000;

        /// <summary>
        /// The list of headers.
        /// </summary>
        public Header[] Headers;

        public int Size => Headers.GetVarSize();

        /// <summary>
        /// Creates a new instance of the <see cref=""HeadersPayload""/> class.
        /// </summary>
        /// <param name=""headers"">The list of headers.</param>
        /// <returns>The created payload.</returns>
        public static HeadersPayload Create(params Header[] headers)
        {
            return new HeadersPayload
            {
                Headers = headers
            };
        }

        void ISerializable.Deserialize(BinaryReader reader)
        {
            Headers = reader.ReadSerializableArray<Header>(MaxHeadersCount);
            if (Headers.Length == 0) throw new FormatException();
        }

        void ISerializable.Serialize(BinaryWriter writer)
        {
            writer.Write(Headers);
        }
    }",0,439 334 2000 58 2001 123 612 439 341 404 2002 61 1505 59 612 439 2003 91 93 2004 59 439 404 2005 619 2004 46 2006 40 41 59 612 439 457 2000 2007 40 433 2003 91 93 2008 41 123 450 418 2000 123 2004 61 2008 125 59 125 492 2001 46 2009 40 2010 2011 41 123 2004 61 2011 46 2012 60 2003 62 40 2002 41 59 392 40 2004 46 2013 614 1500 41 469 418 2014 40 41 59 125 492 2001 46 2015 40 2016 2017 41 123 2017 46 2018 40 2004 41 59 125 125 
69382,C#,"    public class GenericManyToOneString : ManyToOneTestBase
    {
        protected override TestModelBuilder CreateTestModelBuilder(
            TestHelpers testHelpers,
            Action<ModelConfigurationBuilder>? configure)
            => new GenericStringTestModelBuilder(testHelpers, configure);
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 40 2004 2005 44 2006 60 2007 62 63 2008 41 619 418 2009 40 2005 44 2008 41 59 125 
69384,C#,"    public class GenericOneToOneString : OneToOneTestBase
    {
        protected override TestModelBuilder CreateTestModelBuilder(
            TestHelpers testHelpers,
            Action<ModelConfigurationBuilder>? configure)
            => new GenericStringTestModelBuilder(testHelpers, configure);
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 40 2004 2005 44 2006 60 2007 62 63 2008 41 619 418 2009 40 2005 44 2008 41 59 125 
69452,C#,"public class EnumToNumberConverter<TEnum, TNumber> : ValueConverter<TEnum, TNumber>
    where TEnum : struct
    where TNumber : struct
{
    // ReSharper disable once StaticMemberInGenericType
    private static readonly ConverterMappingHints? DefaultHints = CreateDefaultHints();

    private static ConverterMappingHints? CreateDefaultHints()
    {
        var underlyingModelType = typeof(TEnum).UnwrapEnumType();

        return (underlyingModelType == typeof(long) || underlyingModelType == typeof(ulong))
            && typeof(TNumber) == typeof(decimal)
                ? new ConverterMappingHints(precision: 20, scale: 0)
                : default;
    }

    /// <summary>
    ///     Creates a new instance of this converter. This converter preserves order.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    public EnumToNumberConverter()
        : this(null)
    {
    }

    /// <summary>
    ///     Creates a new instance of this converter. This converter preserves order.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    /// <param name=""mappingHints"">
    ///     Hints that can be used by the <see cref=""ITypeMappingSource"" /> to create data types with appropriate
    ///     facets for the converted data.
    /// </param>
    public EnumToNumberConverter(ConverterMappingHints? mappingHints)
        : base(
            ToNumber(),
            ToEnum(),
            DefaultHints?.With(mappingHints) ?? mappingHints)
    {
    }

    /// <summary>
    ///     A <see cref=""ValueConverterInfo"" /> for the default use of this converter.
    /// </summary>
    public static ValueConverterInfo DefaultInfo { get; }
        = new(typeof(TEnum), typeof(TNumber), i => new EnumToNumberConverter<TEnum, TNumber>(i.MappingHints), DefaultHints);

    private static Expression<Func<TEnum, TNumber>> ToNumber()
    {
        if (!typeof(TEnum).UnwrapNullableType().IsEnum)
        {
            throw new InvalidOperationException(
                CoreStrings.ConverterBadType(
                    typeof(EnumToNumberConverter<TEnum, TNumber>).ShortDisplayName(),
                    typeof(TEnum).ShortDisplayName(),
                    ""enum types""));
        }

        CheckTypeSupported(
            typeof(TNumber).UnwrapNullableType(),
            typeof(EnumToNumberConverter<TEnum, TNumber>),
            typeof(int), typeof(long), typeof(short), typeof(byte),
            typeof(uint), typeof(ulong), typeof(ushort), typeof(sbyte),
            typeof(double), typeof(float), typeof(decimal));

        var param = Expression.Parameter(typeof(TEnum), ""value"");

        return Expression.Lambda<Func<TEnum, TNumber>>(
            Expression.Convert(
                typeof(TNumber) == typeof(decimal)
                    ? Expression.Convert(param, typeof(long))
                    : (Expression)param,
                typeof(TNumber)), param);
    }

    private static Expression<Func<TNumber, TEnum>> ToEnum()
    {
        var param = Expression.Parameter(typeof(TNumber), ""value"");
        return Expression.Lambda<Func<TNumber, TEnum>>(
            Expression.Convert(
                typeof(TNumber) == typeof(decimal)
                    ? Expression.Convert(param, typeof(long))
                    : (Expression)param,
                typeof(TEnum)), param);
    }
}",0,439 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 462 2004 2002 58 462 123 621 437 457 441 2005 63 2006 61 2007 40 41 59 437 457 2005 63 2007 40 41 123 490 2008 61 478 40 2001 41 46 2009 40 41 59 450 40 2008 614 478 40 413 41 606 2008 614 478 40 480 41 41 605 478 40 2002 41 614 478 40 345 41 63 418 2005 40 2010 58 1503 44 2011 58 1500 41 58 349 59 125 612 439 2000 40 41 58 467 40 424 41 123 125 612 439 2000 40 2005 63 2012 41 58 320 40 2013 40 41 44 2014 40 41 44 2006 634 2015 40 2012 41 633 2012 41 123 125 612 439 457 2016 2017 123 2018 59 125 61 418 40 478 40 2001 41 44 478 40 2002 41 44 2019 619 418 2000 60 2001 44 2002 62 40 2019 46 2020 41 44 2006 41 59 437 457 2021 60 2022 60 2001 44 2002 640 2013 40 41 123 392 40 33 478 40 2001 41 46 2023 40 41 46 2024 41 123 469 418 2025 40 2026 46 2027 40 478 40 2000 60 2001 44 2002 62 41 46 2028 40 41 44 478 40 2001 41 46 2028 40 41 44 648 41 41 59 125 2029 40 478 40 2002 41 46 2023 40 41 44 478 40 2000 60 2001 44 2002 62 41 44 478 40 404 41 44 478 40 413 41 44 478 40 453 41 44 478 40 326 41 44 478 40 479 41 44 478 40 480 41 44 478 40 488 41 44 478 40 451 41 44 478 40 356 41 44 478 40 384 41 44 478 40 345 41 41 59 490 2030 61 2021 46 2031 40 478 40 2001 41 44 648 41 59 450 2021 46 2032 60 2022 60 2001 44 2002 640 40 2021 46 2033 40 478 40 2002 41 614 478 40 345 41 63 2021 46 2033 40 2030 44 478 40 413 41 41 58 40 2021 41 2030 44 478 40 2002 41 41 44 2030 41 59 125 437 457 2021 60 2022 60 2002 44 2001 640 2014 40 41 123 490 2034 61 2021 46 2035 40 478 40 2002 41 44 648 41 59 450 2021 46 2036 60 2022 60 2002 44 2001 640 40 2021 46 2037 40 478 40 2002 41 614 478 40 345 41 63 2021 46 2037 40 2034 44 478 40 413 41 41 58 40 2021 41 2034 44 478 40 2001 41 41 44 2034 41 59 125 125 
68085,C#,"public static class SqlServerEntityTypeBuilderExtensions
{
    /// <summary>
    ///     Configures the table that the entity maps to when targeting SQL Server as memory-optimized.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-memory-optimized"">Using SQL Server memory-optimized tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""memoryOptimized"">A value indicating whether the table is memory-optimized.</param>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public static EntityTypeBuilder IsMemoryOptimized(
        this EntityTypeBuilder entityTypeBuilder,
        bool memoryOptimized = true)
    {
        entityTypeBuilder.Metadata.SetIsMemoryOptimized(memoryOptimized);

        return entityTypeBuilder;
    }

    /// <summary>
    ///     Configures the table that the entity maps to when targeting SQL Server as memory-optimized.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-memory-optimized"">Using SQL Server memory-optimized tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <typeparam name=""TEntity"">The entity type being configured.</typeparam>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""memoryOptimized"">A value indicating whether the table is memory-optimized.</param>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public static EntityTypeBuilder<TEntity> IsMemoryOptimized<TEntity>(
        this EntityTypeBuilder<TEntity> entityTypeBuilder,
        bool memoryOptimized = true)
        where TEntity : class
        => (EntityTypeBuilder<TEntity>)IsMemoryOptimized((EntityTypeBuilder)entityTypeBuilder, memoryOptimized);

    /// <summary>
    ///     Configures the table that the entity maps to when targeting SQL Server as memory-optimized.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-memory-optimized"">Using SQL Server memory-optimized tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""collectionOwnershipBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""memoryOptimized"">A value indicating whether the table is memory-optimized.</param>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public static OwnedNavigationBuilder IsMemoryOptimized(
        this OwnedNavigationBuilder collectionOwnershipBuilder,
        bool memoryOptimized = true)
    {
        collectionOwnershipBuilder.OwnedEntityType.SetIsMemoryOptimized(memoryOptimized);

        return collectionOwnershipBuilder;
    }

    /// <summary>
    ///     Configures the table that the entity maps to when targeting SQL Server as memory-optimized.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-memory-optimized"">Using SQL Server memory-optimized tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <typeparam name=""TEntity"">The entity type being configured.</typeparam>
    /// <typeparam name=""TRelatedEntity"">The entity type that this relationship targets.</typeparam>
    /// <param name=""collectionOwnershipBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""memoryOptimized"">A value indicating whether the table is memory-optimized.</param>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public static OwnedNavigationBuilder<TEntity, TRelatedEntity> IsMemoryOptimized<TEntity, TRelatedEntity>(
        this OwnedNavigationBuilder<TEntity, TRelatedEntity> collectionOwnershipBuilder,
        bool memoryOptimized = true)
        where TEntity : class
        where TRelatedEntity : class
        => (OwnedNavigationBuilder<TEntity, TRelatedEntity>)IsMemoryOptimized(
            (OwnedNavigationBuilder)collectionOwnershipBuilder, memoryOptimized);

    /// <summary>
    ///     Configures the table that the entity maps to when targeting SQL Server as memory-optimized.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-memory-optimized"">Using SQL Server memory-optimized tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""memoryOptimized"">A value indicating whether the table is memory-optimized.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionEntityTypeBuilder? IsMemoryOptimized(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        bool? memoryOptimized,
        bool fromDataAnnotation = false)
    {
        if (entityTypeBuilder.CanSetIsMemoryOptimized(memoryOptimized, fromDataAnnotation))
        {
            entityTypeBuilder.Metadata.SetIsMemoryOptimized(memoryOptimized, fromDataAnnotation);
            return entityTypeBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the mapped table can be configured as memory-optimized.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-memory-optimized"">Using SQL Server memory-optimized tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""memoryOptimized"">A value indicating whether the table is memory-optimized.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the mapped table can be configured as memory-optimized.</returns>
    public static bool CanSetIsMemoryOptimized(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        bool? memoryOptimized,
        bool fromDataAnnotation = false)
        => entityTypeBuilder.CanSetAnnotation(SqlServerAnnotationNames.MemoryOptimized, memoryOptimized, fromDataAnnotation);

    /// <summary>
    ///     Configures the table as temporal.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-memory-optimized"">Using SQL Server memory-optimized tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity being configured.</param>
    /// <param name=""temporal"">A value indicating whether the table is temporal.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionEntityTypeBuilder? IsTemporal(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        bool temporal = true,
        bool fromDataAnnotation = false)
    {
        if (entityTypeBuilder.CanSetIsTemporal(temporal, fromDataAnnotation))
        {
            entityTypeBuilder.Metadata.SetIsTemporal(temporal, fromDataAnnotation);

            return entityTypeBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the mapped table can be configured as temporal.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-memory-optimized"">Using SQL Server memory-optimized tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""temporal"">A value indicating whether the table is temporal.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the mapped table can be configured as temporal.</returns>
    public static bool CanSetIsTemporal(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        bool temporal = true,
        bool fromDataAnnotation = false)
        => entityTypeBuilder.CanSetAnnotation(SqlServerAnnotationNames.IsTemporal, temporal, fromDataAnnotation);

    /// <summary>
    ///     Configures a history table name for the entity mapped to a temporal table.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-temporal"">Using SQL Server temporal tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity being configured.</param>
    /// <param name=""name"">The name of the history table.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionEntityTypeBuilder? UseHistoryTableName(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        string name,
        bool fromDataAnnotation = false)
    {
        if (entityTypeBuilder.CanSetHistoryTableName(name, fromDataAnnotation))
        {
            entityTypeBuilder.Metadata.SetHistoryTableName(name, fromDataAnnotation);

            return entityTypeBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the given history table name can be set for the entity.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-temporal"">Using SQL Server temporal tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""name"">The name of the history table.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the mapped table can have history table name.</returns>
    public static bool CanSetHistoryTableName(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        string name,
        bool fromDataAnnotation = false)
    {
        Check.NotNull(name, nameof(name));

        return entityTypeBuilder.CanSetAnnotation(SqlServerAnnotationNames.TemporalHistoryTableName, name, fromDataAnnotation);
    }

    /// <summary>
    ///     Configures a history table schema for the entity mapped to a temporal table.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-temporal"">Using SQL Server temporal tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity being configured.</param>
    /// <param name=""schema"">The schema of the history table.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionEntityTypeBuilder? UseHistoryTableSchema(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        string? schema,
        bool fromDataAnnotation = false)
    {
        if (entityTypeBuilder.CanSetHistoryTableSchema(schema, fromDataAnnotation))
        {
            entityTypeBuilder.Metadata.SetHistoryTableSchema(schema, fromDataAnnotation);

            return entityTypeBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the mapped table can have history table schema.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-temporal"">Using SQL Server temporal tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""schema"">The schema of the history table.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the mapped table can have history table schema.</returns>
    public static bool CanSetHistoryTableSchema(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        string? schema,
        bool fromDataAnnotation = false)
        => entityTypeBuilder.CanSetAnnotation(SqlServerAnnotationNames.TemporalHistoryTableSchema, schema, fromDataAnnotation);

    /// <summary>
    ///     Configures a period start property for the entity mapped to a temporal table.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-temporal"">Using SQL Server temporal tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity being configured.</param>
    /// <param name=""propertyName"">The name of the period start property.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionEntityTypeBuilder? HasPeriodStart(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        string? propertyName,
        bool fromDataAnnotation = false)
    {
        if (entityTypeBuilder.CanSetPeriodStart(propertyName, fromDataAnnotation))
        {
            entityTypeBuilder.Metadata.SetPeriodStartPropertyName(propertyName, fromDataAnnotation);

            return entityTypeBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the mapped table can have period start property.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-temporal"">Using SQL Server temporal tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""propertyName"">The name of the period start property.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the mapped table can have period start property.</returns>
    public static bool CanSetPeriodStart(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        string? propertyName,
        bool fromDataAnnotation = false)
        => entityTypeBuilder.CanSetAnnotation(
            SqlServerAnnotationNames.TemporalPeriodStartPropertyName, propertyName, fromDataAnnotation);

    /// <summary>
    ///     Configures a period end property for the entity mapped to a temporal table.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-temporal"">Using SQL Server temporal tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity being configured.</param>
    /// <param name=""propertyName"">The name of the period end property.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionEntityTypeBuilder? HasPeriodEnd(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        string? propertyName,
        bool fromDataAnnotation = false)
    {
        if (entityTypeBuilder.CanSetPeriodEnd(propertyName, fromDataAnnotation))
        {
            entityTypeBuilder.Metadata.SetPeriodEndPropertyName(propertyName, fromDataAnnotation);

            return entityTypeBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the mapped table can have period end property.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-temporal"">Using SQL Server temporal tables with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""entityTypeBuilder"">The builder for the entity type being configured.</param>
    /// <param name=""propertyName"">The name of the period end property.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the mapped table can have period end property.</returns>
    public static bool CanSetPeriodEnd(
        this IConventionEntityTypeBuilder entityTypeBuilder,
        string? propertyName,
        bool fromDataAnnotation = false)
        => entityTypeBuilder.CanSetAnnotation(
            SqlServerAnnotationNames.TemporalPeriodEndPropertyName, propertyName, fromDataAnnotation);
}",0,439 457 334 2000 123 612 439 457 2001 2002 40 467 2001 2003 44 323 2004 61 473 41 123 2003 46 2005 46 2006 40 2004 41 59 450 2003 59 125 612 439 457 2001 60 2007 62 2002 60 2007 62 40 467 2001 60 2007 62 2003 44 323 2004 61 473 41 2008 2007 58 334 619 40 2001 60 2007 62 41 2002 40 40 2001 41 2003 44 2004 41 59 612 439 457 2009 2002 40 467 2009 2010 44 323 2004 61 473 41 123 2010 46 2011 46 2012 40 2004 41 59 450 2010 59 125 612 439 457 2009 60 2007 44 2013 62 2002 60 2007 44 2013 62 40 467 2009 60 2007 44 2013 62 2010 44 323 2004 61 473 41 2008 2007 58 334 2008 2013 58 334 619 40 2009 60 2007 44 2013 62 41 2002 40 40 2009 41 2010 44 2004 41 59 612 439 457 2014 63 2002 40 467 2014 2003 44 323 63 2004 44 323 2015 61 380 41 123 392 40 2003 46 2016 40 2004 44 2015 41 41 123 2003 46 2017 46 2018 40 2004 44 2015 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2019 40 467 2014 2003 44 323 63 2004 44 323 2015 61 380 41 619 2003 46 2020 40 2021 46 2022 44 2004 44 2015 41 59 612 439 457 2014 63 2023 40 467 2014 2003 44 323 2024 61 473 44 323 2015 61 380 41 123 392 40 2003 46 2025 40 2024 44 2015 41 41 123 2003 46 2026 46 2027 40 2024 44 2015 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2028 40 467 2014 2003 44 323 2024 61 473 44 323 2015 61 380 41 619 2003 46 2020 40 2021 46 2023 44 2024 44 2015 41 59 612 439 457 2014 63 2029 40 467 2014 2003 44 461 2030 44 323 2015 61 380 41 123 392 40 2003 46 2031 40 2030 44 2015 41 41 123 2003 46 2032 46 2033 40 2030 44 2015 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2034 40 467 2014 2003 44 461 2030 44 323 2015 61 380 41 123 2035 46 2036 40 2030 44 2037 40 2030 41 41 59 450 2003 46 2020 40 2021 46 2038 44 2030 44 2015 41 59 125 612 439 457 2014 63 2039 40 467 2014 2003 44 461 63 2040 44 323 2015 61 380 41 123 392 40 2003 46 2041 40 2040 44 2015 41 41 123 2003 46 2042 46 2043 40 2040 44 2015 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2044 40 467 2014 2003 44 461 63 2040 44 323 2015 61 380 41 619 2003 46 2020 40 2021 46 2045 44 2040 44 2015 41 59 612 439 457 2014 63 2046 40 467 2014 2003 44 461 63 2047 44 323 2015 61 380 41 123 392 40 2003 46 2048 40 2047 44 2015 41 41 123 2003 46 2049 46 2050 40 2047 44 2015 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2051 40 467 2014 2003 44 461 63 2047 44 323 2015 61 380 41 619 2003 46 2020 40 2021 46 2052 44 2047 44 2015 41 59 612 439 457 2014 63 2053 40 467 2014 2003 44 461 63 2047 44 323 2015 61 380 41 123 392 40 2003 46 2054 40 2047 44 2015 41 41 123 2003 46 2055 46 2056 40 2047 44 2015 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2057 40 467 2014 2003 44 461 63 2047 44 323 2015 61 380 41 619 2003 46 2020 40 2021 46 2058 44 2047 44 2015 41 59 125 
68104,C#,"    private class CustomValueGeneratorContext : DbContext
    {
        private static readonly IServiceProvider _serviceProvider
            = new ServiceCollection()
                .AddEntityFrameworkInMemoryDatabase()
                .AddScoped<IValueGeneratorSelector, CustomInMemoryValueGeneratorSelector>()
                .BuildServiceProvider(validateScopes: true);

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder
                .UseInternalServiceProvider(_serviceProvider)
                .UseInMemoryDatabase(nameof(CustomValueGeneratorContext));

        protected override void OnModelCreating(ModelBuilder modelBuilder)
            => modelBuilder
                .Entity<SomeEntity>(
                    b =>
                    {
                        b.HasAlternateKey(
                            e => new { e.SpecialId, e.SpecialString });
                        b.Property(e => e.SpecialId)
                            .HasAnnotation(""SpecialGuid"", true)
                            .ValueGeneratedOnAdd();

                        b.Property(e => e.SpecialString)
                            .ValueGeneratedOnAdd();
                    });
    }",0,437 334 2000 58 2001 123 437 457 441 2002 2003 61 418 2004 40 41 46 2005 40 41 46 2006 60 2007 44 2008 62 40 41 46 2009 40 2010 58 473 41 59 438 431 492 2011 40 2012 2013 41 619 2013 46 2014 40 2003 41 46 2015 40 2016 40 2000 41 41 59 438 431 492 2017 40 2018 2019 41 619 2019 46 2020 60 2021 62 40 2022 619 123 2022 46 2023 40 2024 619 418 123 2024 46 2025 44 2024 46 2026 125 41 59 2022 46 2027 40 2024 619 2024 46 2028 41 46 2029 40 648 44 473 41 46 2030 40 41 59 2022 46 2027 40 2024 619 2024 46 2031 41 46 2030 40 41 59 125 41 59 125 
68105,C#,"    private class CustomValueGeneratorContextAnnotateFactory : DbContext
    {
        private static readonly IServiceProvider _serviceProvider
            = new ServiceCollection()
                .AddEntityFrameworkInMemoryDatabase()
                .BuildServiceProvider(validateScopes: true);

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder
                .UseInternalServiceProvider(_serviceProvider)
                .UseInMemoryDatabase(nameof(CustomValueGeneratorContextAnnotateFactory));

        protected override void OnModelCreating(ModelBuilder modelBuilder)
            => modelBuilder
                .Entity<SomeEntity>(
                    b =>
                    {
                        var factory = new CustomValueGeneratorFactory();

                        b.Property(e => e.Id).HasValueGenerator(factory.Create);

                        b.Property(e => e.SpecialId)
                            .Metadata.SetValueGeneratorFactory(factory.Create);

                        b.Property(e => e.SpecialId)
                            .HasAnnotation(""SpecialGuid"", true)
                            .ValueGeneratedOnAdd();

                        b.Property(e => e.SpecialString).HasValueGenerator(factory.Create);
                    });
    }",0,437 334 2000 58 2001 123 437 457 441 2002 2003 61 418 2004 40 41 46 2005 40 41 46 2006 40 2007 58 473 41 59 438 431 492 2008 40 2009 2010 41 619 2010 46 2011 40 2003 41 46 2012 40 2013 40 2000 41 41 59 438 431 492 2014 40 2015 2016 41 619 2016 46 2017 60 2018 62 40 2019 619 123 490 2020 61 418 2021 40 41 59 2019 46 2022 40 2023 619 2023 46 2024 41 46 2025 40 2020 46 2026 41 59 2019 46 2022 40 2023 619 2023 46 2027 41 46 2028 46 2029 40 2020 46 2026 41 59 2019 46 2022 40 2023 619 2023 46 2027 41 46 2030 40 648 44 473 41 46 2031 40 41 59 2019 46 2022 40 2023 619 2023 46 2032 41 46 2025 40 2020 46 2026 41 59 125 41 59 125 
68699,C#,"    private sealed class Indenter : IDisposable
    {
        private readonly IndentedStringBuilder _stringBuilder;

        public Indenter(IndentedStringBuilder stringBuilder)
        {
            _stringBuilder = stringBuilder;

            _stringBuilder.IncrementIndent();
        }

        public void Dispose()
            => _stringBuilder.DecrementIndent();
    }",0,437 452 334 2000 58 2001 123 437 441 2002 2003 59 439 2000 40 2002 2004 41 123 2003 61 2004 59 2003 46 2005 40 41 59 125 439 492 2006 40 41 619 2003 46 2007 40 41 59 125 
68778,C#,"    private class FakeRelationalCommand : IRelationalCommand
    {
        public string CommandText { get; }

        public IReadOnlyList<IRelationalParameter> Parameters { get; }

        public IReadOnlyDictionary<string, object> ParameterValues
            => throw new NotImplementedException();

        public int ExecuteNonQuery(RelationalCommandParameterObject parameterObject)
            => 0;

        public Task<int> ExecuteNonQueryAsync(
            RelationalCommandParameterObject parameterObject,
            CancellationToken cancellationToken = default)
            => Task.FromResult(0);

        public RelationalDataReader ExecuteReader(RelationalCommandParameterObject parameterObject)
            => throw new NotImplementedException();

        public Task<RelationalDataReader> ExecuteReaderAsync(
            RelationalCommandParameterObject parameterObject,
            CancellationToken cancellationToken = default)
            => throw new NotImplementedException();

        public DbCommand CreateDbCommand(
            RelationalCommandParameterObject parameterObject,
            Guid commandId,
            DbCommandMethod commandMethod)
            => throw new NotImplementedException();

        public object ExecuteScalar(RelationalCommandParameterObject parameterObject)
            => throw new NotImplementedException();

        public Task<object> ExecuteScalarAsync(
            RelationalCommandParameterObject parameterObject,
            CancellationToken cancellationToken = default)
            => throw new NotImplementedException();

        public void PopulateFrom(IRelationalCommandTemplate commandTemplate)
            => throw new NotImplementedException();
    }",0,437 334 2000 58 2001 123 439 461 2002 123 2003 59 125 439 2004 60 2005 62 2006 123 2007 59 125 439 2008 60 461 44 426 62 2009 619 469 418 2010 40 41 59 439 404 2011 40 2012 2013 41 619 1500 59 439 2014 60 404 62 2015 40 2012 2013 44 2016 2017 61 349 41 619 2014 46 2018 40 1500 41 59 439 2019 2020 40 2012 2013 41 619 469 418 2010 40 41 59 439 2014 60 2019 62 2021 40 2012 2013 44 2016 2017 61 349 41 619 469 418 2010 40 41 59 439 2022 2023 40 2012 2013 44 2024 2025 44 2026 2027 41 619 469 418 2010 40 41 59 439 426 2028 40 2012 2013 41 619 469 418 2010 40 41 59 439 2014 60 426 62 2029 40 2012 2013 44 2016 2017 61 349 41 619 469 418 2010 40 41 59 439 492 2030 40 2031 2032 41 619 469 418 2010 40 41 59 125 
68780,C#,"    private class FakeRelationalCommandBuilderFactory : IRelationalCommandBuilderFactory
    {
        public IRelationalCommandBuilder Create()
            => new FakeRelationalCommandBuilder();
    }",0,437 334 2000 58 2001 123 439 2002 2003 40 41 619 418 2004 40 41 59 125 
68800,C#,"    private class FruityContext : DbContext
    {
        public FruityContext(DbContextOptions options)
            : base(options)
        {
        }

        public DbSet<Banana> Bananas { get; set; }
        public DbSet<Kiwi> Kiwi { get; set; }
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 439 2004 60 2005 62 2006 123 2007 59 2008 59 125 439 2004 60 2009 62 2009 123 2010 59 2011 59 125 125 
68868,C#,"public class SqliteQueryableMethodTranslatingExpressionVisitor : RelationalQueryableMethodTranslatingExpressionVisitor
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public SqliteQueryableMethodTranslatingExpressionVisitor(
        QueryableMethodTranslatingExpressionVisitorDependencies dependencies,
        RelationalQueryableMethodTranslatingExpressionVisitorDependencies relationalDependencies,
        QueryCompilationContext queryCompilationContext)
        : base(dependencies, relationalDependencies, queryCompilationContext)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected SqliteQueryableMethodTranslatingExpressionVisitor(
        SqliteQueryableMethodTranslatingExpressionVisitor parentVisitor)
        : base(parentVisitor)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override QueryableMethodTranslatingExpressionVisitor CreateSubqueryVisitor()
        => new SqliteQueryableMethodTranslatingExpressionVisitor(this);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override ShapedQueryExpression? TranslateOrderBy(
        ShapedQueryExpression source,
        LambdaExpression keySelector,
        bool ascending)
    {
        var translation = base.TranslateOrderBy(source, keySelector, ascending);
        if (translation == null)
        {
            return null;
        }

        var orderingExpression = ((SelectExpression)translation.QueryExpression).Orderings.Last();
        var orderingExpressionType = GetProviderType(orderingExpression.Expression);
        if (orderingExpressionType == typeof(DateTimeOffset)
            || orderingExpressionType == typeof(decimal)
            || orderingExpressionType == typeof(TimeSpan)
            || orderingExpressionType == typeof(ulong))
        {
            throw new NotSupportedException(
                SqliteStrings.OrderByNotSupported(orderingExpressionType.ShortDisplayName()));
        }

        return translation;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override ShapedQueryExpression? TranslateThenBy(
        ShapedQueryExpression source,
        LambdaExpression keySelector,
        bool ascending)
    {
        var translation = base.TranslateThenBy(source, keySelector, ascending);
        if (translation == null)
        {
            return null;
        }

        var orderingExpression = ((SelectExpression)translation.QueryExpression).Orderings.Last();
        var orderingExpressionType = GetProviderType(orderingExpression.Expression);
        if (orderingExpressionType == typeof(DateTimeOffset)
            || orderingExpressionType == typeof(decimal)
            || orderingExpressionType == typeof(TimeSpan)
            || orderingExpressionType == typeof(ulong))
        {
            throw new NotSupportedException(
                SqliteStrings.OrderByNotSupported(orderingExpressionType.ShortDisplayName()));
        }

        return translation;
    }

    private static Type GetProviderType(SqlExpression expression)
        => expression.TypeMapping?.Converter?.ProviderClrType
            ?? expression.TypeMapping?.ClrType
            ?? expression.Type;
}",0,439 334 2000 58 2001 123 612 439 2000 40 2002 2003 44 2004 2005 44 2006 2007 41 58 320 40 2003 44 2005 44 2007 41 123 125 612 438 2000 40 2000 2008 41 58 320 40 2008 41 123 125 612 438 431 2009 2010 40 41 619 418 2000 40 467 41 59 612 438 431 2011 63 2012 40 2011 2013 44 2014 2015 44 323 2016 41 123 490 2017 61 320 46 2012 40 2013 44 2015 44 2016 41 59 392 40 2017 614 424 41 123 450 424 59 125 490 2018 61 40 40 2019 41 2017 46 2020 41 46 2021 46 2022 40 41 59 490 2023 61 2024 40 2018 46 2025 41 59 392 40 2023 614 478 40 2026 41 606 2023 614 478 40 345 41 606 2023 614 478 40 2027 41 606 2023 614 478 40 480 41 41 123 469 418 2028 40 2029 46 2030 40 2023 46 2031 40 41 41 41 59 125 450 2017 59 125 612 438 431 2011 63 2032 40 2011 2013 44 2014 2015 44 323 2016 41 123 490 2033 61 320 46 2032 40 2013 44 2015 44 2016 41 59 392 40 2033 614 424 41 123 450 424 59 125 490 2034 61 40 40 2035 41 2033 46 2036 41 46 2037 46 2038 40 41 59 490 2039 61 2040 40 2034 46 2041 41 59 392 40 2039 614 478 40 2042 41 606 2039 614 478 40 345 41 606 2039 614 478 40 2043 41 606 2039 614 478 40 480 41 41 123 469 418 2044 40 2045 46 2046 40 2039 46 2047 40 41 41 41 59 125 450 2033 59 125 437 457 2048 2049 40 2050 2051 41 619 2051 46 2052 634 2053 634 2054 633 2051 46 2052 634 2055 633 2051 46 2048 59 125 
69020,C#,"public class CSharpMigrationsGenerator : MigrationsCodeGenerator
{
    /// <summary>
    ///     Initializes a new instance of the <see cref=""CSharpMigrationsGenerator"" /> class.
    /// </summary>
    /// <param name=""dependencies"">The base dependencies.</param>
    /// <param name=""csharpDependencies"">The dependencies.</param>
    public CSharpMigrationsGenerator(
        MigrationsCodeGeneratorDependencies dependencies,
        CSharpMigrationsGeneratorDependencies csharpDependencies)
        : base(dependencies)
    {
        CSharpDependencies = csharpDependencies;
    }

    /// <summary>
    ///     Dependencies for this service.
    /// </summary>
    protected virtual CSharpMigrationsGeneratorDependencies CSharpDependencies { get; }

    private ICSharpHelper Code
        => CSharpDependencies.CSharpHelper;

    /// <summary>
    ///     Gets the file extension code files should use.
    /// </summary>
    /// <value> The file extension. </value>
    public override string FileExtension
        => "".cs"";

    /// <summary>
    ///     Gets the programming language supported by this service.
    /// </summary>
    /// <value> The language. </value>
    public override string Language
        => ""C#"";

    /// <summary>
    ///     Generates the migration code.
    /// </summary>
    /// <param name=""migrationNamespace"">The migration's namespace.</param>
    /// <param name=""migrationName"">The migration's name.</param>
    /// <param name=""upOperations"">The migration's up operations.</param>
    /// <param name=""downOperations"">The migration's down operations.</param>
    /// <returns>The migration code.</returns>
    public override string GenerateMigration(
        string? migrationNamespace,
        string migrationName,
        IReadOnlyList<MigrationOperation> upOperations,
        IReadOnlyList<MigrationOperation> downOperations)
    {
        var builder = new IndentedStringBuilder();
        var namespaces = new List<string> { ""Microsoft.EntityFrameworkCore.Migrations"" };
        namespaces.AddRange(GetNamespaces(upOperations.Concat(downOperations)));
        foreach (var n in namespaces.OrderBy(x => x, new NamespaceComparer()).Distinct())
        {
            builder
                .Append(""using "")
                .Append(n)
                .AppendLine("";"");
        }

        builder
            .AppendLine()
            .AppendLine(""#nullable disable"");

        if (!string.IsNullOrEmpty(migrationNamespace))
        {
            builder
                .AppendLine()
                .Append(""namespace "").AppendLine(Code.Namespace(migrationNamespace))
                .AppendLine(""{"")
                .IncrementIndent();
        }

        builder
            .Append(""public partial class "").Append(Code.Identifier(migrationName)).AppendLine("" : Migration"")
            .AppendLine(""{"");
        using (builder.Indent())
        {
            builder
                .AppendLine(""protected override void Up(MigrationBuilder migrationBuilder)"")
                .AppendLine(""{"");
            using (builder.Indent())
            {
                CSharpDependencies.CSharpMigrationOperationGenerator.Generate(""migrationBuilder"", upOperations, builder);
            }

            builder
                .AppendLine()
                .AppendLine(""}"")
                .AppendLine()
                .AppendLine(""protected override void Down(MigrationBuilder migrationBuilder)"")
                .AppendLine(""{"");
            using (builder.Indent())
            {
                CSharpDependencies.CSharpMigrationOperationGenerator.Generate(""migrationBuilder"", downOperations, builder);
            }

            builder
                .AppendLine()
                .AppendLine(""}"");
        }

        builder.AppendLine(""}"");

        if (!string.IsNullOrEmpty(migrationNamespace))
        {
            builder
                .DecrementIndent()
                .AppendLine(""}"");
        }

        return builder.ToString();
    }

    private static void AppendAutoGeneratedTag(IndentedStringBuilder builder)
        => builder.AppendLine(""// <auto-generated />"");

    /// <summary>
    ///     Generates the migration metadata code.
    /// </summary>
    /// <param name=""migrationNamespace"">The migration's namespace.</param>
    /// <param name=""contextType"">The migration's <see cref=""DbContext"" /> type.</param>
    /// <param name=""migrationName"">The migration's name.</param>
    /// <param name=""migrationId"">The migration's ID.</param>
    /// <param name=""targetModel"">The migration's target model.</param>
    /// <returns>The migration metadata code.</returns>
    public override string GenerateMetadata(
        string? migrationNamespace,
        Type contextType,
        string migrationName,
        string migrationId,
        IModel targetModel)
    {
        var builder = new IndentedStringBuilder();
        AppendAutoGeneratedTag(builder);
        var namespaces = new List<string>
        {
            ""Microsoft.EntityFrameworkCore"",
            ""Microsoft.EntityFrameworkCore.Infrastructure"",
            ""Microsoft.EntityFrameworkCore.Migrations"",
            ""Microsoft.EntityFrameworkCore.Storage.ValueConversion""
        };
        if (!string.IsNullOrEmpty(contextType.Namespace))
        {
            namespaces.Add(contextType.Namespace);
        }

        namespaces.AddRange(GetNamespaces(targetModel));
        foreach (var n in namespaces.OrderBy(x => x, new NamespaceComparer()).Distinct())
        {
            builder
                .Append(""using "")
                .Append(n)
                .AppendLine("";"");
        }

        builder
            .AppendLine()
            .AppendLine(""#nullable disable"");

        if (!string.IsNullOrEmpty(migrationNamespace))
        {
            builder
                .AppendLine()
                .Append(""namespace "").AppendLine(Code.Namespace(migrationNamespace))
                .AppendLine(""{"")
                .IncrementIndent();
        }

        builder
            .Append(""[DbContext(typeof("").Append(Code.Reference(contextType)).AppendLine(""))]"")
            .Append(""[Migration("").Append(Code.Literal(migrationId)).AppendLine("")]"")
            .Append(""partial class "").AppendLine(Code.Identifier(migrationName))
            .AppendLine(""{"");
        using (builder.Indent())
        {
            builder
                .AppendLine(""protected override void BuildTargetModel(ModelBuilder modelBuilder)"")
                .AppendLine(""{"")
                .DecrementIndent()
                .DecrementIndent()
                .AppendLine(""#pragma warning disable 612, 618"")
                .IncrementIndent()
                .IncrementIndent();
            using (builder.Indent())
            {
                // TODO: Optimize. This is repeated below
                CSharpDependencies.CSharpSnapshotGenerator.Generate(""modelBuilder"", targetModel, builder);
            }

            builder
                .DecrementIndent()
                .DecrementIndent()
                .AppendLine(""#pragma warning restore 612, 618"")
                .IncrementIndent()
                .IncrementIndent()
                .AppendLine(""}"");
        }

        builder.AppendLine(""}"");

        if (!string.IsNullOrEmpty(migrationNamespace))
        {
            builder
                .DecrementIndent()
                .AppendLine(""}"");
        }

        return builder.ToString();
    }

    /// <summary>
    ///     Generates the model snapshot code.
    /// </summary>
    /// <param name=""modelSnapshotNamespace"">The model snapshot's namespace.</param>
    /// <param name=""contextType"">The model snapshot's <see cref=""DbContext"" /> type.</param>
    /// <param name=""modelSnapshotName"">The model snapshot's name.</param>
    /// <param name=""model"">The model.</param>
    /// <returns>The model snapshot code.</returns>
    public override string GenerateSnapshot(
        string? modelSnapshotNamespace,
        Type contextType,
        string modelSnapshotName,
        IModel model)
    {
        var builder = new IndentedStringBuilder();
        AppendAutoGeneratedTag(builder);
        var namespaces = new List<string>
        {
            ""Microsoft.EntityFrameworkCore"",
            ""Microsoft.EntityFrameworkCore.Infrastructure"",
            ""Microsoft.EntityFrameworkCore.Storage.ValueConversion""
        };
        if (!string.IsNullOrEmpty(contextType.Namespace))
        {
            namespaces.Add(contextType.Namespace);
        }

        namespaces.AddRange(GetNamespaces(model));
        foreach (var n in namespaces.OrderBy(x => x, new NamespaceComparer()).Distinct())
        {
            builder
                .Append(""using "")
                .Append(n)
                .AppendLine("";"");
        }

        builder
            .AppendLine()
            .AppendLine(""#nullable disable"");

        if (!string.IsNullOrEmpty(modelSnapshotNamespace))
        {
            builder
                .AppendLine()
                .Append(""namespace "").AppendLine(Code.Namespace(modelSnapshotNamespace))
                .AppendLine(""{"")
                .IncrementIndent();
        }

        builder
            .Append(""[DbContext(typeof("").Append(Code.Reference(contextType)).AppendLine(""))]"")
            .Append(""partial class "").Append(Code.Identifier(modelSnapshotName)).AppendLine("" : ModelSnapshot"")
            .AppendLine(""{"");
        using (builder.Indent())
        {
            builder
                .AppendLine(""protected override void BuildModel(ModelBuilder modelBuilder)"")
                .AppendLine(""{"")
                .DecrementIndent()
                .DecrementIndent()
                .AppendLine(""#pragma warning disable 612, 618"")
                .IncrementIndent()
                .IncrementIndent();
            using (builder.Indent())
            {
                CSharpDependencies.CSharpSnapshotGenerator.Generate(""modelBuilder"", model, builder);
            }

            builder
                .DecrementIndent()
                .DecrementIndent()
                .AppendLine(""#pragma warning restore 612, 618"")
                .IncrementIndent()
                .IncrementIndent()
                .AppendLine(""}"");
        }

        builder.AppendLine(""}"");

        if (!string.IsNullOrEmpty(modelSnapshotNamespace))
        {
            builder
                .DecrementIndent()
                .AppendLine(""}"");
        }

        return builder.ToString();
    }
}",0,439 334 2000 58 2001 123 612 439 2000 40 2002 2003 44 2004 2005 41 58 320 40 2003 41 123 2006 61 2005 59 125 612 438 491 2004 2007 123 2008 59 125 437 2009 2010 619 2007 46 2011 59 612 439 431 461 2012 619 648 59 612 439 431 461 2013 619 648 59 612 439 431 461 2014 40 461 63 2015 44 461 2016 44 2017 60 2018 62 2019 44 2017 60 2018 62 2020 41 123 490 2021 61 418 2022 40 41 59 490 2023 61 418 2024 60 461 62 123 648 125 59 2023 46 2025 40 2026 40 2019 46 2027 40 2020 41 41 41 59 386 40 490 2028 398 2023 46 2029 40 2030 619 2030 44 418 2031 40 41 41 46 2032 40 41 41 123 2021 46 2033 40 648 41 46 2033 40 2028 41 46 2034 40 648 41 59 125 2021 46 2035 40 41 46 2035 40 648 41 59 392 40 33 461 46 2036 40 2015 41 41 123 2021 46 2035 40 41 46 2037 40 648 41 46 2035 40 2010 46 2038 40 2015 41 41 46 2035 40 648 41 46 2039 40 41 59 125 2021 46 2040 40 648 41 46 2040 40 2010 46 2041 40 2016 41 41 46 2035 40 648 41 46 2035 40 648 41 59 489 40 2021 46 2042 40 41 41 123 2021 46 2035 40 648 41 46 2035 40 648 41 59 489 40 2021 46 2042 40 41 41 123 2007 46 2043 46 2044 40 648 44 2019 44 2021 41 59 125 2021 46 2035 40 41 46 2035 40 648 41 46 2035 40 41 46 2035 40 648 41 46 2035 40 648 41 59 489 40 2021 46 2042 40 41 41 123 2007 46 2045 46 2046 40 648 44 2020 44 2021 41 59 125 2021 46 2035 40 41 46 2035 40 648 41 59 125 2021 46 2035 40 648 41 59 392 40 33 461 46 2036 40 2015 41 41 123 2021 46 2047 40 41 46 2035 40 648 41 59 125 450 2021 46 2048 40 41 59 125 437 457 492 2049 40 2050 2051 41 619 2051 46 2052 40 648 41 59 612 439 431 461 2053 40 461 63 2015 44 2054 2055 44 461 2016 44 461 2056 44 2057 2058 41 123 490 2051 61 418 2050 40 41 59 2049 40 2051 41 59 490 2059 61 418 2060 60 461 62 123 648 44 648 44 648 44 648 125 59 392 40 33 461 46 2061 40 2055 46 2062 41 41 123 2059 46 2063 40 2055 46 2062 41 59 125 2059 46 2064 40 2065 40 2058 41 41 59 386 40 490 2066 398 2059 46 2067 40 2068 619 2068 44 418 2069 40 41 41 46 2070 40 41 41 123 2051 46 2071 40 648 41 46 2071 40 2066 41 46 2052 40 648 41 59 125 2051 46 2052 40 41 46 2052 40 648 41 59 392 40 33 461 46 2061 40 2015 41 41 123 2051 46 2052 40 41 46 2072 40 648 41 46 2052 40 2010 46 2062 40 2015 41 41 46 2052 40 648 41 46 2073 40 41 59 125 2051 46 2074 40 648 41 46 2074 40 2010 46 2075 40 2055 41 41 46 2052 40 648 41 46 2074 40 648 41 46 2074 40 2010 46 2076 40 2056 41 41 46 2052 40 648 41 46 2074 40 648 41 46 2052 40 2010 46 2077 40 2016 41 41 46 2052 40 648 41 59 489 40 2051 46 2078 40 41 41 123 2051 46 2052 40 648 41 46 2052 40 648 41 46 2079 40 41 46 2079 40 41 46 2052 40 648 41 46 2080 40 41 46 2080 40 41 59 489 40 2051 46 2078 40 41 41 123 621 2007 46 2081 46 2082 40 648 44 2058 44 2051 41 59 125 2051 46 2079 40 41 46 2079 40 41 46 2052 40 648 41 46 2080 40 41 46 2080 40 41 46 2052 40 648 41 59 125 2051 46 2052 40 648 41 59 392 40 33 461 46 2061 40 2015 41 41 123 2051 46 2083 40 41 46 2052 40 648 41 59 125 450 2051 46 2084 40 41 59 125 612 439 431 461 2085 40 461 63 2086 44 2054 2055 44 461 2087 44 2057 2088 41 123 490 2051 61 418 2050 40 41 59 2049 40 2051 41 59 490 2089 61 418 2090 60 461 62 123 648 44 648 44 648 125 59 392 40 33 461 46 2091 40 2055 46 2092 41 41 123 2089 46 2093 40 2055 46 2092 41 59 125 2089 46 2094 40 2095 40 2088 41 41 59 386 40 490 2096 398 2089 46 2097 40 2098 619 2098 44 418 2099 40 41 41 46 2100 40 41 41 123 2051 46 2101 40 648 41 46 2101 40 2096 41 46 2052 40 648 41 59 125 2051 46 2052 40 41 46 2052 40 648 41 59 392 40 33 461 46 2091 40 2086 41 41 123 2051 46 2052 40 41 46 2102 40 648 41 46 2052 40 2010 46 2092 40 2086 41 41 46 2052 40 648 41 46 2103 40 41 59 125 2051 46 2104 40 648 41 46 2104 40 2010 46 2105 40 2055 41 41 46 2052 40 648 41 46 2104 40 648 41 46 2104 40 2010 46 2106 40 2087 41 41 46 2052 40 648 41 46 2052 40 648 41 59 489 40 2051 46 2107 40 41 41 123 2051 46 2052 40 648 41 46 2052 40 648 41 46 2108 40 41 46 2108 40 41 46 2052 40 648 41 46 2109 40 41 46 2109 40 41 59 489 40 2051 46 2107 40 41 41 123 2007 46 2110 46 2111 40 648 44 2088 44 2051 41 59 125 2051 46 2108 40 41 46 2108 40 41 46 2052 40 648 41 46 2109 40 41 46 2109 40 41 46 2052 40 648 41 59 125 2051 46 2052 40 648 41 59 392 40 33 461 46 2091 40 2086 41 41 123 2051 46 2112 40 41 46 2052 40 648 41 59 125 450 2051 46 2113 40 41 59 125 125 
69313,C#,"    private class NonGenericStringTestOwnedNavigationBuilder<TEntity, TDependentEntity>
        : NonGenericTestOwnedNavigationBuilder<TEntity, TDependentEntity>
        where TEntity : class
        where TDependentEntity : class
    {
        public NonGenericStringTestOwnedNavigationBuilder(OwnedNavigationBuilder ownedNavigationBuilder)
            : base(ownedNavigationBuilder)
        {
        }

        protected override NonGenericTestOwnedNavigationBuilder<TNewEntity, TNewDependentEntity> Wrap<TNewEntity, TNewDependentEntity>(
            OwnedNavigationBuilder ownedNavigationBuilder)
            => new NonGenericStringTestOwnedNavigationBuilder<TNewEntity, TNewDependentEntity>(ownedNavigationBuilder);

        public override TestReferenceNavigationBuilder<TDependentEntity, TNewDependentEntity> HasOne<TNewDependentEntity>(
            Expression<Func<TDependentEntity, TNewDependentEntity?>>? navigationExpression = null)
            where TNewDependentEntity : class
        {
            var navigationName = navigationExpression?.GetMemberAccess().GetSimpleMemberName();

            return new NonGenericStringTestReferenceNavigationBuilder<TDependentEntity, TNewDependentEntity>(
                navigationName == null
                    ? OwnedNavigationBuilder.HasOne(typeof(TNewDependentEntity).FullName!, navigationName)
                    : OwnedNavigationBuilder.HasOne(navigationName));
        }
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2007 44 2008 62 2009 60 2007 44 2008 62 40 2005 2006 41 619 418 2000 60 2007 44 2008 62 40 2006 41 59 439 431 2010 60 2002 44 2008 62 2011 60 2008 62 40 2012 60 2013 60 2002 44 2008 63 640 63 2014 61 424 41 2004 2008 58 334 123 490 2015 61 2014 634 2016 40 41 46 2017 40 41 59 450 418 2018 60 2002 44 2008 62 40 2015 614 424 63 2005 46 2011 40 478 40 2008 41 46 2019 33 44 2015 41 58 2005 46 2011 40 2015 41 41 59 125 125 
69315,C#,"    private class NonGenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity> : NonGenericTestReferenceReferenceBuilder<
        TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public NonGenericStringTestReferenceReferenceBuilder(ReferenceReferenceBuilder referenceReferenceBuilder)
            : base(referenceReferenceBuilder)
        {
        }

        protected override NonGenericTestReferenceReferenceBuilder<TEntity, TRelatedEntity> Wrap(
            ReferenceReferenceBuilder referenceReferenceBuilder)
            => new NonGenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity>(referenceReferenceBuilder);

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
            Expression<Func<TDependentEntity, object?>> foreignKeyExpression)
            => Wrap(
                ReferenceReferenceBuilder.HasForeignKey(
                    typeof(TDependentEntity).Name,
                    foreignKeyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
            Expression<Func<TPrincipalEntity, object?>> keyExpression)
            => Wrap(
                ReferenceReferenceBuilder.HasPrincipalKey(
                    typeof(TPrincipalEntity).Name,
                    keyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
            params string[] foreignKeyPropertyNames)
            => Wrap(ReferenceReferenceBuilder.HasForeignKey(typeof(TDependentEntity).Name, foreignKeyPropertyNames));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
            params string[] keyPropertyNames)
            => Wrap(ReferenceReferenceBuilder.HasPrincipalKey(typeof(TPrincipalEntity).Name, keyPropertyNames));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2001 44 2002 62 2007 40 2005 2006 41 619 418 2000 60 2001 44 2002 62 40 2006 41 59 439 431 2008 60 2001 44 2002 62 2009 60 2010 62 40 2011 60 2012 60 2010 44 426 63 640 2013 41 619 2007 40 2005 46 2009 40 478 40 2010 41 46 2014 44 2013 46 2015 40 41 46 2016 40 2017 619 2017 46 2018 40 41 41 46 2019 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2020 60 2021 62 40 2011 60 2012 60 2021 44 426 63 640 2022 41 619 2007 40 2005 46 2020 40 478 40 2021 41 46 2014 44 2022 46 2015 40 41 46 2016 40 2017 619 2017 46 2018 40 41 41 46 2019 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2009 60 2010 62 40 433 461 91 93 2023 41 619 2007 40 2005 46 2009 40 478 40 2010 41 46 2014 44 2023 41 41 59 439 431 2008 60 2001 44 2002 62 2020 60 2021 62 40 433 461 91 93 2024 41 619 2007 40 2005 46 2020 40 478 40 2021 41 46 2014 44 2024 41 41 59 125 
69388,C#,"    private class GenericStringTestEntityTypeBuilder<TEntity> : GenericTestEntityTypeBuilder<TEntity>
        where TEntity : class
    {
        public GenericStringTestEntityTypeBuilder(EntityTypeBuilder<TEntity> entityTypeBuilder)
            : base(entityTypeBuilder)
        {
        }

        protected override TestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder<TEntity> entityTypeBuilder)
            => new GenericStringTestEntityTypeBuilder<TEntity>(entityTypeBuilder);

        public override TestOwnedNavigationBuilder<TEntity, TRelatedEntity> OwnsOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>> navigationExpression)
            where TRelatedEntity : class
            => new GenericStringTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.OwnsOne<TRelatedEntity>(navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestEntityTypeBuilder<TEntity> OwnsOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TEntity, TRelatedEntity>> buildAction)
            where TRelatedEntity : class
            => Wrap(
                EntityTypeBuilder.OwnsOne<TRelatedEntity>(
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(new GenericStringTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));

        public override TestOwnedNavigationBuilder<TEntity, TRelatedEntity> OwnsMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>> navigationExpression)
            where TRelatedEntity : class
            => new GenericStringTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.OwnsMany<TRelatedEntity>(navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestEntityTypeBuilder<TEntity> OwnsMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TEntity, TRelatedEntity>> buildAction)
            where TRelatedEntity : class
            => Wrap(
                EntityTypeBuilder.OwnsMany<TRelatedEntity>(
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(new GenericStringTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));

        public override TestReferenceNavigationBuilder<TEntity, TRelatedEntity> HasOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>>? navigationExpression = null)
            where TRelatedEntity : class
            => new GenericStringTestReferenceNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.HasOne<TRelatedEntity>(
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));

        public override TestCollectionNavigationBuilder<TEntity, TRelatedEntity> HasMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>>? navigationExpression = null)
            where TRelatedEntity : class
            => new GenericStringTestCollectionNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.HasMany<TRelatedEntity>(
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));
    }",0,437 334 2000 60 2001 62 58 2002 60 2001 62 2003 2001 58 334 123 439 2000 40 2004 60 2001 62 2005 41 58 320 40 2005 41 123 125 438 431 2006 60 2001 62 2007 40 2004 60 2001 62 2005 41 619 418 2000 60 2001 62 40 2005 41 59 439 431 2008 60 2001 44 2009 62 2010 60 2009 62 40 2011 60 2012 60 2001 44 2009 63 640 2013 41 2003 2009 58 334 619 418 2014 60 2001 44 2009 62 40 2004 46 2010 60 2009 62 40 2013 46 2015 40 41 46 2016 40 41 41 41 59 439 431 2006 60 2001 62 2010 60 2009 62 40 2011 60 2012 60 2001 44 2009 63 640 2013 44 2017 60 2008 60 2001 44 2009 640 2018 41 2003 2009 58 334 619 2007 40 2004 46 2010 60 2009 62 40 2013 46 2015 40 41 46 2016 40 41 44 2019 619 2018 40 418 2014 60 2001 44 2009 62 40 2019 41 41 41 41 59 439 431 2008 60 2001 44 2009 62 2020 60 2009 62 40 2011 60 2012 60 2001 44 2021 60 2009 62 63 640 2013 41 2003 2009 58 334 619 418 2014 60 2001 44 2009 62 40 2004 46 2020 60 2009 62 40 2013 46 2015 40 41 46 2016 40 41 41 41 59 439 431 2006 60 2001 62 2020 60 2009 62 40 2011 60 2012 60 2001 44 2021 60 2009 62 63 640 2013 44 2017 60 2008 60 2001 44 2009 640 2018 41 2003 2009 58 334 619 2007 40 2004 46 2020 60 2009 62 40 2013 46 2015 40 41 46 2016 40 41 44 2019 619 2018 40 418 2014 60 2001 44 2009 62 40 2019 41 41 41 41 59 439 431 2022 60 2001 44 2009 62 2023 60 2009 62 40 2011 60 2012 60 2001 44 2009 63 640 63 2013 61 424 41 2003 2009 58 334 619 418 2024 60 2001 44 2009 62 40 2004 46 2023 60 2009 62 40 2013 634 2015 40 41 46 2016 40 41 41 41 59 439 431 2025 60 2001 44 2009 62 2026 60 2009 62 40 2011 60 2012 60 2001 44 2021 60 2009 62 63 640 63 2013 61 424 41 2003 2009 58 334 619 418 2027 60 2001 44 2009 62 40 2004 46 2026 60 2009 62 40 2013 634 2015 40 41 46 2016 40 41 41 41 59 125 
69391,C#,"    private class GenericStringTestReferenceCollectionBuilder<TEntity, TRelatedEntity>
        : GenericTestReferenceCollectionBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public GenericStringTestReferenceCollectionBuilder(
            ReferenceCollectionBuilder<TEntity, TRelatedEntity> referenceCollectionBuilder)
            : base(referenceCollectionBuilder)
        {
        }

        protected override GenericTestReferenceCollectionBuilder<TEntity, TRelatedEntity> Wrap(
            ReferenceCollectionBuilder<TEntity, TRelatedEntity> referenceCollectionBuilder)
            => new GenericStringTestReferenceCollectionBuilder<TEntity, TRelatedEntity>(referenceCollectionBuilder);

        public override TestReferenceCollectionBuilder<TEntity, TRelatedEntity> HasForeignKey(
            Expression<Func<TRelatedEntity, object?>> foreignKeyExpression)
            => Wrap(
                ReferenceCollectionBuilder.HasForeignKey(
                    foreignKeyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceCollectionBuilder<TEntity, TRelatedEntity> HasPrincipalKey(
            Expression<Func<TEntity, object?>> keyExpression)
            => Wrap(
                ReferenceCollectionBuilder.HasPrincipalKey(
                    keyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2001 44 2002 62 2007 40 2005 60 2001 44 2002 62 2006 41 619 418 2000 60 2001 44 2002 62 40 2006 41 59 439 431 2008 60 2001 44 2002 62 2009 40 2010 60 2011 60 2002 44 426 63 640 2012 41 619 2007 40 2005 46 2009 40 2012 46 2013 40 41 46 2014 40 2015 619 2015 46 2016 40 41 41 46 2017 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2018 40 2010 60 2011 60 2001 44 426 63 640 2019 41 619 2007 40 2005 46 2018 40 2019 46 2013 40 41 46 2014 40 2015 619 2015 46 2016 40 41 41 46 2017 40 41 41 41 59 125 
69392,C#,"    private class GenericStringTestReferenceNavigationBuilder<TEntity, TRelatedEntity> :
        GenericTestReferenceNavigationBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public GenericStringTestReferenceNavigationBuilder(
            ReferenceNavigationBuilder<TEntity, TRelatedEntity> referenceNavigationBuilder)
            : base(referenceNavigationBuilder)
        {
        }

        public override TestReferenceCollectionBuilder<TRelatedEntity, TEntity> WithMany(
            Expression<Func<TRelatedEntity, IEnumerable<TEntity>?>>? navigationExpression = null)
            => new GenericStringTestReferenceCollectionBuilder<TRelatedEntity, TEntity>(
                ReferenceNavigationBuilder.WithMany(
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> WithOne(
            Expression<Func<TRelatedEntity, TEntity?>>? navigationExpression = null)
            => new GenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity>(
                ReferenceNavigationBuilder.WithOne(
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 439 431 2007 60 2002 44 2001 62 2008 40 2009 60 2010 60 2002 44 2011 60 2001 62 63 640 63 2012 61 424 41 619 418 2013 60 2002 44 2001 62 40 2005 46 2008 40 2012 634 2014 40 41 46 2015 40 41 41 41 59 439 431 2016 60 2001 44 2002 62 2017 40 2009 60 2010 60 2002 44 2001 63 640 63 2012 61 424 41 619 418 2018 60 2001 44 2002 62 40 2005 46 2017 40 2012 634 2014 40 41 46 2015 40 41 41 41 59 125 
69527,C#,"public class RelationalCommandBuilderFactory : IRelationalCommandBuilderFactory
{
    /// <summary>
    ///     <para>
    ///         Constructs a new <see cref=""RelationalCommand"" />.
    ///     </para>
    ///     <para>
    ///         This type is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </summary>
    /// <param name=""dependencies"">Parameter object containing dependencies for this service.</param>
    public RelationalCommandBuilderFactory(
        RelationalCommandBuilderDependencies dependencies)
    {
        Dependencies = dependencies;
    }

    /// <summary>
    ///     Relational provider-specific dependencies for this service.
    /// </summary>
    protected virtual RelationalCommandBuilderDependencies Dependencies { get; }

    /// <summary>
    ///     Creates a new <see cref=""IRelationalCommandBuilder"" />.
    /// </summary>
    /// <returns>The newly created builder.</returns>
    public virtual IRelationalCommandBuilder Create()
        => new RelationalCommandBuilder(Dependencies);
}",0,439 334 2000 58 2001 123 612 439 2000 40 2002 2003 41 123 2004 61 2003 59 125 612 438 491 2002 2005 123 2006 59 125 612 439 491 2007 2008 40 41 619 418 2009 40 2005 41 59 125 
70058,C#,"        private class ThrowingRelationalReader : RelationalDataReader
        {
            public override void Initialize(
                IRelationalConnection relationalConnection,
                DbCommand command,
                DbDataReader reader,
                Guid commandId,
                IRelationalCommandDiagnosticsLogger logger)
                => throw new InvalidOperationException(""Bang!"");
        }",0,437 334 2000 58 2001 123 439 431 492 2002 40 2003 2004 44 2005 2006 44 2007 2008 44 2009 2010 44 2011 2012 41 619 469 418 2013 40 648 41 59 125 
70159,C#,"    public class ExecutionStrategyFixture : SharedStoreFixtureBase<DbContext>
    {
        protected override bool UsePooling
            => false;

        protected override string StoreName { get; } = nameof(ExecutionStrategyTest);

        public new RelationalTestStore TestStore
            => (RelationalTestStore)base.TestStore;

        public TestSqlLoggerFactory TestSqlLoggerFactory
            => (TestSqlLoggerFactory)ListLoggerFactory;

        protected override ITestStoreFactory TestStoreFactory
            => SqlServerTestStoreFactory.Instance;

        protected override Type ContextType { get; } = typeof(ExecutionStrategyContext);

        protected override IServiceCollection AddServices(IServiceCollection serviceCollection)
            => base.AddServices(serviceCollection)
                .AddSingleton<IRelationalTransactionFactory, TestRelationalTransactionFactory>()
                .AddScoped<ISqlServerConnection, TestSqlServerConnection>()
                .AddSingleton<IRelationalCommandBuilderFactory, TestRelationalCommandBuilderFactory>();

        public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder builder)
        {
            var options = base.AddOptions(builder);
            new SqlServerDbContextOptionsBuilder(options).MaxBatchSize(1);
            return options;
        }

        protected override bool ShouldLogCategory(string logCategory)
            => logCategory == DbLoggerCategory.Infrastructure.Name;
    }",0,439 334 2000 58 2001 60 2002 62 123 438 431 323 2003 619 380 59 438 431 461 2004 123 2005 59 125 61 2006 40 2007 41 59 439 418 2008 2009 619 40 2008 41 320 46 2009 59 439 2010 2010 619 40 2010 41 2011 59 438 431 2012 2013 619 2014 46 2015 59 438 431 2016 2017 123 2018 59 125 61 478 40 2019 41 59 438 431 2020 2021 40 2020 2022 41 619 320 46 2021 40 2022 41 46 2023 60 2024 44 2025 62 40 41 46 2026 60 2027 44 2028 62 40 41 46 2023 60 2029 44 2030 62 40 41 59 439 431 2031 2032 40 2031 2033 41 123 490 2034 61 320 46 2032 40 2033 41 59 418 2035 40 2034 41 46 2036 40 1501 41 59 450 2034 59 125 438 431 323 2037 40 461 2038 41 619 2038 614 2039 46 2040 46 2041 59 125 
70294,C#,"        private class ConstructorTestContext1A : DbContext
        {
            public ConstructorTestContext1A(DbContextOptions options)
                : base(options)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 125 
70296,C#,"        private class ConstructorTestContextWithOC2A : ConstructorTestContextWithOCBase
        {
            public ConstructorTestContextWithOC2A(
                IServiceProvider internalServicesProvider)
                : base(internalServicesProvider)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 125 
70298,C#,"        private class ConstructorTestContextWithOC3A : ConstructorTestContextWithOCBase, IConstructorTestContextWithOC3A
        {
            public ConstructorTestContextWithOC3A(
                DbContextOptions options)
                : base(options)
            {
            }
        }",0,437 334 2000 58 2001 44 2002 123 439 2000 40 2003 2004 41 58 320 40 2004 41 123 125 125 
70300,C#,"        private class ConstructorTestContextWithSets : DbContext
        {
            public ConstructorTestContextWithSets(DbContextOptions options)
                : base(options)
            {
            }

            public DbSet<Product> Products { get; set; }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 439 2004 60 2005 62 2006 123 2007 59 2008 59 125 125 
70301,C#,"        private class CustomInMemoryTableFactory : InMemoryTableFactory
        {
            public CustomInMemoryTableFactory(ILoggingOptions loggingOptions, IInMemorySingletonOptions options)
                : base(loggingOptions, options)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 2005 41 58 320 40 2003 44 2005 41 123 125 125 
70306,C#,"        private class DerivedContext1 : DbContext
        {
            public DerivedContext1(DbContextOptions<DerivedContext1> options)
                : base(options)
            {
            }

            protected DerivedContext1(DbContextOptions options)
                : base(options)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 60 2000 62 2003 41 58 320 40 2003 41 123 125 438 2000 40 2002 2003 41 58 320 40 2003 41 123 125 125 
70309,C#,"        private class FakeEntityMaterializerSource : EntityMaterializerSource
        {
            public FakeEntityMaterializerSource(EntityMaterializerSourceDependencies dependencies)
                : base(dependencies)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 125 
70312,C#,"        private class FakeNavigationFixer : INavigationFixer
        {
            public void StateChanging(InternalEntityEntry entry, EntityState newState)
                => throw new NotImplementedException();

            public void StateChanged(InternalEntityEntry entry, EntityState oldState, bool fromQuery)
                => throw new NotImplementedException();

            public bool BeginDelayedFixup()
                => false;

            public void CompleteDelayedFixup()
            {
            }

            public void AbortDelayedFixup()
            {
            }

            public void NavigationReferenceChanged(
                InternalEntityEntry entry,
                INavigationBase navigationBase,
                object oldValue,
                object newValue)
                => throw new NotImplementedException();

            public void NavigationCollectionChanged(
                InternalEntityEntry entry,
                INavigationBase navigationBase,
                IEnumerable<object> added,
                IEnumerable<object> removed)
                => throw new NotImplementedException();

            public void KeyPropertyChanged(
                InternalEntityEntry entry,
                IProperty property,
                IEnumerable<IKey> containingPrincipalKeys,
                IEnumerable<IForeignKey> containingForeignKeys,
                object oldValue,
                object newValue)
                => throw new NotImplementedException();

            public void TrackedFromQuery(InternalEntityEntry entry)
                => throw new NotImplementedException();
        }",0,437 334 2000 58 2001 123 439 492 2002 40 2003 2004 44 2005 2006 41 619 469 418 2007 40 41 59 439 492 2008 40 2003 2004 44 2005 2009 44 323 2010 41 619 469 418 2007 40 41 59 439 323 2011 40 41 619 380 59 439 492 2012 40 41 123 125 439 492 2013 40 41 123 125 439 492 2014 40 2003 2004 44 2015 2016 44 426 2017 44 426 2018 41 619 469 418 2007 40 41 59 439 492 2019 40 2003 2004 44 2015 2016 44 2020 60 426 62 2021 44 2020 60 426 62 2022 41 619 469 418 2007 40 41 59 439 492 2023 40 2003 2004 44 2024 2025 44 2020 60 2026 62 2027 44 2020 60 2028 62 2029 44 426 2017 44 426 2018 41 619 469 418 2007 40 41 59 439 492 2030 40 2003 2004 41 619 469 418 2007 40 41 59 125 
70315,C#,"            private class MyListLogger : ILogger
            {
                public MyListLogger(List<(LogLevel, EventId, string)> logMessage)
                {
                    LogMessages = logMessage;
                }

                private List<(LogLevel, EventId, string)> LogMessages { get; }

                public void Log<TState>(
                    LogLevel logLevel,
                    EventId eventId,
                    TState state,
                    Exception exception,
                    Func<TState, Exception, string> formatter)
                {
                    var message = new StringBuilder();
                    if (formatter != null)
                    {
                        message.Append(formatter(state, exception));
                    }
                    else if (state != null)
                    {
                        message.Append(state);

                        if (exception != null)
                        {
                            message.Append(Environment.NewLine);
                            message.Append(exception);
                        }
                    }

                    LogMessages?.Add((logLevel, eventId, message.ToString()));
                }

                public bool IsEnabled(LogLevel logLevel)
                    => true;

                public IDisposable BeginScope(object state)
                    => throw new NotImplementedException();

                public IDisposable BeginScope<TState>(TState state)
                    => null;
            }",0,437 334 2000 58 2001 123 439 2000 40 2002 60 40 2003 44 2004 44 461 41 62 2005 41 123 2006 61 2005 59 125 437 2002 60 40 2003 44 2004 44 461 41 62 2007 123 2008 59 125 439 492 2009 60 2010 62 40 2003 2011 44 2004 2012 44 2010 2013 44 2014 2015 44 2016 60 2010 44 2014 44 461 62 2017 41 123 490 2018 61 418 2019 40 41 59 392 40 2017 631 424 41 123 2018 46 2020 40 2017 40 2013 44 2015 41 41 59 125 360 392 40 2013 631 424 41 123 2018 46 2021 40 2013 41 59 392 40 2015 631 424 41 123 2018 46 2021 40 2022 46 2023 41 59 2018 46 2021 40 2015 41 59 125 125 2007 634 2024 40 40 2011 44 2012 44 2018 46 2025 40 41 41 41 59 125 439 323 2026 40 2003 2011 41 619 473 59 439 2027 2028 40 426 2013 41 619 469 418 2029 40 41 59 439 2027 2028 60 2010 62 40 2010 2013 41 619 424 59 125 
70316,C#,"        private class NonGenericOptions1 : DbContext
        {
            public NonGenericOptions1(DbContextOptions options)
                : base(options)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 125 
70317,C#,"        private class NonGenericOptions2 : DbContext
        {
            public NonGenericOptions2(DbContextOptions options)
                : base(options)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 125 
70319,C#,"        private class ReplaceServiceContext2 : DbContext
        {
            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
                => optionsBuilder
                    .ReplaceService<IModelCustomizer, CustomModelCustomizer>()
                    .ConfigureWarnings(w => w.Default(WarningBehavior.Throw))
                    .UseInternalServiceProvider(
                        new ServiceCollection()
                            .AddEntityFrameworkInMemoryDatabase()
                            .BuildServiceProvider(validateScopes: true))
                    .UseInMemoryDatabase(Guid.NewGuid().ToString());
        }",0,437 334 2000 58 2001 123 438 406 431 492 2002 40 2003 2004 41 619 2004 46 2005 60 2006 44 2007 62 40 41 46 2008 40 2009 619 2009 46 2010 40 2011 46 2012 41 41 46 2013 40 418 2014 40 41 46 2015 40 41 46 2016 40 2017 58 473 41 41 46 2018 40 2019 46 2020 40 41 46 2021 40 41 41 59 125 
70320,C#,"        private class SetLoggerFactoryContext : DbContext
        {
            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
                => optionsBuilder
                    .UseLoggerFactory(new ListLoggerFactory())
                    .UseInternalServiceProvider(
                        new ServiceCollection()
                            .AddEntityFrameworkInMemoryDatabase()
                            .BuildServiceProvider(validateScopes: true))
                    .UseInMemoryDatabase(Guid.NewGuid().ToString());
        }",0,437 334 2000 58 2001 123 438 406 431 492 2002 40 2003 2004 41 619 2004 46 2005 40 418 2006 40 41 41 46 2007 40 418 2008 40 41 46 2009 40 41 46 2010 40 2011 58 473 41 41 46 2012 40 2013 46 2014 40 41 46 2015 40 41 41 59 125 
70640,C#,"        private class BadDataRelationalCommandBuilder : RelationalCommandBuilder
        {
            private readonly object[] _values;

            public BadDataRelationalCommandBuilder(
                RelationalCommandBuilderDependencies dependencies,
                object[] values)
                : base(dependencies)
            {
                _values = values;
            }

            public override IRelationalCommand Build()
                => new BadDataRelationalCommand(Dependencies, ToString(), Parameters, _values);

            private class BadDataRelationalCommand : RelationalCommand
            {
                private object[] _values;

                public BadDataRelationalCommand(
                    RelationalCommandBuilderDependencies dependencies,
                    string commandText,
                    IReadOnlyList<IRelationalParameter> parameters,
                    object[] values)
                    : base(dependencies, commandText, parameters)
                {
                    _values = values;
                }

                public override RelationalDataReader ExecuteReader(
                    RelationalCommandParameterObject parameterObject)
                {
                    var command = parameterObject.Connection.DbConnection.CreateCommand();
                    command.CommandText = CommandText;
                    var reader = new BadDataRelationalDataReader();
                    reader.Initialize(
                        new FakeConnection(),
                        command,
                        new BadDataDataReader(_values),
                        Guid.NewGuid(),
                        parameterObject.Logger);
                    return reader;
                }

                public override void PopulateFrom(IRelationalCommandTemplate commandTemplate)
                {
                    base.PopulateFrom(commandTemplate);
                    _values = ((BadDataRelationalCommand)commandTemplate)._values;
                }

                private class BadDataRelationalDataReader : RelationalDataReader
                {
                }

                private class BadDataDataReader : DbDataReader
                {
                    private readonly object[] _values;

                    public BadDataDataReader(object[] values)
                    {
                        _values = values;
                    }

                    public override bool Read()
                        => true;

                    public override bool IsDBNull(int ordinal)
                        => false;

                    public override int GetInt32(int ordinal)
                        => (int)GetValue(ordinal);

                    public override short GetInt16(int ordinal)
                        => (short)GetValue(ordinal);

                    public override bool GetBoolean(int ordinal)
                        => (bool)GetValue(ordinal);

                    public override string GetString(int ordinal)
                        => (string)GetValue(ordinal);

                    public override object GetValue(int ordinal)
                        => _values[ordinal];

                    #region NotImplemented members

                    public override string GetName(int ordinal)
                        => throw new NotImplementedException();

                    public override int GetValues(object[] values)
                        => throw new NotImplementedException();

                    public override int FieldCount
                        => throw new NotImplementedException();

                    public override object this[int ordinal]
                        => throw new NotImplementedException();

                    public override object this[string name]
                        => throw new NotImplementedException();

                    public override bool HasRows
                        => throw new NotImplementedException();

                    public override bool IsClosed
                        => throw new NotImplementedException();

                    public override int RecordsAffected
                        => 0;

                    public override bool NextResult()
                        => throw new NotImplementedException();

                    public override int Depth
                        => throw new NotImplementedException();

                    public override int GetOrdinal(string name)
                        => throw new NotImplementedException();

                    public override byte GetByte(int ordinal)
                        => throw new NotImplementedException();

                    public override long GetBytes(int ordinal, long dataOffset, byte[] buffer, int bufferOffset, int length)
                        => throw new NotImplementedException();

                    public override char GetChar(int ordinal)
                        => throw new NotImplementedException();

                    public override long GetChars(int ordinal, long dataOffset, char[] buffer, int bufferOffset, int length)
                        => throw new NotImplementedException();

                    public override Guid GetGuid(int ordinal)
                        => throw new NotImplementedException();

                    public override long GetInt64(int ordinal)
                        => throw new NotImplementedException();

                    public override DateTime GetDateTime(int ordinal)
                        => throw new NotImplementedException();

                    public override decimal GetDecimal(int ordinal)
                        => throw new NotImplementedException();

                    public override double GetDouble(int ordinal)
                        => throw new NotImplementedException();

                    public override float GetFloat(int ordinal)
                        => throw new NotImplementedException();

                    public override string GetDataTypeName(int ordinal)
                        => throw new NotImplementedException();

                    public override Type GetFieldType(int ordinal)
                        => throw new NotImplementedException();

                    public override IEnumerator GetEnumerator()
                        => throw new NotImplementedException();

                    #endregion
                }
            }
        }",0,437 334 2000 58 2001 123 437 441 426 91 93 2002 59 439 2000 40 2003 2004 44 426 91 93 2005 41 58 320 40 2004 41 123 2002 61 2005 59 125 439 431 2006 2007 40 41 619 418 2008 40 2009 44 2010 40 41 44 2011 44 2002 41 59 437 334 2008 58 2012 123 437 426 91 93 2002 59 439 2008 40 2003 2004 44 461 2013 44 2014 60 2015 62 2016 44 426 91 93 2005 41 58 320 40 2004 44 2013 44 2016 41 123 2002 61 2005 59 125 439 431 2017 2018 40 2019 2020 41 123 490 2021 61 2020 46 2022 46 2023 46 2024 40 41 59 2021 46 2025 61 2025 59 490 2026 61 418 2027 40 41 59 2026 46 2028 40 418 2029 40 41 44 2021 44 418 2030 40 2002 41 44 2031 46 2032 40 41 44 2020 46 2033 41 59 450 2026 59 125 439 431 492 2034 40 2035 2036 41 123 320 46 2034 40 2036 41 59 2002 61 40 40 2008 41 2036 41 46 2002 59 125 437 334 2037 58 2017 123 125 437 334 2038 58 2039 123 437 441 426 91 93 2002 59 439 2038 40 426 91 93 2005 41 123 2002 61 2005 59 125 439 431 323 2040 40 41 619 473 59 439 431 323 2041 40 404 2042 41 619 380 59 439 431 404 2043 40 404 2042 41 619 40 404 41 2044 40 2042 41 59 439 431 453 2045 40 404 2042 41 619 40 453 41 2044 40 2042 41 59 439 431 323 2046 40 404 2042 41 619 40 323 41 2044 40 2042 41 59 439 431 461 2047 40 404 2042 41 619 40 461 41 2044 40 2042 41 59 439 431 426 2044 40 404 2042 41 619 2002 91 2042 93 59 35 443 439 431 461 2048 40 404 2042 41 619 469 418 2049 40 41 59 439 431 404 2050 40 426 91 93 2005 41 619 469 418 2049 40 41 59 439 431 404 2051 619 469 418 2049 40 41 59 439 431 426 467 91 404 2042 93 619 469 418 2049 40 41 59 439 431 426 467 91 461 2052 93 619 469 418 2049 40 41 59 439 431 323 2053 619 469 418 2049 40 41 59 439 431 323 2054 619 469 418 2049 40 41 59 439 431 404 2055 619 1500 59 439 431 323 2056 40 41 619 469 418 2049 40 41 59 439 431 404 2057 619 469 418 2049 40 41 59 439 431 404 2058 40 461 2052 41 619 469 418 2049 40 41 59 439 431 326 2059 40 404 2042 41 619 469 418 2049 40 41 59 439 431 413 2060 40 404 2042 44 413 2061 44 326 91 93 2062 44 404 2063 44 404 2064 41 619 469 418 2049 40 41 59 439 431 330 2065 40 404 2042 41 619 469 418 2049 40 41 59 439 431 413 2066 40 404 2042 44 413 2061 44 330 91 93 2062 44 404 2063 44 404 2064 41 619 469 418 2049 40 41 59 439 431 2067 2068 40 404 2042 41 619 469 418 2049 40 41 59 439 431 413 2069 40 404 2042 41 619 469 418 2049 40 41 59 439 431 2070 2071 40 404 2042 41 619 469 418 2049 40 41 59 439 431 345 2072 40 404 2042 41 619 469 418 2049 40 41 59 439 431 356 2073 40 404 2042 41 619 469 418 2049 40 41 59 439 431 384 2074 40 404 2042 41 619 469 418 2049 40 41 59 439 431 461 2075 40 404 2042 41 619 469 418 2049 40 41 59 439 431 2076 2077 40 404 2042 41 619 469 418 2049 40 41 59 439 431 2078 2079 40 41 619 469 418 2049 40 41 59 35 367 125 125 125 
70641,C#,"    public class BadDataSqliteFixture : NorthwindQuerySqliteFixture<NoopModelCustomizer>
    {
        protected override IServiceCollection AddServices(IServiceCollection serviceCollection)
            => base.AddServices(serviceCollection)
                .AddSingleton<IRelationalCommandBuilderFactory, BadDataCommandBuilderFactory>();
    }",0,439 334 2000 58 2001 60 2002 62 123 438 431 2003 2004 40 2003 2005 41 619 320 46 2004 40 2005 41 46 2006 60 2007 44 2008 62 40 41 59 125 
71610,C#,"public class TypeExtensionsTest
{
    [ConditionalFact]
    public void GetSequenceType_finds_element_type()
    {
        Assert.Equal(typeof(int), typeof(IEnumerable<int>).GetSequenceType());
        Assert.Equal(typeof(int), typeof(IQueryable<int>).GetSequenceType());
        Assert.Equal(typeof(int), typeof(IAsyncEnumerable<int>).GetSequenceType());
        Assert.Equal(typeof(int), typeof(List<int>).GetSequenceType());
    }

    [ConditionalFact]
    public void IsInteger_returns_true_only_for_integer_types()
    {
        Assert.True(typeof(long).IsInteger());
        Assert.True(typeof(int).IsInteger());
        Assert.True(typeof(short).IsInteger());
        Assert.True(typeof(byte).IsInteger());
        Assert.True(typeof(ulong).IsInteger());
        Assert.True(typeof(uint).IsInteger());
        Assert.True(typeof(ushort).IsInteger());
        Assert.True(typeof(sbyte).IsInteger());
        Assert.True(typeof(long?).IsInteger());
        Assert.True(typeof(int?).IsInteger());
        Assert.True(typeof(short?).IsInteger());
        Assert.True(typeof(byte?).IsInteger());
        Assert.True(typeof(long?).IsInteger());
        Assert.True(typeof(int?).IsInteger());
        Assert.True(typeof(short?).IsInteger());
        Assert.True(typeof(byte?).IsInteger());
        Assert.False(typeof(bool).IsInteger());
        Assert.False(typeof(bool?).IsInteger());
        Assert.False(typeof(decimal).IsInteger());
        Assert.False(typeof(float).IsInteger());
        Assert.False(typeof(SomeEnum).IsInteger());
    }

    public class CtorFixture
    {
        public CtorFixture()
        {
        }

        // ReSharper disable once UnusedParameter.Local
        public CtorFixture(int frob)
        {
        }
    }

    [ConditionalFact]
    public void GetDeclaredConstructor_finds_ctor_no_args()
    {
        var constructorInfo = typeof(CtorFixture).GetDeclaredConstructor(null);

        Assert.NotNull(constructorInfo);
        Assert.Empty(constructorInfo.GetParameters());
    }

    [ConditionalFact]
    public void GetDeclaredConstructor_returns_null_when_no_match()
        => Assert.Null(typeof(CtorFixture).GetDeclaredConstructor(new[] { typeof(string) }));

    [ConditionalFact]
    public void GetDeclaredConstructor_finds_ctor_args()
    {
        var constructorInfo = typeof(CtorFixture).GetDeclaredConstructor(new[] { typeof(int) });

        Assert.NotNull(constructorInfo);
        Assert.Single(constructorInfo.GetParameters());
    }

    [ConditionalFact]
    public void IsNullableType_when_value_or_nullable_type()
    {
        Assert.True(typeof(string).IsNullableType());
        Assert.False(typeof(int).IsNullableType());
        Assert.False(typeof(Guid).IsNullableType());
        Assert.True(typeof(int?).IsNullableType());
    }

    [ConditionalFact]
    public void Element_type_should_return_input_type_when_not_sequence_type()
        => Assert.Equal(typeof(string), typeof(string));

    [ConditionalFact]
    public void Get_any_property_returns_any_property()
    {
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""ElDiabloEnElOjo"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""ANightIn"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""MySister"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""TinyTears"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""SnowyInFSharpMinor"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""Seaweed"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""VertrauenII"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""TalkToMe"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""NoMoreAffairs"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""Singing"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""TravellingLight"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""CherryBlossoms"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""ShesGone"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""Mistakes"").DeclaringType);
        Assert.Null(typeof(TindersticksII).GetAnyProperty(""VertrauenIII""));
        Assert.Same(typeof(TindersticksII), typeof(TindersticksII).GetAnyProperty(""SleepySong"").DeclaringType);

        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""ElDiabloEnElOjo"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""ANightIn"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""MySister"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""TinyTears"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""SnowyInFSharpMinor"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""Seaweed"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""VertrauenII"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""TalkToMe"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""NoMoreAffairs"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""Singing"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""TravellingLight"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""CherryBlossoms"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""ShesGone"").DeclaringType);
        Assert.Same(typeof(TindersticksII), typeof(TindersticksIIVinyl).GetAnyProperty(""Mistakes"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIIVinyl).GetAnyProperty(""VertrauenIII"").DeclaringType);
        Assert.Throws<AmbiguousMatchException>(() => typeof(TindersticksIICd).GetAnyProperty(""SleepySong""));

        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""ANightIn"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""MySister"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""TinyTears"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""SnowyInFSharpMinor"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""Seaweed"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""VertrauenII"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""TalkToMe"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""NoMoreAffairs"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""Singing"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""TravellingLight"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""CherryBlossoms"").DeclaringType);
        Assert.Same(typeof(TindersticksIIVinyl), typeof(TindersticksIICd).GetAnyProperty(""ShesGone"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""Mistakes"").DeclaringType);
        Assert.Same(typeof(TindersticksIICd), typeof(TindersticksIICd).GetAnyProperty(""VertrauenIII"").DeclaringType);
        Assert.Throws<AmbiguousMatchException>(() => typeof(TindersticksIICd).GetAnyProperty(""SleepySong""));
    }

    public class TindersticksII
    {
        public virtual int ElDiabloEnElOjo { get; set; }
        internal virtual int ANightIn { get; set; }

        // ReSharper disable once UnusedMember.Local
        private int MySister { get; set; }

        protected virtual int TinyTears { get; set; }
        public virtual int SnowyInFSharpMinor { get; private set; }
        public virtual int Seaweed { private get; set; }
        public virtual int VertrauenII { get; protected set; }
        public virtual int TalkToMe { protected get; set; }

        public virtual int NoMoreAffairs
            => 1995;

        public virtual int Singing
        {
            // ReSharper disable once ValueParameterNotUsed
            set { }
        }

        public virtual int TravellingLight { get; set; }
        public int CherryBlossoms { get; set; }
        public int ShesGone { get; set; }
        public virtual int Mistakes { get; set; }
        public int SleepySong { get; set; }
    }

    public class TindersticksIIVinyl : TindersticksII
    {
        public override int ElDiabloEnElOjo { get; set; }
        internal override int ANightIn { get; set; }
        private int MySister { get; set; }
        protected override int TinyTears { get; set; }

        public override int SnowyInFSharpMinor
            => 1995;

        public override int Seaweed
        {
            set { }
        }

        public override int VertrauenII { get; protected set; }
        public override int TalkToMe { protected get; set; }

        public override int NoMoreAffairs
            => 1995;

        public override int Singing
        {
            set { }
        }

        public new virtual int TravellingLight { get; set; }
        public new virtual int CherryBlossoms { get; set; }
        public new int ShesGone { get; set; }
        public virtual int VertrauenIII { get; set; }
        public static new int SleepySong { get; set; }
    }

    public class TindersticksIICd : TindersticksIIVinyl
    {
        internal override int ANightIn { get; set; }
        private int MySister { get; set; }
        protected override int TinyTears { get; set; }

        public override int SnowyInFSharpMinor
            => 1995;

        public override int Seaweed
        {
            set { }
        }

        public override int VertrauenII { get; protected set; }
        public override int TalkToMe { protected get; set; }

        public override int NoMoreAffairs
            => 1995;

        public override int Singing
        {
            set { }
        }

        public override int TravellingLight { get; set; }
        public override int CherryBlossoms { get; set; }
        public override int Mistakes { get; set; }
        public override int VertrauenIII { get; set; }
        public static new int SleepySong { get; set; }
    }

    [ConditionalFact]
    public void TryGetElementType_returns_element_type_for_given_interface()
    {
        Assert.Same(typeof(string), typeof(ICollection<string>).TryGetElementType(typeof(ICollection<>)));
        Assert.Same(typeof(Random), typeof(IObservable<Random>).TryGetElementType(typeof(IObservable<>)));
        Assert.Same(typeof(int), typeof(List<int>).TryGetElementType(typeof(IList<>)));
        Assert.Same(
            typeof(Random), typeof(MultipleImplementor<Random, string>).TryGetElementType(typeof(IObservable<>)));
        Assert.Same(typeof(string), typeof(MultipleImplementor<Random, string>).TryGetElementType(typeof(IEnumerable<>)));
    }

    [ConditionalFact]
    public void TryGetElementType_returns_element_type_for_given_class()
    {
        Assert.Same(typeof(string), typeof(Collection<string>).TryGetElementType(typeof(Collection<>)));
        Assert.Same(typeof(int), typeof(List<int>).TryGetElementType(typeof(List<>)));
    }

    [ConditionalFact]
    public void TryGetElementType_returns_null_if_type_is_generic_type_definition()
        => Assert.Null(typeof(ICollection<>).TryGetElementType(typeof(ICollection<>)));

    [ConditionalFact]
    public void TryGetElementType_returns_null_if_type_doesnt_implement_interface()
    {
        Assert.Null(typeof(ICollection<string>).TryGetElementType(typeof(IObservable<>)));
        Assert.Null(typeof(Random).TryGetElementType(typeof(IObservable<>)));
    }

    [ConditionalFact]
    public void TryGetElementType_returns_null_if_type_doesnt_implement_class()
    {
        Assert.Null(typeof(ICollection<string>).TryGetElementType(typeof(List<>)));
        Assert.Null(typeof(Random).TryGetElementType(typeof(Collection<>)));
    }

    // CodePlex 2014
    [ConditionalFact]
    public void TryGetElementType_returns_null_when_ICollection_implemented_more_than_once()
        => Assert.Null(typeof(RoleCollection2014).TryGetElementType(typeof(ICollection<>)));

    private class MultipleImplementor<TRandom, TElement> : IObservable<TRandom>, IEnumerable<TElement>
        where TRandom : Random
    {
        public IEnumerator<TElement> GetEnumerator()
            => throw new NotImplementedException();

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public IDisposable Subscribe(IObserver<TRandom> observer)
            => throw new NotImplementedException();
    }

    private interface IRole2014
    {
        string Permissions { get; set; }
    }

    private interface IRoleCollection2014 : ICollection<IRole2014>
    {
    }

#pragma warning disable CA1061 // Do not hide base class methods
    private class RoleCollection2014 : List<Role2014>, IRoleCollection2014
    {
        public new IEnumerator<IRole2014> GetEnumerator()
            => throw new NotImplementedException();

        public void Add(IRole2014 item)
            => throw new NotImplementedException();

        public bool Contains(IRole2014 item)
            => throw new NotImplementedException();

        public void CopyTo(IRole2014[] array, int arrayIndex)
            => throw new NotImplementedException();

        public bool Remove(IRole2014 item)
            => throw new NotImplementedException();

        public bool IsReadOnly { get; private set; }
    }
#pragma warning restore CA1061 // Do not hide base class methods

    private class Role2014 : IRole2014
    {
        public int RoleId { get; set; }
        public string Permissions { get; set; }
    }

    [ConditionalFact]
    public void GetBaseTypes_return_all_base_types()
    {
        Assert.Equal(3, typeof(MultipleHierarchy).GetBaseTypes().Count());
        Assert.Contains(typeof(Some), typeof(MultipleHierarchy).GetBaseTypes());
        Assert.Contains(typeof(Base), typeof(MultipleHierarchy).GetBaseTypes());
        Assert.Contains(typeof(object), typeof(MultipleHierarchy).GetBaseTypes());
    }

    [ConditionalFact]
    public void GetBaseTypes_return_empty_if_no_base_type_exists()
        => Assert.False(typeof(object).GetBaseTypes().Any());

    private class MultipleHierarchy : Some
    {
    }

    private class Some : Base
    {
    }

    private class Base
    {
    }

    // ReSharper restore InconsistentNaming

    [ConditionalFact]
    public void Can_get_default_value_for_type()
    {
        Assert.False((bool)typeof(bool).GetDefaultValue());
        Assert.Equal((sbyte)0, typeof(sbyte).GetDefaultValue());
        Assert.Equal((short)0, typeof(short).GetDefaultValue());
        Assert.Equal(0, typeof(int).GetDefaultValue());
        Assert.Equal((long)0, typeof(long).GetDefaultValue());
        Assert.Equal((byte)0, typeof(byte).GetDefaultValue());
        Assert.Equal((ushort)0, typeof(ushort).GetDefaultValue());
        Assert.Equal((uint)0, typeof(uint).GetDefaultValue());
        Assert.Equal((ulong)0, typeof(ulong).GetDefaultValue());
        Assert.Equal((float)0.0, typeof(float).GetDefaultValue());
        Assert.Equal(0.0, typeof(double).GetDefaultValue());
        Assert.Equal((char)0, typeof(char).GetDefaultValue());
#pragma warning disable IDE0034 // Simplify 'default' expression - GetDefaultValue returns object causing inference of default(object)
        Assert.Equal(default(Guid), typeof(Guid).GetDefaultValue());
        Assert.Equal(default(DateTime), typeof(DateTime).GetDefaultValue());
        Assert.Equal(default(DateTimeOffset), typeof(DateTimeOffset).GetDefaultValue());
        Assert.Equal(default(SomeStruct), typeof(SomeStruct).GetDefaultValue());
        Assert.Equal(default(SomeEnum), typeof(SomeEnum).GetDefaultValue());
#pragma warning restore IDE0034 // Simplify 'default' expression
        Assert.Null(typeof(string).GetDefaultValue());
        Assert.Null(typeof(bool?).GetDefaultValue());
        Assert.Null(typeof(sbyte?).GetDefaultValue());
        Assert.Null(typeof(short?).GetDefaultValue());
        Assert.Null(typeof(int?).GetDefaultValue());
        Assert.Null(typeof(long?).GetDefaultValue());
        Assert.Null(typeof(byte?).GetDefaultValue());
        Assert.Null(typeof(ushort?).GetDefaultValue());
        Assert.Null(typeof(uint?).GetDefaultValue());
        Assert.Null(typeof(ulong?).GetDefaultValue());
        Assert.Null(typeof(float?).GetDefaultValue());
        Assert.Null(typeof(double?).GetDefaultValue());
        Assert.Null(typeof(char?).GetDefaultValue());
        Assert.Null(typeof(Guid?).GetDefaultValue());
        Assert.Null(typeof(DateTime?).GetDefaultValue());
        Assert.Null(typeof(DateTimeOffset?).GetDefaultValue());
        Assert.Null(typeof(SomeStruct?).GetDefaultValue());
        Assert.Null(typeof(SomeEnum?).GetDefaultValue());
    }

    private struct SomeStruct
    {
        public int Value1 { get; set; }
        public long Value2 { get; set; }
    }

    private enum SomeEnum
    {
        Default
    }

    [ConditionalFact]
    public void GetConstructibleTypes_works()
    {
        var assembly = MockAssembly.Create(
            typeof(SomeAbstractClass),
            typeof(SomeGenericClass<>),
            typeof(SomeGenericClass<int>),
            typeof(SomeTypeWithoutDefaultCtor));

        var types = assembly.GetConstructibleTypes().Select(t => t.AsType()).ToList();

        Assert.DoesNotContain(typeof(SomeAbstractClass), types);
        Assert.DoesNotContain(typeof(SomeGenericClass<>), types);
        Assert.Contains(typeof(SomeGenericClass<int>), types);
        Assert.Contains(typeof(SomeTypeWithoutDefaultCtor), types);
    }

    private abstract class SomeAbstractClass
    {
    }

    private class SomeGenericClass<T>
    {
    }

    private class SomeTypeWithoutDefaultCtor
    {
        public SomeTypeWithoutDefaultCtor(int value)
        {
        }
    }

    [ConditionalFact]
    public void GetNamespaces_works()
    {
        // Predefined Types
        Assert.Empty(typeof(int).GetNamespaces().ToArray());
        Assert.Equal(new[] { ""System"" }, typeof(Guid).GetNamespaces().ToArray());
        Assert.Equal(new[] { ""System.Collections.Generic"", ""System"" }, typeof(List<Guid>).GetNamespaces().ToArray());

        Assert.Equal(new[] { ""Microsoft.EntityFrameworkCore.Utilities"" }, typeof(A).GetNamespaces().ToArray());
        Assert.Equal(
            new[] { ""System.Collections.Generic"", ""Microsoft.EntityFrameworkCore.Utilities"" },
            typeof(List<A>).GetNamespaces().ToArray());
        Assert.Equal(
            new[] { ""System.Collections.Generic"", ""System"", ""System.Collections.Generic"", ""Microsoft.EntityFrameworkCore.Utilities"" },
            typeof(Dictionary<Version, List<A>>).GetNamespaces().ToArray());

        Assert.Equal(new[] { ""Microsoft.EntityFrameworkCore.Utilities"", ""System"" }, typeof(Outer<Guid>).GetNamespaces().ToArray());
        Assert.Equal(
            new[] { ""Microsoft.EntityFrameworkCore.Utilities"", ""System.Collections.Generic"", ""System"" },
            typeof(Outer<List<Guid>>).GetNamespaces().ToArray());
    }

    private class Outer<T>
    {
    }

    private class A
    {
    }
}",0,439 334 2000 123 91 2001 93 439 492 2002 40 41 123 2003 46 2004 40 478 40 404 41 44 478 40 2005 60 404 62 41 46 2006 40 41 41 59 2003 46 2004 40 478 40 404 41 44 478 40 2007 60 404 62 41 46 2006 40 41 41 59 2003 46 2004 40 478 40 404 41 44 478 40 2008 60 404 62 41 46 2006 40 41 41 59 2003 46 2004 40 478 40 404 41 44 478 40 2009 60 404 62 41 46 2006 40 41 41 59 125 91 2001 93 439 492 2010 40 41 123 2011 46 304 40 478 40 413 41 46 2012 40 41 41 59 2011 46 304 40 478 40 404 41 46 2012 40 41 41 59 2011 46 304 40 478 40 453 41 46 2012 40 41 41 59 2011 46 304 40 478 40 326 41 46 2012 40 41 41 59 2011 46 304 40 478 40 480 41 46 2012 40 41 41 59 2011 46 304 40 478 40 479 41 46 2012 40 41 41 59 2011 46 304 40 478 40 488 41 46 2012 40 41 41 59 2011 46 304 40 478 40 451 41 46 2012 40 41 41 59 2011 46 304 40 478 40 413 63 41 46 2012 40 41 41 59 2011 46 304 40 478 40 404 63 41 46 2012 40 41 41 59 2011 46 304 40 478 40 453 63 41 46 2012 40 41 41 59 2011 46 304 40 478 40 326 63 41 46 2012 40 41 41 59 2011 46 304 40 478 40 413 63 41 46 2012 40 41 41 59 2011 46 304 40 478 40 404 63 41 46 2012 40 41 41 59 2011 46 304 40 478 40 453 63 41 46 2012 40 41 41 59 2011 46 304 40 478 40 326 63 41 46 2012 40 41 41 59 2011 46 302 40 478 40 323 41 46 2012 40 41 41 59 2011 46 302 40 478 40 323 63 41 46 2012 40 41 41 59 2011 46 302 40 478 40 345 41 46 2012 40 41 41 59 2011 46 302 40 478 40 384 41 46 2012 40 41 41 59 2011 46 302 40 478 40 2013 41 46 2012 40 41 41 59 125 439 334 2014 123 439 2014 40 41 123 125 621 439 2014 40 404 2015 41 123 125 125 91 2001 93 439 492 2016 40 41 123 490 2017 61 478 40 2014 41 46 2018 40 424 41 59 2019 46 2020 40 2017 41 59 2019 46 2021 40 2017 46 2022 40 41 41 59 125 91 2001 93 439 492 2023 40 41 619 2024 46 2025 40 478 40 2014 41 46 2026 40 418 91 93 123 478 40 461 41 125 41 41 59 91 2001 93 439 492 2027 40 41 123 490 2028 61 478 40 2014 41 46 2026 40 418 91 93 123 478 40 404 41 125 41 59 2024 46 2029 40 2028 41 59 2024 46 2030 40 2028 46 2031 40 41 41 59 125 91 2001 93 439 492 2032 40 41 123 2024 46 304 40 478 40 461 41 46 2033 40 41 41 59 2024 46 302 40 478 40 404 41 46 2033 40 41 41 59 2024 46 302 40 478 40 2034 41 46 2033 40 41 41 59 2024 46 304 40 478 40 404 63 41 46 2033 40 41 41 59 125 91 2001 93 439 492 2035 40 41 619 2024 46 2036 40 478 40 461 41 44 478 40 461 41 41 59 91 2001 93 439 492 2037 40 41 123 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2025 40 478 40 2039 41 46 2040 40 648 41 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2039 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2039 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2042 41 46 2040 40 648 41 46 2041 41 59 2024 46 2043 60 2044 62 40 40 41 619 478 40 2045 41 46 2040 40 648 41 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2042 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2038 40 478 40 2045 41 44 478 40 2045 41 46 2040 40 648 41 46 2041 41 59 2024 46 2043 60 2044 62 40 40 41 619 478 40 2045 41 46 2040 40 648 41 41 59 125 439 334 2046 123 439 491 404 2047 123 2048 59 2049 59 125 406 491 404 2050 123 2051 59 2052 59 125 621 437 404 2053 123 2054 59 2055 59 125 438 491 404 2056 123 2057 59 2058 59 125 439 491 404 2059 123 2060 59 437 2061 59 125 439 491 404 2062 123 437 2063 59 2064 59 125 439 491 404 2065 123 2066 59 438 2067 59 125 439 491 404 2068 123 438 2069 59 2070 59 125 439 491 404 2071 619 1505 59 439 491 404 2072 123 621 2073 123 125 125 439 491 404 2074 123 2075 59 2076 59 125 439 404 2077 123 2078 59 2079 59 125 439 404 2080 123 2081 59 2082 59 125 439 491 404 2083 123 2084 59 2085 59 125 439 404 2086 123 2087 59 2088 59 125 125 439 334 2089 58 2046 123 439 431 404 2090 123 2091 59 2092 59 125 406 431 404 2093 123 2094 59 2095 59 125 437 404 2096 123 2097 59 2098 59 125 438 431 404 2099 123 2100 59 2101 59 125 439 431 404 2102 619 1505 59 439 431 404 2103 123 2104 123 125 125 439 431 404 2105 123 2106 59 438 2107 59 125 439 431 404 2108 123 438 2109 59 2110 59 125 439 431 404 2111 619 1505 59 439 431 404 2112 123 2113 123 125 125 439 418 491 404 2114 123 2115 59 2116 59 125 439 418 491 404 2117 123 2118 59 2119 59 125 439 418 404 2120 123 2121 59 2122 59 125 439 491 404 2123 123 2124 59 2125 59 125 439 457 418 404 2126 123 2127 59 2128 59 125 125 439 334 2129 58 2089 123 406 431 404 2130 123 2131 59 2132 59 125 437 404 2133 123 2134 59 2135 59 125 438 431 404 2136 123 2137 59 2138 59 125 439 431 404 2139 619 1505 59 439 431 404 2140 123 2141 123 125 125 439 431 404 2142 123 2143 59 438 2144 59 125 439 431 404 2145 123 438 2146 59 2147 59 125 439 431 404 2148 619 1505 59 439 431 404 2149 123 2150 123 125 125 439 431 404 2151 123 2152 59 2153 59 125 439 431 404 2154 123 2155 59 2156 59 125 439 431 404 2157 123 2158 59 2159 59 125 439 431 404 2160 123 2161 59 2162 59 125 439 457 418 404 2163 123 2164 59 2165 59 125 125 91 2001 93 439 492 2166 40 41 123 2024 46 2167 40 478 40 461 41 44 478 40 2168 60 461 62 41 46 2169 40 478 40 2168 60 62 41 41 41 59 2024 46 2167 40 478 40 2170 41 44 478 40 2171 60 2170 62 41 46 2169 40 478 40 2171 60 62 41 41 41 59 2024 46 2167 40 478 40 404 41 44 478 40 2172 60 404 62 41 46 2169 40 478 40 2173 60 62 41 41 41 59 2024 46 2167 40 478 40 2170 41 44 478 40 2174 60 2170 44 461 62 41 46 2169 40 478 40 2171 60 62 41 41 41 59 2024 46 2167 40 478 40 461 41 44 478 40 2174 60 2170 44 461 62 41 46 2169 40 478 40 2175 60 62 41 41 41 59 125 91 2001 93 439 492 2176 40 41 123 2024 46 2177 40 478 40 461 41 44 478 40 2178 60 461 62 41 46 2179 40 478 40 2178 60 62 41 41 41 59 2024 46 2177 40 478 40 404 41 44 478 40 2180 60 404 62 41 46 2179 40 478 40 2180 60 62 41 41 41 59 125 91 2001 93 439 492 2181 40 41 619 2024 46 2025 40 478 40 2182 60 62 41 46 2183 40 478 40 2182 60 62 41 41 41 59 91 2001 93 439 492 2184 40 41 123 2024 46 2025 40 478 40 2182 60 461 62 41 46 2183 40 478 40 2185 60 62 41 41 41 59 2024 46 2025 40 478 40 2186 41 46 2183 40 478 40 2185 60 62 41 41 41 59 125 91 2001 93 439 492 2187 40 41 123 2024 46 2025 40 478 40 2182 60 461 62 41 46 2183 40 478 40 2188 60 62 41 41 41 59 2024 46 2025 40 478 40 2189 41 46 2183 40 478 40 2190 60 62 41 41 41 59 125 621 91 2001 93 439 492 2191 40 41 619 2024 46 2025 40 478 40 2192 41 46 2183 40 478 40 2182 60 62 41 41 41 59 437 334 2193 60 2194 44 2195 62 58 2196 60 2194 62 44 2197 60 2195 62 2198 2194 58 2199 123 439 2200 60 2195 62 2201 40 41 619 469 418 2202 40 41 59 2200 2197 46 2201 40 41 619 2201 40 41 59 439 2203 2204 40 2205 60 2194 62 2206 41 619 469 418 2202 40 41 59 125 437 405 2207 123 461 2208 123 2209 59 2210 59 125 125 437 405 2211 58 2182 60 2207 62 123 125 35 435 2212 2213 2214 621 437 334 2192 58 2215 60 2216 62 44 2211 123 439 418 2217 60 2207 62 2218 40 41 619 469 418 2219 40 41 59 439 492 2220 40 2207 2221 41 619 469 418 2219 40 41 59 439 323 2222 40 2207 2221 41 619 469 418 2219 40 41 59 439 492 2223 40 2207 91 93 310 44 404 2224 41 619 469 418 2219 40 41 59 439 323 2225 40 2207 2221 41 619 469 418 2219 40 41 59 439 323 2226 123 2227 59 437 2228 59 125 125 35 435 2212 2229 2214 621 437 334 2216 58 2207 123 439 404 2230 123 2231 59 2232 59 125 439 461 2233 123 2234 59 2235 59 125 125 91 2001 93 439 492 2236 40 41 123 2024 46 2036 40 1502 44 478 40 2237 41 46 2238 40 41 46 2239 40 41 41 59 2024 46 2240 40 478 40 2241 41 44 478 40 2237 41 46 2238 40 41 41 59 2024 46 2240 40 478 40 2242 41 44 478 40 2237 41 46 2238 40 41 41 59 2024 46 2240 40 478 40 426 41 44 478 40 2237 41 46 2238 40 41 41 59 125 91 2001 93 439 492 2243 40 41 619 2024 46 302 40 478 40 426 41 46 2244 40 41 46 2245 40 41 41 59 437 334 2246 58 2247 123 125 437 334 2247 58 2248 123 125 437 334 2248 123 125 621 91 2001 93 439 492 2249 40 41 123 2024 46 302 40 40 323 41 478 40 323 41 46 2250 40 41 41 59 2024 46 2036 40 40 451 41 1500 44 478 40 451 41 46 2250 40 41 41 59 2024 46 2036 40 40 453 41 1500 44 478 40 453 41 46 2250 40 41 41 59 2024 46 2036 40 1500 44 478 40 404 41 46 2250 40 41 41 59 2024 46 2036 40 40 413 41 1500 44 478 40 413 41 46 2250 40 41 41 59 2024 46 2036 40 40 326 41 1500 44 478 40 326 41 46 2250 40 41 41 59 2024 46 2036 40 40 488 41 1500 44 478 40 488 41 46 2250 40 41 41 59 2024 46 2036 40 40 479 41 1500 44 478 40 479 41 46 2250 40 41 41 59 2024 46 2036 40 40 480 41 1500 44 478 40 480 41 46 2250 40 41 41 59 2024 46 2036 40 40 384 41 1500 44 478 40 384 41 46 2250 40 41 41 59 2024 46 2036 40 1500 44 478 40 356 41 46 2250 40 41 41 59 2024 46 2036 40 40 330 41 1500 44 478 40 330 41 46 2250 40 41 41 59 35 435 2212 2213 2251 621 2024 46 2036 40 349 40 2252 41 44 478 40 2252 41 46 2250 40 41 41 59 2024 46 2036 40 349 40 2253 41 44 478 40 2253 41 46 2250 40 41 41 59 2024 46 2036 40 349 40 2254 41 44 478 40 2254 41 46 2250 40 41 41 59 2024 46 2036 40 349 40 2255 41 44 478 40 2255 41 46 2250 40 41 41 59 2024 46 2036 40 349 40 2256 41 44 478 40 2256 41 46 2250 40 41 41 59 35 435 2212 2229 2251 621 2024 46 2025 40 478 40 461 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 323 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 451 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 453 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 404 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 413 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 326 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 488 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 479 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 480 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 384 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 356 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 330 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 2252 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 2253 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 2254 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 2255 63 41 46 2250 40 41 41 59 2024 46 2025 40 478 40 2256 63 41 46 2250 40 41 41 59 125 437 462 2257 123 439 404 2258 123 2259 59 2260 59 125 439 413 2261 123 2262 59 2263 59 125 125 437 370 2264 123 2265 125 91 2001 93 439 492 2266 40 41 123 490 2267 61 2268 46 2269 40 478 40 2270 41 44 478 40 2271 60 62 41 44 478 40 2271 60 404 62 41 44 478 40 2272 41 41 59 490 2273 61 2267 46 2274 40 41 46 2275 40 2276 619 2276 46 2277 40 41 41 46 2278 40 41 59 2024 46 2279 40 478 40 2270 41 44 2273 41 59 2024 46 2279 40 478 40 2271 60 62 41 44 2273 41 59 2024 46 2280 40 478 40 2271 60 404 62 41 44 2273 41 59 2024 46 2280 40 478 40 2272 41 44 2273 41 59 125 437 305 334 2281 123 125 437 334 2282 60 2283 62 123 125 437 334 2284 123 439 2284 40 404 2285 41 123 125 125 91 2001 93 439 492 2286 40 41 123 621 2024 46 2287 40 478 40 404 41 46 2288 40 41 46 2289 40 41 41 59 2024 46 2036 40 418 91 93 123 648 125 44 478 40 2290 41 46 2288 40 41 46 2289 40 41 41 59 2024 46 2036 40 418 91 93 123 648 44 648 125 44 478 40 2215 60 2290 62 41 46 2288 40 41 46 2289 40 41 41 59 2024 46 2036 40 418 91 93 123 648 125 44 478 40 2291 41 46 2288 40 41 46 2289 40 41 41 59 2024 46 2036 40 418 91 93 123 648 44 648 125 44 478 40 2215 60 2291 62 41 46 2288 40 41 46 2289 40 41 41 59 2024 46 2036 40 418 91 93 123 648 44 648 44 648 44 648 125 44 478 40 2292 60 2293 44 2215 60 2291 640 41 46 2288 40 41 46 2289 40 41 41 59 2024 46 2036 40 418 91 93 123 648 44 648 125 44 478 40 2294 60 2290 62 41 46 2288 40 41 46 2289 40 41 41 59 2024 46 2036 40 418 91 93 123 648 44 648 44 648 125 44 478 40 2294 60 2215 60 2290 640 41 46 2288 40 41 46 2289 40 41 41 59 125 437 334 2295 60 2283 62 123 125 437 334 2296 123 125 125 
70992,C#,"    public class CustomEntityDataAnnotationAttribute : Attribute
    {
        public CustomEntityDataAnnotationAttribute(string argument)
        {
            Argument = argument;
        }

        public virtual string Argument { get; }
    }",0,439 334 2000 58 2001 123 439 2000 40 461 2002 41 123 2003 61 2002 59 125 439 491 461 2004 123 2005 59 125 125 
71202,C#,"    private class CustomValueGenerator : ValueGenerator<int>
    {
        public override int Next(EntityEntry entry)
            => throw new NotImplementedException();

        public override bool GeneratesTemporaryValues
            => false;
    }",0,437 334 2000 58 2001 60 404 62 123 439 431 404 2002 40 2003 2004 41 619 469 418 2005 40 41 59 439 431 323 2006 619 380 59 125 
71328,C#,"    private class EarlyLearningCenter : DbContext
    {
        private readonly IServiceProvider _serviceProvider;

        public EarlyLearningCenter()
        {
            _serviceProvider = InMemoryTestHelpers.Instance.CreateServiceProvider();
        }

        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Sweet>().OwnsOne(
                e => e.Dreams, b =>
                {
                    b.WithOwner(e => e.Sweet);
                    b.OwnsOne(e => e.Are);
                    b.OwnsOne(e => e.Made);
                    b.OwnsOne(e => e.OfThis);
                });

            modelBuilder.Entity<WhoAmI>().HasNoKey();

            modelBuilder
                .Entity<Category>().HasMany(e => e.Products).WithOne(e => e.Category);

            modelBuilder
                .Entity<ProductDetailsTag>().HasOne(e => e.TagDetails).WithOne(e => e.Tag)
                .HasForeignKey<ProductDetailsTagDetails>(e => e.Id);

            modelBuilder
                .Entity<ProductDetails>().HasOne(e => e.Tag).WithOne(e => e.Details)
                .HasForeignKey<ProductDetailsTag>(e => e.Id);

            modelBuilder
                .Entity<Product>().HasOne(e => e.Details).WithOne(e => e.Product)
                .HasForeignKey<ProductDetails>(e => e.Id);

            modelBuilder.Entity<OrderDetails>(
                b =>
                {
                    b.HasKey(
                        e => new { e.OrderId, e.ProductId });
                    b.HasOne(e => e.Order).WithMany(e => e.OrderDetails).HasForeignKey(e => e.OrderId);
                    b.HasOne(e => e.Product).WithMany(e => e.OrderDetails).HasForeignKey(e => e.ProductId);
                });

            modelBuilder.Entity<OptionalProduct>();

            modelBuilder.Entity<PrincipalNN>(
                b =>
                {
                    b.HasOne(e => e.DependentNN)
                        .WithOne(e => e.PrincipalNN)
                        .HasForeignKey<DependentNN>(e => e.Id);

                    b.Property(e => e.Id).ValueGeneratedNever();
                });

            modelBuilder.Entity<DependentNN>().Property(e => e.Id).ValueGeneratedNever();

            modelBuilder.Entity<PrincipalGG>(
                b =>
                {
                    b.HasOne(e => e.DependentGG)
                        .WithOne(e => e.PrincipalGG)
                        .HasForeignKey<DependentGG>(e => e.Id);

                    b.Property(e => e.Id).ValueGeneratedOnAdd();
                });

            modelBuilder.Entity<DependentGG>().Property(e => e.Id).ValueGeneratedOnAdd();

            modelBuilder.Entity<PrincipalNG>(
                b =>
                {
                    b.HasOne(e => e.DependentNG)
                        .WithOne(e => e.PrincipalNG)
                        .HasForeignKey<DependentNG>(e => e.Id);

                    b.Property(e => e.Id).ValueGeneratedNever();
                });

            modelBuilder.Entity<DependentNG>().Property(e => e.Id).HasValueGenerator<DummyValueGenerator>();

            modelBuilder.Entity<PrincipalGN>(
                b =>
                {
                    b.HasOne(e => e.DependentGN)
                        .WithOne(e => e.PrincipalGN)
                        .HasForeignKey<DependentGN>(e => e.Id);

                    b.Property(e => e.Id).ValueGeneratedOnAdd();
                });

            modelBuilder.Entity<DependentGN>().Property(e => e.Id).ValueGeneratedNever();
        }

        private class DummyValueGenerator : ValueGenerator<int>
        {
            private static int _value;

            public override int Next(EntityEntry entry)
                => _value++;

            public override bool GeneratesTemporaryValues
                => false;
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder
                .UseInternalServiceProvider(_serviceProvider)
                .UseInMemoryDatabase(nameof(EarlyLearningCenter));
    }",0,437 334 2000 58 2001 123 437 441 2002 2003 59 439 2000 40 41 123 2003 61 2004 46 2005 46 2006 40 41 59 125 438 406 431 492 2007 40 2008 2009 41 123 2009 46 2010 60 2011 62 40 41 46 2012 40 2013 619 2013 46 2014 44 2015 619 123 2015 46 2016 40 2013 619 2013 46 2011 41 59 2015 46 2012 40 2013 619 2013 46 2017 41 59 2015 46 2012 40 2013 619 2013 46 2018 41 59 2015 46 2012 40 2013 619 2013 46 2019 41 59 125 41 59 2009 46 2010 60 2020 62 40 41 46 2021 40 41 59 2009 46 2010 60 2022 62 40 41 46 2023 40 2013 619 2013 46 2024 41 46 2025 40 2013 619 2013 46 2022 41 59 2009 46 2010 60 2026 62 40 41 46 2027 40 2013 619 2013 46 2028 41 46 2025 40 2013 619 2013 46 2029 41 46 2030 60 2031 62 40 2013 619 2013 46 2032 41 59 2009 46 2010 60 2033 62 40 41 46 2027 40 2013 619 2013 46 2029 41 46 2025 40 2013 619 2013 46 2034 41 46 2030 60 2026 62 40 2013 619 2013 46 2032 41 59 2009 46 2010 60 2035 62 40 41 46 2027 40 2013 619 2013 46 2034 41 46 2025 40 2013 619 2013 46 2035 41 46 2030 60 2033 62 40 2013 619 2013 46 2032 41 59 2009 46 2010 60 2036 62 40 2015 619 123 2015 46 2037 40 2013 619 418 123 2013 46 2038 44 2013 46 2039 125 41 59 2015 46 2027 40 2013 619 2013 46 2040 41 46 2041 40 2013 619 2013 46 2036 41 46 2030 40 2013 619 2013 46 2042 41 59 2015 46 2027 40 2013 619 2013 46 2035 41 46 2041 40 2013 619 2013 46 2036 41 46 2030 40 2013 619 2013 46 2043 41 59 125 41 59 2009 46 2010 60 2044 62 40 41 59 2009 46 2010 60 2045 62 40 2015 619 123 2015 46 2027 40 2013 619 2013 46 2046 41 46 2025 40 2013 619 2013 46 2045 41 46 2030 60 2046 62 40 2013 619 2013 46 2032 41 59 2015 46 2047 40 2013 619 2013 46 2032 41 46 2048 40 41 59 125 41 59 2009 46 2010 60 2049 62 40 41 46 2050 40 2013 619 2013 46 2032 41 46 2051 40 41 59 2009 46 2010 60 2052 62 40 2015 619 123 2015 46 2027 40 2013 619 2013 46 2053 41 46 2025 40 2013 619 2013 46 2052 41 46 2030 60 2053 62 40 2013 619 2013 46 2032 41 59 2015 46 2050 40 2013 619 2013 46 2032 41 46 2054 40 41 59 125 41 59 2009 46 2010 60 2055 62 40 41 46 2050 40 2013 619 2013 46 2032 41 46 2056 40 41 59 2009 46 2010 60 2057 62 40 2015 619 123 2015 46 2027 40 2013 619 2013 46 2058 41 46 2025 40 2013 619 2013 46 2057 41 46 2030 60 2058 62 40 2013 619 2013 46 2032 41 59 2015 46 2050 40 2013 619 2013 46 2032 41 46 2051 40 41 59 125 41 59 2009 46 2010 60 2059 62 40 41 46 2050 40 2013 619 2013 46 2032 41 46 2060 60 2061 62 40 41 59 2009 46 2010 60 2062 62 40 2015 619 123 2015 46 2027 40 2013 619 2013 46 2063 41 46 2025 40 2013 619 2013 46 2062 41 46 2030 60 2063 62 40 2013 619 2013 46 2032 41 59 2015 46 2050 40 2013 619 2013 46 2032 41 46 2056 40 41 59 125 41 59 2009 46 2010 60 2064 62 40 41 46 2050 40 2013 619 2013 46 2032 41 46 2051 40 41 59 125 437 334 2065 58 2066 60 404 62 123 437 457 404 2067 59 439 431 404 2068 40 2069 2070 41 619 2067 637 59 439 431 323 2071 619 380 59 125 438 406 431 492 2072 40 2073 2074 41 619 2074 46 2075 40 2003 41 46 2076 40 2077 40 2000 41 41 59 125 
71329,C#,"    private class Hat
    {
        public Hat(int id)
        {
            Id = id;
        }

        // ReSharper disable once AutoPropertyCanBeMadeGetOnly.Local
        public int Id { get; private set; }

        public string Color { get; set; }

        public int CatId { get; set; }
        public Cat Cat { get; set; }
    }",0,437 334 2000 123 439 2000 40 404 2001 41 123 2002 61 2001 59 125 621 439 404 2003 123 2004 59 437 2005 59 125 439 461 2006 123 2007 59 2008 59 125 439 404 2009 123 2010 59 2011 59 125 439 2012 2012 123 2013 59 2014 59 125 125 
71331,C#,"    private class LikeAZooContext : DbContext
    {
        public LikeAZooContext()
        {
        }

        protected LikeAZooContext(DbContextOptions options)
            : base(options)
        {
        }

        public DbSet<Cat> Cats { get; set; }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder
                .UseInternalServiceProvider(_serviceProvider)
                .UseInMemoryDatabase(nameof(LikeAZooContext));

        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder
                .Entity<Cat>()
                .Property(e => e.Id)
                .HasValueGenerator<InMemoryIntegerValueGenerator<int>>();

            modelBuilder
                .Entity<Hat>()
                .Property(e => e.Id)
                .HasValueGenerator<InMemoryIntegerValueGenerator<int>>();

            modelBuilder.Entity<Mat>(
                b =>
                {
                    b.Property(e => e.Id).HasValueGenerator<InMemoryIntegerValueGenerator<int>>();
                    b.HasMany(e => e.Cats)
                        .WithMany(e => e.Mats)
                        .UsingEntity<CatMat>(
                            ts => ts.HasOne<Cat>().WithMany(),
                            ts => ts.HasOne<Mat>().WithMany())
                        .HasKey(ts => new { ts.CatId, ts.MatId });
                });
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 41 123 125 438 2000 40 2002 2003 41 58 320 40 2003 41 123 125 439 2004 60 2005 62 2006 123 2007 59 2008 59 125 438 406 431 492 2009 40 2010 2011 41 619 2011 46 2012 40 2013 41 46 2014 40 2015 40 2000 41 41 59 438 406 431 492 2016 40 2017 2018 41 123 2018 46 2019 60 2005 62 40 41 46 2020 40 2021 619 2021 46 2022 41 46 2023 60 2024 60 404 640 40 41 59 2018 46 2019 60 2025 62 40 41 46 2020 40 2021 619 2021 46 2022 41 46 2023 60 2024 60 404 640 40 41 59 2018 46 2019 60 2026 62 40 2027 619 123 2027 46 2020 40 2021 619 2021 46 2022 41 46 2023 60 2024 60 404 640 40 41 59 2027 46 2028 40 2021 619 2021 46 2006 41 46 2029 40 2021 619 2021 46 2030 41 46 2031 60 2032 62 40 2033 619 2033 46 2034 60 2005 62 40 41 46 2029 40 41 44 2033 619 2033 46 2034 60 2026 62 40 41 46 2029 40 41 41 46 2035 40 2033 619 418 123 2033 46 2036 44 2033 46 2037 125 41 59 125 41 59 125 125 
71332,C#,"    private class LikeAZooContextPooled : LikeAZooContext
    {
        public LikeAZooContextPooled(DbContextOptions<LikeAZooContextPooled> options)
            : base(options)
        {
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 60 2000 62 2003 41 58 320 40 2003 41 123 125 438 406 431 492 2004 40 2005 2006 41 123 125 125 
71333,C#,"    private class LikeAZooContextSensitive : LikeAZooContext
    {
        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder
                .EnableSensitiveDataLogging()
                .UseInternalServiceProvider(_sensitiveProvider)
                .UseInMemoryDatabase(nameof(LikeAZooContextSensitive));
    }",0,437 334 2000 58 2001 123 438 406 431 492 2002 40 2003 2004 41 619 2004 46 2005 40 41 46 2006 40 2007 41 46 2008 40 2009 40 2000 41 41 59 125 
71614,C#,"    private class SomeTypeWithoutDefaultCtor
    {
        public SomeTypeWithoutDefaultCtor(int value)
        {
        }
    }",0,437 334 2000 123 439 2000 40 404 2001 41 123 125 125 
71685,C#,"    protected class Optional1 : NotifyingEntity
    {
        private int _id;
        private int? _parentId;
        private Root _parent;
        private IEnumerable<Optional2> _children = new ObservableHashSet<Optional2>(LegacyReferenceEqualityComparer.Instance);

        private ICollection<OptionalComposite2> _compositeChildren =
            new ObservableHashSet<OptionalComposite2>(LegacyReferenceEqualityComparer.Instance);

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public int? ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public Root Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public IEnumerable<Optional2> Children
        {
            get => _children;
            set => SetWithNotify(value, ref _children);
        }

        public ICollection<OptionalComposite2> CompositeChildren
        {
            get => _compositeChildren;
            set => SetWithNotify(value, ref _compositeChildren);
        }

        public override bool Equals(object obj)
        {
            var other = obj as Optional1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 404 63 2003 59 437 2004 2005 59 437 2006 60 2007 62 2008 61 418 2009 60 2007 62 40 2010 46 2011 41 59 437 2012 60 2013 62 2014 61 418 2009 60 2013 62 40 2010 46 2011 41 59 439 404 2015 123 2016 619 2002 59 2017 619 2018 40 2019 44 442 2002 41 59 125 439 404 63 2020 123 2021 619 2003 59 2022 619 2023 40 2024 44 442 2003 41 59 125 439 2004 2025 123 2026 619 2005 59 2027 619 2028 40 2029 44 442 2005 41 59 125 439 2006 60 2007 62 2030 123 2031 619 2008 59 2032 619 2033 40 2034 44 442 2008 41 59 125 439 2012 60 2013 62 2035 123 2036 619 2014 59 2037 619 2038 40 2039 44 442 2014 41 59 125 439 431 323 2040 40 426 2041 41 123 490 2042 61 2041 311 2000 59 450 2002 614 2042 634 2015 59 125 439 431 404 2043 40 41 619 2002 59 125 
71686,C#,"    protected class Optional1Derived : Optional1
    {
        public override bool Equals(object obj)
            => base.Equals(obj as Optional1Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71687,C#,"    protected class Optional1MoreDerived : Optional1Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as Optional1MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71689,C#,"    protected class Optional2Derived : Optional2
    {
        public override bool Equals(object obj)
            => base.Equals(obj as Optional2Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71690,C#,"    protected class Optional2MoreDerived : Optional2Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as Optional2MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71692,C#,"    protected class OptionalAk1Derived : OptionalAk1
    {
        public override bool Equals(object obj)
            => base.Equals(obj as OptionalAk1Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71693,C#,"    protected class OptionalAk1MoreDerived : OptionalAk1Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as OptionalAk1MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71695,C#,"    protected class OptionalAk2Derived : OptionalAk2
    {
        public override bool Equals(object obj)
            => base.Equals(obj as OptionalAk2Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71696,C#,"    protected class OptionalAk2MoreDerived : OptionalAk2Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as OptionalAk2MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71697,C#,"    protected class OptionalComposite2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private int? _parentId;
        private int? _parent2Id;
        private OptionalAk1 _parent;
        private Optional1 _parent2;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid ParentAlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public int? ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public OptionalAk1 Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public int? Parent2Id
        {
            get => _parent2Id;
            set => SetWithNotify(value, ref _parent2Id);
        }

        public Optional1 Parent2
        {
            get => _parent2;
            set => SetWithNotify(value, ref _parent2);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalComposite2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 404 63 2005 59 437 404 63 2006 59 437 2007 2008 59 437 2009 2010 59 439 404 2011 123 2012 619 2002 59 2013 619 2014 40 2015 44 442 2002 41 59 125 439 2003 2016 123 2017 619 2004 59 2018 619 2019 40 2020 44 442 2004 41 59 125 439 404 63 2021 123 2022 619 2005 59 2023 619 2024 40 2025 44 442 2005 41 59 125 439 2007 2026 123 2027 619 2008 59 2028 619 2029 40 2030 44 442 2008 41 59 125 439 404 63 2031 123 2032 619 2006 59 2033 619 2034 40 2035 44 442 2006 41 59 125 439 2009 2036 123 2037 619 2010 59 2038 619 2039 40 2040 44 442 2010 41 59 125 439 431 323 2041 40 426 2042 41 123 490 2043 61 2042 311 2000 59 450 2002 614 2043 634 2011 59 125 439 431 404 2044 40 41 619 2002 59 125 
71700,C#,"    protected class OptionalSingle1Derived : OptionalSingle1
    {
        private int? _derivedRootId;
        private Root _derivedRoot;

        public int? DerivedRootId
        {
            get => _derivedRootId;
            set => SetWithNotify(value, ref _derivedRootId);
        }

        public Root DerivedRoot
        {
            get => _derivedRoot;
            set => SetWithNotify(value, ref _derivedRoot);
        }

        public override bool Equals(object obj)
            => base.Equals(obj as OptionalSingle1Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 437 404 63 2002 59 437 2003 2004 59 439 404 63 2005 123 2006 619 2002 59 2007 619 2008 40 2009 44 442 2002 41 59 125 439 2003 2010 123 2011 619 2004 59 2012 619 2013 40 2014 44 442 2004 41 59 125 439 431 323 2015 40 426 2016 41 619 320 46 2015 40 2016 311 2000 41 59 439 431 404 2017 40 41 619 320 46 2017 40 41 59 125 
71706,C#,"    protected class OptionalSingleAk1Derived : OptionalSingleAk1
    {
        private Guid? _derivedRootId;
        private Root _derivedRoot;

        public Guid? DerivedRootId
        {
            get => _derivedRootId;
            set => SetWithNotify(value, ref _derivedRootId);
        }

        public Root DerivedRoot
        {
            get => _derivedRoot;
            set => SetWithNotify(value, ref _derivedRoot);
        }

        public override bool Equals(object obj)
            => base.Equals(obj as OptionalSingleAk1Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 437 2002 63 2003 59 437 2004 2005 59 439 2002 63 2006 123 2007 619 2003 59 2008 619 2009 40 2010 44 442 2003 41 59 125 439 2004 2011 123 2012 619 2005 59 2013 619 2014 40 2015 44 442 2005 41 59 125 439 431 323 2016 40 426 2017 41 619 320 46 2016 40 2017 311 2000 41 59 439 431 404 2018 40 41 619 320 46 2018 40 41 59 125 
71707,C#,"    protected class OptionalSingleAk1MoreDerived : OptionalSingleAk1Derived
    {
        private Guid? _moreDerivedRootId;
        private Root _moreDerivedRoot;

        public Guid? MoreDerivedRootId
        {
            get => _moreDerivedRootId;
            set => SetWithNotify(value, ref _moreDerivedRootId);
        }

        public Root MoreDerivedRoot
        {
            get => _moreDerivedRoot;
            set => SetWithNotify(value, ref _moreDerivedRoot);
        }

        public override bool Equals(object obj)
            => base.Equals(obj as OptionalSingleAk1MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 437 2002 63 2003 59 437 2004 2005 59 439 2002 63 2006 123 2007 619 2003 59 2008 619 2009 40 2010 44 442 2003 41 59 125 439 2004 2011 123 2012 619 2005 59 2013 619 2014 40 2015 44 442 2005 41 59 125 439 431 323 2016 40 426 2017 41 619 320 46 2016 40 2017 311 2000 41 59 439 431 404 2018 40 41 619 320 46 2018 40 41 59 125 
71710,C#,"    protected class OptionalSingleAk2MoreDerived : OptionalSingleAk2Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as OptionalSingleAk2MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71717,C#,"    protected class Required2MoreDerived : Required2Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as Required2MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71713,C#,"    protected class Required1Derived : Required1
    {
        public override bool Equals(object obj)
            => base.Equals(obj as Required1Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71714,C#,"    protected class Required1MoreDerived : Required1Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as Required1MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71715,C#,"    protected class Required2 : NotifyingEntity
    {
        private int _id;
        private int _parentId;
        private Required1 _parent;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public int ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public Required1 Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public override bool Equals(object obj)
        {
            var other = obj as Required2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 404 2003 59 437 2004 2005 59 439 404 2006 123 2007 619 2002 59 2008 619 2009 40 2010 44 442 2002 41 59 125 439 404 2011 123 2012 619 2003 59 2013 619 2014 40 2015 44 442 2003 41 59 125 439 2004 2016 123 2017 619 2005 59 2018 619 2019 40 2020 44 442 2005 41 59 125 439 431 323 2021 40 426 2022 41 123 490 2023 61 2022 311 2000 59 450 2002 614 2023 634 2006 59 125 439 431 404 2024 40 41 619 2002 59 125 
71719,C#,"    protected class RequiredAk1Derived : RequiredAk1
    {
        public override bool Equals(object obj)
            => base.Equals(obj as RequiredAk1Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71721,C#,"    protected class RequiredAk2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid _parentId;
        private RequiredAk1 _parent;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public RequiredAk1 Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredAk2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 2003 2013 123 2014 619 2004 59 2015 619 2016 40 2017 44 442 2004 41 59 125 439 2003 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71723,C#,"    protected class RequiredAk2MoreDerived : RequiredAk2Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as RequiredAk2MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71726,C#,"    protected class RequiredNonPkSingle1 : NotifyingEntity
    {
        private int _id;
        private int _rootId;
        private Root _root;
        private RequiredNonPkSingle2 _single;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public int RootId
        {
            get => _rootId;
            set => SetWithNotify(value, ref _rootId);
        }

        public Root Root
        {
            get => _root;
            set => SetWithNotify(value, ref _root);
        }

        public RequiredNonPkSingle2 Single
        {
            get => _single;
            set => SetWithNotify(value, ref _single);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredNonPkSingle1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 404 2003 59 437 2004 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 404 2013 123 2014 619 2003 59 2015 619 2016 40 2017 44 442 2003 41 59 125 439 2004 2004 123 2018 619 2005 59 2019 619 2020 40 2021 44 442 2005 41 59 125 439 2006 2022 123 2023 619 2007 59 2024 619 2025 40 2026 44 442 2007 41 59 125 439 431 323 2027 40 426 2028 41 123 490 2029 61 2028 311 2000 59 450 2002 614 2029 634 2008 59 125 439 431 404 2030 40 41 619 2002 59 125 
71727,C#,"    protected class RequiredNonPkSingle1Derived : RequiredNonPkSingle1
    {
        private int _derivedRootId;
        private Root _derivedRoot;

        public int DerivedRootId
        {
            get => _derivedRootId;
            set => SetWithNotify(value, ref _derivedRootId);
        }

        public Root DerivedRoot
        {
            get => _derivedRoot;
            set => SetWithNotify(value, ref _derivedRoot);
        }

        public override bool Equals(object obj)
            => base.Equals(obj as RequiredNonPkSingle1Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 439 404 2005 123 2006 619 2002 59 2007 619 2008 40 2009 44 442 2002 41 59 125 439 2003 2010 123 2011 619 2004 59 2012 619 2013 40 2014 44 442 2004 41 59 125 439 431 323 2015 40 426 2016 41 619 320 46 2015 40 2016 311 2000 41 59 439 431 404 2017 40 41 619 320 46 2017 40 41 59 125 
71730,C#,"    protected class RequiredNonPkSingle2Derived : RequiredNonPkSingle2
    {
        public override bool Equals(object obj)
            => base.Equals(obj as RequiredNonPkSingle2Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71731,C#,"    protected class RequiredNonPkSingle2MoreDerived : RequiredNonPkSingle2Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as RequiredNonPkSingle2MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71732,C#,"    protected class RequiredNonPkSingleAk1 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid _rootId;
        private Root _root;
        private RequiredNonPkSingleAk2 _single;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid RootId
        {
            get => _rootId;
            set => SetWithNotify(value, ref _rootId);
        }

        public Root Root
        {
            get => _root;
            set => SetWithNotify(value, ref _root);
        }

        public RequiredNonPkSingleAk2 Single
        {
            get => _single;
            set => SetWithNotify(value, ref _single);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredNonPkSingleAk1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 2005 59 437 2006 2007 59 437 2008 2009 59 439 404 2010 123 2011 619 2002 59 2012 619 2013 40 2014 44 442 2002 41 59 125 439 2003 2015 123 2016 619 2004 59 2017 619 2018 40 2019 44 442 2004 41 59 125 439 2003 2020 123 2021 619 2005 59 2022 619 2023 40 2024 44 442 2005 41 59 125 439 2006 2006 123 2025 619 2007 59 2026 619 2027 40 2028 44 442 2007 41 59 125 439 2008 2029 123 2030 619 2009 59 2031 619 2032 40 2033 44 442 2009 41 59 125 439 431 323 2034 40 426 2035 41 123 490 2036 61 2035 311 2000 59 450 2002 614 2036 634 2010 59 125 439 431 404 2037 40 41 619 2002 59 125 
71734,C#,"    protected class RequiredNonPkSingleAk1MoreDerived : RequiredNonPkSingleAk1Derived
    {
        private Guid _moreDerivedRootId;
        private Root _moreDerivedRoot;

        public Guid MoreDerivedRootId
        {
            get => _moreDerivedRootId;
            set => SetWithNotify(value, ref _moreDerivedRootId);
        }

        public Root MoreDerivedRoot
        {
            get => _moreDerivedRoot;
            set => SetWithNotify(value, ref _moreDerivedRoot);
        }

        public override bool Equals(object obj)
            => base.Equals(obj as RequiredNonPkSingleAk1MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 437 2002 2003 59 437 2004 2005 59 439 2002 2006 123 2007 619 2003 59 2008 619 2009 40 2010 44 442 2003 41 59 125 439 2004 2011 123 2012 619 2005 59 2013 619 2014 40 2015 44 442 2005 41 59 125 439 431 323 2016 40 426 2017 41 619 320 46 2016 40 2017 311 2000 41 59 439 431 404 2018 40 41 619 320 46 2018 40 41 59 125 
71736,C#,"    protected class RequiredNonPkSingleAk2Derived : RequiredNonPkSingleAk2
    {
        public override bool Equals(object obj)
            => base.Equals(obj as RequiredNonPkSingleAk2Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71739,C#,"    protected class RequiredSingle2 : NotifyingEntity
    {
        private int _id;
        private bool _bool;
        private RequiredSingle1 _back;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public bool Bool
        {
            get => _bool;
            set => SetWithNotify(value, ref _bool);
        }

        public RequiredSingle1 Back
        {
            get => _back;
            set => SetWithNotify(value, ref _back);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredSingle2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 323 2003 59 437 2004 2005 59 439 404 2006 123 2007 619 2002 59 2008 619 2009 40 2010 44 442 2002 41 59 125 439 323 2011 123 2012 619 2003 59 2013 619 2014 40 2015 44 442 2003 41 59 125 439 2004 2016 123 2017 619 2005 59 2018 619 2019 40 2020 44 442 2005 41 59 125 439 431 323 2021 40 426 2022 41 123 490 2023 61 2022 311 2000 59 450 2002 614 2023 634 2006 59 125 439 431 404 2024 40 41 619 2002 59 125 
71740,C#,"    protected class RequiredSingleAk1 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid _rootId;
        private Root _root;
        private RequiredSingleAk2 _single;
        private RequiredSingleComposite2 _singleComposite;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid RootId
        {
            get => _rootId;
            set => SetWithNotify(value, ref _rootId);
        }

        public Root Root
        {
            get => _root;
            set => SetWithNotify(value, ref _root);
        }

        public RequiredSingleAk2 Single
        {
            get => _single;
            set => SetWithNotify(value, ref _single);
        }

        public RequiredSingleComposite2 SingleComposite
        {
            get => _singleComposite;
            set => SetWithNotify(value, ref _singleComposite);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredSingleAk1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 2005 59 437 2006 2007 59 437 2008 2009 59 437 2010 2011 59 439 404 2012 123 2013 619 2002 59 2014 619 2015 40 2016 44 442 2002 41 59 125 439 2003 2017 123 2018 619 2004 59 2019 619 2020 40 2021 44 442 2004 41 59 125 439 2003 2022 123 2023 619 2005 59 2024 619 2025 40 2026 44 442 2005 41 59 125 439 2006 2006 123 2027 619 2007 59 2028 619 2029 40 2030 44 442 2007 41 59 125 439 2008 2031 123 2032 619 2009 59 2033 619 2034 40 2035 44 442 2009 41 59 125 439 2010 2036 123 2037 619 2011 59 2038 619 2039 40 2040 44 442 2011 41 59 125 439 431 323 2041 40 426 2042 41 123 490 2043 61 2042 311 2000 59 450 2002 614 2043 634 2012 59 125 439 431 404 2044 40 41 619 2002 59 125 
72007,C#,"    public class NonGenericStringOneToOneType : OneToOneTestBase
    {
        protected override TestModelBuilder CreateTestModelBuilder(
            TestHelpers testHelpers,
            Action<ModelConfigurationBuilder>? configure)
            => new NonGenericStringTestModelBuilder(testHelpers, configure);
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 40 2004 2005 44 2006 60 2007 62 63 2008 41 619 418 2009 40 2005 44 2008 41 59 125 
72009,C#,"    private class NonGenericStringTestEntityTypeBuilder<TEntity> : NonGenericTestEntityTypeBuilder<TEntity>
        where TEntity : class
    {
        public NonGenericStringTestEntityTypeBuilder(EntityTypeBuilder entityTypeBuilder)
            : base(entityTypeBuilder)
        {
        }

        protected override NonGenericTestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder entityTypeBuilder)
            => new NonGenericStringTestEntityTypeBuilder<TEntity>(entityTypeBuilder);

        public override TestOwnedNavigationBuilder<TEntity, TRelatedEntity> OwnsOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>> navigationExpression)
            where TRelatedEntity : class
            => new NonGenericStringTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.OwnsOne(
                    typeof(TRelatedEntity).FullName!, navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestEntityTypeBuilder<TEntity> OwnsOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TEntity, TRelatedEntity>> buildAction)
            where TRelatedEntity : class
            => Wrap(
                EntityTypeBuilder.OwnsOne(
                    typeof(TRelatedEntity).FullName!,
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(new NonGenericStringTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));

        public override TestOwnedNavigationBuilder<TEntity, TRelatedEntity> OwnsMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>> navigationExpression)
            where TRelatedEntity : class
            => new NonGenericTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.OwnsMany(
                    typeof(TRelatedEntity).FullName!,
                    navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestEntityTypeBuilder<TEntity> OwnsMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TEntity, TRelatedEntity>> buildAction)
            where TRelatedEntity : class
            => Wrap(
                EntityTypeBuilder.OwnsMany(
                    typeof(TRelatedEntity).FullName!,
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(new NonGenericTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));

        public override TestReferenceNavigationBuilder<TEntity, TRelatedEntity> HasOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>>? navigationExpression = null)
            where TRelatedEntity : class
            => new NonGenericStringTestReferenceNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.HasOne(
                    typeof(TRelatedEntity).FullName!,
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));

        public override TestCollectionNavigationBuilder<TEntity, TRelatedEntity> HasMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>>? navigationExpression = null)
            where TRelatedEntity : class
            => new NonGenericTestCollectionNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.HasMany(
                    typeof(TRelatedEntity).FullName!,
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));
    }",0,437 334 2000 60 2001 62 58 2002 60 2001 62 2003 2001 58 334 123 439 2000 40 2004 2005 41 58 320 40 2005 41 123 125 438 431 2002 60 2001 62 2006 40 2004 2005 41 619 418 2000 60 2001 62 40 2005 41 59 439 431 2007 60 2001 44 2008 62 2009 60 2008 62 40 2010 60 2011 60 2001 44 2008 63 640 2012 41 2003 2008 58 334 619 418 2013 60 2001 44 2008 62 40 2004 46 2009 40 478 40 2008 41 46 2014 33 44 2012 46 2015 40 41 46 2016 40 41 41 41 59 439 431 2017 60 2001 62 2009 60 2008 62 40 2010 60 2011 60 2001 44 2008 63 640 2012 44 2018 60 2007 60 2001 44 2008 640 2019 41 2003 2008 58 334 619 2006 40 2004 46 2009 40 478 40 2008 41 46 2014 33 44 2012 46 2015 40 41 46 2016 40 41 44 2020 619 2019 40 418 2013 60 2001 44 2008 62 40 2020 41 41 41 41 59 439 431 2007 60 2001 44 2008 62 2021 60 2008 62 40 2010 60 2011 60 2001 44 2022 60 2008 62 63 640 2012 41 2003 2008 58 334 619 418 2023 60 2001 44 2008 62 40 2004 46 2021 40 478 40 2008 41 46 2014 33 44 2012 46 2015 40 41 46 2016 40 41 41 41 59 439 431 2017 60 2001 62 2021 60 2008 62 40 2010 60 2011 60 2001 44 2022 60 2008 62 63 640 2012 44 2018 60 2007 60 2001 44 2008 640 2019 41 2003 2008 58 334 619 2006 40 2004 46 2021 40 478 40 2008 41 46 2014 33 44 2012 46 2015 40 41 46 2016 40 41 44 2020 619 2019 40 418 2023 60 2001 44 2008 62 40 2020 41 41 41 41 59 439 431 2024 60 2001 44 2008 62 2025 60 2008 62 40 2010 60 2011 60 2001 44 2008 63 640 63 2012 61 424 41 2003 2008 58 334 619 418 2026 60 2001 44 2008 62 40 2004 46 2025 40 478 40 2008 41 46 2014 33 44 2012 634 2015 40 41 46 2016 40 41 41 41 59 439 431 2027 60 2001 44 2008 62 2028 60 2008 62 40 2010 60 2011 60 2001 44 2022 60 2008 62 63 640 63 2012 61 424 41 2003 2008 58 334 619 418 2029 60 2001 44 2008 62 40 2004 46 2028 40 478 40 2008 41 46 2014 33 44 2012 634 2015 40 41 46 2016 40 41 41 41 59 125 
72010,C#,"    private class NonGenericStringTestModelBuilder : TestModelBuilder
    {
        public NonGenericStringTestModelBuilder(TestHelpers testHelpers, Action<ModelConfigurationBuilder>? configure)
            : base(testHelpers, configure)
        {
        }

        public override TestEntityTypeBuilder<TEntity> Entity<TEntity>()
            => new NonGenericStringTestEntityTypeBuilder<TEntity>(ModelBuilder.Entity(typeof(TEntity)));

        public override TestEntityTypeBuilder<TEntity> SharedTypeEntity<TEntity>(string name)
            => new NonGenericStringTestEntityTypeBuilder<TEntity>(ModelBuilder.SharedTypeEntity(name, typeof(TEntity)));

        public override TestModelBuilder Entity<TEntity>(Action<TestEntityTypeBuilder<TEntity>> buildAction)
        {
            ModelBuilder.Entity(
                typeof(TEntity),
                e => buildAction(new NonGenericStringTestEntityTypeBuilder<TEntity>(e)));
            return this;
        }

        public override TestModelBuilder SharedTypeEntity<TEntity>(string name, Action<TestEntityTypeBuilder<TEntity>> buildAction)
        {
            ModelBuilder.SharedTypeEntity(
                name,
                typeof(TEntity),
                e => buildAction(new NonGenericStringTestEntityTypeBuilder<TEntity>(e)));
            return this;
        }

        public override TestOwnedEntityTypeBuilder<TEntity> Owned<TEntity>()
            => new NonGenericTestOwnedEntityTypeBuilder<TEntity>(ModelBuilder.Owned(typeof(TEntity)));

        public override TestModelBuilder Ignore<TEntity>()
        {
            ModelBuilder.Ignore(typeof(TEntity));
            return this;
        }

        public override string GetDisplayName(Type entityType)
            => entityType.FullName!;
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 60 2005 62 63 2006 41 58 320 40 2003 44 2006 41 123 125 439 431 2007 60 2008 62 2009 60 2008 62 40 41 619 418 2010 60 2008 62 40 2011 46 2009 40 478 40 2008 41 41 41 59 439 431 2007 60 2008 62 2012 60 2008 62 40 461 2013 41 619 418 2010 60 2008 62 40 2011 46 2012 40 2013 44 478 40 2008 41 41 41 59 439 431 2001 2009 60 2008 62 40 2004 60 2007 60 2008 640 2014 41 123 2011 46 2009 40 478 40 2008 41 44 2015 619 2014 40 418 2010 60 2008 62 40 2015 41 41 41 59 450 467 59 125 439 431 2001 2012 60 2008 62 40 461 2013 44 2004 60 2007 60 2008 640 2014 41 123 2011 46 2012 40 2013 44 478 40 2008 41 44 2016 619 2014 40 418 2010 60 2008 62 40 2016 41 41 41 59 450 467 59 125 439 431 2017 60 2008 62 2018 60 2008 62 40 41 619 418 2019 60 2008 62 40 2011 46 2018 40 478 40 2008 41 41 41 59 439 431 2001 2020 60 2008 62 40 41 123 2011 46 2020 40 478 40 2008 41 41 59 450 467 59 125 439 431 461 2021 40 2022 2023 41 619 2023 46 2024 33 59 125 
72011,C#,"    private class NonGenericStringTestOwnedNavigationBuilder<TEntity, TDependentEntity>
        : NonGenericTestOwnedNavigationBuilder<TEntity, TDependentEntity>
        where TEntity : class
        where TDependentEntity : class
    {
        public NonGenericStringTestOwnedNavigationBuilder(OwnedNavigationBuilder ownedNavigationBuilder)
            : base(ownedNavigationBuilder)
        {
        }

        protected override NonGenericTestOwnedNavigationBuilder<TNewEntity, TNewDependentEntity> Wrap<TNewEntity, TNewDependentEntity>(
            OwnedNavigationBuilder ownedNavigationBuilder)
            => new NonGenericStringTestOwnedNavigationBuilder<TNewEntity, TNewDependentEntity>(ownedNavigationBuilder);

        public override TestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity> OwnsOne<TNewDependentEntity>(
            Expression<Func<TDependentEntity, TNewDependentEntity?>> navigationExpression)
            where TNewDependentEntity : class
            => new NonGenericStringTestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity>(
                OwnedNavigationBuilder.OwnsOne(
                    typeof(TNewDependentEntity).FullName!, navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestOwnedNavigationBuilder<TEntity, TDependentEntity> OwnsOne<TNewDependentEntity>(
            Expression<Func<TDependentEntity, TNewDependentEntity?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity>> buildAction)
            where TNewDependentEntity : class
            => Wrap<TEntity, TDependentEntity>(
                OwnedNavigationBuilder.OwnsOne(
                    typeof(TNewDependentEntity).FullName!,
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(new NonGenericStringTestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity>(r))));

        public override TestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity> OwnsMany<TNewDependentEntity>(
            Expression<Func<TDependentEntity, IEnumerable<TNewDependentEntity>?>> navigationExpression)
            where TNewDependentEntity : class
            => Wrap<TDependentEntity, TNewDependentEntity>(
                OwnedNavigationBuilder.OwnsMany(
                    typeof(TNewDependentEntity).FullName!, navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestOwnedNavigationBuilder<TEntity, TDependentEntity> OwnsMany<TNewDependentEntity>(
            Expression<Func<TDependentEntity, IEnumerable<TNewDependentEntity>?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity>> buildAction)
            where TNewDependentEntity : class
            => Wrap<TEntity, TDependentEntity>(
                OwnedNavigationBuilder.OwnsMany(
                    typeof(TNewDependentEntity).FullName!,
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(Wrap<TDependentEntity, TNewDependentEntity>(r))));

        public override TestReferenceNavigationBuilder<TDependentEntity, TNewDependentEntity> HasOne<TNewDependentEntity>(
            Expression<Func<TDependentEntity, TNewDependentEntity?>>? navigationExpression = null)
            where TNewDependentEntity : class
            => new NonGenericStringTestReferenceNavigationBuilder<TDependentEntity, TNewDependentEntity>(
                OwnedNavigationBuilder.HasOne(
                    typeof(TNewDependentEntity).FullName!, navigationExpression?.GetMemberAccess().GetSimpleMemberName()));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2007 44 2008 62 2009 60 2007 44 2008 62 40 2005 2006 41 619 418 2000 60 2007 44 2008 62 40 2006 41 59 439 431 2010 60 2002 44 2008 62 2011 60 2008 62 40 2012 60 2013 60 2002 44 2008 63 640 2014 41 2004 2008 58 334 619 418 2000 60 2002 44 2008 62 40 2005 46 2011 40 478 40 2008 41 46 2015 33 44 2014 46 2016 40 41 46 2017 40 41 41 41 59 439 431 2010 60 2001 44 2002 62 2011 60 2008 62 40 2012 60 2013 60 2002 44 2008 63 640 2014 44 2018 60 2010 60 2002 44 2008 640 2019 41 2004 2008 58 334 619 2009 60 2001 44 2002 62 40 2005 46 2011 40 478 40 2008 41 46 2015 33 44 2014 46 2016 40 41 46 2017 40 41 44 2020 619 2019 40 418 2000 60 2002 44 2008 62 40 2020 41 41 41 41 59 439 431 2010 60 2002 44 2008 62 2021 60 2008 62 40 2012 60 2013 60 2002 44 2022 60 2008 62 63 640 2014 41 2004 2008 58 334 619 2009 60 2002 44 2008 62 40 2005 46 2021 40 478 40 2008 41 46 2015 33 44 2014 46 2016 40 41 46 2017 40 41 41 41 59 439 431 2010 60 2001 44 2002 62 2021 60 2008 62 40 2012 60 2013 60 2002 44 2022 60 2008 62 63 640 2014 44 2018 60 2010 60 2002 44 2008 640 2019 41 2004 2008 58 334 619 2009 60 2001 44 2002 62 40 2005 46 2021 40 478 40 2008 41 46 2015 33 44 2014 46 2016 40 41 46 2017 40 41 44 2020 619 2019 40 2009 60 2002 44 2008 62 40 2020 41 41 41 41 59 439 431 2023 60 2002 44 2008 62 2024 60 2008 62 40 2012 60 2013 60 2002 44 2008 63 640 63 2014 61 424 41 2004 2008 58 334 619 418 2025 60 2002 44 2008 62 40 2005 46 2024 40 478 40 2008 41 46 2015 33 44 2014 634 2016 40 41 46 2017 40 41 41 41 59 125 
72012,C#,"    private class NonGenericStringTestReferenceCollectionBuilder
    {
        public NonGenericStringTestReferenceCollectionBuilder(ReferenceCollectionBuilder referenceCollectionBuilder)
        {
            ReferenceCollectionBuilder = referenceCollectionBuilder;
        }

        private ReferenceCollectionBuilder ReferenceCollectionBuilder { get; }

        public IMutableForeignKey Metadata
            => ReferenceCollectionBuilder.Metadata;
    }",0,437 334 2000 123 439 2000 40 2001 2002 41 123 2001 61 2002 59 125 437 2001 2001 123 2003 59 125 439 2004 2005 619 2001 46 2005 59 125 
72015,C#,"    private class NonGenericStringTestReferenceReferenceBuilder
    {
        public NonGenericStringTestReferenceReferenceBuilder(ReferenceReferenceBuilder referenceReferenceBuilder)
        {
            ReferenceReferenceBuilder = referenceReferenceBuilder;
        }

        public NonGenericStringTestReferenceReferenceBuilder HasForeignKey(
            string dependentEntityTypeName,
            params string[] foreignKeyPropertyNames)
            => new(
                ReferenceReferenceBuilder.HasForeignKey(dependentEntityTypeName, foreignKeyPropertyNames));

        public NonGenericStringTestReferenceReferenceBuilder HasPrincipalKey(
            string principalEntityTypeName,
            params string[] keyPropertyNames)
            => new(ReferenceReferenceBuilder.HasPrincipalKey(principalEntityTypeName, keyPropertyNames));

        private ReferenceReferenceBuilder ReferenceReferenceBuilder { get; }

        public IMutableForeignKey Metadata
            => ReferenceReferenceBuilder.Metadata;
    }",0,437 334 2000 123 439 2000 40 2001 2002 41 123 2001 61 2002 59 125 439 2000 2003 40 461 2004 44 433 461 91 93 2005 41 619 418 40 2001 46 2003 40 2004 44 2005 41 41 59 439 2000 2006 40 461 2007 44 433 461 91 93 2008 41 619 418 40 2001 46 2006 40 2007 44 2008 41 41 59 437 2001 2001 123 2009 59 125 439 2010 2011 619 2001 46 2011 59 125 
72189,C#,"public class IntegerValueGeneratorTest
{
    [ConditionalFact]
    public void Each_property_gets_its_own_generator()
    {
        var macs = new Mac[4];
        var toasts = new Toast[4];

        using (var context = new PetsContext(""Dance""))
        {
            macs[0] = context.Add(new Mac()).Entity;
            toasts[0] = context.Add(new Toast()).Entity;

            Assert.Equal(1, macs[0].Id);
            Assert.Equal(1, toasts[0].Id);

            macs[1] = context.Add(new Mac()).Entity;
            toasts[1] = context.Add(new Toast()).Entity;

            Assert.Equal(2, macs[1].Id);
            Assert.Equal(2, toasts[1].Id);

            context.SaveChanges();

            Assert.Equal(1, macs[0].Id);
            Assert.Equal(1, toasts[0].Id);
            Assert.Equal(2, macs[1].Id);
            Assert.Equal(2, toasts[1].Id);

            macs[2] = context.Add(new Mac()).Entity;
            toasts[2] = context.Add(new Toast()).Entity;

            Assert.Equal(3, macs[2].Id);
            Assert.Equal(3, toasts[2].Id);

            context.SaveChanges();
        }

        using (var context = new PetsContext(""Dance""))
        {
            macs[3] = context.Add(new Mac()).Entity;
            toasts[3] = context.Add(new Toast()).Entity;

            Assert.Equal(4, macs[3].Id);
            Assert.Equal(4, toasts[3].Id);

            context.SaveChanges();
        }

        Assert.Equal(1, macs[0].Id);
        Assert.Equal(1, toasts[0].Id);
        Assert.Equal(2, macs[1].Id);
        Assert.Equal(2, toasts[1].Id);
        Assert.Equal(3, macs[2].Id);
        Assert.Equal(3, toasts[2].Id);
        Assert.Equal(4, macs[3].Id);
        Assert.Equal(4, toasts[3].Id);

        using (var context = new PetsContext(""Dance""))
        {
            macs = context.Macs.OrderBy(e => e.Id).ToArray();
            toasts = context.CookedBreads.OrderBy(e => e.Id).ToArray();
        }

        Assert.Equal(1, macs[0].Id);
        Assert.Equal(1, toasts[0].Id);
        Assert.Equal(2, macs[1].Id);
        Assert.Equal(2, toasts[1].Id);
        Assert.Equal(3, macs[2].Id);
        Assert.Equal(3, toasts[2].Id);
        Assert.Equal(4, macs[3].Id);
        Assert.Equal(4, toasts[3].Id);
    }

    [ConditionalFact]
    public void Each_property_gets_its_own_generator_with_seeding()
    {
        var macs = new Mac[4];
        var toasts = new Toast[4];

        using (var context = new PetsContextWithData(""Pets II""))
        {
            context.Database.EnsureCreated();

            var savedMacs = context.Macs.OrderBy(e => e.Id).ToList();
            var savedToasts = context.CookedBreads.OrderBy(e => e.Id).ToList();

            Assert.Equal(2, savedMacs.Count);
            Assert.Single(savedToasts);

            Assert.Equal(1, savedMacs[0].Id);
            Assert.Equal(2, savedMacs[1].Id);
            Assert.Equal(1, savedToasts[0].Id);
        }

        using (var context = new PetsContextWithData(""Pets II""))
        {
            macs[0] = context.Add(new Mac()).Entity;
            toasts[0] = context.Add(new Toast()).Entity;

            Assert.Equal(3, macs[0].Id);
            Assert.Equal(2, toasts[0].Id);

            macs[1] = context.Add(new Mac()).Entity;
            toasts[1] = context.Add(new Toast()).Entity;

            Assert.Equal(4, macs[1].Id);
            Assert.Equal(3, toasts[1].Id);

            context.SaveChanges();

            Assert.Equal(3, macs[0].Id);
            Assert.Equal(2, toasts[0].Id);
            Assert.Equal(4, macs[1].Id);
            Assert.Equal(3, toasts[1].Id);

            macs[2] = context.Add(new Mac()).Entity;
            toasts[2] = context.Add(new Toast()).Entity;

            Assert.Equal(5, macs[2].Id);
            Assert.Equal(4, toasts[2].Id);

            context.SaveChanges();
        }

        using (var context = new PetsContextWithData(""Pets II""))
        {
            macs[3] = context.Add(new Mac()).Entity;
            toasts[3] = context.Add(new Toast()).Entity;

            Assert.Equal(6, macs[3].Id);
            Assert.Equal(5, toasts[3].Id);

            context.SaveChanges();
        }

        Assert.Equal(3, macs[0].Id);
        Assert.Equal(2, toasts[0].Id);
        Assert.Equal(4, macs[1].Id);
        Assert.Equal(3, toasts[1].Id);
        Assert.Equal(5, macs[2].Id);
        Assert.Equal(4, toasts[2].Id);
        Assert.Equal(6, macs[3].Id);
        Assert.Equal(5, toasts[3].Id);

        using (var context = new PetsContextWithData(""Pets II""))
        {
            var savedMacs = context.Macs.OrderBy(e => e.Id).ToList();
            var savedToasts = context.CookedBreads.OrderBy(e => e.Id).ToList();

            Assert.Equal(6, savedMacs.Count);
            Assert.Equal(5, savedToasts.Count);

            for (var i = 0; i < 5; i++)
            {
                Assert.Equal(i + 1, savedMacs[i].Id);
                Assert.Equal(i + 1, savedToasts[i].Id);
            }

            Assert.Equal(6, savedMacs[5].Id);
        }
    }

    [ConditionalFact]
    public void Generators_are_associated_with_database_root()
    {
        var serviceProvider1 = new ServiceCollection()
            .AddEntityFrameworkInMemoryDatabase()
            .BuildServiceProvider(validateScopes: true);

        var serviceProvider2 = new ServiceCollection()
            .AddEntityFrameworkInMemoryDatabase()
            .BuildServiceProvider(validateScopes: true);

        var root = new InMemoryDatabaseRoot();

        var macs = new Mac[2];
        var toasts = new Toast[2];

        using (var context = new PetsContext(""Drink"", root, serviceProvider1))
        {
            macs[0] = context.Add(new Mac()).Entity;
            toasts[0] = context.Add(new Toast()).Entity;

            Assert.Equal(1, macs[0].Id);
            Assert.Equal(1, toasts[0].Id);

            context.SaveChanges();
        }

        using (var context = new PetsContext(""Drink"", root, serviceProvider2))
        {
            macs[1] = context.Add(new Mac()).Entity;
            toasts[1] = context.Add(new Toast()).Entity;

            Assert.Equal(2, macs[1].Id);
            Assert.Equal(2, toasts[1].Id);

            context.SaveChanges();
        }

        Assert.Equal(1, macs[0].Id);
        Assert.Equal(1, toasts[0].Id);
        Assert.Equal(2, macs[1].Id);
        Assert.Equal(2, toasts[1].Id);
    }

    [ConditionalFact]
    public void Mixing_explicit_values_with_generated_values_with_care_works()
    {
        var macs = new Mac[4];
        var toasts = new Toast[4];

        using var context = new PetsContext(""Wercs"");
        macs[0] = context.Add(new Mac { Id = 10 }).Entity;
        toasts[0] = context.Add(new Toast { Id = 100 }).Entity;

        context.SaveChanges();

        macs[1] = context.Add(new Mac()).Entity;
        toasts[1] = context.Add(new Toast()).Entity;

        context.SaveChanges();

        Assert.Equal(10, macs[0].Id);
        Assert.Equal(100, toasts[0].Id);
        Assert.Equal(11, macs[1].Id);
        Assert.Equal(101, toasts[1].Id);

        macs[2] = context.Add(new Mac { Id = 20 }).Entity;
        toasts[2] = context.Add(new Toast { Id = 200 }).Entity;

        context.SaveChanges();

        macs[3] = context.Add(new Mac()).Entity;
        toasts[3] = context.Add(new Toast()).Entity;

        context.SaveChanges();

        Assert.Equal(20, macs[2].Id);
        Assert.Equal(200, toasts[2].Id);
        Assert.Equal(21, macs[3].Id);
        Assert.Equal(201, toasts[3].Id);
    }

    [ConditionalFact]
    public void Each_database_gets_its_own_generators()
    {
        var macs = new List<Mac>();
        var toasts = new List<Toast>();

        using (var context = new PetsContext(""Nothing""))
        {
            macs.Add(context.Add(new Mac()).Entity);
            toasts.Add(context.Add(new Toast()).Entity);

            Assert.Equal(1, macs[0].Id);
            Assert.Equal(1, toasts[0].Id);

            context.SaveChanges();
        }

        using (var context = new PetsContext(""Else""))
        {
            macs.Add(context.Add(new Mac()).Entity);
            toasts.Add(context.Add(new Toast()).Entity);

            Assert.Equal(1, macs[1].Id);
            Assert.Equal(1, toasts[1].Id);

            context.SaveChanges();
        }

        Assert.Equal(1, macs[0].Id);
        Assert.Equal(1, toasts[0].Id);
        Assert.Equal(1, macs[1].Id);
        Assert.Equal(1, toasts[1].Id);
    }

    [ConditionalFact]
    public void Each_root_gets_its_own_generators()
    {
        var macs = new List<Mac>();
        var toasts = new List<Toast>();

        using (var context = new PetsContext(""To"", new InMemoryDatabaseRoot()))
        {
            macs.Add(context.Add(new Mac()).Entity);
            toasts.Add(context.Add(new Toast()).Entity);

            Assert.Equal(1, macs[0].Id);
            Assert.Equal(1, toasts[0].Id);

            context.SaveChanges();
        }

        using (var context = new PetsContext(""To"", new InMemoryDatabaseRoot()))
        {
            macs.Add(context.Add(new Mac()).Entity);
            toasts.Add(context.Add(new Toast()).Entity);

            Assert.Equal(1, macs[1].Id);
            Assert.Equal(1, toasts[1].Id);

            context.SaveChanges();
        }

        Assert.Equal(1, macs[0].Id);
        Assert.Equal(1, toasts[0].Id);
        Assert.Equal(1, macs[1].Id);
        Assert.Equal(1, toasts[1].Id);
    }

    [ConditionalFact]
    public void EnsureDeleted_resets_generators()
    {
        var macs = new List<Mac>();
        var toasts = new List<Toast>();

        using (var context = new PetsContext(""Do""))
        {
            macs.Add(context.Add(new Mac()).Entity);
            toasts.Add(context.Add(new Toast()).Entity);

            Assert.Equal(1, macs[0].Id);
            Assert.Equal(1, toasts[0].Id);

            context.SaveChanges();
        }

        using (var context = new PetsContext(""Do""))
        {
            context.Database.EnsureDeleted();

            macs.Add(context.Add(new Mac()).Entity);
            toasts.Add(context.Add(new Toast()).Entity);

            Assert.Equal(1, macs[1].Id);
            Assert.Equal(1, toasts[1].Id);

            context.SaveChanges();
        }

        Assert.Equal(1, macs[0].Id);
        Assert.Equal(1, toasts[0].Id);
        Assert.Equal(1, macs[1].Id);
        Assert.Equal(1, toasts[1].Id);
    }

    private class PetsContext : DbContext
    {
        private readonly string _databaseName;
        private readonly InMemoryDatabaseRoot _root;
        private readonly IServiceProvider _internalServiceProvider;

        public PetsContext(
            string databaseName,
            InMemoryDatabaseRoot root = null,
            IServiceProvider internalServiceProvider = null)
        {
            _databaseName = databaseName;
            _root = root;
            _internalServiceProvider = internalServiceProvider;
        }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseInternalServiceProvider(_internalServiceProvider);

            if (_root == null)
            {
                optionsBuilder.UseInMemoryDatabase(_databaseName);
            }
            else
            {
                optionsBuilder.UseInMemoryDatabase(_databaseName, _root);
            }
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Cat>();
            modelBuilder.Entity<Dog>();
        }

        public DbSet<Toast> CookedBreads { get; set; }
        public DbSet<Olive> Olives { get; set; }
        public DbSet<Mac> Macs { get; set; }
        public DbSet<Smokey> Smokeys { get; set; }
        public DbSet<Alice> Alices { get; set; }
    }

    private class PetsContextWithData : PetsContext
    {
        public PetsContextWithData(
            string databaseName,
            InMemoryDatabaseRoot root = null,
            IServiceProvider internalServiceProvider = null)
            : base(databaseName, root, internalServiceProvider)
        {
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Toast>().HasData(new Toast { Id = 1 });
            modelBuilder.Entity<Mac>().HasData(new Mac { Id = 1 }, new Mac { Id = 2 });
        }
    }

    private class Dog
    {
        public int Id { get; set; }
    }

    private class Toast : Dog
    {
    }

    private class Olive : Dog
    {
    }

    private class Cat
    {
        public int Id { get; set; }
    }

    private class Mac : Cat
    {
    }

    private class Smokey : Cat
    {
    }

    private class Alice : Cat
    {
    }
}",0,439 334 2000 123 91 2001 93 439 492 2002 40 41 123 490 2003 61 418 2004 91 1502 93 59 490 2005 61 418 2006 91 1502 93 59 489 40 490 2007 61 418 2008 40 648 41 41 123 2003 91 1500 93 61 2007 46 2009 40 418 2004 40 41 41 46 2010 59 2005 91 1500 93 61 2007 46 2009 40 418 2006 40 41 41 46 2010 59 2011 46 2012 40 1501 44 2003 91 1500 93 46 2013 41 59 2011 46 2012 40 1501 44 2005 91 1500 93 46 2013 41 59 2003 91 1501 93 61 2007 46 2009 40 418 2004 40 41 41 46 2010 59 2005 91 1501 93 61 2007 46 2009 40 418 2006 40 41 41 46 2010 59 2011 46 2012 40 1502 44 2003 91 1501 93 46 2013 41 59 2011 46 2012 40 1502 44 2005 91 1501 93 46 2013 41 59 2007 46 2014 40 41 59 2011 46 2012 40 1501 44 2003 91 1500 93 46 2013 41 59 2011 46 2012 40 1501 44 2005 91 1500 93 46 2013 41 59 2011 46 2012 40 1502 44 2003 91 1501 93 46 2013 41 59 2011 46 2012 40 1502 44 2005 91 1501 93 46 2013 41 59 2003 91 1502 93 61 2007 46 2009 40 418 2004 40 41 41 46 2010 59 2005 91 1502 93 61 2007 46 2009 40 418 2006 40 41 41 46 2010 59 2011 46 2012 40 1502 44 2003 91 1502 93 46 2013 41 59 2011 46 2012 40 1502 44 2005 91 1502 93 46 2013 41 59 2007 46 2014 40 41 59 125 489 40 490 2007 61 418 2008 40 648 41 41 123 2003 91 1502 93 61 2007 46 2015 40 418 2004 40 41 41 46 2016 59 2005 91 1502 93 61 2007 46 2015 40 418 2006 40 41 41 46 2016 59 2017 46 2018 40 1502 44 2003 91 1502 93 46 2019 41 59 2017 46 2018 40 1502 44 2005 91 1502 93 46 2019 41 59 2007 46 2020 40 41 59 125 2021 46 2022 40 1501 44 2003 91 1500 93 46 2023 41 59 2021 46 2022 40 1501 44 2005 91 1500 93 46 2023 41 59 2021 46 2022 40 1502 44 2003 91 1501 93 46 2023 41 59 2021 46 2022 40 1502 44 2005 91 1501 93 46 2023 41 59 2021 46 2022 40 1502 44 2003 91 1502 93 46 2023 41 59 2021 46 2022 40 1502 44 2005 91 1502 93 46 2023 41 59 2021 46 2022 40 1502 44 2003 91 1502 93 46 2023 41 59 2021 46 2022 40 1502 44 2005 91 1502 93 46 2023 41 59 489 40 490 2007 61 418 2008 40 648 41 41 123 2003 61 2007 46 2024 46 2025 40 2026 619 2026 46 2023 41 46 2027 40 41 59 2005 61 2007 46 2028 46 2025 40 2026 619 2026 46 2023 41 46 2027 40 41 59 125 2021 46 2022 40 1501 44 2003 91 1500 93 46 2023 41 59 2021 46 2022 40 1501 44 2005 91 1500 93 46 2023 41 59 2021 46 2022 40 1502 44 2003 91 1501 93 46 2023 41 59 2021 46 2022 40 1502 44 2005 91 1501 93 46 2023 41 59 2021 46 2022 40 1502 44 2003 91 1502 93 46 2023 41 59 2021 46 2022 40 1502 44 2005 91 1502 93 46 2023 41 59 2021 46 2022 40 1502 44 2003 91 1502 93 46 2023 41 59 2021 46 2022 40 1502 44 2005 91 1502 93 46 2023 41 59 125 91 2001 93 439 492 2029 40 41 123 490 2030 61 418 2031 91 1502 93 59 490 2032 61 418 2033 91 1502 93 59 489 40 490 2034 61 418 2035 40 648 41 41 123 2034 46 2036 46 2037 40 41 59 490 2038 61 2034 46 2039 46 2040 40 2041 619 2041 46 2042 41 46 2043 40 41 59 490 2044 61 2034 46 2045 46 2040 40 2041 619 2041 46 2042 41 46 2043 40 41 59 2046 46 2047 40 1502 44 2038 46 2048 41 59 2046 46 2049 40 2044 41 59 2046 46 2047 40 1501 44 2038 91 1500 93 46 2042 41 59 2046 46 2047 40 1502 44 2038 91 1501 93 46 2042 41 59 2046 46 2047 40 1501 44 2044 91 1500 93 46 2042 41 59 125 489 40 490 2034 61 418 2035 40 648 41 41 123 2030 91 1500 93 61 2034 46 2050 40 418 2031 40 41 41 46 2051 59 2032 91 1500 93 61 2034 46 2050 40 418 2033 40 41 41 46 2051 59 2052 46 2053 40 1502 44 2030 91 1500 93 46 2054 41 59 2052 46 2053 40 1502 44 2032 91 1500 93 46 2054 41 59 2030 91 1501 93 61 2034 46 2050 40 418 2031 40 41 41 46 2051 59 2032 91 1501 93 61 2034 46 2050 40 418 2033 40 41 41 46 2051 59 2052 46 2053 40 1502 44 2030 91 1501 93 46 2054 41 59 2052 46 2053 40 1502 44 2032 91 1501 93 46 2054 41 59 2034 46 2055 40 41 59 2052 46 2053 40 1502 44 2030 91 1500 93 46 2054 41 59 2052 46 2053 40 1502 44 2032 91 1500 93 46 2054 41 59 2052 46 2053 40 1502 44 2030 91 1501 93 46 2054 41 59 2052 46 2053 40 1502 44 2032 91 1501 93 46 2054 41 59 2030 91 1502 93 61 2034 46 2050 40 418 2031 40 41 41 46 2051 59 2032 91 1502 93 61 2034 46 2050 40 418 2033 40 41 41 46 2051 59 2052 46 2053 40 1502 44 2030 91 1502 93 46 2054 41 59 2052 46 2053 40 1502 44 2032 91 1502 93 46 2054 41 59 2034 46 2055 40 41 59 125 489 40 490 2034 61 418 2035 40 648 41 41 123 2030 91 1502 93 61 2034 46 2056 40 418 2031 40 41 41 46 2057 59 2032 91 1502 93 61 2034 46 2056 40 418 2033 40 41 41 46 2057 59 2058 46 2059 40 1502 44 2030 91 1502 93 46 2060 41 59 2058 46 2059 40 1502 44 2032 91 1502 93 46 2060 41 59 2034 46 2061 40 41 59 125 2062 46 2063 40 1502 44 2030 91 1500 93 46 2064 41 59 2062 46 2063 40 1502 44 2032 91 1500 93 46 2064 41 59 2062 46 2063 40 1502 44 2030 91 1501 93 46 2064 41 59 2062 46 2063 40 1502 44 2032 91 1501 93 46 2064 41 59 2062 46 2063 40 1502 44 2030 91 1502 93 46 2064 41 59 2062 46 2063 40 1502 44 2032 91 1502 93 46 2064 41 59 2062 46 2063 40 1502 44 2030 91 1502 93 46 2064 41 59 2062 46 2063 40 1502 44 2032 91 1502 93 46 2064 41 59 489 40 490 2034 61 418 2035 40 648 41 41 123 490 2065 61 2034 46 2066 46 2067 40 2068 619 2068 46 2064 41 46 2069 40 41 59 490 2070 61 2034 46 2071 46 2067 40 2068 619 2068 46 2064 41 46 2069 40 41 59 2062 46 2063 40 1502 44 2065 46 2072 41 59 2062 46 2063 40 1502 44 2070 46 2072 41 59 385 40 490 2073 61 1500 59 2073 60 1502 59 2073 637 41 123 2062 46 2063 40 2073 43 1501 44 2065 91 2073 93 46 2064 41 59 2062 46 2063 40 2073 43 1501 44 2070 91 2073 93 46 2064 41 59 125 2062 46 2063 40 1502 44 2065 91 1502 93 46 2064 41 59 125 125 91 2001 93 439 492 2074 40 41 123 490 2075 61 418 2076 40 41 46 2077 40 41 46 2078 40 2079 58 473 41 59 490 2080 61 418 2076 40 41 46 2077 40 41 46 2078 40 2079 58 473 41 59 490 2081 61 418 2082 40 41 59 490 2083 61 418 2084 91 1502 93 59 490 2085 61 418 2086 91 1502 93 59 489 40 490 2087 61 418 2088 40 648 44 2081 44 2075 41 41 123 2083 91 1500 93 61 2087 46 2089 40 418 2084 40 41 41 46 2090 59 2085 91 1500 93 61 2087 46 2089 40 418 2086 40 41 41 46 2090 59 2091 46 2092 40 1501 44 2083 91 1500 93 46 2093 41 59 2091 46 2092 40 1501 44 2085 91 1500 93 46 2093 41 59 2087 46 2094 40 41 59 125 489 40 490 2087 61 418 2088 40 648 44 2081 44 2080 41 41 123 2083 91 1501 93 61 2087 46 2095 40 418 2084 40 41 41 46 2096 59 2085 91 1501 93 61 2087 46 2095 40 418 2086 40 41 41 46 2096 59 2097 46 2098 40 1502 44 2083 91 1501 93 46 2099 41 59 2097 46 2098 40 1502 44 2085 91 1501 93 46 2099 41 59 2087 46 2100 40 41 59 125 2101 46 2102 40 1501 44 2083 91 1500 93 46 2103 41 59 2101 46 2102 40 1501 44 2085 91 1500 93 46 2103 41 59 2101 46 2102 40 1502 44 2083 91 1501 93 46 2103 41 59 2101 46 2102 40 1502 44 2085 91 1501 93 46 2103 41 59 125 91 2001 93 439 492 2104 40 41 123 490 2105 61 418 2106 91 1502 93 59 490 2107 61 418 2108 91 1502 93 59 489 490 2109 61 418 2110 40 648 41 59 2105 91 1500 93 61 2109 46 2111 40 418 2106 123 2112 61 1502 125 41 46 2113 59 2107 91 1500 93 61 2109 46 2111 40 418 2108 123 2114 61 1503 125 41 46 2113 59 2109 46 2115 40 41 59 2105 91 1501 93 61 2109 46 2111 40 418 2106 40 41 41 46 2113 59 2107 91 1501 93 61 2109 46 2111 40 418 2108 40 41 41 46 2113 59 2109 46 2115 40 41 59 2116 46 2117 40 1502 44 2105 91 1500 93 46 2118 41 59 2116 46 2117 40 1503 44 2107 91 1500 93 46 2118 41 59 2116 46 2117 40 1503 44 2105 91 1501 93 46 2118 41 59 2116 46 2117 40 1504 44 2107 91 1501 93 46 2118 41 59 2105 91 1502 93 61 2109 46 2111 40 418 2106 123 2118 61 1503 125 41 46 2113 59 2107 91 1502 93 61 2109 46 2111 40 418 2108 123 2118 61 1504 125 41 46 2113 59 2109 46 2115 40 41 59 2105 91 1502 93 61 2109 46 2111 40 418 2106 40 41 41 46 2113 59 2107 91 1502 93 61 2109 46 2111 40 418 2108 40 41 41 46 2113 59 2109 46 2115 40 41 59 2116 46 2117 40 1503 44 2105 91 1502 93 46 2118 41 59 2116 46 2117 40 1504 44 2107 91 1502 93 46 2118 41 59 2116 46 2117 40 1503 44 2105 91 1502 93 46 2118 41 59 2116 46 2117 40 1504 44 2107 91 1502 93 46 2118 41 59 125 91 2001 93 439 492 2119 40 41 123 490 2120 61 418 2121 60 2122 62 40 41 59 490 2123 61 418 2121 60 2124 62 40 41 59 489 40 490 2125 61 418 2126 40 648 41 41 123 2120 46 2127 40 2125 46 2127 40 418 2122 40 41 41 46 2128 41 59 2123 46 2127 40 2125 46 2127 40 418 2124 40 41 41 46 2128 41 59 2129 46 2130 40 1501 44 2120 91 1500 93 46 2131 41 59 2129 46 2130 40 1501 44 2123 91 1500 93 46 2131 41 59 2125 46 2132 40 41 59 125 489 40 490 2125 61 418 2126 40 648 41 41 123 2120 46 2133 40 2125 46 2133 40 418 2122 40 41 41 46 2134 41 59 2123 46 2133 40 2125 46 2133 40 418 2124 40 41 41 46 2134 41 59 2135 46 2136 40 1501 44 2120 91 1501 93 46 2137 41 59 2135 46 2136 40 1501 44 2123 91 1501 93 46 2137 41 59 2125 46 2138 40 41 59 125 2139 46 2140 40 1501 44 2120 91 1500 93 46 2141 41 59 2139 46 2140 40 1501 44 2123 91 1500 93 46 2141 41 59 2139 46 2140 40 1501 44 2120 91 1501 93 46 2141 41 59 2139 46 2140 40 1501 44 2123 91 1501 93 46 2141 41 59 125 91 2001 93 439 492 2142 40 41 123 490 2143 61 418 2144 60 2145 62 40 41 59 490 2146 61 418 2144 60 2147 62 40 41 59 489 40 490 2148 61 418 2149 40 648 44 418 2150 40 41 41 41 123 2143 46 2151 40 2148 46 2151 40 418 2145 40 41 41 46 2152 41 59 2146 46 2151 40 2148 46 2151 40 418 2147 40 41 41 46 2152 41 59 2153 46 2154 40 1501 44 2143 91 1500 93 46 2155 41 59 2153 46 2154 40 1501 44 2146 91 1500 93 46 2155 41 59 2148 46 2156 40 41 59 125 489 40 490 2148 61 418 2149 40 648 44 418 2150 40 41 41 41 123 2143 46 2157 40 2148 46 2157 40 418 2145 40 41 41 46 2158 41 59 2146 46 2157 40 2148 46 2157 40 418 2147 40 41 41 46 2158 41 59 2159 46 2160 40 1501 44 2143 91 1501 93 46 2161 41 59 2159 46 2160 40 1501 44 2146 91 1501 93 46 2161 41 59 2148 46 2162 40 41 59 125 2163 46 2164 40 1501 44 2143 91 1500 93 46 2165 41 59 2163 46 2164 40 1501 44 2146 91 1500 93 46 2165 41 59 2163 46 2164 40 1501 44 2143 91 1501 93 46 2165 41 59 2163 46 2164 40 1501 44 2146 91 1501 93 46 2165 41 59 125 91 2001 93 439 492 2166 40 41 123 490 2167 61 418 2168 60 2169 62 40 41 59 490 2170 61 418 2168 60 2171 62 40 41 59 489 40 490 2172 61 418 2173 40 648 41 41 123 2167 46 2174 40 2172 46 2174 40 418 2169 40 41 41 46 2175 41 59 2170 46 2174 40 2172 46 2174 40 418 2171 40 41 41 46 2175 41 59 2176 46 2177 40 1501 44 2167 91 1500 93 46 2178 41 59 2176 46 2177 40 1501 44 2170 91 1500 93 46 2178 41 59 2172 46 2179 40 41 59 125 489 40 490 2172 61 418 2173 40 648 41 41 123 2172 46 2180 46 2181 40 41 59 2167 46 2182 40 2172 46 2182 40 418 2169 40 41 41 46 2183 41 59 2170 46 2182 40 2172 46 2182 40 418 2171 40 41 41 46 2183 41 59 2184 46 2185 40 1501 44 2167 91 1501 93 46 2186 41 59 2184 46 2185 40 1501 44 2170 91 1501 93 46 2186 41 59 2172 46 2187 40 41 59 125 2188 46 2189 40 1501 44 2167 91 1500 93 46 2190 41 59 2188 46 2189 40 1501 44 2170 91 1500 93 46 2190 41 59 2188 46 2189 40 1501 44 2167 91 1501 93 46 2190 41 59 2188 46 2189 40 1501 44 2170 91 1501 93 46 2190 41 59 125 437 334 2191 58 2192 123 437 441 461 2193 59 437 441 2194 2195 59 437 441 2196 2197 59 439 2191 40 461 2198 44 2194 2199 61 424 44 2196 2200 61 424 41 123 2193 61 2198 59 2195 61 2199 59 2197 61 2200 59 125 438 431 492 2201 40 2202 2203 41 123 2203 46 2204 40 2197 41 59 392 40 2195 614 424 41 123 2203 46 2205 40 2193 41 59 125 360 123 2203 46 2206 40 2193 44 2195 41 59 125 125 438 431 492 2207 40 2208 2209 41 123 2209 46 2210 60 2211 62 40 41 59 2209 46 2210 60 2212 62 40 41 59 125 439 2213 60 2214 62 2215 123 2216 59 2217 59 125 439 2213 60 2218 62 2219 123 2220 59 2221 59 125 439 2213 60 2222 62 2223 123 2224 59 2225 59 125 439 2213 60 2226 62 2227 123 2228 59 2229 59 125 439 2213 60 2230 62 2231 123 2232 59 2233 59 125 125 437 334 2234 58 2191 123 439 2234 40 461 2235 44 2236 2237 61 424 44 2238 2239 61 424 41 58 320 40 2235 44 2237 44 2239 41 123 125 438 431 492 2240 40 2241 2242 41 123 320 46 2240 40 2242 41 59 2242 46 2243 60 2244 62 40 41 46 2245 40 418 2244 123 2246 61 1501 125 41 59 2242 46 2243 60 2247 62 40 41 46 2245 40 418 2247 123 2248 61 1501 125 44 418 2247 123 2249 61 1502 125 41 59 125 125 437 334 2250 123 439 404 2251 123 2252 59 2253 59 125 125 437 334 2254 58 2250 123 125 437 334 2255 58 2250 123 125 437 334 2256 123 439 404 2257 123 2258 59 2259 59 125 125 437 334 2260 58 2256 123 125 437 334 2261 58 2256 123 125 437 334 2262 58 2256 123 125 125 
72441,C#,"    private class GenericTypeTestModelBuilder : TestModelBuilder
    {
        public GenericTypeTestModelBuilder(TestHelpers testHelpers, Action<ModelConfigurationBuilder>? configure)
            : base(testHelpers, configure)
        {
        }

        public override TestEntityTypeBuilder<TEntity> Entity<TEntity>()
            => new GenericTypeTestEntityTypeBuilder<TEntity>(ModelBuilder.Entity<TEntity>());

        public override TestEntityTypeBuilder<TEntity> SharedTypeEntity<TEntity>(string name)
            => new GenericTypeTestEntityTypeBuilder<TEntity>(ModelBuilder.SharedTypeEntity<TEntity>(name));

        public override TestModelBuilder Entity<TEntity>(Action<TestEntityTypeBuilder<TEntity>> buildAction)
        {
            ModelBuilder.Entity<TEntity>(
                entityTypeBuilder =>
                    buildAction(new GenericTypeTestEntityTypeBuilder<TEntity>(entityTypeBuilder)));
            return this;
        }

        public override TestModelBuilder SharedTypeEntity<TEntity>(string name, Action<TestEntityTypeBuilder<TEntity>> buildAction)
        {
            ModelBuilder.SharedTypeEntity<TEntity>(
                name,
                entityTypeBuilder =>
                    buildAction(new GenericTypeTestEntityTypeBuilder<TEntity>(entityTypeBuilder)));
            return this;
        }

        public override TestOwnedEntityTypeBuilder<TEntity> Owned<TEntity>()
            => new GenericTestOwnedEntityTypeBuilder<TEntity>(ModelBuilder.Owned<TEntity>());

        public override TestModelBuilder Ignore<TEntity>()
        {
            ModelBuilder.Ignore<TEntity>();
            return this;
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 60 2005 62 63 2006 41 58 320 40 2003 44 2006 41 123 125 439 431 2007 60 2008 62 2009 60 2008 62 40 41 619 418 2010 60 2008 62 40 2011 46 2009 60 2008 62 40 41 41 59 439 431 2007 60 2008 62 2012 60 2008 62 40 461 2013 41 619 418 2010 60 2008 62 40 2011 46 2012 60 2008 62 40 2013 41 41 59 439 431 2001 2009 60 2008 62 40 2004 60 2007 60 2008 640 2014 41 123 2011 46 2009 60 2008 62 40 2015 619 2014 40 418 2010 60 2008 62 40 2015 41 41 41 59 450 467 59 125 439 431 2001 2012 60 2008 62 40 461 2013 44 2004 60 2007 60 2008 640 2014 41 123 2011 46 2012 60 2008 62 40 2013 44 2016 619 2014 40 418 2010 60 2008 62 40 2016 41 41 41 59 450 467 59 125 439 431 2017 60 2008 62 2018 60 2008 62 40 41 619 418 2019 60 2008 62 40 2011 46 2018 60 2008 62 40 41 41 59 439 431 2001 2020 60 2008 62 40 41 123 2011 46 2020 60 2008 62 40 41 59 450 467 59 125 125 
72442,C#,"    private class GenericTypeTestOwnedNavigationBuilder<TEntity, TRelatedEntity>
        : GenericTestOwnedNavigationBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public GenericTypeTestOwnedNavigationBuilder(OwnedNavigationBuilder<TEntity, TRelatedEntity> ownedNavigationBuilder)
            : base(ownedNavigationBuilder)
        {
        }

        protected override GenericTestOwnedNavigationBuilder<TNewEntity, TNewRelatedEntity> Wrap<TNewEntity, TNewRelatedEntity>(
            OwnedNavigationBuilder<TNewEntity, TNewRelatedEntity> ownedNavigationBuilder)
            => new GenericTypeTestOwnedNavigationBuilder<TNewEntity, TNewRelatedEntity>(ownedNavigationBuilder);

        public override TestReferenceNavigationBuilder<TRelatedEntity, TNewRelatedEntity> HasOne<TNewRelatedEntity>(
            Expression<Func<TRelatedEntity, TNewRelatedEntity?>>? navigationExpression = null)
            where TNewRelatedEntity : class
            => new GenericTypeTestReferenceNavigationBuilder<TRelatedEntity, TNewRelatedEntity>(
                OwnedNavigationBuilder.HasOne(navigationExpression));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2007 44 2008 62 2009 60 2007 44 2008 62 40 2005 60 2007 44 2008 62 2006 41 619 418 2000 60 2007 44 2008 62 40 2006 41 59 439 431 2010 60 2002 44 2008 62 2011 60 2008 62 40 2012 60 2013 60 2002 44 2008 63 640 63 2014 61 424 41 2004 2008 58 334 619 418 2015 60 2002 44 2008 62 40 2005 46 2011 40 2014 41 41 59 125 
72629,C#,"        private sealed class FunctionsKeyComparer : IEqualityComparer<(string name, int arity)>
        {
            public static readonly FunctionsKeyComparer Instance = new();

            public bool Equals((string name, int arity) x, (string name, int arity) y)
                => StringComparer.OrdinalIgnoreCase.Equals(x.name, y.name)
                    && x.arity == y.arity;

            public int GetHashCode((string name, int arity) obj)
            {
                var nameHashCode = StringComparer.OrdinalIgnoreCase.GetHashCode(obj.name);
                var arityHashCode = obj.arity.GetHashCode();

                return ((int)(((uint)nameHashCode << 5) | ((uint)nameHashCode >> 27)) + nameHashCode) ^ arityHashCode;
            }
        }",0,437 452 334 2000 58 2001 60 40 461 2002 44 404 2003 41 62 123 439 457 441 2000 2004 61 418 40 41 59 439 323 2005 40 40 461 2002 44 404 2003 41 2006 44 40 461 2002 44 404 2003 41 2007 41 619 2008 46 2009 46 2005 40 2006 46 2002 44 2007 46 2002 41 605 2006 46 2003 614 2007 46 2003 59 439 404 2010 40 40 461 2002 44 404 2003 41 2011 41 123 490 2012 61 2008 46 2009 46 2010 40 2011 46 2002 41 59 490 2013 61 2011 46 2003 46 2010 40 41 59 450 40 40 404 41 40 40 40 479 41 2012 622 1502 41 124 40 40 479 41 2012 640 1503 41 41 43 2012 41 94 2013 59 125 125 
72737,C#,"    private class Child : IComparable<Child>
    {
        public string Name { get; set; }

        public Parent Parent { get; set; }
        public SubChild SubChild { get; set; }
        public ICollection<SubChild> SubChildCollection { get; set; }

        public int CompareTo(Child other)
            => StringComparer.InvariantCulture.Compare(Name, other.Name);

        public override bool Equals(object obj)
        {
            Assert.False(true);
            return false;
        }

        public override int GetHashCode()
        {
            Assert.False(true);
            return base.GetHashCode();
        }

        public static bool operator ==(Child _, Child __)
        {
            Assert.False(true);
            return false;
        }

        public static bool operator !=(Child _, Child __)
        {
            Assert.False(true);
            return true;
        }
    }",0,437 334 2000 58 2001 60 2000 62 123 439 461 2002 123 2003 59 2004 59 125 439 2005 2005 123 2006 59 2007 59 125 439 2008 2008 123 2009 59 2010 59 125 439 2011 60 2008 62 2012 123 2013 59 2014 59 125 439 404 2015 40 2000 2016 41 619 2017 46 2018 46 2019 40 2002 44 2016 46 2002 41 59 439 431 323 2020 40 426 2021 41 123 2022 46 302 40 473 41 59 450 380 59 125 439 431 404 2023 40 41 123 2024 46 302 40 473 41 59 450 320 46 2023 40 41 59 125 439 457 323 427 614 40 2000 2025 44 2000 2026 41 123 2027 46 302 40 473 41 59 450 380 59 125 439 457 323 427 631 40 2000 2025 44 2000 2026 41 123 2028 46 302 40 473 41 59 450 473 59 125 125 
72741,C#,"    private class Info
    {
        public string Title { get; set; }

        public static void OnModelCreating<T>(OwnedNavigationBuilder<T, Info> rob)
            where T : class
            => rob.Property(e => e.Title);
    }",0,437 334 2000 123 439 461 2001 123 2002 59 2003 59 125 439 457 492 2004 60 2005 62 40 2006 60 2005 44 2000 62 2007 41 2008 2005 58 334 619 2007 46 2009 40 2010 619 2010 46 2001 41 59 125 
72745,C#,"    private class ParentPN : IComparable<ParentPN>
    {
        public int Id { get; set; }

        public ChildPN Child1 { get; set; }
        public ChildPN Child2 { get; set; }
        public ICollection<ChildPN> ChildCollection1 { get; set; }
        public ICollection<ChildPN> ChildCollection2 { get; set; }

        public int CompareTo(ParentPN other)
            => Id - other.Id;
    }",0,437 334 2000 58 2001 60 2000 62 123 439 404 2002 123 2003 59 2004 59 125 439 2005 2006 123 2007 59 2008 59 125 439 2005 2009 123 2010 59 2011 59 125 439 2012 60 2005 62 2013 123 2014 59 2015 59 125 439 2012 60 2005 62 2016 123 2017 59 2018 59 125 439 404 2019 40 2000 2020 41 619 2002 45 2020 46 2002 59 125 
72746,C#,"    private class Role : IEquatable<Role>
    {
        private Guid RoleAssignmentId { get; set; }
        public string Value { get; set; }

        public bool Equals(Role other)
            => Value == other.Value;
    }",0,437 334 2000 58 2001 60 2000 62 123 437 2002 2003 123 2004 59 2005 59 125 439 461 2006 123 2007 59 2008 59 125 439 323 2009 40 2000 2010 41 619 2006 614 2010 46 2006 59 125 
72751,C#,"    private class TestCurrencyContext : DbContext
    {
        private readonly string _databaseName;

        public TestCurrencyContext(string databaseName)
        {
            _databaseName = databaseName;
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseInMemoryDatabase(_databaseName);

        public DbSet<TestOrder> TestOrders { get; set; }

        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<TestOrder>().HasKey(o => o.Id);

            modelBuilder.Entity<TestOrderItem>()
                .OwnsOne(
                    oi => oi.Price, ip =>
                    {
                        ip.Property(p => p.Amount).IsRequired();
                        ip.OwnsOne(
                            p => p.Currency, pc =>
                            {
                                pc.Property(c => c.Code).IsRequired();
                                pc.Ignore(c => c.Id);
                                pc.Ignore(c => c.Name);
                                pc.Ignore(c => c.NumericCode);
                            });
                    }).HasKey(oi => oi.Id);
        }
    }",0,437 334 2000 58 2001 123 437 441 461 2002 59 439 2000 40 461 2003 41 123 2002 61 2003 59 125 438 406 431 492 2004 40 2005 2006 41 619 2006 46 2007 40 2002 41 59 439 2008 60 2009 62 2010 123 2011 59 2012 59 125 438 406 431 492 2013 40 2014 2015 41 123 2015 46 2016 60 2009 62 40 41 46 2017 40 2018 619 2018 46 2019 41 59 2015 46 2016 60 2020 62 40 41 46 2021 40 2022 619 2022 46 2023 44 2024 619 123 2024 46 2025 40 2026 619 2026 46 2027 41 46 2028 40 41 59 2024 46 2021 40 2026 619 2026 46 2029 44 2030 619 123 2030 46 2025 40 2031 619 2031 46 2032 41 46 2028 40 41 59 2030 46 2033 40 2031 619 2031 46 2019 41 59 2030 46 2033 40 2031 619 2031 46 2034 41 59 2030 46 2033 40 2031 619 2031 46 2035 41 59 125 41 59 125 41 46 2017 40 2022 619 2022 46 2019 41 59 125 125 
72753,C#,"    private class User
    {
        public Guid UserId { get; set; }

        public IReadOnlyList<Role> Roles
            => _roles.AsReadOnly();

        private readonly List<Role> _roles = new();

        public void SetRoles(IList<Role> roles)
        {
            if (_roles.Count == roles.Count
                && !_roles.Except(roles).Any())
            {
                return;
            }

            _roles.Clear();
            _roles.AddRange(roles.Where(x => x != null).Distinct());
        }
    }",0,437 334 2000 123 439 2001 2002 123 2003 59 2004 59 125 439 2005 60 2006 62 2007 619 2008 46 2009 40 41 59 437 441 2010 60 2006 62 2008 61 418 40 41 59 439 492 2011 40 2012 60 2006 62 2013 41 123 392 40 2008 46 2014 614 2013 46 2014 605 33 2008 46 2015 40 2013 41 46 2016 40 41 41 123 450 59 125 2008 46 2017 40 41 59 2008 46 2018 40 2013 46 2019 40 2020 619 2020 631 424 41 46 2021 40 41 41 59 125 125 
69693,C#,"public class IdValueGenerator : ValueGenerator
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override bool GeneratesTemporaryValues
        => false;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override bool GeneratesStableValues
        => true;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override object NextValue(EntityEntry entry)
    {
        var builder = new StringBuilder();
        var entityType = entry.Metadata;

        var primaryKey = entityType.FindPrimaryKey()!;
        var discriminator = entityType.GetDiscriminatorValue();
        if (discriminator != null
            && !primaryKey.Properties.Contains(entityType.FindDiscriminatorProperty()))
        {
            AppendString(builder, discriminator);
            builder.Append('|');
        }

        var partitionKey = entityType.GetPartitionKeyPropertyName();
        foreach (var property in primaryKey.Properties)
        {
            if (property.Name == partitionKey
                && primaryKey.Properties.Count > 1)
            {
                continue;
            }

            var value = entry.Property(property.Name).CurrentValue;

            var converter = property.GetTypeMapping().Converter;
            if (converter != null)
            {
                value = converter.ConvertToProvider(value);
            }

            AppendString(builder, value);

            builder.Append('|');
        }

        builder.Remove(builder.Length - 1, 1);

        return builder.ToString();
    }

    private static void AppendString(StringBuilder builder, object? propertyValue)
    {
        switch (propertyValue)
        {
            case string stringValue:
                AppendEscape(builder, stringValue);
                return;
            case IEnumerable enumerable:
                foreach (var item in enumerable)
                {
                    AppendEscape(builder, item.ToString()!);
                    builder.Append('|');
                }

                return;
            case DateTime dateTime:
                AppendEscape(builder, dateTime.ToString(""O""));
                return;
            default:
                if (propertyValue == null)
                {
                    builder.Append(""null"");
                }
                else
                {
                    AppendEscape(builder, propertyValue.ToString()!);
                }

                return;
        }
    }

    private static StringBuilder AppendEscape(StringBuilder builder, string stringValue)
    {
        var startingIndex = builder.Length;
        return builder.Append(stringValue)
            // We need this to avoid collisions with the value separator
            .Replace(""|"", ""^|"", startingIndex, builder.Length - startingIndex)
            // These are invalid characters, see https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.documents.resource.id
            .Replace(""/"", ""^2F"", startingIndex, builder.Length - startingIndex)
            .Replace(""\\"", ""^5C"", startingIndex, builder.Length - startingIndex)
            .Replace(""?"", ""^3F"", startingIndex, builder.Length - startingIndex)
            .Replace(""#"", ""^23"", startingIndex, builder.Length - startingIndex);
    }
}",0,439 334 2000 58 2001 123 612 439 431 323 2002 619 380 59 612 439 431 323 2003 619 473 59 612 438 431 426 2004 40 2005 2006 41 123 490 2007 61 418 2008 40 41 59 490 2009 61 2006 46 2010 59 490 2011 61 2009 46 2012 40 41 33 59 490 2013 61 2009 46 2014 40 41 59 392 40 2013 631 424 605 33 2011 46 2015 46 2016 40 2009 46 2017 40 41 41 41 123 2018 40 2007 44 2013 41 59 2007 46 2019 40 607 41 59 125 490 2020 61 2009 46 2021 40 41 59 386 40 490 2022 398 2011 46 2015 41 123 392 40 2022 46 2023 614 2020 605 2011 46 2015 46 2024 62 1501 41 123 344 59 125 490 2025 61 2006 46 2026 40 2022 46 2023 41 46 2027 59 490 2028 61 2022 46 2029 40 41 46 2030 59 392 40 2028 631 424 41 123 2025 61 2028 46 2031 40 2025 41 59 125 2032 40 2007 44 2025 41 59 2007 46 2033 40 607 41 59 125 2007 46 2034 40 2007 46 2035 45 1501 44 1501 41 59 450 2007 46 2036 40 41 59 125 437 457 492 2037 40 2038 2039 44 426 63 2040 41 123 464 40 2040 41 123 328 461 2041 58 2042 40 2039 44 2041 41 59 450 59 328 2043 2044 58 386 40 490 2045 398 2044 41 123 2042 40 2039 44 2045 46 2046 40 41 33 41 59 2039 46 2047 40 607 41 59 125 450 59 328 2048 2049 58 2042 40 2039 44 2049 46 2050 40 648 41 41 59 450 59 349 58 392 40 2040 614 424 41 123 2039 46 2051 40 648 41 59 125 360 123 2042 40 2039 44 2040 46 2050 40 41 33 41 59 125 450 59 125 125 437 457 2038 2052 40 2038 2039 44 461 2053 41 123 490 2054 61 2039 46 2055 59 450 2039 46 2056 40 2053 41 621 46 2057 40 648 44 648 44 2054 44 2039 46 2055 45 2054 41 621 46 2057 40 648 44 648 44 2054 44 2039 46 2055 45 2054 41 46 2057 40 648 44 648 44 2054 44 2039 46 2055 45 2054 41 46 2057 40 648 44 648 44 2054 44 2039 46 2055 45 2054 41 46 2057 40 648 44 648 44 2054 44 2039 46 2055 45 2054 41 59 125 125 
68677,C#,"public class RelationalDatabaseFacadeExtensionsTest
{
    [ConditionalTheory]
    [InlineData(false, false)]
    [InlineData(true, false)]
    [InlineData(true, true)]
    public async Task Can_pass_no_params(bool async, bool cancellation)
    {
        using var context = new ThudContext();
        var commandBuilder = (TestRawSqlCommandBuilder)context.GetService<IRawSqlCommandBuilder>();

        if (async)
        {
            if (cancellation)
            {
                var cancellationToken = new CancellationToken();
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", cancellationToken);
            }
            else
            {
                await context.Database.ExecuteSqlRawAsync(""<Some query>"");
            }
        }
        else
        {
            context.Database.ExecuteSqlRaw(""<Some query>"");
        }

        Assert.Equal(""<Some query>"", commandBuilder.Sql);
        Assert.Equal(new List<object>(), commandBuilder.Parameters);
    }

    [ConditionalTheory]
    [InlineData(false, false)]
    [InlineData(true, false)]
    [InlineData(true, true)]
    public async Task Can_pass_array_of_int_params_as_object(bool async, bool cancellation)
    {
        using var context = new ThudContext();
        var commandBuilder = (TestRawSqlCommandBuilder)context.GetService<IRawSqlCommandBuilder>();

        if (async)
        {
            if (cancellation)
            {
                var cancellationToken = new CancellationToken();
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", new object[] { 1, 2 }, cancellationToken);
            }
            else
            {
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", 1, 2);
            }
        }
        else
        {
            context.Database.ExecuteSqlRaw(""<Some query>"", 1, 2);
        }

        Assert.Equal(""<Some query>"", commandBuilder.Sql);
        Assert.Equal(
            new List<object> { 1, 2 }, commandBuilder.Parameters);
    }

    [ConditionalTheory]
    [InlineData(false)]
    [InlineData(true)]
    public async Task Can_pass_ints_as_params(bool async)
    {
        using var context = new ThudContext();
        var commandBuilder = (TestRawSqlCommandBuilder)context.GetService<IRawSqlCommandBuilder>();

        if (async)
        {
            await context.Database.ExecuteSqlRawAsync(""<Some query>"", 1, 2);
        }
        else
        {
            context.Database.ExecuteSqlRaw(""<Some query>"", 1, 2);
        }

        Assert.Equal(""<Some query>"", commandBuilder.Sql);
        Assert.Equal(
            new List<object> { 1, 2 }, commandBuilder.Parameters);
    }

    [ConditionalTheory]
    [InlineData(false, false)]
    [InlineData(true, false)]
    [InlineData(true, true)]
    public async Task Can_pass_mixed_array_of_params(bool async, bool cancellation)
    {
        using var context = new ThudContext();
        var commandBuilder = (TestRawSqlCommandBuilder)context.GetService<IRawSqlCommandBuilder>();

        if (async)
        {
            if (cancellation)
            {
                var cancellationToken = new CancellationToken();
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", new object[] { 1, ""Cheese"" }, cancellationToken);
            }
            else
            {
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", 1, ""Cheese"");
            }
        }
        else
        {
            context.Database.ExecuteSqlRaw(""<Some query>"", 1, ""Cheese"");
        }

        Assert.Equal(""<Some query>"", commandBuilder.Sql);
        Assert.Equal(
            new List<object> { 1, ""Cheese"" }, commandBuilder.Parameters);
    }

    [ConditionalTheory]
    [InlineData(false, false)]
    [InlineData(true, false)]
    [InlineData(true, true)]
    public async Task Can_pass_list_of_int_params_as_object(bool async, bool cancellation)
    {
        using var context = new ThudContext();
        var commandBuilder = (TestRawSqlCommandBuilder)context.GetService<IRawSqlCommandBuilder>();

        if (async)
        {
            if (cancellation)
            {
                var cancellationToken = new CancellationToken();
                await context.Database.ExecuteSqlRawAsync(
                    ""<Some query>"", new List<object> { 1, 2 }, cancellationToken);
            }
            else
            {
                await context.Database.ExecuteSqlRawAsync(
                    ""<Some query>"", new List<object> { 1, 2 });
            }
        }
        else
        {
            context.Database.ExecuteSqlRaw(
                ""<Some query>"", new List<object> { 1, 2 });
        }

        Assert.Equal(""<Some query>"", commandBuilder.Sql);
        Assert.Equal(
            new List<object> { 1, 2 }, commandBuilder.Parameters);
    }

    [ConditionalTheory]
    [InlineData(false, false)]
    [InlineData(true, false)]
    [InlineData(true, true)]
    public async Task Can_pass_mixed_list_of_params(bool async, bool cancellation)
    {
        using var context = new ThudContext();
        var commandBuilder = (TestRawSqlCommandBuilder)context.GetService<IRawSqlCommandBuilder>();

        if (async)
        {
            if (cancellation)
            {
                var cancellationToken = new CancellationToken();
                await context.Database.ExecuteSqlRawAsync(
                    ""<Some query>"", new List<object> { 1, ""Pickle"" }, cancellationToken);
            }
            else
            {
                await context.Database.ExecuteSqlRawAsync(
                    ""<Some query>"", new List<object> { 1, ""Pickle"" });
            }
        }
        else
        {
            context.Database.ExecuteSqlRaw(
                ""<Some query>"", new List<object> { 1, ""Pickle"" });
        }

        Assert.Equal(""<Some query>"", commandBuilder.Sql);
        Assert.Equal(
            new List<object> { 1, ""Pickle"" }, commandBuilder.Parameters);
    }

    [ConditionalTheory]
    [InlineData(false, false)]
    [InlineData(true, false)]
    [InlineData(true, true)]
    public async Task Can_pass_single_int_as_object(bool async, bool cancellation)
    {
        using var context = new ThudContext();
        var commandBuilder = (TestRawSqlCommandBuilder)context.GetService<IRawSqlCommandBuilder>();

        if (async)
        {
            if (cancellation)
            {
                var cancellationToken = new CancellationToken();
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", new object[] { 1 }, cancellationToken);
            }
            else
            {
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", 1);
            }
        }
        else
        {
            context.Database.ExecuteSqlRaw(""<Some query>"", 1);
        }

        Assert.Equal(""<Some query>"", commandBuilder.Sql);
        Assert.Equal(
            new List<object> { 1 }, commandBuilder.Parameters);
    }

    [ConditionalTheory]
    [InlineData(false, false)]
    [InlineData(true, false)]
    [InlineData(true, true)]
    public async Task Can_pass_single_string(bool async, bool cancellation)
    {
        using var context = new ThudContext();
        var commandBuilder = (TestRawSqlCommandBuilder)context.GetService<IRawSqlCommandBuilder>();

        if (async)
        {
            if (cancellation)
            {
                var cancellationToken = new CancellationToken();
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", new[] { ""Branston"" }, cancellationToken);
            }
            else
            {
                await context.Database.ExecuteSqlRawAsync(""<Some query>"", ""Branston"");
            }
        }
        else
        {
            context.Database.ExecuteSqlRaw(""<Some query>"", ""Branston"");
        }

        Assert.Equal(""<Some query>"", commandBuilder.Sql);
        Assert.Equal(
            new List<object> { ""Branston"" }, commandBuilder.Parameters);
    }

    private class ThudContext : DbContext
    {
        public ThudContext()
            : base(
                RelationalTestHelpers.Instance.CreateOptions(
                    RelationalTestHelpers.Instance.CreateServiceProvider(
                        new ServiceCollection()
                            .AddScoped<IRawSqlCommandBuilder, TestRawSqlCommandBuilder>())))
        {
        }
    }

    private class TestRawSqlCommandBuilder : IRawSqlCommandBuilder
    {
        private readonly IRelationalCommandBuilderFactory _commandBuilderFactory;

        public TestRawSqlCommandBuilder(
            IRelationalCommandBuilderFactory relationalCommandBuilderFactory)
        {
            _commandBuilderFactory = relationalCommandBuilderFactory;
        }

        public string Sql { get; private set; }
        public IEnumerable<object> Parameters { get; private set; }

        public IRelationalCommand Build(string sql)
            => throw new NotImplementedException();

        public RawSqlCommand Build(string sql, IEnumerable<object> parameters)
        {
            Sql = sql;
            Parameters = parameters;

            return new RawSqlCommand(_commandBuilderFactory.Create().Build(), new Dictionary<string, object>());
        }
    }
}",0,439 334 2000 123 91 2001 93 91 2002 40 380 44 380 41 93 91 2002 40 473 44 380 41 93 91 2002 40 473 44 473 41 93 439 314 2003 2004 40 323 314 44 323 2005 41 123 489 490 2006 61 418 2007 40 41 59 490 2008 61 40 2009 41 2006 46 2010 60 2011 62 40 41 59 392 40 314 41 123 392 40 2005 41 123 490 2012 61 418 2013 40 41 59 319 2006 46 2014 46 2015 40 648 44 2012 41 59 125 360 123 319 2006 46 2016 46 2017 40 648 41 59 125 125 360 123 2006 46 2018 46 2019 40 648 41 59 125 2020 46 2021 40 648 44 2008 46 2022 41 59 2020 46 2021 40 418 2023 60 426 62 40 41 44 2008 46 2024 41 59 125 91 2001 93 91 2002 40 380 44 380 41 93 91 2002 40 473 44 380 41 93 91 2002 40 473 44 473 41 93 439 314 2003 2025 40 323 314 44 323 2005 41 123 489 490 2026 61 418 2027 40 41 59 490 2028 61 40 2029 41 2026 46 2030 60 2031 62 40 41 59 392 40 314 41 123 392 40 2005 41 123 490 2032 61 418 2033 40 41 59 319 2026 46 2034 46 2035 40 648 44 418 426 91 93 123 1501 44 1502 125 44 2032 41 59 125 360 123 319 2026 46 2036 46 2037 40 648 44 1501 44 1502 41 59 125 125 360 123 2026 46 2038 46 2039 40 648 44 1501 44 1502 41 59 125 2040 46 2041 40 648 44 2028 46 2042 41 59 2040 46 2041 40 418 2043 60 426 62 123 1501 44 1502 125 44 2028 46 2044 41 59 125 91 2001 93 91 2002 40 380 41 93 91 2002 40 473 41 93 439 314 2003 2045 40 323 314 41 123 489 490 2046 61 418 2047 40 41 59 490 2048 61 40 2049 41 2046 46 2050 60 2051 62 40 41 59 392 40 314 41 123 319 2046 46 2052 46 2053 40 648 44 1501 44 1502 41 59 125 360 123 2046 46 2054 46 2055 40 648 44 1501 44 1502 41 59 125 2056 46 2057 40 648 44 2048 46 2058 41 59 2056 46 2057 40 418 2059 60 426 62 123 1501 44 1502 125 44 2048 46 2060 41 59 125 91 2001 93 91 2002 40 380 44 380 41 93 91 2002 40 473 44 380 41 93 91 2002 40 473 44 473 41 93 439 314 2003 2061 40 323 314 44 323 2005 41 123 489 490 2062 61 418 2063 40 41 59 490 2064 61 40 2065 41 2062 46 2066 60 2067 62 40 41 59 392 40 314 41 123 392 40 2005 41 123 490 2068 61 418 2069 40 41 59 319 2062 46 2070 46 2071 40 648 44 418 426 91 93 123 1501 44 648 125 44 2068 41 59 125 360 123 319 2062 46 2072 46 2073 40 648 44 1501 44 648 41 59 125 125 360 123 2062 46 2074 46 2075 40 648 44 1501 44 648 41 59 125 2076 46 2077 40 648 44 2064 46 2078 41 59 2076 46 2077 40 418 2079 60 426 62 123 1501 44 648 125 44 2064 46 2080 41 59 125 91 2001 93 91 2002 40 380 44 380 41 93 91 2002 40 473 44 380 41 93 91 2002 40 473 44 473 41 93 439 314 2003 2081 40 323 314 44 323 2005 41 123 489 490 2082 61 418 2083 40 41 59 490 2084 61 40 2085 41 2082 46 2086 60 2087 62 40 41 59 392 40 314 41 123 392 40 2005 41 123 490 2088 61 418 2089 40 41 59 319 2082 46 2090 46 2091 40 648 44 418 2092 60 426 62 123 1501 44 1502 125 44 2088 41 59 125 360 123 319 2082 46 2093 46 2094 40 648 44 418 2095 60 426 62 123 1501 44 1502 125 41 59 125 125 360 123 2082 46 2096 46 2097 40 648 44 418 2098 60 426 62 123 1501 44 1502 125 41 59 125 2099 46 2100 40 648 44 2084 46 2101 41 59 2099 46 2100 40 418 2102 60 426 62 123 1501 44 1502 125 44 2084 46 2103 41 59 125 91 2001 93 91 2002 40 380 44 380 41 93 91 2002 40 473 44 380 41 93 91 2002 40 473 44 473 41 93 439 314 2003 2104 40 323 314 44 323 2005 41 123 489 490 2105 61 418 2106 40 41 59 490 2107 61 40 2108 41 2105 46 2109 60 2110 62 40 41 59 392 40 314 41 123 392 40 2005 41 123 490 2111 61 418 2112 40 41 59 319 2105 46 2113 46 2114 40 648 44 418 2115 60 426 62 123 1501 44 648 125 44 2111 41 59 125 360 123 319 2105 46 2116 46 2117 40 648 44 418 2118 60 426 62 123 1501 44 648 125 41 59 125 125 360 123 2105 46 2119 46 2120 40 648 44 418 2121 60 426 62 123 1501 44 648 125 41 59 125 2122 46 2123 40 648 44 2107 46 2124 41 59 2122 46 2123 40 418 2125 60 426 62 123 1501 44 648 125 44 2107 46 2126 41 59 125 91 2001 93 91 2002 40 380 44 380 41 93 91 2002 40 473 44 380 41 93 91 2002 40 473 44 473 41 93 439 314 2003 2127 40 323 314 44 323 2005 41 123 489 490 2128 61 418 2129 40 41 59 490 2130 61 40 2131 41 2128 46 2132 60 2133 62 40 41 59 392 40 314 41 123 392 40 2005 41 123 490 2134 61 418 2135 40 41 59 319 2128 46 2136 46 2137 40 648 44 418 426 91 93 123 1501 125 44 2134 41 59 125 360 123 319 2128 46 2138 46 2139 40 648 44 1501 41 59 125 125 360 123 2128 46 2140 46 2141 40 648 44 1501 41 59 125 2142 46 2143 40 648 44 2130 46 2144 41 59 2142 46 2143 40 418 2145 60 426 62 123 1501 125 44 2130 46 2146 41 59 125 91 2001 93 91 2002 40 380 44 380 41 93 91 2002 40 473 44 380 41 93 91 2002 40 473 44 473 41 93 439 314 2003 2147 40 323 314 44 323 2005 41 123 489 490 2148 61 418 2149 40 41 59 490 2150 61 40 2151 41 2148 46 2152 60 2153 62 40 41 59 392 40 314 41 123 392 40 2005 41 123 490 2154 61 418 2155 40 41 59 319 2148 46 2156 46 2157 40 648 44 418 91 93 123 648 125 44 2154 41 59 125 360 123 319 2148 46 2158 46 2159 40 648 44 648 41 59 125 125 360 123 2148 46 2160 46 2161 40 648 44 648 41 59 125 2162 46 2163 40 648 44 2150 46 2164 41 59 2162 46 2163 40 418 2165 60 426 62 123 648 125 44 2150 46 2166 41 59 125 437 334 2167 58 2168 123 439 2167 40 41 58 320 40 2169 46 2170 46 2171 40 2169 46 2170 46 2172 40 418 2173 40 41 46 2174 60 2175 44 2176 62 40 41 41 41 41 123 125 125 437 334 2177 58 2178 123 437 441 2179 2180 59 439 2177 40 2179 2181 41 123 2180 61 2181 59 125 439 461 2182 123 2183 59 437 2184 59 125 439 2185 60 426 62 2186 123 2187 59 437 2188 59 125 439 2189 2190 40 461 2191 41 619 469 418 2192 40 41 59 439 2193 2190 40 461 2191 44 2185 60 426 62 2194 41 123 2182 61 2191 59 2186 61 2194 59 450 418 2193 40 2180 46 2195 40 41 46 2190 40 41 44 418 2196 60 461 44 426 62 40 41 41 59 125 125 125 
69837,C#,"public class StringEnumConverter<TModel, TProvider, TEnum> : ValueConverter<TModel, TProvider>
    where TEnum : struct
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public StringEnumConverter(
        Expression<Func<TModel, TProvider>> convertToProviderExpression,
        Expression<Func<TProvider, TModel>> convertFromProviderExpression,
        ConverterMappingHints? mappingHints = null)
        : base(convertToProviderExpression, convertFromProviderExpression, mappingHints)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected static new Expression<Func<TEnum, string>> ToString()
        => v => v.ToString()!;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected static Expression<Func<string, TEnum>> ToEnum()
    {
        if (!typeof(TEnum).UnwrapNullableType().IsEnum)
        {
            throw new InvalidOperationException(
                CoreStrings.ConverterBadType(
                    typeof(StringEnumConverter<TModel, TProvider, TEnum>).ShortDisplayName(),
                    typeof(TEnum).ShortDisplayName(),
                    ""enum types""));
        }

        return v => ConvertToEnum(v);
    }

    private static TEnum ConvertToEnum(string value)
        => Enum.TryParse<TEnum>(value, out var result)
            ? result
            : Enum.TryParse(value, true, out result)
                ? result
                : ulong.TryParse(value, out var ulongValue)
                    ? (TEnum)(object)ulongValue
                    : long.TryParse(value, out var longValue)
                        ? (TEnum)(object)longValue
                        : value == """"
                            ? default
                            : value == null
                                ? throw new ArgumentNullException(nameof(value))
                                : throw new InvalidOperationException(
                                    CoreStrings.CannotConvertEnumValue(value, typeof(TEnum).ShortDisplayName()));
}",0,439 334 2000 60 2001 44 2002 44 2003 62 58 2004 60 2001 44 2002 62 2005 2003 58 462 123 612 439 2000 40 2006 60 2007 60 2001 44 2002 640 2008 44 2006 60 2007 60 2002 44 2001 640 2009 44 2010 63 2011 61 424 41 58 320 40 2008 44 2009 44 2011 41 123 125 612 438 457 418 2006 60 2007 60 2003 44 461 640 2012 40 41 619 2013 619 2013 46 2012 40 41 33 59 612 438 457 2006 60 2007 60 461 44 2003 640 2014 40 41 123 392 40 33 478 40 2003 41 46 2015 40 41 46 2016 41 123 469 418 2017 40 2018 46 2019 40 478 40 2000 60 2001 44 2002 44 2003 62 41 46 2020 40 41 44 478 40 2003 41 46 2020 40 41 44 648 41 41 59 125 450 2013 619 2021 40 2013 41 59 125 437 457 2003 2022 40 461 2023 41 619 2024 46 2025 60 2003 62 40 2023 44 430 490 2026 41 63 2026 58 2024 46 2025 40 2023 44 473 44 430 2026 41 63 2026 58 480 46 2025 40 2023 44 430 490 2027 41 63 40 2003 41 40 426 41 2027 58 413 46 2025 40 2023 44 430 490 2028 41 63 40 2003 41 40 426 41 2028 58 2023 614 648 63 349 58 2023 614 424 63 469 418 2029 40 2030 40 2023 41 41 58 469 418 2031 40 2032 46 2033 40 2023 44 478 40 2003 41 46 2034 40 41 41 41 59 125 
68405,C#,"public abstract class CoreTypeMapping
{
    /// <summary>
    ///     Parameter object for use in the <see cref=""CoreTypeMapping"" /> hierarchy.
    /// </summary>
    protected readonly struct CoreTypeMappingParameters
    {
        /// <summary>
        ///     Creates a new <see cref=""CoreTypeMappingParameters"" /> parameter object.
        /// </summary>
        /// <param name=""clrType"">The .NET type used in the EF model.</param>
        /// <param name=""converter"">Converts types to and from the store whenever this mapping is used.</param>
        /// <param name=""comparer"">Supports custom value snapshotting and comparisons.</param>
        /// <param name=""keyComparer"">Supports custom comparisons between keys--e.g. PK to FK comparison.</param>
        /// <param name=""valueGeneratorFactory"">An optional factory for creating a specific <see cref=""ValueGenerator"" />.</param>
        public CoreTypeMappingParameters(
            Type clrType,
            ValueConverter? converter = null,
            ValueComparer? comparer = null,
            ValueComparer? keyComparer = null,
            Func<IProperty, IEntityType, ValueGenerator>? valueGeneratorFactory = null)
        {
            ClrType = clrType;
            Converter = converter;
            Comparer = comparer;
            KeyComparer = keyComparer;
            ValueGeneratorFactory = valueGeneratorFactory;
        }

        /// <summary>
        ///     The mapping CLR type.
        /// </summary>
        public Type ClrType { get; }

        /// <summary>
        ///     The mapping converter.
        /// </summary>
        public ValueConverter? Converter { get; }

        /// <summary>
        ///     The mapping comparer.
        /// </summary>
        public ValueComparer? Comparer { get; }

        /// <summary>
        ///     The mapping key comparer.
        /// </summary>
        public ValueComparer? KeyComparer { get; }

        /// <summary>
        ///     An optional factory for creating a specific <see cref=""ValueGenerator"" /> to use with
        ///     this mapping.
        /// </summary>
        public Func<IProperty, IEntityType, ValueGenerator>? ValueGeneratorFactory { get; }

        /// <summary>
        ///     Creates a new <see cref=""CoreTypeMappingParameters"" /> parameter object with the given
        ///     converter composed with any existing converter and set on the new parameter object.
        /// </summary>
        /// <param name=""converter"">The converter.</param>
        /// <returns>The new parameter object.</returns>
        public CoreTypeMappingParameters WithComposedConverter(ValueConverter? converter)
            => new(
                ClrType,
                converter == null ? Converter : converter.ComposeWith(Converter),
                Comparer,
                KeyComparer,
                ValueGeneratorFactory);
    }

    private ValueComparer? _comparer;
    private ValueComparer? _keyComparer;

    /// <summary>
    ///     Initializes a new instance of the <see cref=""CoreTypeMapping"" /> class.
    /// </summary>
    /// <param name=""parameters"">The parameters for this mapping.</param>
    protected CoreTypeMapping(CoreTypeMappingParameters parameters)
    {
        Parameters = parameters;

        var converter = parameters.Converter;

        var clrType = converter?.ModelClrType ?? parameters.ClrType;
        ClrType = clrType;

        Check.DebugAssert(
            parameters.Comparer == null
            || parameters.ClrType == null
            || converter != null
            || parameters.Comparer.Type == parameters.ClrType,
            $""Expected {parameters.ClrType}, got {parameters.Comparer?.Type}"");
        if (parameters.Comparer?.Type == clrType)
        {
            _comparer = parameters.Comparer;
        }

        Check.DebugAssert(
            parameters.KeyComparer == null
            || parameters.ClrType == null
            || converter != null
            || parameters.KeyComparer.Type == parameters.ClrType,
            $""Expected {parameters.ClrType}, got {parameters.KeyComparer?.Type}"");
        if (parameters.KeyComparer?.Type == clrType)
        {
            _keyComparer = parameters.KeyComparer;
        }

        ValueGeneratorFactory = parameters.ValueGeneratorFactory
            ?? converter?.MappingHints?.ValueGeneratorFactory;
    }

    /// <summary>
    ///     Returns the parameters used to create this type mapping.
    /// </summary>
    protected virtual CoreTypeMappingParameters Parameters { get; }

    /// <summary>
    ///     Gets the .NET type used in the EF model.
    /// </summary>
    public virtual Type ClrType { get; }

    /// <summary>
    ///     Converts types to and from the store whenever this mapping is used.
    ///     May be null if no conversion is needed.
    /// </summary>
    public virtual ValueConverter? Converter
        => Parameters.Converter;

    /// <summary>
    ///     An optional factory for creating a specific <see cref=""ValueGenerator"" /> to use with
    ///     this mapping.
    /// </summary>
    public virtual Func<IProperty, IEntityType, ValueGenerator>? ValueGeneratorFactory { get; }

    /// <summary>
    ///     A <see cref=""ValueComparer"" /> adds custom value snapshotting and comparison for
    ///     CLR types that cannot be compared with <see cref=""object.Equals(object, object)"" />
    ///     and/or need a deep copy when taking a snapshot.
    /// </summary>
    public virtual ValueComparer Comparer
        => NonCapturingLazyInitializer.EnsureInitialized(
            ref _comparer,
            this,
            static c => ValueComparer.CreateDefault(c.ClrType, favorStructuralComparisons: false));

    /// <summary>
    ///     A <see cref=""ValueComparer"" /> adds custom value comparison for use when
    ///     comparing key values to each other. For example, when comparing a PK to and FK.
    /// </summary>
    public virtual ValueComparer KeyComparer
        => NonCapturingLazyInitializer.EnsureInitialized(
            ref _keyComparer,
            this,
            static c => ValueComparer.CreateDefault(c.ClrType, favorStructuralComparisons: true));

    /// <summary>
    ///     Returns a new copy of this type mapping with the given <see cref=""ValueConverter"" />
    ///     added.
    /// </summary>
    /// <param name=""converter"">The converter to use.</param>
    /// <returns>A new type mapping</returns>
    public abstract CoreTypeMapping Clone(ValueConverter? converter);

    /// <summary>
    ///     Creates a an expression tree that can be used to generate code for the literal value.
    ///     Currently, only very basic expressions such as constructor calls and factory methods taking
    ///     simple constants are supported.
    /// </summary>
    /// <param name=""value"">The value for which a literal is needed.</param>
    /// <returns>An expression tree that can be used to generate code for the literal value.</returns>
    public virtual Expression GenerateCodeLiteral(object value)
        => throw new NotSupportedException(CoreStrings.LiteralGenerationNotSupported(ClrType.ShortDisplayName()));
}",0,439 305 334 2000 123 612 438 441 462 2001 123 612 439 2001 40 2002 2003 44 2004 63 2005 61 424 44 2006 63 2007 61 424 44 2006 63 2008 61 424 44 2009 60 2010 44 2011 44 2012 62 63 2013 61 424 41 123 2014 61 2003 59 2015 61 2005 59 2016 61 2007 59 2017 61 2008 59 2018 61 2013 59 125 612 439 2002 2019 123 2020 59 125 612 439 2004 63 2021 123 2022 59 125 612 439 2006 63 2023 123 2024 59 125 612 439 2006 63 2025 123 2026 59 125 612 439 2009 60 2010 44 2011 44 2012 62 63 2027 123 2028 59 125 612 439 2001 2029 40 2004 63 2005 41 619 418 40 2019 44 2005 614 424 63 2021 58 2005 46 2030 40 2021 41 44 2023 44 2025 44 2027 41 59 125 437 2031 63 2032 59 437 2031 63 2033 59 612 438 2000 40 2001 2034 41 123 2035 61 2034 59 490 2036 61 2034 46 2037 59 490 2038 61 2036 634 2039 633 2034 46 2040 59 2040 61 2038 59 2041 46 2042 40 2034 46 2043 614 424 606 2034 46 2040 614 424 606 2036 631 424 606 2034 46 2043 46 2044 614 2034 46 2040 44 36 648 41 59 392 40 2034 46 2043 634 2044 614 2038 41 123 2032 61 2034 46 2043 59 125 2041 46 2042 40 2034 46 2045 614 424 606 2034 46 2040 614 424 606 2036 631 424 606 2034 46 2045 46 2044 614 2034 46 2040 44 36 648 41 59 392 40 2034 46 2045 634 2044 614 2038 41 123 2033 61 2034 46 2045 59 125 2046 61 2034 46 2046 633 2036 634 2047 634 2046 59 125 612 438 491 2001 2048 123 2049 59 125 612 439 491 2050 2051 123 2052 59 125 612 439 491 2053 63 2054 619 2048 46 2054 59 612 439 491 2055 60 2056 44 2057 44 2058 62 63 2059 123 2060 59 125 612 439 491 2031 2061 619 2062 46 2063 40 442 2032 44 467 44 457 2064 619 2031 46 2065 40 2064 46 2051 44 2066 58 380 41 41 59 612 439 491 2031 2067 619 2062 46 2063 40 442 2033 44 467 44 457 2064 619 2031 46 2065 40 2064 46 2051 44 2066 58 473 41 41 59 612 439 305 2000 2068 40 2053 63 2069 41 59 612 439 491 2070 2071 40 426 2072 41 619 469 418 2073 40 2074 46 2075 40 2051 46 2076 40 41 41 41 59 125 
68141,C#,"public static class ForeignKeyExtensions
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static bool IsSelfReferencing(this IReadOnlyForeignKey foreignKey)
        => foreignKey.DeclaringEntityType == foreignKey.PrincipalEntityType;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static IEnumerable<IReadOnlyNavigation> GetNavigations(this IReadOnlyForeignKey foreignKey)
    {
        if (foreignKey.PrincipalToDependent != null)
        {
            yield return foreignKey.PrincipalToDependent;
        }

        if (foreignKey.DependentToPrincipal != null)
        {
            yield return foreignKey.DependentToPrincipal;
        }
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static IEnumerable<IReadOnlyNavigation> FindNavigationsFrom(
        this IReadOnlyForeignKey foreignKey,
        IReadOnlyEntityType entityType)
    {
        if (foreignKey.DeclaringEntityType != entityType
            && foreignKey.PrincipalEntityType != entityType)
        {
            throw new InvalidOperationException(
                CoreStrings.EntityTypeNotInRelationshipStrict(
                    entityType.DisplayName(),
                    foreignKey.DeclaringEntityType.DisplayName(),
                    foreignKey.PrincipalEntityType.DisplayName()));
        }

        return foreignKey.IsSelfReferencing()
            ? foreignKey.GetNavigations()
            : foreignKey.FindNavigations(foreignKey.DeclaringEntityType == entityType);
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static IEnumerable<IReadOnlyNavigation> FindNavigationsFromInHierarchy(
        this IReadOnlyForeignKey foreignKey,
        IReadOnlyEntityType entityType)
    {
        if (!foreignKey.DeclaringEntityType.IsAssignableFrom(entityType)
            && !foreignKey.PrincipalEntityType.IsAssignableFrom(entityType))
        {
            throw new InvalidOperationException(
                CoreStrings.EntityTypeNotInRelationship(
                    entityType.DisplayName(),
                    foreignKey.DeclaringEntityType.DisplayName(),
                    foreignKey.PrincipalEntityType.DisplayName()));
        }

        return foreignKey.DeclaringEntityType.IsAssignableFrom(foreignKey.PrincipalEntityType)
            || foreignKey.PrincipalEntityType.IsAssignableFrom(foreignKey.DeclaringEntityType)
                ? foreignKey.GetNavigations()
                : foreignKey.FindNavigations(foreignKey.DeclaringEntityType.IsAssignableFrom(entityType));
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static IEnumerable<IReadOnlyNavigation> FindNavigationsTo(
        this IReadOnlyForeignKey foreignKey,
        IReadOnlyEntityType entityType)
    {
        if (foreignKey.DeclaringEntityType != entityType
            && foreignKey.PrincipalEntityType != entityType)
        {
            throw new InvalidOperationException(
                CoreStrings.EntityTypeNotInRelationshipStrict(
                    entityType.DisplayName(),
                    foreignKey.DeclaringEntityType.DisplayName(),
                    foreignKey.PrincipalEntityType.DisplayName()));
        }

        return foreignKey.IsSelfReferencing()
            ? foreignKey.GetNavigations()
            : foreignKey.FindNavigations(foreignKey.PrincipalEntityType == entityType);
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static IEnumerable<IReadOnlyNavigation> FindNavigationsToInHierarchy(
        this IReadOnlyForeignKey foreignKey,
        IReadOnlyEntityType entityType)
    {
        if (!foreignKey.DeclaringEntityType.IsAssignableFrom(entityType)
            && !foreignKey.PrincipalEntityType.IsAssignableFrom(entityType))
        {
            throw new InvalidOperationException(
                CoreStrings.EntityTypeNotInRelationship(
                    entityType.DisplayName(), foreignKey.DeclaringEntityType.DisplayName(),
                    foreignKey.PrincipalEntityType.DisplayName()));
        }

        return foreignKey.DeclaringEntityType.IsAssignableFrom(foreignKey.PrincipalEntityType)
            || foreignKey.PrincipalEntityType.IsAssignableFrom(foreignKey.DeclaringEntityType)
                ? foreignKey.GetNavigations()
                : foreignKey.FindNavigations(foreignKey.PrincipalEntityType.IsAssignableFrom(entityType));
    }

    private static IEnumerable<IReadOnlyNavigation> FindNavigations(
        this IReadOnlyForeignKey foreignKey,
        bool toPrincipal)
    {
        if (toPrincipal)
        {
            if (foreignKey.DependentToPrincipal != null)
            {
                yield return foreignKey.DependentToPrincipal;
            }
        }
        else
        {
            if (foreignKey.PrincipalToDependent != null)
            {
                yield return foreignKey.PrincipalToDependent;
            }
        }
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static void GetPropertiesWithMinimalOverlapIfPossible(
        this IForeignKey foreignKey,
        out IReadOnlyList<IProperty> foreignKeyProperties,
        out IReadOnlyList<IProperty> principalKeyProperties)
    {
        // Finds the foreign key properties (and their associated principal key properties) of this foreign key where those
        // properties are not overlapping with any other foreign key, or all properties of the foreign key if there is not
        // a smaller set of non-overlapping properties.

        foreignKeyProperties = foreignKey.Properties;
        principalKeyProperties = foreignKey.PrincipalKey.Properties;

        var count = foreignKeyProperties.Count;
        if (count == 1)
        {
            return;
        }

        for (var i = 0; i < count; i++)
        {
            var dependentProperty = foreignKey.Properties[i];

            if (dependentProperty.GetContainingForeignKeys().Count() > 1)
            {
                if (ReferenceEquals(foreignKeyProperties, foreignKey.Properties))
                {
                    foreignKeyProperties = foreignKey.Properties.ToList();
                    principalKeyProperties = foreignKey.PrincipalKey.Properties.ToList();
                }

                ((List<IProperty>)foreignKeyProperties).Remove(dependentProperty);
                ((List<IProperty>)principalKeyProperties).Remove(foreignKey.PrincipalKey.Properties[i]);
            }
        }

        if (!foreignKeyProperties.Any())
        {
            foreignKeyProperties = foreignKey.Properties;
            principalKeyProperties = foreignKey.PrincipalKey.Properties;
        }
    }
}",0,439 457 334 2000 123 612 439 457 323 2001 40 467 2002 2003 41 619 2003 46 2004 614 2003 46 2005 59 612 439 457 2006 60 2007 62 2008 40 467 2002 2003 41 123 392 40 2003 46 2009 631 424 41 123 500 450 2003 46 2009 59 125 392 40 2003 46 2010 631 424 41 123 500 450 2003 46 2010 59 125 125 612 439 457 2006 60 2007 62 2011 40 467 2002 2003 44 2012 2013 41 123 392 40 2003 46 2004 631 2013 605 2003 46 2005 631 2013 41 123 469 418 2014 40 2015 46 2016 40 2013 46 2017 40 41 44 2003 46 2004 46 2017 40 41 44 2003 46 2005 46 2017 40 41 41 41 59 125 450 2003 46 2001 40 41 63 2003 46 2008 40 41 58 2003 46 2018 40 2003 46 2004 614 2013 41 59 125 612 439 457 2006 60 2007 62 2019 40 467 2002 2003 44 2012 2013 41 123 392 40 33 2003 46 2004 46 2020 40 2013 41 605 33 2003 46 2005 46 2020 40 2013 41 41 123 469 418 2021 40 2022 46 2023 40 2013 46 2024 40 41 44 2003 46 2004 46 2024 40 41 44 2003 46 2005 46 2024 40 41 41 41 59 125 450 2003 46 2004 46 2020 40 2003 46 2005 41 606 2003 46 2005 46 2020 40 2003 46 2004 41 63 2003 46 2008 40 41 58 2003 46 2025 40 2003 46 2004 46 2020 40 2013 41 41 59 125 612 439 457 2006 60 2007 62 2026 40 467 2002 2003 44 2012 2013 41 123 392 40 2003 46 2004 631 2013 605 2003 46 2005 631 2013 41 123 469 418 2027 40 2028 46 2029 40 2013 46 2030 40 41 44 2003 46 2004 46 2030 40 41 44 2003 46 2005 46 2030 40 41 41 41 59 125 450 2003 46 2001 40 41 63 2003 46 2008 40 41 58 2003 46 2031 40 2003 46 2005 614 2013 41 59 125 612 439 457 2006 60 2007 62 2032 40 467 2002 2003 44 2012 2013 41 123 392 40 33 2003 46 2004 46 2033 40 2013 41 605 33 2003 46 2005 46 2033 40 2013 41 41 123 469 418 2034 40 2035 46 2036 40 2013 46 2037 40 41 44 2003 46 2004 46 2037 40 41 44 2003 46 2005 46 2037 40 41 41 41 59 125 450 2003 46 2004 46 2033 40 2003 46 2005 41 606 2003 46 2005 46 2033 40 2003 46 2004 41 63 2003 46 2008 40 41 58 2003 46 2038 40 2003 46 2005 46 2033 40 2013 41 41 59 125 437 457 2006 60 2007 62 2039 40 467 2002 2003 44 323 2040 41 123 392 40 2040 41 123 392 40 2003 46 2041 631 424 41 123 500 450 2003 46 2041 59 125 125 360 123 392 40 2003 46 2042 631 424 41 123 500 450 2003 46 2042 59 125 125 125 612 439 457 492 2043 40 467 2044 2003 44 430 2045 60 2046 62 2047 44 430 2045 60 2046 62 2048 41 123 621 621 621 2047 61 2003 46 2049 59 2048 61 2003 46 2050 46 2049 59 490 2051 61 2047 46 2052 59 392 40 2051 614 1501 41 123 450 59 125 385 40 490 2053 61 1500 59 2053 60 2051 59 2053 637 41 123 490 2054 61 2003 46 2049 91 2053 93 59 392 40 2054 46 2055 40 41 46 2052 40 41 62 1501 41 123 392 40 2056 40 2047 44 2003 46 2049 41 41 123 2047 61 2003 46 2049 46 2057 40 41 59 2048 61 2003 46 2050 46 2049 46 2057 40 41 59 125 40 40 2058 60 2046 62 41 2047 41 46 2059 40 2054 41 59 40 40 2058 60 2046 62 41 2048 41 46 2059 40 2003 46 2050 46 2049 91 2053 93 41 59 125 125 392 40 33 2047 46 2060 40 41 41 123 2047 61 2003 46 2049 59 2048 61 2003 46 2050 46 2049 59 125 125 125 
68243,C#,"public class ClrPropertySetterFactory : ClrAccessorFactory<IClrPropertySetter>
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override IClrPropertySetter Create(IPropertyBase property)
        => property as IClrPropertySetter ?? Create(property.GetMemberInfo(forMaterialization: false, forSet: true), property);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override IClrPropertySetter CreateGeneric<TEntity, TValue, TNonNullableEnumValue>(
        MemberInfo memberInfo,
        IPropertyBase? propertyBase)
    {
        var entityParameter = Expression.Parameter(typeof(TEntity), ""entity"");
        var valueParameter = Expression.Parameter(typeof(TValue), ""value"");
        var memberType = memberInfo.GetMemberType();
        var convertedParameter = memberType == typeof(TValue)
            ? (Expression)valueParameter
            : Expression.Convert(valueParameter, memberType);

        Expression writeExpression;
        if (memberInfo.DeclaringType!.IsAssignableFrom(typeof(TEntity)))
        {
            writeExpression = CreateMemberAssignment(entityParameter);
        }
        else
        {
            // This path handles properties that exist only on proxy types and so only exist if the instance is a proxy
            var converted = Expression.Variable(memberInfo.DeclaringType, ""converted"");

            writeExpression = Expression.Block(
                new[] { converted },
                new List<Expression>
                {
                    Expression.Assign(
                        converted,
                        Expression.TypeAs(entityParameter, memberInfo.DeclaringType)),
                    Expression.IfThen(
                        Expression.ReferenceNotEqual(converted, Expression.Constant(null)),
                        CreateMemberAssignment(converted))
                });
        }

        var setter = Expression.Lambda<Action<TEntity, TValue>>(
            writeExpression,
            entityParameter,
            valueParameter).Compile();

        var propertyType = propertyBase?.ClrType ?? memberInfo.GetMemberType();

        return propertyType.IsNullableType()
            && propertyType.UnwrapNullableType().IsEnum
                ? new NullableEnumClrPropertySetter<TEntity, TValue, TNonNullableEnumValue>(setter)
                : new ClrPropertySetter<TEntity, TValue>(setter);

        Expression CreateMemberAssignment(Expression parameter)
            => propertyBase?.IsIndexerProperty() == true
                ? Expression.Assign(
                    Expression.MakeIndex(
                        entityParameter, (PropertyInfo)memberInfo, new List<Expression> { Expression.Constant(propertyBase.Name) }),
                    convertedParameter)
                : Expression.MakeMemberAccess(parameter, memberInfo).Assign(convertedParameter);
    }
}",0,439 334 2000 58 2001 60 2002 62 123 612 439 431 2002 2003 40 2004 2005 41 619 2005 311 2002 633 2003 40 2005 46 2006 40 2007 58 380 44 2008 58 473 41 44 2005 41 59 612 438 431 2002 2009 60 2010 44 2011 44 2012 62 40 2013 2014 44 2004 63 2015 41 123 490 2016 61 2017 46 2018 40 478 40 2010 41 44 648 41 59 490 2019 61 2017 46 2018 40 478 40 2011 41 44 648 41 59 490 2020 61 2014 46 2021 40 41 59 490 2022 61 2020 614 478 40 2011 41 63 40 2017 41 2019 58 2017 46 2023 40 2019 44 2020 41 59 2017 2024 59 392 40 2014 46 2025 33 46 2026 40 478 40 2010 41 41 41 123 2024 61 2027 40 2016 41 59 125 360 123 621 490 2028 61 2017 46 2029 40 2014 46 2025 44 648 41 59 2024 61 2017 46 2030 40 418 91 93 123 2028 125 44 418 2031 60 2017 62 123 2017 46 2032 40 2028 44 2017 46 2033 40 2016 44 2014 46 2025 41 41 44 2017 46 2034 40 2017 46 2035 40 2028 44 2017 46 2036 40 424 41 41 44 2037 40 2028 41 41 125 41 59 125 490 2038 61 2017 46 2039 60 2040 60 2010 44 2011 640 40 2024 44 2016 44 2019 41 46 2041 40 41 59 490 2042 61 2015 634 2043 633 2014 46 2021 40 41 59 450 2042 46 2044 40 41 605 2042 46 2045 40 41 46 2046 63 418 2047 60 2010 44 2011 44 2012 62 40 2038 41 58 418 2048 60 2010 44 2011 62 40 2038 41 59 2017 2049 40 2017 2050 41 619 2015 634 2051 40 41 614 473 63 2017 46 2052 40 2017 46 2053 40 2016 44 40 2054 41 2014 44 418 2055 60 2017 62 123 2017 46 2056 40 2015 46 2057 41 125 41 44 2022 41 58 2017 46 2058 40 2050 44 2014 41 46 2052 40 2022 41 59 125 125 
79969,C#,"    internal static class Helper
    {
        public static byte[] EnsureNotNull(this byte[] source)
        {
            return source ?? Array.Empty<byte>();
        }
    }",0,406 457 334 2000 123 439 457 326 91 93 2001 40 467 326 91 93 2002 41 123 450 2002 633 2003 46 2004 60 326 62 40 41 59 125 125 
79892,C#,"    public class NetworkAddressWithTime : ISerializable
    {
        /// <summary>
        /// The time when connected to the node.
        /// </summary>
        public uint Timestamp;

        /// <summary>
        /// The address of the node.
        /// </summary>
        public IPAddress Address;

        /// <summary>
        /// The capabilities of the node.
        /// </summary>
        public NodeCapability[] Capabilities;

        /// <summary>
        /// The <see cref=""IPEndPoint""/> of the Tcp server.
        /// </summary>
        public IPEndPoint EndPoint => new(Address, Capabilities.Where(p => p.Type == NodeCapabilityType.TcpServer).Select(p => (ServerCapability)p).FirstOrDefault()?.Port ?? 0);

        public int Size => sizeof(uint) + 16 + Capabilities.GetVarSize();

        /// <summary>
        /// Creates a new instance of the <see cref=""NetworkAddressWithTime""/> class.
        /// </summary>
        /// <param name=""address"">The address of the node.</param>
        /// <param name=""timestamp"">The time when connected to the node.</param>
        /// <param name=""capabilities"">The capabilities of the node.</param>
        /// <returns>The created payload.</returns>
        public static NetworkAddressWithTime Create(IPAddress address, uint timestamp, params NodeCapability[] capabilities)
        {
            return new NetworkAddressWithTime
            {
                Timestamp = timestamp,
                Address = address,
                Capabilities = capabilities
            };
        }

        void ISerializable.Deserialize(BinaryReader reader)
        {
            Timestamp = reader.ReadUInt32();

            // Address
            byte[] data = reader.ReadFixedBytes(16);
            Address = new IPAddress(data).Unmap();

            // Capabilities
            Capabilities = new NodeCapability[reader.ReadVarInt(VersionPayload.MaxCapabilities)];
            for (int x = 0, max = Capabilities.Length; x < max; x++)
                Capabilities[x] = NodeCapability.DeserializeFrom(reader);
            if (Capabilities.Select(p => p.Type).Distinct().Count() != Capabilities.Length)
                throw new FormatException();
        }

        void ISerializable.Serialize(BinaryWriter writer)
        {
            writer.Write(Timestamp);
            writer.Write(Address.MapToIPv6().GetAddressBytes());
            writer.Write(Capabilities);
        }
    }",0,439 334 2000 58 2001 123 612 439 479 2002 59 612 439 2003 2004 59 612 439 2005 91 93 2006 59 612 439 2007 2008 619 418 40 2004 44 2006 46 2009 40 2010 619 2010 46 2011 614 2012 46 2013 41 46 2014 40 2010 619 40 2015 41 2010 41 46 2016 40 41 634 2017 633 1500 41 59 439 404 2018 619 455 40 479 41 43 1503 43 2006 46 2019 40 41 59 612 439 457 2000 2020 40 2003 2021 44 479 2022 44 433 2005 91 93 2023 41 123 450 418 2000 123 2002 61 2022 44 2004 61 2021 44 2006 61 2023 125 59 125 492 2001 46 2024 40 2025 2026 41 123 2002 61 2026 46 2027 40 41 59 621 326 91 93 2028 61 2026 46 2029 40 1503 41 59 2004 61 418 2003 40 2028 41 46 2030 40 41 59 621 2006 61 418 2005 91 2026 46 2031 40 2032 46 2033 41 93 59 385 40 404 2034 61 1500 44 2035 61 2006 46 2036 59 2034 60 2035 59 2034 637 41 2006 91 2034 93 61 2005 46 2037 40 2026 41 59 392 40 2006 46 2014 40 2010 619 2010 46 2011 41 46 2038 40 41 46 2039 40 41 631 2006 46 2036 41 469 418 2040 40 41 59 125 492 2001 46 2041 40 2042 2043 41 123 2043 46 2044 40 2002 41 59 2043 46 2044 40 2004 46 2045 40 41 46 2046 40 41 41 59 2043 46 2044 40 2006 41 59 125 125 
68239,C#,"public class ClrPropertyGetterFactory : ClrAccessorFactory<IClrPropertyGetter>
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override IClrPropertyGetter Create(IPropertyBase property)
        => property as IClrPropertyGetter ?? Create(property.GetMemberInfo(forMaterialization: false, forSet: false), property);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override IClrPropertyGetter CreateGeneric<TEntity, TValue, TNonNullableEnumValue>(
        MemberInfo memberInfo,
        IPropertyBase? propertyBase)
    {
        var entityParameter = Expression.Parameter(typeof(TEntity), ""entity"");

        Expression readExpression;
        if (memberInfo.DeclaringType!.IsAssignableFrom(typeof(TEntity)))
        {
            readExpression = PropertyBase.CreateMemberAccess(propertyBase, entityParameter, memberInfo);
        }
        else
        {
            // This path handles properties that exist only on proxy types and so only exist if the instance is a proxy
            var converted = Expression.Variable(memberInfo.DeclaringType, ""converted"");

            readExpression = Expression.Block(
                new[] { converted },
                new List<Expression>
                {
                    Expression.Assign(
                        converted,
                        Expression.TypeAs(entityParameter, memberInfo.DeclaringType)),
                    Expression.Condition(
                        Expression.ReferenceEqual(converted, Expression.Constant(null)),
                        Expression.Default(memberInfo.GetMemberType()),
                        PropertyBase.CreateMemberAccess(propertyBase, converted, memberInfo))
                });
        }

        var hasDefaultValueExpression = readExpression.MakeHasDefaultValue(propertyBase);

        if (readExpression.Type != typeof(TValue))
        {
            readExpression = Expression.Condition(
                hasDefaultValueExpression,
                Expression.Constant(default(TValue), typeof(TValue)),
                Expression.Convert(readExpression, typeof(TValue)));
        }

        return new ClrPropertyGetter<TEntity, TValue>(
            Expression.Lambda<Func<TEntity, TValue>>(readExpression, entityParameter).Compile(),
            Expression.Lambda<Func<TEntity, bool>>(hasDefaultValueExpression, entityParameter).Compile());
    }
}",0,439 334 2000 58 2001 60 2002 62 123 612 439 431 2002 2003 40 2004 2005 41 619 2005 311 2002 633 2003 40 2005 46 2006 40 2007 58 380 44 2008 58 380 41 44 2005 41 59 612 438 431 2002 2009 60 2010 44 2011 44 2012 62 40 2013 2014 44 2004 63 2015 41 123 490 2016 61 2017 46 2018 40 478 40 2010 41 44 648 41 59 2017 2019 59 392 40 2014 46 2020 33 46 2021 40 478 40 2010 41 41 41 123 2019 61 2022 46 2023 40 2015 44 2016 44 2014 41 59 125 360 123 621 490 2024 61 2017 46 2025 40 2014 46 2020 44 648 41 59 2019 61 2017 46 2026 40 418 91 93 123 2024 125 44 418 2027 60 2017 62 123 2017 46 2028 40 2024 44 2017 46 2029 40 2016 44 2014 46 2020 41 41 44 2017 46 2030 40 2017 46 2031 40 2024 44 2017 46 2032 40 424 41 41 44 2017 46 2033 40 2014 46 2034 40 41 41 44 2035 46 2036 40 2015 44 2024 44 2014 41 41 125 41 59 125 490 2037 61 2019 46 2038 40 2015 41 59 392 40 2019 46 2039 631 478 40 2011 41 41 123 2019 61 2017 46 2040 40 2037 44 2017 46 2041 40 349 40 2011 41 44 478 40 2011 41 41 44 2017 46 2042 40 2019 44 478 40 2011 41 41 41 59 125 450 418 2043 60 2010 44 2011 62 40 2017 46 2044 60 2045 60 2010 44 2011 640 40 2019 44 2016 41 46 2046 40 41 44 2017 46 2044 60 2045 60 2010 44 323 640 40 2037 44 2016 41 46 2046 40 41 41 59 125 125 
71281,C#,"public class ReferenceReferenceBuilder<TEntity, TRelatedEntity> : ReferenceReferenceBuilder
    where TEntity : class
    where TRelatedEntity : class
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    public ReferenceReferenceBuilder(
        IMutableEntityType declaringEntityType,
        IMutableEntityType relatedEntityType,
        IMutableForeignKey foreignKey)
        : base(declaringEntityType, relatedEntityType, foreignKey)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected ReferenceReferenceBuilder(
        InternalForeignKeyBuilder builder,
        ReferenceReferenceBuilder oldBuilder,
        bool inverted = false,
        bool foreignKeySet = false,
        bool principalKeySet = false,
        bool requiredSet = false)
        : base(builder, oldBuilder, inverted, foreignKeySet, principalKeySet, requiredSet)
    {
    }

    /// <summary>
    ///     Adds or updates an annotation on the relationship. If an annotation with the key specified in
    ///     <paramref name=""annotation"" /> already exists its value will be updated.
    /// </summary>
    /// <param name=""annotation"">The key of the annotation to be added or updated.</param>
    /// <param name=""value"">The value to be stored in the annotation.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasAnnotation(
        string annotation,
        object? value)
        => (ReferenceReferenceBuilder<TEntity, TRelatedEntity>)base.HasAnnotation(annotation, value);

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey(string, string[])"" /> is not specified, then an attempt will be made to
    ///         match the data type and order of foreign key properties against the primary key of the principal
    ///         entity type. If they do not match, new shadow state properties that form a unique index will be
    ///         added to the principal entity type to serve as the reference key.
    ///     </para>
    /// </remarks>
    /// <param name=""dependentEntityTypeName"">
    ///     The name of entity type that is the dependent in this relationship (the type that has the foreign key
    ///     properties).
    /// </param>
    /// <param name=""foreignKeyPropertyNames"">
    ///     The name(s) of the foreign key property(s).
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey(
        string dependentEntityTypeName,
        params string[] foreignKeyPropertyNames)
        => new(
            HasForeignKeyBuilder(
                ResolveEntityType(Check.NotNull(dependentEntityTypeName, nameof(dependentEntityTypeName)))!,
                dependentEntityTypeName,
                Check.NotNull(foreignKeyPropertyNames, nameof(foreignKeyPropertyNames))),
            this,
            inverted: Builder.Metadata.DeclaringEntityType.Name != ResolveEntityType(dependentEntityTypeName)!.Name,
            foreignKeySet: foreignKeyPropertyNames.Length > 0);

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey(Type,string[])"" /> is not specified, then an attempt will be made to
    ///         match the data type and order of foreign key properties against the primary key of the principal
    ///         entity type. If they do not match, new shadow state properties that form a unique index will be
    ///         added to the principal entity type to serve as the reference key.
    ///     </para>
    /// </remarks>
    /// <param name=""dependentEntityType"">
    ///     The entity type that is the dependent in this relationship (the type that has the foreign key
    ///     properties).
    /// </param>
    /// <param name=""foreignKeyPropertyNames"">
    ///     The name(s) of the foreign key property(s).
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey(
        Type dependentEntityType,
        params string[] foreignKeyPropertyNames)
        => new(
            HasForeignKeyBuilder(
                ResolveEntityType(Check.NotNull(dependentEntityType, nameof(dependentEntityType)))!,
                dependentEntityType.ShortDisplayName(),
                Check.NotNull(foreignKeyPropertyNames, nameof(foreignKeyPropertyNames))),
            this,
            inverted: Builder.Metadata.DeclaringEntityType.ClrType != dependentEntityType,
            foreignKeySet: foreignKeyPropertyNames.Length > 0);

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey{T}(string[])"" /> is not specified, then an attempt will be made to
    ///         match the data type and order of foreign key properties against the primary key of the principal
    ///         entity type. If they do not match, new shadow state properties that form a unique index will be
    ///         added to the principal entity type to serve as the referenced key.
    ///     </para>
    /// </remarks>
    /// <typeparam name=""TDependentEntity"">
    ///     The entity type that is the dependent in this relationship (the type that has the foreign key
    ///     properties).
    /// </typeparam>
    /// <param name=""foreignKeyPropertyNames"">
    ///     The name(s) of the foreign key property(s).
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
        params string[] foreignKeyPropertyNames)
        where TDependentEntity : class
        => HasForeignKey(typeof(TDependentEntity), foreignKeyPropertyNames);

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey{T}(Expression{Func{T, object}})"" /> is not specified, then an attempt
    ///         will be made to match the data type and order of foreign key properties against the primary key of
    ///         the principal entity type. If they do not match, new shadow state properties that form a unique
    ///         index will be added to the principal entity type to serve as the reference key.
    ///     </para>
    /// </remarks>
    /// <typeparam name=""TDependentEntity"">
    ///     The entity type that is the dependent in this relationship. That is, the type
    ///     that has the foreign key properties.
    /// </typeparam>
    /// <param name=""foreignKeyExpression"">
    ///     <para>
    ///         A lambda expression representing the foreign key property(s) (<c>t => t.Id1</c>).
    ///     </para>
    ///     <para>
    ///         If the foreign key is made up of multiple properties then specify an anonymous type including the
    ///         properties (<c>t => new { t.Id1, t.Id2 }</c>). The order specified should match the order of
    ///         corresponding keys in <see cref=""HasPrincipalKey{TPrincipalEntity}(Expression{Func{TPrincipalEntity, object}})"" />.
    ///     </para>
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
        Expression<Func<TDependentEntity, object?>> foreignKeyExpression)
        where TDependentEntity : class
        => new(
            HasForeignKeyBuilder(
                ResolveEntityType(typeof(TDependentEntity))!,
                typeof(TDependentEntity).ShortDisplayName(),
                Check.NotNull(foreignKeyExpression, nameof(foreignKeyExpression)).GetMemberAccessList()),
            this,
            inverted: Builder.Metadata.DeclaringEntityType.ClrType != typeof(TDependentEntity),
            foreignKeySet: true);

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <param name=""principalEntityTypeName"">
    ///     The name of entity type that is the principal in this relationship (the type
    ///     that has the reference key properties).
    /// </param>
    /// <param name=""keyPropertyNames"">The name(s) of the reference key property(s).</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey(
        string principalEntityTypeName,
        params string[] keyPropertyNames)
        => new(
            HasPrincipalKeyBuilder(
                ResolveEntityType(Check.NotEmpty(principalEntityTypeName, nameof(principalEntityTypeName)))!,
                principalEntityTypeName,
                Check.NotNull(keyPropertyNames, nameof(keyPropertyNames))),
            this,
            inverted: Builder.Metadata.PrincipalEntityType.Name != principalEntityTypeName,
            principalKeySet: keyPropertyNames.Length > 0);

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <param name=""principalEntityType"">
    ///     The entity type that is the principal in this relationship (the type
    ///     that has the reference key properties).
    /// </param>
    /// <param name=""keyPropertyNames"">The name(s) of the reference key property(s).</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey(
        Type principalEntityType,
        params string[] keyPropertyNames)
        => new(
            HasPrincipalKeyBuilder(
                ResolveEntityType(Check.NotNull(principalEntityType, nameof(principalEntityType)))!,
                principalEntityType.ShortDisplayName(),
                Check.NotNull(keyPropertyNames, nameof(keyPropertyNames))),
            this,
            inverted: Builder.Metadata.PrincipalEntityType.ClrType != principalEntityType,
            principalKeySet: keyPropertyNames.Length > 0);

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <typeparam name=""TPrincipalEntity"">
    ///     The entity type that is the principal in this relationship (the type
    ///     that has the reference key properties).
    /// </typeparam>
    /// <param name=""keyPropertyNames"">The name(s) of the reference key property(s).</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
        params string[] keyPropertyNames)
        where TPrincipalEntity : class
        => HasPrincipalKey(typeof(TPrincipalEntity), keyPropertyNames);

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <remarks>
    ///     If multiple principal key properties are specified, the order of principal key properties should
    ///     match the order that the primary key or unique constraint properties were configured on the principal
    ///     entity type.
    /// </remarks>
    /// <typeparam name=""TPrincipalEntity"">
    ///     The entity type that is the principal in this relationship. That is, the type that has the reference key properties.
    /// </typeparam>
    /// <param name=""keyExpression"">
    ///     <para>
    ///         A lambda expression representing the reference key property(s) (<c>t => t.Id</c>).
    ///     </para>
    ///     <para>
    ///         If the principal key is made up of multiple properties then specify an anonymous type including the
    ///         properties (<c>t => new { t.Id1, t.Id2 }</c>). The order specified should match the order of
    ///         corresponding properties in <see cref=""HasForeignKey{TDependentEntity}(Expression{Func{TDependentEntity, object}})"" />.
    ///     </para>
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
        Expression<Func<TPrincipalEntity, object?>> keyExpression)
        where TPrincipalEntity : class
        => new(
            HasPrincipalKeyBuilder(
                ResolveEntityType(typeof(TPrincipalEntity))!,
                typeof(TPrincipalEntity).ShortDisplayName(),
                Check.NotNull(keyExpression, nameof(keyExpression)).GetMemberAccessList()),
            this,
            inverted: Builder.Metadata.PrincipalEntityType.ClrType != typeof(TPrincipalEntity),
            principalKeySet: true);

    /// <summary>
    ///     Configures whether this is a required relationship (i.e. whether the foreign key property(s) can
    ///     be assigned <see langword=""null"" />).
    /// </summary>
    /// <param name=""required"">A value indicating whether this is a required relationship.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> IsRequired(bool required = true)
        => new(Builder.IsRequired(required, ConfigurationSource.Explicit)!, this, requiredSet: true);

    /// <summary>
    ///     Configures the operation applied to dependent entities in the relationship when the
    ///     principal is deleted or the relationship is severed.
    /// </summary>
    /// <param name=""deleteBehavior"">The action to perform.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceReferenceBuilder<TEntity, TRelatedEntity> OnDelete(DeleteBehavior deleteBehavior)
        => new(Builder.OnDelete(deleteBehavior, ConfigurationSource.Explicit)!, this);
}",0,439 334 2000 60 2001 44 2002 62 58 2000 2003 2001 58 334 2003 2002 58 334 123 612 91 2004 93 439 2000 40 2005 2006 44 2005 2007 44 2008 2009 41 58 320 40 2006 44 2007 44 2009 41 123 125 612 91 2004 93 438 2000 40 2010 2011 44 2000 2012 44 323 2013 61 380 44 323 2014 61 380 44 323 2015 61 380 44 323 2016 61 380 41 58 320 40 2011 44 2012 44 2013 44 2014 44 2015 44 2016 41 123 125 612 439 418 491 2000 60 2001 44 2002 62 2017 40 461 2018 44 426 63 2019 41 619 40 2000 60 2001 44 2002 62 41 320 46 2017 40 2018 44 2019 41 59 612 439 418 491 2000 60 2001 44 2002 62 2020 40 461 2021 44 433 461 91 93 2022 41 619 418 40 2023 40 2024 40 2025 46 2026 40 2021 44 2027 40 2021 41 41 41 33 44 2021 44 2025 46 2026 40 2022 44 2027 40 2022 41 41 41 44 467 44 2013 58 2028 46 2029 46 2030 46 2031 631 2024 40 2021 41 33 46 2031 44 2014 58 2022 46 2032 62 1500 41 59 612 439 418 491 2000 60 2001 44 2002 62 2020 40 2033 2034 44 433 461 91 93 2022 41 619 418 40 2023 40 2024 40 2025 46 2026 40 2034 44 2027 40 2034 41 41 41 33 44 2034 46 2035 40 41 44 2025 46 2026 40 2022 44 2027 40 2022 41 41 41 44 467 44 2013 58 2028 46 2029 46 2030 46 2036 631 2034 44 2014 58 2022 46 2032 62 1500 41 59 612 439 491 2000 60 2001 44 2002 62 2020 60 2037 62 40 433 461 91 93 2022 41 2003 2037 58 334 619 2020 40 478 40 2037 41 44 2022 41 59 612 439 491 2000 60 2001 44 2002 62 2020 60 2037 62 40 2038 60 2039 60 2037 44 426 63 640 2040 41 2003 2037 58 334 619 418 40 2023 40 2024 40 478 40 2037 41 41 33 44 478 40 2037 41 46 2035 40 41 44 2025 46 2026 40 2040 44 2027 40 2040 41 41 46 2041 40 41 41 44 467 44 2013 58 2028 46 2029 46 2030 46 2036 631 478 40 2037 41 44 2014 58 473 41 59 612 439 418 491 2000 60 2001 44 2002 62 2042 40 461 2043 44 433 461 91 93 2044 41 619 418 40 2045 40 2024 40 2025 46 2046 40 2043 44 2027 40 2043 41 41 41 33 44 2043 44 2025 46 2026 40 2044 44 2027 40 2044 41 41 41 44 467 44 2013 58 2028 46 2029 46 2047 46 2031 631 2043 44 2015 58 2044 46 2032 62 1500 41 59 612 439 418 491 2000 60 2001 44 2002 62 2042 40 2033 2048 44 433 461 91 93 2044 41 619 418 40 2045 40 2024 40 2025 46 2026 40 2048 44 2027 40 2048 41 41 41 33 44 2048 46 2035 40 41 44 2025 46 2026 40 2044 44 2027 40 2044 41 41 41 44 467 44 2013 58 2028 46 2029 46 2047 46 2036 631 2048 44 2015 58 2044 46 2032 62 1500 41 59 612 439 491 2000 60 2001 44 2002 62 2042 60 2049 62 40 433 461 91 93 2044 41 2003 2049 58 334 619 2042 40 478 40 2049 41 44 2044 41 59 612 439 491 2000 60 2001 44 2002 62 2042 60 2049 62 40 2038 60 2039 60 2049 44 426 63 640 2050 41 2003 2049 58 334 619 418 40 2045 40 2024 40 478 40 2049 41 41 33 44 478 40 2049 41 46 2035 40 41 44 2025 46 2026 40 2050 44 2027 40 2050 41 41 46 2041 40 41 41 44 467 44 2013 58 2028 46 2029 46 2047 46 2036 631 478 40 2049 41 44 2015 58 473 41 59 612 439 418 491 2000 60 2001 44 2002 62 2051 40 323 2052 61 473 41 619 418 40 2028 46 2051 40 2052 44 2053 46 2054 41 33 44 467 44 2016 58 473 41 59 612 439 418 491 2000 60 2001 44 2002 62 2055 40 2056 2057 41 619 418 40 2028 46 2055 40 2057 44 2053 46 2054 41 33 44 467 41 59 125 
70441,C#,"public class ReferenceReferenceBuilder : InvertibleRelationshipBuilderBase
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    public ReferenceReferenceBuilder(
        IMutableEntityType declaringEntityType,
        IMutableEntityType relatedEntityType,
        IMutableForeignKey foreignKey)
        : base(declaringEntityType, relatedEntityType, foreignKey)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected ReferenceReferenceBuilder(
        InternalForeignKeyBuilder builder,
        ReferenceReferenceBuilder oldBuilder,
        bool inverted = false,
        bool foreignKeySet = false,
        bool principalKeySet = false,
        bool requiredSet = false)
        : base(builder, oldBuilder, inverted, foreignKeySet, principalKeySet, requiredSet)
    {
    }

    /// <summary>
    ///     Adds or updates an annotation on the relationship. If an annotation with the key specified in
    ///     <paramref name=""annotation"" /> already exists its value will be updated.
    /// </summary>
    /// <param name=""annotation"">The key of the annotation to be added or updated.</param>
    /// <param name=""value"">The value to be stored in the annotation.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder HasAnnotation(string annotation, object? value)
    {
        Check.NotEmpty(annotation, nameof(annotation));

        Builder.HasAnnotation(annotation, value, ConfigurationSource.Explicit);

        return this;
    }

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey(Type,string[])"" /> is not specified, then an attempt will be made to
    ///         match the data type and order of foreign key properties against the primary key of the principal
    ///         entity type. If they do not match, new shadow state properties that form a unique index will be
    ///         added to the principal entity type to serve as the reference key.
    ///     </para>
    /// </remarks>
    /// <param name=""dependentEntityTypeName"">
    ///     The name of the entity type that is the dependent in this relationship (the type that has the foreign
    ///     key properties).
    /// </param>
    /// <param name=""foreignKeyPropertyNames"">
    ///     The name(s) of the foreign key property(s).
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder HasForeignKey(
        string dependentEntityTypeName,
        params string[] foreignKeyPropertyNames)
        => new(
            HasForeignKeyBuilder(
                ResolveEntityType(Check.NotNull(dependentEntityTypeName, nameof(dependentEntityTypeName)))!,
                dependentEntityTypeName,
                Check.NotNull(foreignKeyPropertyNames, nameof(foreignKeyPropertyNames))),
            this,
            Builder.Metadata.DeclaringEntityType.Name != ResolveEntityType(dependentEntityTypeName)!.Name,
            foreignKeySet: foreignKeyPropertyNames.Length > 0);

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey(Type,string[])"" /> is not specified, then an attempt will be made to
    ///         match the data type and order of foreign key properties against the primary key of the principal
    ///         entity type. If they do not match, new shadow state properties that form a unique index will be
    ///         added to the principal entity type to serve as the reference key.
    ///     </para>
    /// </remarks>
    /// <param name=""dependentEntityType"">
    ///     The entity type that is the dependent in this relationship (the type that has the foreign key
    ///     properties).
    /// </param>
    /// <param name=""foreignKeyPropertyNames"">
    ///     The name(s) of the foreign key property(s).
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder HasForeignKey(
        Type dependentEntityType,
        params string[] foreignKeyPropertyNames)
        => new(
            HasForeignKeyBuilder(
                ResolveEntityType(Check.NotNull(dependentEntityType, nameof(dependentEntityType)))!,
                dependentEntityType.ShortDisplayName(),
                Check.NotNull(foreignKeyPropertyNames, nameof(foreignKeyPropertyNames))),
            this,
            Builder.Metadata.DeclaringEntityType.ClrType != dependentEntityType,
            foreignKeySet: foreignKeyPropertyNames.Length > 0);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected virtual InternalForeignKeyBuilder HasForeignKeyBuilder(
        EntityType dependentEntityType,
        string dependentEntityTypeName,
        IReadOnlyList<string> foreignKeyPropertyNames)
        => HasForeignKeyBuilder(
            dependentEntityType, dependentEntityTypeName,
            (b, d) => b.HasForeignKey(foreignKeyPropertyNames, d, ConfigurationSource.Explicit)!);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected virtual InternalForeignKeyBuilder HasForeignKeyBuilder(
        EntityType dependentEntityType,
        string dependentEntityTypeName,
        IReadOnlyList<MemberInfo> foreignKeyMembers)
        => HasForeignKeyBuilder(
            dependentEntityType, dependentEntityTypeName,
            (b, d) => b.HasForeignKey(foreignKeyMembers, d, ConfigurationSource.Explicit)!);

    private InternalForeignKeyBuilder HasForeignKeyBuilder(
        EntityType? dependentEntityType,
        string dependentEntityTypeName,
        Func<InternalForeignKeyBuilder, EntityType, InternalForeignKeyBuilder> hasForeignKey)
    {
        if (dependentEntityType == null)
        {
            throw new InvalidOperationException(
                CoreStrings.DependentEntityTypeNotInRelationship(
                    DeclaringEntityType.DisplayName(),
                    RelatedEntityType.DisplayName(),
                    dependentEntityTypeName));
        }

        using var batch = dependentEntityType.Model.DelayConventions();
        var builder = Builder.HasEntityTypes(
            GetOtherEntityType(dependentEntityType), dependentEntityType, ConfigurationSource.Explicit)!;
        builder = hasForeignKey(builder, dependentEntityType);

        return batch.Run(builder)!;
    }

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <remarks>
    ///     If multiple principal key properties are specified, the order of principal key properties should
    ///     match the order that the primary key or unique constraint properties were configured on the principal
    ///     entity type.
    /// </remarks>
    /// <param name=""principalEntityTypeName"">
    ///     The name of the entity type that is the principal in this relationship (the type
    ///     that has the reference key properties).
    /// </param>
    /// <param name=""keyPropertyNames"">The name(s) of the reference key property(s).</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder HasPrincipalKey(
        string principalEntityTypeName,
        params string[] keyPropertyNames)
        => new(
            HasPrincipalKeyBuilder(
                ResolveEntityType(Check.NotEmpty(principalEntityTypeName, nameof(principalEntityTypeName)))!,
                principalEntityTypeName,
                Check.NotNull(keyPropertyNames, nameof(keyPropertyNames))),
            this,
            inverted: Builder.Metadata.PrincipalEntityType.Name != ResolveEntityType(principalEntityTypeName)!.Name,
            principalKeySet: keyPropertyNames.Length > 0);

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <remarks>
    ///     If multiple principal key properties are specified, the order of principal key properties should
    ///     match the order that the primary key or unique constraint properties were configured on the principal
    ///     entity type.
    /// </remarks>
    /// <param name=""principalEntityType"">
    ///     The entity type that is the principal in this relationship (the type
    ///     that has the reference key properties).
    /// </param>
    /// <param name=""keyPropertyNames"">The name(s) of the reference key property(s).</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder HasPrincipalKey(
        Type principalEntityType,
        params string[] keyPropertyNames)
        => new(
            HasPrincipalKeyBuilder(
                ResolveEntityType(Check.NotNull(principalEntityType, nameof(principalEntityType)))!,
                principalEntityType.ShortDisplayName(),
                Check.NotNull(keyPropertyNames, nameof(keyPropertyNames))),
            this,
            inverted: Builder.Metadata.PrincipalEntityType.ClrType != principalEntityType,
            principalKeySet: keyPropertyNames.Length > 0);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected virtual InternalForeignKeyBuilder HasPrincipalKeyBuilder(
        EntityType principalEntityType,
        string principalEntityTypeName,
        IReadOnlyList<string> foreignKeyPropertyNames)
        => HasPrincipalKeyBuilder(
            principalEntityType, principalEntityTypeName,
            b => b.HasPrincipalKey(foreignKeyPropertyNames, ConfigurationSource.Explicit)!);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected virtual InternalForeignKeyBuilder HasPrincipalKeyBuilder(
        EntityType principalEntityType,
        string principalEntityTypeName,
        IReadOnlyList<MemberInfo> foreignKeyMembers)
        => HasPrincipalKeyBuilder(
            principalEntityType, principalEntityTypeName,
            b => b.HasPrincipalKey(foreignKeyMembers, ConfigurationSource.Explicit)!);

    private InternalForeignKeyBuilder HasPrincipalKeyBuilder(
        EntityType? principalEntityType,
        string principalEntityTypeName,
        Func<InternalForeignKeyBuilder, InternalForeignKeyBuilder> hasPrincipalKey)
    {
        if (principalEntityType == null)
        {
            throw new InvalidOperationException(
                CoreStrings.PrincipalEntityTypeNotInRelationship(
                    DeclaringEntityType.DisplayName(),
                    RelatedEntityType.DisplayName(),
                    principalEntityTypeName));
        }

        using var batch = principalEntityType.Model.DelayConventions();
        var builder = Builder.HasEntityTypes(
            principalEntityType, GetOtherEntityType(principalEntityType), ConfigurationSource.Explicit)!;
        builder = hasPrincipalKey(builder);

        return batch.Run(builder)!;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected virtual EntityType? ResolveEntityType(string entityTypeName)
    {
        if (DeclaringEntityType.Name == entityTypeName)
        {
            return (EntityType)DeclaringEntityType;
        }

        if (RelatedEntityType.Name == entityTypeName)
        {
            return (EntityType)RelatedEntityType;
        }

        if (DeclaringEntityType.DisplayName() == entityTypeName)
        {
            return (EntityType)DeclaringEntityType;
        }

        if (RelatedEntityType.DisplayName() == entityTypeName)
        {
            return (EntityType)RelatedEntityType;
        }

        if (DeclaringEntityType.HasSharedClrType
            && DeclaringEntityType.ShortName() == entityTypeName)
        {
            return (EntityType)DeclaringEntityType;
        }

        return RelatedEntityType.HasSharedClrType && RelatedEntityType.ShortName() == entityTypeName
            ? (EntityType)RelatedEntityType
            : null;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected virtual EntityType? ResolveEntityType(Type entityType)
    {
        if (DeclaringEntityType.ClrType == entityType)
        {
            return (EntityType)DeclaringEntityType;
        }

        return RelatedEntityType.ClrType == entityType ? (EntityType)RelatedEntityType : null;
    }

    private EntityType GetOtherEntityType(EntityType entityType)
        => DeclaringEntityType == entityType ? (EntityType)RelatedEntityType : (EntityType)DeclaringEntityType;

    /// <summary>
    ///     Configures whether this is a required relationship (i.e. whether the foreign key property(s) can
    ///     be assigned <see langword=""null"" />).
    /// </summary>
    /// <param name=""required"">A value indicating whether this is a required relationship.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder IsRequired(bool required = true)
        => new(Builder.IsRequired(required, ConfigurationSource.Explicit)!, this, requiredSet: true);

    /// <summary>
    ///     Configures the operation applied to dependent entities in the relationship when the
    ///     principal is deleted or the relationship is severed.
    /// </summary>
    /// <param name=""deleteBehavior"">The action to perform.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceReferenceBuilder OnDelete(DeleteBehavior deleteBehavior)
        => new(Builder.OnDelete(deleteBehavior, ConfigurationSource.Explicit)!, this);
}",0,439 334 2000 58 2001 123 612 91 2002 93 439 2000 40 2003 2004 44 2003 2005 44 2006 2007 41 58 320 40 2004 44 2005 44 2007 41 123 125 612 91 2002 93 438 2000 40 2008 2009 44 2000 2010 44 323 2011 61 380 44 323 2012 61 380 44 323 2013 61 380 44 323 2014 61 380 41 58 320 40 2009 44 2010 44 2011 44 2012 44 2013 44 2014 41 123 125 612 439 491 2000 2015 40 461 2016 44 426 63 2017 41 123 2018 46 2019 40 2016 44 2020 40 2016 41 41 59 2021 46 2015 40 2016 44 2017 44 2022 46 2023 41 59 450 467 59 125 612 439 491 2000 2024 40 461 2025 44 433 461 91 93 2026 41 619 418 40 2027 40 2028 40 2029 46 2030 40 2025 44 2031 40 2025 41 41 41 33 44 2025 44 2029 46 2030 40 2026 44 2031 40 2026 41 41 41 44 467 44 2032 46 2033 46 2034 46 2035 631 2028 40 2025 41 33 46 2035 44 2012 58 2026 46 2036 62 1500 41 59 612 439 491 2000 2024 40 2037 2038 44 433 461 91 93 2026 41 619 418 40 2027 40 2028 40 2029 46 2030 40 2038 44 2031 40 2038 41 41 41 33 44 2038 46 2039 40 41 44 2029 46 2030 40 2026 44 2031 40 2026 41 41 41 44 467 44 2032 46 2033 46 2034 46 2040 631 2038 44 2012 58 2026 46 2036 62 1500 41 59 612 91 2002 93 438 491 2008 2027 40 2041 2038 44 461 2025 44 2042 60 461 62 2026 41 619 2027 40 2038 44 2025 44 40 2043 44 2044 41 619 2043 46 2024 40 2026 44 2044 44 2045 46 2046 41 33 41 59 612 91 2002 93 438 491 2008 2027 40 2041 2038 44 461 2025 44 2042 60 2047 62 2048 41 619 2027 40 2038 44 2025 44 40 2043 44 2044 41 619 2043 46 2024 40 2048 44 2044 44 2045 46 2046 41 33 41 59 437 2008 2027 40 2041 63 2038 44 461 2025 44 2049 60 2008 44 2041 44 2008 62 2050 41 123 392 40 2038 614 424 41 123 469 418 2051 40 2052 46 2053 40 2034 46 2054 40 41 44 2055 46 2054 40 41 44 2025 41 41 59 125 489 490 2056 61 2038 46 2057 46 2058 40 41 59 490 2009 61 2032 46 2059 40 2060 40 2038 41 44 2038 44 2045 46 2046 41 33 59 2009 61 2050 40 2009 44 2038 41 59 450 2056 46 2061 40 2009 41 33 59 125 612 439 491 2000 2062 40 461 2063 44 433 461 91 93 2064 41 619 418 40 2065 40 2028 40 2029 46 2066 40 2063 44 2031 40 2063 41 41 41 33 44 2063 44 2029 46 2030 40 2064 44 2031 40 2064 41 41 41 44 467 44 2011 58 2032 46 2033 46 2067 46 2035 631 2028 40 2063 41 33 46 2035 44 2013 58 2064 46 2036 62 1500 41 59 612 439 491 2000 2062 40 2037 2068 44 433 461 91 93 2064 41 619 418 40 2065 40 2028 40 2029 46 2030 40 2068 44 2031 40 2068 41 41 41 33 44 2068 46 2039 40 41 44 2029 46 2030 40 2064 44 2031 40 2064 41 41 41 44 467 44 2011 58 2032 46 2033 46 2067 46 2040 631 2068 44 2013 58 2064 46 2036 62 1500 41 59 612 91 2002 93 438 491 2008 2065 40 2041 2068 44 461 2063 44 2042 60 461 62 2026 41 619 2065 40 2068 44 2063 44 2043 619 2043 46 2062 40 2026 44 2045 46 2046 41 33 41 59 612 91 2002 93 438 491 2008 2065 40 2041 2068 44 461 2063 44 2042 60 2047 62 2048 41 619 2065 40 2068 44 2063 44 2043 619 2043 46 2062 40 2048 44 2045 46 2046 41 33 41 59 437 2008 2065 40 2041 63 2068 44 461 2063 44 2049 60 2008 44 2008 62 2069 41 123 392 40 2068 614 424 41 123 469 418 2070 40 2071 46 2072 40 2034 46 2073 40 41 44 2074 46 2073 40 41 44 2063 41 41 59 125 489 490 2075 61 2068 46 2076 46 2077 40 41 59 490 2009 61 2032 46 2078 40 2068 44 2079 40 2068 41 44 2045 46 2046 41 33 59 2009 61 2069 40 2009 41 59 450 2075 46 2080 40 2009 41 33 59 125 612 91 2002 93 438 491 2041 63 2028 40 461 2081 41 123 392 40 2034 46 2035 614 2081 41 123 450 40 2041 41 2034 59 125 392 40 2082 46 2035 614 2081 41 123 450 40 2041 41 2082 59 125 392 40 2034 46 2083 40 41 614 2081 41 123 450 40 2041 41 2034 59 125 392 40 2082 46 2083 40 41 614 2081 41 123 450 40 2041 41 2082 59 125 392 40 2034 46 2084 605 2034 46 2085 40 41 614 2081 41 123 450 40 2041 41 2034 59 125 450 2082 46 2084 605 2082 46 2085 40 41 614 2081 63 40 2041 41 2082 58 424 59 125 612 91 2002 93 438 491 2041 63 2028 40 2037 2086 41 123 392 40 2034 46 2040 614 2086 41 123 450 40 2041 41 2034 59 125 450 2087 46 2040 614 2086 63 40 2041 41 2087 58 424 59 125 437 2041 2088 40 2041 2086 41 619 2034 614 2086 63 40 2041 41 2089 58 40 2041 41 2034 59 612 439 491 2000 2090 40 323 2091 61 473 41 619 418 40 2032 46 2090 40 2091 44 2045 46 2046 41 33 44 467 44 2014 58 473 41 59 612 439 491 2000 2092 40 2093 2094 41 619 418 40 2032 46 2092 40 2094 44 2045 46 2046 41 33 44 467 41 59 125 
68628,C#,"public class ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity> : ReferenceCollectionBuilder
    where TPrincipalEntity : class
    where TDependentEntity : class
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    public ReferenceCollectionBuilder(
        IMutableEntityType principalEntityType,
        IMutableEntityType dependentEntityType,
        IMutableForeignKey foreignKey)
        : base(principalEntityType, dependentEntityType, foreignKey)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected ReferenceCollectionBuilder(
        InternalForeignKeyBuilder builder,
        ReferenceCollectionBuilder oldBuilder,
        bool foreignKeySet = false,
        bool principalKeySet = false,
        bool requiredSet = false)
        : base(builder, oldBuilder, foreignKeySet, principalKeySet, requiredSet)
    {
    }

    /// <summary>
    ///     Adds or updates an annotation on the relationship. If an annotation with the key specified in
    ///     <paramref name=""annotation"" /> already exists its value will be updated.
    /// </summary>
    /// <param name=""annotation"">The key of the annotation to be added or updated.</param>
    /// <param name=""value"">The value to be stored in the annotation.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity> HasAnnotation(
        string annotation,
        object? value)
        => (ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity>)base.HasAnnotation(
            Check.NotEmpty(annotation, nameof(annotation)),
            Check.NotNull(value, nameof(value)));

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey(System.Linq.Expressions.Expression{System.Func{TPrincipalEntity,object}})"" /> is not specified,
    ///         then an attempt will be made to match the data type and order of foreign key properties against
    ///         the primary key of the principal entity type. If they do not match, new shadow state properties
    ///         that form a unique index will be added to the principal entity type to serve as the reference key.
    ///     </para>
    /// </remarks>
    /// <param name=""foreignKeyPropertyNames"">
    ///     The name(s) of the foreign key property(s).
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity> HasForeignKey(
        params string[] foreignKeyPropertyNames)
        => new(
            HasForeignKeyBuilder(Check.NotEmpty(foreignKeyPropertyNames, nameof(foreignKeyPropertyNames))),
            this,
            foreignKeySet: true);

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     If <see cref=""HasPrincipalKey(Expression{Func{TPrincipalEntity, object}})"" /> is not specified, then
    ///     an attempt will be made to match the data type and order of foreign key properties against the
    ///     primary key of the principal entity type. If they do not match, new shadow state properties that
    ///     form a unique index will be added to the principal entity type to serve as the reference key.
    ///     A shadow state property is one that does not have a corresponding property in the entity class. The
    ///     current value for the property is stored in the <see cref=""ChangeTracker"" /> rather than being
    ///     stored in instances of the entity class.
    /// </remarks>
    /// <param name=""foreignKeyExpression"">
    ///     <para>
    ///         A lambda expression representing the foreign key property(s) (<c>post => post.BlogId</c>).
    ///     </para>
    ///     <para>
    ///         If the foreign key is made up of multiple properties then specify an anonymous type including the
    ///         properties (<c>comment => new { comment.BlogId, comment.PostTitle }</c>). The order specified should match the order of
    ///         corresponding properties in <see cref=""HasPrincipalKey(Expression{Func{TPrincipalEntity,object}})"" />.
    ///     </para>
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity> HasForeignKey(
        Expression<Func<TDependentEntity, object?>> foreignKeyExpression)
        => new(
            HasForeignKeyBuilder(Check.NotNull(foreignKeyExpression, nameof(foreignKeyExpression)).GetMemberAccessList()),
            this,
            foreignKeySet: true);

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <param name=""keyPropertyNames"">The name(s) of the referenced key property(s).</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity> HasPrincipalKey(
        params string[] keyPropertyNames)
        => new(
            HasPrincipalKeyBuilder(Check.NotEmpty(keyPropertyNames, nameof(keyPropertyNames))),
            this,
            principalKeySet: true);

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <param name=""keyExpression"">
    ///     <para>
    ///         A lambda expression representing the referenced key property(s) (<c>blog => blog.BlogId</c>).
    ///     </para>
    ///     <para>
    ///         If the principal key is made up of multiple properties then specify an anonymous type including the
    ///         properties (<c>t => new { t.Id1, t.Id2 }</c>). The order specified should match the order of
    ///         corresponding properties in <see cref=""HasForeignKey(Expression{Func{TDependentEntity,object}})"" />.
    ///     </para>
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity> HasPrincipalKey(
        Expression<Func<TPrincipalEntity, object?>> keyExpression)
        => new(
            HasPrincipalKeyBuilder(Check.NotNull(keyExpression, nameof(keyExpression)).GetMemberAccessList()),
            this,
            principalKeySet: true);

    /// <summary>
    ///     Configures whether this is a required relationship (i.e. whether the foreign key property(s) can
    ///     be assigned <see langword=""null"" />).
    /// </summary>
    /// <param name=""required"">A value indicating whether this is a required relationship.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity> IsRequired(bool required = true)
        => new(Builder.IsRequired(required, ConfigurationSource.Explicit)!, this, requiredSet: true);

    /// <summary>
    ///     Configures the operation applied to dependent entities in the relationship when the
    ///     principal is deleted or the relationship is severed.
    /// </summary>
    /// <param name=""deleteBehavior"">The action to perform.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual ReferenceCollectionBuilder<TPrincipalEntity, TDependentEntity> OnDelete(DeleteBehavior deleteBehavior)
        => new(Builder.OnDelete(deleteBehavior, ConfigurationSource.Explicit)!, this);
}",0,439 334 2000 60 2001 44 2002 62 58 2000 2003 2001 58 334 2003 2002 58 334 123 612 91 2004 93 439 2000 40 2005 2006 44 2005 2007 44 2008 2009 41 58 320 40 2006 44 2007 44 2009 41 123 125 612 91 2004 93 438 2000 40 2010 2011 44 2000 2012 44 323 2013 61 380 44 323 2014 61 380 44 323 2015 61 380 41 58 320 40 2011 44 2012 44 2013 44 2014 44 2015 41 123 125 612 439 418 491 2000 60 2001 44 2002 62 2016 40 461 2017 44 426 63 2018 41 619 40 2000 60 2001 44 2002 62 41 320 46 2016 40 2019 46 2020 40 2017 44 2021 40 2017 41 41 44 2019 46 2022 40 2018 44 2021 40 2018 41 41 41 59 612 439 418 491 2000 60 2001 44 2002 62 2023 40 433 461 91 93 2024 41 619 418 40 2025 40 2019 46 2020 40 2024 44 2021 40 2024 41 41 41 44 467 44 2013 58 473 41 59 612 439 491 2000 60 2001 44 2002 62 2023 40 2026 60 2027 60 2002 44 426 63 640 2028 41 619 418 40 2025 40 2019 46 2022 40 2028 44 2021 40 2028 41 41 46 2029 40 41 41 44 467 44 2013 58 473 41 59 612 439 418 491 2000 60 2001 44 2002 62 2030 40 433 461 91 93 2031 41 619 418 40 2032 40 2019 46 2020 40 2031 44 2021 40 2031 41 41 41 44 467 44 2014 58 473 41 59 612 439 491 2000 60 2001 44 2002 62 2030 40 2026 60 2027 60 2001 44 426 63 640 2033 41 619 418 40 2032 40 2019 46 2022 40 2033 44 2021 40 2033 41 41 46 2029 40 41 41 44 467 44 2014 58 473 41 59 612 439 418 491 2000 60 2001 44 2002 62 2034 40 323 2035 61 473 41 619 418 40 2036 46 2034 40 2035 44 2037 46 2038 41 33 44 467 44 2015 58 473 41 59 612 439 418 491 2000 60 2001 44 2002 62 2039 40 2040 2041 41 619 418 40 2036 46 2039 40 2041 44 2037 46 2038 41 33 44 467 41 59 125 
71161,C#,"public class OwnershipBuilder<TEntity, TDependentEntity> : OwnershipBuilder
    where TEntity : class
    where TDependentEntity : class
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    public OwnershipBuilder(
        IMutableEntityType principalEntityType,
        IMutableEntityType dependentEntityType,
        IMutableForeignKey foreignKey)
        : base(principalEntityType, dependentEntityType, foreignKey)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    protected OwnershipBuilder(
        InternalForeignKeyBuilder builder,
        OwnershipBuilder oldBuilder,
        bool foreignKeySet = false,
        bool principalKeySet = false,
        bool requiredSet = false)
        : base(builder, oldBuilder, foreignKeySet, principalKeySet, requiredSet)
    {
    }

    /// <summary>
    ///     Adds or updates an annotation on the foreign key. If an annotation with the key specified in
    ///     <paramref name=""annotation"" /> already exists its value will be updated.
    /// </summary>
    /// <param name=""annotation"">The key of the annotation to be added or updated.</param>
    /// <param name=""value"">The value to be stored in the annotation.</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual OwnershipBuilder<TEntity, TDependentEntity> HasAnnotation(
        string annotation,
        object? value)
        => (OwnershipBuilder<TEntity, TDependentEntity>)base.HasAnnotation(annotation, value);

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey(string[])"" /> is not specified, then an attempt will be made to
    ///         match the data type and order of foreign key properties against the primary key of the principal
    ///         entity type. If they do not match, new shadow state properties that form a unique index will be
    ///         added to the principal entity type to serve as the reference key.
    ///     </para>
    /// </remarks>
    /// <param name=""foreignKeyPropertyNames"">
    ///     The name(s) of the foreign key property(s).
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual OwnershipBuilder<TEntity, TDependentEntity> HasForeignKey(
        params string[] foreignKeyPropertyNames)
    {
        Builder = Builder.HasForeignKey(
            Check.NotNull(foreignKeyPropertyNames, nameof(foreignKeyPropertyNames)),
            (EntityType)DependentEntityType,
            ConfigurationSource.Explicit)!;
        return new OwnershipBuilder<TEntity, TDependentEntity>(
            Builder,
            this,
            foreignKeySet: foreignKeyPropertyNames.Length > 0);
    }

    /// <summary>
    ///     Configures the property(s) to use as the foreign key for this relationship.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If the specified property name(s) do not exist on the entity type then a new shadow state
    ///         property(s) will be added to serve as the foreign key. A shadow state property is one
    ///         that does not have a corresponding property in the entity class. The current value for the
    ///         property is stored in the <see cref=""ChangeTracker"" /> rather than being stored in instances
    ///         of the entity class.
    ///     </para>
    ///     <para>
    ///         If <see cref=""HasPrincipalKey(Expression{Func{TEntity, object}})"" /> is not specified, then an
    ///         attempt will be made to match the data type and order of foreign key properties against the primary
    ///         key of the principal entity type. If they do not match, new shadow state properties that form a
    ///         unique index will be added to the principal entity type to serve as the reference key.
    ///     </para>
    /// </remarks>
    /// <param name=""foreignKeyExpression"">
    ///     <para>
    ///         A lambda expression representing the foreign key property(s) (<c>t => t.Id1</c>).
    ///     </para>
    ///     <para>
    ///         If the foreign key is made up of multiple properties then specify an anonymous type including the
    ///         properties (<c>t => new { t.Id1, t.Id2 }</c>). The order specified should match the order of
    ///         corresponding properties in <see cref=""HasPrincipalKey(Expression{Func{TEntity, object}})"" />.
    ///     </para>
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual OwnershipBuilder<TEntity, TDependentEntity> HasForeignKey(
        Expression<Func<TDependentEntity, object?>> foreignKeyExpression)
    {
        Builder = Builder.HasForeignKey(
            Check.NotNull(foreignKeyExpression, nameof(foreignKeyExpression)).GetMemberAccessList(),
            (EntityType)DependentEntityType,
            ConfigurationSource.Explicit)!;
        return new OwnershipBuilder<TEntity, TDependentEntity>(
            Builder,
            this,
            foreignKeySet: true);
    }

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <param name=""keyPropertyNames"">The name(s) of the reference key property(s).</param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public new virtual OwnershipBuilder<TEntity, TDependentEntity> HasPrincipalKey(
        params string[] keyPropertyNames)
    {
        Builder = Builder.HasPrincipalKey(
            Check.NotNull(keyPropertyNames, nameof(keyPropertyNames)),
            ConfigurationSource.Explicit)!;
        return new OwnershipBuilder<TEntity, TDependentEntity>(
            Builder,
            this,
            principalKeySet: keyPropertyNames.Length > 0);
    }

    /// <summary>
    ///     Configures the unique property(s) that this relationship targets. Typically you would only call this
    ///     method if you want to use a property(s) other than the primary key as the principal property(s). If
    ///     the specified property(s) is not already a unique constraint (or the primary key) then a new unique
    ///     constraint will be introduced.
    /// </summary>
    /// <param name=""keyExpression"">
    ///     <para>
    ///         A lambda expression representing the reference key property(s) (<c>t => t.Id</c>).
    ///     </para>
    ///     <para>
    ///         If the principal key is made up of multiple properties then specify an anonymous type including the
    ///         properties (<c>t => new { t.Id1, t.Id2 }</c>). The order specified should match the order of
    ///         corresponding properties in <see cref=""HasForeignKey(Expression{Func{TDependentEntity, object}})"" />.
    ///     </para>
    /// </param>
    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
    public virtual OwnershipBuilder<TEntity, TDependentEntity> HasPrincipalKey(
        Expression<Func<TEntity, object?>> keyExpression)
    {
        Builder = Builder.HasPrincipalKey(
            Check.NotNull(keyExpression, nameof(keyExpression)).GetMemberAccessList(),
            ConfigurationSource.Explicit)!;
        return new OwnershipBuilder<TEntity, TDependentEntity>(
            Builder,
            this,
            principalKeySet: true);
    }
}",0,439 334 2000 60 2001 44 2002 62 58 2000 2003 2001 58 334 2003 2002 58 334 123 612 91 2004 93 439 2000 40 2005 2006 44 2005 2007 44 2008 2009 41 58 320 40 2006 44 2007 44 2009 41 123 125 612 91 2004 93 438 2000 40 2010 2011 44 2000 2012 44 323 2013 61 380 44 323 2014 61 380 44 323 2015 61 380 41 58 320 40 2011 44 2012 44 2013 44 2014 44 2015 41 123 125 612 439 418 491 2000 60 2001 44 2002 62 2016 40 461 2017 44 426 63 2018 41 619 40 2000 60 2001 44 2002 62 41 320 46 2016 40 2017 44 2018 41 59 612 439 418 491 2000 60 2001 44 2002 62 2019 40 433 461 91 93 2020 41 123 2021 61 2021 46 2019 40 2022 46 2023 40 2020 44 2024 40 2020 41 41 44 40 2025 41 2026 44 2027 46 2028 41 33 59 450 418 2000 60 2001 44 2002 62 40 2021 44 467 44 2013 58 2020 46 2029 62 1500 41 59 125 612 439 491 2000 60 2001 44 2002 62 2019 40 2030 60 2031 60 2002 44 426 63 640 2032 41 123 2033 61 2033 46 2019 40 2034 46 2035 40 2032 44 2036 40 2032 41 41 46 2037 40 41 44 40 2038 41 2039 44 2040 46 2041 41 33 59 450 418 2000 60 2001 44 2002 62 40 2033 44 467 44 2013 58 473 41 59 125 612 439 418 491 2000 60 2001 44 2002 62 2042 40 433 461 91 93 2043 41 123 2044 61 2044 46 2042 40 2045 46 2046 40 2043 44 2047 40 2043 41 41 44 2048 46 2049 41 33 59 450 418 2000 60 2001 44 2002 62 40 2044 44 467 44 2014 58 2043 46 2050 62 1500 41 59 125 612 439 491 2000 60 2001 44 2002 62 2042 40 2030 60 2031 60 2001 44 426 63 640 2051 41 123 2052 61 2052 46 2042 40 2053 46 2054 40 2051 44 2055 40 2051 41 41 46 2056 40 41 44 2057 46 2058 41 33 59 450 418 2000 60 2001 44 2002 62 40 2052 44 467 44 2014 58 473 41 59 125 125 
68296,C#,"public class EntityEntry<TEntity> : EntityEntry
    where TEntity : class
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    [EntityFrameworkInternal]
    public EntityEntry(InternalEntityEntry internalEntry)
        : base(internalEntry)
    {
    }

    /// <summary>
    ///     Gets the entity being tracked by this entry.
    /// </summary>
    public new virtual TEntity Entity
        => (TEntity)base.Entity;

    /// <summary>
    ///     Provides access to change tracking information and operations for a given
    ///     property of this entity.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-entity-entries"">Accessing tracked entities in EF Core</see> for more information and
    ///     examples.
    /// </remarks>
    /// <param name=""propertyExpression"">
    ///     A lambda expression representing the property to access information and operations for
    ///     (<c>t => t.Property1</c>).
    /// </param>
    /// <returns>An object that exposes change tracking information and operations for the given property.</returns>
    public virtual PropertyEntry<TEntity, TProperty> Property<TProperty>(
        Expression<Func<TEntity, TProperty>> propertyExpression)
    {
        Check.NotNull(propertyExpression, nameof(propertyExpression));

        return new PropertyEntry<TEntity, TProperty>(InternalEntry, propertyExpression.GetMemberAccess().GetSimpleMemberName());
    }

    /// <summary>
    ///     Provides access to change tracking and loading information for a reference (i.e. non-collection)
    ///     navigation property that associates this entity to another entity.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-entity-entries"">Accessing tracked entities in EF Core</see>
    ///     and <see href=""https://aka.ms/efcore-docs-changing-relationships"">Changing foreign keys and navigations</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""propertyExpression"">
    ///     A lambda expression representing the property to access information and operations for
    ///     (<c>t => t.Property1</c>).
    /// </param>
    /// <returns>
    ///     An object that exposes change tracking information and operations for the
    ///     given navigation property.
    /// </returns>
    public virtual ReferenceEntry<TEntity, TProperty> Reference<TProperty>(
        Expression<Func<TEntity, TProperty?>> propertyExpression)
        where TProperty : class
    {
        Check.NotNull(propertyExpression, nameof(propertyExpression));

        return new ReferenceEntry<TEntity, TProperty>(InternalEntry, propertyExpression.GetMemberAccess().GetSimpleMemberName());
    }

    /// <summary>
    ///     Provides access to change tracking and loading information for a collection
    ///     navigation property that associates this entity to a collection of another entities.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-entity-entries"">Accessing tracked entities in EF Core</see>
    ///     and <see href=""https://aka.ms/efcore-docs-changing-relationships"">Changing foreign keys and navigations</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""propertyExpression"">
    ///     A lambda expression representing the property to access information and operations for
    ///     (<c>t => t.Property1</c>).
    /// </param>
    /// <returns>
    ///     An object that exposes change tracking information and operations for the
    ///     given navigation property.
    /// </returns>
    public virtual CollectionEntry<TEntity, TProperty> Collection<TProperty>(
        Expression<Func<TEntity, IEnumerable<TProperty>>> propertyExpression)
        where TProperty : class
    {
        Check.NotNull(propertyExpression, nameof(propertyExpression));

        return new CollectionEntry<TEntity, TProperty>(InternalEntry, propertyExpression.GetMemberAccess().GetSimpleMemberName());
    }

    /// <summary>
    ///     Provides access to change tracking and loading information for a reference (i.e. non-collection)
    ///     navigation property that associates this entity to another entity.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-entity-entries"">Accessing tracked entities in EF Core</see>
    ///     and <see href=""https://aka.ms/efcore-docs-changing-relationships"">Changing foreign keys and navigations</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""propertyName"">The name of the navigation property.</param>
    /// <returns>
    ///     An object that exposes change tracking information and operations for the
    ///     given navigation property.
    /// </returns>
    public virtual ReferenceEntry<TEntity, TProperty> Reference<TProperty>(string propertyName)
        where TProperty : class
    {
        Check.NotEmpty(propertyName, nameof(propertyName));

        return new ReferenceEntry<TEntity, TProperty>(InternalEntry, propertyName);
    }

    /// <summary>
    ///     Provides access to change tracking and loading information for a collection
    ///     navigation property that associates this entity to a collection of another entities.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-entity-entries"">Accessing tracked entities in EF Core</see>
    ///     and <see href=""https://aka.ms/efcore-docs-changing-relationships"">Changing foreign keys and navigations</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""propertyName"">The name of the navigation property.</param>
    /// <returns>
    ///     An object that exposes change tracking information and operations for the
    ///     given navigation property.
    /// </returns>
    public virtual CollectionEntry<TEntity, TProperty> Collection<TProperty>(string propertyName)
        where TProperty : class
    {
        Check.NotEmpty(propertyName, nameof(propertyName));

        return new CollectionEntry<TEntity, TProperty>(InternalEntry, propertyName);
    }

    /// <summary>
    ///     Provides access to change tracking information and operations for a given
    ///     property of this entity.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-entity-entries"">Accessing tracked entities in EF Core</see> for more information and
    ///     examples.
    /// </remarks>
    /// <typeparam name=""TProperty"">The type of the property.</typeparam>
    /// <param name=""propertyName"">The property to access information and operations for.</param>
    /// <returns>An object that exposes change tracking information and operations for the given property.</returns>
    public virtual PropertyEntry<TEntity, TProperty> Property<TProperty>(
        string propertyName)
    {
        Check.NotEmpty(propertyName, nameof(propertyName));

        ValidateType<TProperty>(InternalEntry.EntityType.FindProperty(propertyName));

        return new PropertyEntry<TEntity, TProperty>(InternalEntry, propertyName);
    }

    private static void ValidateType<TProperty>(IProperty? property)
    {
        if (property != null
            && property.ClrType != typeof(TProperty))
        {
            throw new ArgumentException(
                CoreStrings.WrongGenericPropertyType(
                    property.Name,
                    property.DeclaringEntityType.DisplayName(),
                    property.ClrType.ShortDisplayName(),
                    typeof(TProperty).ShortDisplayName()));
        }
    }
}",0,439 334 2000 60 2001 62 58 2000 2002 2001 58 334 123 612 91 2003 93 439 2000 40 2004 2005 41 58 320 40 2005 41 123 125 612 439 418 491 2001 2006 619 40 2001 41 320 46 2006 59 612 439 491 2007 60 2001 44 2008 62 2009 60 2008 62 40 2010 60 2011 60 2001 44 2008 640 2012 41 123 2013 46 2014 40 2012 44 2015 40 2012 41 41 59 450 418 2007 60 2001 44 2008 62 40 2016 44 2012 46 2017 40 41 46 2018 40 41 41 59 125 612 439 491 2019 60 2001 44 2008 62 2020 60 2008 62 40 2010 60 2011 60 2001 44 2008 63 640 2012 41 2002 2008 58 334 123 2021 46 2022 40 2012 44 2023 40 2012 41 41 59 450 418 2019 60 2001 44 2008 62 40 2024 44 2012 46 2025 40 41 46 2026 40 41 41 59 125 612 439 491 2027 60 2001 44 2008 62 2028 60 2008 62 40 2010 60 2011 60 2001 44 2029 60 2008 640 62 2012 41 2002 2008 58 334 123 2030 46 2031 40 2012 44 2032 40 2012 41 41 59 450 418 2027 60 2001 44 2008 62 40 2033 44 2012 46 2034 40 41 46 2035 40 41 41 59 125 612 439 491 2019 60 2001 44 2008 62 2020 60 2008 62 40 461 2036 41 2002 2008 58 334 123 2037 46 2038 40 2036 44 2039 40 2036 41 41 59 450 418 2019 60 2001 44 2008 62 40 2040 44 2036 41 59 125 612 439 491 2027 60 2001 44 2008 62 2028 60 2008 62 40 461 2036 41 2002 2008 58 334 123 2041 46 2042 40 2036 44 2043 40 2036 41 41 59 450 418 2027 60 2001 44 2008 62 40 2044 44 2036 41 59 125 612 439 491 2007 60 2001 44 2008 62 2009 60 2008 62 40 461 2036 41 123 2045 46 2046 40 2036 44 2047 40 2036 41 41 59 2048 60 2008 62 40 2049 46 2050 46 2051 40 2036 41 41 59 450 418 2007 60 2001 44 2008 62 40 2049 44 2036 41 59 125 437 457 492 2052 60 2008 62 40 2053 63 2054 41 123 392 40 2054 631 424 605 2054 46 2055 631 478 40 2008 41 41 123 469 418 2056 40 2057 46 2058 40 2054 46 2059 44 2054 46 2060 46 2061 40 41 44 2054 46 2055 46 2062 40 41 44 478 40 2008 41 46 2062 40 41 41 41 59 125 125 125 
79831,C#,"    public abstract class WalletAccount
    {
        /// <summary>
        /// The <see cref=""Neo.ProtocolSettings""/> to be used by the wallet.
        /// </summary>
        protected readonly ProtocolSettings ProtocolSettings;

        /// <summary>
        /// The hash of the account.
        /// </summary>
        public readonly UInt160 ScriptHash;

        /// <summary>
        /// The label of the account.
        /// </summary>
        public string Label;

        /// <summary>
        /// Indicates whether the account is the default account in the wallet.
        /// </summary>
        public bool IsDefault;

        /// <summary>
        /// Indicates whether the account is locked.
        /// </summary>
        public bool Lock;

        /// <summary>
        /// The contract of the account.
        /// </summary>
        public Contract Contract;

        /// <summary>
        /// The address of the account.
        /// </summary>
        public string Address => ScriptHash.ToAddress(ProtocolSettings.AddressVersion);

        /// <summary>
        /// Indicates whether the account contains a private key.
        /// </summary>
        public abstract bool HasKey { get; }

        /// <summary>
        /// Indicates whether the account is a watch-only account.
        /// </summary>
        public bool WatchOnly => Contract == null;

        /// <summary>
        /// Gets the private key of the account.
        /// </summary>
        /// <returns>The private key of the account. Or <see langword=""null""/> if there is no private key in the account.</returns>
        public abstract KeyPair GetKey();

        /// <summary>
        /// Initializes a new instance of the <see cref=""WalletAccount""/> class.
        /// </summary>
        /// <param name=""scriptHash"">The hash of the account.</param>
        /// <param name=""settings"">The <see cref=""Neo.ProtocolSettings""/> to be used by the wallet.</param>
        protected WalletAccount(UInt160 scriptHash, ProtocolSettings settings)
        {
            this.ProtocolSettings = settings;
            this.ScriptHash = scriptHash;
        }
    }",0,439 305 334 2000 123 612 438 441 2001 2001 59 612 439 441 2002 2003 59 612 439 461 2004 59 612 439 323 2005 59 612 439 323 2006 59 612 439 2007 2007 59 612 439 461 2008 619 2003 46 2009 40 2001 46 2010 41 59 612 439 305 323 2011 123 2012 59 125 612 439 323 2013 619 2007 614 424 59 612 439 305 2014 2015 40 41 59 612 438 2000 40 2002 2016 44 2001 2017 41 123 467 46 2001 61 2017 59 467 46 2003 61 2016 59 125 125 
79822,C#,"    sealed class UserWalletAccount : WalletAccount
    {
        public KeyPair Key;

        public override bool HasKey => Key != null;

        public UserWalletAccount(UInt160 scriptHash, ProtocolSettings settings)
            : base(scriptHash, settings)
        {
        }

        public override KeyPair GetKey()
        {
            return Key;
        }
    }",0,452 334 2000 58 2001 123 439 2002 2003 59 439 431 323 2004 619 2003 631 424 59 439 2000 40 2005 2006 44 2007 2008 41 58 320 40 2006 44 2008 41 123 125 439 431 2002 2009 40 41 123 450 2003 59 125 125 
79823,C#,"    public class ScryptParameters
    {
        /// <summary>
        /// The default parameters used by <see cref=""NEP6Wallet""/>.
        /// </summary>
        public static ScryptParameters Default { get; } = new ScryptParameters(16384, 8, 8);

        /// <summary>
        /// CPU/Memory cost parameter. Must be larger than 1, a power of 2 and less than 2^(128 * r / 8).
        /// </summary>
        public readonly int N;

        /// <summary>
        /// The block size, must be >= 1.
        /// </summary>
        public readonly int R;

        /// <summary>
        /// Parallelization parameter. Must be a positive integer less than or equal to Int32.MaxValue / (128 * r * 8).
        /// </summary>
        public readonly int P;

        /// <summary>
        /// Initializes a new instance of the <see cref=""ScryptParameters""/> class.
        /// </summary>
        /// <param name=""n"">CPU/Memory cost parameter.</param>
        /// <param name=""r"">The block size.</param>
        /// <param name=""p"">Parallelization parameter.</param>
        public ScryptParameters(int n, int r, int p)
        {
            this.N = n;
            this.R = r;
            this.P = p;
        }

        /// <summary>
        /// Converts the parameters from a JSON object.
        /// </summary>
        /// <param name=""json"">The parameters represented by a JSON object.</param>
        /// <returns>The converted parameters.</returns>
        public static ScryptParameters FromJson(JObject json)
        {
            return new ScryptParameters((int)json[""n""].AsNumber(), (int)json[""r""].AsNumber(), (int)json[""p""].AsNumber());
        }

        /// <summary>
        /// Converts the parameters to a JSON object.
        /// </summary>
        /// <returns>The parameters represented by a JSON object.</returns>
        public JObject ToJson()
        {
            JObject json = new();
            json[""n""] = N;
            json[""r""] = R;
            json[""p""] = P;
            return json;
        }
    }",0,439 334 2000 123 612 439 457 2000 2001 123 2002 59 125 61 418 2000 40 1506 44 1502 44 1502 41 59 612 439 441 404 2003 59 612 439 441 404 2004 59 612 439 441 404 2005 59 612 439 2000 40 404 2006 44 404 2007 44 404 2008 41 123 467 46 2003 61 2006 59 467 46 2004 61 2007 59 467 46 2005 61 2008 59 125 612 439 457 2000 2009 40 2010 2011 41 123 450 418 2000 40 40 404 41 2011 91 648 93 46 2012 40 41 44 40 404 41 2011 91 648 93 46 2012 40 41 44 40 404 41 2011 91 648 93 46 2012 40 41 41 59 125 612 439 2010 2013 40 41 123 2010 2011 61 418 40 41 59 2011 91 648 93 61 2003 59 2011 91 648 93 61 2004 59 2011 91 648 93 61 2005 59 450 2011 59 125 125 
79861,C#,"    internal class NEP6Contract : Contract
    {
        public string[] ParameterNames;
        public bool Deployed;

        public static NEP6Contract FromJson(JObject json)
        {
            if (json == null) return null;
            return new NEP6Contract
            {
                Script = Convert.FromBase64String(json[""script""].AsString()),
                ParameterList = ((JArray)json[""parameters""]).Select(p => p[""type""].TryGetEnum<ContractParameterType>()).ToArray(),
                ParameterNames = ((JArray)json[""parameters""]).Select(p => p[""name""].AsString()).ToArray(),
                Deployed = json[""deployed""].AsBoolean()
            };
        }

        public JObject ToJson()
        {
            JObject contract = new();
            contract[""script""] = Convert.ToBase64String(Script);
            contract[""parameters""] = new JArray(ParameterList.Zip(ParameterNames, (type, name) =>
            {
                JObject parameter = new();
                parameter[""name""] = name;
                parameter[""type""] = type;
                return parameter;
            }));
            contract[""deployed""] = Deployed;
            return contract;
        }
    }",0,406 334 2000 58 2001 123 439 461 91 93 2002 59 439 323 2003 59 439 457 2000 2004 40 2005 2006 41 123 392 40 2006 614 424 41 450 424 59 450 418 2000 123 2007 61 2008 46 2009 40 2006 91 648 93 46 2010 40 41 41 44 2011 61 40 40 2012 41 2006 91 648 93 41 46 2013 40 2014 619 2014 91 648 93 46 2015 60 2016 62 40 41 41 46 2017 40 41 44 2002 61 40 40 2012 41 2006 91 648 93 41 46 2013 40 2014 619 2014 91 648 93 46 2010 40 41 41 46 2017 40 41 44 2003 61 2006 91 648 93 46 2018 40 41 125 59 125 439 2005 2019 40 41 123 2005 2020 61 418 40 41 59 2020 91 648 93 61 2021 46 2022 40 2023 41 59 2020 91 648 93 61 418 2024 40 2025 46 2026 40 2002 44 40 2027 44 2028 41 619 123 2005 2029 61 418 40 41 59 2029 91 648 93 61 2028 59 2029 91 648 93 61 2027 59 450 2029 59 125 41 41 59 2020 91 648 93 61 2003 59 450 2020 59 125 125 
79841,C#,"    public static class Helper
    {
        /// <summary>
        /// Signs an <see cref=""IVerifiable""/> with the specified private key.
        /// </summary>
        /// <param name=""verifiable"">The <see cref=""IVerifiable""/> to sign.</param>
        /// <param name=""key"">The private key to be used.</param>
        /// <param name=""network"">The magic number of the NEO network.</param>
        /// <returns>The signature for the <see cref=""IVerifiable""/>.</returns>
        public static byte[] Sign(this IVerifiable verifiable, KeyPair key, uint network)
        {
            return Crypto.Sign(verifiable.GetSignData(network), key.PrivateKey, key.PublicKey.EncodePoint(false)[1..]);
        }

        /// <summary>
        /// Converts the specified script hash to an address.
        /// </summary>
        /// <param name=""scriptHash"">The script hash to convert.</param>
        /// <param name=""version"">The address version.</param>
        /// <returns>The converted address.</returns>
        public static string ToAddress(this UInt160 scriptHash, byte version)
        {
            Span<byte> data = stackalloc byte[21];
            data[0] = version;
            scriptHash.ToArray().CopyTo(data[1..]);
            return Base58.Base58CheckEncode(data);
        }

        /// <summary>
        /// Converts the specified address to a script hash.
        /// </summary>
        /// <param name=""address"">The address to convert.</param>
        /// <param name=""version"">The address version.</param>
        /// <returns>The converted script hash.</returns>
        public static UInt160 ToScriptHash(this string address, byte version)
        {
            byte[] data = address.Base58CheckDecode();
            if (data.Length != 21)
                throw new FormatException();
            if (data[0] != version)
                throw new FormatException();
            return new UInt160(data.AsSpan(1));
        }

        internal static byte[] XOR(byte[] x, byte[] y)
        {
            if (x.Length != y.Length) throw new ArgumentException();
            byte[] r = new byte[x.Length];
            for (int i = 0; i < r.Length; i++)
                r[i] = (byte)(x[i] ^ y[i]);
            return r;
        }
    }",0,439 457 334 2000 123 612 439 457 326 91 93 2001 40 467 2002 2003 44 2004 2005 44 479 2006 41 123 450 2007 46 2001 40 2003 46 2008 40 2006 41 44 2005 46 2009 44 2005 46 2010 46 2011 40 380 41 91 1501 93 41 59 125 612 439 457 461 2012 40 467 2013 2014 44 326 2015 41 123 2016 60 326 62 2017 61 456 326 91 1503 93 59 2017 91 1500 93 61 2015 59 2014 46 2018 40 41 46 2019 40 2017 91 1501 93 41 59 450 2020 46 2021 40 2017 41 59 125 612 439 457 2013 2022 40 467 461 2023 44 326 2015 41 123 326 91 93 2024 61 2023 46 2025 40 41 59 392 40 2024 46 2026 631 1503 41 469 418 2027 40 41 59 392 40 2024 91 1500 93 631 2015 41 469 418 2027 40 41 59 450 418 2013 40 2024 46 2028 40 1501 41 41 59 125 406 457 326 91 93 2029 40 326 91 93 2030 44 326 91 93 2031 41 123 392 40 2030 46 2032 631 2031 46 2032 41 469 418 2033 40 41 59 326 91 93 2034 61 418 326 91 2030 46 2032 93 59 385 40 404 2035 61 1500 59 2035 60 2034 46 2032 59 2035 637 41 2034 91 2035 93 61 40 326 41 40 2030 91 2035 93 94 2031 91 2035 93 41 59 450 2034 59 125 125 
79791,C#,"    public class AssetDescriptor
    {
        /// <summary>
        /// The id of the asset.
        /// </summary>
        public UInt160 AssetId { get; }

        /// <summary>
        /// The name of the asset.
        /// </summary>
        public string AssetName { get; }

        /// <summary>
        /// The symbol of the asset.
        /// </summary>
        public string Symbol { get; }

        /// <summary>
        /// The number of decimal places of the token.
        /// </summary>
        public byte Decimals { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref=""AssetDescriptor""/> class.
        /// </summary>
        /// <param name=""snapshot"">The snapshot used to read data.</param>
        /// <param name=""settings"">The <see cref=""ProtocolSettings""/> used by the <see cref=""ApplicationEngine""/>.</param>
        /// <param name=""asset_id"">The id of the asset.</param>
        public AssetDescriptor(DataCache snapshot, ProtocolSettings settings, UInt160 asset_id)
        {
            var contract = NativeContract.ContractManagement.GetContract(snapshot, asset_id);
            if (contract is null) throw new ArgumentException(null, nameof(asset_id));

            byte[] script;
            using (ScriptBuilder sb = new())
            {
                sb.EmitDynamicCall(asset_id, ""decimals"", CallFlags.ReadOnly);
                sb.EmitDynamicCall(asset_id, ""symbol"", CallFlags.ReadOnly);
                script = sb.ToArray();
            }
            using ApplicationEngine engine = ApplicationEngine.Run(script, snapshot, settings: settings, gas: 0_30000000L);
            if (engine.State != VMState.HALT) throw new ArgumentException(null, nameof(asset_id));
            this.AssetId = asset_id;
            this.AssetName = contract.Manifest.Name;
            this.Symbol = engine.ResultStack.Pop().GetString();
            this.Decimals = (byte)engine.ResultStack.Pop().GetInteger();
        }

        public override string ToString()
        {
            return AssetName;
        }
    }",0,439 334 2000 123 612 439 2001 2002 123 2003 59 125 612 439 461 2004 123 2005 59 125 612 439 461 2006 123 2007 59 125 612 439 326 2008 123 2009 59 125 612 439 2000 40 2010 2011 44 2012 2013 44 2001 2014 41 123 490 2015 61 2016 46 2017 46 2018 40 2011 44 2014 41 59 392 40 2015 407 424 41 469 418 2019 40 424 44 2020 40 2014 41 41 59 326 91 93 2021 59 489 40 2022 2023 61 418 40 41 41 123 2023 46 2024 40 2014 44 648 44 2025 46 2026 41 59 2023 46 2024 40 2014 44 648 44 2025 46 2026 41 59 2021 61 2023 46 2027 40 41 59 125 489 2028 2029 61 2028 46 2030 40 2021 44 2011 44 2013 58 2013 44 2031 58 1500 41 59 392 40 2029 46 2032 631 2033 46 2034 41 469 418 2019 40 424 44 2020 40 2014 41 41 59 467 46 2002 61 2014 59 467 46 2004 61 2015 46 2035 46 2036 59 467 46 2006 61 2029 46 2037 46 2038 40 41 46 2039 40 41 59 467 46 2008 61 40 326 41 2029 46 2037 46 2038 40 41 46 2040 40 41 59 125 439 431 461 2041 40 41 123 450 2004 59 125 125 
79730,C#,"    internal class StorageIterator : IIterator
    {
        private readonly IEnumerator<(StorageKey Key, StorageItem Value)> enumerator;
        private readonly int prefixLength;
        private readonly FindOptions options;
        private readonly ReferenceCounter referenceCounter;

        public StorageIterator(IEnumerator<(StorageKey, StorageItem)> enumerator, int prefixLength, FindOptions options, ReferenceCounter referenceCounter)
        {
            this.enumerator = enumerator;
            this.prefixLength = prefixLength;
            this.options = options;
            this.referenceCounter = referenceCounter;
        }

        public void Dispose()
        {
            enumerator.Dispose();
        }

        public bool Next()
        {
            return enumerator.MoveNext();
        }

        public StackItem Value()
        {
            byte[] key = enumerator.Current.Key.Key;
            byte[] value = enumerator.Current.Value.Value;

            if (options.HasFlag(FindOptions.RemovePrefix))
                key = key[prefixLength..];

            StackItem item = options.HasFlag(FindOptions.DeserializeValues)
                ? BinarySerializer.Deserialize(value, ExecutionEngineLimits.Default, referenceCounter)
                : value;

            if (options.HasFlag(FindOptions.PickField0))
                item = ((Array)item)[0];
            else if (options.HasFlag(FindOptions.PickField1))
                item = ((Array)item)[1];

            if (options.HasFlag(FindOptions.KeysOnly))
                return key;
            if (options.HasFlag(FindOptions.ValuesOnly))
                return item;
            return new Struct(referenceCounter) { key, item };
        }
    }",0,406 334 2000 58 2001 123 437 441 2002 60 40 2003 2004 44 2005 2006 41 62 2007 59 437 441 404 2008 59 437 441 2009 2010 59 437 441 2011 2012 59 439 2000 40 2002 60 40 2003 44 2005 41 62 2007 44 404 2008 44 2009 2010 44 2011 2012 41 123 467 46 2007 61 2007 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 467 46 2012 61 2012 59 125 439 492 2013 40 41 123 2007 46 2013 40 41 59 125 439 323 2014 40 41 123 450 2007 46 2015 40 41 59 125 439 2016 2006 40 41 123 326 91 93 2017 61 2007 46 2018 46 2004 46 2004 59 326 91 93 2019 61 2007 46 2018 46 2006 46 2006 59 392 40 2010 46 2020 40 2009 46 2021 41 41 2017 61 2017 91 2008 46 46 93 59 2016 2022 61 2010 46 2020 40 2009 46 2023 41 63 2024 46 2025 40 2019 44 2026 46 2027 44 2012 41 58 2019 59 392 40 2010 46 2020 40 2009 46 2028 41 41 2022 61 40 40 2029 41 2022 41 91 1500 93 59 360 392 40 2010 46 2020 40 2009 46 2030 41 41 2022 61 40 40 2029 41 2022 41 91 1501 93 59 392 40 2010 46 2020 40 2009 46 2031 41 41 450 2017 59 392 40 2010 46 2020 40 2009 46 2032 41 41 450 2022 59 450 418 2033 40 2012 41 123 2017 44 2022 125 59 125 125 
79946,C#,"        private class ContextItem
        {
            public readonly byte[] Script;
            public readonly ContractParameter[] Parameters;
            public readonly Dictionary<ECPoint, byte[]> Signatures;

            public ContextItem(Contract contract)
            {
                this.Script = contract.Script;
                this.Parameters = contract.ParameterList.Select(p => new ContractParameter { Type = p }).ToArray();
                this.Signatures = new Dictionary<ECPoint, byte[]>();
            }

            public ContextItem(JObject json)
            {
                this.Script = Convert.FromBase64String(json[""script""].AsString());
                this.Parameters = ((JArray)json[""parameters""]).Select(p => ContractParameter.FromJson(p)).ToArray();
                this.Signatures = json[""signatures""].Properties.Select(p => new
                {
                    PublicKey = ECPoint.Parse(p.Key, ECCurve.Secp256r1),
                    Signature = Convert.FromBase64String(p.Value.AsString())
                }).ToDictionary(p => p.PublicKey, p => p.Signature);
            }

            public JObject ToJson()
            {
                JObject json = new();
                json[""script""] = Convert.ToBase64String(Script);
                json[""parameters""] = new JArray(Parameters.Select(p => p.ToJson()));
                json[""signatures""] = new JObject();
                foreach (var signature in Signatures)
                    json[""signatures""][signature.Key.ToString()] = Convert.ToBase64String(signature.Value);
                return json;
            }
        }",0,437 334 2000 123 439 441 326 91 93 2001 59 439 441 2002 91 93 2003 59 439 441 2004 60 2005 44 326 91 93 62 2006 59 439 2000 40 2007 2008 41 123 467 46 2001 61 2008 46 2001 59 467 46 2003 61 2008 46 2009 46 2010 40 2011 619 418 2002 123 2012 61 2011 125 41 46 2013 40 41 59 467 46 2006 61 418 2004 60 2005 44 326 91 93 62 40 41 59 125 439 2000 40 2014 2015 41 123 467 46 2001 61 2016 46 2017 40 2015 91 648 93 46 2018 40 41 41 59 467 46 2003 61 40 40 2019 41 2015 91 648 93 41 46 2020 40 2021 619 2002 46 2022 40 2021 41 41 46 2023 40 41 59 467 46 2006 61 2015 91 648 93 46 2024 46 2020 40 2021 619 418 123 2025 61 2005 46 2026 40 2021 46 2027 44 2028 46 2029 41 44 2030 61 2016 46 2017 40 2021 46 2031 46 2018 40 41 41 125 41 46 2032 40 2021 619 2021 46 2033 44 2021 619 2021 46 2034 41 59 125 439 2014 2035 40 41 123 2014 2015 61 418 40 41 59 2015 91 648 93 61 2036 46 2037 40 2001 41 59 2015 91 648 93 61 418 2038 40 2003 46 2039 40 2040 619 2040 46 2035 40 41 41 41 59 2015 91 648 93 61 418 2014 40 41 59 386 40 490 2041 398 2006 41 2015 91 648 93 91 2041 46 2042 46 2043 40 41 93 61 2036 46 2037 40 2041 46 2044 41 59 450 2015 59 125 125 
79767,C#,"    internal class TaskSession
    {
        public Dictionary<UInt256, DateTime> InvTasks { get; } = new Dictionary<UInt256, DateTime>();
        public Dictionary<uint, DateTime> IndexTasks { get; } = new Dictionary<uint, DateTime>();
        public HashSet<UInt256> AvailableTasks { get; } = new HashSet<UInt256>();
        public Dictionary<uint, Block> ReceivedBlock { get; } = new Dictionary<uint, Block>();
        public bool HasTooManyTasks => InvTasks.Count + IndexTasks.Count >= 100;
        public bool IsFullNode { get; }
        public uint LastBlockIndex { get; set; }
        public bool MempoolSent { get; set; }

        public TaskSession(VersionPayload version)
        {
            var fullNode = version.Capabilities.OfType<FullNodeCapability>().FirstOrDefault();
            this.IsFullNode = fullNode != null;
            this.LastBlockIndex = fullNode?.StartHeight ?? 0;
        }
    }",0,406 334 2000 123 439 2001 60 2002 44 2003 62 2004 123 2005 59 125 61 418 2001 60 2002 44 2003 62 40 41 59 439 2001 60 479 44 2003 62 2006 123 2007 59 125 61 418 2001 60 479 44 2003 62 40 41 59 439 2008 60 2002 62 2009 123 2010 59 125 61 418 2008 60 2002 62 40 41 59 439 2001 60 479 44 2011 62 2012 123 2013 59 125 61 418 2001 60 479 44 2011 62 40 41 59 439 323 2014 619 2004 46 2015 43 2006 46 2015 615 1503 59 439 323 2016 123 2017 59 125 439 479 2018 123 2019 59 2020 59 125 439 323 2021 123 2022 59 2023 59 125 439 2000 40 2024 2025 41 123 490 2026 61 2025 46 2027 46 2028 60 2029 62 40 41 46 2030 40 41 59 467 46 2016 61 2026 631 424 59 467 46 2018 61 2026 634 2031 633 1500 59 125 125 
79906,C#,"    internal class TaskManagerMailbox : PriorityMailbox
    {
        public TaskManagerMailbox(Akka.Actor.Settings settings, Config config)
            : base(settings, config)
        {
        }

        internal protected override bool IsHighPriority(object message)
        {
            switch (message)
            {
                case TaskManager.Register _:
                case TaskManager.Update _:
                case TaskManager.RestartTasks _:
                    return true;
                case TaskManager.NewTasks tasks:
                    if (tasks.Payload.Type == InventoryType.Block || tasks.Payload.Type == InventoryType.Extensible)
                        return true;
                    return false;
                default:
                    return false;
            }
        }

        internal protected override bool ShallDrop(object message, IEnumerable queue)
        {
            if (message is not TaskManager.NewTasks tasks) return false;
            // Remove duplicate tasks
            if (queue.OfType<TaskManager.NewTasks>().Any(x => x.Payload.Type == tasks.Payload.Type && x.Payload.Hashes.SequenceEqual(tasks.Payload.Hashes))) return true;
            return false;
        }
    }",0,406 334 2000 58 2001 123 439 2000 40 2002 46 2003 46 2004 2005 44 2006 2007 41 58 320 40 2005 44 2007 41 123 125 406 438 431 323 2008 40 426 2009 41 123 464 40 2009 41 123 328 2010 46 2011 2012 58 328 2010 46 2013 2012 58 328 2010 46 2014 2012 58 450 473 59 328 2010 46 2015 2016 58 392 40 2016 46 2017 46 2018 614 2019 46 2020 606 2016 46 2017 46 2018 614 2019 46 2021 41 450 473 59 450 380 59 349 58 450 380 59 125 125 406 438 431 323 2022 40 426 2009 44 2023 2024 41 123 392 40 2009 407 422 2025 46 2026 2027 41 450 380 59 621 392 40 2024 46 2028 60 2025 46 2026 62 40 41 46 2029 40 2030 619 2030 46 2031 46 2032 614 2027 46 2031 46 2032 605 2030 46 2031 46 2033 46 2034 40 2027 46 2031 46 2033 41 41 41 450 473 59 450 380 59 125 125 
80002,C#,"    internal class RemoteNodeMailbox : PriorityMailbox
    {
        public RemoteNodeMailbox(Settings settings, Config config) : base(settings, config) { }

        internal protected override bool IsHighPriority(object message)
        {
            return message switch
            {
                Message msg => msg.Command switch
                {
                    MessageCommand.Extensible or MessageCommand.FilterAdd or MessageCommand.FilterClear or MessageCommand.FilterLoad or MessageCommand.Verack or MessageCommand.Version or MessageCommand.Alert => true,
                    _ => false,
                },
                Tcp.ConnectionClosed _ or Connection.Close _ or Connection.Ack _ => true,
                _ => false,
            };
        }

        internal protected override bool ShallDrop(object message, IEnumerable queue)
        {
            if (message is not Message msg) return false;
            return msg.Command switch
            {
                MessageCommand.GetAddr or MessageCommand.GetBlocks or MessageCommand.GetHeaders or MessageCommand.Mempool => queue.OfType<Message>().Any(p => p.Command == msg.Command),
                _ => false,
            };
        }
    }
}
",0,406 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 2005 41 58 320 40 2003 44 2005 41 123 125 406 438 431 323 2006 40 426 2007 41 123 450 2007 464 123 2008 2009 619 2009 46 2010 464 123 2011 46 2012 428 2011 46 2013 428 2011 46 2014 428 2011 46 2015 428 2011 46 2016 428 2011 46 2017 428 2011 46 2018 619 473 44 2019 619 380 44 125 44 2020 46 2021 2022 428 2023 46 2024 2022 428 2023 46 2025 2022 619 473 44 2022 619 380 44 125 59 125 406 438 431 323 2026 40 426 2007 44 2027 2028 41 123 392 40 2007 407 422 2029 2030 41 450 380 59 450 2030 46 2031 464 123 2032 46 2033 428 2032 46 2034 428 2032 46 2035 428 2032 46 2036 619 2028 46 2037 60 2029 62 40 41 46 2038 40 2039 619 2039 46 2031 614 2030 46 2031 41 44 2040 619 380 44 125 59 125 125 125 
79762,C#,"    public static class Helper
    {
        /// <summary>
        /// Calculates the hash of a <see cref=""IVerifiable""/>.
        /// </summary>
        /// <param name=""verifiable"">The <see cref=""IVerifiable""/> object to hash.</param>
        /// <returns>The hash of the object.</returns>
        public static UInt256 CalculateHash(this IVerifiable verifiable)
        {
            using MemoryStream ms = new();
            using BinaryWriter writer = new(ms);
            verifiable.SerializeUnsigned(writer);
            writer.Flush();
            return new UInt256(ms.ToArray().Sha256());
        }

        /// <summary>
        /// Gets the data of a <see cref=""IVerifiable""/> object to be hashed.
        /// </summary>
        /// <param name=""verifiable"">The <see cref=""IVerifiable""/> object to hash.</param>
        /// <param name=""network"">The magic number of the network.</param>
        /// <returns>The data to hash.</returns>
        public static byte[] GetSignData(this IVerifiable verifiable, uint network)
        {
            using MemoryStream ms = new();
            using BinaryWriter writer = new(ms);
            writer.Write(network);
            writer.Write(verifiable.Hash);
            writer.Flush();
            return ms.ToArray();
        }
    }",0,439 457 334 2000 123 612 439 457 2001 2002 40 467 2003 2004 41 123 489 2005 2006 61 418 40 41 59 489 2007 2008 61 418 40 2006 41 59 2004 46 2009 40 2008 41 59 2008 46 2010 40 41 59 450 418 2001 40 2006 46 2011 40 41 46 2012 40 41 41 59 125 612 439 457 326 91 93 2013 40 467 2003 2004 44 479 2014 41 123 489 2015 2016 61 418 40 41 59 489 2017 2018 61 418 40 2016 41 59 2018 46 2019 40 2014 41 59 2018 46 2019 40 2004 46 2020 41 59 2018 46 2021 40 41 59 450 2016 46 2022 40 41 59 125 125 
79954,C#,"    public class Witness : ISerializable
    {
        // This is designed to allow a MultiSig 21/11 (committee)
        // Invocation = 11 * (64 + 2) = 726
        private const int MaxInvocationScript = 1024;

        // Verification = m + (PUSH_PubKey * 21) + length + null + syscall = 1 + ((2 + 33) * 21) + 2 + 1 + 5 = 744
        private const int MaxVerificationScript = 1024;

        /// <summary>
        /// The invocation script of the witness. Used to pass arguments for <see cref=""VerificationScript""/>.
        /// </summary>
        public byte[] InvocationScript;

        /// <summary>
        /// The verification script of the witness. It can be empty if the contract is deployed.
        /// </summary>
        public byte[] VerificationScript;

        private UInt160 _scriptHash;
        /// <summary>
        /// The hash of the <see cref=""VerificationScript""/>.
        /// </summary>
        public UInt160 ScriptHash
        {
            get
            {
                if (_scriptHash == null)
                {
                    _scriptHash = VerificationScript.ToScriptHash();
                }
                return _scriptHash;
            }
        }

        public int Size => InvocationScript.GetVarSize() + VerificationScript.GetVarSize();

        void ISerializable.Deserialize(BinaryReader reader)
        {
            InvocationScript = reader.ReadVarBytes(MaxInvocationScript);
            VerificationScript = reader.ReadVarBytes(MaxVerificationScript);
        }

        void ISerializable.Serialize(BinaryWriter writer)
        {
            writer.WriteVarBytes(InvocationScript);
            writer.WriteVarBytes(VerificationScript);
        }

        /// <summary>
        /// Converts the witness to a JSON object.
        /// </summary>
        /// <returns>The witness represented by a JSON object.</returns>
        public JObject ToJson()
        {
            JObject json = new();
            json[""invocation""] = Convert.ToBase64String(InvocationScript);
            json[""verification""] = Convert.ToBase64String(VerificationScript);
            return json;
        }
    }",0,439 334 2000 58 2001 123 621 621 437 341 404 2002 61 1505 59 621 437 341 404 2003 61 1505 59 612 439 326 91 93 2004 59 612 439 326 91 93 2005 59 437 2006 2007 59 612 439 2006 2008 123 2009 123 392 40 2007 614 424 41 123 2007 61 2005 46 2010 40 41 59 125 450 2007 59 125 125 439 404 2011 619 2004 46 2012 40 41 43 2005 46 2012 40 41 59 492 2001 46 2013 40 2014 2015 41 123 2004 61 2015 46 2016 40 2002 41 59 2005 61 2015 46 2016 40 2003 41 59 125 492 2001 46 2017 40 2018 2019 41 123 2019 46 2020 40 2004 41 59 2019 46 2020 40 2005 41 59 125 612 439 2021 2022 40 41 123 2021 2023 61 418 40 41 59 2023 91 648 93 61 2024 46 2025 40 2004 41 59 2023 91 648 93 61 2024 46 2025 40 2005 41 59 450 2023 59 125 125 
79897,C#,"    public abstract class Connection : UntypedActor
    {
        internal class Close { public bool Abort; }
        internal class Ack : Tcp.Event { public static Ack Instance = new(); }

        /// <summary>
        /// connection initial timeout (in seconds) before any package has been accepted.
        /// </summary>
        private const int connectionTimeoutLimitStart = 10;

        /// <summary>
        /// connection timeout (in seconds) after every `OnReceived(ByteString data)` event.
        /// </summary>
        private const int connectionTimeoutLimit = 60;

        /// <summary>
        /// The address of the remote node.
        /// </summary>
        public IPEndPoint Remote { get; }

        /// <summary>
        /// The address of the local node.
        /// </summary>
        public IPEndPoint Local { get; }

        private ICancelable timer;
        private readonly IActorRef tcp;
        private readonly WebSocket ws;
        private bool disconnected = false;

        /// <summary>
        /// Initializes a new instance of the <see cref=""Connection""/> class.
        /// </summary>
        /// <param name=""connection"">The underlying connection object.</param>
        /// <param name=""remote"">The address of the remote node.</param>
        /// <param name=""local"">The address of the local node.</param>
        protected Connection(object connection, IPEndPoint remote, IPEndPoint local)
        {
            this.Remote = remote;
            this.Local = local;
            this.timer = Context.System.Scheduler.ScheduleTellOnceCancelable(TimeSpan.FromSeconds(connectionTimeoutLimitStart), Self, new Close { Abort = true }, ActorRefs.NoSender);
            switch (connection)
            {
                case IActorRef tcp:
                    this.tcp = tcp;
                    break;
                case WebSocket ws:
                    this.ws = ws;
                    WsReceive();
                    break;
            }
        }

        private void WsReceive()
        {
            byte[] buffer = new byte[512];
            ws.ReceiveAsync(buffer, CancellationToken.None).PipeTo(Self,
                success: p =>
                {
                    switch (p.MessageType)
                    {
                        case WebSocketMessageType.Binary:
                            return new Tcp.Received(ByteString.FromBytes(buffer, 0, p.Count));
                        case WebSocketMessageType.Close:
                            return Tcp.PeerClosed.Instance;
                        default:
                            ws.Abort();
                            return Tcp.Aborted.Instance;
                    }
                },
                failure: ex => new Tcp.ErrorClosed(ex.Message));
        }

        /// <summary>
        /// Disconnect from the remote node.
        /// </summary>
        /// <param name=""abort"">Indicates whether the TCP ABORT command should be sent.</param>
        public void Disconnect(bool abort = false)
        {
            disconnected = true;
            if (tcp != null)
            {
                tcp.Tell(abort ? Tcp.Abort.Instance : Tcp.Close.Instance);
            }
            else
            {
                ws.Abort();
            }
            Context.Stop(Self);
        }

        /// <summary>
        /// Called when a TCP ACK message is received.
        /// </summary>
        protected virtual void OnAck()
        {
        }

        /// <summary>
        /// Called when data is received.
        /// </summary>
        /// <param name=""data"">The received data.</param>
        protected abstract void OnData(ByteString data);

        protected override void OnReceive(object message)
        {
            switch (message)
            {
                case Close close:
                    Disconnect(close.Abort);
                    break;
                case Ack _:
                    OnAck();
                    break;
                case Tcp.Received received:
                    OnReceived(received.Data);
                    break;
                case Tcp.ConnectionClosed _:
                    Context.Stop(Self);
                    break;
            }
        }

        private void OnReceived(ByteString data)
        {
            timer.CancelIfNotNull();
            timer = Context.System.Scheduler.ScheduleTellOnceCancelable(TimeSpan.FromSeconds(connectionTimeoutLimit), Self, new Close { Abort = true }, ActorRefs.NoSender);
            try
            {
                OnData(data);
            }
            catch
            {
                Disconnect(true);
            }
        }

        protected override void PostStop()
        {
            if (!disconnected)
                tcp?.Tell(Tcp.Close.Instance);
            timer.CancelIfNotNull();
            ws?.Dispose();
            base.PostStop();
        }

        /// <summary>
        /// Sends data to the remote node.
        /// </summary>
        /// <param name=""data""></param>
        protected void SendData(ByteString data)
        {
            if (tcp != null)
            {
                tcp.Tell(Tcp.Write.Create(data, Ack.Instance));
            }
            else
            {
                ArraySegment<byte> segment = new(data.ToArray());
                ws.SendAsync(segment, WebSocketMessageType.Binary, true, CancellationToken.None).PipeTo(Self,
                    success: () => Ack.Instance,
                    failure: ex => new Tcp.ErrorClosed(ex.Message));
            }
        }
    }",0,439 305 334 2000 58 2001 123 406 334 2002 123 439 323 2003 59 125 406 334 2004 58 2005 46 2006 123 439 457 2004 2007 61 418 40 41 59 125 612 437 341 404 2008 61 1502 59 612 437 341 404 2009 61 1503 59 612 439 2010 2011 123 2012 59 125 612 439 2010 2013 123 2014 59 125 437 2015 2016 59 437 441 2017 2018 59 437 441 2019 2020 59 437 323 2021 61 380 59 612 438 2000 40 426 2022 44 2010 2023 44 2010 2024 41 123 467 46 2011 61 2023 59 467 46 2013 61 2024 59 467 46 2016 61 2025 46 2026 46 2027 46 2028 40 2029 46 2030 40 2008 41 44 2031 44 418 2002 123 2032 61 473 125 44 2033 46 2034 41 59 464 40 2022 41 123 328 2017 2018 58 467 46 2018 61 2018 59 325 59 328 2019 2020 58 467 46 2020 61 2020 59 2035 40 41 59 325 59 125 125 437 492 2036 40 41 123 326 91 93 2037 61 418 326 91 1504 93 59 2020 46 2038 40 2037 44 2039 46 303 41 46 2040 40 2041 44 2042 58 2043 619 123 464 40 2043 46 2044 41 123 328 2045 46 2046 58 450 418 2005 46 2047 40 2048 46 2049 40 2037 44 1500 44 2043 46 2050 41 41 59 328 2045 46 2002 58 450 2005 46 2051 46 2052 59 349 58 2020 46 2053 40 41 59 450 2005 46 2054 46 2052 59 125 125 44 2055 58 2056 619 418 2005 46 2057 40 2056 46 2058 41 41 59 125 612 439 492 2059 40 323 2060 61 380 41 123 2021 61 473 59 392 40 2018 631 424 41 123 2018 46 2061 40 2060 63 2005 46 2062 46 2063 58 2005 46 2002 46 2063 41 59 125 360 123 2020 46 2064 40 41 59 125 2065 46 2066 40 2067 41 59 125 612 438 491 492 2068 40 41 123 125 612 438 305 492 2069 40 2070 2071 41 59 438 431 492 2072 40 426 2073 41 123 464 40 2073 41 123 328 2002 2074 58 2059 40 2074 46 2075 41 59 325 59 328 2004 2076 58 2068 40 41 59 325 59 328 2005 46 2077 2078 58 2079 40 2078 46 2080 41 59 325 59 328 2005 46 2081 2076 58 2082 46 2083 40 2084 41 59 325 59 125 125 437 492 2085 40 2070 2071 41 123 2016 46 2086 40 41 59 2016 61 2087 46 2088 46 2089 46 2090 40 2091 46 2092 40 2009 41 44 2093 44 418 2002 123 2094 61 473 125 44 2095 46 2096 41 59 474 123 2069 40 2071 41 59 125 329 123 2059 40 473 41 59 125 125 438 431 492 2097 40 41 123 392 40 33 2021 41 2018 634 2098 40 2005 46 2002 46 2099 41 59 2016 46 2100 40 41 59 2020 634 2101 40 41 59 320 46 2097 40 41 59 125 612 438 492 2102 40 2070 2071 41 123 392 40 2018 631 424 41 123 2018 46 2103 40 2005 46 2104 46 2105 40 2071 44 2004 46 2106 41 41 59 125 360 123 2107 60 326 62 2108 61 418 40 2071 46 2109 40 41 41 59 2020 46 2110 40 2108 44 2111 46 2112 44 473 44 2113 46 303 41 46 2114 40 2115 44 2116 58 40 41 619 2004 46 2117 44 2118 58 2119 619 418 2005 46 2120 40 2119 46 2121 41 41 59 125 125 125 
79989,C#,"    internal class BlockchainMailbox : PriorityMailbox
    {
        public BlockchainMailbox(Settings settings, Config config)
            : base(settings, config)
        {
        }

        internal protected override bool IsHighPriority(object message)
        {
            return message switch
            {
                Header[] or Block or ExtensiblePayload or Terminated => true,
                _ => false,
            };
        }
    }
}
",0,406 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 2005 41 58 320 40 2003 44 2005 41 123 125 406 438 431 323 2006 40 426 2007 41 123 450 2007 464 123 2008 91 93 428 2009 428 2010 428 2011 619 473 44 2012 619 380 44 125 59 125 125 125 
79955,C#,"    public class GetBlocksPayload : ISerializable
    {
        /// <summary>
        /// The starting hash of the blocks to request.
        /// </summary>
        public UInt256 HashStart;

        /// <summary>
        /// The number of blocks to request.
        /// </summary>
        public short Count;

        public int Size => sizeof(short) + HashStart.Size;

        /// <summary>
        /// Creates a new instance of the <see cref=""GetBlocksPayload""/> class.
        /// </summary>
        /// <param name=""hash_start"">The starting hash of the blocks to request.</param>
        /// <param name=""count"">The number of blocks to request. Set this parameter to -1 to request as many blocks as possible.</param>
        /// <returns>The created payload.</returns>
        public static GetBlocksPayload Create(UInt256 hash_start, short count = -1)
        {
            return new GetBlocksPayload
            {
                HashStart = hash_start,
                Count = count
            };
        }

        void ISerializable.Deserialize(BinaryReader reader)
        {
            HashStart = reader.ReadSerializable<UInt256>();
            Count = reader.ReadInt16();
            if (Count < -1 || Count == 0) throw new FormatException();
        }

        void ISerializable.Serialize(BinaryWriter writer)
        {
            writer.Write(HashStart);
            writer.Write(Count);
        }
    }",0,439 334 2000 58 2001 123 612 439 2002 2003 59 612 439 453 2004 59 439 404 2005 619 455 40 453 41 43 2003 46 2005 59 612 439 457 2000 2006 40 2002 2007 44 453 2008 61 45 1501 41 123 450 418 2000 123 2003 61 2007 44 2004 61 2008 125 59 125 492 2001 46 2009 40 2010 2011 41 123 2003 61 2011 46 2012 60 2002 62 40 41 59 2004 61 2011 46 2013 40 41 59 392 40 2004 60 45 1501 606 2004 614 1500 41 469 418 2014 40 41 59 125 492 2001 46 2015 40 2016 2017 41 123 2017 46 2018 40 2003 41 59 2017 46 2018 40 2004 41 59 125 125 
70190,C#,"public class SqlServerHistoryRepository : HistoryRepository
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public SqlServerHistoryRepository(HistoryRepositoryDependencies dependencies)
        : base(dependencies)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override string ExistsSql
    {
        get
        {
            var stringTypeMapping = Dependencies.TypeMappingSource.GetMapping(typeof(string));

            return ""SELECT OBJECT_ID(""
                + stringTypeMapping.GenerateSqlLiteral(
                    SqlGenerationHelper.DelimitIdentifier(TableName, TableSchema))
                + "")""
                + SqlGenerationHelper.StatementTerminator;
        }
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override bool InterpretExistsResult(object? value)
        => value != DBNull.Value;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override string GetCreateIfNotExistsScript()
    {
        var stringTypeMapping = Dependencies.TypeMappingSource.GetMapping(typeof(string));

        var builder = new StringBuilder()
            .Append(""IF OBJECT_ID("")
            .Append(
                stringTypeMapping.GenerateSqlLiteral(
                    SqlGenerationHelper.DelimitIdentifier(TableName, TableSchema)))
            .AppendLine("") IS NULL"")
            .AppendLine(""BEGIN"");

        using (var reader = new StringReader(GetCreateScript()))
        {
            var first = true;
            string? line;
            while ((line = reader.ReadLine()) != null)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    builder.AppendLine();
                }

                if (line.Length != 0)
                {
                    builder
                        .Append(""    "")
                        .Append(line);
                }
            }
        }

        builder
            .AppendLine()
            .Append(""END"")
            .AppendLine(SqlGenerationHelper.StatementTerminator);

        return builder.ToString();
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override string GetBeginIfNotExistsScript(string migrationId)
    {
        var stringTypeMapping = Dependencies.TypeMappingSource.GetMapping(typeof(string));

        return new StringBuilder()
            .Append(""IF NOT EXISTS(SELECT * FROM "")
            .Append(SqlGenerationHelper.DelimitIdentifier(TableName, TableSchema))
            .Append("" WHERE "")
            .Append(SqlGenerationHelper.DelimitIdentifier(MigrationIdColumnName))
            .Append("" = "")
            .Append(stringTypeMapping.GenerateSqlLiteral(migrationId))
            .AppendLine("")"")
            .Append(""BEGIN"")
            .ToString();
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override string GetBeginIfExistsScript(string migrationId)
    {
        var stringTypeMapping = Dependencies.TypeMappingSource.GetMapping(typeof(string));

        return new StringBuilder()
            .Append(""IF EXISTS(SELECT * FROM "")
            .Append(SqlGenerationHelper.DelimitIdentifier(TableName, TableSchema))
            .Append("" WHERE "")
            .Append(SqlGenerationHelper.DelimitIdentifier(MigrationIdColumnName))
            .Append("" = "")
            .Append(stringTypeMapping.GenerateSqlLiteral(migrationId))
            .AppendLine("")"")
            .Append(""BEGIN"")
            .ToString();
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override string GetEndIfScript()
        => new StringBuilder()
            .Append(""END"")
            .AppendLine(SqlGenerationHelper.StatementTerminator)
            .ToString();
}",0,439 334 2000 58 2001 123 612 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 612 438 431 461 2004 123 2005 123 490 2006 61 2007 46 2008 46 2009 40 478 40 461 41 41 59 450 648 43 2006 46 2010 40 2011 46 2012 40 2013 44 2014 41 41 43 648 43 2011 46 2015 59 125 125 612 438 431 323 2016 40 426 63 2017 41 619 2017 631 2018 46 2019 59 612 439 431 461 2020 40 41 123 490 2021 61 2022 46 2023 46 2024 40 478 40 461 41 41 59 490 2025 61 418 2026 40 41 46 2027 40 648 41 46 2027 40 2021 46 2028 40 2029 46 2030 40 2031 44 2032 41 41 41 46 2033 40 648 41 46 2033 40 648 41 59 489 40 490 2034 61 418 2035 40 2036 40 41 41 41 123 490 2037 61 473 59 461 63 2038 59 496 40 40 2038 61 2034 46 2039 40 41 41 631 424 41 123 392 40 2037 41 123 2037 61 380 59 125 360 123 2025 46 2033 40 41 59 125 392 40 2038 46 2040 631 1500 41 123 2025 46 2027 40 648 41 46 2027 40 2038 41 59 125 125 125 2025 46 2033 40 41 46 2027 40 648 41 46 2033 40 2029 46 2041 41 59 450 2025 46 2042 40 41 59 125 612 439 431 461 2043 40 461 2044 41 123 490 2045 61 2046 46 2047 46 2048 40 478 40 461 41 41 59 450 418 2049 40 41 46 2050 40 648 41 46 2050 40 2051 46 2052 40 2053 44 2054 41 41 46 2050 40 648 41 46 2050 40 2051 46 2052 40 2055 41 41 46 2050 40 648 41 46 2050 40 2045 46 2056 40 2044 41 41 46 2057 40 648 41 46 2050 40 648 41 46 2058 40 41 59 125 612 439 431 461 2059 40 461 2044 41 123 490 2060 61 2061 46 2062 46 2063 40 478 40 461 41 41 59 450 418 2064 40 41 46 2065 40 648 41 46 2065 40 2066 46 2067 40 2068 44 2069 41 41 46 2065 40 648 41 46 2065 40 2066 46 2067 40 2070 41 41 46 2065 40 648 41 46 2065 40 2060 46 2071 40 2044 41 41 46 2072 40 648 41 46 2065 40 648 41 46 2073 40 41 59 125 612 439 431 461 2074 40 41 619 418 2075 40 41 46 2076 40 648 41 46 2077 40 2078 46 2079 41 46 2080 40 41 59 125 
79963,C#,"    public class FilterLoadPayload : ISerializable
    {
        /// <summary>
        /// The data of the <see cref=""BloomFilter""/>.
        /// </summary>
        public byte[] Filter;

        /// <summary>
        /// The number of hash functions used by the <see cref=""BloomFilter""/>.
        /// </summary>
        public byte K;

        /// <summary>
        /// Used to generate the seeds of the murmur hash functions.
        /// </summary>
        public uint Tweak;

        public int Size => Filter.GetVarSize() + sizeof(byte) + sizeof(uint);

        /// <summary>
        /// Creates a new instance of the <see cref=""FilterLoadPayload""/> class.
        /// </summary>
        /// <param name=""filter"">The fields in the filter will be copied to the payload.</param>
        /// <returns>The created payload.</returns>
        public static FilterLoadPayload Create(BloomFilter filter)
        {
            byte[] buffer = new byte[filter.M / 8];
            filter.GetBits(buffer);
            return new FilterLoadPayload
            {
                Filter = buffer,
                K = (byte)filter.K,
                Tweak = filter.Tweak
            };
        }

        void ISerializable.Deserialize(BinaryReader reader)
        {
            Filter = reader.ReadVarBytes(36000);
            K = reader.ReadByte();
            if (K > 50) throw new FormatException();
            Tweak = reader.ReadUInt32();
        }

        void ISerializable.Serialize(BinaryWriter writer)
        {
            writer.WriteVarBytes(Filter);
            writer.Write(K);
            writer.Write(Tweak);
        }
    }",0,439 334 2000 58 2001 123 612 439 326 91 93 2002 59 612 439 326 2003 59 612 439 479 2004 59 439 404 2005 619 2002 46 2006 40 41 43 455 40 326 41 43 455 40 479 41 59 612 439 457 2000 2007 40 2008 2009 41 123 326 91 93 2010 61 418 326 91 2009 46 2011 47 1502 93 59 2009 46 2012 40 2010 41 59 450 418 2000 123 2002 61 2010 44 2003 61 40 326 41 2009 46 2003 44 2004 61 2009 46 2004 125 59 125 492 2001 46 2013 40 2014 2015 41 123 2002 61 2015 46 2016 40 1506 41 59 2003 61 2015 46 2017 40 41 59 392 40 2003 62 1503 41 469 418 2018 40 41 59 2004 61 2015 46 2019 40 41 59 125 492 2001 46 2020 40 2021 2022 41 123 2022 46 2023 40 2002 41 59 2022 46 2024 40 2003 41 59 2022 46 2024 40 2004 41 59 125 125 
79788,C#,"    public class FilterAddPayload : ISerializable
    {
        /// <summary>
        /// The items to be added.
        /// </summary>
        public byte[] Data;

        public int Size => Data.GetVarSize();

        void ISerializable.Deserialize(BinaryReader reader)
        {
            Data = reader.ReadVarBytes(520);
        }

        void ISerializable.Serialize(BinaryWriter writer)
        {
            writer.WriteVarBytes(Data);
        }
    }",0,439 334 2000 58 2001 123 612 439 326 91 93 2002 59 439 404 2003 619 2002 46 2004 40 41 59 492 2001 46 2005 40 2006 2007 41 123 2002 61 2007 46 2008 40 1504 41 59 125 492 2001 46 2009 40 2010 2011 41 123 2011 46 2012 40 2002 41 59 125 125 
79908,C#,"    internal class RelayCache : FIFOCache<UInt256, IInventory>
    {
        public RelayCache(int max_capacity)
            : base(max_capacity)
        {
        }

        protected override UInt256 GetKeyForItem(IInventory item)
        {
            return item.Hash;
        }
    }",0,406 334 2000 58 2001 60 2002 44 2003 62 123 439 2000 40 404 2004 41 58 320 40 2004 41 123 125 438 431 2002 2005 40 2003 2006 41 123 450 2006 46 2007 59 125 125 
79836,C#,"    internal class PriorityMessageQueue : IMessageQueue, IUnboundedMessageQueueSemantics
    {
        private readonly ConcurrentQueue<Envelope> high = new();
        private readonly ConcurrentQueue<Envelope> low = new();
        private readonly Func<object, IEnumerable, bool> dropper;
        private readonly Func<object, bool> priority_generator;
        private int idle = 1;

        public bool HasMessages => !high.IsEmpty || !low.IsEmpty;
        public int Count => high.Count + low.Count;

        public PriorityMessageQueue(Func<object, IEnumerable, bool> dropper, Func<object, bool> priority_generator)
        {
            this.dropper = dropper;
            this.priority_generator = priority_generator;
        }

        public void CleanUp(IActorRef owner, IMessageQueue deadletters)
        {
        }

        public void Enqueue(IActorRef receiver, Envelope envelope)
        {
            Interlocked.Increment(ref idle);
            if (envelope.Message is Idle) return;
            if (dropper(envelope.Message, high.Concat(low).Select(p => p.Message)))
                return;
            ConcurrentQueue<Envelope> queue = priority_generator(envelope.Message) ? high : low;
            queue.Enqueue(envelope);
        }

        public bool TryDequeue(out Envelope envelope)
        {
            if (high.TryDequeue(out envelope)) return true;
            if (low.TryDequeue(out envelope)) return true;
            if (Interlocked.Exchange(ref idle, 0) > 0)
            {
                envelope = new Envelope(Idle.Instance, ActorRefs.NoSender);
                return true;
            }
            return false;
        }
    }",0,406 334 2000 58 2001 44 2002 123 437 441 2003 60 2004 62 2005 61 418 40 41 59 437 441 2003 60 2004 62 2006 61 418 40 41 59 437 441 2007 60 426 44 2008 44 323 62 2009 59 437 441 2007 60 426 44 323 62 2010 59 437 404 2011 61 1501 59 439 323 2012 619 33 2005 46 2013 606 33 2006 46 2013 59 439 404 2014 619 2005 46 2014 43 2006 46 2014 59 439 2000 40 2007 60 426 44 2008 44 323 62 2009 44 2007 60 426 44 323 62 2010 41 123 467 46 2009 61 2009 59 467 46 2010 61 2010 59 125 439 492 2015 40 2016 2017 44 2001 2018 41 123 125 439 492 2019 40 2016 2020 44 2004 2021 41 123 2022 46 2023 40 442 2011 41 59 392 40 2021 46 2024 407 2025 41 450 59 392 40 2009 40 2021 46 2024 44 2005 46 2026 40 2006 41 46 2027 40 2028 619 2028 46 2024 41 41 41 450 59 2003 60 2004 62 2029 61 2010 40 2021 46 2024 41 63 2005 58 2006 59 2029 46 2019 40 2021 41 59 125 439 323 2030 40 430 2004 2021 41 123 392 40 2005 46 2030 40 430 2021 41 41 450 473 59 392 40 2006 46 2030 40 430 2021 41 41 450 473 59 392 40 2031 46 2032 40 442 2011 44 1500 41 62 1500 41 123 2021 61 418 2004 40 2033 46 2034 44 2035 46 2036 41 59 450 473 59 125 450 380 59 125 125 
68200,C#,"public static class SqlServerIndexBuilderExtensions
{
    /// <summary>
    ///     Configures whether the index is clustered when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""clustered"">A value indicating whether the index is clustered.</param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder IsClustered(this IndexBuilder indexBuilder, bool clustered = true)
    {
        indexBuilder.Metadata.SetIsClustered(clustered);

        return indexBuilder;
    }

    /// <summary>
    ///     Configures whether the index is clustered when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""clustered"">A value indicating whether the index is clustered.</param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder<TEntity> IsClustered<TEntity>(
        this IndexBuilder<TEntity> indexBuilder,
        bool clustered = true)
        => (IndexBuilder<TEntity>)IsClustered((IndexBuilder)indexBuilder, clustered);

    /// <summary>
    ///     Configures whether the index is clustered when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""clustered"">A value indicating whether the index is clustered.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionIndexBuilder? IsClustered(
        this IConventionIndexBuilder indexBuilder,
        bool? clustered,
        bool fromDataAnnotation = false)
    {
        if (indexBuilder.CanSetIsClustered(clustered, fromDataAnnotation))
        {
            indexBuilder.Metadata.SetIsClustered(clustered, fromDataAnnotation);
            return indexBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the index can be configured as clustered.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""clustered"">A value indicating whether the index is clustered.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the index can be configured as clustered.</returns>
    public static bool CanSetIsClustered(
        this IConventionIndexBuilder indexBuilder,
        bool? clustered,
        bool fromDataAnnotation = false)
        => indexBuilder.CanSetAnnotation(SqlServerAnnotationNames.Clustered, clustered, fromDataAnnotation);

    /// <summary>
    ///     Configures index include properties when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""propertyNames"">An array of property names to be used in 'include' clause.</param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder IncludeProperties(this IndexBuilder indexBuilder, params string[] propertyNames)
    {
        Check.NotNull(propertyNames, nameof(propertyNames));

        indexBuilder.Metadata.SetIncludeProperties(propertyNames);

        return indexBuilder;
    }

    /// <summary>
    ///     Configures index include properties when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""propertyNames"">An array of property names to be used in 'include' clause.</param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder<TEntity> IncludeProperties<TEntity>(
        this IndexBuilder<TEntity> indexBuilder,
        params string[] propertyNames)
    {
        Check.NotNull(propertyNames, nameof(propertyNames));

        indexBuilder.Metadata.SetIncludeProperties(propertyNames);

        return indexBuilder;
    }

    /// <summary>
    ///     Configures index include properties when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""includeExpression"">
    ///     <para>
    ///         A lambda expression representing the property(s) to be included in the 'include' clause
    ///         (<c>blog => blog.Url</c>).
    ///     </para>
    ///     <para>
    ///         If multiple properties are to be included then specify an anonymous type including the
    ///         properties (<c>post => new { post.Title, post.BlogId }</c>).
    ///     </para>
    /// </param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder<TEntity> IncludeProperties<TEntity>(
        this IndexBuilder<TEntity> indexBuilder,
        Expression<Func<TEntity, object?>> includeExpression)
    {
        Check.NotNull(includeExpression, nameof(includeExpression));

        IncludeProperties(
            indexBuilder,
            includeExpression.GetMemberAccessList().Select(EntityFrameworkMemberInfoExtensions.GetSimpleMemberName).ToArray());

        return indexBuilder;
    }

    /// <summary>
    ///     Configures index include properties when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""propertyNames"">An array of property names to be used in 'include' clause.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionIndexBuilder? IncludeProperties(
        this IConventionIndexBuilder indexBuilder,
        IReadOnlyList<string>? propertyNames,
        bool fromDataAnnotation = false)
    {
        if (indexBuilder.CanSetIncludeProperties(propertyNames, fromDataAnnotation))
        {
            indexBuilder.Metadata.SetIncludeProperties(propertyNames, fromDataAnnotation);

            return indexBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the given include properties can be set.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""propertyNames"">An array of property names to be used in 'include' clause.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the given include properties can be set.</returns>
    public static bool CanSetIncludeProperties(
        this IConventionIndexBuilder indexBuilder,
        IReadOnlyList<string>? propertyNames,
        bool fromDataAnnotation = false)
        => (fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention)
            .Overrides(indexBuilder.Metadata.GetIncludePropertiesConfigurationSource())
            || indexBuilder.Metadata.GetIncludeProperties() is var currentProperties
            && ((propertyNames is null && currentProperties is null)
                || (propertyNames is not null && currentProperties is not null && propertyNames.SequenceEqual(currentProperties)));

    /// <summary>
    ///     Configures whether the index is created with online option when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""createdOnline"">A value indicating whether the index is created with online option.</param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder IsCreatedOnline(this IndexBuilder indexBuilder, bool createdOnline = true)
    {
        indexBuilder.Metadata.SetIsCreatedOnline(createdOnline);

        return indexBuilder;
    }

    /// <summary>
    ///     Configures whether the index is created with online option when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""createdOnline"">A value indicating whether the index is created with online option.</param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder<TEntity> IsCreatedOnline<TEntity>(
        this IndexBuilder<TEntity> indexBuilder,
        bool createdOnline = true)
        => (IndexBuilder<TEntity>)IsCreatedOnline((IndexBuilder)indexBuilder, createdOnline);

    /// <summary>
    ///     Configures whether the index is created with online option when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""createdOnline"">A value indicating whether the index is created with online option.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionIndexBuilder? IsCreatedOnline(
        this IConventionIndexBuilder indexBuilder,
        bool? createdOnline,
        bool fromDataAnnotation = false)
    {
        if (indexBuilder.CanSetIsCreatedOnline(createdOnline, fromDataAnnotation))
        {
            indexBuilder.Metadata.SetIsCreatedOnline(createdOnline, fromDataAnnotation);

            return indexBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the index can be configured with online option when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""createdOnline"">A value indicating whether the index is created with online option.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    /// <returns><see langword=""true"" /> if the index can be configured with online option when targeting SQL Server.</returns>
    public static bool CanSetIsCreatedOnline(
        this IConventionIndexBuilder indexBuilder,
        bool? createdOnline,
        bool fromDataAnnotation = false)
        => indexBuilder.CanSetAnnotation(SqlServerAnnotationNames.CreatedOnline, createdOnline, fromDataAnnotation);

    /// <summary>
    ///     Configures whether the index is created with fill factor option when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""fillFactor"">A value indicating whether the index is created with fill factor option.</param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder HasFillFactor(this IndexBuilder indexBuilder, int fillFactor)
    {
        indexBuilder.Metadata.SetFillFactor(fillFactor);

        return indexBuilder;
    }

    /// <summary>
    ///     Configures whether the index is created with fill factor option when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""fillFactor"">A value indicating whether the index is created with fill factor option.</param>
    /// <returns>A builder to further configure the index.</returns>
    public static IndexBuilder<TEntity> HasFillFactor<TEntity>(
        this IndexBuilder<TEntity> indexBuilder,
        int fillFactor)
        => (IndexBuilder<TEntity>)HasFillFactor((IndexBuilder)indexBuilder, fillFactor);

    /// <summary>
    ///     Configures whether the index is created with fill factor option when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""fillFactor"">A value indicating whether the index is created with fill factor option.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns>
    ///     The same builder instance if the configuration was applied,
    ///     <see langword=""null"" /> otherwise.
    /// </returns>
    public static IConventionIndexBuilder? HasFillFactor(
        this IConventionIndexBuilder indexBuilder,
        int? fillFactor,
        bool fromDataAnnotation = false)
    {
        if (indexBuilder.CanSetFillFactor(fillFactor, fromDataAnnotation))
        {
            indexBuilder.Metadata.SetFillFactor(fillFactor, fromDataAnnotation);

            return indexBuilder;
        }

        return null;
    }

    /// <summary>
    ///     Returns a value indicating whether the index can be configured with fill factor option when targeting SQL Server.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-modeling"">Modeling entity types and relationships</see>, and
    ///     <see href=""https://aka.ms/efcore-docs-sqlserver"">Accessing SQL Server and SQL Azure databases with EF Core</see>
    ///     for more information and examples.
    /// </remarks>
    /// <param name=""indexBuilder"">The builder for the index being configured.</param>
    /// <param name=""fillFactor"">A value indicating whether the index is created with fill factor option.</param>
    /// <param name=""fromDataAnnotation"">Indicates whether the configuration was specified using a data annotation.</param>
    /// <returns><see langword=""true"" /> if the index can be configured with fill factor option when targeting SQL Server.</returns>
    public static bool CanSetFillFactor(
        this IConventionIndexBuilder indexBuilder,
        int? fillFactor,
        bool fromDataAnnotation = false)
        => indexBuilder.CanSetAnnotation(SqlServerAnnotationNames.FillFactor, fillFactor, fromDataAnnotation);
}",0,439 457 334 2000 123 612 439 457 2001 2002 40 467 2001 2003 44 323 2004 61 473 41 123 2003 46 2005 46 2006 40 2004 41 59 450 2003 59 125 612 439 457 2001 60 2007 62 2002 60 2007 62 40 467 2001 60 2007 62 2003 44 323 2004 61 473 41 619 40 2001 60 2007 62 41 2002 40 40 2001 41 2003 44 2004 41 59 612 439 457 2008 63 2002 40 467 2008 2003 44 323 63 2004 44 323 2009 61 380 41 123 392 40 2003 46 2010 40 2004 44 2009 41 41 123 2003 46 2011 46 2012 40 2004 44 2009 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2013 40 467 2008 2003 44 323 63 2004 44 323 2009 61 380 41 619 2003 46 2014 40 2015 46 2016 44 2004 44 2009 41 59 612 439 457 2001 2017 40 467 2001 2003 44 433 461 91 93 2018 41 123 2019 46 2020 40 2018 44 2021 40 2018 41 41 59 2003 46 2022 46 2023 40 2018 41 59 450 2003 59 125 612 439 457 2001 60 2007 62 2017 60 2007 62 40 467 2001 60 2007 62 2003 44 433 461 91 93 2018 41 123 2024 46 2025 40 2018 44 2026 40 2018 41 41 59 2003 46 2027 46 2028 40 2018 41 59 450 2003 59 125 612 439 457 2001 60 2007 62 2017 60 2007 62 40 467 2001 60 2007 62 2003 44 2029 60 2030 60 2007 44 426 63 640 2031 41 123 2032 46 2033 40 2031 44 2034 40 2031 41 41 59 2017 40 2003 44 2031 46 2035 40 41 46 2036 40 2037 46 2038 41 46 2039 40 41 41 59 450 2003 59 125 612 439 457 2008 63 2017 40 467 2008 2003 44 2040 60 461 62 63 2018 44 323 2009 61 380 41 123 392 40 2003 46 2041 40 2018 44 2009 41 41 123 2003 46 2042 46 2043 40 2018 44 2009 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2044 40 467 2008 2003 44 2040 60 461 62 63 2018 44 323 2009 61 380 41 619 40 2009 63 2045 46 2046 58 2045 46 2047 41 46 2048 40 2003 46 2049 46 2050 40 41 41 606 2003 46 2049 46 2051 40 41 407 490 2052 605 40 40 2018 407 424 605 2052 407 424 41 606 40 2018 407 422 424 605 2052 407 422 424 605 2018 46 2053 40 2052 41 41 41 59 612 439 457 2001 2054 40 467 2001 2003 44 323 2055 61 473 41 123 2003 46 2049 46 2056 40 2055 41 59 450 2003 59 125 612 439 457 2001 60 2007 62 2054 60 2007 62 40 467 2001 60 2007 62 2003 44 323 2055 61 473 41 619 40 2001 60 2007 62 41 2054 40 40 2001 41 2003 44 2055 41 59 612 439 457 2008 63 2054 40 467 2008 2003 44 323 63 2055 44 323 2009 61 380 41 123 392 40 2003 46 2057 40 2055 44 2009 41 41 123 2003 46 2049 46 2058 40 2055 44 2009 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2059 40 467 2008 2003 44 323 63 2055 44 323 2009 61 380 41 619 2003 46 2014 40 2015 46 2060 44 2055 44 2009 41 59 612 439 457 2001 2061 40 467 2001 2003 44 404 2062 41 123 2003 46 2049 46 2063 40 2062 41 59 450 2003 59 125 612 439 457 2001 60 2007 62 2061 60 2007 62 40 467 2001 60 2007 62 2003 44 404 2062 41 619 40 2001 60 2007 62 41 2061 40 40 2001 41 2003 44 2062 41 59 612 439 457 2008 63 2061 40 467 2008 2003 44 404 63 2062 44 323 2009 61 380 41 123 392 40 2003 46 2064 40 2062 44 2009 41 41 123 2003 46 2049 46 2065 40 2062 44 2009 41 59 450 2003 59 125 450 424 59 125 612 439 457 323 2066 40 467 2008 2003 44 404 63 2062 44 323 2009 61 380 41 619 2003 46 2014 40 2015 46 2067 44 2062 44 2009 41 59 125 
68074,C#,"public abstract class ReaderModificationCommandBatch : ModificationCommandBatch
{
    private readonly List<IReadOnlyModificationCommand> _modificationCommands = new();

    /// <summary>
    ///     Creates a new <see cref=""ReaderModificationCommandBatch"" /> instance.
    /// </summary>
    /// <param name=""dependencies"">Service dependencies.</param>
    protected ReaderModificationCommandBatch(ModificationCommandBatchFactoryDependencies dependencies)
    {
        Dependencies = dependencies;
        CachedCommandText = new StringBuilder();
    }

    /// <summary>
    ///     Relational provider-specific dependencies for this service.
    /// </summary>
    protected virtual ModificationCommandBatchFactoryDependencies Dependencies { get; }

    /// <summary>
    ///     The update SQL generator.
    /// </summary>
    protected virtual IUpdateSqlGenerator UpdateSqlGenerator
        => Dependencies.UpdateSqlGenerator;

    /// <summary>
    ///     Gets or sets the cached command text for the commands in the batch.
    /// </summary>
    protected virtual StringBuilder CachedCommandText { get; set; }

    /// <summary>
    ///     The ordinal of the last command for which command text was built.
    /// </summary>
    protected virtual int LastCachedCommandIndex { get; set; }

    /// <summary>
    ///     The list of conceptual insert/update/delete <see cref=""ModificationCommands"" />s in the batch.
    /// </summary>
    public override IReadOnlyList<IReadOnlyModificationCommand> ModificationCommands
        => _modificationCommands;

    /// <summary>
    ///     The <see cref=""ResultSetMapping"" />s for each command in <see cref=""ModificationCommands"" />.
    /// </summary>
    protected virtual IList<ResultSetMapping> CommandResultSet { get; } = new List<ResultSetMapping>();

    /// <summary>
    ///     Adds the given insert/update/delete <see cref=""ModificationCommands"" /> to the batch.
    /// </summary>
    /// <param name=""modificationCommand"">The command to add.</param>
    /// <returns>
    ///     <see langword=""true"" /> if the command was successfully added; <see langword=""false"" /> if there was no
    ///     room in the current batch to add the command and it must instead be added to a new batch.
    /// </returns>
    public override bool AddCommand(IReadOnlyModificationCommand modificationCommand)
    {
        if (ModificationCommands.Count == 0)
        {
            ResetCommandText();
        }

        if (!CanAddCommand(modificationCommand))
        {
            return false;
        }

        _modificationCommands.Add(modificationCommand);
        CommandResultSet.Add(ResultSetMapping.LastInResultSet);

        if (!IsCommandTextValid())
        {
            ResetCommandText();
            _modificationCommands.RemoveAt(_modificationCommands.Count - 1);
            CommandResultSet.RemoveAt(CommandResultSet.Count - 1);
            return false;
        }

        return true;
    }

    /// <summary>
    ///     Resets the builder to start building a new batch.
    /// </summary>
    protected virtual void ResetCommandText()
    {
        if (CachedCommandText.Length > 0)
        {
            CachedCommandText = new StringBuilder();
        }

        UpdateSqlGenerator.AppendBatchHeader(CachedCommandText);
        LastCachedCommandIndex = -1;
    }

    /// <summary>
    ///     Checks whether a new command can be added to the batch.
    /// </summary>
    /// <param name=""modificationCommand"">The command to potentially add.</param>
    /// <returns><see langword=""true"" /> if the command can be added; <see langword=""false"" /> otherwise.</returns>
    protected abstract bool CanAddCommand(IReadOnlyModificationCommand modificationCommand);

    /// <summary>
    ///     Checks whether the command text is valid.
    /// </summary>
    /// <returns><see langword=""true"" /> if the command text is valid; <see langword=""false"" /> otherwise.</returns>
    protected abstract bool IsCommandTextValid();

    /// <summary>
    ///     Gets the command text for all the commands in the current batch and also caches it
    ///     on <see cref=""CachedCommandText"" />.
    /// </summary>
    /// <returns>The command text.</returns>
    protected virtual string GetCommandText()
    {
        for (var i = LastCachedCommandIndex + 1; i < ModificationCommands.Count; i++)
        {
            UpdateCachedCommandText(i);
        }

        return CachedCommandText.ToString();
    }

    /// <summary>
    ///     Updates the command text for the command at the given position in the
    ///     <see cref=""ModificationCommands"" /> list.
    /// </summary>
    /// <param name=""commandPosition"">The position of the command to generate command text for.</param>
    protected virtual void UpdateCachedCommandText(int commandPosition)
    {
        var newModificationCommand = ModificationCommands[commandPosition];

        switch (newModificationCommand.EntityState)
        {
            case EntityState.Added:
                CommandResultSet[commandPosition] =
                    UpdateSqlGenerator.AppendInsertOperation(CachedCommandText, newModificationCommand, commandPosition);
                break;
            case EntityState.Modified:
                CommandResultSet[commandPosition] =
                    UpdateSqlGenerator.AppendUpdateOperation(CachedCommandText, newModificationCommand, commandPosition);
                break;
            case EntityState.Deleted:
                CommandResultSet[commandPosition] =
                    UpdateSqlGenerator.AppendDeleteOperation(CachedCommandText, newModificationCommand, commandPosition);
                break;
        }

        LastCachedCommandIndex = commandPosition;
    }

    /// <summary>
    ///     Gets the total number of parameters needed for the batch.
    /// </summary>
    /// <returns>The total parameter count.</returns>
    protected virtual int GetParameterCount()
        => ModificationCommands.Sum(c => c.ColumnModifications.Count);

    /// <summary>
    ///     Generates a <see cref=""RawSqlCommand"" /> for the batch.
    /// </summary>
    /// <returns>The command.</returns>
    protected virtual RawSqlCommand CreateStoreCommand()
    {
        var commandBuilder = Dependencies.CommandBuilderFactory
            .Create()
            .Append(GetCommandText());

        var parameterValues = new Dictionary<string, object?>(GetParameterCount());

        // ReSharper disable once ForCanBeConvertedToForeach
        for (var commandIndex = 0; commandIndex < ModificationCommands.Count; commandIndex++)
        {
            var command = ModificationCommands[commandIndex];
            // ReSharper disable once ForCanBeConvertedToForeach
            for (var columnIndex = 0; columnIndex < command.ColumnModifications.Count; columnIndex++)
            {
                var columnModification = command.ColumnModifications[columnIndex];
                if (columnModification.UseCurrentValueParameter)
                {
                    commandBuilder.AddParameter(
                        columnModification.ParameterName,
                        Dependencies.SqlGenerationHelper.GenerateParameterName(columnModification.ParameterName),
                        columnModification.TypeMapping!,
                        columnModification.IsNullable);

                    parameterValues.Add(columnModification.ParameterName, columnModification.Value);
                }

                if (columnModification.UseOriginalValueParameter)
                {
                    commandBuilder.AddParameter(
                        columnModification.OriginalParameterName,
                        Dependencies.SqlGenerationHelper.GenerateParameterName(columnModification.OriginalParameterName),
                        columnModification.TypeMapping!,
                        columnModification.IsNullable);

                    parameterValues.Add(columnModification.OriginalParameterName, columnModification.OriginalValue);
                }
            }
        }

        return new RawSqlCommand(commandBuilder.Build(), parameterValues);
    }

    /// <summary>
    ///     Executes the command generated by <see cref=""CreateStoreCommand"" /> against a
    ///     database using the given connection.
    /// </summary>
    /// <param name=""connection"">The connection to the database to update.</param>
    public override void Execute(IRelationalConnection connection)
    {
        var storeCommand = CreateStoreCommand();

        try
        {
            using var dataReader = storeCommand.RelationalCommand.ExecuteReader(
                new RelationalCommandParameterObject(
                    connection,
                    storeCommand.ParameterValues,
                    null,
                    Dependencies.CurrentContext.Context,
                    Dependencies.Logger, CommandSource.SaveChanges));
            Consume(dataReader);
        }
        catch (Exception ex) when (ex is not DbUpdateException and not OperationCanceledException)
        {
            throw new DbUpdateException(
                RelationalStrings.UpdateStoreException,
                ex,
                ModificationCommands.SelectMany(c => c.Entries).ToList());
        }
    }

    /// <summary>
    ///     Executes the command generated by <see cref=""CreateStoreCommand"" /> against a
    ///     database using the given connection.
    /// </summary>
    /// <param name=""connection"">The connection to the database to update.</param>
    /// <param name=""cancellationToken"">A <see cref=""CancellationToken"" /> to observe while waiting for the task to complete.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    /// <exception cref=""OperationCanceledException"">If the <see cref=""CancellationToken"" /> is canceled.</exception>
    public override async Task ExecuteAsync(
        IRelationalConnection connection,
        CancellationToken cancellationToken = default)
    {
        var storeCommand = CreateStoreCommand();

        try
        {
            var dataReader = await storeCommand.RelationalCommand.ExecuteReaderAsync(
                new RelationalCommandParameterObject(
                    connection,
                    storeCommand.ParameterValues,
                    null,
                    Dependencies.CurrentContext.Context,
                    Dependencies.Logger, CommandSource.SaveChanges),
                cancellationToken).ConfigureAwait(false);

            await using var _ = dataReader.ConfigureAwait(false);
            await ConsumeAsync(dataReader, cancellationToken).ConfigureAwait(false);
        }
        catch (Exception ex) when (ex is not DbUpdateException and not OperationCanceledException)
        {
            throw new DbUpdateException(
                RelationalStrings.UpdateStoreException,
                ex,
                ModificationCommands.SelectMany(c => c.Entries).ToList());
        }
    }

    /// <summary>
    ///     Consumes the data reader created by <see cref=""Execute"" />.
    /// </summary>
    /// <param name=""reader"">The data reader.</param>
    protected abstract void Consume(RelationalDataReader reader);

    /// <summary>
    ///     Consumes the data reader created by <see cref=""ExecuteAsync"" />.
    /// </summary>
    /// <param name=""reader"">The data reader.</param>
    /// <param name=""cancellationToken"">A <see cref=""CancellationToken"" /> to observe while waiting for the task to complete.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    /// <exception cref=""OperationCanceledException"">If the <see cref=""CancellationToken"" /> is canceled.</exception>
    protected abstract Task ConsumeAsync(
        RelationalDataReader reader,
        CancellationToken cancellationToken = default);

    /// <summary>
    ///     Creates the <see cref=""IRelationalValueBufferFactory"" /> that will be used for creating a
    ///     <see cref=""ValueBuffer"" /> to consume the data reader.
    /// </summary>
    /// <param name=""columnModifications"">
    ///     The list of <see cref=""IColumnModification"" />s for all the columns
    ///     being modified such that a ValueBuffer with appropriate slots can be created.
    /// </param>
    /// <returns>The factory.</returns>
    protected virtual IRelationalValueBufferFactory CreateValueBufferFactory(
        IReadOnlyList<IColumnModification> columnModifications)
        => Dependencies.ValueBufferFactoryFactory
            .Create(
                columnModifications
                    .Where(c => c.IsRead)
                    .Select(c => new TypeMaterializationInfo(c.Property!.ClrType, c.Property, c.TypeMapping!))
                    .ToArray());
}",0,439 305 334 2000 58 2001 123 437 441 2002 60 2003 62 2004 61 418 40 41 59 612 438 2000 40 2005 2006 41 123 2007 61 2006 59 2008 61 418 2009 40 41 59 125 612 438 491 2005 2010 123 2011 59 125 612 438 491 2012 2013 619 2010 46 2013 59 612 438 491 2014 2015 123 2016 59 2017 59 125 612 438 491 404 2018 123 2019 59 2020 59 125 612 439 431 2021 60 2003 62 2022 619 2004 59 612 438 491 2023 60 2024 62 2025 123 2026 59 125 61 418 2002 60 2024 62 40 41 59 612 439 431 323 2027 40 2003 2028 41 123 392 40 2022 46 2029 614 1500 41 123 2030 40 41 59 125 392 40 33 2031 40 2028 41 41 123 450 380 59 125 2004 46 2032 40 2028 41 59 2025 46 2032 40 2024 46 2033 41 59 392 40 33 2034 40 41 41 123 2035 40 41 59 2004 46 2036 40 2004 46 2029 45 1501 41 59 2025 46 2036 40 2025 46 2029 45 1501 41 59 450 380 59 125 450 473 59 125 612 438 491 492 2037 40 41 123 392 40 2015 46 2038 62 1500 41 123 2015 61 418 2014 40 41 59 125 2013 46 2039 40 2015 41 59 2018 61 45 1501 59 125 612 438 305 323 2040 40 2003 2028 41 59 612 438 305 323 2041 40 41 59 612 438 491 461 2042 40 41 123 385 40 490 2043 61 2018 43 1501 59 2043 60 2022 46 2044 59 2043 637 41 123 2045 40 2043 41 59 125 450 2015 46 2046 40 41 59 125 612 438 491 492 2047 40 404 2048 41 123 490 2049 61 2022 91 2048 93 59 464 40 2049 46 2050 41 123 328 2050 46 2051 58 2025 91 2048 93 61 2013 46 2052 40 2015 44 2049 44 2048 41 59 325 59 328 2050 46 2053 58 2025 91 2048 93 61 2013 46 2054 40 2015 44 2049 44 2048 41 59 325 59 328 2050 46 2055 58 2025 91 2048 93 61 2013 46 2056 40 2015 44 2049 44 2048 41 59 325 59 125 2018 61 2048 59 125 612 438 491 404 2057 40 41 619 2022 46 2058 40 2059 619 2059 46 2060 46 2061 41 59 612 438 491 2062 2063 40 41 123 490 2064 61 2010 46 2065 46 2066 40 41 46 2067 40 2042 40 41 41 59 490 2068 61 418 2069 60 461 44 426 63 62 40 2057 40 41 41 59 621 385 40 490 2070 61 1500 59 2070 60 2022 46 2061 59 2070 637 41 123 490 2071 61 2022 91 2070 93 59 621 385 40 490 2072 61 1500 59 2072 60 2071 46 2060 46 2061 59 2072 637 41 123 490 2073 61 2071 46 2060 91 2072 93 59 392 40 2073 46 2074 41 123 2064 46 2075 40 2073 46 2076 44 2010 46 2077 46 2078 40 2073 46 2076 41 44 2073 46 2079 33 44 2073 46 2080 41 59 2068 46 2081 40 2073 46 2076 44 2073 46 2082 41 59 125 392 40 2073 46 2083 41 123 2064 46 2084 40 2073 46 2085 44 2010 46 2086 46 2087 40 2073 46 2085 41 44 2073 46 2088 33 44 2073 46 2089 41 59 2068 46 2090 40 2073 46 2085 44 2073 46 2091 41 59 125 125 125 450 418 2062 40 2064 46 2092 40 41 44 2068 41 59 125 612 439 431 492 2093 40 2094 2095 41 123 490 2096 61 2063 40 41 59 474 123 489 490 2097 61 2096 46 2098 46 2099 40 418 2100 40 2095 44 2096 46 2101 44 424 44 2010 46 2102 46 2103 44 2010 46 2104 44 2105 46 2106 41 41 59 2107 40 2097 41 59 125 329 40 2108 2109 41 2110 40 2109 407 422 2111 308 422 2112 41 123 469 418 2111 40 2113 46 2114 44 2109 44 2022 46 2115 40 2059 619 2059 46 2116 41 46 2117 40 41 41 59 125 125 612 439 431 314 2118 2119 40 2094 2095 44 2120 2121 61 349 41 123 490 2122 61 2063 40 41 59 474 123 490 2123 61 319 2122 46 2124 46 2125 40 418 2126 40 2095 44 2122 46 2127 44 424 44 2010 46 2128 46 2129 44 2010 46 2130 44 2131 46 2132 41 44 2121 41 46 2133 40 380 41 59 319 489 490 2134 61 2123 46 2133 40 380 41 59 319 2135 40 2123 44 2121 41 46 2133 40 380 41 59 125 329 40 2136 2137 41 2138 40 2137 407 422 2139 308 422 2140 41 123 469 418 2139 40 2141 46 2142 44 2137 44 2022 46 2143 40 2059 619 2059 46 2144 41 46 2145 40 41 41 59 125 125 612 438 305 492 2146 40 2147 2148 41 59 612 438 305 2118 2149 40 2147 2148 44 2120 2121 61 349 41 59 612 438 491 2150 2151 40 2021 60 2152 62 2153 41 619 2010 46 2154 46 2155 40 2153 46 2156 40 2059 619 2059 46 2157 41 46 2158 40 2059 619 418 2159 40 2059 46 2160 33 46 2161 44 2059 46 2160 44 2059 46 2162 33 41 41 46 2163 40 41 41 59 125 
69526,C#,"public class RawSqlCommandBuilder : IRawSqlCommandBuilder
{
    private readonly IRelationalCommandBuilderFactory _relationalCommandBuilderFactory;
    private readonly ISqlGenerationHelper _sqlGenerationHelper;
    private readonly IParameterNameGeneratorFactory _parameterNameGeneratorFactory;
    private readonly IRelationalTypeMappingSource _typeMappingSource;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public RawSqlCommandBuilder(
        IRelationalCommandBuilderFactory relationalCommandBuilderFactory,
        ISqlGenerationHelper sqlGenerationHelper,
        IParameterNameGeneratorFactory parameterNameGeneratorFactory,
            IRelationalTypeMappingSource typeMappingSource)
    {
        _relationalCommandBuilderFactory = relationalCommandBuilderFactory;
        _sqlGenerationHelper = sqlGenerationHelper;
        _parameterNameGeneratorFactory = parameterNameGeneratorFactory;
        _typeMappingSource = typeMappingSource;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual IRelationalCommand Build(string sql)
        => _relationalCommandBuilderFactory
            .Create()
            .Append(sql)
            .Build();

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual RawSqlCommand Build(string sql, IEnumerable<object> parameters)
    {
        var relationalCommandBuilder = _relationalCommandBuilderFactory.Create();

        var substitutions = new List<string>();

        var parameterNameGenerator = _parameterNameGeneratorFactory.Create();

        var parameterValues = new Dictionary<string, object?>();

        foreach (var parameter in parameters)
        {
            if (parameter is DbParameter dbParameter)
            {
                if (string.IsNullOrEmpty(dbParameter.ParameterName))
                {
                    dbParameter.ParameterName = _sqlGenerationHelper.GenerateParameterName(parameterNameGenerator.GenerateNext());
                }

                substitutions.Add(_sqlGenerationHelper.GenerateParameterName(dbParameter.ParameterName));
                relationalCommandBuilder.AddRawParameter(dbParameter.ParameterName, dbParameter);
            }
            else
            {
                var parameterName = parameterNameGenerator.GenerateNext();
                var substitutedName = _sqlGenerationHelper.GenerateParameterName(parameterName);

                substitutions.Add(substitutedName);
                var typeMapping = parameter == null
                        ? _typeMappingSource.GetMappingForValue(null)
                        : _typeMappingSource.GetMapping(parameter.GetType());
                var nullable = parameter == null || parameter.GetType().IsNullableType();

                relationalCommandBuilder.AddParameter(parameterName, substitutedName, typeMapping, nullable);
                parameterValues.Add(parameterName, parameter);
            }
        }

        // ReSharper disable once CoVariantArrayConversion
        sql = string.Format(sql, substitutions.ToArray());

        return new RawSqlCommand(
            relationalCommandBuilder.Append(sql).Build(),
            parameterValues);
    }
}",0,439 334 2000 58 2001 123 437 441 2002 2003 59 437 441 2004 2005 59 437 441 2006 2007 59 437 441 2008 2009 59 612 439 2000 40 2002 2010 44 2004 2011 44 2006 2012 44 2008 2013 41 123 2003 61 2010 59 2005 61 2011 59 2007 61 2012 59 2009 61 2013 59 125 612 439 491 2014 2015 40 461 2016 41 619 2003 46 2017 40 41 46 2018 40 2016 41 46 2015 40 41 59 612 439 491 2019 2015 40 461 2016 44 2020 60 426 62 2021 41 123 490 2022 61 2003 46 2017 40 41 59 490 2023 61 418 2024 60 461 62 40 41 59 490 2025 61 2007 46 2017 40 41 59 490 2026 61 418 2027 60 461 44 426 63 62 40 41 59 386 40 490 2028 398 2021 41 123 392 40 2028 407 2029 2030 41 123 392 40 461 46 2031 40 2030 46 2032 41 41 123 2030 46 2032 61 2005 46 2033 40 2025 46 2034 40 41 41 59 125 2023 46 2035 40 2005 46 2036 40 2030 46 2032 41 41 59 2022 46 2037 40 2030 46 2032 44 2030 41 59 125 360 123 490 2038 61 2025 46 2039 40 41 59 490 2040 61 2005 46 2041 40 2038 41 59 2023 46 2042 40 2040 41 59 490 2043 61 2028 614 424 63 2009 46 2044 40 424 41 58 2009 46 2045 40 2028 46 2046 40 41 41 59 490 2047 61 2028 614 424 606 2028 46 2046 40 41 46 2048 40 41 59 2022 46 2049 40 2038 44 2040 44 2043 44 2047 41 59 2026 46 2042 40 2038 44 2028 41 59 125 125 621 2016 61 461 46 2050 40 2016 44 2023 46 2051 40 41 41 59 450 418 2019 40 2022 46 2018 40 2016 41 46 2015 40 41 44 2026 41 59 125 125 
69924,C#,"public class TableMapping : TableMappingBase, ITableMapping
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public TableMapping(
        IEntityType entityType,
        Table table,
        bool includesDerivedTypes)
        : base(entityType, table, includesDerivedTypes)
    {
    }

    /// <inheritdoc />
    public new virtual ITable Table
        => (ITable)base.Table;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override string ToString()
        => ((ITableMapping)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);

    /// <inheritdoc />
    ITableBase ITableMappingBase.Table
    {
        [DebuggerStepThrough]
        get => Table;
    }

    /// <inheritdoc />
    IEnumerable<IColumnMapping> ITableMapping.ColumnMappings
    {
        [DebuggerStepThrough]
        get => ColumnMappings.Cast<IColumnMapping>();
    }
}",0,439 334 2000 58 2001 44 2002 123 612 439 2000 40 2003 2004 44 2005 2006 44 323 2007 41 58 320 40 2004 44 2006 44 2007 41 123 125 612 439 418 491 2008 2005 619 40 2008 41 320 46 2005 59 612 439 431 461 2009 40 41 619 40 40 2002 41 467 41 46 2010 40 2011 46 2012 41 59 612 2013 2014 46 2005 123 91 2015 93 2016 619 2005 59 125 612 2017 60 2018 62 2002 46 2019 123 91 2020 93 2021 619 2019 46 2022 60 2018 62 40 41 59 125 125 
70993,C#,"    public class CustomPropertyDataAnnotationAttribute : Attribute
    {
        public CustomPropertyDataAnnotationAttribute(string argument)
        {
            Argument = argument;
        }

        public virtual string Argument { get; }
    }",0,439 334 2000 58 2001 123 439 2000 40 461 2002 41 123 2003 61 2002 59 125 439 491 461 2004 123 2005 59 125 125 
72146,C#,"    private sealed class PropertyInfoEqualityComparer : IEqualityComparer<PropertyInfo>
    {
        private PropertyInfoEqualityComparer()
        {
        }

        public static readonly PropertyInfoEqualityComparer Instance = new();

        public bool Equals(PropertyInfo? x, PropertyInfo? y)
            => x.IsSameAs(y);

        public int GetHashCode([DisallowNull] PropertyInfo obj)
            => throw new NotSupportedException();
    }",0,437 452 334 2000 58 2001 60 2002 62 123 437 2000 40 41 123 125 439 457 441 2000 2003 61 418 40 41 59 439 323 2004 40 2002 63 2005 44 2002 63 2006 41 619 2005 46 2007 40 2006 41 59 439 404 2008 40 91 2009 93 2002 2010 41 619 469 418 2011 40 41 59 125 
72147,C#,"    private sealed class SharedIdentityMap
    {
        private readonly IUpdateAdapter _updateAdapter;

        private readonly Dictionary<IUpdateEntry, EntryMapping> _entryValueMap
            = new();

        public SharedIdentityMap(IUpdateAdapter updateAdapter)
        {
            _updateAdapter = updateAdapter;
        }

        /// <summary>
        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
        ///     any release. You should only use it directly in your code with extreme caution and knowing that
        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
        /// </summary>
        public IEnumerable<EntryMapping> Values
            => _entryValueMap.Values;

        /// <summary>
        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
        ///     any release. You should only use it directly in your code with extreme caution and knowing that
        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
        /// </summary>
        public EntryMapping GetOrAddValue(IUpdateEntry entry, ITable table)
        {
            var mainEntry = GetMainEntry(entry, table);
            if (_entryValueMap.TryGetValue(mainEntry, out var entryMapping))
            {
                return entryMapping;
            }

            entryMapping = new EntryMapping();
            _entryValueMap.Add(mainEntry, entryMapping);

            return entryMapping;
        }

        private IUpdateEntry GetMainEntry(IUpdateEntry entry, ITable table)
        {
            var entityType = entry.EntityType;
            var foreignKeys = table.GetRowInternalForeignKeys(entityType);
            foreach (var foreignKey in foreignKeys)
            {
                var principalEntry = _updateAdapter.FindPrincipal(entry, foreignKey);
                if (principalEntry != null)
                {
                    return GetMainEntry(principalEntry, table);
                }
            }

            var mainTable = entry.EntityType.GetTableMappings().First(m => m.IsSplitEntityTypePrincipal).Table;

            return mainTable != table
                ? GetMainEntry(entry, mainTable)
                : entry;
        }
    }",0,437 452 334 2000 123 437 441 2001 2002 59 437 441 2003 60 2004 44 2005 62 2006 61 418 40 41 59 439 2000 40 2001 2007 41 123 2002 61 2007 59 125 612 439 2008 60 2005 62 2009 619 2006 46 2009 59 612 439 2005 2010 40 2004 2011 44 2012 2013 41 123 490 2014 61 2015 40 2011 44 2013 41 59 392 40 2006 46 2016 40 2014 44 430 490 2017 41 41 123 450 2017 59 125 2017 61 418 2005 40 41 59 2006 46 2018 40 2014 44 2017 41 59 450 2017 59 125 437 2004 2019 40 2004 2011 44 2012 2013 41 123 490 2020 61 2011 46 2021 59 490 2022 61 2013 46 2023 40 2020 41 59 386 40 490 2024 398 2022 41 123 490 2025 61 2002 46 2026 40 2011 44 2024 41 59 392 40 2025 631 424 41 123 450 2019 40 2025 44 2013 41 59 125 125 490 2027 61 2011 46 2021 46 2028 40 41 46 2029 40 2030 619 2030 46 2031 41 46 2032 59 450 2027 631 2013 63 2019 40 2011 44 2027 41 58 2011 59 125 125 
72628,C#,"        private sealed class AggregateContext<T>
        {
            public AggregateContext(T seed)
                => Accumulate = seed;

            public T Accumulate { get; set; }
            public Exception? Exception { get; set; }
        }",0,437 452 334 2000 60 2001 62 123 439 2000 40 2001 2002 41 619 2003 61 2002 59 439 2001 2003 123 2004 59 2005 59 125 439 2006 63 2006 123 2007 59 2008 59 125 125 
69520,C#,"    public class SqliteBlob : Stream
    {
        private sqlite3_blob? _blob;
        private readonly SqliteConnection _connection;
        private long _position;

        /// <summary>
        ///     Initializes a new instance of the <see cref=""SqliteBlob"" /> class.
        /// </summary>
        /// <param name=""connection"">An open connection to the database.</param>
        /// <param name=""tableName"">The name of table containing the blob.</param>
        /// <param name=""columnName"">The name of the column containing the blob.</param>
        /// <param name=""rowid"">The rowid of the row containing the blob.</param>
        /// <param name=""readOnly"">A value indicating whether the blob is read-only.</param>
        /// <seealso href=""https://docs.microsoft.com/dotnet/standard/data/sqlite/blob-io"">BLOB I/O</seealso>
        public SqliteBlob(
            SqliteConnection connection,
            string tableName,
            string columnName,
            long rowid,
            bool readOnly = false)
            : this(connection, SqliteConnection.MainDatabaseName, tableName, columnName, rowid, readOnly)
        {
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref=""SqliteBlob"" /> class.
        /// </summary>
        /// <param name=""connection"">An open connection to the database.</param>
        /// <param name=""databaseName"">The name of the attached database containing the blob.</param>
        /// <param name=""tableName"">The name of table containing the blob.</param>
        /// <param name=""columnName"">The name of the column containing the blob.</param>
        /// <param name=""rowid"">The rowid of the row containing the blob.</param>
        /// <param name=""readOnly"">A value indicating whether the blob is read-only.</param>
        /// <seealso href=""https://docs.microsoft.com/dotnet/standard/data/sqlite/blob-io"">BLOB I/O</seealso>
        public SqliteBlob(
            SqliteConnection connection,
            string databaseName,
            string tableName,
            string columnName,
            long rowid,
            bool readOnly = false)
        {
            if (connection?.State != ConnectionState.Open)
            {
                throw new InvalidOperationException(Resources.SqlBlobRequiresOpenConnection);
            }

            if (tableName is null)
            {
                throw new ArgumentNullException(nameof(tableName));
            }

            if (columnName is null)
            {
                throw new ArgumentNullException(nameof(columnName));
            }

            _connection = connection;
            CanWrite = !readOnly;
            var rc = sqlite3_blob_open(
                _connection.Handle,
                databaseName,
                tableName,
                columnName,
                rowid,
                readOnly ? 0 : 1,
                out _blob);
            SqliteException.ThrowExceptionForRC(rc, _connection.Handle);
            Length = sqlite3_blob_bytes(_blob);
        }

        /// <summary>
        ///     Gets a value indicating whether the current stream supports reading.
        ///     Always true.
        /// </summary>
        /// <value><see langword=""true"" /> if the stream supports reading; otherwise, <see langword=""false"" />. </value>
        public override bool CanRead
            => true;

        /// <summary>
        ///     Gets a value indicating whether the current stream supports writing.
        /// </summary>
        /// <value><see langword=""true"" /> if the stream supports writing; otherwise, <see langword=""false"" />. </value>
        public override bool CanWrite { get; }

        /// <summary>
        ///     Gets a value indicating whether the current stream supports seeking.
        ///     Always true.
        /// </summary>
        /// <value><see langword=""true"" /> if the stream supports seeking; otherwise, <see langword=""false"" />. </value>
        public override bool CanSeek
            => true;

        /// <summary>
        ///     Gets the length in bytes of the stream.
        /// </summary>
        /// <value>A long value representing the length of the stream in bytes.</value>
        public override long Length { get; }

        /// <summary>
        ///     Gets or sets the position within the current stream.
        /// </summary>
        /// <value>The current position within the stream.</value>
        public override long Position
        {
            get => _position;
            set
            {
                if (value < 0)
                {
                    // NB: Message is provided by the framework
                    throw new ArgumentOutOfRangeException(nameof(value), value, message: null);
                }

                _position = value;
            }
        }

        /// <summary>
        ///     Reads a sequence of bytes from the current stream and advances the position
        ///     within the stream by the number of bytes read.
        /// </summary>
        /// <param name=""buffer"">
        ///     An array of bytes. When this method returns, the buffer contains the specified byte array
        ///     with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.
        /// </param>
        /// <param name=""offset"">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
        /// <param name=""count"">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>The total number of bytes read into the buffer.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException(nameof(buffer));
            }

            if (offset < 0)
            {
                // NB: Message is provided by the framework
                throw new ArgumentOutOfRangeException(nameof(offset), offset, message: null);
            }

            if (count < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(count), count, message: null);
            }

            if (offset + count > buffer.Length)
            {
                throw new ArgumentException(Resources.InvalidOffsetAndCount);
            }

            return Read(buffer.AsSpan(offset, count));
        }

        /// <summary>
        ///     Reads a sequence of bytes from the current stream and advances the position within the stream by the
        ///     number of bytes read.
        /// </summary>
        /// <param name=""buffer"">
        ///     A region of memory. When this method returns, the contents of this region are replaced by the bytes read
        ///     from the current source.
        /// </param>
        /// <returns>
        ///     The total number of bytes read into the buffer. This can be less than the number of bytes allocated in
        ///     the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been
        ///     reached.
        /// </returns>
#if NET
        public override int Read(Span<byte> buffer)
#else
        public virtual int Read(Span<byte> buffer)
#endif
        {
            if (_blob == null)
            {
                throw new ObjectDisposedException(objectName: null);
            }

            var position = _position;
            if (position > Length)
            {
                position = Length;
            }

            var count = buffer.Length;
            if (position + count > Length)
            {
                count = (int)(Length - position);
            }

            var rc = sqlite3_blob_read(_blob, buffer.Slice(0, count), (int)position);
            SqliteException.ThrowExceptionForRC(rc, _connection.Handle);
            _position += count;
            return count;
        }

        /// <summary>
        ///     Writes a sequence of bytes to the current stream and advances the current position
        ///     within this stream by the number of bytes written.
        /// </summary>
        /// <param name=""buffer"">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
        /// <param name=""offset"">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
        /// <param name=""count"">The number of bytes to be written to the current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException(nameof(buffer));
            }

            if (offset < 0)
            {
                // NB: Message is provided by the framework
                throw new ArgumentOutOfRangeException(nameof(offset), offset, message: null);
            }

            if (count < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(count), count, message: null);
            }

            if (offset + count > buffer.Length)
            {
                throw new ArgumentException(Resources.InvalidOffsetAndCount);
            }

            if (_blob == null)
            {
                throw new ObjectDisposedException(objectName: null);
            }

            Write(buffer.AsSpan(offset, count));
        }

        /// <summary>
        ///     Writes a sequence of bytes to the current stream and advances the current position within this stream by
        ///     the number of bytes written.
        /// </summary>
        /// <param name=""buffer"">
        ///     A region of memory. This method copies the contents of this region to the current stream.
        /// </param>
#if NET
        public override void Write(ReadOnlySpan<byte> buffer)
#else
        public virtual void Write(ReadOnlySpan<byte> buffer)
#endif
        {
            if (!CanWrite)
            {
                throw new NotSupportedException(Resources.WriteNotSupported);
            }

            var position = _position;
            if (position > Length)
            {
                position = Length;
            }

            var count = buffer.Length;
            if (position + count > Length)
            {
                throw new NotSupportedException(Resources.ResizeNotSupported);
            }

            var rc = sqlite3_blob_write(_blob, buffer.Slice(0, count), (int)position);
            SqliteException.ThrowExceptionForRC(rc, _connection.Handle);
            _position += count;
        }

        /// <summary>
        ///     Sets the position within the current stream.
        /// </summary>
        /// <param name=""offset"">A byte offset relative to the origin parameter.</param>
        /// <param name=""origin"">A value indicating the reference point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            long position;
            switch (origin)
            {
                case SeekOrigin.Begin:
                    position = offset;
                    break;
                case SeekOrigin.Current:
                    position = _position + offset;
                    break;
                case SeekOrigin.End:
                    position = Length + offset;
                    break;
                default:
                    throw new ArgumentException(Resources.InvalidEnumValue(typeof(SeekOrigin), origin), nameof(origin));
            }

            if (position < 0)
            {
                throw new IOException(Resources.SeekBeforeBegin);
            }

            return _position = position;
        }

        /// <summary>
        ///     Releases any resources used by the blob and closes it.
        /// </summary>
        /// <param name=""disposing"">
        ///     true to release managed and unmanaged resources; <see langword=""false"" /> to release only unmanaged resources.
        /// </param>
        protected override void Dispose(bool disposing)
        {
            if (_blob != null)
            {
                _blob.Dispose();
                _blob = null;
            }
        }

        /// <summary>
        ///     Clears all buffers for this stream and causes any buffered data to be written to the underlying device.
        ///     Does nothing.
        /// </summary>
        public override void Flush()
        {
        }

        /// <summary>
        ///     Sets the length of the current stream. This is not supported by sqlite blobs.
        ///     Not supported.
        /// </summary>
        /// <param name=""value"">The desired length of the current stream in bytes.</param>
        /// <exception cref=""NotSupportedException"">Always.</exception>
        public override void SetLength(long value)
            => throw new NotSupportedException(Resources.ResizeNotSupported);
    }",0,439 334 2000 58 2001 123 437 2002 63 2003 59 437 441 2004 2005 59 437 413 2006 59 612 439 2000 40 2004 2007 44 461 2008 44 461 2009 44 413 2010 44 323 2011 61 380 41 58 467 40 2007 44 2004 46 2012 44 2008 44 2009 44 2010 44 2011 41 123 125 612 439 2000 40 2004 2007 44 461 2013 44 461 2008 44 461 2009 44 413 2010 44 323 2011 61 380 41 123 392 40 2007 634 2014 631 2015 46 2016 41 123 469 418 2017 40 2018 46 2019 41 59 125 392 40 2008 407 424 41 123 469 418 2020 40 2021 40 2008 41 41 59 125 392 40 2009 407 424 41 123 469 418 2022 40 2023 40 2009 41 41 59 125 2005 61 2007 59 2024 61 33 2011 59 490 2025 61 2026 40 2005 46 2027 44 2013 44 2008 44 2009 44 2010 44 2011 63 1500 58 1501 44 430 2003 41 59 2028 46 2029 40 2025 44 2005 46 2027 41 59 2030 61 2031 40 2003 41 59 125 612 439 431 323 2032 619 473 59 612 439 431 323 2033 123 2034 59 125 612 439 431 323 2035 619 473 59 612 439 431 413 2036 123 2037 59 125 612 439 431 413 2038 123 2039 619 2006 59 2040 123 392 40 2041 60 1500 41 123 621 469 418 2042 40 2043 40 2041 41 44 2041 44 2044 58 424 41 59 125 2006 61 2041 59 125 125 612 439 431 404 2045 40 326 91 93 2046 44 404 2047 44 404 2048 41 123 392 40 2046 614 424 41 123 469 418 2049 40 2050 40 2046 41 41 59 125 392 40 2047 60 1500 41 123 621 469 418 2051 40 2052 40 2047 41 44 2047 44 2053 58 424 41 59 125 392 40 2048 60 1500 41 123 469 418 2054 40 2055 40 2048 41 44 2048 44 2056 58 424 41 59 125 392 40 2047 43 2048 62 2046 46 2036 41 123 469 418 2057 40 2058 46 2059 41 59 125 450 2045 40 2046 46 2060 40 2047 44 2048 41 41 59 125 612 35 392 2061 439 431 404 2045 40 2062 60 326 62 2046 41 35 360 439 491 404 2045 40 2062 60 326 62 2046 41 35 366 123 392 40 2003 614 424 41 123 469 418 2063 40 2064 58 424 41 59 125 490 2065 61 2006 59 392 40 2065 62 2036 41 123 2065 61 2036 59 125 490 2048 61 2046 46 2036 59 392 40 2065 43 2048 62 2036 41 123 2048 61 40 404 41 40 2036 45 2065 41 59 125 490 2066 61 2067 40 2003 44 2046 46 2068 40 1500 44 2048 41 44 40 404 41 2065 41 59 2069 46 2070 40 2066 44 2005 46 2071 41 59 2006 636 2048 59 450 2048 59 125 612 439 431 492 2072 40 326 91 93 2046 44 404 2047 44 404 2048 41 123 392 40 2046 614 424 41 123 469 418 2073 40 2074 40 2046 41 41 59 125 392 40 2047 60 1500 41 123 621 469 418 2075 40 2076 40 2047 41 44 2047 44 2077 58 424 41 59 125 392 40 2048 60 1500 41 123 469 418 2078 40 2079 40 2048 41 44 2048 44 2080 58 424 41 59 125 392 40 2047 43 2048 62 2046 46 2036 41 123 469 418 2081 40 2082 46 2083 41 59 125 392 40 2003 614 424 41 123 469 418 2084 40 2085 58 424 41 59 125 2072 40 2046 46 2086 40 2047 44 2048 41 41 59 125 612 35 392 2061 439 431 492 2072 40 2087 60 326 62 2046 41 35 360 439 491 492 2072 40 2087 60 326 62 2046 41 35 366 123 392 40 33 2033 41 123 469 418 2088 40 2089 46 2090 41 59 125 490 2091 61 2006 59 392 40 2091 62 2036 41 123 2091 61 2036 59 125 490 2048 61 2046 46 2036 59 392 40 2091 43 2048 62 2036 41 123 469 418 2092 40 2093 46 2094 41 59 125 490 2095 61 2096 40 2003 44 2046 46 2097 40 1500 44 2048 41 44 40 404 41 2091 41 59 2098 46 2099 40 2095 44 2005 46 2100 41 59 2006 636 2048 59 125 612 439 431 413 2101 40 413 2047 44 2102 2103 41 123 413 2104 59 464 40 2103 41 123 328 2102 46 2105 58 2104 61 2047 59 325 59 328 2102 46 2106 58 2104 61 2006 43 2047 59 325 59 328 2102 46 2107 58 2104 61 2036 43 2047 59 325 59 349 58 469 418 2108 40 2109 46 2110 40 478 40 2102 41 44 2103 41 44 2111 40 2103 41 41 59 125 392 40 2104 60 1500 41 123 469 418 2112 40 2113 46 2114 41 59 125 450 2006 61 2104 59 125 612 438 431 492 2115 40 323 2116 41 123 392 40 2003 631 424 41 123 2003 46 2115 40 41 59 2003 61 424 59 125 125 612 439 431 492 2117 40 41 123 125 612 439 431 492 2118 40 413 2119 41 619 469 418 2120 40 2121 46 2122 41 59 125 
76166,C#,"    public class PlaylistXmlSaver : BaseXmlSaver
    {
        /// <summary>
        /// The default file name to use when creating a new playlist.
        /// </summary>
        public const string DefaultPlaylistFilename = ""playlist.xml"";

        /// <summary>
        /// Initializes a new instance of the <see cref=""PlaylistXmlSaver""/> class.
        /// </summary>
        /// <param name=""fileSystem"">Instance of the <see cref=""IFileSystem""/> interface.</param>
        /// <param name=""configurationManager"">Instance of the <see cref=""IServerConfigurationManager""/> interface.</param>
        /// <param name=""libraryManager"">Instance of the <see cref=""ILibraryManager""/> interface.</param>
        /// <param name=""logger"">Instance of the <see cref=""ILogger{PlaylistXmlSaver}""/> interface.</param>
        public PlaylistXmlSaver(IFileSystem fileSystem, IServerConfigurationManager configurationManager, ILibraryManager libraryManager, ILogger<PlaylistXmlSaver> logger)
            : base(fileSystem, configurationManager, libraryManager, logger)
        {
        }

        /// <inheritdoc />
        public override bool IsEnabledFor(BaseItem item, ItemUpdateType updateType)
        {
            if (!item.SupportsLocalMetadata)
            {
                return false;
            }

            return item is Playlist && updateType >= ItemUpdateType.MetadataImport;
        }

        /// <inheritdoc />
        protected override void WriteCustomElements(BaseItem item, XmlWriter writer)
        {
            var game = (Playlist)item;

            if (!string.IsNullOrEmpty(game.PlaylistMediaType))
            {
                writer.WriteElementString(""PlaylistMediaType"", game.PlaylistMediaType);
            }
        }

        /// <inheritdoc />
        protected override string GetLocalSavePath(BaseItem item)
        {
            return GetSavePath(item.Path);
        }

        /// <summary>
        /// Get the save path.
        /// </summary>
        /// <param name=""itemPath"">The item path.</param>
        /// <returns>The save path.</returns>
        public static string GetSavePath(string itemPath)
        {
            var path = itemPath;

            if (Playlist.IsPlaylistFile(path))
            {
                return Path.ChangeExtension(itemPath, "".xml"");
            }

            return Path.Combine(path, DefaultPlaylistFilename);
        }
    }",0,439 334 2000 58 2001 123 612 439 341 461 2002 61 648 59 612 439 2000 40 2003 2004 44 2005 2006 44 2007 2008 44 2009 60 2000 62 2010 41 58 320 40 2004 44 2006 44 2008 44 2010 41 123 125 612 439 431 323 2011 40 2012 2013 44 2014 2015 41 123 392 40 33 2013 46 2016 41 123 450 380 59 125 450 2013 407 2017 605 2015 615 2014 46 2018 59 125 612 438 431 492 2019 40 2012 2013 44 2020 2021 41 123 490 2022 61 40 2023 41 2013 59 392 40 33 461 46 2024 40 2022 46 2025 41 41 123 2021 46 2026 40 648 44 2022 46 2025 41 59 125 125 612 438 431 461 2027 40 2012 2013 41 123 450 2028 40 2013 46 2029 41 59 125 612 439 457 461 2030 40 461 2031 41 123 490 2032 61 2031 59 392 40 2033 46 2034 40 2032 41 41 123 450 2035 46 2036 40 2031 44 648 41 59 125 450 2037 46 2038 40 2032 44 2002 41 59 125 125 
76106,C#,"    public class BoxSetXmlParser : BaseItemXmlParser<BoxSet>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""BoxSetXmlParser""/> class.
        /// </summary>
        /// <param name=""logger"">Instance of the <see cref=""ILogger{BoxSetXmlParset}""/> interface.</param>
        /// <param name=""providerManager"">Instance of the <see cref=""IProviderManager""/> interface.</param>
        public BoxSetXmlParser(ILogger<BoxSetXmlParser> logger, IProviderManager providerManager)
            : base(logger, providerManager)
        {
        }

        /// <inheritdoc />
        protected override void FetchDataFromXmlNode(XmlReader reader, MetadataResult<BoxSet> itemResult)
        {
            switch (reader.Name)
            {
                case ""CollectionItems"":

                    if (!reader.IsEmptyElement)
                    {
                        using (var subReader = reader.ReadSubtree())
                        {
                            FetchFromCollectionItemsNode(subReader, itemResult);
                        }
                    }
                    else
                    {
                        reader.Read();
                    }

                    break;

                default:
                    base.FetchDataFromXmlNode(reader, itemResult);
                    break;
            }
        }

        private void FetchFromCollectionItemsNode(XmlReader reader, MetadataResult<BoxSet> item)
        {
            var list = new List<LinkedChild>();

            reader.MoveToContent();
            reader.Read();

            // Loop through each element
            while (!reader.EOF && reader.ReadState == ReadState.Interactive)
            {
                if (reader.NodeType == XmlNodeType.Element)
                {
                    switch (reader.Name)
                    {
                        case ""CollectionItem"":
                        {
                            if (!reader.IsEmptyElement)
                            {
                                using (var subReader = reader.ReadSubtree())
                                {
                                    var child = GetLinkedChild(subReader);

                                    if (child != null)
                                    {
                                        list.Add(child);
                                    }
                                }
                            }
                            else
                            {
                                reader.Read();
                            }

                            break;
                        }

                        default:
                        {
                            reader.Skip();
                            break;
                        }
                    }
                }
                else
                {
                    reader.Read();
                }
            }

            item.Item.LinkedChildren = list.ToArray();
        }
    }",0,439 334 2000 58 2001 60 2002 62 123 612 439 2000 40 2003 60 2000 62 2004 44 2005 2006 41 58 320 40 2004 44 2006 41 123 125 612 438 431 492 2007 40 2008 2009 44 2010 60 2002 62 2011 41 123 464 40 2009 46 2012 41 123 328 648 58 392 40 33 2009 46 2013 41 123 489 40 490 2014 61 2009 46 2015 40 41 41 123 2016 40 2014 44 2011 41 59 125 125 360 123 2009 46 2017 40 41 59 125 325 59 349 58 320 46 2007 40 2009 44 2011 41 59 325 59 125 125 437 492 2018 40 2008 2009 44 2010 60 2002 62 2019 41 123 490 411 61 418 2020 60 2021 62 40 41 59 2009 46 2022 40 41 59 2009 46 2023 40 41 59 621 496 40 33 2009 46 2024 605 2009 46 2025 614 2025 46 2026 41 123 392 40 2009 46 2027 614 2028 46 2029 41 123 464 40 2009 46 2030 41 123 328 648 58 123 392 40 33 2009 46 2031 41 123 489 40 490 2032 61 2009 46 2033 40 41 41 123 490 2034 61 2035 40 2032 41 59 392 40 2034 631 424 41 123 411 46 2036 40 2034 41 59 125 125 125 360 123 2009 46 2023 40 41 59 125 325 59 125 349 58 123 2009 46 2037 40 41 59 325 59 125 125 125 360 123 2009 46 2023 40 41 59 125 125 2019 46 2038 46 2039 61 411 46 2040 40 41 59 125 125 
76272,C#,"    public class BoxSet : Folder, IHasTrailers, IHasDisplayOrder, IHasLookupInfo<BoxSetInfo>
    {
        public BoxSet()
        {
            DisplayOrder = ItemSortBy.PremiereDate;
        }

        [JsonIgnore]
        protected override bool FilterLinkedChildrenPerUser => true;

        [JsonIgnore]
        public override bool SupportsInheritedParentImages => false;

        [JsonIgnore]
        public override bool SupportsPeople => true;

        /// <inheritdoc />
        public IReadOnlyList<BaseItem> LocalTrailers => GetExtras()
            .Where(extra => extra.ExtraType == Model.Entities.ExtraType.Trailer)
            .ToArray();

        /// <summary>
        /// Gets or sets the display order.
        /// </summary>
        /// <value>The display order.</value>
        public string DisplayOrder { get; set; }

        [JsonIgnore]
        private bool IsLegacyBoxSet
        {
            get
            {
                if (string.IsNullOrEmpty(Path))
                {
                    return false;
                }

                if (LinkedChildren.Length > 0)
                {
                    return false;
                }

                return !FileSystem.ContainsSubPath(ConfigurationManager.ApplicationPaths.DataPath, Path);
            }
        }

        [JsonIgnore]
        public override bool IsPreSorted => true;

        public Guid[] LibraryFolderIds { get; set; }

        protected override bool GetBlockUnratedValue(User user)
        {
            return user.GetPreferenceValues<UnratedItem>(PreferenceKind.BlockUnratedItems).Contains(UnratedItem.Movie);
        }

        public override double GetDefaultPrimaryImageAspectRatio()
            => 2.0 / 3;

        public override UnratedItem GetBlockUnratedType()
        {
            return UnratedItem.Movie;
        }

        protected override IEnumerable<BaseItem> GetNonCachedChildren(IDirectoryService directoryService)
        {
            if (IsLegacyBoxSet)
            {
                return base.GetNonCachedChildren(directoryService);
            }

            return Enumerable.Empty<BaseItem>();
        }

        protected override List<BaseItem> LoadChildren()
        {
            if (IsLegacyBoxSet)
            {
                return base.LoadChildren();
            }

            // Save a trip to the database
            return new List<BaseItem>();
        }

        public override bool IsAuthorizedToDelete(User user, List<Folder> allCollectionFolders)
        {
            return true;
        }

        public override bool IsSaveLocalMetadataEnabled()
        {
            return true;
        }

        public override List<BaseItem> GetChildren(User user, bool includeLinkedChildren, InternalItemsQuery query)
        {
            var children = base.GetChildren(user, includeLinkedChildren, query);

            if (string.Equals(DisplayOrder, ItemSortBy.SortName, StringComparison.OrdinalIgnoreCase))
            {
                // Sort by name
                return LibraryManager.Sort(children, user, new[] { ItemSortBy.SortName }, SortOrder.Ascending).ToList();
            }

            if (string.Equals(DisplayOrder, ItemSortBy.PremiereDate, StringComparison.OrdinalIgnoreCase))
            {
                // Sort by release date
                return LibraryManager.Sort(children, user, new[] { ItemSortBy.ProductionYear, ItemSortBy.PremiereDate, ItemSortBy.SortName }, SortOrder.Ascending).ToList();
            }

            // Default sorting
            return LibraryManager.Sort(children, user, new[] { ItemSortBy.ProductionYear, ItemSortBy.PremiereDate, ItemSortBy.SortName }, SortOrder.Ascending).ToList();
        }

        public override IEnumerable<BaseItem> GetRecursiveChildren(User user, InternalItemsQuery query)
        {
            var children = base.GetRecursiveChildren(user, query);

            if (string.Equals(DisplayOrder, ItemSortBy.PremiereDate, StringComparison.OrdinalIgnoreCase))
            {
                // Sort by release date
                return LibraryManager.Sort(children, user, new[] { ItemSortBy.ProductionYear, ItemSortBy.PremiereDate, ItemSortBy.SortName }, SortOrder.Ascending).ToList();
            }

            return children;
        }

        public BoxSetInfo GetLookupInfo()
        {
            return GetItemLookupInfo<BoxSetInfo>();
        }

        public override bool IsVisible(User user)
        {
            if (IsLegacyBoxSet)
            {
                return base.IsVisible(user);
            }

            if (base.IsVisible(user))
            {
                if (LinkedChildren.Length == 0)
                {
                    return true;
                }

                var userLibraryFolderIds = GetLibraryFolderIds(user);
                var libraryFolderIds = LibraryFolderIds ?? GetLibraryFolderIds();

                if (libraryFolderIds.Length == 0)
                {
                    return true;
                }

                return userLibraryFolderIds.Any(i => libraryFolderIds.Contains(i));
            }

            return false;
        }

        public override bool IsVisibleStandalone(User user)
        {
            if (IsLegacyBoxSet)
            {
                return base.IsVisibleStandalone(user);
            }

            return IsVisible(user);
        }

        private Guid[] GetLibraryFolderIds(User user)
        {
            return LibraryManager.GetUserRootFolder().GetChildren(user, true)
                .Select(i => i.Id)
                .ToArray();
        }

        public Guid[] GetLibraryFolderIds()
        {
            var expandedFolders = new List<Guid>();

            return FlattenItems(this, expandedFolders)
                .SelectMany(i => LibraryManager.GetCollectionFolders(i))
                .Select(i => i.Id)
                .Distinct()
                .ToArray();
        }

        private IEnumerable<BaseItem> FlattenItems(IEnumerable<BaseItem> items, List<Guid> expandedFolders)
        {
            return items
                .SelectMany(i => FlattenItems(i, expandedFolders));
        }

        private IEnumerable<BaseItem> FlattenItems(BaseItem item, List<Guid> expandedFolders)
        {
            if (item is BoxSet boxset)
            {
                if (!expandedFolders.Contains(item.Id))
                {
                    expandedFolders.Add(item.Id);

                    return FlattenItems(boxset.GetLinkedChildren(), expandedFolders);
                }

                return Array.Empty<BaseItem>();
            }

            return new[] { item };
        }
    }",0,439 334 2000 58 2001 44 2002 44 2003 44 2004 60 2005 62 123 439 2000 40 41 123 2006 61 2007 46 2008 59 125 91 2009 93 438 431 323 2010 619 473 59 91 2009 93 439 431 323 2011 619 380 59 91 2009 93 439 431 323 2012 619 473 59 612 439 2013 60 2014 62 2015 619 2016 40 41 46 2017 40 2018 619 2018 46 2019 614 2020 46 2021 46 2019 46 2022 41 46 2023 40 41 59 612 439 461 2024 123 2025 59 2026 59 125 91 2009 93 437 323 2027 123 2028 123 392 40 461 46 2029 40 2030 41 41 123 450 380 59 125 392 40 2031 46 2032 62 1500 41 123 450 380 59 125 450 33 2033 46 2034 40 2035 46 2036 46 2037 44 2030 41 59 125 125 91 2009 93 439 431 323 2038 619 473 59 439 2039 91 93 2040 123 2041 59 2042 59 125 438 431 323 2043 40 2044 2045 41 123 450 2045 46 2046 60 2047 62 40 2048 46 2049 41 46 2050 40 2047 46 2051 41 59 125 439 431 356 2052 40 41 619 1502 47 1502 59 439 431 2053 2054 40 41 123 450 2053 46 2055 59 125 438 431 2056 60 2014 62 2057 40 2058 2059 41 123 392 40 2027 41 123 450 320 46 2057 40 2059 41 59 125 450 2060 46 2061 60 2014 62 40 41 59 125 438 431 2062 60 2014 62 2063 40 41 123 392 40 2027 41 123 450 320 46 2063 40 41 59 125 621 450 418 2062 60 2014 62 40 41 59 125 439 431 323 2064 40 2044 2045 44 2062 60 2001 62 2065 41 123 450 473 59 125 439 431 323 2066 40 41 123 450 473 59 125 439 431 2062 60 2014 62 2067 40 2044 2045 44 323 2068 44 2069 2070 41 123 490 2071 61 320 46 2067 40 2045 44 2068 44 2070 41 59 392 40 461 46 2072 40 2024 44 2073 46 2074 44 2075 46 2076 41 41 123 621 450 2077 46 2078 40 2071 44 2045 44 418 91 93 123 2073 46 2074 125 44 2079 46 2080 41 46 2081 40 41 59 125 392 40 461 46 2072 40 2024 44 2073 46 2082 44 2075 46 2076 41 41 123 621 450 2083 46 2084 40 2071 44 2045 44 418 91 93 123 2073 46 2085 44 2073 46 2082 44 2073 46 2074 125 44 2086 46 2087 41 46 2088 40 41 59 125 621 450 2089 46 2090 40 2071 44 2045 44 418 91 93 123 2073 46 2091 44 2073 46 2082 44 2073 46 2074 125 44 2092 46 2093 41 46 2094 40 41 59 125 439 431 2056 60 2014 62 2095 40 2044 2045 44 2069 2070 41 123 490 2096 61 320 46 2095 40 2045 44 2070 41 59 392 40 461 46 2097 40 2024 44 2098 46 2099 44 2100 46 2101 41 41 123 621 450 2102 46 2103 40 2096 44 2045 44 418 91 93 123 2098 46 2104 44 2098 46 2099 44 2098 46 2105 125 44 2106 46 2107 41 46 2108 40 41 59 125 450 2096 59 125 439 2005 2109 40 41 123 450 2110 60 2005 62 40 41 59 125 439 431 323 2111 40 2044 2045 41 123 392 40 2027 41 123 450 320 46 2111 40 2045 41 59 125 392 40 320 46 2111 40 2045 41 41 123 392 40 2112 46 2113 614 1500 41 123 450 473 59 125 490 2114 61 2115 40 2045 41 59 490 2116 61 2040 633 2115 40 41 59 392 40 2116 46 2113 614 1500 41 123 450 473 59 125 450 2114 46 2117 40 2118 619 2116 46 2119 40 2118 41 41 59 125 450 380 59 125 439 431 323 2120 40 2044 2045 41 123 392 40 2027 41 123 450 320 46 2120 40 2045 41 59 125 450 2111 40 2045 41 59 125 437 2039 91 93 2121 40 2044 2045 41 123 450 2122 46 2123 40 41 46 2067 40 2045 44 473 41 46 2124 40 2125 619 2125 46 2126 41 46 2023 40 41 59 125 439 2039 91 93 2121 40 41 123 490 2127 61 418 2062 60 2039 62 40 41 59 450 2128 40 467 44 2127 41 46 2129 40 2130 619 2131 46 2132 40 2130 41 41 46 2133 40 2130 619 2130 46 2134 41 46 2135 40 41 46 2023 40 41 59 125 437 2056 60 2014 62 2136 40 2056 60 2014 62 2137 44 2062 60 2039 62 2138 41 123 450 2137 46 2139 40 2140 619 2136 40 2140 44 2138 41 41 59 125 437 2056 60 2014 62 2136 40 2014 2141 44 2062 60 2039 62 2138 41 123 392 40 2141 407 2000 2142 41 123 392 40 33 2138 46 2143 40 2141 46 2144 41 41 123 2138 46 2145 40 2141 46 2144 41 59 450 2136 40 2142 46 2146 40 41 44 2138 41 59 125 450 2147 46 2148 60 2014 62 40 41 59 125 450 418 91 93 123 2141 125 59 125 125 
76026,C#,"    public class Trailer : Video, IHasLookupInfo<TrailerInfo>
    {
        public Trailer()
        {
            TrailerTypes = Array.Empty<TrailerType>();
        }

        [JsonIgnore]
        public override bool StopRefreshIfLocalMetadataFound => false;

        public TrailerType[] TrailerTypes { get; set; }

        public override double GetDefaultPrimaryImageAspectRatio()
            => 2.0 / 3;

        public override UnratedItem GetBlockUnratedType()
        {
            return UnratedItem.Trailer;
        }

        public TrailerInfo GetLookupInfo()
        {
            var info = GetItemLookupInfo<TrailerInfo>();

            if (!IsInMixedFolder && IsFileProtocol)
            {
                info.Name = System.IO.Path.GetFileName(ContainingFolderPath);
            }

            return info;
        }

        public override bool BeforeMetadataRefresh(bool replaceAllMetadata)
        {
            var hasChanges = base.BeforeMetadataRefresh(replaceAllMetadata);

            if (!ProductionYear.HasValue)
            {
                var info = LibraryManager.ParseName(Name);

                var yearInName = info.Year;

                if (yearInName.HasValue)
                {
                    ProductionYear = yearInName;
                    hasChanges = true;
                }
                else
                {
                    // Try to get the year from the folder name
                    if (!IsInMixedFolder)
                    {
                        info = LibraryManager.ParseName(System.IO.Path.GetFileName(ContainingFolderPath));

                        yearInName = info.Year;

                        if (yearInName.HasValue)
                        {
                            ProductionYear = yearInName;
                            hasChanges = true;
                        }
                    }
                }
            }

            return hasChanges;
        }

        public override List<ExternalUrl> GetRelatedUrls()
        {
            var list = base.GetRelatedUrls();

            var imdbId = this.GetProviderId(MetadataProvider.Imdb);
            if (!string.IsNullOrEmpty(imdbId))
            {
                list.Add(new ExternalUrl
                {
                    Name = ""Trakt"",
                    Url = string.Format(CultureInfo.InvariantCulture, ""https://trakt.tv/movies/{0}"", imdbId)
                });
            }

            return list;
        }
    }",0,439 334 2000 58 2001 44 2002 60 2003 62 123 439 2000 40 41 123 2004 61 2005 46 2006 60 2007 62 40 41 59 125 91 2008 93 439 431 323 2009 619 380 59 439 2010 91 93 2011 123 2012 59 2013 59 125 439 431 356 2014 40 41 619 1502 47 1502 59 439 431 2015 2016 40 41 123 450 2015 46 2000 59 125 439 2003 2017 40 41 123 490 2018 61 2019 60 2003 62 40 41 59 392 40 33 2020 605 2021 41 123 2018 46 2022 61 2023 46 2024 46 2025 46 2026 40 2027 41 59 125 450 2018 59 125 439 431 323 2028 40 323 2029 41 123 490 2030 61 320 46 2028 40 2029 41 59 392 40 33 2031 46 2032 41 123 490 2033 61 2034 46 2035 40 2036 41 59 490 2037 61 2033 46 2038 59 392 40 2037 46 2032 41 123 2031 61 2037 59 2030 61 473 59 125 360 123 621 392 40 33 2039 41 123 2033 61 2034 46 2035 40 2040 46 2041 46 2042 46 2043 40 2044 41 41 59 2037 61 2033 46 2038 59 392 40 2037 46 2032 41 123 2031 61 2037 59 2030 61 473 59 125 125 125 125 450 2030 59 125 439 431 2045 60 2046 62 2047 40 41 123 490 411 61 320 46 2047 40 41 59 490 2048 61 467 46 2049 40 2050 46 2051 41 59 392 40 33 461 46 2052 40 2048 41 41 123 411 46 2053 40 418 2046 123 2054 61 648 44 2055 61 461 46 2056 40 2057 46 2058 44 648 44 2048 41 125 41 59 125 450 411 59 125 125 
76863,C#,"    public class FFProbeProvider : ICustomMetadataProvider<Episode>,
        ICustomMetadataProvider<MusicVideo>,
        ICustomMetadataProvider<Movie>,
        ICustomMetadataProvider<Trailer>,
        ICustomMetadataProvider<Video>,
        ICustomMetadataProvider<Audio>,
        ICustomMetadataProvider<AudioBook>,
        IHasOrder,
        IForcedProvider,
        IPreRefreshProvider,
        IHasItemChangeMonitor
    {
        private readonly ILogger<FFProbeProvider> _logger;
        private readonly SubtitleResolver _subtitleResolver;
        private readonly AudioResolver _audioResolver;
        private readonly FFProbeVideoInfo _videoProber;
        private readonly FFProbeAudioInfo _audioProber;

        private readonly Task<ItemUpdateType> _cachedTask = Task.FromResult(ItemUpdateType.None);

        public FFProbeProvider(
            ILogger<FFProbeProvider> logger,
            IMediaSourceManager mediaSourceManager,
            IMediaEncoder mediaEncoder,
            IItemRepository itemRepo,
            IBlurayExaminer blurayExaminer,
            ILocalizationManager localization,
            IEncodingManager encodingManager,
            IServerConfigurationManager config,
            ISubtitleManager subtitleManager,
            IChapterManager chapterManager,
            ILibraryManager libraryManager,
            NamingOptions namingOptions)
        {
            _logger = logger;
            _audioResolver = new AudioResolver(localization, mediaEncoder, namingOptions);
            _subtitleResolver = new SubtitleResolver(BaseItem.LocalizationManager);
            _videoProber = new FFProbeVideoInfo(
                _logger,
                mediaSourceManager,
                mediaEncoder,
                itemRepo,
                blurayExaminer,
                localization,
                encodingManager,
                config,
                subtitleManager,
                chapterManager,
                libraryManager,
                _audioResolver);
            _audioProber = new FFProbeAudioInfo(mediaSourceManager, mediaEncoder, itemRepo, libraryManager);
        }

        public string Name => ""ffprobe"";

        // Run last
        public int Order => 100;

        public bool HasChanged(BaseItem item, IDirectoryService directoryService)
        {
            var video = item as Video;
            if (video == null || video.VideoType == VideoType.VideoFile || video.VideoType == VideoType.Iso)
            {
                var path = item.Path;

                if (!string.IsNullOrWhiteSpace(path) && item.IsFileProtocol)
                {
                    var file = directoryService.GetFile(path);
                    if (file != null && file.LastWriteTimeUtc != item.DateModified)
                    {
                        _logger.LogDebug(""Refreshing {ItemPath} due to date modified timestamp change."", path);
                        return true;
                    }
                }
            }

            if (item.SupportsLocalMetadata && video != null && !video.IsPlaceHolder
                && !video.SubtitleFiles.SequenceEqual(
                        _subtitleResolver.GetExternalSubtitleFiles(video, directoryService, false), StringComparer.Ordinal))
            {
                _logger.LogDebug(""Refreshing {ItemPath} due to external subtitles change."", item.Path);
                return true;
            }

            if (item.SupportsLocalMetadata && video != null && !video.IsPlaceHolder
                && !video.AudioFiles.SequenceEqual(
                        _audioResolver.GetExternalAudioFiles(video, directoryService, false), StringComparer.Ordinal))
            {
                _logger.LogDebug(""Refreshing {ItemPath} due to external audio change."", item.Path);
                return true;
            }

            return false;
        }

        public Task<ItemUpdateType> FetchAsync(Episode item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(MusicVideo item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Movie item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Trailer item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Video item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Audio item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchAudioInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(AudioBook item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchAudioInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchVideoInfo<T>(T item, MetadataRefreshOptions options, CancellationToken cancellationToken)
            where T : Video
        {
            if (item.IsPlaceHolder)
            {
                return _cachedTask;
            }

            if (!item.IsCompleteMedia)
            {
                return _cachedTask;
            }

            if (item.IsVirtualItem)
            {
                return _cachedTask;
            }

            if (!options.EnableRemoteContentProbe && !item.IsFileProtocol)
            {
                return _cachedTask;
            }

            if (item.IsShortcut)
            {
                FetchShortcutInfo(item);
            }

            return _videoProber.ProbeVideo(item, options, cancellationToken);
        }

        private string NormalizeStrmLine(string line)
        {
            return line.Replace(""\t"", string.Empty, StringComparison.Ordinal)
                .Replace(""\r"", string.Empty, StringComparison.Ordinal)
                .Replace(""\n"", string.Empty, StringComparison.Ordinal)
                .Trim();
        }

        private void FetchShortcutInfo(BaseItem item)
        {
            item.ShortcutPath = File.ReadAllLines(item.Path)
                .Select(NormalizeStrmLine)
                .FirstOrDefault(i => !string.IsNullOrWhiteSpace(i) && !i.StartsWith('#'));
        }

        public Task<ItemUpdateType> FetchAudioInfo<T>(T item, MetadataRefreshOptions options, CancellationToken cancellationToken)
            where T : Audio
        {
            if (item.IsVirtualItem)
            {
                return _cachedTask;
            }

            if (!options.EnableRemoteContentProbe && !item.IsFileProtocol)
            {
                return _cachedTask;
            }

            if (item.IsShortcut)
            {
                FetchShortcutInfo(item);
            }

            return _audioProber.Probe(item, options, cancellationToken);
        }
    }",0,439 334 2000 58 2001 60 2002 62 44 2001 60 2003 62 44 2001 60 2004 62 44 2001 60 2005 62 44 2001 60 2006 62 44 2001 60 2007 62 44 2001 60 2008 62 44 2009 44 2010 44 2011 44 2012 123 437 441 2013 60 2000 62 2014 59 437 441 2015 2016 59 437 441 2017 2018 59 437 441 2019 2020 59 437 441 2021 2022 59 437 441 2023 60 2024 62 2025 61 2023 46 2026 40 2024 46 303 41 59 439 2000 40 2013 60 2000 62 2027 44 2028 2029 44 2030 2031 44 2032 2033 44 2034 2035 44 2036 2037 44 2038 2039 44 2040 2041 44 2042 2043 44 2044 2045 44 2046 2047 44 2048 2049 41 123 2014 61 2027 59 2018 61 418 2017 40 2037 44 2031 44 2049 41 59 2016 61 418 2015 40 2050 46 2051 41 59 2020 61 418 2019 40 2014 44 2029 44 2031 44 2033 44 2035 44 2037 44 2039 44 2041 44 2043 44 2045 44 2047 44 2018 41 59 2022 61 418 2021 40 2029 44 2031 44 2033 44 2047 41 59 125 439 461 2052 619 648 59 621 439 404 2053 619 1503 59 439 323 2054 40 2055 2056 44 2057 2058 41 123 490 2059 61 2056 311 2006 59 392 40 2059 614 424 606 2059 46 2060 614 2060 46 2061 606 2059 46 2060 614 2060 46 2062 41 123 490 2063 61 2056 46 2064 59 392 40 33 461 46 2065 40 2063 41 605 2056 46 2066 41 123 490 2067 61 2058 46 2068 40 2063 41 59 392 40 2067 631 424 605 2067 46 2069 631 2056 46 2070 41 123 2014 46 2071 40 648 44 2063 41 59 450 473 59 125 125 125 392 40 2056 46 2072 605 2059 631 424 605 33 2059 46 2073 605 33 2059 46 2074 46 2075 40 2016 46 2076 40 2059 44 2058 44 380 41 44 2077 46 2078 41 41 123 2014 46 2079 40 648 44 2056 46 2080 41 59 450 473 59 125 392 40 2056 46 2072 605 2059 631 424 605 33 2059 46 2073 605 33 2059 46 2081 46 2075 40 2018 46 2082 40 2059 44 2058 44 380 41 44 2077 46 2078 41 41 123 2014 46 2083 40 648 44 2056 46 2084 41 59 450 473 59 125 450 380 59 125 439 2023 60 2024 62 2085 40 2002 2056 44 2086 2087 44 2088 2089 41 123 450 2090 40 2056 44 2087 44 2089 41 59 125 439 2023 60 2024 62 2085 40 2003 2056 44 2086 2087 44 2088 2089 41 123 450 2091 40 2056 44 2087 44 2089 41 59 125 439 2023 60 2024 62 2085 40 2004 2056 44 2086 2087 44 2088 2089 41 123 450 2092 40 2056 44 2087 44 2089 41 59 125 439 2023 60 2024 62 2085 40 2005 2056 44 2086 2087 44 2088 2089 41 123 450 2093 40 2056 44 2087 44 2089 41 59 125 439 2023 60 2024 62 2085 40 2006 2056 44 2086 2087 44 2088 2089 41 123 450 2094 40 2056 44 2087 44 2089 41 59 125 439 2023 60 2024 62 2085 40 2007 2056 44 2086 2087 44 2088 2089 41 123 450 2095 40 2056 44 2087 44 2089 41 59 125 439 2023 60 2024 62 2085 40 2008 2056 44 2086 2087 44 2088 2089 41 123 450 2096 40 2056 44 2087 44 2089 41 59 125 439 2023 60 2024 62 2097 60 2098 62 40 2098 2056 44 2086 2087 44 2088 2089 41 2099 2098 58 2006 123 392 40 2056 46 2100 41 123 450 2025 59 125 392 40 33 2056 46 2101 41 123 450 2025 59 125 392 40 2056 46 2102 41 123 450 2025 59 125 392 40 33 2087 46 2103 605 33 2056 46 2104 41 123 450 2025 59 125 392 40 2056 46 2105 41 123 2106 40 2056 41 59 125 450 2020 46 2107 40 2056 44 2087 44 2089 41 59 125 437 461 2108 40 461 2109 41 123 450 2109 46 2110 40 648 44 461 46 2111 44 2112 46 2113 41 46 2110 40 648 44 461 46 2111 44 2112 46 2113 41 46 2110 40 648 44 461 46 2111 44 2112 46 2113 41 46 2114 40 41 59 125 437 492 2115 40 2055 2056 41 123 2056 46 2116 61 2117 46 2118 40 2056 46 2119 41 46 2120 40 2108 41 46 2121 40 2122 619 33 461 46 2123 40 2122 41 605 33 2122 46 2124 40 607 41 41 59 125 439 2023 60 2024 62 2125 60 2098 62 40 2098 2056 44 2086 2087 44 2088 2089 41 2099 2098 58 2007 123 392 40 2056 46 2126 41 123 450 2025 59 125 392 40 33 2087 46 2127 605 33 2056 46 2128 41 123 450 2025 59 125 392 40 2056 46 2129 41 123 2115 40 2056 41 59 125 450 2022 46 2130 40 2056 44 2087 44 2089 41 59 125 125 
76073,C#,"    public static class MimeTypes
    {
        /// <summary>
        /// Any extension in this list is considered a video file.
        /// </summary>
        private static readonly HashSet<string> _videoFileExtensions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "".3gp"",
            "".asf"",
            "".avi"",
            "".divx"",
            "".dvr-ms"",
            "".f4v"",
            "".flv"",
            "".img"",
            "".iso"",
            "".m2t"",
            "".m2ts"",
            "".m2v"",
            "".m4v"",
            "".mk3d"",
            "".mkv"",
            "".mov"",
            "".mp4"",
            "".mpg"",
            "".mpeg"",
            "".mts"",
            "".ogg"",
            "".ogm"",
            "".ogv"",
            "".rec"",
            "".ts"",
            "".rmvb"",
            "".webm"",
            "".wmv"",
            "".wtv"",
        };

        /// <summary>
        /// Used for extensions not in <see cref=""Model.MimeTypes""/> or to override them.
        /// </summary>
        private static readonly Dictionary<string, string> _mimeTypeLookup = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            // Type application
            { "".azw3"", ""application/vnd.amazon.ebook"" },

            // Type image
            { "".tbn"", ""image/jpeg"" },

            // Type text
            { "".ass"", ""text/x-ssa"" },
            { "".ssa"", ""text/x-ssa"" },
            { "".edl"", ""text/plain"" },
            { "".html"", ""text/html; charset=UTF-8"" },
            { "".htm"", ""text/html; charset=UTF-8"" },

            // Type video
            { "".mpegts"", ""video/mp2t"" },

            // Type audio
            { "".aac"", ""audio/aac"" },
            { "".ac3"", ""audio/ac3"" },
            { "".ape"", ""audio/x-ape"" },
            { "".dsf"", ""audio/dsf"" },
            { "".dsp"", ""audio/dsp"" },
            { "".flac"", ""audio/flac"" },
            { "".m4b"", ""audio/m4b"" },
            { "".mp3"", ""audio/mpeg"" },
            { "".vorbis"", ""audio/vorbis"" },
            { "".webma"", ""audio/webm"" },
            { "".wv"", ""audio/x-wavpack"" },
            { "".xsp"", ""audio/xsp"" },
        };

        private static readonly Dictionary<string, string> _extensionLookup = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            // Type application
            { ""application/x-cbz"", "".cbz"" },
            { ""application/x-javascript"", "".js"" },
            { ""application/xml"", "".xml"" },
            { ""application/x-mpegURL"", "".m3u8"" },

            // Type audio
            { ""audio/aac"", "".aac"" },
            { ""audio/ac3"", "".ac3"" },
            { ""audio/dsf"", "".dsf"" },
            { ""audio/dsp"", "".dsp"" },
            { ""audio/flac"", "".flac"" },
            { ""audio/m4b"", "".m4b"" },
            { ""audio/vorbis"", "".vorbis"" },
            { ""audio/x-ape"", "".ape"" },
            { ""audio/xsp"", "".xsp"" },
            { ""audio/x-wavpack"", "".wv"" },

            // Type image
            { ""image/jpeg"", "".jpg"" },
            { ""image/x-png"", "".png"" },

            // Type text
            { ""text/plain"", "".txt"" },
            { ""text/rtf"", "".rtf"" },
            { ""text/x-ssa"", "".ssa"" },

            // Type video
            { ""video/vnd.mpeg.dash.mpd"", "".mpd"" },
            { ""video/x-matroska"", "".mkv"" },
        };

        public static string GetMimeType(string path) => GetMimeType(path, ""application/octet-stream"");

        /// <summary>
        /// Gets the type of the MIME.
        /// </summary>
        /// <param name=""filename"">The filename to find the MIME type of.</param>
        /// <param name=""defaultValue"">The default value to return if no fitting MIME type is found.</param>
        /// <returns>The correct MIME type for the given filename, or <paramref name=""defaultValue""/> if it wasn't found.</returns>
        [return: NotNullIfNotNull(""defaultValue"")]
        public static string? GetMimeType(string filename, string? defaultValue = null)
        {
            if (filename.Length == 0)
            {
                throw new ArgumentException(""String can't be empty."", nameof(filename));
            }

            var ext = Path.GetExtension(filename);

            if (_mimeTypeLookup.TryGetValue(ext, out string? result))
            {
                return result;
            }

            if (Model.MimeTypes.TryGetMimeType(filename, out var mimeType))
            {
                return mimeType;
            }

            // Catch-all for all video types that don't require specific mime types
            if (_videoFileExtensions.Contains(ext))
            {
                return string.Concat(""video/"", ext.AsSpan(1));
            }

            return defaultValue;
        }

        public static string? ToExtension(string mimeType)
        {
            if (mimeType.Length == 0)
            {
                throw new ArgumentException(""String can't be empty."", nameof(mimeType));
            }

            // handle text/html; charset=UTF-8
            mimeType = mimeType.AsSpan().LeftPart(';').ToString();

            if (_extensionLookup.TryGetValue(mimeType, out string? result))
            {
                return result;
            }

            var extension = Model.MimeTypes.GetMimeTypeExtensions(mimeType).FirstOrDefault();
            return string.IsNullOrEmpty(extension) ? null : ""."" + extension;
        }
    }",0,439 457 334 2000 123 612 437 457 441 2001 60 461 62 2002 61 418 2001 60 461 62 40 2003 46 2004 41 123 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 125 59 612 437 457 441 2005 60 461 44 461 62 2006 61 418 2005 60 461 44 461 62 40 2003 46 2004 41 123 621 123 648 44 648 125 44 621 123 648 44 648 125 44 621 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 621 123 648 44 648 125 44 621 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 125 59 437 457 441 2005 60 461 44 461 62 2007 61 418 2005 60 461 44 461 62 40 2003 46 2004 41 123 621 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 621 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 621 123 648 44 648 125 44 123 648 44 648 125 44 621 123 648 44 648 125 44 123 648 44 648 125 44 123 648 44 648 125 44 621 123 648 44 648 125 44 123 648 44 648 125 44 125 59 439 457 461 2008 40 461 2009 41 619 2008 40 2009 44 648 41 59 612 91 450 58 2010 40 648 41 93 439 457 461 63 2008 40 461 2011 44 461 63 2012 61 424 41 123 392 40 2011 46 2013 614 1500 41 123 469 418 2014 40 648 44 2015 40 2011 41 41 59 125 490 2016 61 2017 46 2018 40 2011 41 59 392 40 2006 46 2019 40 2016 44 430 461 63 2020 41 41 123 450 2020 59 125 392 40 2021 46 2000 46 2022 40 2011 44 430 490 2023 41 41 123 450 2023 59 125 621 392 40 2002 46 2024 40 2016 41 41 123 450 461 46 2025 40 648 44 2016 46 2026 40 1501 41 41 59 125 450 2012 59 125 439 457 461 63 2027 40 461 2028 41 123 392 40 2028 46 2029 614 1500 41 123 469 418 2030 40 648 44 2031 40 2028 41 41 59 125 621 2028 61 2028 46 2032 40 41 46 2033 40 607 41 46 2034 40 41 59 392 40 2007 46 2035 40 2028 44 430 461 63 2036 41 41 123 450 2036 59 125 490 2037 61 2038 46 2000 46 2039 40 2028 41 46 2040 40 41 59 450 461 46 2041 40 2037 41 63 424 58 648 43 2037 59 125 125 
68798,C#,"    protected class FakeValueComparer : ValueComparer<object>
    {
        public FakeValueComparer()
            : base(false)
        {
        }

        public override Type Type { get; } = typeof(object);
    }",0,438 334 2000 58 2001 60 426 62 123 439 2000 40 41 58 320 40 380 41 123 125 439 431 2002 2002 123 2003 59 125 61 478 40 426 41 59 125 
72742,C#,"    private class OneRowContext : DbContext
    {
        private readonly bool _async;

        public OneRowContext(bool async)
        {
            _async = async;
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseInMemoryDatabase(nameof(OneRowContext) + _async);

        public DbSet<Blog> Blogs { get; set; }
    }",0,437 334 2000 58 2001 123 437 441 323 2002 59 439 2000 40 323 314 41 123 2002 61 314 59 125 438 406 431 492 2003 40 2004 2005 41 619 2005 46 2006 40 2007 40 2000 41 43 2002 41 59 439 2008 60 2009 62 2010 123 2011 59 2012 59 125 125 
69970,C#,"public static class DesignTimeServiceCollectionExtensions
{
    /// <summary>
    ///     Adds the Entity Framework Core design-time services.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-design-time-services"">EF Core design-time services</see> for more information and examples.
    /// </remarks>
    /// <param name=""services"">The <see cref=""IServiceCollection"" /> the services will be added to.</param>
    /// <param name=""reporter"">Used to report design-time messages.</param>
    /// <param name=""applicationServiceProviderAccessor"">An accessor to the application service provider.</param>
    /// <returns>The <paramref name=""services"" />. This enables chaining additional method calls.</returns>
    public static IServiceCollection AddEntityFrameworkDesignTimeServices(
        this IServiceCollection services,
        IOperationReporter? reporter = null,
        Func<IServiceProvider>? applicationServiceProviderAccessor = null)
    {
        reporter ??= new OperationReporter(handler: null);

        new EntityFrameworkRelationalDesignServicesBuilder(services)
            .TryAddProviderSpecificServices(
                services => services
                    .TryAddSingleton<CSharpMigrationOperationGeneratorDependencies, CSharpMigrationOperationGeneratorDependencies>()
                    .TryAddSingleton<CSharpMigrationsGeneratorDependencies, CSharpMigrationsGeneratorDependencies>()
                    .TryAddSingleton<CSharpSnapshotGeneratorDependencies, CSharpSnapshotGeneratorDependencies>()
                    .TryAddSingleton<ICandidateNamingService, CandidateNamingService>()
                    .TryAddSingleton<ICSharpDbContextGenerator, CSharpDbContextGenerator>()
                    .TryAddSingleton<ICSharpEntityTypeGenerator, CSharpEntityTypeGenerator>()
                    .TryAddSingleton<ICSharpHelper, CSharpHelper>()
                    .TryAddSingleton<ICSharpMigrationOperationGenerator, CSharpMigrationOperationGenerator>()
                    .TryAddSingleton<ICSharpSnapshotGenerator, CSharpSnapshotGenerator>()
                    .TryAddSingleton<ICSharpUtilities, CSharpUtilities>()
                    .TryAddSingleton(reporter)
                    .TryAddSingleton<IMigrationsCodeGenerator, CSharpMigrationsGenerator>()
                    .TryAddSingleton<IMigrationsCodeGeneratorSelector, MigrationsCodeGeneratorSelector>()
                    .TryAddSingleton<IModelCodeGenerator, CSharpModelGenerator>()
                    .TryAddSingleton<IModelCodeGeneratorSelector, ModelCodeGeneratorSelector>()
                    .TryAddSingleton<ICompiledModelCodeGenerator, CSharpRuntimeModelCodeGenerator>()
                    .TryAddSingleton<ICompiledModelCodeGeneratorSelector, CompiledModelCodeGeneratorSelector>()
                    .TryAddSingleton<ICompiledModelScaffolder, CompiledModelScaffolder>()
                    .TryAddSingleton<IDesignTimeConnectionStringResolver>(
                        new DesignTimeConnectionStringResolver(applicationServiceProviderAccessor))
                    .TryAddSingleton<IPluralizer, HumanizerPluralizer>()
                    .TryAddSingleton<IScaffoldingModelFactory, RelationalScaffoldingModelFactory>()
                    .TryAddSingleton<IScaffoldingTypeMapper, ScaffoldingTypeMapper>()
                    .TryAddSingleton<MigrationsCodeGeneratorDependencies, MigrationsCodeGeneratorDependencies>()
                    .TryAddSingleton<ModelCodeGeneratorDependencies, ModelCodeGeneratorDependencies>()
                    .TryAddScoped<IReverseEngineerScaffolder, ReverseEngineerScaffolder>()
                    .TryAddScoped<MigrationsScaffolderDependencies, MigrationsScaffolderDependencies>()
                    .TryAddScoped<IMigrationsScaffolder, MigrationsScaffolder>()
                    .TryAddScoped<ISnapshotModelProcessor, SnapshotModelProcessor>());

        var loggerFactory = new LoggerFactory(
            new[] { new OperationLoggerProvider(reporter) }, new LoggerFilterOptions { MinLevel = LogLevel.Debug });
        services.AddScoped<ILoggerFactory>(_ => loggerFactory);

        return services;
    }

    /// <summary>
    ///     Adds services from the <see cref=""DbContext"" /> which are used at design time.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-design-time-services"">EF Core design-time services</see> for more information and examples.
    /// </remarks>
    /// <param name=""services"">The <see cref=""IServiceCollection"" /> the services will be added to.</param>
    /// <param name=""context"">The <see cref=""DbContext"" /> the services will be added from.</param>
    /// <returns>The <paramref name=""services"" />. This enables chaining additional method calls.</returns>
    public static IServiceCollection AddDbContextDesignTimeServices(
        this IServiceCollection services,
        DbContext context)
    {
        new EntityFrameworkRelationalServicesBuilder(services)
            .TryAdd(context.GetService<IDatabaseProvider>())
            .TryAdd(_ => context.GetService<IMigrationsIdGenerator>())
            .TryAdd(_ => context.GetService<IRelationalTypeMappingSource>())
            .TryAdd(_ => context.GetService<IModelRuntimeInitializer>())
            .TryAdd(_ => context.GetService<LoggingDefinitions>())
            .TryAdd(_ => context.GetService<ICurrentDbContext>())
            .TryAdd(_ => context.GetService<IDbContextOptions>())
            .TryAdd(_ => context.GetService<IHistoryRepository>())
            .TryAdd(_ => context.GetService<IMigrationsAssembly>())
            .TryAdd(_ => context.GetService<IMigrationsModelDiffer>())
            .TryAdd(_ => context.GetService<IMigrator>())
            .TryAdd(_ => context.GetService<IDesignTimeModel>().Model);
        return services;
    }
}",0,439 457 334 2000 123 612 439 457 2001 2002 40 467 2001 2003 44 2004 63 2005 61 424 44 2006 60 2007 62 63 2008 61 424 41 123 2005 633 61 418 2009 40 2010 58 424 41 59 418 2011 40 2003 41 46 2012 40 2003 619 2003 46 2013 60 2014 44 2014 62 40 41 46 2013 60 2015 44 2015 62 40 41 46 2013 60 2016 44 2016 62 40 41 46 2013 60 2017 44 2018 62 40 41 46 2013 60 2019 44 2020 62 40 41 46 2013 60 2021 44 2022 62 40 41 46 2013 60 2023 44 2024 62 40 41 46 2013 60 2025 44 2026 62 40 41 46 2013 60 2027 44 2028 62 40 41 46 2013 60 2029 44 2030 62 40 41 46 2013 40 2005 41 46 2013 60 2031 44 2032 62 40 41 46 2013 60 2033 44 2034 62 40 41 46 2013 60 2035 44 2036 62 40 41 46 2013 60 2037 44 2038 62 40 41 46 2013 60 2039 44 2040 62 40 41 46 2013 60 2041 44 2042 62 40 41 46 2013 60 2043 44 2044 62 40 41 46 2013 60 2045 62 40 418 2046 40 2008 41 41 46 2013 60 2047 44 2048 62 40 41 46 2013 60 2049 44 2050 62 40 41 46 2013 60 2051 44 2052 62 40 41 46 2013 60 2053 44 2053 62 40 41 46 2013 60 2054 44 2054 62 40 41 46 2055 60 2056 44 2057 62 40 41 46 2055 60 2058 44 2058 62 40 41 46 2055 60 2059 44 2060 62 40 41 46 2055 60 2061 44 2062 62 40 41 41 59 490 2063 61 418 2064 40 418 91 93 123 418 2065 40 2005 41 125 44 418 2066 123 2067 61 2068 46 2069 125 41 59 2003 46 2070 60 2071 62 40 2072 619 2063 41 59 450 2003 59 125 612 439 457 2001 2073 40 467 2001 2003 44 2074 2075 41 123 418 2076 40 2003 41 46 2077 40 2075 46 2078 60 2079 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2081 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2082 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2083 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2084 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2085 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2086 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2087 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2088 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2089 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2090 62 40 41 41 46 2077 40 2080 619 2075 46 2078 60 2091 62 40 41 46 2092 41 59 450 2003 59 125 125 
72738,C#,"    private class ChildPN : IComparable<ChildPN>
    {
        public string Name { get; set; }

        // ReSharper disable once MemberHidesStaticFromOuterClass
        public SubChildPN SubChild { get; set; }
        public ICollection<SubChildPN> SubChildCollection { get; set; }

        public int CompareTo(ChildPN other)
            => StringComparer.InvariantCulture.Compare(Name, other.Name);
    }",0,437 334 2000 58 2001 60 2000 62 123 439 461 2002 123 2003 59 2004 59 125 621 439 2005 2006 123 2007 59 2008 59 125 439 2009 60 2005 62 2010 123 2011 59 2012 59 125 439 404 2013 40 2000 2014 41 619 2015 46 2016 46 2017 40 2002 44 2014 46 2002 41 59 125 
72749,C#,"    private class SubChildPN : IComparable<SubChildPN>
    {
        public string Name { get; set; }

        public int CompareTo(SubChildPN other)
            => StringComparer.InvariantCulture.Compare(Name, other.Name);
    }",0,437 334 2000 58 2001 60 2000 62 123 439 461 2002 123 2003 59 2004 59 125 439 404 2005 40 2000 2006 41 619 2007 46 2008 46 2009 40 2002 44 2006 46 2002 41 59 125 
72735,C#,"    private class Book
    {
        public long BookId { get; set; }
        public int Pages { get; set; }
        public Info EnglishInfo { get; set; }

        public static void OnModelCreating(ModelBuilder modelBuilder)
        {
            var e_tb = modelBuilder.Entity<Book>();
            e_tb.Property(e => e.BookId);
            e_tb.Property(e => e.Pages);
            e_tb.HasKey(e => e.BookId);
            e_tb.OwnsOne(e => e.EnglishInfo, rob => Info.OnModelCreating(rob));
        }
    }",0,437 334 2000 123 439 413 2001 123 2002 59 2003 59 125 439 404 2004 123 2005 59 2006 59 125 439 2007 2008 123 2009 59 2010 59 125 439 457 492 2011 40 2012 2013 41 123 490 2014 61 2013 46 2015 60 2000 62 40 41 59 2014 46 2016 40 2017 619 2017 46 2001 41 59 2014 46 2016 40 2017 619 2017 46 2004 41 59 2014 46 2018 40 2017 619 2017 46 2001 41 59 2014 46 2019 40 2017 619 2017 46 2008 44 2020 619 2007 46 2011 40 2020 41 41 59 125 125 
72736,C#,"    private class BooksContext : DbContext
    {
        private readonly string _databaseName;

        public BooksContext(string databaseName)
        {
            _databaseName = databaseName;
        }

        public DbSet<Book> Books { get; set; }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseInMemoryDatabase(_databaseName);

        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
            => Book.OnModelCreating(modelBuilder);
    }",0,437 334 2000 58 2001 123 437 441 461 2002 59 439 2000 40 461 2003 41 123 2002 61 2003 59 125 439 2004 60 2005 62 2006 123 2007 59 2008 59 125 438 406 431 492 2009 40 2010 2011 41 619 2011 46 2012 40 2002 41 59 438 406 431 492 2013 40 2014 2015 41 619 2005 46 2013 40 2015 41 59 125 
72739,C#,"    private class EquatableEntitiesContext : DbContext
    {
        private readonly string _databaseName;

        public EquatableEntitiesContext(string databaseName)
        {
            _databaseName = databaseName;
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseInMemoryDatabase(_databaseName);

        protected internal override void OnModelCreating(ModelBuilder builder)
            => builder.Entity<User>(
                m =>
                {
                    m.HasKey(x => x.UserId);
                    m.OwnsMany(
                        x => x.Roles,
                        b =>
                        {
                            b.Property<Guid>(""RoleAssignmentId"");
                            b.HasKey(""RoleAssignmentId"");
                            b.Property(x => x.Value);
                            b.Property<Guid>(""UserId"");
                            b.WithOwner().HasForeignKey(""UserId"");
                        }).UsePropertyAccessMode(PropertyAccessMode.Field);
                });
    }",0,437 334 2000 58 2001 123 437 441 461 2002 59 439 2000 40 461 2003 41 123 2002 61 2003 59 125 438 406 431 492 2004 40 2005 2006 41 619 2006 46 2007 40 2002 41 59 438 406 431 492 2008 40 2009 2010 41 619 2010 46 2011 60 2012 62 40 2013 619 123 2013 46 2014 40 2015 619 2015 46 2016 41 59 2013 46 2017 40 2015 619 2015 46 2018 44 2019 619 123 2019 46 2020 60 2021 62 40 648 41 59 2019 46 2014 40 648 41 59 2019 46 2020 40 2015 619 2015 46 2022 41 59 2019 46 2020 60 2021 62 40 648 41 59 2019 46 2023 40 41 46 2024 40 648 41 59 125 41 46 2025 40 2026 46 2027 41 59 125 41 59 125 
72743,C#,"    private class OwnedModifiedContext : DbContext
    {
        private readonly string _databaseName;

        public OwnedModifiedContext(string databaseName)
        {
            _databaseName = databaseName;
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseInMemoryDatabase(_databaseName);

        protected internal override void OnModelCreating(ModelBuilder builder)
            => builder.Entity<Product>().OwnsOne(x => x.Details);
    }",0,437 334 2000 58 2001 123 437 441 461 2002 59 439 2000 40 461 2003 41 123 2002 61 2003 59 125 438 406 431 492 2004 40 2005 2006 41 619 2006 46 2007 40 2002 41 59 438 406 431 492 2008 40 2009 2010 41 619 2010 46 2011 60 2012 62 40 41 46 2013 40 2014 619 2014 46 2015 41 59 125 
72747,C#,"    private class StreetContext : DbContext
    {
        private readonly string _databaseName;

        public StreetContext(string databaseName)
        {
            _databaseName = databaseName;
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseInMemoryDatabase(_databaseName);

        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
            => modelBuilder.Entity<Distributor>().OwnsMany(
                rt => rt.ShippingCenters, image =>
                {
                    image.WithOwner().HasForeignKey(""DistributorId"");
                    image.Property<int>(""Id"");
                    image.HasKey(""DistributorId"", ""Id"");
                });
    }",0,437 334 2000 58 2001 123 437 441 461 2002 59 439 2000 40 461 2003 41 123 2002 61 2003 59 125 438 406 431 492 2004 40 2005 2006 41 619 2006 46 2007 40 2002 41 59 438 406 431 492 2008 40 2009 2010 41 619 2010 46 2011 60 2012 62 40 41 46 2013 40 2014 619 2014 46 2015 44 2016 619 123 2016 46 2017 40 41 46 2018 40 648 41 59 2016 46 2019 60 404 62 40 648 41 59 2016 46 2020 40 648 44 648 41 59 125 41 59 125 
72748,C#,"    private class SubChild : IComparable<SubChild>
    {
        // ReSharper disable once UnusedMember.Local
        public string Name { get; set; }

        public Child Parent { get; set; }

        public int CompareTo(SubChild other)
            => StringComparer.InvariantCulture.Compare(Name, other.Name);

        public override bool Equals(object obj)
        {
            Assert.False(true);
            return false;
        }

        public override int GetHashCode()
        {
            Assert.False(true);
            return base.GetHashCode();
        }

        public static bool operator ==(SubChild _, SubChild __)
        {
            Assert.False(true);
            return false;
        }

        public static bool operator !=(SubChild _, SubChild __)
        {
            Assert.False(true);
            return true;
        }
    }",0,437 334 2000 58 2001 60 2000 62 123 621 439 461 2002 123 2003 59 2004 59 125 439 2005 2006 123 2007 59 2008 59 125 439 404 2009 40 2000 2010 41 619 2011 46 2012 46 2013 40 2002 44 2010 46 2002 41 59 439 431 323 2014 40 426 2015 41 123 2016 46 302 40 473 41 59 450 380 59 125 439 431 404 2017 40 41 123 2018 46 302 40 473 41 59 450 320 46 2017 40 41 59 125 439 457 323 427 614 40 2000 2019 44 2000 2020 41 123 2021 46 302 40 473 41 59 450 380 59 125 439 457 323 427 631 40 2000 2019 44 2000 2020 41 123 2022 46 302 40 473 41 59 450 473 59 125 125 
72750,C#,"    private class TestCurrency
    {
        public static readonly TestCurrency EUR = new(49, ""EUR"", 978, ""Euro"");
        public static readonly TestCurrency USD = new(148, ""USD"", 840, ""United States dollar"");

        private TestCurrency()
        {
        }

        public TestCurrency(int id, string code, int numericCode, string name)
        {
            Id = id;
            Name = name;
            Code = code;
            NumericCode = numericCode;
        }

        public int Id { get; }
        public string Name { get; }
        public string Code { get; }
        public int NumericCode { get; }
    }",0,437 334 2000 123 439 457 441 2000 2001 61 418 40 1503 44 648 44 1504 44 648 41 59 439 457 441 2000 2002 61 418 40 1504 44 648 44 1504 44 648 41 59 437 2000 40 41 123 125 439 2000 40 404 2003 44 461 2004 44 404 2005 44 461 2006 41 123 2007 61 2003 59 2008 61 2006 59 2009 61 2004 59 2010 61 2005 59 125 439 404 2011 123 2012 59 125 439 461 2013 123 2014 59 125 439 461 2015 123 2016 59 125 439 404 2017 123 2018 59 125 125 
72752,C#,"    private class TestCurrencyContextRevisited : DbContext
    {
        private readonly string _databaseName;

        public TestCurrencyContextRevisited(string databaseName)
        {
            _databaseName = databaseName;
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseInMemoryDatabase(_databaseName);

        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<TestOrder>().HasKey(o => o.Id);

            modelBuilder.Entity<TestOrderItem>()
                .OwnsOne(
                    oi => oi.Price, ip =>
                    {
                        ip.Property(p => p.Amount).IsRequired();
                        ip.Property(p => p.Currency).HasConversion(
                            v => v.Code,
                            v => v == ""EUR"" ? TestCurrency.EUR : v == ""USD"" ? TestCurrency.USD : null);
                    }).HasKey(oi => oi.Id);
        }
    }",0,437 334 2000 58 2001 123 437 441 461 2002 59 439 2000 40 461 2003 41 123 2002 61 2003 59 125 438 406 431 492 2004 40 2005 2006 41 619 2006 46 2007 40 2002 41 59 438 406 431 492 2008 40 2009 2010 41 123 2010 46 2011 60 2012 62 40 41 46 2013 40 2014 619 2014 46 2015 41 59 2010 46 2011 60 2016 62 40 41 46 2017 40 2018 619 2018 46 2019 44 2020 619 123 2020 46 2021 40 2022 619 2022 46 2023 41 46 2024 40 41 59 2020 46 2021 40 2022 619 2022 46 2025 41 46 2026 40 2027 619 2027 46 2028 44 2027 619 2027 614 648 63 2029 46 2030 58 2027 614 648 63 2029 46 2031 58 424 41 59 125 41 46 2013 40 2018 619 2018 46 2015 41 59 125 125 
71453,C#,"    protected class MyDiscriminator
    {
        public MyDiscriminator(int value)
        {
            Value = value;
        }

        public int Value { get; }

        public override bool Equals(object obj)
            => throw new InvalidOperationException();

        public override int GetHashCode()
            => throw new InvalidOperationException();
    }",0,438 334 2000 123 439 2000 40 404 2001 41 123 2002 61 2001 59 125 439 404 2003 123 2004 59 125 439 431 323 2005 40 426 2006 41 619 469 418 2007 40 41 59 439 431 404 2008 40 41 619 469 418 2007 40 41 59 125 
71683,C#,"        public class KeyValueEntityTracker
        {
            public virtual void TrackEntity(EntityEntry entry)
                => entry.GetInfrastructure()
                    .SetEntityState(DetermineState(entry), true);

            public virtual EntityState DetermineState(EntityEntry entry)
                => entry.IsKeySet ? EntityState.Unchanged : EntityState.Added;
        }",0,439 334 2000 123 439 491 492 2001 40 2002 2003 41 619 2003 46 2004 40 41 46 2005 40 2006 40 2003 41 44 473 41 59 439 491 2007 2006 40 2002 2003 41 619 2003 46 2008 63 2007 46 2009 58 2007 46 2010 59 125 
71688,C#,"    protected class Optional2 : NotifyingEntity
    {
        private int _id;
        private int? _parentId;
        private Optional1 _parent;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public int? ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public Optional1 Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public override bool Equals(object obj)
        {
            var other = obj as Optional2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 404 63 2003 59 437 2004 2005 59 439 404 2006 123 2007 619 2002 59 2008 619 2009 40 2010 44 442 2002 41 59 125 439 404 63 2011 123 2012 619 2003 59 2013 619 2014 40 2015 44 442 2003 41 59 125 439 2004 2016 123 2017 619 2005 59 2018 619 2019 40 2020 44 442 2005 41 59 125 439 431 323 2021 40 426 2022 41 123 490 2023 61 2022 311 2000 59 450 2002 614 2023 634 2006 59 125 439 431 404 2024 40 41 619 2002 59 125 
71691,C#,"    protected class OptionalAk1 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid? _parentId;
        private Root _parent;
        private IEnumerable<OptionalAk2> _children = new ObservableHashSet<OptionalAk2>(LegacyReferenceEqualityComparer.Instance);

        private ICollection<OptionalComposite2> _compositeChildren =
            new ObservableHashSet<OptionalComposite2>(LegacyReferenceEqualityComparer.Instance);

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid? ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public Root Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public IEnumerable<OptionalAk2> Children
        {
            get => _children;
            set => SetWithNotify(value, ref _children);
        }

        public ICollection<OptionalComposite2> CompositeChildren
        {
            get => _compositeChildren;
            set => SetWithNotify(value, ref _compositeChildren);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalAk1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 63 2005 59 437 2006 2007 59 437 2008 60 2009 62 2010 61 418 2011 60 2009 62 40 2012 46 2013 41 59 437 2014 60 2015 62 2016 61 418 2011 60 2015 62 40 2012 46 2013 41 59 439 404 2017 123 2018 619 2002 59 2019 619 2020 40 2021 44 442 2002 41 59 125 439 2003 2022 123 2023 619 2004 59 2024 619 2025 40 2026 44 442 2004 41 59 125 439 2003 63 2027 123 2028 619 2005 59 2029 619 2030 40 2031 44 442 2005 41 59 125 439 2006 2032 123 2033 619 2007 59 2034 619 2035 40 2036 44 442 2007 41 59 125 439 2008 60 2009 62 2037 123 2038 619 2010 59 2039 619 2040 40 2041 44 442 2010 41 59 125 439 2014 60 2015 62 2042 123 2043 619 2016 59 2044 619 2045 40 2046 44 442 2016 41 59 125 439 431 323 2047 40 426 2048 41 123 490 2049 61 2048 311 2000 59 450 2002 614 2049 634 2017 59 125 439 431 404 2050 40 41 619 2002 59 125 
71694,C#,"    protected class OptionalAk2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid? _parentId;
        private OptionalAk1 _parent;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid? ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public OptionalAk1 Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalAk2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 63 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 2003 2013 123 2014 619 2004 59 2015 619 2016 40 2017 44 442 2004 41 59 125 439 2003 63 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71698,C#,"    protected class OptionalOverlapping2 : NotifyingEntity
    {
        private int _id;
        private Guid _parentAlternateId;
        private int? _parentId;
        private RequiredComposite1 _parent;
        private Root _root;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid ParentAlternateId
        {
            get => _parentAlternateId;
            set => SetWithNotify(value, ref _parentAlternateId);
        }

        public int? ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public RequiredComposite1 Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public Root Root
        {
            get => _root;
            set => SetWithNotify(value, ref _root);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalOverlapping2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 404 63 2005 59 437 2006 2007 59 437 2008 2009 59 439 404 2010 123 2011 619 2002 59 2012 619 2013 40 2014 44 442 2002 41 59 125 439 2003 2015 123 2016 619 2004 59 2017 619 2018 40 2019 44 442 2004 41 59 125 439 404 63 2020 123 2021 619 2005 59 2022 619 2023 40 2024 44 442 2005 41 59 125 439 2006 2025 123 2026 619 2007 59 2027 619 2028 40 2029 44 442 2007 41 59 125 439 2008 2008 123 2030 619 2009 59 2031 619 2032 40 2033 44 442 2009 41 59 125 439 431 323 2034 40 426 2035 41 123 490 2036 61 2035 311 2000 59 450 2002 614 2036 634 2010 59 125 439 431 404 2037 40 41 619 2002 59 125 
71704,C#,"    protected class OptionalSingle2MoreDerived : OptionalSingle2Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as OptionalSingle2MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71699,C#,"    protected class OptionalSingle1 : NotifyingEntity
    {
        private int _id;
        private int? _rootId;
        private Root _root;
        private OptionalSingle2 _single;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public int? RootId
        {
            get => _rootId;
            set => SetWithNotify(value, ref _rootId);
        }

        public Root Root
        {
            get => _root;
            set => SetWithNotify(value, ref _root);
        }

        public OptionalSingle2 Single
        {
            get => _single;
            set => SetWithNotify(value, ref _single);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalSingle1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 404 63 2003 59 437 2004 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 404 63 2013 123 2014 619 2003 59 2015 619 2016 40 2017 44 442 2003 41 59 125 439 2004 2004 123 2018 619 2005 59 2019 619 2020 40 2021 44 442 2005 41 59 125 439 2006 2022 123 2023 619 2007 59 2024 619 2025 40 2026 44 442 2007 41 59 125 439 431 323 2027 40 426 2028 41 123 490 2029 61 2028 311 2000 59 450 2002 614 2029 634 2008 59 125 439 431 404 2030 40 41 619 2002 59 125 
71701,C#,"    protected class OptionalSingle1MoreDerived : OptionalSingle1Derived
    {
        private Root _moreDerivedRoot;
        private int? _moreDerivedRootId;

        public int? MoreDerivedRootId
        {
            get => _moreDerivedRootId;
            set => SetWithNotify(value, ref _moreDerivedRootId);
        }

        public Root MoreDerivedRoot
        {
            get => _moreDerivedRoot;
            set => SetWithNotify(value, ref _moreDerivedRoot);
        }

        public override bool Equals(object obj)
            => base.Equals(obj as OptionalSingle1MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 437 2002 2003 59 437 404 63 2004 59 439 404 63 2005 123 2006 619 2004 59 2007 619 2008 40 2009 44 442 2004 41 59 125 439 2002 2010 123 2011 619 2003 59 2012 619 2013 40 2014 44 442 2003 41 59 125 439 431 323 2015 40 426 2016 41 619 320 46 2015 40 2016 311 2000 41 59 439 431 404 2017 40 41 619 320 46 2017 40 41 59 125 
71702,C#,"    protected class OptionalSingle2 : NotifyingEntity
    {
        private int _id;
        private int? _backId;
        private MyDiscriminator _disc;
        private OptionalSingle1 _back;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public int? BackId
        {
            get => _backId;
            set => SetWithNotify(value, ref _backId);
        }

        public MyDiscriminator Disc
        {
            get => _disc;
            set => SetWithNotify(value, ref _disc);
        }

        public OptionalSingle1 Back
        {
            get => _back;
            set => SetWithNotify(value, ref _back);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalSingle2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 404 63 2003 59 437 2004 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 404 63 2013 123 2014 619 2003 59 2015 619 2016 40 2017 44 442 2003 41 59 125 439 2004 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71703,C#,"    protected class OptionalSingle2Derived : OptionalSingle2
    {
        public override bool Equals(object obj)
            => base.Equals(obj as OptionalSingle2Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71705,C#,"    protected class OptionalSingleAk1 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid? _rootId;
        private Root _root;
        private OptionalSingleAk2 _single;
        private OptionalSingleComposite2 _singleComposite;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid? RootId
        {
            get => _rootId;
            set => SetWithNotify(value, ref _rootId);
        }

        public Root Root
        {
            get => _root;
            set => SetWithNotify(value, ref _root);
        }

        public OptionalSingleComposite2 SingleComposite
        {
            get => _singleComposite;
            set => SetWithNotify(value, ref _singleComposite);
        }

        public OptionalSingleAk2 Single
        {
            get => _single;
            set => SetWithNotify(value, ref _single);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalSingleAk1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 63 2005 59 437 2006 2007 59 437 2008 2009 59 437 2010 2011 59 439 404 2012 123 2013 619 2002 59 2014 619 2015 40 2016 44 442 2002 41 59 125 439 2003 2017 123 2018 619 2004 59 2019 619 2020 40 2021 44 442 2004 41 59 125 439 2003 63 2022 123 2023 619 2005 59 2024 619 2025 40 2026 44 442 2005 41 59 125 439 2006 2006 123 2027 619 2007 59 2028 619 2029 40 2030 44 442 2007 41 59 125 439 2010 2031 123 2032 619 2011 59 2033 619 2034 40 2035 44 442 2011 41 59 125 439 2008 2036 123 2037 619 2009 59 2038 619 2039 40 2040 44 442 2009 41 59 125 439 431 323 2041 40 426 2042 41 123 490 2043 61 2042 311 2000 59 450 2002 614 2043 634 2012 59 125 439 431 404 2044 40 41 619 2002 59 125 
71708,C#,"    protected class OptionalSingleAk2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid? _backId;
        private OptionalSingleAk1 _back;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid? BackId
        {
            get => _backId;
            set => SetWithNotify(value, ref _backId);
        }

        public OptionalSingleAk1 Back
        {
            get => _back;
            set => SetWithNotify(value, ref _back);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalSingleAk2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 63 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 2003 2013 123 2014 619 2004 59 2015 619 2016 40 2017 44 442 2004 41 59 125 439 2003 63 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71709,C#,"    protected class OptionalSingleAk2Derived : OptionalSingleAk2
    {
        public override bool Equals(object obj)
            => base.Equals(obj as OptionalSingleAk2Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71716,C#,"    protected class Required2Derived : Required2
    {
        public override bool Equals(object obj)
            => base.Equals(obj as Required2Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71711,C#,"    protected class OptionalSingleComposite2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private int? _backId;
        private OptionalSingleAk1 _back;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid ParentAlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public int? BackId
        {
            get => _backId;
            set => SetWithNotify(value, ref _backId);
        }

        public OptionalSingleAk1 Back
        {
            get => _back;
            set => SetWithNotify(value, ref _back);
        }

        public override bool Equals(object obj)
        {
            var other = obj as OptionalSingleComposite2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 404 63 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 2003 2013 123 2014 619 2004 59 2015 619 2016 40 2017 44 442 2004 41 59 125 439 404 63 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71712,C#,"    protected class Required1 : NotifyingEntity
    {
        private int _id;
        private int _parentId;
        private Root _parent;
        private IEnumerable<Required2> _children = new ObservableHashSet<Required2>(LegacyReferenceEqualityComparer.Instance);

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public int ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public Root Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public IEnumerable<Required2> Children
        {
            get => _children;
            set => SetWithNotify(value, ref _children);
        }

        public override bool Equals(object obj)
        {
            var other = obj as Required1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 404 2003 59 437 2004 2005 59 437 2006 60 2007 62 2008 61 418 2009 60 2007 62 40 2010 46 2011 41 59 439 404 2012 123 2013 619 2002 59 2014 619 2015 40 2016 44 442 2002 41 59 125 439 404 2017 123 2018 619 2003 59 2019 619 2020 40 2021 44 442 2003 41 59 125 439 2004 2022 123 2023 619 2005 59 2024 619 2025 40 2026 44 442 2005 41 59 125 439 2006 60 2007 62 2027 123 2028 619 2008 59 2029 619 2030 40 2031 44 442 2008 41 59 125 439 431 323 2032 40 426 2033 41 123 490 2034 61 2033 311 2000 59 450 2002 614 2034 634 2012 59 125 439 431 404 2035 40 41 619 2002 59 125 
71718,C#,"    protected class RequiredAk1 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid _parentId;
        private Root _parent;
        private IEnumerable<RequiredAk2> _children = new ObservableHashSet<RequiredAk2>(LegacyReferenceEqualityComparer.Instance);

        private IEnumerable<RequiredComposite2> _compositeChildren =
            new ObservableHashSet<RequiredComposite2>(LegacyReferenceEqualityComparer.Instance);

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public Root Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public IEnumerable<RequiredAk2> Children
        {
            get => _children;
            set => SetWithNotify(value, ref _children);
        }

        public IEnumerable<RequiredComposite2> CompositeChildren
        {
            get => _compositeChildren;
            set => SetWithNotify(value, ref _compositeChildren);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredAk1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 2005 59 437 2006 2007 59 437 2008 60 2009 62 2010 61 418 2011 60 2009 62 40 2012 46 2013 41 59 437 2008 60 2014 62 2015 61 418 2011 60 2014 62 40 2012 46 2013 41 59 439 404 2016 123 2017 619 2002 59 2018 619 2019 40 2020 44 442 2002 41 59 125 439 2003 2021 123 2022 619 2004 59 2023 619 2024 40 2025 44 442 2004 41 59 125 439 2003 2026 123 2027 619 2005 59 2028 619 2029 40 2030 44 442 2005 41 59 125 439 2006 2031 123 2032 619 2007 59 2033 619 2034 40 2035 44 442 2007 41 59 125 439 2008 60 2009 62 2036 123 2037 619 2010 59 2038 619 2039 40 2040 44 442 2010 41 59 125 439 2008 60 2014 62 2041 123 2042 619 2015 59 2043 619 2044 40 2045 44 442 2015 41 59 125 439 431 323 2046 40 426 2047 41 123 490 2048 61 2047 311 2000 59 450 2002 614 2048 634 2016 59 125 439 431 404 2049 40 41 619 2002 59 125 
71720,C#,"    protected class RequiredAk1MoreDerived : RequiredAk1Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as RequiredAk1MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71722,C#,"    protected class RequiredAk2Derived : RequiredAk2
    {
        public override bool Equals(object obj)
            => base.Equals(obj as RequiredAk2Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71724,C#,"    protected class RequiredComposite1 : NotifyingEntity
    {
        private int _id;
        private Guid _parentAlternateId;
        private Root _parent;

        private ICollection<OptionalOverlapping2> _compositeChildren =
            new ObservableHashSet<OptionalOverlapping2>(LegacyReferenceEqualityComparer.Instance);

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid ParentAlternateId
        {
            get => _parentAlternateId;
            set => SetWithNotify(value, ref _parentAlternateId);
        }

        public Root Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredComposite1;
            return _id == other?.Id;
        }

        public ICollection<OptionalOverlapping2> CompositeChildren
        {
            get => _compositeChildren;
            set => SetWithNotify(value, ref _compositeChildren);
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2005 2006 59 437 2007 60 2008 62 2009 61 418 2010 60 2008 62 40 2011 46 2012 41 59 439 404 2013 123 2014 619 2002 59 2015 619 2016 40 2017 44 442 2002 41 59 125 439 2003 2018 123 2019 619 2004 59 2020 619 2021 40 2022 44 442 2004 41 59 125 439 2005 2023 123 2024 619 2006 59 2025 619 2026 40 2027 44 442 2006 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2013 59 125 439 2007 60 2008 62 2031 123 2032 619 2009 59 2033 619 2034 40 2035 44 442 2009 41 59 125 439 431 404 2036 40 41 619 2002 59 125 
71725,C#,"    protected class RequiredComposite2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private int _parentId;
        private RequiredAk1 _parent;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid ParentAlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public int ParentId
        {
            get => _parentId;
            set => SetWithNotify(value, ref _parentId);
        }

        public RequiredAk1 Parent
        {
            get => _parent;
            set => SetWithNotify(value, ref _parent);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredComposite2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 404 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 2003 2013 123 2014 619 2004 59 2015 619 2016 40 2017 44 442 2004 41 59 125 439 404 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71733,C#,"    protected class RequiredNonPkSingleAk1Derived : RequiredNonPkSingleAk1
    {
        private Guid _derivedRootId;
        private Root _derivedRoot;

        public Guid DerivedRootId
        {
            get => _derivedRootId;
            set => SetWithNotify(value, ref _derivedRootId);
        }

        public Root DerivedRoot
        {
            get => _derivedRoot;
            set => SetWithNotify(value, ref _derivedRoot);
        }

        public override bool Equals(object obj)
            => base.Equals(obj as RequiredNonPkSingleAk1Derived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 437 2002 2003 59 437 2004 2005 59 439 2002 2006 123 2007 619 2003 59 2008 619 2009 40 2010 44 442 2003 41 59 125 439 2004 2011 123 2012 619 2005 59 2013 619 2014 40 2015 44 442 2005 41 59 125 439 431 323 2016 40 426 2017 41 619 320 46 2016 40 2017 311 2000 41 59 439 431 404 2018 40 41 619 320 46 2018 40 41 59 125 
71728,C#,"    protected class RequiredNonPkSingle1MoreDerived : RequiredNonPkSingle1Derived
    {
        private int _moreDerivedRootId;
        private Root _moreDerivedRoot;

        public int MoreDerivedRootId
        {
            get => _moreDerivedRootId;
            set => SetWithNotify(value, ref _moreDerivedRootId);
        }

        public Root MoreDerivedRoot
        {
            get => _moreDerivedRoot;
            set => SetWithNotify(value, ref _moreDerivedRoot);
        }

        public override bool Equals(object obj)
            => base.Equals(obj as RequiredNonPkSingle1MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 439 404 2005 123 2006 619 2002 59 2007 619 2008 40 2009 44 442 2002 41 59 125 439 2003 2010 123 2011 619 2004 59 2012 619 2013 40 2014 44 442 2004 41 59 125 439 431 323 2015 40 426 2016 41 619 320 46 2015 40 2016 311 2000 41 59 439 431 404 2017 40 41 619 320 46 2017 40 41 59 125 
71729,C#,"    protected class RequiredNonPkSingle2 : NotifyingEntity
    {
        private int _id;
        private int _backId;
        private RequiredNonPkSingle1 _back;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public int BackId
        {
            get => _backId;
            set => SetWithNotify(value, ref _backId);
        }

        public RequiredNonPkSingle1 Back
        {
            get => _back;
            set => SetWithNotify(value, ref _back);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredNonPkSingle2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 404 2003 59 437 2004 2005 59 439 404 2006 123 2007 619 2002 59 2008 619 2009 40 2010 44 442 2002 41 59 125 439 404 2011 123 2012 619 2003 59 2013 619 2014 40 2015 44 442 2003 41 59 125 439 2004 2016 123 2017 619 2005 59 2018 619 2019 40 2020 44 442 2005 41 59 125 439 431 323 2021 40 426 2022 41 123 490 2023 61 2022 311 2000 59 450 2002 614 2023 634 2006 59 125 439 431 404 2024 40 41 619 2002 59 125 
71735,C#,"    protected class RequiredNonPkSingleAk2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid _backId;
        private RequiredNonPkSingleAk1 _back;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid BackId
        {
            get => _backId;
            set => SetWithNotify(value, ref _backId);
        }

        public RequiredNonPkSingleAk1 Back
        {
            get => _back;
            set => SetWithNotify(value, ref _back);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredNonPkSingleAk2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 2003 2013 123 2014 619 2004 59 2015 619 2016 40 2017 44 442 2004 41 59 125 439 2003 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71737,C#,"    protected class RequiredNonPkSingleAk2MoreDerived : RequiredNonPkSingleAk2Derived
    {
        public override bool Equals(object obj)
            => base.Equals(obj as RequiredNonPkSingleAk2MoreDerived);

        public override int GetHashCode()
            => base.GetHashCode();
    }",0,438 334 2000 58 2001 123 439 431 323 2002 40 426 2003 41 619 320 46 2002 40 2003 311 2000 41 59 439 431 404 2004 40 41 619 320 46 2004 40 41 59 125 
71738,C#,"    protected class RequiredSingle1 : NotifyingEntity
    {
        private int _id;
        private bool _bool;
        private Root _root;
        private RequiredSingle2 _single;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public bool Bool
        {
            get => _bool;
            set => SetWithNotify(value, ref _bool);
        }

        public Root Root
        {
            get => _root;
            set => SetWithNotify(value, ref _root);
        }

        public RequiredSingle2 Single
        {
            get => _single;
            set => SetWithNotify(value, ref _single);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredSingle1;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 323 2003 59 437 2004 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 323 2013 123 2014 619 2003 59 2015 619 2016 40 2017 44 442 2003 41 59 125 439 2004 2004 123 2018 619 2005 59 2019 619 2020 40 2021 44 442 2005 41 59 125 439 2006 2022 123 2023 619 2007 59 2024 619 2025 40 2026 44 442 2007 41 59 125 439 431 323 2027 40 426 2028 41 123 490 2029 61 2028 311 2000 59 450 2002 614 2029 634 2008 59 125 439 431 404 2030 40 41 619 2002 59 125 
69308,C#,"    public class InMemoryFixture : GraphUpdatesFixtureBase
    {
        protected override string StoreName { get; } = ""GraphUpdatesTest"";

        protected override ITestStoreFactory TestStoreFactory
            => InMemoryTestStoreFactory.Instance;

        public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder builder)
            => base.AddOptions(builder).ConfigureWarnings(w => w.Log(InMemoryEventId.TransactionIgnoredWarning));
    }",0,439 334 2000 58 2001 123 438 431 461 2002 123 2003 59 125 61 648 59 438 431 2004 2005 619 2006 46 2007 59 439 431 2008 2009 40 2008 2010 41 619 320 46 2009 40 2010 41 46 2011 40 2012 619 2012 46 2013 40 2014 46 2015 41 41 59 125 
70525,C#,"public abstract class ValueGenerator
{
    /// <summary>
    ///     Gets a value to be assigned to a property.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-generation"">EF Core value generation</see> for more information and examples.
    /// </remarks>
    /// <param name=""entry"">The change tracking entry of the entity for which the value is being generated.</param>
    /// <returns>The value to be assigned to a property.</returns>
    public virtual object? Next(EntityEntry entry)
        => NextValue(entry);

    /// <summary>
    ///     Template method to be overridden by implementations to perform value generation.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-generation"">EF Core value generation</see> for more information and examples.
    /// </remarks>
    /// <param name=""entry"">The change tracking entry of the entity for which the value is being generated.</param>
    /// <returns>The generated value.</returns>
    protected abstract object? NextValue(EntityEntry entry);

    /// <summary>
    ///     Gets a value to be assigned to a property.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-generation"">EF Core value generation</see> for more information and examples.
    /// </remarks>
    /// <param name=""entry"">The change tracking entry of the entity for which the value is being generated.</param>
    /// <param name=""cancellationToken"">A <see cref=""CancellationToken"" /> to observe while waiting for the task to complete.</param>
    /// <returns>The value to be assigned to a property.</returns>
    /// <exception cref=""OperationCanceledException"">If the <see cref=""CancellationToken"" /> is canceled.</exception>
    public virtual ValueTask<object?> NextAsync(
        EntityEntry entry,
        CancellationToken cancellationToken = default)
        => NextValueAsync(entry, cancellationToken);

    /// <summary>
    ///     Template method to be overridden by implementations to perform value generation.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-generation"">EF Core value generation</see> for more information and examples.
    /// </remarks>
    /// <param name=""entry"">The change tracking entry of the entity for which the value is being generated.</param>
    /// <param name=""cancellationToken"">A <see cref=""CancellationToken"" /> to observe while waiting for the task to complete.</param>
    /// <returns>The generated value.</returns>
    /// <exception cref=""OperationCanceledException"">If the <see cref=""CancellationToken"" /> is canceled.</exception>
    protected virtual ValueTask<object?> NextValueAsync(
        EntityEntry entry,
        CancellationToken cancellationToken = default)
        => new(NextValue(entry));

    /// <summary>
    ///     Gets a value indicating whether the values generated are temporary (i.e they should be replaced
    ///     by database generated values when the entity is saved) or are permanent (i.e. the generated values
    ///     should be saved to the database).
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         An example of temporary value generation is generating negative numbers for an integer primary key
    ///         that are then replaced by positive numbers generated by the database when the entity is saved. An
    ///         example of permanent value generation are client-generated values for a <see cref=""Guid"" /> primary
    ///         key which are saved to the database.
    ///     </para>
    ///     <para>
    ///         See <see href=""https://aka.ms/efcore-docs-value-generation"">EF Core value generation</see> for more information and examples.
    ///     </para>
    /// </remarks>
    public abstract bool GeneratesTemporaryValues { get; }

    /// <summary>
    ///     Gets a value indicating whether the values generated are stable. That is, the value will always be the
    ///     same for a given property in a given entity, and does not depend on what other values may have been generated
    ///     previously. For example, discriminator values generated for a TPH hierarchy are stable. Stable values will never
    ///     be marked as unknown.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-generation"">EF Core value generation</see> for more information and examples.
    /// </remarks>
    public virtual bool GeneratesStableValues
        => false;
}",0,439 305 334 2000 123 612 439 491 426 63 2001 40 2002 2003 41 619 2004 40 2003 41 59 612 438 305 426 63 2004 40 2002 2003 41 59 612 439 491 2005 60 426 63 62 2006 40 2002 2003 44 2007 2008 61 349 41 619 2009 40 2003 44 2008 41 59 612 438 491 2005 60 426 63 62 2009 40 2002 2003 44 2007 2008 61 349 41 619 418 40 2004 40 2003 41 41 59 612 439 305 323 2010 123 2011 59 125 612 439 491 323 2012 619 380 59 125 
71741,C#,"    protected class RequiredSingleAk2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private Guid _backId;
        private RequiredSingleAk1 _back;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid AlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public Guid BackId
        {
            get => _backId;
            set => SetWithNotify(value, ref _backId);
        }

        public RequiredSingleAk1 Back
        {
            get => _back;
            set => SetWithNotify(value, ref _back);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredSingleAk2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 2003 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 2003 2013 123 2014 619 2004 59 2015 619 2016 40 2017 44 442 2004 41 59 125 439 2003 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71742,C#,"    protected class RequiredSingleComposite2 : NotifyingEntity
    {
        private int _id;
        private Guid _alternateId;
        private int _backId;
        private RequiredSingleAk1 _back;

        public int Id
        {
            get => _id;
            set => SetWithNotify(value, ref _id);
        }

        public Guid BackAlternateId
        {
            get => _alternateId;
            set => SetWithNotify(value, ref _alternateId);
        }

        public int BackId
        {
            get => _backId;
            set => SetWithNotify(value, ref _backId);
        }

        public RequiredSingleAk1 Back
        {
            get => _back;
            set => SetWithNotify(value, ref _back);
        }

        public override bool Equals(object obj)
        {
            var other = obj as RequiredSingleComposite2;
            return _id == other?.Id;
        }

        public override int GetHashCode()
            => _id;
    }",0,438 334 2000 58 2001 123 437 404 2002 59 437 2003 2004 59 437 404 2005 59 437 2006 2007 59 439 404 2008 123 2009 619 2002 59 2010 619 2011 40 2012 44 442 2002 41 59 125 439 2003 2013 123 2014 619 2004 59 2015 619 2016 40 2017 44 442 2004 41 59 125 439 404 2018 123 2019 619 2005 59 2020 619 2021 40 2022 44 442 2005 41 59 125 439 2006 2023 123 2024 619 2007 59 2025 619 2026 40 2027 44 442 2007 41 59 125 439 431 323 2028 40 426 2029 41 123 490 2030 61 2029 311 2000 59 450 2002 614 2030 634 2008 59 125 439 431 404 2031 40 41 619 2002 59 125 
71577,C#,"public class DiscriminatorValueGenerator : ValueGenerator
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override object NextValue(EntityEntry entry)
        => entry.GetInfrastructure().EntityType.GetDiscriminatorValue()!;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override bool GeneratesTemporaryValues
        => false;

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override bool GeneratesStableValues
        => true;
}",0,439 334 2000 58 2001 123 612 438 431 426 2002 40 2003 2004 41 619 2004 46 2005 40 41 46 2006 46 2007 40 41 33 59 612 439 431 323 2008 619 380 59 612 439 431 323 2009 619 473 59 125 
69311,C#,"    private class NonGenericStringTestEntityTypeBuilder<TEntity> : NonGenericTestEntityTypeBuilder<TEntity>
        where TEntity : class
    {
        public NonGenericStringTestEntityTypeBuilder(EntityTypeBuilder entityTypeBuilder)
            : base(entityTypeBuilder)
        {
        }

        protected override NonGenericTestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder entityTypeBuilder)
            => new NonGenericStringTestEntityTypeBuilder<TEntity>(entityTypeBuilder);

        public override TestOwnedNavigationBuilder<TEntity, TRelatedEntity> OwnsOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>> navigationExpression)
            where TRelatedEntity : class
            => new NonGenericStringTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.OwnsOne(
                    typeof(TRelatedEntity).Name, navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestEntityTypeBuilder<TEntity> OwnsOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TEntity, TRelatedEntity>> buildAction)
            where TRelatedEntity : class
            => Wrap(
                EntityTypeBuilder.OwnsOne(
                    typeof(TRelatedEntity).Name,
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(new NonGenericStringTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));

        public override TestOwnedNavigationBuilder<TEntity, TRelatedEntity> OwnsMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>> navigationExpression)
            => new NonGenericTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.OwnsMany(
                    typeof(TRelatedEntity).Name,
                    navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestEntityTypeBuilder<TEntity> OwnsMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TEntity, TRelatedEntity>> buildAction)
            => Wrap(
                EntityTypeBuilder.OwnsMany(
                    typeof(TRelatedEntity).Name,
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(new NonGenericTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));

        public override TestReferenceNavigationBuilder<TEntity, TRelatedEntity> HasOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>>? navigationExpression = null)
            where TRelatedEntity : class
        {
            var navigationName = navigationExpression?.GetMemberAccess().GetSimpleMemberName();

            return new NonGenericStringTestReferenceNavigationBuilder<TEntity, TRelatedEntity>(
                navigationName == null
                    ? EntityTypeBuilder.HasOne(typeof(TRelatedEntity).FullName!, navigationName)
                    : EntityTypeBuilder.HasOne(navigationName));
        }

        public override TestCollectionNavigationBuilder<TEntity, TRelatedEntity> HasMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>>? navigationExpression = null)
            where TRelatedEntity : class
        {
            var navigationName = navigationExpression?.GetMemberAccess().GetSimpleMemberName();

            return new NonGenericTestCollectionNavigationBuilder<TEntity, TRelatedEntity>(
                navigationName == null
                    ? EntityTypeBuilder.HasMany(typeof(TRelatedEntity).FullName!, navigationName)
                    : EntityTypeBuilder.HasMany(navigationName));
        }
    }",0,437 334 2000 60 2001 62 58 2002 60 2001 62 2003 2001 58 334 123 439 2000 40 2004 2005 41 58 320 40 2005 41 123 125 438 431 2002 60 2001 62 2006 40 2004 2005 41 619 418 2000 60 2001 62 40 2005 41 59 439 431 2007 60 2001 44 2008 62 2009 60 2008 62 40 2010 60 2011 60 2001 44 2008 63 640 2012 41 2003 2008 58 334 619 418 2013 60 2001 44 2008 62 40 2004 46 2009 40 478 40 2008 41 46 2014 44 2012 46 2015 40 41 46 2016 40 41 41 41 59 439 431 2017 60 2001 62 2009 60 2008 62 40 2010 60 2011 60 2001 44 2008 63 640 2012 44 2018 60 2007 60 2001 44 2008 640 2019 41 2003 2008 58 334 619 2006 40 2004 46 2009 40 478 40 2008 41 46 2014 44 2012 46 2015 40 41 46 2016 40 41 44 2020 619 2019 40 418 2013 60 2001 44 2008 62 40 2020 41 41 41 41 59 439 431 2007 60 2001 44 2008 62 2021 60 2008 62 40 2010 60 2011 60 2001 44 2022 60 2008 62 63 640 2012 41 619 418 2023 60 2001 44 2008 62 40 2004 46 2021 40 478 40 2008 41 46 2014 44 2012 46 2015 40 41 46 2016 40 41 41 41 59 439 431 2017 60 2001 62 2021 60 2008 62 40 2010 60 2011 60 2001 44 2022 60 2008 62 63 640 2012 44 2018 60 2007 60 2001 44 2008 640 2019 41 619 2006 40 2004 46 2021 40 478 40 2008 41 46 2014 44 2012 46 2015 40 41 46 2016 40 41 44 2020 619 2019 40 418 2023 60 2001 44 2008 62 40 2020 41 41 41 41 59 439 431 2024 60 2001 44 2008 62 2025 60 2008 62 40 2010 60 2011 60 2001 44 2008 63 640 63 2012 61 424 41 2003 2008 58 334 123 490 2026 61 2012 634 2015 40 41 46 2016 40 41 59 450 418 2027 60 2001 44 2008 62 40 2026 614 424 63 2004 46 2025 40 478 40 2008 41 46 2028 33 44 2026 41 58 2004 46 2025 40 2026 41 41 59 125 439 431 2029 60 2001 44 2008 62 2030 60 2008 62 40 2010 60 2011 60 2001 44 2022 60 2008 62 63 640 63 2012 61 424 41 2003 2008 58 334 123 490 2031 61 2012 634 2015 40 41 46 2016 40 41 59 450 418 2032 60 2001 44 2008 62 40 2031 614 424 63 2004 46 2030 40 478 40 2008 41 46 2033 33 44 2031 41 58 2004 46 2030 40 2031 41 41 59 125 125 
69312,C#,"    private class NonGenericStringTestModelBuilder : TestModelBuilder
    {
        public NonGenericStringTestModelBuilder(TestHelpers testHelpers, Action<ModelConfigurationBuilder>? configure)
            : base(testHelpers, configure)
        {
        }

        public override TestEntityTypeBuilder<TEntity> Entity<TEntity>()
            => new NonGenericStringTestEntityTypeBuilder<TEntity>(ModelBuilder.Entity(typeof(TEntity)));

        public override TestEntityTypeBuilder<TEntity> SharedTypeEntity<TEntity>(string name)
            => new NonGenericStringTestEntityTypeBuilder<TEntity>(ModelBuilder.SharedTypeEntity(name, typeof(TEntity)));

        public override TestModelBuilder Entity<TEntity>(Action<TestEntityTypeBuilder<TEntity>> buildAction)
        {
            ModelBuilder.Entity(
                typeof(TEntity), entityTypeBuilder =>
                    buildAction(new NonGenericStringTestEntityTypeBuilder<TEntity>(entityTypeBuilder)));
            return this;
        }

        public override TestModelBuilder SharedTypeEntity<TEntity>(string name, Action<TestEntityTypeBuilder<TEntity>> buildAction)
        {
            ModelBuilder.SharedTypeEntity(
                name,
                typeof(TEntity), entityTypeBuilder =>
                    buildAction(new NonGenericStringTestEntityTypeBuilder<TEntity>(entityTypeBuilder)));
            return this;
        }

        public override TestOwnedEntityTypeBuilder<TEntity> Owned<TEntity>()
            => new NonGenericTestOwnedEntityTypeBuilder<TEntity>(ModelBuilder.Owned(typeof(TEntity)));

        public override TestModelBuilder Ignore<TEntity>()
        {
            ModelBuilder.Ignore(typeof(TEntity));
            return this;
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 60 2005 62 63 2006 41 58 320 40 2003 44 2006 41 123 125 439 431 2007 60 2008 62 2009 60 2008 62 40 41 619 418 2010 60 2008 62 40 2011 46 2009 40 478 40 2008 41 41 41 59 439 431 2007 60 2008 62 2012 60 2008 62 40 461 2013 41 619 418 2010 60 2008 62 40 2011 46 2012 40 2013 44 478 40 2008 41 41 41 59 439 431 2001 2009 60 2008 62 40 2004 60 2007 60 2008 640 2014 41 123 2011 46 2009 40 478 40 2008 41 44 2015 619 2014 40 418 2010 60 2008 62 40 2015 41 41 41 59 450 467 59 125 439 431 2001 2012 60 2008 62 40 461 2013 44 2004 60 2007 60 2008 640 2014 41 123 2011 46 2012 40 2013 44 478 40 2008 41 44 2016 619 2014 40 418 2010 60 2008 62 40 2016 41 41 41 59 450 467 59 125 439 431 2017 60 2008 62 2018 60 2008 62 40 41 619 418 2019 60 2008 62 40 2011 46 2018 40 478 40 2008 41 41 41 59 439 431 2001 2020 60 2008 62 40 41 123 2011 46 2020 40 478 40 2008 41 41 59 450 467 59 125 125 
69314,C#,"    private class NonGenericStringTestReferenceNavigationBuilder<TEntity, TRelatedEntity> : NonGenericTestReferenceNavigationBuilder<
        TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public NonGenericStringTestReferenceNavigationBuilder(ReferenceNavigationBuilder referenceNavigationBuilder)
            : base(referenceNavigationBuilder)
        {
        }

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> WithOne(
            Expression<Func<TRelatedEntity, TEntity?>>? navigationExpression = null)
            => new NonGenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity>(
                ReferenceNavigationBuilder.WithOne(
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 2006 41 58 320 40 2006 41 123 125 439 431 2007 60 2001 44 2002 62 2008 40 2009 60 2010 60 2002 44 2001 63 640 63 2011 61 424 41 619 418 2012 60 2001 44 2002 62 40 2005 46 2008 40 2011 634 2013 40 41 46 2014 40 41 41 41 59 125 
72005,C#,"    public class NonGenericStringManyToOneType : ManyToOneTestBase
    {
        protected override TestModelBuilder CreateTestModelBuilder(
            TestHelpers testHelpers,
            Action<ModelConfigurationBuilder>? configure)
            => new NonGenericStringTestModelBuilder(testHelpers, configure);
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 40 2004 2005 44 2006 60 2007 62 63 2008 41 619 418 2009 40 2005 44 2008 41 59 125 
72006,C#,"    public class NonGenericStringOneToManyType : OneToManyTestBase
    {
        protected override TestModelBuilder CreateTestModelBuilder(
            TestHelpers testHelpers,
            Action<ModelConfigurationBuilder>? configure)
            => new NonGenericStringTestModelBuilder(testHelpers, configure);

        public override void WithMany_pointing_to_keyless_entity_throws()
            // Test throws exception before reaching the first exception due to entity type being property bag entity
            => Assert.Equal(
                CoreStrings.NavigationSingleWrongClrType(
                    ""Reference"", ""KeylessCollectionNavigation"", ""KeylessReferenceNavigation"", ""Dictionary<string, object>""),
                Assert.Throws<EqualException>(
                    () => base.WithMany_pointing_to_keyless_entity_throws()).Actual);
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 40 2004 2005 44 2006 60 2007 62 63 2008 41 619 418 2009 40 2005 44 2008 41 59 439 431 492 2010 40 41 621 619 2011 46 2012 40 2013 46 2014 40 648 44 648 44 648 44 648 41 44 2011 46 2015 60 2016 62 40 40 41 619 320 46 2010 40 41 41 46 2017 41 59 125 
72008,C#,"    public class NonGenericStringOwnedTypes : OwnedTypesTestBase
    {
        protected override TestModelBuilder CreateTestModelBuilder(
            TestHelpers testHelpers,
            Action<ModelConfigurationBuilder>? configure)
            => new NonGenericStringTestModelBuilder(testHelpers, configure);

        public override void OwnedType_can_derive_from_Collection()
            // Shadow navigations. Issue #3864.
            => Assert.Equal(
                CoreStrings.AmbiguousSharedTypeEntityTypeName(
                    ""Microsoft.EntityFrameworkCore.ModelBuilding.ModelBuilderTest+DependentEntity""),
                Assert.Throws<InvalidOperationException>(
                    () => base.OwnedType_can_derive_from_Collection()).Message);
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 40 2004 2005 44 2006 60 2007 62 63 2008 41 619 418 2009 40 2005 44 2008 41 59 439 431 492 2010 40 41 621 619 2011 46 2012 40 2013 46 2014 40 648 41 44 2011 46 2015 60 2016 62 40 40 41 619 320 46 2010 40 41 41 46 2017 41 59 125 
72013,C#,"    private class NonGenericStringTestReferenceNavigationBuilder<TEntity, TRelatedEntity>
        : NonGenericTestReferenceNavigationBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public NonGenericStringTestReferenceNavigationBuilder(ReferenceNavigationBuilder referenceNavigationBuilder)
            : base(referenceNavigationBuilder)
        {
        }

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> WithOne(
            Expression<Func<TRelatedEntity, TEntity?>>? navigationExpression = null)
            => new NonGenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity>(
                ReferenceNavigationBuilder.WithOne(
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 2006 41 58 320 40 2006 41 123 125 439 431 2007 60 2001 44 2002 62 2008 40 2009 60 2010 60 2002 44 2001 63 640 63 2011 61 424 41 619 418 2012 60 2001 44 2002 62 40 2005 46 2008 40 2011 634 2013 40 41 46 2014 40 41 41 41 59 125 
72014,C#,"    private class NonGenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity>
        : NonGenericTestReferenceReferenceBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public NonGenericStringTestReferenceReferenceBuilder(ReferenceReferenceBuilder referenceReferenceBuilder)
            : base(referenceReferenceBuilder)
        {
        }

        protected override NonGenericTestReferenceReferenceBuilder<TEntity, TRelatedEntity> Wrap(
            ReferenceReferenceBuilder referenceReferenceBuilder)
            => new NonGenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity>(referenceReferenceBuilder);

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
            Expression<Func<TDependentEntity, object?>> foreignKeyExpression)
            => Wrap(
                ReferenceReferenceBuilder.HasForeignKey(
                    typeof(TDependentEntity).FullName!,
                    foreignKeyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
            Expression<Func<TPrincipalEntity, object?>> keyExpression)
            => Wrap(
                ReferenceReferenceBuilder.HasPrincipalKey(
                    typeof(TPrincipalEntity).FullName!,
                    keyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
            params string[] foreignKeyPropertyNames)
            => Wrap(ReferenceReferenceBuilder.HasForeignKey(typeof(TDependentEntity).FullName!, foreignKeyPropertyNames));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
            params string[] keyPropertyNames)
            => Wrap(ReferenceReferenceBuilder.HasPrincipalKey(typeof(TPrincipalEntity).FullName!, keyPropertyNames));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2001 44 2002 62 2007 40 2005 2006 41 619 418 2000 60 2001 44 2002 62 40 2006 41 59 439 431 2008 60 2001 44 2002 62 2009 60 2010 62 40 2011 60 2012 60 2010 44 426 63 640 2013 41 619 2007 40 2005 46 2009 40 478 40 2010 41 46 2014 33 44 2013 46 2015 40 41 46 2016 40 2017 619 2017 46 2018 40 41 41 46 2019 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2020 60 2021 62 40 2011 60 2012 60 2021 44 426 63 640 2022 41 619 2007 40 2005 46 2020 40 478 40 2021 41 46 2014 33 44 2022 46 2015 40 41 46 2016 40 2017 619 2017 46 2018 40 41 41 46 2019 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2009 60 2010 62 40 433 461 91 93 2023 41 619 2007 40 2005 46 2009 40 478 40 2010 41 46 2014 33 44 2023 41 41 59 439 431 2008 60 2001 44 2002 62 2020 60 2021 62 40 433 461 91 93 2024 41 619 2007 40 2005 46 2020 40 478 40 2021 41 46 2014 33 44 2024 41 41 59 125 
69385,C#,"    public class GenericOwnedTypesString : OwnedTypesTestBase
    {
        protected override TestModelBuilder CreateTestModelBuilder(
            TestHelpers testHelpers,
            Action<ModelConfigurationBuilder>? configure)
            => new GenericStringTestModelBuilder(testHelpers, configure);
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 40 2004 2005 44 2006 60 2007 62 63 2008 41 619 418 2009 40 2005 44 2008 41 59 125 
69386,C#,"    private class GenericStringTestCollectionCollectionBuilder<TLeftEntity, TRightEntity> :
        GenericTestCollectionCollectionBuilder<TLeftEntity, TRightEntity>
        where TLeftEntity : class
        where TRightEntity : class
    {
        public GenericStringTestCollectionCollectionBuilder(
            CollectionCollectionBuilder<TLeftEntity, TRightEntity> collectionCollectionBuilder)
            : base(collectionCollectionBuilder)
        {
        }
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 125 
72438,C#,"    protected class GenericTypeTestCollectionCollectionBuilder<TLeftEntity, TRightEntity> :
        GenericTestCollectionCollectionBuilder<TLeftEntity, TRightEntity>
        where TLeftEntity : class
        where TRightEntity : class
    {
        public GenericTypeTestCollectionCollectionBuilder(
            CollectionCollectionBuilder<TLeftEntity, TRightEntity> collectionCollectionBuilder)
            : base(collectionCollectionBuilder)
        {
        }

        public override TestEntityTypeBuilder<TJoinEntity> UsingEntity<TJoinEntity>()
            => new GenericTypeTestEntityTypeBuilder<TJoinEntity>(
                new EntityTypeBuilder<TJoinEntity>(
                    CollectionCollectionBuilder.UsingEntity(
                        typeof(TJoinEntity)).Metadata));

        public override TestEntityTypeBuilder<TJoinEntity> UsingEntity<TJoinEntity>(
            string joinEntityName)
            => new GenericTypeTestEntityTypeBuilder<TJoinEntity>(
                new EntityTypeBuilder<TJoinEntity>(
                    CollectionCollectionBuilder.UsingEntity(
                        joinEntityName,
                        typeof(TJoinEntity)).Metadata));

        public override TestEntityTypeBuilder<TRightEntity> UsingEntity<TJoinEntity>(
            Action<TestEntityTypeBuilder<TJoinEntity>> configureJoinEntityType)
            => new GenericTypeTestEntityTypeBuilder<TRightEntity>(
                CollectionCollectionBuilder.UsingEntity<TJoinEntity>(
                    e => configureJoinEntityType(new GenericTypeTestEntityTypeBuilder<TJoinEntity>(e))));

        public override TestEntityTypeBuilder<TRightEntity> UsingEntity<TJoinEntity>(
            string joinEntityName,
            Action<TestEntityTypeBuilder<TJoinEntity>> configureJoinEntityType)
            => new GenericTypeTestEntityTypeBuilder<TRightEntity>(
                CollectionCollectionBuilder.UsingEntity(
                    joinEntityName,
                    typeof(TJoinEntity),
                    e => configureJoinEntityType(
                        new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(e.Metadata)))));

        public override TestEntityTypeBuilder<TJoinEntity> UsingEntity<TJoinEntity>(
            Func<TestEntityTypeBuilder<TJoinEntity>,
                TestReferenceCollectionBuilder<TLeftEntity, TJoinEntity>> configureRight,
            Func<TestEntityTypeBuilder<TJoinEntity>,
                TestReferenceCollectionBuilder<TRightEntity, TJoinEntity>> configureLeft)
            => new GenericTypeTestEntityTypeBuilder<TJoinEntity>(
                new EntityTypeBuilder<TJoinEntity>(
                    CollectionCollectionBuilder.UsingEntity(
                        typeof(TJoinEntity),
                        l => ((GenericTestReferenceCollectionBuilder<TLeftEntity, TJoinEntity>)configureRight(
                                new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(l.Metadata))))
                            .ReferenceCollectionBuilder,
                        r => ((GenericTestReferenceCollectionBuilder<TRightEntity, TJoinEntity>)configureLeft(
                                new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(r.Metadata))))
                            .ReferenceCollectionBuilder).Metadata));

        public override TestEntityTypeBuilder<TJoinEntity> UsingEntity<TJoinEntity>(
            string joinEntityName,
            Func<TestEntityTypeBuilder<TJoinEntity>,
                TestReferenceCollectionBuilder<TLeftEntity, TJoinEntity>> configureRight,
            Func<TestEntityTypeBuilder<TJoinEntity>,
                TestReferenceCollectionBuilder<TRightEntity, TJoinEntity>> configureLeft)
            => new GenericTypeTestEntityTypeBuilder<TJoinEntity>(
                new EntityTypeBuilder<TJoinEntity>(
                    CollectionCollectionBuilder.UsingEntity(
                        joinEntityName,
                        typeof(TJoinEntity),
                        l => ((GenericTestReferenceCollectionBuilder<TLeftEntity, TJoinEntity>)configureRight(
                                new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(l.Metadata))))
                            .ReferenceCollectionBuilder,
                        r => ((GenericTestReferenceCollectionBuilder<TRightEntity, TJoinEntity>)configureLeft(
                                new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(r.Metadata))))
                            .ReferenceCollectionBuilder).Metadata));

        public override TestEntityTypeBuilder<TRightEntity> UsingEntity<TJoinEntity>(
            Func<TestEntityTypeBuilder<TJoinEntity>,
                TestReferenceCollectionBuilder<TLeftEntity, TJoinEntity>> configureRight,
            Func<TestEntityTypeBuilder<TJoinEntity>,
                TestReferenceCollectionBuilder<TRightEntity, TJoinEntity>> configureLeft,
            Action<TestEntityTypeBuilder<TJoinEntity>> configureJoinEntityType)
            where TJoinEntity : class
            => new GenericTypeTestEntityTypeBuilder<TRightEntity>(
                CollectionCollectionBuilder.UsingEntity(
                    typeof(TJoinEntity),
                    l => ((GenericTestReferenceCollectionBuilder<TLeftEntity, TJoinEntity>)configureRight(
                            new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(l.Metadata))))
                        .ReferenceCollectionBuilder,
                    r => ((GenericTestReferenceCollectionBuilder<TRightEntity, TJoinEntity>)configureLeft(
                            new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(r.Metadata))))
                        .ReferenceCollectionBuilder,
                    e => configureJoinEntityType(
                        new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(e.Metadata)))));

        public override TestEntityTypeBuilder<TRightEntity> UsingEntity<TJoinEntity>(
            string joinEntityName,
            Func<TestEntityTypeBuilder<TJoinEntity>,
                TestReferenceCollectionBuilder<TLeftEntity, TJoinEntity>> configureRight,
            Func<TestEntityTypeBuilder<TJoinEntity>,
                TestReferenceCollectionBuilder<TRightEntity, TJoinEntity>> configureLeft,
            Action<TestEntityTypeBuilder<TJoinEntity>> configureJoinEntityType)
            where TJoinEntity : class
            => new GenericTypeTestEntityTypeBuilder<TRightEntity>(
                CollectionCollectionBuilder.UsingEntity(
                    joinEntityName,
                    typeof(TJoinEntity),
                    l => ((GenericTestReferenceCollectionBuilder<TLeftEntity, TJoinEntity>)configureRight(
                            new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(l.Metadata))))
                        .ReferenceCollectionBuilder,
                    r => ((GenericTestReferenceCollectionBuilder<TRightEntity, TJoinEntity>)configureLeft(
                            new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(r.Metadata))))
                        .ReferenceCollectionBuilder,
                    e => configureJoinEntityType(
                        new GenericTypeTestEntityTypeBuilder<TJoinEntity>(new EntityTypeBuilder<TJoinEntity>(e.Metadata)))));
    }",0,438 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 439 431 2007 60 2008 62 2009 60 2008 62 40 41 619 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2005 46 2009 40 478 40 2008 41 41 46 2012 41 41 59 439 431 2007 60 2008 62 2009 60 2008 62 40 461 2013 41 619 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2005 46 2009 40 2013 44 478 40 2008 41 41 46 2012 41 41 59 439 431 2007 60 2002 62 2009 60 2008 62 40 2014 60 2007 60 2008 640 2015 41 619 418 2010 60 2002 62 40 2005 46 2009 60 2008 62 40 2016 619 2015 40 418 2010 60 2008 62 40 2016 41 41 41 41 59 439 431 2007 60 2002 62 2009 60 2008 62 40 461 2013 44 2014 60 2007 60 2008 640 2015 41 619 418 2010 60 2002 62 40 2005 46 2009 40 2013 44 478 40 2008 41 44 2016 619 2015 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2016 46 2012 41 41 41 41 41 59 439 431 2007 60 2008 62 2009 60 2008 62 40 2017 60 2007 60 2008 62 44 2018 60 2001 44 2008 640 2019 44 2017 60 2007 60 2008 62 44 2018 60 2002 44 2008 640 2020 41 619 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2005 46 2009 40 478 40 2008 41 44 2021 619 40 40 2022 60 2001 44 2008 62 41 2019 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2021 46 2012 41 41 41 41 46 2023 44 2024 619 40 40 2022 60 2002 44 2008 62 41 2020 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2024 46 2012 41 41 41 41 46 2023 41 46 2012 41 41 59 439 431 2007 60 2008 62 2009 60 2008 62 40 461 2013 44 2017 60 2007 60 2008 62 44 2018 60 2001 44 2008 640 2019 44 2017 60 2007 60 2008 62 44 2018 60 2002 44 2008 640 2020 41 619 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2005 46 2009 40 2013 44 478 40 2008 41 44 2021 619 40 40 2022 60 2001 44 2008 62 41 2019 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2021 46 2012 41 41 41 41 46 2023 44 2024 619 40 40 2022 60 2002 44 2008 62 41 2020 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2024 46 2012 41 41 41 41 46 2023 41 46 2012 41 41 59 439 431 2007 60 2002 62 2009 60 2008 62 40 2017 60 2007 60 2008 62 44 2018 60 2001 44 2008 640 2019 44 2017 60 2007 60 2008 62 44 2018 60 2002 44 2008 640 2020 44 2014 60 2007 60 2008 640 2015 41 2004 2008 58 334 619 418 2010 60 2002 62 40 2005 46 2009 40 478 40 2008 41 44 2021 619 40 40 2022 60 2001 44 2008 62 41 2019 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2021 46 2012 41 41 41 41 46 2023 44 2024 619 40 40 2022 60 2002 44 2008 62 41 2020 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2024 46 2012 41 41 41 41 46 2023 44 2016 619 2015 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2016 46 2012 41 41 41 41 41 59 439 431 2007 60 2002 62 2009 60 2008 62 40 461 2013 44 2017 60 2007 60 2008 62 44 2018 60 2001 44 2008 640 2019 44 2017 60 2007 60 2008 62 44 2018 60 2002 44 2008 640 2020 44 2014 60 2007 60 2008 640 2015 41 2004 2008 58 334 619 418 2010 60 2002 62 40 2005 46 2009 40 2013 44 478 40 2008 41 44 2021 619 40 40 2022 60 2001 44 2008 62 41 2019 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2021 46 2012 41 41 41 41 46 2023 44 2024 619 40 40 2022 60 2002 44 2008 62 41 2020 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2024 46 2012 41 41 41 41 46 2023 44 2016 619 2015 40 418 2010 60 2008 62 40 418 2011 60 2008 62 40 2016 46 2012 41 41 41 41 41 59 125 
72439,C#,"    protected class GenericTypeTestCollectionNavigationBuilder<TEntity, TRelatedEntity> :
        GenericTestCollectionNavigationBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public GenericTypeTestCollectionNavigationBuilder(
            CollectionNavigationBuilder<TEntity, TRelatedEntity> collectionNavigationBuilder)
            : base(collectionNavigationBuilder)
        {
        }

        public override TestCollectionCollectionBuilder<TRelatedEntity, TEntity> WithMany(
            Expression<Func<TRelatedEntity, IEnumerable<TEntity>?>> navigationExpression)
            => new GenericTypeTestCollectionCollectionBuilder<TRelatedEntity, TEntity>(
                CollectionNavigationBuilder.WithMany(navigationExpression));
    }",0,438 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 439 431 2007 60 2002 44 2001 62 2008 40 2009 60 2010 60 2002 44 2011 60 2001 62 63 640 2012 41 619 418 2013 60 2002 44 2001 62 40 2005 46 2008 40 2012 41 41 59 125 
72440,C#,"    private class GenericTypeTestEntityTypeBuilder<TEntity> : GenericTestEntityTypeBuilder<TEntity>
        where TEntity : class
    {
        public GenericTypeTestEntityTypeBuilder(EntityTypeBuilder<TEntity> entityTypeBuilder)
            : base(entityTypeBuilder)
        {
        }

        protected override TestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder<TEntity> entityTypeBuilder)
            => new GenericTypeTestEntityTypeBuilder<TEntity>(entityTypeBuilder);

        public override TestOwnedNavigationBuilder<TEntity, TRelatedEntity> OwnsOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>> navigationExpression)
            where TRelatedEntity : class
            => new GenericTypeTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(EntityTypeBuilder.OwnsOne(navigationExpression));

        public override TestEntityTypeBuilder<TEntity> OwnsOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TEntity, TRelatedEntity>> buildAction)
            where TRelatedEntity : class
            => Wrap(
                EntityTypeBuilder.OwnsOne(
                    navigationExpression,
                    r => buildAction(new GenericTypeTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));

        public override TestReferenceNavigationBuilder<TEntity, TRelatedEntity> HasOne<TRelatedEntity>(
            Expression<Func<TEntity, TRelatedEntity?>>? navigationExpression = null)
            where TRelatedEntity : class
            => new GenericTypeTestReferenceNavigationBuilder<TEntity, TRelatedEntity>(
                EntityTypeBuilder.HasOne(navigationExpression));

        public override TestCollectionNavigationBuilder<TEntity, TRelatedEntity> HasMany<TRelatedEntity>(
            Expression<Func<TEntity, IEnumerable<TRelatedEntity>?>>? navigationExpression = null)
            where TRelatedEntity : class
            => new GenericTypeTestCollectionNavigationBuilder<TEntity, TRelatedEntity>(EntityTypeBuilder.HasMany(navigationExpression));
    }",0,437 334 2000 60 2001 62 58 2002 60 2001 62 2003 2001 58 334 123 439 2000 40 2004 60 2001 62 2005 41 58 320 40 2005 41 123 125 438 431 2006 60 2001 62 2007 40 2004 60 2001 62 2005 41 619 418 2000 60 2001 62 40 2005 41 59 439 431 2008 60 2001 44 2009 62 2010 60 2009 62 40 2011 60 2012 60 2001 44 2009 63 640 2013 41 2003 2009 58 334 619 418 2014 60 2001 44 2009 62 40 2004 46 2010 40 2013 41 41 59 439 431 2006 60 2001 62 2010 60 2009 62 40 2011 60 2012 60 2001 44 2009 63 640 2013 44 2015 60 2008 60 2001 44 2009 640 2016 41 2003 2009 58 334 619 2007 40 2004 46 2010 40 2013 44 2017 619 2016 40 418 2014 60 2001 44 2009 62 40 2017 41 41 41 41 59 439 431 2018 60 2001 44 2009 62 2019 60 2009 62 40 2011 60 2012 60 2001 44 2009 63 640 63 2013 61 424 41 2003 2009 58 334 619 418 2020 60 2001 44 2009 62 40 2004 46 2019 40 2013 41 41 59 439 431 2021 60 2001 44 2009 62 2022 60 2009 62 40 2011 60 2012 60 2001 44 2023 60 2009 62 63 640 63 2013 61 424 41 2003 2009 58 334 619 418 2024 60 2001 44 2009 62 40 2004 46 2022 40 2013 41 41 59 125 
72443,C#,"    private class GenericTypeTestReferenceNavigationBuilder<TEntity, TRelatedEntity> : GenericTestReferenceNavigationBuilder<TEntity,
        TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public GenericTypeTestReferenceNavigationBuilder(ReferenceNavigationBuilder<TEntity, TRelatedEntity> referenceNavigationBuilder)
            : base(referenceNavigationBuilder)
        {
        }

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> WithOne(
            Expression<Func<TRelatedEntity, TEntity?>>? navigationExpression = null)
            => new GenericTypeTestReferenceReferenceBuilder<TEntity, TRelatedEntity>(
                ReferenceNavigationBuilder.WithOne(navigationExpression));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 439 431 2007 60 2001 44 2002 62 2008 40 2009 60 2010 60 2002 44 2001 63 640 63 2011 61 424 41 619 418 2012 60 2001 44 2002 62 40 2005 46 2008 40 2011 41 41 59 125 
72444,C#,"    private class GenericTypeTestReferenceReferenceBuilder<TEntity, TRelatedEntity>
        : GenericTestReferenceReferenceBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public GenericTypeTestReferenceReferenceBuilder(ReferenceReferenceBuilder<TEntity, TRelatedEntity> referenceReferenceBuilder)
            : base(referenceReferenceBuilder)
        {
        }

        protected override GenericTestReferenceReferenceBuilder<TEntity, TRelatedEntity> Wrap(
            ReferenceReferenceBuilder<TEntity, TRelatedEntity> referenceReferenceBuilder)
            => new GenericTypeTestReferenceReferenceBuilder<TEntity, TRelatedEntity>(referenceReferenceBuilder);

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
            Expression<Func<TDependentEntity, object?>> foreignKeyExpression)
            => Wrap(
                ReferenceReferenceBuilder.HasForeignKey(
                    typeof(TDependentEntity),
                    foreignKeyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
            params string[] foreignKeyPropertyNames)
            => Wrap(ReferenceReferenceBuilder.HasForeignKey(typeof(TDependentEntity), foreignKeyPropertyNames));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
            Expression<Func<TPrincipalEntity, object?>> keyExpression)
            => Wrap(
                ReferenceReferenceBuilder.HasPrincipalKey(
                    typeof(TPrincipalEntity),
                    keyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
            params string[] keyPropertyNames)
            => Wrap(ReferenceReferenceBuilder.HasPrincipalKey(typeof(TPrincipalEntity), keyPropertyNames));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2001 44 2002 62 2007 40 2005 60 2001 44 2002 62 2006 41 619 418 2000 60 2001 44 2002 62 40 2006 41 59 439 431 2008 60 2001 44 2002 62 2009 60 2010 62 40 2011 60 2012 60 2010 44 426 63 640 2013 41 619 2007 40 2005 46 2009 40 478 40 2010 41 44 2013 46 2014 40 41 46 2015 40 2016 619 2016 46 2017 40 41 41 46 2018 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2009 60 2010 62 40 433 461 91 93 2019 41 619 2007 40 2005 46 2009 40 478 40 2010 41 44 2019 41 41 59 439 431 2008 60 2001 44 2002 62 2020 60 2021 62 40 2011 60 2012 60 2021 44 426 63 640 2022 41 619 2007 40 2005 46 2020 40 478 40 2021 41 44 2022 46 2014 40 41 46 2015 40 2016 619 2016 46 2017 40 41 41 46 2018 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2020 60 2021 62 40 433 461 91 93 2023 41 619 2007 40 2005 46 2020 40 478 40 2021 41 44 2023 41 41 59 125 
69381,C#,"    public class GenericManyToManyString : ManyToManyTestBase
    {
        protected override TestModelBuilder CreateTestModelBuilder(
            TestHelpers testHelpers,
            Action<ModelConfigurationBuilder>? configure)
            => new GenericStringTestModelBuilder(testHelpers, configure);
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 40 2004 2005 44 2006 60 2007 62 63 2008 41 619 418 2009 40 2005 44 2008 41 59 125 
69387,C#,"    private class GenericStringTestCollectionNavigationBuilder<TEntity, TRelatedEntity>
        : GenericTestCollectionNavigationBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public GenericStringTestCollectionNavigationBuilder(
            CollectionNavigationBuilder<TEntity, TRelatedEntity> collectionNavigationBuilder)
            : base(collectionNavigationBuilder)
        {
        }

        public override TestReferenceCollectionBuilder<TEntity, TRelatedEntity> WithOne(
            Expression<Func<TRelatedEntity, TEntity?>>? navigationExpression = null)
            => new GenericStringTestReferenceCollectionBuilder<TEntity, TRelatedEntity>(
                CollectionNavigationBuilder.WithOne(
                    navigationExpression?.GetMemberAccess().GetSimpleMemberName()));

        public override TestCollectionCollectionBuilder<TRelatedEntity, TEntity> WithMany(
            Expression<Func<TRelatedEntity, IEnumerable<TEntity>?>> navigationExpression)
            => new GenericStringTestCollectionCollectionBuilder<TRelatedEntity, TEntity>(
                CollectionNavigationBuilder.WithMany(
                    navigationExpression.GetMemberAccess().GetSimpleMemberName()));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 439 431 2007 60 2001 44 2002 62 2008 40 2009 60 2010 60 2002 44 2001 63 640 63 2011 61 424 41 619 418 2012 60 2001 44 2002 62 40 2005 46 2008 40 2011 634 2013 40 41 46 2014 40 41 41 41 59 439 431 2015 60 2002 44 2001 62 2016 40 2009 60 2010 60 2002 44 2017 60 2001 62 63 640 2011 41 619 418 2018 60 2002 44 2001 62 40 2005 46 2016 40 2011 46 2013 40 41 46 2014 40 41 41 41 59 125 
69389,C#,"    private class GenericStringTestModelBuilder : TestModelBuilder
    {
        public GenericStringTestModelBuilder(TestHelpers testHelpers, Action<ModelConfigurationBuilder>? configure)
            : base(testHelpers, configure)
        {
        }

        public override TestEntityTypeBuilder<TEntity> Entity<TEntity>()
            => new GenericStringTestEntityTypeBuilder<TEntity>(ModelBuilder.Entity<TEntity>());

        public override TestEntityTypeBuilder<TEntity> SharedTypeEntity<TEntity>(string name)
            => new GenericStringTestEntityTypeBuilder<TEntity>(ModelBuilder.SharedTypeEntity<TEntity>(name));

        public override TestModelBuilder Entity<TEntity>(Action<TestEntityTypeBuilder<TEntity>> buildAction)
        {
            ModelBuilder.Entity<TEntity>(
                entityTypeBuilder =>
                    buildAction(new GenericStringTestEntityTypeBuilder<TEntity>(entityTypeBuilder)));
            return this;
        }

        public override TestModelBuilder SharedTypeEntity<TEntity>(string name, Action<TestEntityTypeBuilder<TEntity>> buildAction)
        {
            ModelBuilder.SharedTypeEntity<TEntity>(
                name,
                entityTypeBuilder =>
                    buildAction(new GenericStringTestEntityTypeBuilder<TEntity>(entityTypeBuilder)));
            return this;
        }

        public override TestOwnedEntityTypeBuilder<TEntity> Owned<TEntity>()
            => new GenericTestOwnedEntityTypeBuilder<TEntity>(ModelBuilder.Owned<TEntity>());

        public override TestModelBuilder Ignore<TEntity>()
        {
            ModelBuilder.Ignore<TEntity>();
            return this;
        }

        public override string GetDisplayName(Type entityType)
            => entityType.FullName!;
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 60 2005 62 63 2006 41 58 320 40 2003 44 2006 41 123 125 439 431 2007 60 2008 62 2009 60 2008 62 40 41 619 418 2010 60 2008 62 40 2011 46 2009 60 2008 62 40 41 41 59 439 431 2007 60 2008 62 2012 60 2008 62 40 461 2013 41 619 418 2010 60 2008 62 40 2011 46 2012 60 2008 62 40 2013 41 41 59 439 431 2001 2009 60 2008 62 40 2004 60 2007 60 2008 640 2014 41 123 2011 46 2009 60 2008 62 40 2015 619 2014 40 418 2010 60 2008 62 40 2015 41 41 41 59 450 467 59 125 439 431 2001 2012 60 2008 62 40 461 2013 44 2004 60 2007 60 2008 640 2014 41 123 2011 46 2012 60 2008 62 40 2013 44 2016 619 2014 40 418 2010 60 2008 62 40 2016 41 41 41 59 450 467 59 125 439 431 2017 60 2008 62 2018 60 2008 62 40 41 619 418 2019 60 2008 62 40 2011 46 2018 60 2008 62 40 41 41 59 439 431 2001 2020 60 2008 62 40 41 123 2011 46 2020 60 2008 62 40 41 59 450 467 59 125 439 431 461 2021 40 2022 2023 41 619 2023 46 2024 33 59 125 
69390,C#,"    private class GenericStringTestOwnedNavigationBuilder<TEntity, TDependentEntity>
        : GenericTestOwnedNavigationBuilder<TEntity, TDependentEntity>
        where TEntity : class
        where TDependentEntity : class
    {
        public GenericStringTestOwnedNavigationBuilder(OwnedNavigationBuilder<TEntity, TDependentEntity> ownedNavigationBuilder)
            : base(ownedNavigationBuilder)
        {
        }

        protected override GenericTestOwnedNavigationBuilder<TNewEntity, TNewRelatedEntity> Wrap<TNewEntity, TNewRelatedEntity>(
            OwnedNavigationBuilder<TNewEntity, TNewRelatedEntity> referenceOwnershipBuilder)
            => new GenericStringTestOwnedNavigationBuilder<TNewEntity, TNewRelatedEntity>(referenceOwnershipBuilder);

        public override TestOwnershipBuilder<TEntity, TDependentEntity> WithOwner(
            Expression<Func<TDependentEntity, TEntity?>>? referenceExpression)
            => new GenericTestOwnershipBuilder<TEntity, TDependentEntity>(
                OwnedNavigationBuilder.WithOwner(referenceExpression?.GetMemberAccess().GetSimpleMemberName()));

        public override TestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity> OwnsOne<TNewDependentEntity>(
            Expression<Func<TDependentEntity, TNewDependentEntity?>> navigationExpression)
            where TNewDependentEntity : class
            => Wrap(
                OwnedNavigationBuilder.OwnsOne<TNewDependentEntity>(navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestOwnedNavigationBuilder<TEntity, TDependentEntity> OwnsOne<TNewDependentEntity>(
            Expression<Func<TDependentEntity, TNewDependentEntity?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity>> buildAction)
            where TNewDependentEntity : class
            => Wrap(
                OwnedNavigationBuilder.OwnsOne<TNewDependentEntity>(
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(Wrap(r))));

        public override TestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity> OwnsMany<TNewDependentEntity>(
            Expression<Func<TDependentEntity, IEnumerable<TNewDependentEntity>?>> navigationExpression)
            where TNewDependentEntity : class
            => Wrap(
                OwnedNavigationBuilder.OwnsMany<TNewDependentEntity>(navigationExpression.GetMemberAccess().GetSimpleMemberName()));

        public override TestOwnedNavigationBuilder<TEntity, TDependentEntity> OwnsMany<TNewDependentEntity>(
            Expression<Func<TDependentEntity, IEnumerable<TNewDependentEntity>?>> navigationExpression,
            Action<TestOwnedNavigationBuilder<TDependentEntity, TNewDependentEntity>> buildAction)
            where TNewDependentEntity : class
            => Wrap(
                OwnedNavigationBuilder.OwnsMany<TNewDependentEntity>(
                    navigationExpression.GetMemberAccess().GetSimpleMemberName(),
                    r => buildAction(Wrap(r))));

        public override TestReferenceNavigationBuilder<TDependentEntity, TNewRelatedEntity> HasOne<TNewRelatedEntity>(
            Expression<Func<TDependentEntity, TNewRelatedEntity?>>? navigationExpression = null)
            where TNewRelatedEntity : class
            => new GenericStringTestReferenceNavigationBuilder<TDependentEntity, TNewRelatedEntity>(
                OwnedNavigationBuilder.HasOne<TNewRelatedEntity>(navigationExpression?.GetMemberAccess().GetSimpleMemberName()));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2007 44 2008 62 2009 60 2007 44 2008 62 40 2005 60 2007 44 2008 62 2010 41 619 418 2000 60 2007 44 2008 62 40 2010 41 59 439 431 2011 60 2001 44 2002 62 2012 40 2013 60 2014 60 2002 44 2001 63 640 63 2015 41 619 418 2016 60 2001 44 2002 62 40 2005 46 2012 40 2015 634 2017 40 41 46 2018 40 41 41 41 59 439 431 2019 60 2002 44 2020 62 2021 60 2020 62 40 2013 60 2014 60 2002 44 2020 63 640 2022 41 2004 2020 58 334 619 2009 40 2005 46 2021 60 2020 62 40 2022 46 2017 40 41 46 2018 40 41 41 41 59 439 431 2019 60 2001 44 2002 62 2021 60 2020 62 40 2013 60 2014 60 2002 44 2020 63 640 2022 44 2023 60 2019 60 2002 44 2020 640 2024 41 2004 2020 58 334 619 2009 40 2005 46 2021 60 2020 62 40 2022 46 2017 40 41 46 2018 40 41 44 2025 619 2024 40 2009 40 2025 41 41 41 41 59 439 431 2019 60 2002 44 2020 62 2026 60 2020 62 40 2013 60 2014 60 2002 44 2027 60 2020 62 63 640 2022 41 2004 2020 58 334 619 2009 40 2005 46 2026 60 2020 62 40 2022 46 2017 40 41 46 2018 40 41 41 41 59 439 431 2019 60 2001 44 2002 62 2026 60 2020 62 40 2013 60 2014 60 2002 44 2027 60 2020 62 63 640 2022 44 2023 60 2019 60 2002 44 2020 640 2024 41 2004 2020 58 334 619 2009 40 2005 46 2026 60 2020 62 40 2022 46 2017 40 41 46 2018 40 41 44 2025 619 2024 40 2009 40 2025 41 41 41 41 59 439 431 2028 60 2002 44 2008 62 2029 60 2008 62 40 2013 60 2014 60 2002 44 2008 63 640 63 2022 61 424 41 2004 2008 58 334 619 418 2030 60 2002 44 2008 62 40 2005 46 2029 60 2008 62 40 2022 634 2017 40 41 46 2018 40 41 41 41 59 125 
69393,C#,"    private class GenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity>
        : GenericTestReferenceReferenceBuilder<TEntity, TRelatedEntity>
        where TEntity : class
        where TRelatedEntity : class
    {
        public GenericStringTestReferenceReferenceBuilder(ReferenceReferenceBuilder<TEntity, TRelatedEntity> referenceReferenceBuilder)
            : base(referenceReferenceBuilder)
        {
        }

        protected override GenericTestReferenceReferenceBuilder<TEntity, TRelatedEntity> Wrap(
            ReferenceReferenceBuilder<TEntity, TRelatedEntity> referenceReferenceBuilder)
            => new GenericStringTestReferenceReferenceBuilder<TEntity, TRelatedEntity>(referenceReferenceBuilder);

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
            Expression<Func<TDependentEntity, object?>> foreignKeyExpression)
            => Wrap(
                ReferenceReferenceBuilder.HasForeignKey(
                    typeof(TDependentEntity).FullName!,
                    foreignKeyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasForeignKey<TDependentEntity>(
            params string[] foreignKeyPropertyNames)
            => Wrap(
                ReferenceReferenceBuilder.HasForeignKey(
                    typeof(TDependentEntity).FullName!, foreignKeyPropertyNames));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
            Expression<Func<TPrincipalEntity, object?>> keyExpression)
            => Wrap(
                ReferenceReferenceBuilder.HasPrincipalKey(
                    typeof(TPrincipalEntity).FullName!,
                    keyExpression.GetMemberAccessList().Select(p => p.GetSimpleMemberName()).ToArray()));

        public override TestReferenceReferenceBuilder<TEntity, TRelatedEntity> HasPrincipalKey<TPrincipalEntity>(
            params string[] keyPropertyNames)
            => Wrap(
                ReferenceReferenceBuilder.HasPrincipalKey(
                    typeof(TPrincipalEntity).FullName!, keyPropertyNames));
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 44 2002 62 2004 2001 58 334 2004 2002 58 334 123 439 2000 40 2005 60 2001 44 2002 62 2006 41 58 320 40 2006 41 123 125 438 431 2003 60 2001 44 2002 62 2007 40 2005 60 2001 44 2002 62 2006 41 619 418 2000 60 2001 44 2002 62 40 2006 41 59 439 431 2008 60 2001 44 2002 62 2009 60 2010 62 40 2011 60 2012 60 2010 44 426 63 640 2013 41 619 2007 40 2005 46 2009 40 478 40 2010 41 46 2014 33 44 2013 46 2015 40 41 46 2016 40 2017 619 2017 46 2018 40 41 41 46 2019 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2009 60 2010 62 40 433 461 91 93 2020 41 619 2007 40 2005 46 2009 40 478 40 2010 41 46 2014 33 44 2020 41 41 59 439 431 2008 60 2001 44 2002 62 2021 60 2022 62 40 2011 60 2012 60 2022 44 426 63 640 2023 41 619 2007 40 2005 46 2021 40 478 40 2022 41 46 2014 33 44 2023 46 2015 40 41 46 2016 40 2017 619 2017 46 2018 40 41 41 46 2019 40 41 41 41 59 439 431 2008 60 2001 44 2002 62 2021 60 2022 62 40 433 461 91 93 2024 41 619 2007 40 2005 46 2021 40 478 40 2022 41 46 2014 33 44 2024 41 41 59 125 
70637,C#,"    private class BadDataCommandBuilderFactory : RelationalCommandBuilderFactory
    {
        public BadDataCommandBuilderFactory(
            RelationalCommandBuilderDependencies dependencies)
            : base(dependencies)
        {
        }

        public object[] Values { private get; set; }

        public override IRelationalCommandBuilder Create()
            => new BadDataRelationalCommandBuilder(Dependencies, Values);

        private class BadDataRelationalCommandBuilder : RelationalCommandBuilder
        {
            private readonly object[] _values;

            public BadDataRelationalCommandBuilder(
                RelationalCommandBuilderDependencies dependencies,
                object[] values)
                : base(dependencies)
            {
                _values = values;
            }

            public override IRelationalCommand Build()
                => new BadDataRelationalCommand(Dependencies, ToString(), Parameters, _values);

            private class BadDataRelationalCommand : RelationalCommand
            {
                private object[] _values;

                public BadDataRelationalCommand(
                    RelationalCommandBuilderDependencies dependencies,
                    string commandText,
                    IReadOnlyList<IRelationalParameter> parameters,
                    object[] values)
                    : base(dependencies, commandText, parameters)
                {
                    _values = values;
                }

                public override RelationalDataReader ExecuteReader(
                    RelationalCommandParameterObject parameterObject)
                {
                    var command = parameterObject.Connection.DbConnection.CreateCommand();
                    command.CommandText = CommandText;
                    var reader = new BadDataRelationalDataReader();
                    reader.Initialize(
                        new FakeConnection(),
                        command,
                        new BadDataDataReader(_values),
                        Guid.NewGuid(),
                        parameterObject.Logger);
                    return reader;
                }

                public override void PopulateFrom(IRelationalCommandTemplate commandTemplate)
                {
                    base.PopulateFrom(commandTemplate);
                    _values = ((BadDataRelationalCommand)commandTemplate)._values;
                }

                private class BadDataRelationalDataReader : RelationalDataReader
                {
                }

                private class BadDataDataReader : DbDataReader
                {
                    private readonly object[] _values;

                    public BadDataDataReader(object[] values)
                    {
                        _values = values;
                    }

                    public override bool Read()
                        => true;

                    public override bool IsDBNull(int ordinal)
                        => false;

                    public override int GetInt32(int ordinal)
                        => (int)GetValue(ordinal);

                    public override short GetInt16(int ordinal)
                        => (short)GetValue(ordinal);

                    public override bool GetBoolean(int ordinal)
                        => (bool)GetValue(ordinal);

                    public override string GetString(int ordinal)
                        => (string)GetValue(ordinal);

                    public override object GetValue(int ordinal)
                        => _values[ordinal];

                    #region NotImplemented members

                    public override string GetName(int ordinal)
                        => throw new NotImplementedException();

                    public override int GetValues(object[] values)
                        => throw new NotImplementedException();

                    public override int FieldCount
                        => throw new NotImplementedException();

                    public override object this[int ordinal]
                        => throw new NotImplementedException();

                    public override object this[string name]
                        => throw new NotImplementedException();

                    public override bool HasRows
                        => throw new NotImplementedException();

                    public override bool IsClosed
                        => throw new NotImplementedException();

                    public override int RecordsAffected
                        => 0;

                    public override bool NextResult()
                        => throw new NotImplementedException();

                    public override int Depth
                        => throw new NotImplementedException();

                    public override int GetOrdinal(string name)
                        => throw new NotImplementedException();

                    public override byte GetByte(int ordinal)
                        => throw new NotImplementedException();

                    public override long GetBytes(int ordinal, long dataOffset, byte[] buffer, int bufferOffset, int length)
                        => throw new NotImplementedException();

                    public override char GetChar(int ordinal)
                        => throw new NotImplementedException();

                    public override long GetChars(int ordinal, long dataOffset, char[] buffer, int bufferOffset, int length)
                        => throw new NotImplementedException();

                    public override Guid GetGuid(int ordinal)
                        => throw new NotImplementedException();

                    public override long GetInt64(int ordinal)
                        => throw new NotImplementedException();

                    public override DateTime GetDateTime(int ordinal)
                        => throw new NotImplementedException();

                    public override decimal GetDecimal(int ordinal)
                        => throw new NotImplementedException();

                    public override double GetDouble(int ordinal)
                        => throw new NotImplementedException();

                    public override float GetFloat(int ordinal)
                        => throw new NotImplementedException();

                    public override string GetDataTypeName(int ordinal)
                        => throw new NotImplementedException();

                    public override Type GetFieldType(int ordinal)
                        => throw new NotImplementedException();

                    public override IEnumerator GetEnumerator()
                        => throw new NotImplementedException();

                    #endregion
                }
            }
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 439 426 91 93 2004 123 437 2005 59 2006 59 125 439 431 2007 2008 40 41 619 418 2009 40 2010 44 2004 41 59 437 334 2009 58 2011 123 437 441 426 91 93 2012 59 439 2009 40 2002 2003 44 426 91 93 2013 41 58 320 40 2003 41 123 2012 61 2013 59 125 439 431 2014 2015 40 41 619 418 2016 40 2010 44 2017 40 41 44 2018 44 2012 41 59 437 334 2016 58 2019 123 437 426 91 93 2012 59 439 2016 40 2002 2003 44 461 2020 44 2021 60 2022 62 2023 44 426 91 93 2013 41 58 320 40 2003 44 2020 44 2023 41 123 2012 61 2013 59 125 439 431 2024 2025 40 2026 2027 41 123 490 2028 61 2027 46 2029 46 2030 46 2031 40 41 59 2028 46 2032 61 2032 59 490 2033 61 418 2034 40 41 59 2033 46 2035 40 418 2036 40 41 44 2028 44 418 2037 40 2012 41 44 2038 46 2039 40 41 44 2027 46 2040 41 59 450 2033 59 125 439 431 492 2041 40 2042 2043 41 123 320 46 2041 40 2043 41 59 2012 61 40 40 2016 41 2043 41 46 2012 59 125 437 334 2044 58 2024 123 125 437 334 2045 58 2046 123 437 441 426 91 93 2012 59 439 2045 40 426 91 93 2013 41 123 2012 61 2013 59 125 439 431 323 2047 40 41 619 473 59 439 431 323 2048 40 404 2049 41 619 380 59 439 431 404 2050 40 404 2049 41 619 40 404 41 2051 40 2049 41 59 439 431 453 2052 40 404 2049 41 619 40 453 41 2051 40 2049 41 59 439 431 323 2053 40 404 2049 41 619 40 323 41 2051 40 2049 41 59 439 431 461 2054 40 404 2049 41 619 40 461 41 2051 40 2049 41 59 439 431 426 2051 40 404 2049 41 619 2012 91 2049 93 59 35 443 439 431 461 2055 40 404 2049 41 619 469 418 2056 40 41 59 439 431 404 2057 40 426 91 93 2013 41 619 469 418 2056 40 41 59 439 431 404 2058 619 469 418 2056 40 41 59 439 431 426 467 91 404 2049 93 619 469 418 2056 40 41 59 439 431 426 467 91 461 2059 93 619 469 418 2056 40 41 59 439 431 323 2060 619 469 418 2056 40 41 59 439 431 323 2061 619 469 418 2056 40 41 59 439 431 404 2062 619 1500 59 439 431 323 2063 40 41 619 469 418 2056 40 41 59 439 431 404 2064 619 469 418 2056 40 41 59 439 431 404 2065 40 461 2059 41 619 469 418 2056 40 41 59 439 431 326 2066 40 404 2049 41 619 469 418 2056 40 41 59 439 431 413 2067 40 404 2049 44 413 2068 44 326 91 93 2069 44 404 2070 44 404 2071 41 619 469 418 2056 40 41 59 439 431 330 2072 40 404 2049 41 619 469 418 2056 40 41 59 439 431 413 2073 40 404 2049 44 413 2068 44 330 91 93 2069 44 404 2070 44 404 2071 41 619 469 418 2056 40 41 59 439 431 2074 2075 40 404 2049 41 619 469 418 2056 40 41 59 439 431 413 2076 40 404 2049 41 619 469 418 2056 40 41 59 439 431 2077 2078 40 404 2049 41 619 469 418 2056 40 41 59 439 431 345 2079 40 404 2049 41 619 469 418 2056 40 41 59 439 431 356 2080 40 404 2049 41 619 469 418 2056 40 41 59 439 431 384 2081 40 404 2049 41 619 469 418 2056 40 41 59 439 431 461 2082 40 404 2049 41 619 469 418 2056 40 41 59 439 431 2083 2084 40 404 2049 41 619 469 418 2056 40 41 59 439 431 2085 2086 40 41 619 469 418 2056 40 41 59 35 367 125 125 125 125 
68781,C#,"    private class FakeSqlServerConnection : SqlServerConnection
    {
        private readonly IDbContextOptions _options;

        public FakeSqlServerConnection(IDbContextOptions options, RelationalConnectionDependencies dependencies)
            : base(dependencies)
        {
            _options = options;
        }

        public int ErrorNumber { get; set; }
        public int FailureCount { get; set; }
        public int FailDelay { get; set; }
        public int OpenCount { get; set; }

        public override bool Open(bool errorsExpected = false)
        {
            if (++OpenCount < FailureCount)
            {
                Thread.Sleep(FailDelay);
                throw SqlExceptionFactory.CreateSqlException(ErrorNumber);
            }

            return true;
        }

        public override async Task<bool> OpenAsync(CancellationToken cancellationToken, bool errorsExpected = false)
        {
            if (++OpenCount < FailureCount)
            {
                await Task.Delay(FailDelay, cancellationToken);
                throw SqlExceptionFactory.CreateSqlException(ErrorNumber);
            }

            return await Task.FromResult(true);
        }

        public override ISqlServerConnection CreateMasterConnection()
            => new FakeSqlServerConnection(_options, Dependencies);
    }",0,437 334 2000 58 2001 123 437 441 2002 2003 59 439 2000 40 2002 2004 44 2005 2006 41 58 320 40 2006 41 123 2003 61 2004 59 125 439 404 2007 123 2008 59 2009 59 125 439 404 2010 123 2011 59 2012 59 125 439 404 2013 123 2014 59 2015 59 125 439 404 2016 123 2017 59 2018 59 125 439 431 323 2019 40 323 2020 61 380 41 123 392 40 637 2016 60 2010 41 123 2021 46 2022 40 2013 41 59 469 2023 46 2024 40 2007 41 59 125 450 473 59 125 439 431 314 2025 60 323 62 2026 40 2027 2028 44 323 2020 61 380 41 123 392 40 637 2016 60 2010 41 123 319 2025 46 2029 40 2013 44 2028 41 59 469 2030 46 2031 40 2007 41 59 125 450 319 2025 46 2032 40 473 41 59 125 439 431 2033 2034 40 41 619 418 2000 40 2003 44 2035 41 59 125 
69694,C#,"public class SqlServerValueGenerationStrategyConventionTest
{
    [ConditionalFact]
    public void Annotations_are_added_when_conventional_model_builder_is_used()
    {
        var model = SqlServerTestHelpers.Instance.CreateConventionBuilder().Model;
        model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

        var annotations = model.GetAnnotations().OrderBy(a => a.Name).ToList();
        Assert.Equal(2, annotations.Count);

        Assert.Equal(SqlServerAnnotationNames.ValueGenerationStrategy, annotations.Last().Name);
        Assert.Equal(SqlServerValueGenerationStrategy.IdentityColumn, annotations.Last().Value);
    }

    [ConditionalFact]
    public void Annotations_are_added_when_conventional_model_builder_is_used_with_sequences()
    {
        var model = SqlServerTestHelpers.Instance.CreateConventionBuilder()
            .UseHiLo()
            .Model;

        model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

        var annotations = model.GetAnnotations().OrderBy(a => a.Name).ToList();
        Assert.Equal(4, annotations.Count);

        Assert.Equal(RelationalAnnotationNames.MaxIdentifierLength, annotations[0].Name);

        Assert.Equal(
            RelationalAnnotationNames.Sequences,
            annotations[1].Name);
        Assert.NotNull(annotations[1].Value);

        Assert.Equal(SqlServerAnnotationNames.HiLoSequenceName, annotations[2].Name);
        Assert.Equal(SqlServerModelExtensions.DefaultHiLoSequenceName, annotations[2].Value);

        Assert.Equal(SqlServerAnnotationNames.ValueGenerationStrategy, annotations[3].Name);
        Assert.Equal(SqlServerValueGenerationStrategy.SequenceHiLo, annotations[3].Value);
    }
}",0,439 334 2000 123 91 2001 93 439 492 2002 40 41 123 490 2003 61 2004 46 2005 46 2006 40 41 46 2007 59 2003 46 2008 40 2009 46 2010 41 59 490 2011 61 2003 46 2012 40 41 46 2013 40 2014 619 2014 46 2015 41 46 2016 40 41 59 2017 46 2018 40 1502 44 2011 46 2019 41 59 2017 46 2018 40 2020 46 2021 44 2011 46 2022 40 41 46 2015 41 59 2017 46 2018 40 2023 46 2024 44 2011 46 2022 40 41 46 2025 41 59 125 91 2001 93 439 492 2026 40 41 123 490 2027 61 2028 46 2029 46 2030 40 41 46 2031 40 41 46 2032 59 2027 46 2033 40 2034 46 2035 41 59 490 2036 61 2027 46 2037 40 41 46 2038 40 2039 619 2039 46 2040 41 46 2041 40 41 59 2042 46 2043 40 1502 44 2036 46 2044 41 59 2042 46 2043 40 2045 46 2046 44 2036 91 1500 93 46 2040 41 59 2042 46 2043 40 2045 46 2047 44 2036 91 1501 93 46 2040 41 59 2042 46 2048 40 2036 91 1501 93 46 2049 41 59 2042 46 2043 40 2050 46 2051 44 2036 91 1502 93 46 2040 41 59 2042 46 2043 40 2052 46 2053 44 2036 91 1502 93 46 2049 41 59 2042 46 2043 40 2050 46 2054 44 2036 91 1502 93 46 2040 41 59 2042 46 2043 40 2055 46 2056 44 2036 91 1502 93 46 2049 41 59 125 125 
68413,C#,"    private class TestRelationalCommand : IRelationalCommand
    {
        private readonly RelationalCommand _realRelationalCommand;

        public TestRelationalCommand(
            RelationalCommandBuilderDependencies dependencies,
            string commandText,
            IReadOnlyList<IRelationalParameter> parameters)
        {
            _realRelationalCommand = new RelationalCommand(dependencies, commandText, parameters);
        }

        public string CommandText
            => _realRelationalCommand.CommandText;

        public IReadOnlyList<IRelationalParameter> Parameters
            => _realRelationalCommand.Parameters;

        public int ExecuteNonQuery(RelationalCommandParameterObject parameterObject)
        {
            var connection = parameterObject.Connection;
            var errorNumber = PreExecution(connection);

            var result = _realRelationalCommand.ExecuteNonQuery(parameterObject);
            if (errorNumber.HasValue)
            {
                connection.DbConnection.Close();
                throw SqlExceptionFactory.CreateSqlException(errorNumber.Value);
            }

            return result;
        }

        public Task<int> ExecuteNonQueryAsync(
            RelationalCommandParameterObject parameterObject,
            CancellationToken cancellationToken = default)
        {
            var connection = parameterObject.Connection;
            var errorNumber = PreExecution(connection);

            var result = _realRelationalCommand.ExecuteNonQueryAsync(parameterObject, cancellationToken);
            if (errorNumber.HasValue)
            {
                connection.DbConnection.Close();
                throw SqlExceptionFactory.CreateSqlException(errorNumber.Value);
            }

            return result;
        }

        public object ExecuteScalar(RelationalCommandParameterObject parameterObject)
        {
            var connection = parameterObject.Connection;
            var errorNumber = PreExecution(connection);

            var result = _realRelationalCommand.ExecuteScalar(parameterObject);
            if (errorNumber.HasValue)
            {
                connection.DbConnection.Close();
                throw SqlExceptionFactory.CreateSqlException(errorNumber.Value);
            }

            return result;
        }

        public async Task<object> ExecuteScalarAsync(
            RelationalCommandParameterObject parameterObject,
            CancellationToken cancellationToken = default)
        {
            var connection = parameterObject.Connection;
            var errorNumber = PreExecution(connection);

            var result = await _realRelationalCommand.ExecuteScalarAsync(parameterObject, cancellationToken);
            if (errorNumber.HasValue)
            {
                connection.DbConnection.Close();
                throw SqlExceptionFactory.CreateSqlException(errorNumber.Value);
            }

            return result;
        }

        public RelationalDataReader ExecuteReader(RelationalCommandParameterObject parameterObject)
        {
            var connection = parameterObject.Connection;
            var errorNumber = PreExecution(connection);

            var result = _realRelationalCommand.ExecuteReader(parameterObject);
            if (errorNumber.HasValue)
            {
                connection.DbConnection.Close();
                result.Dispose(); // Normally, in non-test case, reader is disposed by using in caller code
                throw SqlExceptionFactory.CreateSqlException(errorNumber.Value);
            }

            return result;
        }

        public async Task<RelationalDataReader> ExecuteReaderAsync(
            RelationalCommandParameterObject parameterObject,
            CancellationToken cancellationToken = default)
        {
            var connection = parameterObject.Connection;
            var errorNumber = PreExecution(connection);

            var result = await _realRelationalCommand.ExecuteReaderAsync(parameterObject);
            if (errorNumber.HasValue)
            {
                connection.DbConnection.Close();
                result.Dispose(); // Normally, in non-test case, reader is disposed by using in caller code
                throw SqlExceptionFactory.CreateSqlException(errorNumber.Value);
            }

            return result;
        }

        public DbCommand CreateDbCommand(
            RelationalCommandParameterObject parameterObject,
            Guid commandId,
            DbCommandMethod commandMethod)
            => throw new NotSupportedException();

        public void PopulateFrom(IRelationalCommandTemplate commandTemplate)
            => _realRelationalCommand.PopulateFrom(commandTemplate);

        private int? PreExecution(IRelationalConnection connection)
        {
            int? errorNumber = null;
            var testConnection = (TestSqlServerConnection)connection;

            testConnection.ExecutionCount++;
            if (testConnection.ExecutionFailures.Count > 0)
            {
                var fail = testConnection.ExecutionFailures.Dequeue();
                if (fail.HasValue)
                {
                    if (fail.Value)
                    {
                        testConnection.DbConnection.Close();
                        throw SqlExceptionFactory.CreateSqlException(testConnection.ErrorNumber);
                    }

                    errorNumber = testConnection.ErrorNumber;
                }
            }

            return errorNumber;
        }
    }",0,437 334 2000 58 2001 123 437 441 2002 2003 59 439 2000 40 2004 2005 44 461 2006 44 2007 60 2008 62 2009 41 123 2003 61 418 2002 40 2005 44 2006 44 2009 41 59 125 439 461 2010 619 2003 46 2010 59 439 2007 60 2008 62 2011 619 2003 46 2011 59 439 404 2012 40 2013 2014 41 123 490 2015 61 2014 46 2016 59 490 2017 61 2018 40 2015 41 59 490 2019 61 2003 46 2012 40 2014 41 59 392 40 2017 46 2020 41 123 2015 46 2021 46 2022 40 41 59 469 2023 46 2024 40 2017 46 2025 41 59 125 450 2019 59 125 439 2026 60 404 62 2027 40 2013 2014 44 2028 2029 61 349 41 123 490 2030 61 2014 46 2031 59 490 2032 61 2033 40 2030 41 59 490 2034 61 2003 46 2027 40 2014 44 2029 41 59 392 40 2032 46 2035 41 123 2030 46 2036 46 2037 40 41 59 469 2038 46 2039 40 2032 46 2040 41 59 125 450 2034 59 125 439 426 2041 40 2013 2014 41 123 490 2042 61 2014 46 2043 59 490 2044 61 2045 40 2042 41 59 490 2046 61 2003 46 2041 40 2014 41 59 392 40 2044 46 2047 41 123 2042 46 2048 46 2049 40 41 59 469 2050 46 2051 40 2044 46 2052 41 59 125 450 2046 59 125 439 314 2026 60 426 62 2053 40 2013 2014 44 2028 2029 61 349 41 123 490 2054 61 2014 46 2055 59 490 2056 61 2057 40 2054 41 59 490 2058 61 319 2003 46 2053 40 2014 44 2029 41 59 392 40 2056 46 2059 41 123 2054 46 2060 46 2061 40 41 59 469 2062 46 2063 40 2056 46 2064 41 59 125 450 2058 59 125 439 2065 2066 40 2013 2014 41 123 490 2067 61 2014 46 2068 59 490 2069 61 2070 40 2067 41 59 490 2071 61 2003 46 2066 40 2014 41 59 392 40 2069 46 2072 41 123 2067 46 2073 46 2074 40 41 59 2071 46 2075 40 41 59 621 469 2076 46 2077 40 2069 46 2078 41 59 125 450 2071 59 125 439 314 2026 60 2065 62 2079 40 2013 2014 44 2028 2029 61 349 41 123 490 2080 61 2014 46 2081 59 490 2082 61 2083 40 2080 41 59 490 2084 61 319 2003 46 2079 40 2014 41 59 392 40 2082 46 2085 41 123 2080 46 2086 46 2087 40 41 59 2084 46 2088 40 41 59 621 469 2089 46 2090 40 2082 46 2091 41 59 125 450 2084 59 125 439 2092 2093 40 2013 2014 44 2094 2095 44 2096 2097 41 619 469 418 2098 40 41 59 439 492 2099 40 2100 2101 41 619 2003 46 2099 40 2101 41 59 437 404 63 2102 40 2103 2104 41 123 404 63 2105 61 424 59 490 2106 61 40 2107 41 2104 59 2106 46 2108 637 59 392 40 2106 46 2109 46 2110 62 1500 41 123 490 2111 61 2106 46 2109 46 2112 40 41 59 392 40 2111 46 2113 41 123 392 40 2111 46 2114 41 123 2106 46 2115 46 2116 40 41 59 469 2117 46 2118 40 2106 46 2119 41 59 125 2105 61 2106 46 2120 59 125 125 450 2105 59 125 125 
70156,C#,"    public class AuditContext : DbContext
    {
        public DbSet<Audit> Audits { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseSqlServer();
    }",0,439 334 2000 58 2001 123 439 2002 60 2003 62 2004 123 2005 59 2006 59 125 438 431 492 2007 40 2008 2009 41 619 2009 46 2010 40 41 59 125 
70158,C#,"    protected class ExecutionStrategyContext : DbContext
    {
        public ExecutionStrategyContext(DbContextOptions options)
            : base(options)
        {
        }

        public DbSet<Product> Products { get; set; }
        public DbSet<Audit> Audits { get; set; }
    }",0,438 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 439 2004 60 2005 62 2006 123 2007 59 2008 59 125 439 2004 60 2009 62 2010 123 2011 59 2012 59 125 125 
72582,C#,"    public class ConvertToProviderTypesSqlServerFixture : ConvertToProviderTypesFixtureBase
    {
        public override bool StrictEquality
            => true;

        public override bool SupportsAnsi
            => true;

        public override bool SupportsUnicodeToAnsiConversion
            => true;

        public override bool SupportsLargeStringComparisons
            => true;

        protected override ITestStoreFactory TestStoreFactory
            => SqlServerTestStoreFactory.Instance;

        public override bool SupportsBinaryKeys
            => true;

        public override bool SupportsDecimalComparisons
            => true;

        public override DateTime DefaultDateTime
            => new();

        public override bool PreservesDateTimeKind
            => false;

        public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder builder)
            => base
                .AddOptions(builder)
                .ConfigureWarnings(
                    c => c.Log(SqlServerEventId.DecimalTypeDefaultWarning));

        protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext context)
        {
            base.OnModelCreating(modelBuilder, context);

            modelBuilder.Entity<BuiltInDataTypes>().Property(e => e.Enum8).IsFixedLength();
        }
    }",0,439 334 2000 58 2001 123 439 431 323 2002 619 473 59 439 431 323 2003 619 473 59 439 431 323 2004 619 473 59 439 431 323 2005 619 473 59 438 431 2006 2007 619 2008 46 2009 59 439 431 323 2010 619 473 59 439 431 323 2011 619 473 59 439 431 2012 2013 619 418 40 41 59 439 431 323 2014 619 380 59 439 431 2015 2016 40 2015 2017 41 619 320 46 2016 40 2017 41 46 2018 40 2019 619 2019 46 2020 40 2021 46 2022 41 41 59 438 431 492 2023 40 2024 2025 44 2026 2027 41 123 320 46 2023 40 2025 44 2027 41 59 2025 46 2028 60 2029 62 40 41 46 2030 40 2031 619 2031 46 2032 41 46 2033 40 41 59 125 125 
68678,C#,"    private class TestRawSqlCommandBuilder : IRawSqlCommandBuilder
    {
        private readonly IRelationalCommandBuilderFactory _commandBuilderFactory;

        public TestRawSqlCommandBuilder(
            IRelationalCommandBuilderFactory relationalCommandBuilderFactory)
        {
            _commandBuilderFactory = relationalCommandBuilderFactory;
        }

        public string Sql { get; private set; }
        public IEnumerable<object> Parameters { get; private set; }

        public IRelationalCommand Build(string sql)
            => throw new NotImplementedException();

        public RawSqlCommand Build(string sql, IEnumerable<object> parameters)
        {
            Sql = sql;
            Parameters = parameters;

            return new RawSqlCommand(_commandBuilderFactory.Create().Build(), new Dictionary<string, object>());
        }
    }",0,437 334 2000 58 2001 123 437 441 2002 2003 59 439 2000 40 2002 2004 41 123 2003 61 2004 59 125 439 461 2005 123 2006 59 437 2007 59 125 439 2008 60 426 62 2009 123 2010 59 437 2011 59 125 439 2012 2013 40 461 2014 41 619 469 418 2015 40 41 59 439 2016 2013 40 461 2014 44 2008 60 426 62 2017 41 123 2005 61 2014 59 2009 61 2017 59 450 418 2016 40 2003 46 2018 40 41 46 2013 40 41 44 418 2019 60 461 44 426 62 40 41 41 59 125 125 
68679,C#,"    private class ThudContext : DbContext
    {
        public ThudContext()
            : base(
                RelationalTestHelpers.Instance.CreateOptions(
                    RelationalTestHelpers.Instance.CreateServiceProvider(
                        new ServiceCollection()
                            .AddScoped<IRawSqlCommandBuilder, TestRawSqlCommandBuilder>())))
        {
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 41 58 320 40 2002 46 2003 46 2004 40 2002 46 2003 46 2005 40 418 2006 40 41 46 2007 60 2008 44 2009 62 40 41 41 41 41 123 125 125 
70056,C#,"    private class FakeLoggingOptions : ILoggingOptions
    {
        public FakeLoggingOptions(bool sensitiveDataLoggingEnabled)
        {
            IsSensitiveDataLoggingEnabled = sensitiveDataLoggingEnabled;
        }

        public void Initialize(IDbContextOptions options)
        {
        }

        public void Validate(IDbContextOptions options)
        {
        }

        public bool IsSensitiveDataLoggingEnabled { get; }
        public bool IsSensitiveDataLoggingWarned { get; set; }

        public WarningsConfiguration WarningsConfiguration
            => null;
    }",0,437 334 2000 58 2001 123 439 2000 40 323 2002 41 123 2003 61 2002 59 125 439 492 2004 40 2005 2006 41 123 125 439 492 2007 40 2005 2006 41 123 125 439 323 2008 123 2009 59 125 439 323 2010 123 2011 59 2012 59 125 439 2013 2013 619 424 59 125 
70057,C#,"    private class ReaderThrowingRelationalCommand : RelationalCommand
    {
        public ReaderThrowingRelationalCommand(
            RelationalCommandBuilderDependencies dependencies,
            string commandText,
            IReadOnlyList<IRelationalParameter> parameters)
            : base(dependencies, commandText, parameters)
        {
        }

        protected override RelationalDataReader CreateRelationalDataReader()
            => new ThrowingRelationalReader();

        public static IRelationalCommand Create(string commandText = ""Command Text"")
            => new ReaderThrowingRelationalCommand(
                new RelationalCommandBuilderDependencies(
                    new TestRelationalTypeMappingSource(
                        TestServiceFactory.Instance.Create<TypeMappingSourceDependencies>(),
                        TestServiceFactory.Instance.Create<RelationalTypeMappingSourceDependencies>()),
                    new ExceptionDetector()),
                commandText,
                Array.Empty<IRelationalParameter>());

        private class ThrowingRelationalReader : RelationalDataReader
        {
            public override void Initialize(
                IRelationalConnection relationalConnection,
                DbCommand command,
                DbDataReader reader,
                Guid commandId,
                IRelationalCommandDiagnosticsLogger logger)
                => throw new InvalidOperationException(""Bang!"");
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 461 2004 44 2005 60 2006 62 2007 41 58 320 40 2003 44 2004 44 2007 41 123 125 438 431 2008 2009 40 41 619 418 2010 40 41 59 439 457 2011 2012 40 461 2004 61 648 41 619 418 2000 40 418 2002 40 418 2013 40 2014 46 2015 46 2012 60 2016 62 40 41 44 2014 46 2015 46 2012 60 2017 62 40 41 41 44 418 2018 40 41 41 44 2004 44 2019 46 2020 60 2006 62 40 41 41 59 437 334 2010 58 2008 123 439 431 492 2021 40 2022 2023 44 2024 2025 44 2026 2027 44 2028 2029 44 2030 2031 41 619 469 418 2032 40 648 41 59 125 125 
70684,C#,"public class MigrationCommandListBuilderTest
{
    [ConditionalTheory]
    [InlineData(false)]
    [InlineData(true)]
    public void MigrationCommandListBuilder_groups_multiple_statements_into_one_batch(bool suppressTransaction)
    {
        var commandListBuilder = CreateBuilder();
        commandListBuilder.AppendLine(""Statement1"");
        commandListBuilder.AppendLine(""Statement2"");
        commandListBuilder.AppendLine(""Statement3"");
        commandListBuilder.EndCommand(suppressTransaction);

        var commandList = commandListBuilder.GetCommandList();

        Assert.Equal(1, commandList.Count);

        Assert.Equal(suppressTransaction, commandList[0].TransactionSuppressed);
        Assert.NotNull(commandList[0].CommandLogger);
        Assert.Equal(
            @""Statement1
Statement2
Statement3
"",
            commandList[0].CommandText,
            ignoreLineEndingDifferences: true);
    }

    [ConditionalTheory]
    [InlineData(false)]
    [InlineData(true)]
    public void MigrationCommandListBuilder_correctly_produces_multiple_batches(bool suppressTransaction)
    {
        var commandListBuilder = CreateBuilder();
        commandListBuilder.AppendLine(""Statement1"");
        commandListBuilder.EndCommand(suppressTransaction);
        commandListBuilder.AppendLine(""Statement2"");
        commandListBuilder.AppendLine(""Statement3"");
        commandListBuilder.EndCommand(suppressTransaction);
        commandListBuilder.AppendLine(""Statement4"");
        commandListBuilder.AppendLine(""Statement5"");
        commandListBuilder.AppendLine(""Statement6"");
        commandListBuilder.EndCommand(suppressTransaction);

        var commandList = commandListBuilder.GetCommandList();

        Assert.Equal(3, commandList.Count);

        Assert.Equal(suppressTransaction, commandList[0].TransactionSuppressed);
        Assert.NotNull(commandList[0].CommandLogger);
        Assert.Equal(
            @""Statement1
"",
            commandList[0].CommandText,
            ignoreLineEndingDifferences: true);

        Assert.Equal(suppressTransaction, commandList[1].TransactionSuppressed);
        Assert.NotNull(commandList[1].CommandLogger);
        Assert.Equal(
            @""Statement2
Statement3
"",
            commandList[1].CommandText,
            ignoreLineEndingDifferences: true);

        Assert.Equal(suppressTransaction, commandList[2].TransactionSuppressed);
        Assert.NotNull(commandList[2].CommandLogger);
        Assert.Equal(
            @""Statement4
Statement5
Statement6
"",
            commandList[2].CommandText,
            ignoreLineEndingDifferences: true);
    }

    [ConditionalTheory]
    [InlineData(false)]
    [InlineData(true)]
    public void MigrationCommandListBuilder_ignores_empty_batches(bool suppressTransaction)
    {
        var commandListBuilder = CreateBuilder();
        commandListBuilder.AppendLine(""Statement1"");
        commandListBuilder.EndCommand(suppressTransaction);
        commandListBuilder.EndCommand(suppressTransaction: true);
        commandListBuilder.EndCommand(suppressTransaction: true);
        commandListBuilder.AppendLine(""Statement2"");
        commandListBuilder.AppendLine(""Statement3"");
        commandListBuilder.EndCommand(suppressTransaction);
        commandListBuilder.EndCommand();

        var commandList = commandListBuilder.GetCommandList();

        Assert.Equal(2, commandList.Count);

        Assert.Equal(suppressTransaction, commandList[0].TransactionSuppressed);
        Assert.NotNull(commandList[0].CommandLogger);
        Assert.Equal(
            @""Statement1
"",
            commandList[0].CommandText,
            ignoreLineEndingDifferences: true);

        Assert.Equal(suppressTransaction, commandList[1].TransactionSuppressed);
        Assert.NotNull(commandList[1].CommandLogger);
        Assert.Equal(
            @""Statement2
Statement3
"",
            commandList[1].CommandText,
            ignoreLineEndingDifferences: true);
    }

    private MigrationCommandListBuilder CreateBuilder()
    {
        var typeMappingSource = new TestRelationalTypeMappingSource(
            TestServiceFactory.Instance.Create<TypeMappingSourceDependencies>(),
            TestServiceFactory.Instance.Create<RelationalTypeMappingSourceDependencies>());

        var logger = new FakeRelationalCommandDiagnosticsLogger();
        var migrationsLogger = new FakeDiagnosticsLogger<DbLoggerCategory.Migrations>();
        var generationHelper = new RelationalSqlGenerationHelper(new RelationalSqlGenerationHelperDependencies());

        return new MigrationCommandListBuilder(
            new MigrationsSqlGeneratorDependencies(
                new RelationalCommandBuilderFactory(
                    new RelationalCommandBuilderDependencies(
                        typeMappingSource,
                        new ExceptionDetector())),
                new FakeSqlGenerator(
                    new UpdateSqlGeneratorDependencies(
                        generationHelper,
                        typeMappingSource)),
                generationHelper,
                typeMappingSource,
                new CurrentDbContext(new FakeDbContext()),
                new ModificationCommandFactory(),
                new LoggingOptions(),
                logger,
                migrationsLogger));
    }

    private class FakeDbContext : DbContext
    {
    }
}",0,439 334 2000 123 91 2001 93 91 2002 40 380 41 93 91 2002 40 473 41 93 439 492 2003 40 323 2004 41 123 490 2005 61 2006 40 41 59 2005 46 2007 40 648 41 59 2005 46 2007 40 648 41 59 2005 46 2007 40 648 41 59 2005 46 2008 40 2004 41 59 490 2009 61 2005 46 2010 40 41 59 2011 46 2012 40 1501 44 2009 46 2013 41 59 2011 46 2012 40 2004 44 2009 91 1500 93 46 2014 41 59 2011 46 2015 40 2009 91 1500 93 46 2016 41 59 2011 46 2012 40 64 648 44 2009 91 1500 93 46 2017 44 2018 58 473 41 59 125 91 2001 93 91 2002 40 380 41 93 91 2002 40 473 41 93 439 492 2019 40 323 2004 41 123 490 2020 61 2021 40 41 59 2020 46 2022 40 648 41 59 2020 46 2023 40 2004 41 59 2020 46 2022 40 648 41 59 2020 46 2022 40 648 41 59 2020 46 2023 40 2004 41 59 2020 46 2022 40 648 41 59 2020 46 2022 40 648 41 59 2020 46 2022 40 648 41 59 2020 46 2023 40 2004 41 59 490 2024 61 2020 46 2025 40 41 59 2026 46 2027 40 1502 44 2024 46 2028 41 59 2026 46 2027 40 2004 44 2024 91 1500 93 46 2029 41 59 2026 46 2030 40 2024 91 1500 93 46 2031 41 59 2026 46 2027 40 64 648 44 2024 91 1500 93 46 2032 44 2033 58 473 41 59 2026 46 2027 40 2004 44 2024 91 1501 93 46 2029 41 59 2026 46 2030 40 2024 91 1501 93 46 2031 41 59 2026 46 2027 40 64 648 44 2024 91 1501 93 46 2032 44 2033 58 473 41 59 2026 46 2027 40 2004 44 2024 91 1502 93 46 2029 41 59 2026 46 2030 40 2024 91 1502 93 46 2031 41 59 2026 46 2027 40 64 648 44 2024 91 1502 93 46 2032 44 2033 58 473 41 59 125 91 2001 93 91 2002 40 380 41 93 91 2002 40 473 41 93 439 492 2034 40 323 2004 41 123 490 2035 61 2036 40 41 59 2035 46 2037 40 648 41 59 2035 46 2038 40 2004 41 59 2035 46 2038 40 2004 58 473 41 59 2035 46 2038 40 2004 58 473 41 59 2035 46 2037 40 648 41 59 2035 46 2037 40 648 41 59 2035 46 2038 40 2004 41 59 2035 46 2038 40 41 59 490 2039 61 2035 46 2040 40 41 59 2041 46 2042 40 1502 44 2039 46 2043 41 59 2041 46 2042 40 2004 44 2039 91 1500 93 46 2044 41 59 2041 46 2045 40 2039 91 1500 93 46 2046 41 59 2041 46 2042 40 64 648 44 2039 91 1500 93 46 2047 44 2048 58 473 41 59 2041 46 2042 40 2004 44 2039 91 1501 93 46 2044 41 59 2041 46 2045 40 2039 91 1501 93 46 2046 41 59 2041 46 2042 40 64 648 44 2039 91 1501 93 46 2047 44 2048 58 473 41 59 125 437 2049 2050 40 41 123 490 2051 61 418 2052 40 2053 46 2054 46 2055 60 2056 62 40 41 44 2053 46 2054 46 2055 60 2057 62 40 41 41 59 490 2058 61 418 2059 40 41 59 490 2060 61 418 2061 60 2062 46 2063 62 40 41 59 490 2064 61 418 2065 40 418 2066 40 41 41 59 450 418 2049 40 418 2067 40 418 2068 40 418 2069 40 2051 44 418 2070 40 41 41 41 44 418 2071 40 418 2072 40 2064 44 2051 41 41 44 2064 44 2051 44 418 2073 40 418 2074 40 41 41 44 418 2075 40 41 44 418 2076 40 41 44 2058 44 2060 41 41 59 125 437 334 2077 58 2078 123 125 125 
69112,C#,"    public class CustomConvertersCosmosFixture : CustomConvertersFixtureBase
    {
        protected override ITestStoreFactory TestStoreFactory
            => CosmosTestStoreFactory.Instance;

        public override bool StrictEquality
            => true;

        public override int IntegerPrecision
            => 53;

        public override bool SupportsAnsi
            => false;

        public override bool SupportsUnicodeToAnsiConversion
            => false;

        public override bool SupportsLargeStringComparisons
            => true;

        public override bool SupportsBinaryKeys
            => true;

        public override bool SupportsDecimalComparisons
            => true;

        public override DateTime DefaultDateTime
            => new();

        public override bool PreservesDateTimeKind
            => true;

        public TestSqlLoggerFactory TestSqlLoggerFactory
            => (TestSqlLoggerFactory)ListLoggerFactory;

        protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext context)
        {
            base.OnModelCreating(modelBuilder, context);

            var shadowJObject = (Property)modelBuilder.Entity<BuiltInDataTypesShadow>().Property(""__jObject"").Metadata;
            shadowJObject.SetConfigurationSource(ConfigurationSource.Convention);
            var nullableShadowJObject = (Property)modelBuilder.Entity<BuiltInNullableDataTypesShadow>().Property(""__jObject"").Metadata;
            nullableShadowJObject.SetConfigurationSource(ConfigurationSource.Convention);

            modelBuilder.Entity<SimpleCounter>(b => b.ToContainer(""SimpleCounters""));
        }
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 619 2004 46 2005 59 439 431 323 2006 619 473 59 439 431 404 2007 619 1503 59 439 431 323 2008 619 380 59 439 431 323 2009 619 380 59 439 431 323 2010 619 473 59 439 431 323 2011 619 473 59 439 431 323 2012 619 473 59 439 431 2013 2014 619 418 40 41 59 439 431 323 2015 619 473 59 439 2016 2016 619 40 2016 41 2017 59 438 431 492 2018 40 2019 2020 44 2021 2022 41 123 320 46 2018 40 2020 44 2022 41 59 490 2023 61 40 2024 41 2020 46 2025 60 2026 62 40 41 46 2024 40 648 41 46 2027 59 2023 46 2028 40 2029 46 2030 41 59 490 2031 61 40 2024 41 2020 46 2025 60 2032 62 40 41 46 2024 40 648 41 46 2027 59 2031 46 2028 40 2029 46 2030 41 59 2020 46 2025 60 2033 62 40 2034 619 2034 46 2035 40 648 41 41 59 125 125 
70104,C#,"    public class BuiltInDataTypesCosmosFixture : BuiltInDataTypesFixtureBase
    {
        protected override ITestStoreFactory TestStoreFactory
            => CosmosTestStoreFactory.Instance;

        public override bool StrictEquality
            => true;

        public override int IntegerPrecision
            => 53;

        public override bool SupportsAnsi
            => false;

        public override bool SupportsUnicodeToAnsiConversion
            => false;

        public override bool SupportsLargeStringComparisons
            => true;

        public override bool SupportsBinaryKeys
            => true;

        public override bool SupportsDecimalComparisons
            => true;

        public TestSqlLoggerFactory TestSqlLoggerFactory
            => (TestSqlLoggerFactory)ListLoggerFactory;

        public override DateTime DefaultDateTime
            => new();

        public override bool PreservesDateTimeKind
            => true;

        protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext context)
        {
            base.OnModelCreating(modelBuilder, context);

            var shadowJObject = (Property)modelBuilder.Entity<BuiltInDataTypesShadow>().Property(""__jObject"").Metadata;
            shadowJObject.SetConfigurationSource(ConfigurationSource.Convention);
            var nullableShadowJObject = (Property)modelBuilder.Entity<BuiltInNullableDataTypesShadow>().Property(""__jObject"").Metadata;
            nullableShadowJObject.SetConfigurationSource(ConfigurationSource.Convention);
        }
    }",0,439 334 2000 58 2001 123 438 431 2002 2003 619 2004 46 2005 59 439 431 323 2006 619 473 59 439 431 404 2007 619 1503 59 439 431 323 2008 619 380 59 439 431 323 2009 619 380 59 439 431 323 2010 619 473 59 439 431 323 2011 619 473 59 439 431 323 2012 619 473 59 439 2013 2013 619 40 2013 41 2014 59 439 431 2015 2016 619 418 40 41 59 439 431 323 2017 619 473 59 438 431 492 2018 40 2019 2020 44 2021 2022 41 123 320 46 2018 40 2020 44 2022 41 59 490 2023 61 40 2024 41 2020 46 2025 60 2026 62 40 41 46 2024 40 648 41 46 2027 59 2023 46 2028 40 2029 46 2030 41 59 490 2031 61 40 2024 41 2020 46 2025 60 2032 62 40 41 46 2024 40 648 41 46 2027 59 2031 46 2028 40 2029 46 2030 41 59 125 125 
69716,C#,"public class ValueGeneratorSelector : IValueGeneratorSelector
{
    /// <summary>
    ///     The cache being used to store value generator instances.
    /// </summary>
    public virtual IValueGeneratorCache Cache
        => Dependencies.Cache;

    /// <summary>
    ///     Initializes a new instance of the <see cref=""ValueGeneratorSelector"" /> class.
    /// </summary>
    /// <param name=""dependencies"">Parameter object containing dependencies for this service.</param>
    public ValueGeneratorSelector(ValueGeneratorSelectorDependencies dependencies)
    {
        Dependencies = dependencies;
    }

    /// <summary>
    ///     Dependencies for this service.
    /// </summary>
    protected virtual ValueGeneratorSelectorDependencies Dependencies { get; }

    /// <summary>
    ///     Selects the appropriate value generator for a given property.
    /// </summary>
    /// <param name=""property"">The property to get the value generator for.</param>
    /// <param name=""entityType"">
    ///     The entity type that the value generator will be used for. When called on inherited properties on derived entity types,
    ///     this entity type may be different from the declared entity type on <paramref name=""property"" />
    /// </param>
    /// <returns>The value generator to be used.</returns>
    public virtual ValueGenerator Select(IProperty property, IEntityType entityType)
        => Cache.GetOrAdd(property, entityType, (p, t) => CreateFromFactory(p, t) ?? Create(p, t));

    private static ValueGenerator? CreateFromFactory(IProperty property, IEntityType entityType)
    {
        var factory = property.GetValueGeneratorFactory();

        if (factory == null)
        {
            var mapping = property.GetTypeMapping();
            factory = mapping.ValueGeneratorFactory;

            if (factory == null)
            {
                var converter = mapping.Converter;

                if (converter != null)
                {
                    var type = converter.ProviderClrType.UnwrapNullableType();
                    if (!type.IsInteger()
                        && !type.IsEnum
                        && type != typeof(decimal))
                    {
                        throw new NotSupportedException(
                            CoreStrings.ValueGenWithConversion(
                                property.DeclaringEntityType.DisplayName(),
                                property.Name,
                                converter.GetType().ShortDisplayName()));
                    }
                }
            }
        }

        return factory?.Invoke(property, entityType);
    }

    /// <summary>
    ///     Creates a new value generator for the given property.
    /// </summary>
    /// <param name=""property"">The property to get the value generator for.</param>
    /// <param name=""entityType"">
    ///     The entity type that the value generator will be used for. When called on inherited properties on derived entity types,
    ///     this entity type may be different from the declared entity type on <paramref name=""property"" />
    /// </param>
    /// <returns>The newly created value generator.</returns>
    public virtual ValueGenerator Create(IProperty property, IEntityType entityType)
    {
        var propertyType = property.ClrType.UnwrapNullableType().UnwrapEnumType();

        if (propertyType == typeof(Guid))
        {
            return new GuidValueGenerator();
        }

        if (propertyType == typeof(string))
        {
            return new StringValueGenerator();
        }

        if (propertyType == typeof(byte[]))
        {
            return new BinaryValueGenerator();
        }

        throw new NotSupportedException(
            CoreStrings.NoValueGenerator(property.Name, property.DeclaringEntityType.DisplayName(), propertyType.ShortDisplayName()));
    }
}",0,439 334 2000 58 2001 123 612 439 491 2002 2003 619 2004 46 2003 59 612 439 2000 40 2005 2006 41 123 2004 61 2006 59 125 612 438 491 2005 2004 123 2007 59 125 612 439 491 2008 2009 40 2010 2011 44 2012 2013 41 619 2003 46 2014 40 2011 44 2013 44 40 2015 44 2016 41 619 2017 40 2015 44 2016 41 633 2018 40 2015 44 2016 41 41 59 437 457 2008 63 2017 40 2010 2011 44 2012 2013 41 123 490 2019 61 2011 46 2020 40 41 59 392 40 2019 614 424 41 123 490 2021 61 2011 46 2022 40 41 59 2019 61 2021 46 2023 59 392 40 2019 614 424 41 123 490 2024 61 2021 46 2025 59 392 40 2024 631 424 41 123 490 2026 61 2024 46 2027 46 2028 40 41 59 392 40 33 2026 46 2029 40 41 605 33 2026 46 2030 605 2026 631 478 40 345 41 41 123 469 418 2031 40 2032 46 2033 40 2011 46 2034 46 2035 40 41 44 2011 46 2036 44 2024 46 2037 40 41 46 2038 40 41 41 41 59 125 125 125 125 450 2019 634 2039 40 2011 44 2013 41 59 125 612 439 491 2008 2018 40 2010 2011 44 2012 2013 41 123 490 2040 61 2011 46 2041 46 2042 40 41 46 2043 40 41 59 392 40 2040 614 478 40 2044 41 41 123 450 418 2045 40 41 59 125 392 40 2040 614 478 40 461 41 41 123 450 418 2046 40 41 59 125 392 40 2040 614 478 40 326 91 93 41 41 123 450 418 2047 40 41 59 125 469 418 2048 40 2049 46 2050 40 2011 46 2051 44 2011 46 2052 46 2053 40 41 44 2040 46 2054 40 41 41 41 59 125 125 
69453,C#,"public abstract class ValueConverter
{
    /// <summary>
    ///     Initializes a new instance of the <see cref=""ValueConverter"" /> class.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    /// <param name=""convertToProviderExpression"">
    ///     The expression to convert objects when writing data to the store,
    ///     exactly as supplied and may not handle
    ///     nulls, boxing, and non-exact matches of simple types.
    /// </param>
    /// <param name=""convertFromProviderExpression"">
    ///     The expression to convert objects when reading data from the store,
    ///     exactly as supplied and may not handle
    ///     nulls, boxing, and non-exact matches of simple types.
    /// </param>
    /// <param name=""mappingHints"">
    ///     Hints that can be used by the <see cref=""ITypeMappingSource"" /> to create data types with appropriate
    ///     facets for the converted data.
    /// </param>
    protected ValueConverter(
        LambdaExpression convertToProviderExpression,
        LambdaExpression convertFromProviderExpression,
        ConverterMappingHints? mappingHints = null)
        : this(convertToProviderExpression, convertFromProviderExpression, false, mappingHints)
    {
    }

    /// <summary>
    ///     <para>
    ///         Initializes a new instance of the <see cref=""ValueConverter"" /> class, allowing conversion of
    ///         nulls.
    ///     </para>
    ///     <para>
    ///         Warning: this is currently an internal API since converting nulls to and from the database can lead to broken
    ///         queries and other issues. See <see href=""https://github.com/dotnet/efcore/issues/26230"">GitHub issue #26230</see>
    ///         for more information and examples.
    ///     </para>
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    /// <param name=""convertToProviderExpression"">
    ///     The expression to convert objects when writing data to the store,
    ///     exactly as supplied and may not handle
    ///     nulls, boxing, and non-exact matches of simple types.
    /// </param>
    /// <param name=""convertFromProviderExpression"">
    ///     The expression to convert objects when reading data from the store,
    ///     exactly as supplied and may not handle
    ///     nulls, boxing, and non-exact matches of simple types.
    /// </param>
    /// <param name=""convertsNulls"">
    ///     If <see langword=""true"" />, then the nulls will be passed to the converter for conversion. Otherwise null
    ///     values always remain null.
    /// </param>
    /// <param name=""mappingHints"">
    ///     Hints that can be used by the <see cref=""ITypeMappingSource"" /> to create data types with appropriate
    ///     facets for the converted data.
    /// </param>
    [EntityFrameworkInternal]
    protected ValueConverter(
        LambdaExpression convertToProviderExpression,
        LambdaExpression convertFromProviderExpression,
        bool convertsNulls,
        ConverterMappingHints? mappingHints = null)
    {
        Check.NotNull(convertToProviderExpression, nameof(convertToProviderExpression));
        Check.NotNull(convertFromProviderExpression, nameof(convertFromProviderExpression));

        ConvertToProviderExpression = convertToProviderExpression;
        ConvertFromProviderExpression = convertFromProviderExpression;
        ConvertsNulls = convertsNulls;
        MappingHints = mappingHints;
    }

    /// <summary>
    ///     Gets the function to convert objects when writing data to the store,
    ///     setup to handle nulls, boxing, and non-exact matches of simple types.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    public abstract Func<object?, object?> ConvertToProvider { get; }

    /// <summary>
    ///     Gets the function to convert objects when reading data from the store,
    ///     setup to handle nulls, boxing, and non-exact matches of simple types.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    public abstract Func<object?, object?> ConvertFromProvider { get; }

    /// <summary>
    ///     Gets the expression to convert objects when writing data to the store,
    ///     exactly as supplied and may not handle
    ///     nulls, boxing, and non-exact matches of simple types.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    public virtual LambdaExpression ConvertToProviderExpression { get; }

    /// <summary>
    ///     Gets the expression to convert objects when reading data from the store,
    ///     exactly as supplied and may not handle
    ///     nulls, boxing, and non-exact matches of simple types.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    public virtual LambdaExpression ConvertFromProviderExpression { get; }

    /// <summary>
    ///     The CLR type used in the EF model.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    public abstract Type ModelClrType { get; }

    /// <summary>
    ///     The CLR type used when reading and writing from the store.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    public abstract Type ProviderClrType { get; }

    /// <summary>
    ///     Hints that can be used by the <see cref=""ITypeMappingSource"" /> to create data types with appropriate
    ///     facets for the converted data.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    public virtual ConverterMappingHints? MappingHints { get; }

    /// <summary>
    ///     If <see langword=""true"" />, then the nulls will be passed to the converter for conversion. Otherwise null
    ///     values always remain null.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         By default, value converters do not handle nulls so that a value converter for a non-nullable property (such as
    ///         a primary key) can be used for correlated nullable properties, such as any corresponding foreign key properties.
    ///     </para>
    ///     <para>
    ///         See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    ///     </para>
    /// </remarks>
    public virtual bool ConvertsNulls { get; }

    /// <summary>
    ///     Checks that the type used with a value converter is supported by that converter and throws if not.
    /// </summary>
    /// <param name=""type"">The type to check.</param>
    /// <param name=""converterType"">The value converter type.</param>
    /// <param name=""supportedTypes"">The types that are supported.</param>
    /// <returns>The given type.</returns>
    protected static Type CheckTypeSupported(
        Type type,
        Type converterType,
        params Type[] supportedTypes)
    {
        Check.NotNull(type, nameof(type));
        Check.NotNull(converterType, nameof(converterType));
        Check.NotEmpty(supportedTypes, nameof(supportedTypes));

        if (!supportedTypes.Contains(type))
        {
            throw new InvalidOperationException(
                CoreStrings.ConverterBadType(
                    converterType.ShortDisplayName(),
                    type.ShortDisplayName(),
                    string.Join("", "", supportedTypes.Select(t => $""'{t.ShortDisplayName()}'""))));
        }

        return type;
    }

    /// <summary>
    ///     Composes another <see cref=""ValueConverter"" /> instance with this one such that
    ///     the result of the first conversion is used as the input to the second conversion.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-value-converters"">EF Core value converters</see> for more information and examples.
    /// </remarks>
    /// <param name=""secondConverter"">The second converter.</param>
    /// <returns>The composed converter.</returns>
    public virtual ValueConverter ComposeWith(
        ValueConverter? secondConverter)
    {
        if (secondConverter == null)
        {
            return this;
        }

        if (ProviderClrType.UnwrapNullableType() != secondConverter.ModelClrType.UnwrapNullableType())
        {
            throw new ArgumentException(
                CoreStrings.ConvertersCannotBeComposed(
                    ModelClrType.ShortDisplayName(),
                    ProviderClrType.ShortDisplayName(),
                    secondConverter.ModelClrType.ShortDisplayName(),
                    secondConverter.ProviderClrType.ShortDisplayName()));
        }

        var firstConverter
            = ProviderClrType.IsNullableType()
            && !secondConverter.ModelClrType.IsNullableType()
                ? ComposeWith(
                    (ValueConverter)Activator.CreateInstance(
                        typeof(CastingConverter<,>).MakeGenericType(
                            ProviderClrType,
                            secondConverter.ModelClrType),
                        MappingHints)!)
                : this;

        return (ValueConverter)Activator.CreateInstance(
            typeof(CompositeValueConverter<,,>).MakeGenericType(
                firstConverter.ModelClrType,
                firstConverter.ProviderClrType,
                secondConverter.ProviderClrType),
            firstConverter,
            secondConverter,
            secondConverter.MappingHints == null
                ? firstConverter.MappingHints
                : secondConverter.MappingHints.With(firstConverter.MappingHints))!;
    }
}",0,439 305 334 2000 123 612 438 2000 40 2001 2002 44 2001 2003 44 2004 63 2005 61 424 41 58 467 40 2002 44 2003 44 380 44 2005 41 123 125 612 91 2006 93 438 2000 40 2001 2002 44 2001 2003 44 323 2007 44 2004 63 2005 61 424 41 123 2008 46 2009 40 2002 44 2010 40 2002 41 41 59 2008 46 2009 40 2003 44 2010 40 2003 41 41 59 2011 61 2002 59 2012 61 2003 59 2013 61 2007 59 2014 61 2005 59 125 612 439 305 2015 60 426 63 44 426 63 62 2016 123 2017 59 125 612 439 305 2015 60 426 63 44 426 63 62 2018 123 2019 59 125 612 439 491 2001 2020 123 2021 59 125 612 439 491 2001 2022 123 2023 59 125 612 439 305 2024 2025 123 2026 59 125 612 439 305 2024 2027 123 2028 59 125 612 439 491 2004 63 2029 123 2030 59 125 612 439 491 323 2031 123 2032 59 125 612 438 457 2024 2033 40 2024 2034 44 2024 2035 44 433 2024 91 93 2036 41 123 2037 46 2038 40 2034 44 2039 40 2034 41 41 59 2037 46 2038 40 2035 44 2039 40 2035 41 41 59 2037 46 2040 40 2036 44 2039 40 2036 41 41 59 392 40 33 2036 46 2041 40 2034 41 41 123 469 418 2042 40 2043 46 2044 40 2035 46 2045 40 41 44 2034 46 2045 40 41 44 461 46 2046 40 648 44 2036 46 2047 40 2048 619 36 648 41 41 41 41 59 125 450 2034 59 125 612 439 491 2000 2049 40 2000 63 2050 41 123 392 40 2050 614 424 41 123 450 467 59 125 392 40 2027 46 2051 40 41 631 2050 46 2025 46 2051 40 41 41 123 469 418 2052 40 2053 46 2054 40 2025 46 2055 40 41 44 2027 46 2055 40 41 44 2050 46 2025 46 2055 40 41 44 2050 46 2027 46 2055 40 41 41 41 59 125 490 2056 61 2027 46 2057 40 41 605 33 2050 46 2025 46 2057 40 41 63 2049 40 40 2000 41 2058 46 2059 40 478 40 2060 60 44 62 41 46 2061 40 2027 44 2050 46 2025 41 44 2029 41 33 41 58 467 59 450 40 2000 41 2058 46 2059 40 478 40 2062 60 44 44 62 41 46 2061 40 2056 46 2025 44 2056 46 2027 44 2050 46 2027 41 44 2056 44 2050 44 2050 46 2029 614 424 63 2056 46 2029 58 2050 46 2029 46 2063 40 2056 46 2029 41 41 33 59 125 125 
69991,C#,"public static class NavigationExtensions
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static MemberIdentity CreateMemberIdentity(this IReadOnlyNavigation? navigation)
    {
        var memberInfo = navigation?.GetIdentifyingMemberInfo();
        return memberInfo == null
            ? MemberIdentity.Create(navigation?.Name)
            : MemberIdentity.Create(memberInfo);
    }
}",0,439 457 334 2000 123 612 439 457 2001 2002 40 467 2003 63 2004 41 123 490 2005 61 2004 634 2006 40 41 59 450 2005 614 424 63 2001 46 2007 40 2004 634 2008 41 58 2001 46 2007 40 2005 41 59 125 125 
68273,C#,"public static class TypeExtensions
{
    /// <summary>
    ///     <para>
    ///         Generates a short, human-readable name of the type such as is suitable for exception messages, etc.
    ///     </para>
    ///     <para>
    ///         Notes that this name should be used for display purposes only. It is not the same string
    ///         as the entity type name in the model.
    ///     </para>
    ///     <para>
    ///         This method is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </summary>
    /// <param name=""type"">The type.</param>
    /// <returns>The human-readable name.</returns>
    public static string ShortDisplayName(this Type type)
        => type.DisplayName(fullName: false);
}",0,439 457 334 2000 123 612 439 457 461 2001 40 467 2002 2003 41 619 2003 46 2004 40 2005 58 380 41 59 125 
70892,C#,"public static class ExpressionExtensions
{
    /// <summary>
    ///     Creates a printable string representation of the given expression.
    /// </summary>
    /// <param name=""expression"">The expression.</param>
    /// <param name=""characterLimit"">An optional limit to the number of characters included. Additional output will be truncated.</param>
    /// <returns>The printable representation.</returns>
    public static string Print(this Expression expression, int? characterLimit = null)
        => new ExpressionPrinter().Print(expression, characterLimit);

    /// <summary>
    ///     Creates a <see cref=""MemberExpression""></see> that represents accessing either a field or a property.
    /// </summary>
    /// <param name=""expression"">An <see cref=""Expression""></see> that represents the object that the member belongs to.</param>
    /// <param name=""member"">The <see cref=""MemberInfo""></see> that describes the field or property to be accessed.</param>
    /// <returns>The <see cref=""MemberExpression""></see> that results from calling the appropriate factory method.</returns>
    public static MemberExpression MakeMemberAccess(
        this Expression? expression,
        MemberInfo member)
    {
        var memberDeclaringClrType = member.DeclaringType;
        if (expression != null
            && memberDeclaringClrType != expression.Type
            && expression.Type.IsAssignableFrom(memberDeclaringClrType))
        {
            expression = Expression.Convert(expression, memberDeclaringClrType);
        }

        return Expression.MakeMemberAccess(expression, member);
    }

    /// <summary>
    ///     Creates a <see cref=""BinaryExpression""></see> that represents an assignment operation.
    /// </summary>
    /// <param name=""memberExpression"">The member to which assignment will be made.</param>
    /// <param name=""valueExpression"">The value that will be assigned.</param>
    /// <returns>The <see cref=""BinaryExpression"" /> representing the assignment binding.</returns>
    public static Expression Assign(
        this MemberExpression memberExpression,
        Expression valueExpression)
    {
        if (memberExpression.Member is FieldInfo fieldInfo
            && fieldInfo.IsInitOnly)
        {
            return (BinaryExpression)Activator.CreateInstance(
                AssignBinaryExpressionType,
                BindingFlags.NonPublic | BindingFlags.Instance,
                null,
                new object[] { memberExpression, valueExpression },
                null)!;
        }

        return Expression.Assign(memberExpression, valueExpression);
    }

    private static readonly Type AssignBinaryExpressionType
        = typeof(Expression).Assembly.GetType(""System.Linq.Expressions.AssignBinaryExpression"", throwOnError: true)!;

    /// <summary>
    ///     If the given a method-call expression represents a call to <see cref=""EF.Property{TProperty}"" />, then this
    ///     method extracts the entity expression and property name.
    /// </summary>
    /// <param name=""methodCallExpression"">The method-call expression for <see cref=""EF.Property{TProperty}"" /></param>
    /// <param name=""entityExpression"">The extracted entity access expression.</param>
    /// <param name=""propertyName"">The accessed property name.</param>
    /// <returns><see langword=""true"" /> if the method-call was for <see cref=""EF.Property{TProperty}"" />; <see langword=""false"" /> otherwise.</returns>
    public static bool TryGetEFPropertyArguments(
        this MethodCallExpression methodCallExpression,
        [NotNullWhen(true)] out Expression? entityExpression,
        [NotNullWhen(true)] out string? propertyName)
    {
        if (methodCallExpression.Method.IsEFPropertyMethod()
            && methodCallExpression.Arguments[1] is ConstantExpression propertyNameExpression)
        {
            entityExpression = methodCallExpression.Arguments[0];
            propertyName = (string)propertyNameExpression.Value!;
            return true;
        }

        (entityExpression, propertyName) = (null, null);
        return false;
    }

    /// <summary>
    ///     If the given a method-call expression represents a call to indexer on the entity, then this
    ///     method extracts the entity expression and property name.
    /// </summary>
    /// <param name=""methodCallExpression"">The method-call expression for indexer.</param>
    /// <param name=""model"">The model to use.</param>
    /// <param name=""entityExpression"">The extracted entity access expression.</param>
    /// <param name=""propertyName"">The accessed property name.</param>
    /// <returns><see langword=""true"" /> if the method-call was for indexer; <see langword=""false"" /> otherwise.</returns>
    public static bool TryGetIndexerArguments(
        this MethodCallExpression methodCallExpression,
        IModel model,
        [NotNullWhen(true)] out Expression? entityExpression,
        [NotNullWhen(true)] out string? propertyName)
    {
        if (model.IsIndexerMethod(methodCallExpression.Method)
            && methodCallExpression.Arguments[0] is ConstantExpression propertyNameExpression)
        {
            entityExpression = methodCallExpression.Object!;
            propertyName = (string)propertyNameExpression.Value!;

            return true;
        }

        (entityExpression, propertyName) = (null, null);
        return false;
    }

    /// <summary>
    ///     Gets the <see cref=""PropertyInfo"" /> represented by a simple property-access expression.
    /// </summary>
    /// <remarks>
    ///     This method is typically used to parse property access lambdas from fluent APIs.
    /// </remarks>
    /// <param name=""propertyAccessExpression"">The expression.</param>
    /// <returns>The <see cref=""PropertyInfo"" />.</returns>
    public static PropertyInfo GetPropertyAccess(this LambdaExpression propertyAccessExpression)
        => GetInternalMemberAccess<PropertyInfo>(propertyAccessExpression);

    /// <summary>
    ///     Gets the <see cref=""MemberInfo"" /> represented by a simple member-access expression.
    /// </summary>
    /// <remarks>
    ///     This method is typically used to parse member access lambdas from fluent APIs.
    /// </remarks>
    /// <param name=""memberAccessExpression"">The expression.</param>
    /// <returns>The <see cref=""MemberInfo"" />.</returns>
    public static MemberInfo GetMemberAccess(this LambdaExpression memberAccessExpression)
        => GetInternalMemberAccess<MemberInfo>(memberAccessExpression);

    private static TMemberInfo GetInternalMemberAccess<TMemberInfo>(this LambdaExpression memberAccessExpression)
        where TMemberInfo : MemberInfo
    {
        Check.DebugAssert(
            memberAccessExpression.Parameters.Count == 1,
            $""Parameters.Count is {memberAccessExpression.Parameters.Count}"");

        var parameterExpression = memberAccessExpression.Parameters[0];
        var memberInfo = parameterExpression.MatchSimpleMemberAccess<TMemberInfo>(memberAccessExpression.Body);

        if (memberInfo == null)
        {
            throw new ArgumentException(
                CoreStrings.InvalidMemberExpression(memberAccessExpression),
                nameof(memberAccessExpression));
        }

        var declaringType = memberInfo.DeclaringType;
        var parameterType = parameterExpression.Type;

        if (declaringType != null
            && declaringType != parameterType
            && declaringType.IsInterface
            && declaringType.IsAssignableFrom(parameterType)
            && memberInfo is PropertyInfo propertyInfo)
        {
            var propertyGetter = propertyInfo.GetMethod;
            var interfaceMapping = parameterType.GetTypeInfo().GetRuntimeInterfaceMap(declaringType);
            var index = Array.FindIndex(interfaceMapping.InterfaceMethods, p => p.Equals(propertyGetter));
            var targetMethod = interfaceMapping.TargetMethods[index];
            foreach (var runtimeProperty in parameterType.GetRuntimeProperties())
            {
                if (targetMethod.Equals(runtimeProperty.GetMethod))
                {
                    return (TMemberInfo)(object)runtimeProperty;
                }
            }
        }

        return memberInfo;
    }

    /// <summary>
    ///     Returns a list of <see cref=""PropertyInfo"" /> extracted from the given simple
    ///     <see cref=""LambdaExpression"" />.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Only simple expressions are supported, such as those used to reference a property.
    ///     </para>
    ///     <para>
    ///         This method is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </remarks>
    /// <param name=""propertyAccessExpression"">The expression.</param>
    /// <returns>The list of referenced properties.</returns>
    public static IReadOnlyList<PropertyInfo> GetPropertyAccessList(this LambdaExpression propertyAccessExpression)
    {
        if (propertyAccessExpression.Parameters.Count != 1)
        {
            throw new ArgumentException(
                CoreStrings.InvalidMembersExpression(propertyAccessExpression),
                nameof(propertyAccessExpression));
        }

        var propertyPaths = propertyAccessExpression
            .MatchMemberAccessList((p, e) => e.MatchSimpleMemberAccess<PropertyInfo>(p));

        if (propertyPaths == null)
        {
            throw new ArgumentException(
                CoreStrings.InvalidMembersExpression(propertyAccessExpression),
                nameof(propertyAccessExpression));
        }

        return propertyPaths;
    }

    /// <summary>
    ///     Returns a list of <see cref=""MemberInfo"" /> extracted from the given simple
    ///     <see cref=""LambdaExpression"" />.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Only simple expressions are supported, such as those used to reference a member.
    ///     </para>
    ///     <para>
    ///         This method is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </remarks>
    /// <param name=""memberAccessExpression"">The expression.</param>
    /// <returns>The list of referenced members.</returns>
    public static IReadOnlyList<MemberInfo> GetMemberAccessList(this LambdaExpression memberAccessExpression)
    {
        var memberPaths = memberAccessExpression
            .MatchMemberAccessList((p, e) => e.MatchSimpleMemberAccess<MemberInfo>(p));

        if (memberPaths == null)
        {
            throw new ArgumentException(
                CoreStrings.InvalidMembersExpression(memberAccessExpression),
                nameof(memberAccessExpression));
        }

        return memberPaths;
    }

    /// <summary>
    ///     <para>
    ///         Creates an <see cref=""Expression"" /> tree representing reading a value from a <see cref=""ValueBuffer"" />
    ///     </para>
    ///     <para>
    ///         This method is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </summary>
    /// <param name=""valueBuffer"">The expression that exposes the <see cref=""ValueBuffer"" />.</param>
    /// <param name=""type"">The type to read.</param>
    /// <param name=""index"">The index in the buffer to read from.</param>
    /// <param name=""property"">The IPropertyBase being read if any.</param>
    /// <returns>An expression to read the value.</returns>
    public static Expression CreateValueBufferReadValueExpression(
        this Expression valueBuffer,
        Type type,
        int index,
        IPropertyBase? property)
        => Expression.Call(
            ValueBufferTryReadValueMethod.MakeGenericMethod(type),
            valueBuffer,
            Expression.Constant(index),
            Expression.Constant(property, typeof(IPropertyBase)));

    /// <summary>
    ///     <para>
    ///         MethodInfo which is used to generate an <see cref=""Expression"" /> tree representing reading a value from a
    ///         <see cref=""ValueBuffer"" />
    ///     </para>
    ///     <para>
    ///         This method is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </summary>
    public static readonly MethodInfo ValueBufferTryReadValueMethod
        = typeof(ExpressionExtensions).GetRequiredDeclaredMethod(nameof(ValueBufferTryReadValue));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static TValue ValueBufferTryReadValue<TValue>(
#pragma warning disable IDE0060 // Remove unused parameter
        in ValueBuffer valueBuffer,
        int index,
        IPropertyBase property)
#pragma warning restore IDE0060 // Remove unused parameter
        => (TValue)valueBuffer[index]!;

    /// <summary>
    ///     <para>
    ///         Creates an <see cref=""Expression"" /> tree representing reading of a key values on given expression.
    ///     </para>
    ///     <para>
    ///         This method is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </summary>
    /// <param name=""target"">The expression that will be root for generated read operation.</param>
    /// <param name=""properties"">The list of properties to use to generate key values.</param>
    /// <param name=""makeNullable"">A value indicating if the key values should be read nullable.</param>
    /// <returns>An expression to read the key values.</returns>
    public static Expression CreateKeyValuesExpression(
        this Expression target,
        IReadOnlyList<IProperty> properties,
        bool makeNullable = false)
        => properties.Count == 1
            ? target.CreateEFPropertyExpression(properties[0], makeNullable)
            : Expression.NewArrayInit(
                typeof(object),
                properties
                    .Select(p => Expression.Convert(target.CreateEFPropertyExpression(p, makeNullable), typeof(object))));

    /// <summary>
    ///     <para>
    ///         Creates an <see cref=""Expression"" /> tree representing EF property access on given expression.
    ///     </para>
    ///     <para>
    ///         This method is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </summary>
    /// <param name=""target"">The expression that will be root for generated read operation.</param>
    /// <param name=""property"">The property to access.</param>
    /// <param name=""makeNullable"">A value indicating if the value can be nullable.</param>
    /// <returns>An expression to access EF property on given expression.</returns>
    public static Expression CreateEFPropertyExpression(
        this Expression target,
        IPropertyBase property,
        bool makeNullable = true) // No shadow entities in runtime
        => CreateEFPropertyExpression(target, property.DeclaringType.ClrType, property.ClrType, property.Name, makeNullable);

    private static Expression CreateEFPropertyExpression(
        Expression target,
        Type propertyDeclaringType,
        Type propertyType,
        string propertyName,
        bool makeNullable)
    {
        if (propertyDeclaringType != target.Type
            && target.Type.IsAssignableFrom(propertyDeclaringType))
        {
            target = Expression.Convert(target, propertyDeclaringType);
        }

        if (makeNullable)
        {
            propertyType = propertyType.MakeNullable();
        }

        return Expression.Call(
            EF.PropertyMethod.MakeGenericMethod(propertyType),
            target,
            Expression.Constant(propertyName));
    }
}",0,439 457 334 2000 123 612 439 457 461 2001 40 467 2002 2003 44 404 63 2004 61 424 41 619 418 2005 40 41 46 2001 40 2003 44 2004 41 59 612 439 457 2006 2007 40 467 2002 63 2003 44 2008 2009 41 123 490 2010 61 2009 46 2011 59 392 40 2003 631 424 605 2010 631 2003 46 2012 605 2003 46 2012 46 2013 40 2010 41 41 123 2003 61 2002 46 2014 40 2003 44 2010 41 59 125 450 2002 46 2007 40 2003 44 2009 41 59 125 612 439 457 2002 2015 40 467 2006 2016 44 2002 2017 41 123 392 40 2016 46 2018 407 2019 2020 605 2020 46 2021 41 123 450 40 2022 41 2023 46 2024 40 2025 44 2026 46 2027 124 2026 46 2028 44 424 44 418 426 91 93 123 2016 44 2017 125 44 424 41 33 59 125 450 2002 46 2015 40 2016 44 2017 41 59 125 437 457 441 2029 2030 61 478 40 2002 41 46 2031 46 2032 40 648 44 2033 58 473 41 33 59 612 439 457 323 2034 40 467 2035 2036 44 91 2037 40 473 41 93 430 2002 63 2038 44 91 2037 40 473 41 93 430 461 63 2039 41 123 392 40 2036 46 2040 46 2041 40 41 605 2036 46 2042 91 1501 93 407 2043 2044 41 123 2038 61 2036 46 2042 91 1500 93 59 2039 61 40 461 41 2044 46 2045 33 59 450 473 59 125 40 2038 44 2039 41 61 40 424 44 424 41 59 450 380 59 125 612 439 457 323 2046 40 467 2035 2036 44 2047 2048 44 91 2037 40 473 41 93 430 2002 63 2038 44 91 2037 40 473 41 93 430 461 63 2039 41 123 392 40 2048 46 2049 40 2036 46 2050 41 605 2036 46 2051 91 1500 93 407 2052 2053 41 123 2038 61 2036 46 2054 33 59 2039 61 40 461 41 2053 46 2055 33 59 450 473 59 125 40 2038 44 2039 41 61 40 424 44 424 41 59 450 380 59 125 612 439 457 2056 2057 40 467 2058 2059 41 619 2060 60 2056 62 40 2059 41 59 612 439 457 2008 2061 40 467 2058 2062 41 619 2060 60 2008 62 40 2062 41 59 437 457 2063 2060 60 2063 62 40 467 2058 2062 41 2064 2063 58 2008 123 2065 46 2066 40 2062 46 2067 46 2068 614 1501 44 36 648 41 59 490 2069 61 2062 46 2067 91 1500 93 59 490 2070 61 2069 46 2071 60 2063 62 40 2062 46 2072 41 59 392 40 2070 614 424 41 123 469 418 2073 40 2074 46 2075 40 2062 41 44 2076 40 2062 41 41 59 125 490 2077 61 2070 46 2078 59 490 2079 61 2069 46 2029 59 392 40 2077 631 424 605 2077 631 2079 605 2077 46 2080 605 2077 46 2081 40 2079 41 605 2070 407 2056 2082 41 123 490 2083 61 2082 46 2084 59 490 2085 61 2079 46 2086 40 41 46 2087 40 2077 41 59 490 2088 61 2089 46 2090 40 2085 46 2091 44 2092 619 2092 46 2093 40 2083 41 41 59 490 2094 61 2085 46 2095 91 2088 93 59 386 40 490 2096 398 2079 46 2097 40 41 41 123 392 40 2094 46 2093 40 2096 46 2084 41 41 123 450 40 2063 41 40 426 41 2096 59 125 125 125 450 2070 59 125 612 439 457 2098 60 2056 62 2099 40 467 2058 2059 41 123 392 40 2059 46 2100 46 2101 631 1501 41 123 469 418 2102 40 2103 46 2104 40 2059 41 44 2105 40 2059 41 41 59 125 490 2106 61 2059 46 2107 40 40 2108 44 2109 41 619 2109 46 2110 60 2056 62 40 2108 41 41 59 392 40 2106 614 424 41 123 469 418 2111 40 2112 46 2113 40 2059 41 44 2114 40 2059 41 41 59 125 450 2106 59 125 612 439 457 2098 60 2008 62 2115 40 467 2058 2062 41 123 490 2116 61 2062 46 2117 40 40 2118 44 2119 41 619 2119 46 2120 60 2008 62 40 2118 41 41 59 392 40 2116 614 424 41 123 469 418 2121 40 2122 46 2123 40 2062 41 44 2124 40 2062 41 41 59 125 450 2116 59 125 612 439 457 2002 2125 40 467 2002 2126 44 2029 2127 44 404 2128 44 2129 63 2130 41 619 2002 46 2131 40 2132 46 2133 40 2127 41 44 2126 44 2002 46 2134 40 2128 41 44 2002 46 2134 40 2130 44 478 40 2129 41 41 41 59 612 439 457 441 2135 2132 61 478 40 2000 41 46 2136 40 2137 40 2138 41 41 59 91 2139 40 2140 46 2141 41 93 437 457 2142 2138 60 2142 62 40 35 435 2143 2144 2145 621 398 2146 2126 44 404 2128 44 2129 2130 41 35 435 2143 2147 2145 621 619 40 2142 41 2126 91 2128 93 33 59 612 439 457 2002 2148 40 467 2002 2149 44 2098 60 2150 62 2151 44 323 2152 61 380 41 619 2151 46 2153 614 1501 63 2149 46 2154 40 2151 91 1500 93 44 2152 41 58 2002 46 2155 40 478 40 426 41 44 2151 46 2156 40 2157 619 2002 46 2158 40 2149 46 2154 40 2157 44 2152 41 44 478 40 426 41 41 41 41 59 612 439 457 2002 2154 40 467 2002 2149 44 2129 2130 44 323 2152 61 473 41 621 619 2154 40 2149 44 2130 46 2159 46 2160 44 2130 46 2160 44 2130 46 2161 44 2152 41 59 437 457 2002 2154 40 2002 2149 44 2029 2162 44 2029 2163 44 461 2039 44 323 2152 41 123 392 40 2162 631 2149 46 2029 605 2149 46 2029 46 2164 40 2162 41 41 123 2149 61 2002 46 2158 40 2149 44 2162 41 59 125 392 40 2152 41 123 2163 61 2163 46 2165 40 41 59 125 450 2002 46 2131 40 2166 46 2167 46 2133 40 2163 41 44 2149 44 2002 46 2134 40 2039 41 41 59 125 125 
68051,C#,"public static class PropertyBaseExtensions
{
    /// <summary>
    ///     Creates a formatted string representation of the given properties such as is useful
    ///     when throwing exceptions about keys, indexes, etc. that use the properties.
    /// </summary>
    /// <param name=""properties"">The properties to format.</param>
    /// <param name=""includeTypes"">If true, then type names are included in the string. The default is <see langword=""false"" />.</param>
    /// <returns>The string representation.</returns>
    public static string Format(this IEnumerable<IReadOnlyPropertyBase> properties, bool includeTypes = false)
        => ""{""
            + string.Join(
                "", "",
                properties.Select(
                    p => ""'"" + p.Name + ""'"" + (includeTypes ? "" : "" + p.ClrType.DisplayName(fullName: false) : """")))
            + ""}"";
}",0,439 457 334 2000 123 612 439 457 461 2001 40 467 2002 60 2003 62 2004 44 323 2005 61 380 41 619 648 43 461 46 2006 40 648 44 2004 46 2007 40 2008 619 648 43 2008 46 2009 43 648 43 40 2005 63 648 43 2008 46 2010 46 2011 40 2012 58 380 41 58 648 41 41 41 43 648 59 125 
69701,C#,"    private sealed class ColumnValuePropagator
    {
        private bool _write;
        private object? _originalValue;
        private object? _currentValue;

        public IColumnModification? ColumnModification { get; set; }

        public void RecordValue(IProperty property, IUpdateEntry entry)
        {
            switch (entry.EntityState)
            {
                case EntityState.Modified:
                    if (!_write
                        && entry.IsModified(property))
                    {
                        _write = true;
                        _currentValue = entry.GetCurrentValue(property);
                    }

                    break;
                case EntityState.Added:
                    _currentValue = entry.GetCurrentValue(property);
                    _write = !property.GetValueComparer().Equals(_originalValue, _currentValue);

                    break;
                case EntityState.Deleted:
                    _originalValue = entry.GetOriginalValue(property);
                    if (!_write
                        && !property.IsPrimaryKey())
                    {
                        _write = true;
                        _currentValue = null;
                    }

                    break;
            }
        }

        public bool TryPropagate(IProperty property, IUpdateEntry entry)
        {
            if (_write
                && (entry.EntityState == EntityState.Unchanged
                    || (entry.EntityState == EntityState.Modified && !entry.IsModified(property))
                    || (entry.EntityState == EntityState.Added
                        && property.GetValueComparer().Equals(_originalValue, entry.GetCurrentValue(property)))))
            {
                entry.SetStoreGeneratedValue(property, _currentValue);

                return false;
            }

            return _write;
        }
    }",0,437 452 334 2000 123 437 323 2001 59 437 426 63 2002 59 437 426 63 2003 59 439 2004 63 2005 123 2006 59 2007 59 125 439 492 2008 40 2009 2010 44 2011 2012 41 123 464 40 2012 46 2013 41 123 328 2013 46 2014 58 392 40 33 2001 605 2012 46 2015 40 2010 41 41 123 2001 61 473 59 2003 61 2012 46 2016 40 2010 41 59 125 325 59 328 2013 46 2017 58 2003 61 2012 46 2018 40 2010 41 59 2001 61 33 2010 46 2019 40 41 46 2020 40 2002 44 2003 41 59 325 59 328 2013 46 2021 58 2002 61 2012 46 2022 40 2010 41 59 392 40 33 2001 605 33 2010 46 2023 40 41 41 123 2001 61 473 59 2003 61 424 59 125 325 59 125 125 439 323 2024 40 2009 2010 44 2011 2012 41 123 392 40 2001 605 40 2012 46 2025 614 2025 46 2026 606 40 2012 46 2025 614 2025 46 2027 605 33 2012 46 2028 40 2010 41 41 606 40 2012 46 2025 614 2025 46 2029 605 2010 46 2030 40 41 46 2031 40 2002 44 2012 46 2032 40 2010 41 41 41 41 41 123 2012 46 2033 40 2010 44 2003 41 59 450 380 59 125 450 2001 59 125 125 
70962,C#,"public static class RelationalTypeMappingSourceExtensions
{
    /// <summary>
    ///     Gets the relational database type for a given object, throwing if no mapping is found.
    /// </summary>
    /// <param name=""typeMappingSource"">The type mapping source.</param>
    /// <param name=""value"">The object to get the mapping for.</param>
    /// <returns>The type mapping to be used.</returns>
    public static RelationalTypeMapping GetMappingForValue(
        this IRelationalTypeMappingSource typeMappingSource,
        object? value)
        => value == null
            || value == DBNull.Value
                ? RelationalTypeMapping.NullMapping
                : typeMappingSource.GetMapping(value.GetType());

    /// <summary>
    ///     Gets the relational database type for a given object, throwing if no mapping is found.
    /// </summary>
    /// <param name=""typeMappingSource"">The type mapping source.</param>
    /// <param name=""value"">The object to get the mapping for.</param>
    /// <param name=""model"">The model.</param>
    /// <returns>The type mapping to be used.</returns>
    public static RelationalTypeMapping GetMappingForValue(
        this IRelationalTypeMappingSource typeMappingSource,
        object? value,
        IModel model)
        => value == null
            || value == DBNull.Value
                ? RelationalTypeMapping.NullMapping
                : typeMappingSource.GetMapping(value.GetType(), model);

    /// <summary>
    ///     Gets the relational database type for a given property, throwing if no mapping is found.
    /// </summary>
    /// <param name=""typeMappingSource"">The type mapping source.</param>
    /// <param name=""property"">The property to get the mapping for.</param>
    /// <returns>The type mapping to be used.</returns>
    public static RelationalTypeMapping GetMapping(
        this IRelationalTypeMappingSource typeMappingSource,
        IProperty property)
    {
        Check.NotNull(property, nameof(property));

        var mapping = typeMappingSource.FindMapping(property);

        if (mapping != null)
        {
            return mapping;
        }

        throw new InvalidOperationException(
            RelationalStrings.UnsupportedPropertyType(
                property.DeclaringEntityType.DisplayName(),
                property.Name,
                property.ClrType.ShortDisplayName()));
    }

    /// <summary>
    ///     Gets the relational database type for a given .NET type, throwing if no mapping is found.
    /// </summary>
    /// <param name=""typeMappingSource"">The type mapping source.</param>
    /// <param name=""clrType"">The type to get the mapping for.</param>
    /// <returns>The type mapping to be used.</returns>
    public static RelationalTypeMapping GetMapping(
        this IRelationalTypeMappingSource typeMappingSource,
        Type clrType)
    {
        Check.NotNull(clrType, nameof(clrType));

        var mapping = typeMappingSource.FindMapping(clrType);
        if (mapping != null)
        {
            return mapping;
        }

        throw new InvalidOperationException(RelationalStrings.UnsupportedType(clrType.ShortDisplayName()));
    }

    /// <summary>
    ///     Gets the relational database type for a given .NET type, throwing if no mapping is found.
    /// </summary>
    /// <param name=""typeMappingSource"">The type mapping source.</param>
    /// <param name=""clrType"">The type to get the mapping for.</param>
    /// <param name=""model"">The model.</param>
    /// <returns>The type mapping to be used.</returns>
    public static RelationalTypeMapping GetMapping(
        this IRelationalTypeMappingSource typeMappingSource,
        Type clrType,
        IModel model)
    {
        Check.NotNull(clrType, nameof(clrType));

        var mapping = typeMappingSource.FindMapping(clrType, model);
        if (mapping != null)
        {
            return mapping;
        }

        throw new InvalidOperationException(RelationalStrings.UnsupportedType(clrType.ShortDisplayName()));
    }

    /// <summary>
    ///     Gets the mapping that represents the given database type, throwing if no mapping is found.
    /// </summary>
    /// <remarks>
    ///     Note that sometimes the same store type can have different mappings; this method returns the default.
    /// </remarks>
    /// <param name=""typeMappingSource"">The type mapping source.</param>
    /// <param name=""typeName"">The type to get the mapping for.</param>
    /// <returns>The type mapping to be used.</returns>
    public static RelationalTypeMapping GetMapping(
        this IRelationalTypeMappingSource typeMappingSource,
        string typeName)
    {
        // Note: Empty string is allowed for store type name because SQLite
        Check.NotNull(typeName, nameof(typeName));

        var mapping = typeMappingSource.FindMapping(typeName);
        if (mapping != null)
        {
            return mapping;
        }

        throw new InvalidOperationException(RelationalStrings.UnsupportedStoreType(typeName));
    }
}",0,439 457 334 2000 123 612 439 457 2001 2002 40 467 2003 2004 44 426 63 2005 41 619 2005 614 424 606 2005 614 2006 46 2007 63 2001 46 2008 58 2004 46 2009 40 2005 46 2010 40 41 41 59 612 439 457 2001 2002 40 467 2003 2004 44 426 63 2005 44 2011 2012 41 619 2005 614 424 606 2005 614 2006 46 2007 63 2001 46 2008 58 2004 46 2009 40 2005 46 2010 40 41 44 2012 41 59 612 439 457 2001 2009 40 467 2003 2004 44 2013 2014 41 123 2015 46 2016 40 2014 44 2017 40 2014 41 41 59 490 2018 61 2004 46 2019 40 2014 41 59 392 40 2018 631 424 41 123 450 2018 59 125 469 418 2020 40 2021 46 2022 40 2014 46 2023 46 2024 40 41 44 2014 46 2025 44 2014 46 2026 46 2027 40 41 41 41 59 125 612 439 457 2001 2009 40 467 2003 2004 44 2028 2029 41 123 2030 46 2031 40 2029 44 2032 40 2029 41 41 59 490 2033 61 2004 46 2034 40 2029 41 59 392 40 2033 631 424 41 123 450 2033 59 125 469 418 2035 40 2036 46 2037 40 2029 46 2038 40 41 41 41 59 125 612 439 457 2001 2009 40 467 2003 2004 44 2028 2029 44 2011 2012 41 123 2039 46 2040 40 2029 44 2041 40 2029 41 41 59 490 2042 61 2004 46 2043 40 2029 44 2012 41 59 392 40 2042 631 424 41 123 450 2042 59 125 469 418 2044 40 2045 46 2046 40 2029 46 2047 40 41 41 41 59 125 612 439 457 2001 2009 40 467 2003 2004 44 461 2048 41 123 621 2049 46 2050 40 2048 44 2051 40 2048 41 41 59 490 2052 61 2004 46 2053 40 2048 41 59 392 40 2052 631 424 41 123 450 2052 59 125 469 418 2054 40 2055 46 2056 40 2048 41 41 59 125 125 
68665,C#,"public class RelationalCommandBuilder : IRelationalCommandBuilder
{
    private readonly List<IRelationalParameter> _parameters = new();
    private readonly IndentedStringBuilder _commandTextBuilder = new();

    /// <summary>
    ///     <para>
    ///         Constructs a new <see cref=""RelationalCommand"" />.
    ///     </para>
    ///     <para>
    ///         This type is typically used by database providers (and other extensions). It is generally
    ///         not used in application code.
    ///     </para>
    /// </summary>
    /// <param name=""dependencies"">Parameter object containing dependencies for this service.</param>
    public RelationalCommandBuilder(
        RelationalCommandBuilderDependencies dependencies)
    {
        Dependencies = dependencies;
    }

    /// <summary>
    ///     Relational provider-specific dependencies for this service.
    /// </summary>
    protected virtual RelationalCommandBuilderDependencies Dependencies { get; }

    /// <summary>
    ///     The source for <see cref=""RelationalTypeMapping"" />s to use.
    /// </summary>
    [Obsolete(""Code trying to add parameter should add type mapped parameter using TypeMappingSource directly."")]
    public virtual IRelationalTypeMappingSource TypeMappingSource
        => Dependencies.TypeMappingSource;

    /// <summary>
    ///     Creates the command.
    /// </summary>
    /// <returns>The newly created command.</returns>
    public virtual IRelationalCommand Build()
        => new RelationalCommand(Dependencies, _commandTextBuilder.ToString(), Parameters);

    /// <summary>
    ///     Gets the command text.
    /// </summary>
    public override string ToString()
        => _commandTextBuilder.ToString();

    /// <summary>
    ///     The collection of parameters.
    /// </summary>
    public virtual IReadOnlyList<IRelationalParameter> Parameters
        => _parameters;

    /// <summary>
    ///     Adds the given parameter to this command.
    /// </summary>
    /// <param name=""parameter"">The parameter.</param>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public virtual IRelationalCommandBuilder AddParameter(IRelationalParameter parameter)
    {
        _parameters.Add(parameter);

        return this;
    }

    /// <summary>
    ///     Appends an object to the command text.
    /// </summary>
    /// <param name=""value"">The object to be written.</param>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public virtual IRelationalCommandBuilder Append(string value)
    {
        _commandTextBuilder.Append(value);

        return this;
    }

    /// <summary>
    ///     Appends a blank line to the command text.
    /// </summary>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public virtual IRelationalCommandBuilder AppendLine()
    {
        _commandTextBuilder.AppendLine();

        return this;
    }

    /// <summary>
    ///     Increments the indent of subsequent lines.
    /// </summary>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public virtual IRelationalCommandBuilder IncrementIndent()
    {
        _commandTextBuilder.IncrementIndent();

        return this;
    }

    /// <summary>
    ///     Decrements the indent of subsequent lines.
    /// </summary>
    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
    public virtual IRelationalCommandBuilder DecrementIndent()
    {
        _commandTextBuilder.DecrementIndent();

        return this;
    }

    /// <summary>
    ///     Gets the length of the command text.
    /// </summary>
    public virtual int CommandTextLength
        => _commandTextBuilder.Length;
}",0,439 334 2000 58 2001 123 437 441 2002 60 2003 62 2004 61 418 40 41 59 437 441 2005 2006 61 418 40 41 59 612 439 2000 40 2007 2008 41 123 2009 61 2008 59 125 612 438 491 2007 2010 123 2011 59 125 612 91 2012 40 648 41 93 439 491 2013 2014 619 2010 46 2014 59 612 439 491 2015 2016 40 41 619 418 2017 40 2010 44 2006 46 2018 40 41 44 2019 41 59 612 439 431 461 2018 40 41 619 2006 46 2018 40 41 59 612 439 491 2020 60 2003 62 2019 619 2004 59 612 439 491 2001 2021 40 2003 2022 41 123 2004 46 2023 40 2022 41 59 450 467 59 125 612 439 491 2001 2024 40 461 2025 41 123 2006 46 2024 40 2025 41 59 450 467 59 125 612 439 491 2001 2026 40 41 123 2006 46 2026 40 41 59 450 467 59 125 612 439 491 2001 2027 40 41 123 2006 46 2027 40 41 59 450 467 59 125 612 439 491 2001 2028 40 41 123 2006 46 2028 40 41 59 450 467 59 125 612 439 491 404 2029 619 2006 46 2030 59 125 
72476,C#,"public class RelationalModelCustomizer : ModelCustomizer
{
    /// <summary>
    ///     Initializes a new instance of the <see cref=""RelationalModelCustomizer"" /> class.
    /// </summary>
    /// <param name=""dependencies"">Parameter object containing dependencies for this service.</param>
    public RelationalModelCustomizer(ModelCustomizerDependencies dependencies)
        : base(dependencies)
    {
    }
}",0,439 334 2000 58 2001 123 612 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 125 
72038,C#,"public class EntityFrameworkRelationalServicesBuilder : EntityFrameworkServicesBuilder
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    /// <remarks>
    ///     This dictionary is exposed for testing and provider-validation only.
    ///     It should not be used from application code.
    /// </remarks>
    [EntityFrameworkInternal]
    public static readonly IDictionary<Type, ServiceCharacteristics> RelationalServices
        = new Dictionary<Type, ServiceCharacteristics>
        {
            { typeof(IKeyValueIndexFactorySource), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IParameterNameGeneratorFactory), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IComparer<IReadOnlyModificationCommand>), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IMigrationsIdGenerator), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(ISqlGenerationHelper), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IRelationalAnnotationProvider), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IMigrationsAnnotationProvider), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IMigrationCommandExecutor), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IRelationalTypeMappingSource), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IRelationalValueBufferFactoryFactory), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IUpdateSqlGenerator), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IRelationalTransactionFactory), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IRelationalCommandBuilderFactory), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IRawSqlCommandBuilder), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IQuerySqlGeneratorFactory), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(IModificationCommandFactory), new ServiceCharacteristics(ServiceLifetime.Singleton) },
            { typeof(ICommandBatchPreparer), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IModificationCommandBatchFactory), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IRelationalSqlTranslatingExpressionVisitorFactory), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IMethodCallTranslatorProvider), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IMemberTranslatorProvider), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(ISqlExpressionFactory), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IRelationalQueryStringFactory), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IRelationalParameterBasedSqlProcessorFactory), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IMigrationsModelDiffer), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IMigrationsSqlGenerator), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IMigrator), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IMigrationsAssembly), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IBatchExecutor), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IRelationalConnection), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IRelationalDatabaseFacadeDependencies), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IRelationalDatabaseCreator), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IHistoryRepository), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(INamedConnectionStringResolver), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IRelationalConnectionDiagnosticsLogger), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IDiagnosticsLogger<DbLoggerCategory.Database.Connection>), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IRelationalCommandDiagnosticsLogger), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            { typeof(IDiagnosticsLogger<DbLoggerCategory.Database.Command>), new ServiceCharacteristics(ServiceLifetime.Scoped) },
            {
                typeof(IRelationalTypeMappingSourcePlugin),
                new ServiceCharacteristics(ServiceLifetime.Singleton, multipleRegistrations: true)
            },
            { typeof(IMethodCallTranslatorPlugin), new ServiceCharacteristics(ServiceLifetime.Scoped, multipleRegistrations: true) },
            { typeof(IMemberTranslatorPlugin), new ServiceCharacteristics(ServiceLifetime.Scoped, multipleRegistrations: true) }
        };

    /// <summary>
    ///     Used by relational database providers to create a new <see cref=""EntityFrameworkRelationalServicesBuilder"" /> for
    ///     registration of provider services.
    /// </summary>
    /// <param name=""serviceCollection"">The collection to which services will be registered.</param>
    public EntityFrameworkRelationalServicesBuilder(IServiceCollection serviceCollection)
        : base(serviceCollection)
    {
    }

    /// <summary>
    ///     Gets the <see cref=""ServiceCharacteristics"" /> for the given service type.
    /// </summary>
    /// <param name=""serviceType"">The type that defines the service API.</param>
    /// <returns>The <see cref=""ServiceCharacteristics"" /> for the type or <see langword=""null"" /> if it's not an EF service.</returns>
    protected override ServiceCharacteristics? TryGetServiceCharacteristics(Type serviceType)
        => RelationalServices.TryGetValue(serviceType, out var characteristics)
            ? characteristics
            : base.TryGetServiceCharacteristics(serviceType);

    /// <summary>
    ///     Registers default implementations of all services, including relational services, not already
    ///     registered by the provider. Relational database providers must call this method as the last
    ///     step of service registration--that is, after all provider services have been registered.
    /// </summary>
    /// <remarks>
    ///     See <see href=""https://aka.ms/efcore-docs-providers"">Implementation of database providers and extensions</see>
    ///     for more information and examples.
    /// </remarks>
    /// <returns>This builder, such that further calls can be chained.</returns>
    public override EntityFrameworkServicesBuilder TryAddCoreServices()
    {
        TryAdd<IParameterNameGeneratorFactory, ParameterNameGeneratorFactory>();
        TryAdd<IComparer<IReadOnlyModificationCommand>, ModificationCommandComparer>();
        TryAdd<IMigrationsIdGenerator, MigrationsIdGenerator>();
        TryAdd<IKeyValueIndexFactorySource, KeyValueIndexFactorySource>();
        TryAdd<IModelCustomizer, RelationalModelCustomizer>();
        TryAdd<IModelRuntimeInitializer, RelationalModelRuntimeInitializer>();
        TryAdd<IRelationalAnnotationProvider, RelationalAnnotationProvider>();
        TryAdd<IMigrationsAnnotationProvider, MigrationsAnnotationProvider>();
        TryAdd<IModelValidator, RelationalModelValidator>();
        TryAdd<IMigrator, Migrator>();
        TryAdd<IMigrationCommandExecutor, MigrationCommandExecutor>();
        TryAdd<IMigrationsAssembly, MigrationsAssembly>();
        TryAdd<IDatabase, RelationalDatabase>();
        TryAdd<IBatchExecutor, BatchExecutor>();
        TryAdd<IValueGeneratorSelector, RelationalValueGeneratorSelector>();
        TryAdd<IRelationalCommandBuilderFactory, RelationalCommandBuilderFactory>();
        TryAdd<IRawSqlCommandBuilder, RawSqlCommandBuilder>();
        TryAdd<ICommandBatchPreparer, CommandBatchPreparer>();
        TryAdd<IModificationCommandFactory, ModificationCommandFactory>();
        TryAdd<IMigrationsModelDiffer, MigrationsModelDiffer>();
        TryAdd<IMigrationsSqlGenerator, MigrationsSqlGenerator>();
        TryAdd<IExecutionStrategyFactory, RelationalExecutionStrategyFactory>();
        TryAdd<ITypeMappingSource>(p => p.GetRequiredService<IRelationalTypeMappingSource>());
        TryAdd<IRelationalValueBufferFactoryFactory, TypedRelationalValueBufferFactoryFactory>();
        TryAdd<IDatabaseCreator>(p => p.GetRequiredService<IRelationalDatabaseCreator>());
        TryAdd<IDbContextTransactionManager>(p => p.GetRequiredService<IRelationalConnection>());
        TryAdd<IQueryContextFactory, RelationalQueryContextFactory>();
        TryAdd<ICompiledQueryCacheKeyGenerator, RelationalCompiledQueryCacheKeyGenerator>();
        TryAdd<INamedConnectionStringResolver, NamedConnectionStringResolver>();
        TryAdd<IEvaluatableExpressionFilter, RelationalEvaluatableExpressionFilter>();
        TryAdd<IRelationalTransactionFactory, RelationalTransactionFactory>();
        TryAdd<IDatabaseFacadeDependencies>(p => p.GetRequiredService<IRelationalDatabaseFacadeDependencies>());
        TryAdd<IRelationalDatabaseFacadeDependencies, RelationalDatabaseFacadeDependencies>();
        TryAdd<IRelationalConnectionDiagnosticsLogger, RelationalConnectionDiagnosticsLogger>();
        TryAdd<IDiagnosticsLogger<DbLoggerCategory.Database.Connection>>(
            p => p.GetRequiredService<IRelationalConnectionDiagnosticsLogger>());
        TryAdd<IRelationalCommandDiagnosticsLogger, RelationalCommandDiagnosticsLogger>();
        TryAdd<IDiagnosticsLogger<DbLoggerCategory.Database.Command>>(p => p.GetRequiredService<IRelationalCommandDiagnosticsLogger>());
        TryAdd<IInterceptorAggregator, DbConnectionInterceptorAggregator>();
        TryAdd<IInterceptorAggregator, DbTransactionInterceptorAggregator>();
        TryAdd<IInterceptorAggregator, DbCommandInterceptorAggregator>();
        TryAdd<IQuerySqlGeneratorFactory, QuerySqlGeneratorFactory>();
        TryAdd<IShapedQueryCompilingExpressionVisitorFactory, RelationalShapedQueryCompilingExpressionVisitorFactory>();
        TryAdd<IQueryableMethodTranslatingExpressionVisitorFactory, RelationalQueryableMethodTranslatingExpressionVisitorFactory>();
        TryAdd<IMethodCallTranslatorProvider, RelationalMethodCallTranslatorProvider>();
        TryAdd<IMemberTranslatorProvider, RelationalMemberTranslatorProvider>();
        TryAdd<IQueryTranslationPostprocessorFactory, RelationalQueryTranslationPostprocessorFactory>();
        TryAdd<IRelationalSqlTranslatingExpressionVisitorFactory, RelationalSqlTranslatingExpressionVisitorFactory>();
        TryAdd<ISqlExpressionFactory, SqlExpressionFactory>();
        TryAdd<IQueryTranslationPreprocessorFactory, RelationalQueryTranslationPreprocessorFactory>();
        TryAdd<IRelationalParameterBasedSqlProcessorFactory, RelationalParameterBasedSqlProcessorFactory>();
        TryAdd<IRelationalQueryStringFactory, RelationalQueryStringFactory>();
        TryAdd<IQueryCompilationContextFactory, RelationalQueryCompilationContextFactory>();

        ServiceCollectionMap.GetInfrastructure()
            .AddDependencySingleton<RelationalSqlGenerationHelperDependencies>()
            .AddDependencySingleton<RelationalTypeMappingSourceDependencies>()
            .AddDependencySingleton<RelationalModelValidatorDependencies>()
            .AddDependencySingleton<UpdateSqlGeneratorDependencies>()
            .AddDependencySingleton<RelationalAnnotationProviderDependencies>()
            .AddDependencySingleton<MigrationsAnnotationProviderDependencies>()
            .AddDependencySingleton<ParameterNameGeneratorDependencies>()
            .AddDependencySingleton<RelationalValueBufferFactoryDependencies>()
            .AddDependencySingleton<RelationalTransactionFactoryDependencies>()
            .AddDependencySingleton<RelationalCommandBuilderDependencies>()
            .AddDependencySingleton<QuerySqlGeneratorDependencies>()
            .AddDependencySingleton<RelationalEvaluatableExpressionFilterDependencies>()
            .AddDependencySingleton<RelationalModelDependencies>()
            .AddDependencySingleton<RelationalModelRuntimeInitializerDependencies>()
            .AddDependencyScoped<MigrationsSqlGeneratorDependencies>()
            .AddDependencyScoped<RelationalConventionSetBuilderDependencies>()
            .AddDependencyScoped<ModificationCommandBatchFactoryDependencies>()
            .AddDependencyScoped<CommandBatchPreparerDependencies>()
            .AddDependencyScoped<RelationalDatabaseCreatorDependencies>()
            .AddDependencyScoped<HistoryRepositoryDependencies>()
            .AddDependencyScoped<RelationalCompiledQueryCacheKeyGeneratorDependencies>()
            .AddDependencyScoped<RelationalMethodCallTranslatorProviderDependencies>()
            .AddDependencyScoped<RelationalMemberTranslatorProviderDependencies>()
            .AddDependencyScoped<SqlExpressionFactoryDependencies>()
            .AddDependencyScoped<RelationalSqlTranslatingExpressionVisitorDependencies>()
            .AddDependencyScoped<RelationalQueryableMethodTranslatingExpressionVisitorDependencies>()
            .AddDependencyScoped<RelationalShapedQueryCompilingExpressionVisitorDependencies>()
            .AddDependencyScoped<RelationalQueryTranslationPreprocessorDependencies>()
            .AddDependencyScoped<RelationalQueryTranslationPostprocessorDependencies>()
            .AddDependencyScoped<RelationalParameterBasedSqlProcessorDependencies>()
            .AddDependencyScoped<RelationalConnectionDependencies>()
            .AddDependencyScoped<RelationalDatabaseDependencies>()
            .AddDependencyScoped<RelationalQueryContextDependencies>()
            .AddDependencyScoped<RelationalQueryCompilationContextDependencies>();

        return base.TryAddCoreServices();
    }
}",0,439 334 2000 58 2001 123 612 91 2002 93 439 457 441 2003 60 2004 44 2005 62 2006 61 418 2007 60 2004 44 2005 62 123 123 478 40 2008 41 44 418 2005 40 2009 46 2010 41 125 44 123 478 40 2011 41 44 418 2005 40 2012 46 2013 41 125 44 123 478 40 2014 60 2015 62 41 44 418 2005 40 2016 46 2017 41 125 44 123 478 40 2018 41 44 418 2005 40 2019 46 2020 41 125 44 123 478 40 2021 41 44 418 2005 40 2022 46 2023 41 125 44 123 478 40 2024 41 44 418 2005 40 2025 46 2026 41 125 44 123 478 40 2027 41 44 418 2005 40 2028 46 2029 41 125 44 123 478 40 2030 41 44 418 2005 40 2031 46 2032 41 125 44 123 478 40 2033 41 44 418 2005 40 2034 46 2035 41 125 44 123 478 40 2036 41 44 418 2005 40 2037 46 2038 41 125 44 123 478 40 2039 41 44 418 2005 40 2040 46 2041 41 125 44 123 478 40 2042 41 44 418 2005 40 2043 46 2044 41 125 44 123 478 40 2045 41 44 418 2005 40 2046 46 2047 41 125 44 123 478 40 2048 41 44 418 2005 40 2049 46 2050 41 125 44 123 478 40 2051 41 44 418 2005 40 2052 46 2053 41 125 44 123 478 40 2054 41 44 418 2005 40 2055 46 2056 41 125 44 123 478 40 2057 41 44 418 2005 40 2058 46 2059 41 125 44 123 478 40 2060 41 44 418 2005 40 2061 46 2062 41 125 44 123 478 40 2063 41 44 418 2005 40 2064 46 2065 41 125 44 123 478 40 2066 41 44 418 2005 40 2067 46 2068 41 125 44 123 478 40 2069 41 44 418 2005 40 2070 46 2071 41 125 44 123 478 40 2072 41 44 418 2005 40 2073 46 2074 41 125 44 123 478 40 2075 41 44 418 2005 40 2076 46 2077 41 125 44 123 478 40 2078 41 44 418 2005 40 2079 46 2080 41 125 44 123 478 40 2081 41 44 418 2005 40 2082 46 2083 41 125 44 123 478 40 2084 41 44 418 2005 40 2085 46 2086 41 125 44 123 478 40 2087 41 44 418 2005 40 2088 46 2089 41 125 44 123 478 40 2090 41 44 418 2005 40 2091 46 2092 41 125 44 123 478 40 2093 41 44 418 2005 40 2094 46 2095 41 125 44 123 478 40 2096 41 44 418 2005 40 2097 46 2098 41 125 44 123 478 40 2099 41 44 418 2005 40 2100 46 2101 41 125 44 123 478 40 2102 41 44 418 2005 40 2103 46 2104 41 125 44 123 478 40 2105 41 44 418 2005 40 2106 46 2107 41 125 44 123 478 40 2108 41 44 418 2005 40 2109 46 2110 41 125 44 123 478 40 2111 41 44 418 2005 40 2112 46 2113 41 125 44 123 478 40 2114 60 2115 46 2116 46 2117 62 41 44 418 2005 40 2118 46 2119 41 125 44 123 478 40 2120 41 44 418 2005 40 2121 46 2122 41 125 44 123 478 40 2123 60 2124 46 2125 46 2126 62 41 44 418 2005 40 2127 46 2128 41 125 44 123 478 40 2129 41 44 418 2005 40 2130 46 2131 44 2132 58 473 41 125 44 123 478 40 2133 41 44 418 2005 40 2134 46 2135 44 2136 58 473 41 125 44 123 478 40 2137 41 44 418 2005 40 2138 46 2139 44 2140 58 473 41 125 125 59 612 439 2000 40 2141 2142 41 58 320 40 2142 41 123 125 612 438 431 2005 63 2143 40 2004 2144 41 619 2006 46 2145 40 2144 44 430 490 2146 41 63 2146 58 320 46 2143 40 2144 41 59 612 439 431 2001 2147 40 41 123 2148 60 2149 44 2150 62 40 41 59 2148 60 2151 60 2152 62 44 2153 62 40 41 59 2148 60 2154 44 2155 62 40 41 59 2148 60 2156 44 2157 62 40 41 59 2148 60 2158 44 2159 62 40 41 59 2148 60 2160 44 2161 62 40 41 59 2148 60 2162 44 2163 62 40 41 59 2148 60 2164 44 2165 62 40 41 59 2148 60 2166 44 2167 62 40 41 59 2148 60 2168 44 2169 62 40 41 59 2148 60 2170 44 2171 62 40 41 59 2148 60 2172 44 2173 62 40 41 59 2148 60 2174 44 2175 62 40 41 59 2148 60 2176 44 2177 62 40 41 59 2148 60 2178 44 2179 62 40 41 59 2148 60 2180 44 2181 62 40 41 59 2148 60 2182 44 2183 62 40 41 59 2148 60 2184 44 2185 62 40 41 59 2148 60 2186 44 2187 62 40 41 59 2148 60 2188 44 2189 62 40 41 59 2148 60 2190 44 2191 62 40 41 59 2148 60 2192 44 2193 62 40 41 59 2148 60 2194 62 40 2195 619 2195 46 2196 60 2197 62 40 41 41 59 2148 60 2198 44 2199 62 40 41 59 2148 60 2200 62 40 2195 619 2195 46 2196 60 2201 62 40 41 41 59 2148 60 2202 62 40 2195 619 2195 46 2196 60 2203 62 40 41 41 59 2148 60 2204 44 2205 62 40 41 59 2148 60 2206 44 2207 62 40 41 59 2148 60 2208 44 2209 62 40 41 59 2148 60 2210 44 2211 62 40 41 59 2148 60 2212 44 2213 62 40 41 59 2148 60 2214 62 40 2195 619 2195 46 2196 60 2215 62 40 41 41 59 2148 60 2215 44 2216 62 40 41 59 2148 60 2217 44 2218 62 40 41 59 2148 60 2219 60 2220 46 2221 46 2222 640 40 2195 619 2195 46 2196 60 2217 62 40 41 41 59 2148 60 2223 44 2224 62 40 41 59 2148 60 2219 60 2220 46 2221 46 2225 640 40 2195 619 2195 46 2196 60 2223 62 40 41 41 59 2148 60 2226 44 2227 62 40 41 59 2148 60 2226 44 2228 62 40 41 59 2148 60 2226 44 2229 62 40 41 59 2148 60 2230 44 2231 62 40 41 59 2148 60 2232 44 2233 62 40 41 59 2148 60 2234 44 2235 62 40 41 59 2148 60 2236 44 2237 62 40 41 59 2148 60 2238 44 2239 62 40 41 59 2148 60 2240 44 2241 62 40 41 59 2148 60 2242 44 2243 62 40 41 59 2148 60 2244 44 2245 62 40 41 59 2148 60 2246 44 2247 62 40 41 59 2148 60 2248 44 2249 62 40 41 59 2148 60 2250 44 2251 62 40 41 59 2148 60 2252 44 2253 62 40 41 59 2254 46 2255 40 41 46 2256 60 2257 62 40 41 46 2256 60 2258 62 40 41 46 2256 60 2259 62 40 41 46 2256 60 2260 62 40 41 46 2256 60 2261 62 40 41 46 2256 60 2262 62 40 41 46 2256 60 2263 62 40 41 46 2256 60 2264 62 40 41 46 2256 60 2265 62 40 41 46 2256 60 2266 62 40 41 46 2256 60 2267 62 40 41 46 2256 60 2268 62 40 41 46 2256 60 2269 62 40 41 46 2256 60 2270 62 40 41 46 2271 60 2272 62 40 41 46 2271 60 2273 62 40 41 46 2271 60 2274 62 40 41 46 2271 60 2275 62 40 41 46 2271 60 2276 62 40 41 46 2271 60 2277 62 40 41 46 2271 60 2278 62 40 41 46 2271 60 2279 62 40 41 46 2271 60 2280 62 40 41 46 2271 60 2281 62 40 41 46 2271 60 2282 62 40 41 46 2271 60 2283 62 40 41 46 2271 60 2284 62 40 41 46 2271 60 2285 62 40 41 46 2271 60 2286 62 40 41 46 2271 60 2287 62 40 41 46 2271 60 2288 62 40 41 46 2271 60 2289 62 40 41 46 2271 60 2290 62 40 41 46 2271 60 2291 62 40 41 59 450 320 46 2147 40 41 59 125 125 
68449,C#,"public static class DatabaseColumnExtensions
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static string DisplayName(this DatabaseColumn column)
    {
        var tablePrefix = column.Table?.DisplayName();
        return (!string.IsNullOrEmpty(tablePrefix) ? tablePrefix + ""."" : """") + column.Name;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static bool IsKeyOrIndex(this DatabaseColumn column)
    {
        var table = column.Table;

        return table.PrimaryKey?.Columns.Contains(column) == true
            || (table.UniqueConstraints.Any(uc => uc.Columns.Contains(column))
                || table.Indexes.Any(uc => uc.Columns.Contains(column)));
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static bool IsRowVersion(this DatabaseColumn column)
        => column.ValueGenerated == ValueGenerated.OnAddOrUpdate
            && (bool?)column[ScaffoldingAnnotationNames.ConcurrencyToken] == true;
}",0,439 457 334 2000 123 612 439 457 461 2001 40 467 2002 2003 41 123 490 2004 61 2003 46 2005 634 2001 40 41 59 450 40 33 461 46 2006 40 2004 41 63 2004 43 648 58 648 41 43 2003 46 2007 59 125 612 439 457 323 2008 40 467 2002 2003 41 123 490 2009 61 2003 46 2010 59 450 2009 46 2011 634 2012 46 2013 40 2003 41 614 473 606 40 2009 46 2014 46 2015 40 2016 619 2016 46 2012 46 2013 40 2003 41 41 606 2009 46 2017 46 2015 40 2016 619 2016 46 2012 46 2013 40 2003 41 41 41 59 125 612 439 457 323 2018 40 467 2002 2003 41 619 2003 46 2019 614 2019 46 2020 605 40 323 63 41 2003 91 2021 46 2022 93 614 473 59 125 
69844,C#,"public abstract class LanguageBasedSelector<T>
    where T : ILanguageBasedService
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected LanguageBasedSelector(IEnumerable<T> services)
    {
        Services = services;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected virtual IEnumerable<T> Services { get; }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual T Select(string? language)
        => Select(language, Services);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected virtual T Select(string? language, IEnumerable<T> services)
    {
        if (string.IsNullOrEmpty(language))
        {
            language = ""C#"";
        }

        var legacyService = services.LastOrDefault(s => s.Language == null);
        if (legacyService != null)
        {
            return legacyService;
        }

        var matches = services.Where(s => string.Equals(s.Language, language, StringComparison.OrdinalIgnoreCase)).ToList();
        if (matches.Count == 0)
        {
            throw new OperationException(DesignStrings.NoLanguageService(language, typeof(T).ShortDisplayName()));
        }

        return matches.Last();
    }
}",0,439 305 334 2000 60 2001 62 2002 2001 58 2003 123 612 438 2000 40 2004 60 2001 62 2005 41 123 2006 61 2005 59 125 612 438 491 2004 60 2001 62 2007 123 2008 59 125 612 439 491 2001 2009 40 461 63 2010 41 619 2009 40 2010 44 2007 41 59 612 438 491 2001 2009 40 461 63 2010 44 2004 60 2001 62 2005 41 123 392 40 461 46 2011 40 2010 41 41 123 2010 61 648 59 125 490 2012 61 2005 46 2013 40 2014 619 2014 46 2015 614 424 41 59 392 40 2012 631 424 41 123 450 2012 59 125 490 2016 61 2005 46 2017 40 2014 619 461 46 2018 40 2014 46 2015 44 2010 44 2019 46 2020 41 41 46 2021 40 41 59 392 40 2016 46 2022 614 1500 41 123 469 418 2023 40 2024 46 2025 40 2010 44 478 40 2001 41 46 2026 40 41 41 41 59 125 450 2016 46 2027 40 41 59 125 125 
72207,C#,"    private class Post
    {
        private readonly ILazyLoader _loader;
        private Blog _blog;

        public Post()
        {
        }

        private Post(ILazyLoader loader)
        {
            _loader = loader;
        }

        public int PostId { get; set; }
        public string Title { get; set; }
        public int? BlogId { get; set; }

        public Blog Blog
        {
            get => _loader.Load(this, ref _blog);
            set => _blog = value;
        }
    }",0,437 334 2000 123 437 441 2001 2002 59 437 2003 2004 59 439 2000 40 41 123 125 437 2000 40 2001 2005 41 123 2002 61 2005 59 125 439 404 2006 123 2007 59 2008 59 125 439 461 2009 123 2010 59 2011 59 125 439 404 63 2012 123 2013 59 2014 59 125 439 2003 2003 123 2015 619 2002 46 2016 40 467 44 442 2004 41 59 2017 619 2004 61 2018 59 125 125 
72203,C#,"    protected class ApplicationUser
    {
        private readonly SomeOwnedEntity _ownedEntity;

        public ApplicationUser()
        {
            _ownedEntity = null!;
        }

        public virtual long Id { get; set; }

        public virtual SomeOwnedEntity OwnedEntity
            => _ownedEntity;

        public Guid Guid { get; set; }
    }",0,438 334 2000 123 437 441 2001 2002 59 439 2000 40 41 123 2002 61 424 33 59 125 439 491 413 2003 123 2004 59 2005 59 125 439 491 2001 2006 619 2002 59 439 2007 2007 123 2008 59 2009 59 125 125 
72204,C#,"    private class Blog
    {
        private readonly Action<object, string> _loader;
        private ICollection<Post> _posts;

        public Blog()
        {
        }

        private Blog(Action<object, string> lazyLoader)
        {
            _loader = lazyLoader;
        }

        public int BlogId { get; set; }
        public string Url { get; set; }

        public ICollection<Post> Posts
        {
            get => _loader.Load(this, ref _posts);
            set => _posts = value;
        }
    }",0,437 334 2000 123 437 441 2001 60 426 44 461 62 2002 59 437 2003 60 2004 62 2005 59 439 2000 40 41 123 125 437 2000 40 2001 60 426 44 461 62 2006 41 123 2002 61 2006 59 125 439 404 2007 123 2008 59 2009 59 125 439 461 2010 123 2011 59 2012 59 125 439 2003 60 2004 62 2013 123 2014 619 2002 46 2015 40 467 44 442 2005 41 59 2016 619 2005 61 2017 59 125 125 
72208,C#,"    protected class SomeEntity
    {
        public SomeEntity(long id, Guid guid)
        {
            Id = id;
            Guid = guid;
        }

        public virtual SomeOwnedEntity OwnedEntity { get; } = new();

        public Guid Guid { get; protected set; }

        public long Id { get; protected set; }
    }",0,438 334 2000 123 439 2000 40 413 2001 44 2002 2003 41 123 2004 61 2001 59 2002 61 2003 59 125 439 491 2005 2006 123 2007 59 125 61 418 40 41 59 439 2002 2002 123 2008 59 438 2009 59 125 439 413 2010 123 2011 59 438 2012 59 125 125 
71282,C#,"public class ExpressionEqualityComparerTest
{
    [ConditionalFact]
    public void Member_init_expressions_are_compared_correctly()
    {
        var expressionComparer = ExpressionEqualityComparer.Instance;

        var addMethod = typeof(List<string>).GetTypeInfo().GetDeclaredMethod(""Add"");

        var bindingMessages = Expression.ListBind(
            typeof(Node).GetProperty(""Messages""),
            Expression.ElementInit(addMethod, Expression.Constant(""Constant1""))
        );

        var bindingDescriptions = Expression.ListBind(
            typeof(Node).GetProperty(""Descriptions""),
            Expression.ElementInit(addMethod, Expression.Constant(""Constant2""))
        );

        Expression e1 = Expression.MemberInit(
            Expression.New(typeof(Node)),
            new List<MemberBinding> { bindingMessages }
        );

        Expression e2 = Expression.MemberInit(
            Expression.New(typeof(Node)),
            new List<MemberBinding> { bindingMessages, bindingDescriptions }
        );

        Assert.NotEqual(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e2));
        Assert.False(expressionComparer.Equals(e1, e2));
        Assert.Equal(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e1));
        Assert.True(expressionComparer.Equals(e1, e1));
    }

    [ConditionalFact]
    public void Default_expressions_are_compared_correctly()
    {
        var expressionComparer = ExpressionEqualityComparer.Instance;

        Expression e1 = Expression.Default(typeof(int));
        Expression e2 = Expression.Default(typeof(int));
        Expression e3 = Expression.Default(typeof(string));

        Assert.Equal(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e2));
        Assert.NotEqual(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e3));
        Assert.True(expressionComparer.Equals(e1, e2));
        Assert.False(expressionComparer.Equals(e1, e3));
        Assert.Equal(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e1));
        Assert.True(expressionComparer.Equals(e1, e1));
    }

    [ConditionalFact]
    public void Index_expressions_are_compared_correctly()
    {
        var expressionComparer = ExpressionEqualityComparer.Instance;

        var param = Expression.Parameter(typeof(Indexable));
        var prop = typeof(Indexable).GetProperty(""Item"");
        var e1 = Expression.MakeIndex(param, prop, new Expression[] { Expression.Constant(1) });
        var e2 = Expression.MakeIndex(param, prop, new Expression[] { Expression.Constant(2) });
        var e3 = Expression.MakeIndex(param, prop, new Expression[] { Expression.Constant(2) });

        Assert.Equal(ExpressionType.Index, e1.NodeType);
        Assert.NotNull(e1.Indexer);
        Assert.Equal(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e1));
        Assert.True(expressionComparer.Equals(e1, e1));
        Assert.NotEqual(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e2));
        Assert.False(expressionComparer.Equals(e1, e2));
        Assert.Equal(expressionComparer.GetHashCode(e2), expressionComparer.GetHashCode(e3));
        Assert.True(expressionComparer.Equals(e2, e3));

        param = Expression.Parameter(typeof(int[]));
        e1 = Expression.ArrayAccess(param, Expression.Constant(1));
        e2 = Expression.ArrayAccess(param, Expression.Constant(2));
        e3 = Expression.ArrayAccess(param, Expression.Constant(2));

        Assert.Equal(ExpressionType.Index, e1.NodeType);
        Assert.Null(e1.Indexer);
        Assert.Equal(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e1));
        Assert.True(expressionComparer.Equals(e1, e1));
        Assert.NotEqual(expressionComparer.GetHashCode(e1), expressionComparer.GetHashCode(e2));
        Assert.False(expressionComparer.Equals(e1, e2));
        Assert.Equal(expressionComparer.GetHashCode(e2), expressionComparer.GetHashCode(e3));
        Assert.True(expressionComparer.Equals(e2, e3));
    }

    private class Node
    {
        [UsedImplicitly]
        public List<string> Messages { set; get; }

        [UsedImplicitly]
        public List<string> Descriptions { set; get; }
    }

    private class Indexable
    {
        public int this[int index]
            => 0;
    }
}",0,439 334 2000 123 91 2001 93 439 492 2002 40 41 123 490 2003 61 2004 46 2005 59 490 2006 61 478 40 2007 60 461 62 41 46 2008 40 41 46 2009 40 648 41 59 490 2010 61 2011 46 2012 40 478 40 2013 41 46 2014 40 648 41 44 2011 46 2015 40 2006 44 2011 46 2016 40 648 41 41 41 59 490 2017 61 2011 46 2012 40 478 40 2013 41 46 2014 40 648 41 44 2011 46 2015 40 2006 44 2011 46 2016 40 648 41 41 41 59 2011 2018 61 2011 46 2019 40 2011 46 2020 40 478 40 2013 41 41 44 418 2007 60 2021 62 123 2010 125 41 59 2011 2022 61 2011 46 2019 40 2011 46 2020 40 478 40 2013 41 41 44 418 2007 60 2021 62 123 2010 44 2017 125 41 59 2023 46 2024 40 2003 46 2025 40 2018 41 44 2003 46 2025 40 2022 41 41 59 2023 46 302 40 2003 46 2026 40 2018 44 2022 41 41 59 2023 46 2027 40 2003 46 2025 40 2018 41 44 2003 46 2025 40 2018 41 41 59 2023 46 304 40 2003 46 2026 40 2018 44 2018 41 41 59 125 91 2001 93 439 492 2028 40 41 123 490 2029 61 2030 46 2031 59 2032 2033 61 2032 46 2034 40 478 40 404 41 41 59 2032 2035 61 2032 46 2034 40 478 40 404 41 41 59 2032 2036 61 2032 46 2034 40 478 40 461 41 41 59 2037 46 2038 40 2029 46 2039 40 2033 41 44 2029 46 2039 40 2035 41 41 59 2037 46 2040 40 2029 46 2039 40 2033 41 44 2029 46 2039 40 2036 41 41 59 2037 46 304 40 2029 46 2041 40 2033 44 2035 41 41 59 2037 46 302 40 2029 46 2041 40 2033 44 2036 41 41 59 2037 46 2038 40 2029 46 2039 40 2033 41 44 2029 46 2039 40 2033 41 41 59 2037 46 304 40 2029 46 2041 40 2033 44 2033 41 41 59 125 91 2001 93 439 492 2042 40 41 123 490 2043 61 2044 46 2045 59 490 2046 61 2047 46 2048 40 478 40 2049 41 41 59 490 2050 61 478 40 2049 41 46 2051 40 648 41 59 490 2052 61 2047 46 2053 40 2046 44 2050 44 418 2047 91 93 123 2047 46 2054 40 1501 41 125 41 59 490 2055 61 2047 46 2053 40 2046 44 2050 44 418 2047 91 93 123 2047 46 2056 40 1502 41 125 41 59 490 2057 61 2047 46 2053 40 2046 44 2050 44 418 2047 91 93 123 2047 46 2058 40 1502 41 125 41 59 2059 46 2060 40 2061 46 2062 44 2052 46 2063 41 59 2059 46 2064 40 2052 46 2065 41 59 2059 46 2060 40 2043 46 2066 40 2052 41 44 2043 46 2066 40 2052 41 41 59 2059 46 304 40 2043 46 2067 40 2052 44 2052 41 41 59 2059 46 2068 40 2043 46 2066 40 2052 41 44 2043 46 2066 40 2055 41 41 59 2059 46 302 40 2043 46 2067 40 2052 44 2055 41 41 59 2059 46 2060 40 2043 46 2066 40 2055 41 44 2043 46 2066 40 2057 41 41 59 2059 46 304 40 2043 46 2067 40 2055 44 2057 41 41 59 2046 61 2047 46 2048 40 478 40 404 91 93 41 41 59 2052 61 2047 46 2069 40 2046 44 2047 46 2070 40 1501 41 41 59 2055 61 2047 46 2069 40 2046 44 2047 46 2070 40 1502 41 41 59 2057 61 2047 46 2069 40 2046 44 2047 46 2070 40 1502 41 41 59 2059 46 2060 40 2061 46 2062 44 2052 46 2063 41 59 2059 46 2071 40 2052 46 2065 41 59 2059 46 2060 40 2043 46 2066 40 2052 41 44 2043 46 2066 40 2052 41 41 59 2059 46 304 40 2043 46 2067 40 2052 44 2052 41 41 59 2059 46 2068 40 2043 46 2066 40 2052 41 44 2043 46 2066 40 2055 41 41 59 2059 46 302 40 2043 46 2067 40 2052 44 2055 41 41 59 2059 46 2060 40 2043 46 2066 40 2055 41 44 2043 46 2066 40 2057 41 41 59 2059 46 304 40 2043 46 2067 40 2055 44 2057 41 41 59 125 437 334 2072 123 91 2073 93 439 2074 60 461 62 2075 123 2076 59 2077 59 125 91 2073 93 439 2074 60 461 62 2078 123 2079 59 2080 59 125 125 437 334 2081 123 439 404 467 91 404 2082 93 619 1500 59 125 125 
70154,C#,"    private class ReplacementTypeMappingSource : SqliteTypeMappingSource
    {
        public ReplacementTypeMappingSource(
            TypeMappingSourceDependencies dependencies,
            RelationalTypeMappingSourceDependencies relationalDependencies)
            : base(dependencies, relationalDependencies)
        {
        }

        protected override RelationalTypeMapping FindMapping(in RelationalTypeMappingInfo mappingInfo)
            => mappingInfo.ClrType == typeof(GeoPoint)
                ? ((RelationalTypeMapping)base.FindMapping(typeof(Point))
                    .Clone(new GeoPointConverter()))
                .Clone(""geometry"", null)
                : base.FindMapping(mappingInfo);
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 2005 41 58 320 40 2003 44 2005 41 123 125 438 431 2006 2007 40 398 2008 2009 41 619 2009 46 2010 614 478 40 2011 41 63 40 40 2006 41 320 46 2007 40 478 40 2012 41 41 46 2013 40 418 2014 40 41 41 41 46 2013 40 648 44 424 41 58 320 46 2007 40 2009 41 59 125 
68799,C#,"    protected class FakeValueConverter : ValueConverter<object, object>
    {
        public FakeValueConverter()
            : base(_ => _, _ => _)
        {
        }

        public override Type ModelClrType { get; } = typeof(object);
        public override Type ProviderClrType { get; } = typeof(object);
    }",0,438 334 2000 58 2001 60 426 44 426 62 123 439 2000 40 41 58 320 40 2002 619 2002 44 2002 619 2002 41 123 125 439 431 2003 2004 123 2005 59 125 61 478 40 426 41 59 439 431 2003 2006 123 2007 59 125 61 478 40 426 41 59 125 
70864,C#,"public class SpatialQuerySqlServerFixture : SpatialQueryRelationalFixture
{
    protected override ITestStoreFactory TestStoreFactory
        => SqlServerTestStoreFactory.Instance;

    protected override IServiceCollection AddServices(IServiceCollection serviceCollection)
        => base.AddServices(serviceCollection)
            .AddEntityFrameworkSqlServerNetTopologySuite();

    public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder builder)
    {
        var optionsBuilder = base.AddOptions(builder);
        new SqlServerDbContextOptionsBuilder(optionsBuilder).UseNetTopologySuite();

        return optionsBuilder;
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext context)
    {
        base.OnModelCreating(modelBuilder, context);

        modelBuilder.HasDbFunction(
            typeof(GeoExtensions).GetMethod(nameof(GeoExtensions.Distance)),
            b => b.HasTranslation(
                e => new SqlFunctionExpression(
                    instance: e[0],
                    ""STDistance"",
                    arguments: e.Skip(1),
                    nullable: true,
                    instancePropagatesNullability: true,
                    argumentsPropagateNullability: e.Skip(1).Select(a => true),
                    typeof(double),
                    null)));
    }
}",0,439 334 2000 58 2001 123 438 431 2002 2003 619 2004 46 2005 59 438 431 2006 2007 40 2006 2008 41 619 320 46 2007 40 2008 41 46 2009 40 41 59 439 431 2010 2011 40 2010 2012 41 123 490 2013 61 320 46 2011 40 2012 41 59 418 2014 40 2013 41 46 2015 40 41 59 450 2013 59 125 438 431 492 2016 40 2017 2018 44 2019 2020 41 123 320 46 2016 40 2018 44 2020 41 59 2018 46 2021 40 478 40 2022 41 46 2023 40 2024 40 2022 46 2025 41 41 44 2026 619 2026 46 2027 40 2028 619 418 2029 40 2030 58 2028 91 1500 93 44 648 44 2031 58 2028 46 2032 40 1501 41 44 2033 58 473 44 2034 58 473 44 2035 58 2028 46 2032 40 1501 41 46 2036 40 2037 619 473 41 44 478 40 356 41 44 424 41 41 41 59 125 125 
69828,C#,"    public class SqlServerDatabaseModelFixture : SharedStoreFixtureBase<PoolableDbContext>
    {
        protected override string StoreName { get; } = nameof(SqlServerDatabaseModelFactoryTest);

        protected override ITestStoreFactory TestStoreFactory
            => SqlServerTestStoreFactory.Instance;

        public new SqlServerTestStore TestStore
            => (SqlServerTestStore)base.TestStore;

        public TestOperationReporter OperationReporter { get; } = new();

        public override async Task InitializeAsync()
        {
            await base.InitializeAsync();
            await TestStore.ExecuteNonQueryAsync(""CREATE SCHEMA db2"");
            await TestStore.ExecuteNonQueryAsync(""CREATE SCHEMA [db.2]"");
        }

        protected override bool ShouldLogCategory(string logCategory)
            => logCategory == DbLoggerCategory.Scaffolding.Name;
    }",0,439 334 2000 58 2001 60 2002 62 123 438 431 461 2003 123 2004 59 125 61 2005 40 2006 41 59 438 431 2007 2008 619 2009 46 2010 59 439 418 2011 2012 619 40 2011 41 320 46 2012 59 439 2013 2014 123 2015 59 125 61 418 40 41 59 439 431 314 2016 2017 40 41 123 319 320 46 2017 40 41 59 319 2012 46 2018 40 648 41 59 319 2012 46 2018 40 648 41 59 125 438 431 323 2019 40 461 2020 41 619 2020 614 2021 46 2022 46 2023 59 125 
68801,C#,"    private class MismatchedFruityContext : FruityContext
    {
        public MismatchedFruityContext(DbContextOptions options)
            : base(options)
        {
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Banana>().Property(e => e.Id).HasConversion<short>();
            modelBuilder.Entity<Kiwi>().Property(e => e.Id).HasConversion<int>();
            modelBuilder.Entity<Kiwi>().HasOne(e => e.Banana).WithMany(e => e.Kiwis).HasForeignKey(e => e.Id);
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 438 431 492 2004 40 2005 2006 41 123 320 46 2004 40 2006 41 59 2006 46 2007 60 2008 62 40 41 46 2009 40 2010 619 2010 46 2011 41 46 2012 60 453 62 40 41 59 2006 46 2007 60 2013 62 40 41 46 2009 40 2010 619 2010 46 2011 41 46 2012 60 404 62 40 41 59 2006 46 2007 60 2013 62 40 41 46 2014 40 2010 619 2010 46 2008 41 46 2015 40 2010 619 2010 46 2016 41 46 2017 40 2010 619 2010 46 2011 41 59 125 125 
68797,C#,"    private class FakeTypeMapping : RelationalTypeMapping
    {
        private FakeTypeMapping(RelationalTypeMappingParameters parameters)
            : base(parameters)
        {
        }

        public FakeTypeMapping()
            : base(""storeType"", typeof(object))
        {
        }

        public static object CreateParameters(
            Type type,
            int? size = null,
            bool unicode = false,
            bool fixedLength = false,
            StoreTypePostfix storeTypePostfix = StoreTypePostfix.PrecisionAndScale)
            => new RelationalTypeMappingParameters(
                new CoreTypeMappingParameters(
                    type,
                    new FakeValueConverter(),
                    new FakeValueComparer(),
                    new FakeValueComparer()),
                ""<original>"",
                storeTypePostfix,
                System.Data.DbType.VarNumeric,
                size: size,
                unicode: unicode,
                fixedLength: fixedLength);

        protected override RelationalTypeMapping Clone(RelationalTypeMappingParameters parameters)
            => new FakeTypeMapping(parameters);
    }",0,437 334 2000 58 2001 123 437 2000 40 2002 2003 41 58 320 40 2003 41 123 125 439 2000 40 41 58 320 40 648 44 478 40 426 41 41 123 125 439 457 426 2004 40 2005 2006 44 404 63 2007 61 424 44 323 2008 61 380 44 323 2009 61 380 44 2010 2011 61 2010 46 2012 41 619 418 2002 40 418 2013 40 2006 44 418 2014 40 41 44 418 2015 40 41 44 418 2015 40 41 41 44 648 44 2011 44 2016 46 2017 46 2018 46 2019 44 2007 58 2007 44 2008 58 2008 44 2009 58 2009 41 59 438 431 2001 2020 40 2002 2003 41 619 418 2000 40 2003 41 59 125 
72205,C#,"    private class CustomValueGenerator : ValueGenerator<string>
    {
        public override string Next(EntityEntry entry)
            => throw new NotImplementedException();

        public override bool GeneratesTemporaryValues
            => false;
    }",0,437 334 2000 58 2001 60 461 62 123 439 431 461 2002 40 2003 2004 41 619 469 418 2005 40 41 59 439 431 323 2006 619 380 59 125 
72206,C#,"    private class Order
    {
        private readonly int _secretId;

        public Order()
        {
        }

        public Order(int secretId)
        {
            _secretId = secretId;
        }

        public int Id { get; set; }

        public Address Billing { get; set; }
        public Address Shipping { get; set; }
    }",0,437 334 2000 123 437 441 404 2001 59 439 2000 40 41 123 125 439 2000 40 404 2002 41 123 2001 61 2002 59 125 439 404 2003 123 2004 59 2005 59 125 439 2006 2007 123 2008 59 2009 59 125 439 2006 2010 123 2011 59 2012 59 125 125 
70292,C#,"        private class ChangeSdlCacheContext : DbContext
        {
            private static readonly IServiceProvider _serviceProvider
                = new ServiceCollection()
                    .AddEntityFrameworkInMemoryDatabase()
                    .BuildServiceProvider(validateScopes: true);

            private readonly bool _on;

            public ChangeSdlCacheContext(bool on)
            {
                _on = on;
            }

            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
                => optionsBuilder
                    .EnableSensitiveDataLogging(_on)
                    .UseInternalServiceProvider(_serviceProvider)
                    .UseInMemoryDatabase(Guid.NewGuid().ToString());
        }",0,437 334 2000 58 2001 123 437 457 441 2002 2003 61 418 2004 40 41 46 2005 40 41 46 2006 40 2007 58 473 41 59 437 441 323 2008 59 439 2000 40 323 2009 41 123 2008 61 2009 59 125 438 406 431 492 2010 40 2011 2012 41 619 2012 46 2013 40 2008 41 46 2014 40 2003 41 46 2015 40 2016 46 2017 40 41 46 2018 40 41 41 59 125 
70293,C#,"        private class ChangeWarningsCacheContext : DbContext
        {
            private readonly IServiceProvider _serviceProvider;
            private readonly Action<WarningsConfigurationBuilder> _configAction;

            public ChangeWarningsCacheContext(
                IServiceProvider serviceProvider,
                Action<WarningsConfigurationBuilder> configAction)
            {
                _serviceProvider = serviceProvider;
                _configAction = configAction;
            }

            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
                => optionsBuilder
                    .ConfigureWarnings(_configAction)
                    .UseInternalServiceProvider(_serviceProvider)
                    .UseInMemoryDatabase(Guid.NewGuid().ToString());
        }",0,437 334 2000 58 2001 123 437 441 2002 2003 59 437 441 2004 60 2005 62 2006 59 439 2000 40 2002 2007 44 2004 60 2005 62 2008 41 123 2003 61 2007 59 2006 61 2008 59 125 438 406 431 492 2009 40 2010 2011 41 619 2011 46 2012 40 2006 41 46 2013 40 2003 41 46 2014 40 2015 46 2016 40 41 46 2017 40 41 41 59 125 
70295,C#,"        private class ConstructorTestContextWithOC1B : ConstructorTestContextWithOCBase
        {
            public ConstructorTestContextWithOC1B(
                ILoggerFactory loggerFactory,
                IMemoryCache memoryCache)
                : base(loggerFactory, memoryCache)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 2005 41 58 320 40 2003 44 2005 41 123 125 125 
71326,C#,"    private class Cat
    {
        public Cat(int id)
        {
            Id = id;
        }

        // ReSharper disable once AutoPropertyCanBeMadeGetOnly.Local
        public int Id { get; private set; }

        public string Name { get; set; }

        public ICollection<Hat> Hats { get; } = new List<Hat>();

        public ICollection<Mat> Mats { get; } = new List<Mat>();
    }",0,437 334 2000 123 439 2000 40 404 2001 41 123 2002 61 2001 59 125 621 439 404 2003 123 2004 59 437 2005 59 125 439 461 2006 123 2007 59 2008 59 125 439 2009 60 2010 62 2011 123 2012 59 125 61 418 2013 60 2010 62 40 41 59 439 2009 60 2014 62 2015 123 2016 59 125 61 418 2013 60 2014 62 40 41 59 125 
70297,C#,"        private class ConstructorTestContextWithOC2B : ConstructorTestContextWithOCBase
        {
            public ConstructorTestContextWithOC2B(
                IServiceProvider internalServicesProvider,
                ILoggerFactory loggerFactory,
                IMemoryCache memoryCache)
                : base(internalServicesProvider, loggerFactory, memoryCache)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 2005 44 2006 2007 41 58 320 40 2003 44 2005 44 2007 41 123 125 125 
70299,C#,"        private class ConstructorTestContextWithOCBase : DbContext
        {
            private readonly IServiceProvider _internalServicesProvider;
            private readonly ILoggerFactory _loggerFactory;
            private readonly IMemoryCache _memoryCache;
            private readonly bool _isConfigured;

            protected ConstructorTestContextWithOCBase(
                ILoggerFactory loggerFactory = null,
                IMemoryCache memoryCache = null)
            {
                _loggerFactory = loggerFactory;
                _memoryCache = memoryCache;
            }

            protected ConstructorTestContextWithOCBase(
                IServiceProvider internalServicesProvider,
                ILoggerFactory loggerFactory = null,
                IMemoryCache memoryCache = null)
            {
                _internalServicesProvider = internalServicesProvider;
                _loggerFactory = loggerFactory;
                _memoryCache = memoryCache;
            }

            protected ConstructorTestContextWithOCBase(
                DbContextOptions options,
                ILoggerFactory loggerFactory = null,
                IMemoryCache memoryCache = null)
                : base(options)
            {
                _loggerFactory = loggerFactory;
                _memoryCache = memoryCache;
                _isConfigured = true;
            }

            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            {
                Assert.Equal(_isConfigured, optionsBuilder.IsConfigured);

                if (!optionsBuilder.IsConfigured)
                {
                    optionsBuilder.UseInMemoryDatabase(Guid.NewGuid().ToString());
                }

                if (_internalServicesProvider != null)
                {
                    optionsBuilder.UseInternalServiceProvider(_internalServicesProvider);
                }
                else if (optionsBuilder.Options.FindExtension<CoreOptionsExtension>()?.InternalServiceProvider == null)
                {
                    optionsBuilder.EnableServiceProviderCaching(false);
                }

                if (_memoryCache != null)
                {
                    optionsBuilder.UseMemoryCache(_memoryCache);
                }

                if (_loggerFactory != null)
                {
                    optionsBuilder.UseLoggerFactory(_loggerFactory);
                }
            }
        }",0,437 334 2000 58 2001 123 437 441 2002 2003 59 437 441 2004 2005 59 437 441 2006 2007 59 437 441 323 2008 59 438 2000 40 2004 2009 61 424 44 2006 2010 61 424 41 123 2005 61 2009 59 2007 61 2010 59 125 438 2000 40 2002 2011 44 2004 2009 61 424 44 2006 2010 61 424 41 123 2003 61 2011 59 2005 61 2009 59 2007 61 2010 59 125 438 2000 40 2012 2013 44 2004 2009 61 424 44 2006 2010 61 424 41 58 320 40 2013 41 123 2005 61 2009 59 2007 61 2010 59 2008 61 473 59 125 438 406 431 492 2014 40 2015 2016 41 123 2017 46 2018 40 2008 44 2016 46 2019 41 59 392 40 33 2016 46 2019 41 123 2016 46 2020 40 2021 46 2022 40 41 46 2023 40 41 41 59 125 392 40 2003 631 424 41 123 2016 46 2024 40 2003 41 59 125 360 392 40 2016 46 2025 46 2026 60 2027 62 40 41 634 2028 614 424 41 123 2016 46 2029 40 380 41 59 125 392 40 2007 631 424 41 123 2016 46 2030 40 2007 41 59 125 392 40 2005 631 424 41 123 2016 46 2031 40 2005 41 59 125 125 125 
70302,C#,"        private class CustomInMemoryValueGeneratorSelector : InMemoryValueGeneratorSelector
        {
            public CustomInMemoryValueGeneratorSelector(
                ValueGeneratorSelectorDependencies dependencies,
                IInMemoryDatabase inMemoryDatabase)
                : base(dependencies, inMemoryDatabase)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 44 2004 2005 41 58 320 40 2003 44 2005 41 123 125 125 
70303,C#,"        private class CustomModelCustomizer : ModelCustomizer
        {
            public CustomModelCustomizer(ModelCustomizerDependencies dependencies)
                : base(dependencies)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 2003 41 58 320 40 2003 41 123 125 125 
70304,C#,"        private class CustomParameterBindingFactory : IParameterBindingFactory
        {
            public bool CanBind(Type parameterType, string parameterName)
                => false;

            public ParameterBinding Bind(IMutableEntityType entityType, Type parameterType, string parameterName)
                => throw new NotImplementedException();

            public ParameterBinding Bind(IConventionEntityType entityType, Type parameterType, string parameterName)
                => throw new NotImplementedException();

            public ParameterBinding Bind(IReadOnlyEntityType entityType, Type parameterType, string parameterName)
                => throw new NotImplementedException();
        }",0,437 334 2000 58 2001 123 439 323 2002 40 2003 2004 44 461 2005 41 619 380 59 439 2006 2007 40 2008 2009 44 2003 2004 44 461 2005 41 619 469 418 2010 40 41 59 439 2006 2007 40 2011 2009 44 2003 2004 44 461 2005 41 619 469 418 2010 40 41 59 439 2006 2007 40 2012 2009 44 2003 2004 44 461 2005 41 619 469 418 2010 40 41 59 125 
70305,C#,"        private class CustomParameterBindingFactory2 : IParameterBindingFactory
        {
            public bool CanBind(Type parameterType, string parameterName)
                => false;

            public ParameterBinding Bind(IMutableEntityType entityType, Type parameterType, string parameterName)
                => throw new NotImplementedException();

            public ParameterBinding Bind(IConventionEntityType entityType, Type parameterType, string parameterName)
                => throw new NotImplementedException();

            public ParameterBinding Bind(IReadOnlyEntityType entityType, Type parameterType, string parameterName)
                => throw new NotImplementedException();
        }",0,437 334 2000 58 2001 123 439 323 2002 40 2003 2004 44 461 2005 41 619 380 59 439 2006 2007 40 2008 2009 44 2003 2004 44 461 2005 41 619 469 418 2010 40 41 59 439 2006 2007 40 2011 2009 44 2003 2004 44 461 2005 41 619 469 418 2010 40 41 59 439 2006 2007 40 2012 2009 44 2003 2004 44 461 2005 41 619 469 418 2010 40 41 59 125 
70307,C#,"        private class DerivedContext2 : DerivedContext1
        {
            public DerivedContext2(DbContextOptions<DerivedContext2> options)
                : base(options)
            {
            }
        }",0,437 334 2000 58 2001 123 439 2000 40 2002 60 2000 62 2003 41 58 320 40 2003 41 123 125 125 
70308,C#,"        private class EarlyLearningCenter : DbContext
        {
            private readonly IServiceProvider _serviceProvider;

            public EarlyLearningCenter()
            {
            }

            public EarlyLearningCenter(IServiceProvider serviceProvider)
            {
                _serviceProvider = serviceProvider;
            }

            public EarlyLearningCenter(IServiceProvider serviceProvider, DbContextOptions options)
                : base(options)
            {
                _serviceProvider = serviceProvider;
            }

            public DbSet<Product> Products { get; set; }
            public DbSet<Category> Categories { get; set; }
            public DbSet<TheGu> Gus { get; set; }

            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
                => optionsBuilder
                    .UseInMemoryDatabase(Guid.NewGuid().ToString())
                    .ConfigureWarnings(w => w.Default(WarningBehavior.Throw))
                    .UseInternalServiceProvider(_serviceProvider)
                    .EnableServiceProviderCaching(false);

            protected internal override void OnModelCreating(ModelBuilder modelBuilder)
                => modelBuilder
                    .Entity<Category>().HasMany(e => e.Products).WithOne(e => e.Category);
        }",0,437 334 2000 58 2001 123 437 441 2002 2003 59 439 2000 40 41 123 125 439 2000 40 2002 2004 41 123 2003 61 2004 59 125 439 2000 40 2002 2004 44 2005 2006 41 58 320 40 2006 41 123 2003 61 2004 59 125 439 2007 60 2008 62 2009 123 2010 59 2011 59 125 439 2007 60 2012 62 2013 123 2014 59 2015 59 125 439 2007 60 2016 62 2017 123 2018 59 2019 59 125 438 406 431 492 2020 40 2021 2022 41 619 2022 46 2023 40 2024 46 2025 40 41 46 2026 40 41 41 46 2027 40 2028 619 2028 46 2029 40 2030 46 2031 41 41 46 2032 40 2003 41 46 2033 40 380 41 59 438 406 431 492 2034 40 2035 2036 41 619 2036 46 2037 60 2012 62 40 41 46 2038 40 2039 619 2039 46 2009 41 46 2040 40 2039 619 2039 46 2012 41 59 125 
70310,C#,"        private class FakeMemoryCache : IMemoryCache
        {
            public void Dispose()
            {
            }

            public bool TryGetValue(object key, out object value)
                => throw new NotImplementedException();

            public ICacheEntry CreateEntry(object key)
                => throw new NotImplementedException();

            public void Remove(object key)
            {
            }
        }",0,437 334 2000 58 2001 123 439 492 2002 40 41 123 125 439 323 2003 40 426 2004 44 430 426 2005 41 619 469 418 2006 40 41 59 439 2007 2008 40 426 2004 41 619 469 418 2006 40 41 59 439 492 2009 40 426 2004 41 123 125 125 
70311,C#,"        private class FakeModelSource : IModelSource
        {
            public IModel GetModel(
                DbContext context,
                IConventionSetBuilder conventionSetBuilder)
                => new Model();

            public IModel GetModel(
                DbContext context,
                IConventionSetBuilder conventionSetBuilder,
                ModelDependencies modelDependencies)
                => new Model();

            public IModel GetModel(
                DbContext context,
                ModelCreationDependencies modelCreationDependencies,
                bool designTime)
                => new Model();
        }",0,437 334 2000 58 2001 123 439 2002 2003 40 2004 2005 44 2006 2007 41 619 418 2008 40 41 59 439 2002 2003 40 2004 2005 44 2006 2007 44 2009 2010 41 619 418 2008 40 41 59 439 2002 2003 40 2004 2005 44 2011 2012 44 323 2013 41 619 418 2008 40 41 59 125 
70313,C#,"        private class InfoLogContext : DbContext
        {
            private readonly bool _useLoggerFactory;
            private readonly bool _configureForDebug;

            public InfoLogContext(bool useLoggerFactory, bool configureForDebug)
            {
                _useLoggerFactory = useLoggerFactory;
                _configureForDebug = configureForDebug;
            }

            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            {
                optionsBuilder.UseInMemoryDatabase(typeof(InfoLogContext).FullName)
                    .ConfigureWarnings(w => w.Default(WarningBehavior.Throw));

                if (_useLoggerFactory)
                {
                    var externalProvider =
                        _configureForDebug
                            ? new ServiceCollection()
                                .AddLogging(b => b.SetMinimumLevel(LogLevel.Debug))
                                .BuildServiceProvider(validateScopes: true)
                            : new ServiceCollection()
                                .AddLogging()
                                .BuildServiceProvider(validateScopes: true);

                    optionsBuilder
                        .EnableServiceProviderCaching(false)
                        .UseLoggerFactory(externalProvider.GetService<ILoggerFactory>());
                }
                else
                {
                    var internalServiceProvider = new ServiceCollection()
                        .AddEntityFrameworkInMemoryDatabase()
                        .BuildServiceProvider(validateScopes: true);

                    optionsBuilder.UseInternalServiceProvider(internalServiceProvider);
                }
            }
        }",0,437 334 2000 58 2001 123 437 441 323 2002 59 437 441 323 2003 59 439 2000 40 323 2004 44 323 2005 41 123 2002 61 2004 59 2003 61 2005 59 125 438 406 431 492 2006 40 2007 2008 41 123 2008 46 2009 40 478 40 2000 41 46 2010 41 46 2011 40 2012 619 2012 46 2013 40 2014 46 2015 41 41 59 392 40 2002 41 123 490 2016 61 2003 63 418 2017 40 41 46 2018 40 2019 619 2019 46 2020 40 2021 46 2022 41 41 46 2023 40 2024 58 473 41 58 418 2017 40 41 46 2018 40 41 46 2023 40 2024 58 473 41 59 2008 46 2025 40 380 41 46 2026 40 2016 46 2027 60 2028 62 40 41 41 59 125 360 123 490 2029 61 418 2030 40 41 46 2031 40 41 46 2032 40 2033 58 473 41 59 2008 46 2034 40 2029 41 59 125 125 125 
71327,C#,"        private class DummyValueGenerator : ValueGenerator<int>
        {
            private static int _value;

            public override int Next(EntityEntry entry)
                => _value++;

            public override bool GeneratesTemporaryValues
                => false;
        }",0,437 334 2000 58 2001 60 404 62 123 437 457 404 2002 59 439 431 404 2003 40 2004 2005 41 619 2002 637 59 439 431 323 2006 619 380 59 125 
70314,C#,"        private class MyLoggerProvider : ILoggerProvider
        {
            private bool _disposed;

            public ILogger CreateLogger(string categoryName)
            {
                if (_disposed)
                {
                    throw new ObjectDisposedException(nameof(MyLoggerProvider));
                }

                return new MyListLogger(Log);
            }

            public void Dispose()
                => _disposed = true;

            private class MyListLogger : ILogger
            {
                public MyListLogger(List<(LogLevel, EventId, string)> logMessage)
                {
                    LogMessages = logMessage;
                }

                private List<(LogLevel, EventId, string)> LogMessages { get; }

                public void Log<TState>(
                    LogLevel logLevel,
                    EventId eventId,
                    TState state,
                    Exception exception,
                    Func<TState, Exception, string> formatter)
                {
                    var message = new StringBuilder();
                    if (formatter != null)
                    {
                        message.Append(formatter(state, exception));
                    }
                    else if (state != null)
                    {
                        message.Append(state);

                        if (exception != null)
                        {
                            message.Append(Environment.NewLine);
                            message.Append(exception);
                        }
                    }

                    LogMessages?.Add((logLevel, eventId, message.ToString()));
                }

                public bool IsEnabled(LogLevel logLevel)
                    => true;

                public IDisposable BeginScope(object state)
                    => throw new NotImplementedException();

                public IDisposable BeginScope<TState>(TState state)
                    => null;
            }
        }",0,437 334 2000 58 2001 123 437 323 2002 59 439 2003 2004 40 461 2005 41 123 392 40 2002 41 123 469 418 2006 40 2007 40 2000 41 41 59 125 450 418 2008 40 2009 41 59 125 439 492 2010 40 41 619 2002 61 473 59 437 334 2011 58 2003 123 439 2011 40 2012 60 40 2013 44 2014 44 461 41 62 2015 41 123 2016 61 2015 59 125 437 2012 60 40 2013 44 2014 44 461 41 62 2017 123 2018 59 125 439 492 2019 60 2020 62 40 2013 2021 44 2014 2022 44 2020 2023 44 2024 2025 44 2026 60 2020 44 2024 44 461 62 2027 41 123 490 2028 61 418 2029 40 41 59 392 40 2027 631 424 41 123 2028 46 2030 40 2027 40 2023 44 2025 41 41 59 125 360 392 40 2023 631 424 41 123 2028 46 2031 40 2023 41 59 392 40 2025 631 424 41 123 2028 46 2031 40 2032 46 2033 41 59 2028 46 2031 40 2025 41 59 125 125 2017 634 2034 40 40 2021 44 2022 44 2028 46 2035 40 41 41 41 59 125 439 323 2036 40 2013 2021 41 619 473 59 439 2037 2038 40 426 2023 41 619 469 418 2039 40 41 59 439 2037 2038 60 2020 62 40 2020 2023 41 619 424 59 125 125 
70318,C#,"        private class ReplaceServiceContext1 : DbContext
        {
            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
                => optionsBuilder
                    .ReplaceService<IModelCustomizer, CustomModelCustomizer>()
                    .ReplaceService<IValueGeneratorSelector, CustomInMemoryValueGeneratorSelector>()
                    .ReplaceService<IInMemoryTableFactory, CustomInMemoryTableFactory>()
                    .EnableServiceProviderCaching(false)
                    .UseInMemoryDatabase(Guid.NewGuid().ToString())
                    .ConfigureWarnings(w => w.Default(WarningBehavior.Throw));
        }",0,437 334 2000 58 2001 123 438 406 431 492 2002 40 2003 2004 41 619 2004 46 2005 60 2006 44 2007 62 40 41 46 2005 60 2008 44 2009 62 40 41 46 2005 60 2010 44 2011 62 40 41 46 2012 40 380 41 46 2013 40 2014 46 2015 40 41 46 2016 40 41 41 46 2017 40 2018 619 2018 46 2019 40 2020 46 2021 41 41 59 125 
68102,C#,"    private class CustomGuidValueGenerator : ValueGenerator<Guid>
    {
        public static Guid[] SpecialGuids { get; } =
        {
            Guid.NewGuid(),
            Guid.NewGuid(),
            Guid.NewGuid(),
            Guid.NewGuid(),
            Guid.NewGuid(),
            Guid.NewGuid(),
            Guid.NewGuid(),
            Guid.NewGuid()
        };

        private int _counter = -1;

        public override Guid Next(EntityEntry entry)
            => SpecialGuids[Interlocked.Increment(ref _counter)];

        public override bool GeneratesTemporaryValues
            => false;
    }",0,437 334 2000 58 2001 60 2002 62 123 439 457 2002 91 93 2003 123 2004 59 125 61 123 2002 46 2005 40 41 44 2002 46 2005 40 41 44 2002 46 2005 40 41 44 2002 46 2005 40 41 44 2002 46 2005 40 41 44 2002 46 2005 40 41 44 2002 46 2005 40 41 44 2002 46 2005 40 41 125 59 437 404 2006 61 45 1501 59 439 431 2002 2007 40 2008 2009 41 619 2003 91 2010 46 2011 40 442 2006 41 93 59 439 431 323 2012 619 380 59 125 
70321,C#,"        private class SetMemoryCacheContext : DbContext
        {
            protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
                => optionsBuilder
                    .UseMemoryCache(new FakeMemoryCache())
                    .UseInternalServiceProvider(
                        new ServiceCollection()
                            .AddEntityFrameworkInMemoryDatabase()
                            .BuildServiceProvider(validateScopes: true))
                    .UseInMemoryDatabase(Guid.NewGuid().ToString());
        }",0,437 334 2000 58 2001 123 438 406 431 492 2002 40 2003 2004 41 619 2004 46 2005 40 418 2006 40 41 41 46 2007 40 418 2008 40 41 46 2009 40 41 46 2010 40 2011 58 473 41 41 46 2012 40 2013 46 2014 40 41 46 2015 40 41 41 59 125 
70322,C#,"        private class WrappingLoggerFactory : ILoggerFactory
        {
            private readonly ILoggerFactory _loggerFactory;

            public IList<string> CreatedLoggers { get; } = new List<string>();

            public WrappingLoggerFactory(ILoggerFactory loggerFactory)
            {
                _loggerFactory = loggerFactory;
            }

            public void Dispose()
                => _loggerFactory.Dispose();

            public ILogger CreateLogger(string categoryName)
            {
                CreatedLoggers.Add(categoryName);

                return _loggerFactory.CreateLogger(categoryName);
            }

            public void AddProvider(ILoggerProvider provider)
                => _loggerFactory.AddProvider(provider);
        }",0,437 334 2000 58 2001 123 437 441 2001 2002 59 439 2003 60 461 62 2004 123 2005 59 125 61 418 2006 60 461 62 40 41 59 439 2000 40 2001 2007 41 123 2002 61 2007 59 125 439 492 2008 40 41 619 2002 46 2008 40 41 59 439 2009 2010 40 461 2011 41 123 2004 46 2012 40 2011 41 59 450 2002 46 2010 40 2011 41 59 125 439 492 2013 40 2014 2015 41 619 2002 46 2013 40 2015 41 59 125 
71330,C#,"    private class KontainerContext : DbContext
    {
        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
            => modelBuilder.Entity<KontainerRoom>()
                .HasOne(room => room.Troduct)
                .WithMany(product => product.Rooms)
                .HasForeignKey(room => room.TroductId)
                .IsRequired(false)
                .OnDelete(DeleteBehavior.Cascade);

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder
                .UseInternalServiceProvider(InMemoryFixture.DefaultServiceProvider)
                .UseInMemoryDatabase(nameof(KontainerContext));
    }",0,437 334 2000 58 2001 123 438 406 431 492 2002 40 2003 2004 41 619 2004 46 2005 60 2006 62 40 41 46 2007 40 2008 619 2008 46 2009 41 46 2010 40 2011 619 2011 46 2012 41 46 2013 40 2008 619 2008 46 2014 41 46 2015 40 380 41 46 2016 40 2017 46 2018 41 59 438 406 431 492 2019 40 2020 2021 41 619 2021 46 2022 40 2023 46 2024 41 46 2025 40 2026 40 2000 41 41 59 125 
71334,C#,"    private class Mat
    {
        public Mat(int id)
        {
            Id = id;
        }

        // ReSharper disable once AutoPropertyCanBeMadeGetOnly.Local
        public int Id { get; private set; }

        public ICollection<Cat> Cats { get; } = new List<Cat>();
    }",0,437 334 2000 123 439 2000 40 404 2001 41 123 2002 61 2001 59 125 621 439 404 2003 123 2004 59 437 2005 59 125 439 2006 60 2007 62 2008 123 2009 59 125 61 418 2010 60 2007 62 40 41 59 125 
71335,C#,"    private class ResettableValueGenerator : ValueGenerator<int>
    {
        private int _current;
        private bool _generatesTemporaryValues;

        public override bool GeneratesTemporaryValues
            => _generatesTemporaryValues;

        public override int Next(EntityEntry entry)
            => Interlocked.Increment(ref _current);

        public void Reset(bool generateTemporaryValues)
        {
            _generatesTemporaryValues = generateTemporaryValues;
            _current = 0;
        }
    }",0,437 334 2000 58 2001 60 404 62 123 437 404 2002 59 437 323 2003 59 439 431 323 2004 619 2003 59 439 431 404 2005 40 2006 2007 41 619 2008 46 2009 40 442 2002 41 59 439 492 2010 40 323 2011 41 123 2003 61 2011 59 2002 61 1500 59 125 125 
71336,C#,"    private class TheShadows : DbContext
    {
        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
            => modelBuilder.Entity<Dark>(
                b =>
                {
                    b.Property<int>(""Id"").ValueGeneratedOnAdd();
                    b.Property<int>(""SomeInt"");
                    b.Property<string>(""SomeString"");
                });

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder
                .UseInternalServiceProvider(InMemoryFixture.DefaultServiceProvider)
                .UseInMemoryDatabase(nameof(TheShadows));
    }",0,437 334 2000 58 2001 123 438 406 431 492 2002 40 2003 2004 41 619 2004 46 2005 60 2006 62 40 2007 619 123 2007 46 2008 60 404 62 40 648 41 46 2009 40 41 59 2007 46 2008 60 404 62 40 648 41 59 2007 46 2008 60 461 62 40 648 41 59 125 41 59 438 406 431 492 2010 40 2011 2012 41 619 2012 46 2013 40 2014 46 2015 41 46 2016 40 2017 40 2000 41 41 59 125 
71337,C#,"    public class WeakHerosContext : DbContext
    {
        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Weak>(
                b =>
                {
                    b.HasKey(e => new { e.Id, e.HeroId });
                    b.HasOne(e => e.Hero).WithMany(e => e.Weaks).HasForeignKey(e => e.HeroId);
                });

            modelBuilder.Entity<Mike>(
                b =>
                {
                    b.OwnsOne(e => e.TheHero);
                    b.OwnsMany(e => e.TheStreets);
                });
        }

        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder.UseInMemoryDatabase(nameof(WeakHerosContext));
    }",0,439 334 2000 58 2001 123 438 406 431 492 2002 40 2003 2004 41 123 2004 46 2005 60 2006 62 40 2007 619 123 2007 46 2008 40 2009 619 418 123 2009 46 2010 44 2009 46 2011 125 41 59 2007 46 2012 40 2009 619 2009 46 2013 41 46 2014 40 2009 619 2009 46 2015 41 46 2016 40 2009 619 2009 46 2017 41 59 125 41 59 2004 46 2005 60 2018 62 40 2007 619 123 2007 46 2019 40 2020 619 2020 46 2021 41 59 2007 46 2022 40 2020 619 2020 46 2023 41 59 125 41 59 125 438 406 431 492 2024 40 2025 2026 41 619 2026 46 2027 40 2028 40 2000 41 41 59 125 
71201,C#,"public class InMemoryValueGeneratorSelectorTest
{
    [ConditionalFact]
    public void Returns_built_in_generators_for_types_setup_for_value_generation()
    {
        var model = BuildModel();
        var entityType = model.FindEntityType(typeof(AnEntity));

        var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();

        Assert.IsType<CustomValueGenerator>(selector.Select(entityType.FindProperty(""Custom""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<int>>(selector.Select(entityType.FindProperty(""Id""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<long>>(selector.Select(entityType.FindProperty(""Long""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<short>>(selector.Select(entityType.FindProperty(""Short""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<byte>>(selector.Select(entityType.FindProperty(""Byte""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<int>>(selector.Select(entityType.FindProperty(""NullableInt""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<long>>(selector.Select(entityType.FindProperty(""NullableLong""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<short>>(selector.Select(entityType.FindProperty(""NullableShort""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<byte>>(selector.Select(entityType.FindProperty(""NullableByte""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<uint>>(selector.Select(entityType.FindProperty(""UInt""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<ulong>>(selector.Select(entityType.FindProperty(""ULong""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<ushort>>(selector.Select(entityType.FindProperty(""UShort""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<sbyte>>(selector.Select(entityType.FindProperty(""SByte""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<uint>>(selector.Select(entityType.FindProperty(""NullableUInt""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<ulong>>(selector.Select(entityType.FindProperty(""NullableULong""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<ushort>>(selector.Select(entityType.FindProperty(""NullableUShort""), entityType));
        Assert.IsType<InMemoryIntegerValueGenerator<sbyte>>(selector.Select(entityType.FindProperty(""NullableSByte""), entityType));
        Assert.IsType<StringValueGenerator>(selector.Select(entityType.FindProperty(""String""), entityType));
        Assert.IsType<GuidValueGenerator>(selector.Select(entityType.FindProperty(""Guid""), entityType));
        Assert.IsType<BinaryValueGenerator>(selector.Select(entityType.FindProperty(""Binary""), entityType));
    }

    [ConditionalFact]
    public void Can_create_factories_for_all_integer_types()
    {
        var model = BuildModel();
        var entityType = model.FindEntityType(typeof(AnEntity));

        Assert.Equal(1, CreateAndUseFactory(entityType.FindProperty(""Id"")));
        Assert.Equal(1L, CreateAndUseFactory(entityType.FindProperty(""Long"")));
        Assert.Equal((short)1, CreateAndUseFactory(entityType.FindProperty(""Short"")));
        Assert.Equal((byte)1, CreateAndUseFactory(entityType.FindProperty(""Byte"")));
        Assert.Equal((int?)1, CreateAndUseFactory(entityType.FindProperty(""NullableInt"")));
        Assert.Equal((long?)1, CreateAndUseFactory(entityType.FindProperty(""NullableLong"")));
        Assert.Equal((short?)1, CreateAndUseFactory(entityType.FindProperty(""NullableShort"")));
        Assert.Equal((byte?)1, CreateAndUseFactory(entityType.FindProperty(""NullableByte"")));
        Assert.Equal((uint)1, CreateAndUseFactory(entityType.FindProperty(""UInt"")));
        Assert.Equal((ulong)1, CreateAndUseFactory(entityType.FindProperty(""ULong"")));
        Assert.Equal((ushort)1, CreateAndUseFactory(entityType.FindProperty(""UShort"")));
        Assert.Equal((sbyte)1, CreateAndUseFactory(entityType.FindProperty(""SByte"")));
        Assert.Equal((uint?)1, CreateAndUseFactory(entityType.FindProperty(""NullableUInt"")));
        Assert.Equal((ulong?)1, CreateAndUseFactory(entityType.FindProperty(""NullableULong"")));
        Assert.Equal((ushort?)1, CreateAndUseFactory(entityType.FindProperty(""NullableUShort"")));
        Assert.Equal((sbyte?)1, CreateAndUseFactory(entityType.FindProperty(""NullableSByte"")));
    }

    private static object CreateAndUseFactory(IProperty property)
    {
        var model = BuildModel();

        var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();

        return selector.Select(property, property.DeclaringEntityType).Next(null);
    }

    [ConditionalFact]
    public void Throws_for_unsupported_combinations()
    {
        var model = BuildModel();
        var entityType = model.FindEntityType(typeof(AnEntity));

        var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();

        Assert.Equal(
            CoreStrings.NoValueGenerator(""Float"", ""AnEntity"", ""float""),
            Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty(""Float""), entityType)).Message);
    }

    private static IModel BuildModel(bool generateValues = true)
    {
        var builder = InMemoryTestHelpers.Instance.CreateConventionBuilder();
        builder.Entity<AnEntity>().Property(e => e.Custom).HasValueGenerator<CustomValueGenerator>();
        var model = builder.Model;
        var entityType = model.FindEntityType(typeof(AnEntity));

        foreach (var property in entityType.GetProperties())
        {
            property.ValueGenerated = generateValues ? ValueGenerated.OnAdd : ValueGenerated.Never;
        }

        return builder.FinalizeModel();
    }

    private class AnEntity
    {
        public int Id { get; set; }
        public int Custom { get; set; }
        public long Long { get; set; }
        public short Short { get; set; }
        public byte Byte { get; set; }
        public int? NullableInt { get; set; }
        public long? NullableLong { get; set; }
        public short? NullableShort { get; set; }
        public byte? NullableByte { get; set; }
        public uint UInt { get; set; }
        public ulong ULong { get; set; }
        public ushort UShort { get; set; }
        public sbyte SByte { get; set; }
        public uint? NullableUInt { get; set; }
        public ulong? NullableULong { get; set; }
        public ushort? NullableUShort { get; set; }
        public sbyte? NullableSByte { get; set; }
        public string String { get; set; }
        public Guid Guid { get; set; }
        public byte[] Binary { get; set; }
        public float Float { get; set; }
    }

    private class CustomValueGenerator : ValueGenerator<int>
    {
        public override int Next(EntityEntry entry)
            => throw new NotImplementedException();

        public override bool GeneratesTemporaryValues
            => false;
    }
}",0,439 334 2000 123 91 2001 93 439 492 2002 40 41 123 490 2003 61 2004 40 41 59 490 2005 61 2003 46 2006 40 478 40 2007 41 41 59 490 2008 61 2009 46 2010 46 2011 40 2003 41 46 2012 60 2013 62 40 41 59 2014 46 2015 60 2016 62 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 404 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 413 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 453 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 326 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 404 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 413 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 453 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 326 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 479 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 480 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 488 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 451 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 479 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 480 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 488 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2019 60 451 640 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2020 62 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2021 62 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 2014 46 2015 60 2022 62 40 2008 46 2017 40 2005 46 2018 40 648 41 44 2005 41 41 59 125 91 2001 93 439 492 2023 40 41 123 490 2024 61 2025 40 41 59 490 2026 61 2024 46 2027 40 478 40 2028 41 41 59 2029 46 2030 40 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 453 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 326 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 404 63 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 413 63 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 453 63 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 326 63 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 479 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 480 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 488 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 451 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 479 63 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 480 63 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 488 63 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 2029 46 2030 40 40 451 63 41 1501 44 2031 40 2026 46 2032 40 648 41 41 41 59 125 437 457 426 2033 40 2034 2035 41 123 490 2036 61 2037 40 41 59 490 2038 61 2039 46 2040 46 2041 40 2036 41 46 2042 60 2043 62 40 41 59 450 2038 46 2044 40 2035 44 2035 46 2045 41 46 2046 40 424 41 59 125 91 2001 93 439 492 2047 40 41 123 490 2048 61 2049 40 41 59 490 2050 61 2048 46 2051 40 478 40 2052 41 41 59 490 2053 61 2054 46 2055 46 2056 40 2048 41 46 2057 60 2058 62 40 41 59 2059 46 2060 40 2061 46 2062 40 648 44 648 44 648 41 44 2059 46 2063 60 2064 62 40 40 41 619 2053 46 2065 40 2050 46 2066 40 648 41 44 2050 41 41 46 2067 41 59 125 437 457 2068 2069 40 323 2070 61 473 41 123 490 2071 61 2072 46 2073 46 2074 40 41 59 2071 46 2075 60 2076 62 40 41 46 2077 40 2078 619 2078 46 2079 41 46 2080 60 2081 62 40 41 59 490 2082 61 2071 46 2083 59 490 2084 61 2082 46 2085 40 478 40 2076 41 41 59 386 40 490 2035 398 2084 46 2086 40 41 41 123 2035 46 2087 61 2070 63 2087 46 2088 58 2087 46 2089 59 125 450 2071 46 2090 40 41 59 125 437 334 2091 123 439 404 2092 123 2093 59 2094 59 125 439 404 2095 123 2096 59 2097 59 125 439 413 2098 123 2099 59 2100 59 125 439 453 2101 123 2102 59 2103 59 125 439 326 2104 123 2105 59 2106 59 125 439 404 63 2107 123 2108 59 2109 59 125 439 413 63 2110 123 2111 59 2112 59 125 439 453 63 2113 123 2114 59 2115 59 125 439 326 63 2116 123 2117 59 2118 59 125 439 479 2119 123 2120 59 2121 59 125 439 480 2122 123 2123 59 2124 59 125 439 488 2125 123 2126 59 2127 59 125 439 451 2128 123 2129 59 2130 59 125 439 479 63 2131 123 2132 59 2133 59 125 439 480 63 2134 123 2135 59 2136 59 125 439 488 63 2137 123 2138 59 2139 59 125 439 451 63 2140 123 2141 59 2142 59 125 439 461 2143 123 2144 59 2145 59 125 439 2146 2146 123 2147 59 2148 59 125 439 326 91 93 2149 123 2150 59 2151 59 125 439 384 2152 123 2153 59 2154 59 125 125 437 334 2155 58 2156 60 404 62 123 439 431 404 2157 40 2158 2159 41 619 469 418 2160 40 41 59 439 431 323 2161 619 380 59 125 125 
72190,C#,"    private class PetsContext : DbContext
    {
        private readonly string _databaseName;
        private readonly InMemoryDatabaseRoot _root;
        private readonly IServiceProvider _internalServiceProvider;

        public PetsContext(
            string databaseName,
            InMemoryDatabaseRoot root = null,
            IServiceProvider internalServiceProvider = null)
        {
            _databaseName = databaseName;
            _root = root;
            _internalServiceProvider = internalServiceProvider;
        }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseInternalServiceProvider(_internalServiceProvider);

            if (_root == null)
            {
                optionsBuilder.UseInMemoryDatabase(_databaseName);
            }
            else
            {
                optionsBuilder.UseInMemoryDatabase(_databaseName, _root);
            }
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Cat>();
            modelBuilder.Entity<Dog>();
        }

        public DbSet<Toast> CookedBreads { get; set; }
        public DbSet<Olive> Olives { get; set; }
        public DbSet<Mac> Macs { get; set; }
        public DbSet<Smokey> Smokeys { get; set; }
        public DbSet<Alice> Alices { get; set; }
    }",0,437 334 2000 58 2001 123 437 441 461 2002 59 437 441 2003 2004 59 437 441 2005 2006 59 439 2000 40 461 2007 44 2003 2008 61 424 44 2005 2009 61 424 41 123 2002 61 2007 59 2004 61 2008 59 2006 61 2009 59 125 438 431 492 2010 40 2011 2012 41 123 2012 46 2013 40 2006 41 59 392 40 2004 614 424 41 123 2012 46 2014 40 2002 41 59 125 360 123 2012 46 2015 40 2002 44 2004 41 59 125 125 438 431 492 2016 40 2017 2018 41 123 2018 46 2019 60 2020 62 40 41 59 2018 46 2019 60 2021 62 40 41 59 125 439 2022 60 2023 62 2024 123 2025 59 2026 59 125 439 2022 60 2027 62 2028 123 2029 59 2030 59 125 439 2022 60 2031 62 2032 123 2033 59 2034 59 125 439 2022 60 2035 62 2036 123 2037 59 2038 59 125 439 2022 60 2039 62 2040 123 2041 59 2042 59 125 125 
72191,C#,"    private class PetsContextWithData : PetsContext
    {
        public PetsContextWithData(
            string databaseName,
            InMemoryDatabaseRoot root = null,
            IServiceProvider internalServiceProvider = null)
            : base(databaseName, root, internalServiceProvider)
        {
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Toast>().HasData(new Toast { Id = 1 });
            modelBuilder.Entity<Mac>().HasData(new Mac { Id = 1 }, new Mac { Id = 2 });
        }
    }",0,437 334 2000 58 2001 123 439 2000 40 461 2002 44 2003 2004 61 424 44 2005 2006 61 424 41 58 320 40 2002 44 2004 44 2006 41 123 125 438 431 492 2007 40 2008 2009 41 123 320 46 2007 40 2009 41 59 2009 46 2010 60 2011 62 40 41 46 2012 40 418 2011 123 2013 61 1501 125 41 59 2009 46 2010 60 2014 62 40 41 46 2012 40 418 2014 123 2015 61 1501 125 44 418 2014 123 2016 61 1502 125 41 59 125 125 
68108,C#,"    private class SomeEntityStringValueGenerator : ValueGenerator<string>
    {
        private int _counter;

        public override string Next(EntityEntry entry)
            => ((SomeEntity)entry.Entity).Name + "" - "" + Interlocked.Increment(ref _counter);

        public override bool GeneratesTemporaryValues
            => false;
    }",0,437 334 2000 58 2001 60 461 62 123 437 404 2002 59 439 431 461 2003 40 2004 2005 41 619 40 40 2006 41 2005 46 2007 41 46 2008 43 648 43 2009 46 2010 40 442 2002 41 59 439 431 323 2011 619 380 59 125 
68103,C#,"    private class CustomInMemoryValueGeneratorSelector : InMemoryValueGeneratorSelector
    {
        private readonly ValueGeneratorFactory _factory = new CustomValueGeneratorFactory();

        public CustomInMemoryValueGeneratorSelector(
            ValueGeneratorSelectorDependencies dependencies,
            IInMemoryDatabase inMemoryDatabase)
            : base(dependencies, inMemoryDatabase)
        {
        }

        public override ValueGenerator Create(IProperty property, IEntityType entityType)
            => _factory.Create(property, entityType);
    }",0,437 334 2000 58 2001 123 437 441 2002 2003 61 418 2004 40 41 59 439 2000 40 2005 2006 44 2007 2008 41 58 320 40 2006 44 2008 41 123 125 439 431 2009 2010 40 2011 2012 44 2013 2014 41 619 2003 46 2010 40 2012 44 2014 41 59 125 
68106,C#,"    private class CustomValueGeneratorContextAnnotateType : DbContext
    {
        private static readonly IServiceProvider _serviceProvider
            = new ServiceCollection()
                .AddEntityFrameworkInMemoryDatabase()
                .BuildServiceProvider(validateScopes: true);

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            => optionsBuilder
                .UseInternalServiceProvider(_serviceProvider)
                .UseInMemoryDatabase(nameof(CustomValueGeneratorContextAnnotateType));

        protected override void OnModelCreating(ModelBuilder modelBuilder)
            => modelBuilder
                .Entity<SomeEntity>(
                    b =>
                    {
                        b.Property(e => e.Id).HasValueGenerator<SequentialGuidValueGenerator>();
                        b.Property(e => e.SpecialId).HasValueGenerator(typeof(CustomGuidValueGenerator));
                        b.Property(e => e.SpecialString).HasValueGenerator<SomeEntityStringValueGenerator>();
                    });
    }",0,437 334 2000 58 2001 123 437 457 441 2002 2003 61 418 2004 40 41 46 2005 40 41 46 2006 40 2007 58 473 41 59 438 431 492 2008 40 2009 2010 41 619 2010 46 2011 40 2003 41 46 2012 40 2013 40 2000 41 41 59 438 431 492 2014 40 2015 2016 41 619 2016 46 2017 60 2018 62 40 2019 619 123 2019 46 2020 40 2021 619 2021 46 2022 41 46 2023 60 2024 62 40 41 59 2019 46 2020 40 2021 619 2021 46 2025 41 46 2023 40 478 40 2026 41 41 59 2019 46 2020 40 2021 619 2021 46 2027 41 46 2023 60 2028 62 40 41 59 125 41 59 125 
68107,C#,"    private class CustomValueGeneratorFactory : ValueGeneratorFactory
    {
        public override ValueGenerator Create(IProperty property, IEntityType entityType)
        {
            if (property.ClrType == typeof(Guid))
            {
                return property[""SpecialGuid""] != null
                    ? new CustomGuidValueGenerator()
                    : new SequentialGuidValueGenerator();
            }

            return property.ClrType == typeof(string)
                && property.DeclaringEntityType.ClrType == typeof(SomeEntity)
                    ? new SomeEntityStringValueGenerator()
                    : null;
        }
    }",0,437 334 2000 58 2001 123 439 431 2002 2003 40 2004 2005 44 2006 2007 41 123 392 40 2005 46 2008 614 478 40 2009 41 41 123 450 2005 91 648 93 631 424 63 418 2010 40 41 58 418 2011 40 41 59 125 450 2005 46 2008 614 478 40 461 41 605 2005 46 2012 46 2008 614 478 40 2013 41 63 418 2014 40 41 58 424 59 125 125 
71611,C#,"    public class CtorFixture
    {
        public CtorFixture()
        {
        }

        // ReSharper disable once UnusedParameter.Local
        public CtorFixture(int frob)
        {
        }
    }",0,439 334 2000 123 439 2000 40 41 123 125 621 439 2000 40 404 2001 41 123 125 125 
71612,C#,"    private class MultipleImplementor<TRandom, TElement> : IObservable<TRandom>, IEnumerable<TElement>
        where TRandom : Random
    {
        public IEnumerator<TElement> GetEnumerator()
            => throw new NotImplementedException();

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public IDisposable Subscribe(IObserver<TRandom> observer)
            => throw new NotImplementedException();
    }",0,437 334 2000 60 2001 44 2002 62 58 2003 60 2001 62 44 2004 60 2002 62 2005 2001 58 2006 123 439 2007 60 2002 62 2008 40 41 619 469 418 2009 40 41 59 2007 2004 46 2008 40 41 619 2008 40 41 59 439 2010 2011 40 2012 60 2001 62 2013 41 619 469 418 2009 40 41 59 125 
71613,C#,"    private class RoleCollection2014 : List<Role2014>, IRoleCollection2014
    {
        public new IEnumerator<IRole2014> GetEnumerator()
            => throw new NotImplementedException();

        public void Add(IRole2014 item)
            => throw new NotImplementedException();

        public bool Contains(IRole2014 item)
            => throw new NotImplementedException();

        public void CopyTo(IRole2014[] array, int arrayIndex)
            => throw new NotImplementedException();

        public bool Remove(IRole2014 item)
            => throw new NotImplementedException();

        public bool IsReadOnly { get; private set; }
    }",0,437 334 2000 58 2001 60 2002 62 44 2003 123 439 418 2004 60 2005 62 2006 40 41 619 469 418 2007 40 41 59 439 492 2008 40 2005 2009 41 619 469 418 2007 40 41 59 439 323 2010 40 2005 2009 41 619 469 418 2007 40 41 59 439 492 2011 40 2005 91 93 310 44 404 2012 41 619 469 418 2007 40 41 59 439 323 2013 40 2005 2009 41 619 469 418 2007 40 41 59 439 323 2014 123 2015 59 437 2016 59 125 125 
69572,C#,"    private class EntityWithConstructorBinding
    {
        public EntityWithConstructorBinding(int id)
        {
            Id = id;
        }

        public int Id { get; }
    }",0,437 334 2000 123 439 2000 40 404 2001 41 123 2002 61 2001 59 125 439 404 2003 123 2004 59 125 125 
72197,C#,"        private class TestModelAnnotationCodeGenerator : SqlServerAnnotationCodeGenerator
        {
            private static readonly MethodInfo _testFluentApiCallMethodInfo
                = typeof(TestModelBuilderExtensions).GetRuntimeMethod(
                    nameof(TestModelBuilderExtensions.TestFluentApiCall), new[] { typeof(ModelBuilder) })!;

            public TestModelAnnotationCodeGenerator(AnnotationCodeGeneratorDependencies dependencies)
                : base(dependencies)
            {
            }

            protected override MethodCallCodeFragment GenerateFluentApi(IModel model, IAnnotation annotation)
                => annotation.Name switch
                {
                    ""Test:TestModelAnnotation"" => new MethodCallCodeFragment(_testFluentApiCallMethodInfo),
                    _ => base.GenerateFluentApi(model, annotation)
                };
        }",0,437 334 2000 58 2001 123 437 457 441 2002 2003 61 478 40 2004 41 46 2005 40 2006 40 2004 46 2007 41 44 418 91 93 123 478 40 2008 41 125 41 33 59 439 2000 40 2009 2010 41 58 320 40 2010 41 123 125 438 431 2011 2012 40 2013 2014 44 2015 2016 41 619 2016 46 2017 464 123 648 619 418 2011 40 2003 41 44 2018 619 320 46 2012 40 2014 44 2016 41 125 59 125 
71480,C#,"    private class CustomValueGenerator : ValueGenerator<int>
    {
        public override int Next(EntityEntry entry)
            => throw new NotImplementedException();

        public override bool GeneratesTemporaryValues
            => false;
    }",0,437 334 2000 58 2001 60 404 62 123 439 431 404 2002 40 2003 2004 41 619 469 418 2005 40 41 59 439 431 323 2006 619 380 59 125 
68643,C#,"    public static class SqliteResources
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager(""Microsoft.EntityFrameworkCore.Sqlite.Properties.SqliteStrings"", typeof(SqliteResources).Assembly);

        /// <summary>
        ///     Skipping foreign key with identity '{id}' on table '{tableName}' since principal table '{principalTableName}' was not found in the model. This usually happens when the principal table was not included in the selection set.
        /// </summary>
        public static EventDefinition<string?, string?, string?> LogForeignKeyScaffoldErrorPrincipalTableNotFound(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogForeignKeyScaffoldErrorPrincipalTableNotFound;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogForeignKeyScaffoldErrorPrincipalTableNotFound,
                    logger,
                    static logger => new EventDefinition<string?, string?, string?>(
                        logger.Options,
                        SqliteEventId.ForeignKeyReferencesMissingTableWarning,
                        LogLevel.Warning,
                        ""SqliteEventId.ForeignKeyReferencesMissingTableWarning"",
                        level => LoggerMessage.Define<string?, string?, string?>(
                            level,
                            SqliteEventId.ForeignKeyReferencesMissingTableWarning,
                            _resourceManager.GetString(""LogForeignKeyScaffoldErrorPrincipalTableNotFound"")!)));
            }

            return (EventDefinition<string?, string?, string?>)definition;
        }

        /// <summary>
        ///     Found column on table '{tableName}' with name: '{columnName}', data type: {dataType}, not nullable: {notNullable}, default value: {defaultValue}.
        /// </summary>
        public static EventDefinition<string?, string?, string?, bool, string?> LogFoundColumn(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundColumn;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundColumn,
                    logger,
                    static logger => new EventDefinition<string?, string?, string?, bool, string?>(
                        logger.Options,
                        SqliteEventId.ColumnFound,
                        LogLevel.Debug,
                        ""SqliteEventId.ColumnFound"",
                        level => LoggerMessage.Define<string?, string?, string?, bool, string?>(
                            level,
                            SqliteEventId.ColumnFound,
                            _resourceManager.GetString(""LogFoundColumn"")!)));
            }

            return (EventDefinition<string?, string?, string?, bool, string?>)definition;
        }

        /// <summary>
        ///     Found foreign key on table '{tableName}', id: {id}, principal table: {principalTableName}, delete action: {deleteAction}.
        /// </summary>
        public static EventDefinition<string?, long, string?, string?> LogFoundForeignKey(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundForeignKey;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundForeignKey,
                    logger,
                    static logger => new EventDefinition<string?, long, string?, string?>(
                        logger.Options,
                        SqliteEventId.ForeignKeyFound,
                        LogLevel.Debug,
                        ""SqliteEventId.ForeignKeyFound"",
                        level => LoggerMessage.Define<string?, long, string?, string?>(
                            level,
                            SqliteEventId.ForeignKeyFound,
                            _resourceManager.GetString(""LogFoundForeignKey"")!)));
            }

            return (EventDefinition<string?, long, string?, string?>)definition;
        }

        /// <summary>
        ///     Found index on table '{tableName}' with name '{indexName}', is unique: {isUnique}.
        /// </summary>
        public static EventDefinition<string?, string?, bool?> LogFoundIndex(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundIndex;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundIndex,
                    logger,
                    static logger => new EventDefinition<string?, string?, bool?>(
                        logger.Options,
                        SqliteEventId.IndexFound,
                        LogLevel.Debug,
                        ""SqliteEventId.IndexFound"",
                        level => LoggerMessage.Define<string?, string?, bool?>(
                            level,
                            SqliteEventId.IndexFound,
                            _resourceManager.GetString(""LogFoundIndex"")!)));
            }

            return (EventDefinition<string?, string?, bool?>)definition;
        }

        /// <summary>
        ///     Found primary key on table '{tableName}' with name {primaryKeyName}.
        /// </summary>
        public static EventDefinition<string?, string?> LogFoundPrimaryKey(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundPrimaryKey;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundPrimaryKey,
                    logger,
                    static logger => new EventDefinition<string?, string?>(
                        logger.Options,
                        SqliteEventId.PrimaryKeyFound,
                        LogLevel.Debug,
                        ""SqliteEventId.PrimaryKeyFound"",
                        level => LoggerMessage.Define<string?, string?>(
                            level,
                            SqliteEventId.PrimaryKeyFound,
                            _resourceManager.GetString(""LogFoundPrimaryKey"")!)));
            }

            return (EventDefinition<string?, string?>)definition;
        }

        /// <summary>
        ///     Found table with name: '{name}'.
        /// </summary>
        public static EventDefinition<string?> LogFoundTable(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundTable,
                    logger,
                    static logger => new EventDefinition<string?>(
                        logger.Options,
                        SqliteEventId.TableFound,
                        LogLevel.Debug,
                        ""SqliteEventId.TableFound"",
                        level => LoggerMessage.Define<string?>(
                            level,
                            SqliteEventId.TableFound,
                            _resourceManager.GetString(""LogFoundTable"")!)));
            }

            return (EventDefinition<string?>)definition;
        }

        /// <summary>
        ///     Found unique constraint on table '{tableName}' with name: {uniqueConstraintName}.
        /// </summary>
        public static EventDefinition<string?, string?> LogFoundUniqueConstraint(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundUniqueConstraint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogFoundUniqueConstraint,
                    logger,
                    static logger => new EventDefinition<string?, string?>(
                        logger.Options,
                        SqliteEventId.UniqueConstraintFound,
                        LogLevel.Debug,
                        ""SqliteEventId.UniqueConstraintFound"",
                        level => LoggerMessage.Define<string?, string?>(
                            level,
                            SqliteEventId.UniqueConstraintFound,
                            _resourceManager.GetString(""LogFoundUniqueConstraint"")!)));
            }

            return (EventDefinition<string?, string?>)definition;
        }

        /// <summary>
        ///     Unable to find a table in the database matching the selected table '{table}'.
        /// </summary>
        public static EventDefinition<string?> LogMissingTable(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogMissingTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogMissingTable,
                    logger,
                    static logger => new EventDefinition<string?>(
                        logger.Options,
                        SqliteEventId.MissingTableWarning,
                        LogLevel.Warning,
                        ""SqliteEventId.MissingTableWarning"",
                        level => LoggerMessage.Define<string?>(
                            level,
                            SqliteEventId.MissingTableWarning,
                            _resourceManager.GetString(""LogMissingTable"")!)));
            }

            return (EventDefinition<string?>)definition;
        }

        /// <summary>
        ///     Skipping foreign key with identity '{id}' on table '{tableName}', since the principal column '{principalColumnName}' on the foreign key's principal table, '{principalTableName}', was not found in the model.
        /// </summary>
        public static EventDefinition<string?, string?, string?, string?> LogPrincipalColumnNotFound(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogPrincipalColumnNotFound;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogPrincipalColumnNotFound,
                    logger,
                    static logger => new EventDefinition<string?, string?, string?, string?>(
                        logger.Options,
                        SqliteEventId.ForeignKeyPrincipalColumnMissingWarning,
                        LogLevel.Warning,
                        ""SqliteEventId.ForeignKeyPrincipalColumnMissingWarning"",
                        level => LoggerMessage.Define<string?, string?, string?, string?>(
                            level,
                            SqliteEventId.ForeignKeyPrincipalColumnMissingWarning,
                            _resourceManager.GetString(""LogPrincipalColumnNotFound"")!)));
            }

            return (EventDefinition<string?, string?, string?, string?>)definition;
        }

        /// <summary>
        ///     The entity type '{entityType}' is configured to use schema '{schema}', but SQLite does not support schemas. This configuration will be ignored by the SQLite provider.
        /// </summary>
        public static EventDefinition<string, string> LogSchemaConfigured(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogSchemaConfigured;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogSchemaConfigured,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SqliteEventId.SchemaConfiguredWarning,
                        LogLevel.Warning,
                        ""SqliteEventId.SchemaConfiguredWarning"",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SqliteEventId.SchemaConfiguredWarning,
                            _resourceManager.GetString(""LogSchemaConfigured"")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     The model was configured with the database sequence '{sequence}'. SQLite does not support sequences.
        /// </summary>
        public static EventDefinition<string> LogSequenceConfigured(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogSequenceConfigured;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogSequenceConfigured,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        SqliteEventId.SequenceConfiguredWarning,
                        LogLevel.Warning,
                        ""SqliteEventId.SequenceConfiguredWarning"",
                        level => LoggerMessage.Define<string>(
                            level,
                            SqliteEventId.SequenceConfiguredWarning,
                            _resourceManager.GetString(""LogSequenceConfigured"")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     An operation of type '{operationType}' will be attempted while a rebuild of table '{tableName}' is pending. The database may not be in an expected state. Review the SQL generated by this migration to help diagnose any failures. Consider moving these operations to a subsequent migration.
        /// </summary>
        public static EventDefinition<string, string> LogTableRebuildPendingWarning(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogTableRebuildPendingWarning;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogTableRebuildPendingWarning,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SqliteEventId.TableRebuildPendingWarning,
                        LogLevel.Warning,
                        ""SqliteEventId.TableRebuildPendingWarning"",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SqliteEventId.TableRebuildPendingWarning,
                            _resourceManager.GetString(""LogTableRebuildPendingWarning"")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     A connection of an unexpected type ({type}) is being used. The SQL functions prefixed with 'ef_' could not be created automatically. Manually define them if you encounter errors while querying.
        /// </summary>
        public static EventDefinition<string> LogUnexpectedConnectionType(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogUnexpectedConnectionType;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogUnexpectedConnectionType,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        SqliteEventId.UnexpectedConnectionTypeWarning,
                        LogLevel.Warning,
                        ""SqliteEventId.UnexpectedConnectionTypeWarning"",
                        level => LoggerMessage.Define<string>(
                            level,
                            SqliteEventId.UnexpectedConnectionTypeWarning,
                            _resourceManager.GetString(""LogUnexpectedConnectionType"")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     SQLite doesn't support schemas. The specified schema selection arguments will be ignored.
        /// </summary>
        public static EventDefinition LogUsingSchemaSelectionsWarning(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogUsingSchemaSelectionsWarning;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SqliteLoggingDefinitions)logger.Definitions).LogUsingSchemaSelectionsWarning,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        SqliteEventId.SchemasNotSupportedWarning,
                        LogLevel.Warning,
                        ""SqliteEventId.SchemasNotSupportedWarning"",
                        level => LoggerMessage.Define(
                            level,
                            SqliteEventId.SchemasNotSupportedWarning,
                            _resourceManager.GetString(""LogUsingSchemaSelectionsWarning"")!)));
            }

            return (EventDefinition)definition;
        }
    }",0,439 457 334 2000 123 437 457 441 2001 2002 61 418 2001 40 648 44 478 40 2000 41 46 2003 41 59 612 439 457 2004 60 461 63 44 461 63 44 461 63 62 2005 40 2006 2007 41 123 490 2008 61 40 40 2009 46 2010 46 2011 41 2007 46 2012 41 46 2005 59 392 40 2008 614 424 41 123 2008 61 2013 46 2014 40 442 40 40 2009 46 2010 46 2011 41 2007 46 2012 41 46 2005 44 2007 44 457 2007 619 418 2004 60 461 63 44 461 63 44 461 63 62 40 2007 46 2015 44 2016 46 2017 44 2018 46 2019 44 648 44 2020 619 2021 46 2022 60 461 63 44 461 63 44 461 63 62 40 2020 44 2016 46 2017 44 2002 46 2023 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 44 461 63 44 461 63 62 41 2008 59 125 612 439 457 2004 60 461 63 44 461 63 44 461 63 44 323 44 461 63 62 2024 40 2006 2007 41 123 490 2025 61 40 40 2026 46 2027 46 2028 41 2007 46 2029 41 46 2024 59 392 40 2025 614 424 41 123 2025 61 2030 46 2031 40 442 40 40 2026 46 2027 46 2028 41 2007 46 2029 41 46 2024 44 2007 44 457 2007 619 418 2004 60 461 63 44 461 63 44 461 63 44 323 44 461 63 62 40 2007 46 2032 44 2033 46 2034 44 2035 46 2036 44 648 44 2037 619 2038 46 2039 60 461 63 44 461 63 44 461 63 44 323 44 461 63 62 40 2037 44 2033 46 2034 44 2002 46 2040 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 44 461 63 44 461 63 44 323 44 461 63 62 41 2025 59 125 612 439 457 2004 60 461 63 44 413 44 461 63 44 461 63 62 2041 40 2006 2007 41 123 490 2042 61 40 40 2043 46 2044 46 2045 41 2007 46 2046 41 46 2041 59 392 40 2042 614 424 41 123 2042 61 2047 46 2048 40 442 40 40 2043 46 2044 46 2045 41 2007 46 2046 41 46 2041 44 2007 44 457 2007 619 418 2004 60 461 63 44 413 44 461 63 44 461 63 62 40 2007 46 2049 44 2050 46 2051 44 2052 46 2053 44 648 44 2054 619 2055 46 2056 60 461 63 44 413 44 461 63 44 461 63 62 40 2054 44 2050 46 2051 44 2002 46 2057 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 44 413 44 461 63 44 461 63 62 41 2042 59 125 612 439 457 2004 60 461 63 44 461 63 44 323 63 62 2058 40 2006 2007 41 123 490 2059 61 40 40 2060 46 2061 46 2062 41 2007 46 2063 41 46 2058 59 392 40 2059 614 424 41 123 2059 61 2064 46 2065 40 442 40 40 2060 46 2061 46 2062 41 2007 46 2063 41 46 2058 44 2007 44 457 2007 619 418 2004 60 461 63 44 461 63 44 323 63 62 40 2007 46 2066 44 2067 46 2068 44 2069 46 2070 44 648 44 2071 619 2072 46 2073 60 461 63 44 461 63 44 323 63 62 40 2071 44 2067 46 2068 44 2002 46 2074 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 44 461 63 44 323 63 62 41 2059 59 125 612 439 457 2004 60 461 63 44 461 63 62 2075 40 2006 2007 41 123 490 2076 61 40 40 2077 46 2078 46 2079 41 2007 46 2080 41 46 2075 59 392 40 2076 614 424 41 123 2076 61 2081 46 2082 40 442 40 40 2077 46 2078 46 2079 41 2007 46 2080 41 46 2075 44 2007 44 457 2007 619 418 2004 60 461 63 44 461 63 62 40 2007 46 2083 44 2084 46 2085 44 2086 46 2087 44 648 44 2088 619 2089 46 2090 60 461 63 44 461 63 62 40 2088 44 2084 46 2085 44 2002 46 2091 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 44 461 63 62 41 2076 59 125 612 439 457 2004 60 461 63 62 2092 40 2006 2007 41 123 490 2093 61 40 40 2094 46 2095 46 2096 41 2007 46 2097 41 46 2092 59 392 40 2093 614 424 41 123 2093 61 2098 46 2099 40 442 40 40 2094 46 2095 46 2096 41 2007 46 2097 41 46 2092 44 2007 44 457 2007 619 418 2004 60 461 63 62 40 2007 46 2100 44 2101 46 2102 44 2103 46 2104 44 648 44 2105 619 2106 46 2107 60 461 63 62 40 2105 44 2101 46 2102 44 2002 46 2108 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 62 41 2093 59 125 612 439 457 2004 60 461 63 44 461 63 62 2109 40 2006 2007 41 123 490 2110 61 40 40 2111 46 2112 46 2113 41 2007 46 2114 41 46 2109 59 392 40 2110 614 424 41 123 2110 61 2115 46 2116 40 442 40 40 2111 46 2112 46 2113 41 2007 46 2114 41 46 2109 44 2007 44 457 2007 619 418 2004 60 461 63 44 461 63 62 40 2007 46 2117 44 2118 46 2119 44 2120 46 2121 44 648 44 2122 619 2123 46 2124 60 461 63 44 461 63 62 40 2122 44 2118 46 2119 44 2002 46 2125 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 44 461 63 62 41 2110 59 125 612 439 457 2004 60 461 63 62 2126 40 2006 2007 41 123 490 2127 61 40 40 2128 46 2129 46 2130 41 2007 46 2131 41 46 2126 59 392 40 2127 614 424 41 123 2127 61 2132 46 2133 40 442 40 40 2128 46 2129 46 2130 41 2007 46 2131 41 46 2126 44 2007 44 457 2007 619 418 2004 60 461 63 62 40 2007 46 2134 44 2135 46 2136 44 2137 46 2138 44 648 44 2139 619 2140 46 2141 60 461 63 62 40 2139 44 2135 46 2136 44 2002 46 2142 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 62 41 2127 59 125 612 439 457 2004 60 461 63 44 461 63 44 461 63 44 461 63 62 2143 40 2006 2007 41 123 490 2144 61 40 40 2145 46 2146 46 2147 41 2007 46 2148 41 46 2143 59 392 40 2144 614 424 41 123 2144 61 2149 46 2150 40 442 40 40 2145 46 2146 46 2147 41 2007 46 2148 41 46 2143 44 2007 44 457 2007 619 418 2004 60 461 63 44 461 63 44 461 63 44 461 63 62 40 2007 46 2151 44 2152 46 2153 44 2154 46 2155 44 648 44 2156 619 2157 46 2158 60 461 63 44 461 63 44 461 63 44 461 63 62 40 2156 44 2152 46 2153 44 2002 46 2159 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 63 44 461 63 44 461 63 44 461 63 62 41 2144 59 125 612 439 457 2004 60 461 44 461 62 2160 40 2006 2007 41 123 490 2161 61 40 40 2162 46 2163 46 2164 41 2007 46 2165 41 46 2160 59 392 40 2161 614 424 41 123 2161 61 2166 46 2167 40 442 40 40 2162 46 2163 46 2164 41 2007 46 2165 41 46 2160 44 2007 44 457 2007 619 418 2004 60 461 44 461 62 40 2007 46 2168 44 2169 46 2170 44 2171 46 2172 44 648 44 2173 619 2174 46 2175 60 461 44 461 62 40 2173 44 2169 46 2170 44 2002 46 2176 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 44 461 62 41 2161 59 125 612 439 457 2004 60 461 62 2177 40 2006 2007 41 123 490 2178 61 40 40 2179 46 2180 46 2181 41 2007 46 2182 41 46 2177 59 392 40 2178 614 424 41 123 2178 61 2183 46 2184 40 442 40 40 2179 46 2180 46 2181 41 2007 46 2182 41 46 2177 44 2007 44 457 2007 619 418 2004 60 461 62 40 2007 46 2185 44 2186 46 2187 44 2188 46 2189 44 648 44 2190 619 2191 46 2192 60 461 62 40 2190 44 2186 46 2187 44 2002 46 2193 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 62 41 2178 59 125 612 439 457 2004 60 461 44 461 62 2194 40 2006 2007 41 123 490 2195 61 40 40 2196 46 2197 46 2198 41 2007 46 2199 41 46 2194 59 392 40 2195 614 424 41 123 2195 61 2200 46 2201 40 442 40 40 2196 46 2197 46 2198 41 2007 46 2199 41 46 2194 44 2007 44 457 2007 619 418 2004 60 461 44 461 62 40 2007 46 2202 44 2203 46 2204 44 2205 46 2206 44 648 44 2207 619 2208 46 2209 60 461 44 461 62 40 2207 44 2203 46 2204 44 2002 46 2210 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 44 461 62 41 2195 59 125 612 439 457 2004 60 461 62 2211 40 2006 2007 41 123 490 2212 61 40 40 2213 46 2214 46 2215 41 2007 46 2216 41 46 2211 59 392 40 2212 614 424 41 123 2212 61 2217 46 2218 40 442 40 40 2213 46 2214 46 2215 41 2007 46 2216 41 46 2211 44 2007 44 457 2007 619 418 2004 60 461 62 40 2007 46 2219 44 2220 46 2221 44 2222 46 2223 44 648 44 2224 619 2225 46 2226 60 461 62 40 2224 44 2220 46 2221 44 2002 46 2227 40 648 41 33 41 41 41 59 125 450 40 2004 60 461 62 41 2212 59 125 612 439 457 2004 2228 40 2006 2007 41 123 490 2229 61 40 40 2230 46 2231 46 2232 41 2007 46 2233 41 46 2228 59 392 40 2229 614 424 41 123 2229 61 2234 46 2235 40 442 40 40 2230 46 2231 46 2232 41 2007 46 2233 41 46 2228 44 2007 44 457 2007 619 418 2004 40 2007 46 2236 44 2237 46 2238 44 2239 46 2240 44 648 44 2241 619 2242 46 2243 40 2241 44 2237 46 2238 44 2002 46 2244 40 648 41 33 41 41 41 59 125 450 40 2004 41 2229 59 125 125 
68689,C#,"public static class SqliteServiceCollectionExtensions
{
    /// <summary>
    ///     Registers the given Entity Framework <see cref=""DbContext"" /> as a service in the <see cref=""IServiceCollection"" />
    ///     and configures it to connect to a SQLite database.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         This method is a shortcut for configuring a <see cref=""DbContext"" /> to use SQLite. It does not support all options.
    ///         Use <see cref=""O:EntityFrameworkServiceCollectionExtensions.AddDbContext"" /> and related methods for full control of
    ///         this process.
    ///     </para>
    ///     <para>
    ///         Use this method when using dependency injection in your application, such as with ASP.NET Core.
    ///         For applications that don't use dependency injection, consider creating <see cref=""DbContext"" />
    ///         instances directly with its constructor. The <see cref=""DbContext.OnConfiguring"" /> method can then be
    ///         overridden to configure the SQLite provider and connection string.
    ///     </para>
    ///     <para>
    ///         To configure the <see cref=""DbContextOptions{TContext}"" /> for the context, either override the
    ///         <see cref=""DbContext.OnConfiguring"" /> method in your derived context, or supply
    ///         an optional action to configure the <see cref=""DbContextOptions"" /> for the context.
    ///     </para>
    ///     <para>
    ///         See <see href=""https://aka.ms/efcore-docs-di"">Using DbContext with dependency injection</see> for more information and examples.
    ///     </para>
    ///     <para>
    ///         See <see href=""https://aka.ms/efcore-docs-dbcontext-options"">Using DbContextOptions</see>, and
    ///         <see href=""https://aka.ms/efcore-docs-sqlite"">Accessing SQLite databases with EF Core</see> for more information and examples.
    ///     </para>
    /// </remarks>
    /// <typeparam name=""TContext"">The type of context to be registered.</typeparam>
    /// <param name=""serviceCollection"">The <see cref=""IServiceCollection"" /> to add services to.</param>
    /// <param name=""connectionString"">The connection string of the database to connect to.</param>
    /// <param name=""sqliteOptionsAction"">An optional action to allow additional SQLite specific configuration.</param>
    /// <param name=""optionsAction"">An optional action to configure the <see cref=""DbContextOptions"" /> for the context.</param>
    /// <returns>The same service collection so that multiple calls can be chained.</returns>
    public static IServiceCollection AddSqlite<TContext>(
        this IServiceCollection serviceCollection,
        string connectionString,
        Action<SqliteDbContextOptionsBuilder>? sqliteOptionsAction = null,
        Action<DbContextOptionsBuilder>? optionsAction = null)
        where TContext : DbContext
    {
        Check.NotEmpty(connectionString, nameof(connectionString));

        return serviceCollection.AddDbContext<TContext>(
            (_, options) =>
            {
                optionsAction?.Invoke(options);
                options.UseSqlite(connectionString, sqliteOptionsAction);
            });
    }

    /// <summary>
    ///     <para>
    ///         Adds the services required by the SQLite database provider for Entity Framework
    ///         to an <see cref=""IServiceCollection"" />.
    ///     </para>
    ///     <para>
    ///         Warning: Do not call this method accidentally. It is much more likely you need
    ///         to call <see cref=""AddSqlite{TContext}"" />.
    ///     </para>
    /// </summary>
    /// <remarks>
    ///     Calling this method is no longer necessary when building most applications, including those that
    ///     use dependency injection in ASP.NET or elsewhere.
    ///     It is only needed when building the internal service provider for use with
    ///     the <see cref=""DbContextOptionsBuilder.UseInternalServiceProvider"" /> method.
    ///     This is not recommend other than for some advanced scenarios.
    /// </remarks>
    /// <param name=""serviceCollection"">The <see cref=""IServiceCollection"" /> to add services to.</param>
    /// <returns>
    ///     The same service collection so that multiple calls can be chained.
    /// </returns>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static IServiceCollection AddEntityFrameworkSqlite(this IServiceCollection serviceCollection)
    {
        var builder = new EntityFrameworkRelationalServicesBuilder(serviceCollection)
            .TryAdd<LoggingDefinitions, SqliteLoggingDefinitions>()
            .TryAdd<IDatabaseProvider, DatabaseProvider<SqliteOptionsExtension>>()
            .TryAdd<IRelationalTypeMappingSource, SqliteTypeMappingSource>()
            .TryAdd<ISqlGenerationHelper, SqliteSqlGenerationHelper>()
            .TryAdd<IRelationalAnnotationProvider, SqliteAnnotationProvider>()
            .TryAdd<IModelValidator, SqliteModelValidator>()
            .TryAdd<IProviderConventionSetBuilder, SqliteConventionSetBuilder>()
            .TryAdd<IUpdateSqlGenerator, SqliteUpdateSqlGenerator>()
            .TryAdd<IModificationCommandBatchFactory, SqliteModificationCommandBatchFactory>()
            .TryAdd<IRelationalConnection>(p => p.GetRequiredService<ISqliteRelationalConnection>())
            .TryAdd<IMigrationsSqlGenerator, SqliteMigrationsSqlGenerator>()
            .TryAdd<IRelationalDatabaseCreator, SqliteDatabaseCreator>()
            .TryAdd<IHistoryRepository, SqliteHistoryRepository>()
            .TryAdd<IRelationalQueryStringFactory, SqliteQueryStringFactory>()

            // New Query Pipeline
            .TryAdd<IMethodCallTranslatorProvider, SqliteMethodCallTranslatorProvider>()
            .TryAdd<IMemberTranslatorProvider, SqliteMemberTranslatorProvider>()
            .TryAdd<IQuerySqlGeneratorFactory, SqliteQuerySqlGeneratorFactory>()
            .TryAdd<IQueryableMethodTranslatingExpressionVisitorFactory, SqliteQueryableMethodTranslatingExpressionVisitorFactory>()
            .TryAdd<IRelationalSqlTranslatingExpressionVisitorFactory, SqliteSqlTranslatingExpressionVisitorFactory>()
            .TryAdd<IQueryTranslationPostprocessorFactory, SqliteQueryTranslationPostprocessorFactory>()
            .TryAddProviderSpecificServices(
                b => b.TryAddScoped<ISqliteRelationalConnection, SqliteRelationalConnection>());

        builder.TryAddCoreServices();

        return serviceCollection;
    }
}",0,439 457 334 2000 123 612 439 457 2001 2002 60 2003 62 40 467 2001 2004 44 461 2005 44 2006 60 2007 62 63 2008 61 424 44 2006 60 2009 62 63 2010 61 424 41 2011 2003 58 2012 123 2013 46 2014 40 2005 44 2015 40 2005 41 41 59 450 2004 46 2016 60 2003 62 40 40 2017 44 2018 41 619 123 2010 634 2019 40 2018 41 59 2018 46 2020 40 2005 44 2008 41 59 125 41 59 125 612 91 2021 40 2022 46 2023 41 93 439 457 2001 2024 40 467 2001 2004 41 123 490 2025 61 418 2026 40 2004 41 46 2027 60 2028 44 2029 62 40 41 46 2027 60 2030 44 2031 60 2032 640 40 41 46 2027 60 2033 44 2034 62 40 41 46 2027 60 2035 44 2036 62 40 41 46 2027 60 2037 44 2038 62 40 41 46 2027 60 2039 44 2040 62 40 41 46 2027 60 2041 44 2042 62 40 41 46 2027 60 2043 44 2044 62 40 41 46 2027 60 2045 44 2046 62 40 41 46 2027 60 2047 62 40 2048 619 2048 46 2049 60 2050 62 40 41 41 46 2027 60 2051 44 2052 62 40 41 46 2027 60 2053 44 2054 62 40 41 46 2027 60 2055 44 2056 62 40 41 46 2027 60 2057 44 2058 62 40 41 621 46 2027 60 2059 44 2060 62 40 41 46 2027 60 2061 44 2062 62 40 41 46 2027 60 2063 44 2064 62 40 41 46 2027 60 2065 44 2066 62 40 41 46 2027 60 2067 44 2068 62 40 41 46 2027 60 2069 44 2070 62 40 41 46 2071 40 2072 619 2072 46 2073 60 2050 44 2074 62 40 41 41 59 2025 46 2075 40 41 59 450 2004 59 125 125 
70670,C#,"public class CandidateNamingService : ICandidateNamingService
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual string GenerateCandidateIdentifier(DatabaseTable originalTable)
        => GenerateCandidateIdentifier(originalTable.Name);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual string GenerateCandidateIdentifier(DatabaseColumn originalColumn)
        => GenerateCandidateIdentifier(originalColumn.Name);

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual string GetDependentEndCandidateNavigationPropertyName(IReadOnlyForeignKey foreignKey)
    {
        var candidateName = FindCandidateNavigationName(foreignKey.Properties);

        return !string.IsNullOrEmpty(candidateName) ? candidateName : foreignKey.PrincipalEntityType.ShortName();
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual string GetPrincipalEndCandidateNavigationPropertyName(
        IReadOnlyForeignKey foreignKey,
        string dependentEndNavigationPropertyName)
    {
        var allForeignKeysBetweenDependentAndPrincipal =
            foreignKey.PrincipalEntityType?
                .GetReferencingForeignKeys()
                .Where(fk => foreignKey.DeclaringEntityType == fk.DeclaringEntityType);

        return allForeignKeysBetweenDependentAndPrincipal?.Count() > 1
            ? foreignKey.DeclaringEntityType.ShortName()
            + dependentEndNavigationPropertyName
            : foreignKey.DeclaringEntityType.ShortName();
    }

    private static string GenerateCandidateIdentifier(string originalIdentifier)
    {
        var candidateStringBuilder = new StringBuilder();
        var previousLetterCharInWordIsLowerCase = false;
        var isFirstCharacterInWord = true;
        foreach (var c in originalIdentifier)
        {
            var isNotLetterOrDigit = !char.IsLetterOrDigit(c);
            if (isNotLetterOrDigit
                || (previousLetterCharInWordIsLowerCase && char.IsUpper(c)))
            {
                isFirstCharacterInWord = true;
                previousLetterCharInWordIsLowerCase = false;
                if (isNotLetterOrDigit)
                {
                    continue;
                }
            }

            candidateStringBuilder.Append(
                isFirstCharacterInWord ? char.ToUpperInvariant(c) : char.ToLowerInvariant(c));
            isFirstCharacterInWord = false;
            if (char.IsLower(c))
            {
                previousLetterCharInWordIsLowerCase = true;
            }
        }

        return candidateStringBuilder.ToString();
    }

    private static string FindCandidateNavigationName(IEnumerable<IReadOnlyProperty> properties)
    {
        var count = properties.Count();
        if (count == 0)
        {
            return string.Empty;
        }

        var firstProperty = properties.First();
        return StripId(
            count == 1
                ? firstProperty.Name
                : FindCommonPrefix(firstProperty.Name, properties.Select(p => p.Name)));
    }

    private static string FindCommonPrefix(string firstName, IEnumerable<string> propertyNames)
    {
        var prefixLength = 0;
        foreach (var c in firstName)
        {
            foreach (var s in propertyNames)
            {
                if (s.Length <= prefixLength
                    || s[prefixLength] != c)
                {
                    return firstName[..prefixLength];
                }
            }

            prefixLength++;
        }

        return firstName[..prefixLength];
    }

    private static string StripId(string commonPrefix)
    {
        if (commonPrefix.Length < 3
            || !commonPrefix.EndsWith(""id"", StringComparison.OrdinalIgnoreCase))
        {
            return commonPrefix;
        }

        int i;
        for (i = commonPrefix.Length - 3; i >= 0; i--)
        {
            if (char.IsLetterOrDigit(commonPrefix[i]))
            {
                break;
            }
        }

        return i != 0
            ? commonPrefix[..(i + 1)]
            : commonPrefix;
    }
}",0,439 334 2000 58 2001 123 612 439 491 461 2002 40 2003 2004 41 619 2002 40 2004 46 2005 41 59 612 439 491 461 2002 40 2006 2007 41 619 2002 40 2007 46 2005 41 59 612 439 491 461 2008 40 2009 2010 41 123 490 2011 61 2012 40 2010 46 2013 41 59 450 33 461 46 2014 40 2011 41 63 2011 58 2010 46 2015 46 2016 40 41 59 125 612 439 491 461 2017 40 2009 2010 44 461 2018 41 123 490 2019 61 2010 46 2020 63 46 2021 40 41 46 2022 40 2023 619 2010 46 2024 614 2023 46 2024 41 59 450 2019 634 2025 40 41 62 1501 63 2010 46 2024 46 2026 40 41 43 2018 58 2010 46 2024 46 2026 40 41 59 125 437 457 461 2002 40 461 2027 41 123 490 2028 61 418 2029 40 41 59 490 2030 61 380 59 490 2031 61 473 59 386 40 490 2032 398 2027 41 123 490 2033 61 33 330 46 2034 40 2032 41 59 392 40 2033 606 40 2030 605 330 46 2035 40 2032 41 41 41 123 2031 61 473 59 2030 61 380 59 392 40 2033 41 123 344 59 125 125 2028 46 2036 40 2031 63 330 46 2037 40 2032 41 58 330 46 2038 40 2032 41 41 59 2031 61 380 59 392 40 330 46 2039 40 2032 41 41 123 2030 61 473 59 125 125 450 2028 46 2040 40 41 59 125 437 457 461 2041 40 2042 60 2043 62 2044 41 123 490 2045 61 2044 46 2046 40 41 59 392 40 2045 614 1500 41 123 450 461 46 2047 59 125 490 2048 61 2044 46 2049 40 41 59 450 2050 40 2045 614 1501 63 2048 46 2005 58 2051 40 2048 46 2005 44 2044 46 2052 40 2053 619 2053 46 2005 41 41 41 59 125 437 457 461 2054 40 461 2055 44 2042 60 461 62 2056 41 123 490 2057 61 1500 59 386 40 490 2058 398 2055 41 123 386 40 490 2059 398 2056 41 123 392 40 2059 46 2060 620 2057 606 2059 91 2057 93 631 2058 41 123 450 2055 91 46 46 2057 93 59 125 125 2057 637 59 125 450 2055 91 46 46 2057 93 59 125 437 457 461 2061 40 461 2062 41 123 392 40 2062 46 2063 60 1502 606 33 2062 46 2064 40 648 44 2065 46 2066 41 41 123 450 2062 59 125 404 2067 59 385 40 2067 61 2062 46 2063 45 1502 59 2067 615 1500 59 2067 629 41 123 392 40 330 46 2068 40 2062 91 2067 93 41 41 123 325 59 125 125 450 2067 631 1500 63 2062 91 46 46 40 2067 43 1501 41 93 58 2062 59 125 125 
71574,C#,"    public class BuiltInDataTypesSqliteFixture : BuiltInDataTypesFixtureBase
    {
        public override bool StrictEquality
            => false;

        public override bool SupportsAnsi
            => false;

        public override bool SupportsUnicodeToAnsiConversion
            => true;

        public override bool SupportsLargeStringComparisons
            => true;

        public override bool SupportsDecimalComparisons
            => false;

        public override bool PreservesDateTimeKind
            => false;

        protected override ITestStoreFactory TestStoreFactory
            => SqliteTestStoreFactory.Instance;

        public TestSqlLoggerFactory TestSqlLoggerFactory
            => (TestSqlLoggerFactory)ListLoggerFactory;

        protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext context)
        {
            base.OnModelCreating(modelBuilder, context);

            modelBuilder.Entity<MappedDataTypes>(
                b =>
                {
                    b.Property(e => e.Id).ValueGeneratedNever();
                    b.Property(e => e.Integer).HasColumnType(""Integer"");
                    b.Property(e => e.Real).HasColumnType(""Real"");
                    b.Property(e => e.Text).HasColumnType(""Text"").IsRequired();
                    b.Property(e => e.Blob).HasColumnType(""Blob"").IsRequired();
                    b.Property(e => e.SomeString).HasColumnType(""SomeString"").IsRequired();
                    b.Property(e => e.Int).HasColumnType(""Int"");
                });

            modelBuilder.Entity<MappedNullableDataTypes>(
                b =>
                {
                    b.Property(e => e.Id).ValueGeneratedNever();
                    b.Property(e => e.Integer).HasColumnType(""Integer"");
                    b.Property(e => e.Real).HasColumnType(""Real"");
                    b.Property(e => e.Text).HasColumnType(""Text"");
                    b.Property(e => e.Blob).HasColumnType(""Blob"");
                    b.Property(e => e.SomeString).HasColumnType(""SomeString"");
                    b.Property(e => e.Int).HasColumnType(""Int"");
                });

            modelBuilder.Entity<MappedSizedDataTypes>(
                b =>
                {
                    b.Property(e => e.Id).ValueGeneratedNever();
                    b.Property(e => e.Nvarchar).HasColumnType(""nvarchar(3)"");
                    b.Property(e => e.Binary).HasColumnType(""varbinary(3)"");
                });

            modelBuilder.Entity<MappedScaledDataTypes>(
                b =>
                {
                    b.Property(e => e.Id).ValueGeneratedNever();
                    b.Property(e => e.Float).HasColumnType(""real(3)"");
                    b.Property(e => e.Datetimeoffset).HasColumnType(""datetimeoffset(3)"");
                    b.Property(e => e.Datetime2).HasColumnType(""datetime2(3)"");
                    b.Property(e => e.Decimal).HasColumnType(""decimal(3)"");
                });

            modelBuilder.Entity<MappedPrecisionAndScaledDataTypes>(
                b =>
                {
                    b.Property(e => e.Id).ValueGeneratedNever();
                    b.Property(e => e.Decimal).HasColumnType(""decimal(5, 2)"");
                });

            modelBuilder.Entity<MappedDataTypesWithIdentity>(
                b =>
                {
                    b.Property(e => e.Integer).HasColumnType(""Integer"");
                    b.Property(e => e.Real).HasColumnType(""Real"");
                    b.Property(e => e.Text).HasColumnType(""Text"").IsRequired();
                    b.Property(e => e.Blob).HasColumnType(""Blob"").IsRequired();
                    b.Property(e => e.SomeString).HasColumnType(""SomeString"").IsRequired();
                    b.Property(e => e.Int).HasColumnType(""Int"");
                });

            modelBuilder.Entity<MappedNullableDataTypesWithIdentity>(
                b =>
                {
                    b.Property(e => e.Integer).HasColumnType(""Integer"");
                    b.Property(e => e.Real).HasColumnType(""Real"");
                    b.Property(e => e.Text).HasColumnType(""Text"");
                    b.Property(e => e.Blob).HasColumnType(""Blob"");
                    b.Property(e => e.SomeString).HasColumnType(""SomeString"");
                    b.Property(e => e.Int).HasColumnType(""Int"");
                });

            modelBuilder.Entity<MappedSizedDataTypesWithIdentity>(
                b =>
                {
                    b.Property(e => e.Nvarchar).HasColumnType(""nvarchar(3)"");
                    b.Property(e => e.Binary).HasColumnType(""varbinary(3)"");
                });

            modelBuilder.Entity<MappedScaledDataTypesWithIdentity>(
                b =>
                {
                    b.Property(e => e.Float).HasColumnType(""real(3)"");
                    b.Property(e => e.Datetimeoffset).HasColumnType(""datetimeoffset(3)"");
                    b.Property(e => e.Datetime2).HasColumnType(""datetime2(3)"");
                    b.Property(e => e.Decimal).HasColumnType(""decimal(3)"");
                });

            modelBuilder.Entity<MappedPrecisionAndScaledDataTypesWithIdentity>(
                b => b.Property(e => e.Decimal).HasColumnType(""decimal(5, 2)""));
        }

        public override bool SupportsBinaryKeys
            => true;

        public override DateTime DefaultDateTime
            => new();
    }",0,439 334 2000 58 2001 123 439 431 323 2002 619 380 59 439 431 323 2003 619 380 59 439 431 323 2004 619 473 59 439 431 323 2005 619 473 59 439 431 323 2006 619 380 59 439 431 323 2007 619 380 59 438 431 2008 2009 619 2010 46 2011 59 439 2012 2012 619 40 2012 41 2013 59 438 431 492 2014 40 2015 2016 44 2017 2018 41 123 320 46 2014 40 2016 44 2018 41 59 2016 46 2019 60 2020 62 40 2021 619 123 2021 46 2022 40 2023 619 2023 46 2024 41 46 2025 40 41 59 2021 46 2022 40 2023 619 2023 46 2026 41 46 2027 40 648 41 59 2021 46 2022 40 2023 619 2023 46 2028 41 46 2027 40 648 41 59 2021 46 2022 40 2023 619 2023 46 2029 41 46 2027 40 648 41 46 2030 40 41 59 2021 46 2022 40 2023 619 2023 46 2031 41 46 2027 40 648 41 46 2030 40 41 59 2021 46 2022 40 2023 619 2023 46 2032 41 46 2027 40 648 41 46 2030 40 41 59 2021 46 2022 40 2023 619 2023 46 2033 41 46 2027 40 648 41 59 125 41 59 2016 46 2019 60 2034 62 40 2021 619 123 2021 46 2035 40 2036 619 2036 46 2037 41 46 2038 40 41 59 2021 46 2035 40 2036 619 2036 46 2039 41 46 2040 40 648 41 59 2021 46 2035 40 2036 619 2036 46 2041 41 46 2040 40 648 41 59 2021 46 2035 40 2036 619 2036 46 2042 41 46 2040 40 648 41 59 2021 46 2035 40 2036 619 2036 46 2043 41 46 2040 40 648 41 59 2021 46 2035 40 2036 619 2036 46 2044 41 46 2040 40 648 41 59 2021 46 2035 40 2036 619 2036 46 2045 41 46 2040 40 648 41 59 125 41 59 2016 46 2019 60 2046 62 40 2021 619 123 2021 46 2047 40 2048 619 2048 46 2049 41 46 2050 40 41 59 2021 46 2047 40 2048 619 2048 46 2051 41 46 2052 40 648 41 59 2021 46 2047 40 2048 619 2048 46 2053 41 46 2052 40 648 41 59 125 41 59 2016 46 2019 60 2054 62 40 2021 619 123 2021 46 2055 40 2056 619 2056 46 2057 41 46 2058 40 41 59 2021 46 2055 40 2056 619 2056 46 2059 41 46 2060 40 648 41 59 2021 46 2055 40 2056 619 2056 46 2061 41 46 2060 40 648 41 59 2021 46 2055 40 2056 619 2056 46 2062 41 46 2060 40 648 41 59 2021 46 2055 40 2056 619 2056 46 2063 41 46 2060 40 648 41 59 125 41 59 2016 46 2019 60 2064 62 40 2021 619 123 2021 46 2065 40 2066 619 2066 46 2067 41 46 2068 40 41 59 2021 46 2065 40 2066 619 2066 46 2069 41 46 2070 40 648 41 59 125 41 59 2016 46 2019 60 2071 62 40 2021 619 123 2021 46 2072 40 2073 619 2073 46 2074 41 46 2075 40 648 41 59 2021 46 2072 40 2073 619 2073 46 2076 41 46 2075 40 648 41 59 2021 46 2072 40 2073 619 2073 46 2077 41 46 2075 40 648 41 46 2078 40 41 59 2021 46 2072 40 2073 619 2073 46 2079 41 46 2075 40 648 41 46 2078 40 41 59 2021 46 2072 40 2073 619 2073 46 2080 41 46 2075 40 648 41 46 2078 40 41 59 2021 46 2072 40 2073 619 2073 46 2081 41 46 2075 40 648 41 59 125 41 59 2016 46 2019 60 2082 62 40 2021 619 123 2021 46 2083 40 2084 619 2084 46 2085 41 46 2086 40 648 41 59 2021 46 2083 40 2084 619 2084 46 2087 41 46 2086 40 648 41 59 2021 46 2083 40 2084 619 2084 46 2088 41 46 2086 40 648 41 59 2021 46 2083 40 2084 619 2084 46 2089 41 46 2086 40 648 41 59 2021 46 2083 40 2084 619 2084 46 2090 41 46 2086 40 648 41 59 2021 46 2083 40 2084 619 2084 46 2091 41 46 2086 40 648 41 59 125 41 59 2016 46 2019 60 2092 62 40 2021 619 123 2021 46 2093 40 2094 619 2094 46 2095 41 46 2096 40 648 41 59 2021 46 2093 40 2094 619 2094 46 2097 41 46 2096 40 648 41 59 125 41 59 2016 46 2019 60 2098 62 40 2021 619 123 2021 46 2099 40 2100 619 2100 46 2101 41 46 2102 40 648 41 59 2021 46 2099 40 2100 619 2100 46 2103 41 46 2102 40 648 41 59 2021 46 2099 40 2100 619 2100 46 2104 41 46 2102 40 648 41 59 2021 46 2099 40 2100 619 2100 46 2105 41 46 2102 40 648 41 59 125 41 59 2016 46 2019 60 2106 62 40 2021 619 2021 46 2107 40 2108 619 2108 46 2109 41 46 2110 40 648 41 41 59 125 439 431 323 2111 619 473 59 439 431 2112 2113 619 418 40 41 59 125 
69045,C#,"public class SqliteSqlTranslatingExpressionVisitor : RelationalSqlTranslatingExpressionVisitor
{
    private static readonly IReadOnlyDictionary<ExpressionType, IReadOnlyCollection<Type>> RestrictedBinaryExpressions
        = new Dictionary<ExpressionType, IReadOnlyCollection<Type>>
        {
            [ExpressionType.Add] = new HashSet<Type>
            {
                typeof(DateTime),
                typeof(DateTimeOffset),
                typeof(TimeSpan)
            },
            [ExpressionType.Divide] = new HashSet<Type> { typeof(TimeSpan), typeof(ulong) },
            [ExpressionType.GreaterThan] = new HashSet<Type>
            {
                typeof(DateTimeOffset),
                typeof(TimeSpan),
                typeof(ulong)
            },
            [ExpressionType.GreaterThanOrEqual] = new HashSet<Type>
            {
                typeof(DateTimeOffset),
                typeof(TimeSpan),
                typeof(ulong)
            },
            [ExpressionType.LessThan] = new HashSet<Type>
            {
                typeof(DateTimeOffset),
                typeof(TimeSpan),
                typeof(ulong)
            },
            [ExpressionType.LessThanOrEqual] = new HashSet<Type>
            {
                typeof(DateTimeOffset),
                typeof(TimeSpan),
                typeof(ulong)
            },
            [ExpressionType.Modulo] = new HashSet<Type> { typeof(ulong) },
            [ExpressionType.Multiply] = new HashSet<Type> { typeof(TimeSpan), typeof(ulong) },
            [ExpressionType.Subtract] = new HashSet<Type>
            {
                typeof(DateTime),
                typeof(DateTimeOffset),
                typeof(TimeSpan)
            }
        };

    private static readonly IReadOnlyCollection<Type> FunctionModuloTypes = new HashSet<Type>
    {
        typeof(decimal),
        typeof(double),
        typeof(float)
    };

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public SqliteSqlTranslatingExpressionVisitor(
        RelationalSqlTranslatingExpressionVisitorDependencies dependencies,
        QueryCompilationContext queryCompilationContext,
        QueryableMethodTranslatingExpressionVisitor queryableMethodTranslatingExpressionVisitor)
        : base(dependencies, queryCompilationContext, queryableMethodTranslatingExpressionVisitor)
    {
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override Expression VisitUnary(UnaryExpression unaryExpression)
    {
        if (unaryExpression.NodeType == ExpressionType.ArrayLength
            && unaryExpression.Operand.Type == typeof(byte[]))
        {
            return Visit(unaryExpression.Operand) is SqlExpression sqlExpression
                ? Dependencies.SqlExpressionFactory.Function(
                    ""length"",
                    new[] { sqlExpression },
                    nullable: true,
                    argumentsPropagateNullability: new[] { true },
                    typeof(int))
                : QueryCompilationContext.NotTranslatedExpression;
        }

        var visitedExpression = base.VisitUnary(unaryExpression);
        if (visitedExpression == QueryCompilationContext.NotTranslatedExpression)
        {
            return QueryCompilationContext.NotTranslatedExpression;
        }

        if (visitedExpression is SqlUnaryExpression sqlUnary
            && sqlUnary.OperatorType == ExpressionType.Negate)
        {
            var operandType = GetProviderType(sqlUnary.Operand);
            if (operandType == typeof(decimal))
            {
                return Dependencies.SqlExpressionFactory.Function(
                    name: ""ef_negate"",
                    new[] { sqlUnary.Operand },
                    nullable: true,
                    new[] { true },
                    visitedExpression.Type);
            }

            if (operandType == typeof(TimeSpan))
            {
                return QueryCompilationContext.NotTranslatedExpression;
            }
        }

        return visitedExpression;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    protected override Expression VisitBinary(BinaryExpression binaryExpression)
    {
        // See issue#16428
        //if (binaryExpression.NodeType == ExpressionType.ArrayIndex
        //    && binaryExpression.Left.Type == typeof(byte[]))
        //{
        //    var left = Visit(binaryExpression.Left);
        //    var right = Visit(binaryExpression.Right);

        //    if (left is SqlExpression leftSql
        //        && right is SqlExpression rightSql)
        //    {
        //        return Dependencies.SqlExpressionFactory.Function(
        //            ""unicode"",
        //            new SqlExpression[]
        //            {
        //                Dependencies.SqlExpressionFactory.Function(
        //                    ""substr"",
        //                    new SqlExpression[]
        //                    {
        //                        leftSql,
        //                        Dependencies.SqlExpressionFactory.Add(
        //                            Dependencies.SqlExpressionFactory.ApplyDefaultTypeMapping(rightSql),
        //                            Dependencies.SqlExpressionFactory.Constant(1)),
        //                        Dependencies.SqlExpressionFactory.Constant(1)
        //                    },
        //                    nullable: true,
        //                    argumentsPropagateNullability: new[] { true, true, true },
        //                    typeof(byte[]))
        //            },
        //            nullable: true,
        //            argumentsPropagateNullability: new[] { true },
        //            binaryExpression.Type);
        //    }
        //}

        if (!(base.VisitBinary(binaryExpression) is SqlExpression visitedExpression))
        {
            return QueryCompilationContext.NotTranslatedExpression;
        }

        if (visitedExpression is SqlBinaryExpression sqlBinary)
        {
            if (sqlBinary.OperatorType == ExpressionType.Modulo
                && (FunctionModuloTypes.Contains(GetProviderType(sqlBinary.Left))
                    || FunctionModuloTypes.Contains(GetProviderType(sqlBinary.Right))))
            {
                return Dependencies.SqlExpressionFactory.Function(
                    ""ef_mod"",
                    new[] { sqlBinary.Left, sqlBinary.Right },
                    nullable: true,
                    argumentsPropagateNullability: new[] { true, true },
                    visitedExpression.Type,
                    visitedExpression.TypeMapping);
            }

            if (AttemptDecimalCompare(sqlBinary))
            {
                return DoDecimalCompare(visitedExpression, sqlBinary.OperatorType, sqlBinary.Left, sqlBinary.Right);
            }

            if (AttemptDecimalArithmetic(sqlBinary))
            {
                return DoDecimalArithmetics(visitedExpression, sqlBinary.OperatorType, sqlBinary.Left, sqlBinary.Right);
            }

            if (RestrictedBinaryExpressions.TryGetValue(sqlBinary.OperatorType, out var restrictedTypes)
                && (restrictedTypes.Contains(GetProviderType(sqlBinary.Left))
                    || restrictedTypes.Contains(GetProviderType(sqlBinary.Right))))
            {
                return QueryCompilationContext.NotTranslatedExpression;
            }
        }

        return visitedExpression;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override SqlExpression? TranslateAverage(SqlExpression sqlExpression)
    {
        var visitedExpression = base.TranslateAverage(sqlExpression);
        var argumentType = GetProviderType(visitedExpression);
        if (argumentType == typeof(decimal))
        {
            throw new NotSupportedException(
                SqliteStrings.AggregateOperationNotSupported(nameof(Queryable.Average), argumentType.ShortDisplayName()));
        }

        return visitedExpression;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override SqlExpression? TranslateMax(SqlExpression sqlExpression)
    {
        var visitedExpression = base.TranslateMax(sqlExpression);
        var argumentType = GetProviderType(visitedExpression);
        if (argumentType == typeof(DateTimeOffset)
            || argumentType == typeof(decimal)
            || argumentType == typeof(TimeSpan)
            || argumentType == typeof(ulong))
        {
            throw new NotSupportedException(
                SqliteStrings.AggregateOperationNotSupported(nameof(Queryable.Max), argumentType.ShortDisplayName()));
        }

        return visitedExpression;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override SqlExpression? TranslateMin(SqlExpression sqlExpression)
    {
        var visitedExpression = base.TranslateMin(sqlExpression);
        var argumentType = GetProviderType(visitedExpression);
        if (argumentType == typeof(DateTimeOffset)
            || argumentType == typeof(decimal)
            || argumentType == typeof(TimeSpan)
            || argumentType == typeof(ulong))
        {
            throw new NotSupportedException(
                SqliteStrings.AggregateOperationNotSupported(nameof(Queryable.Min), argumentType.ShortDisplayName()));
        }

        return visitedExpression;
    }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public override SqlExpression? TranslateSum(SqlExpression sqlExpression)
    {
        var visitedExpression = base.TranslateSum(sqlExpression);
        var argumentType = GetProviderType(visitedExpression);
        if (argumentType == typeof(decimal))
        {
            throw new NotSupportedException(
                SqliteStrings.AggregateOperationNotSupported(nameof(Queryable.Sum), argumentType.ShortDisplayName()));
        }

        return visitedExpression;
    }

    private static Type? GetProviderType(SqlExpression? expression)
        => expression == null
            ? null
            : (expression.TypeMapping?.Converter?.ProviderClrType
                ?? expression.TypeMapping?.ClrType
                ?? expression.Type);

    private static bool AreOperandsDecimals(SqlBinaryExpression sqlExpression)
        => GetProviderType(sqlExpression.Left) == typeof(decimal)
            && GetProviderType(sqlExpression.Right) == typeof(decimal);

    private static bool AttemptDecimalCompare(SqlBinaryExpression sqlBinary)
        => AreOperandsDecimals(sqlBinary)
            && new[]
            {
                ExpressionType.GreaterThan, ExpressionType.GreaterThanOrEqual, ExpressionType.LessThan, ExpressionType.LessThanOrEqual
            }.Contains(sqlBinary.OperatorType);

    private Expression DoDecimalCompare(SqlExpression visitedExpression, ExpressionType op, SqlExpression left, SqlExpression right)
    {
        var actual = Dependencies.SqlExpressionFactory.Function(
            name: ""ef_compare"",
            new[] { left, right },
            nullable: true,
            new[] { true, true },
            typeof(int));
        var oracle = Dependencies.SqlExpressionFactory.Constant(value: 0);

        return op switch
        {
            ExpressionType.GreaterThan => Dependencies.SqlExpressionFactory.GreaterThan(left: actual, right: oracle),
            ExpressionType.GreaterThanOrEqual => Dependencies.SqlExpressionFactory.GreaterThanOrEqual(left: actual, right: oracle),
            ExpressionType.LessThan => Dependencies.SqlExpressionFactory.LessThan(left: actual, right: oracle),
            ExpressionType.LessThanOrEqual => Dependencies.SqlExpressionFactory.LessThanOrEqual(left: actual, right: oracle),
            _ => visitedExpression
        };
    }

    private static bool AttemptDecimalArithmetic(SqlBinaryExpression sqlBinary)
        => AreOperandsDecimals(sqlBinary)
            && new[] { ExpressionType.Add, ExpressionType.Subtract, ExpressionType.Multiply, ExpressionType.Divide }.Contains(
                sqlBinary.OperatorType);

    private Expression DoDecimalArithmetics(SqlExpression visitedExpression, ExpressionType op, SqlExpression left, SqlExpression right)
    {
        return op switch
        {
            ExpressionType.Add => DecimalArithmeticExpressionFactoryMethod(ResolveFunctionNameFromExpressionType(op), left, right),
            ExpressionType.Divide => DecimalArithmeticExpressionFactoryMethod(ResolveFunctionNameFromExpressionType(op), left, right),
            ExpressionType.Multiply => DecimalArithmeticExpressionFactoryMethod(ResolveFunctionNameFromExpressionType(op), left, right),
            ExpressionType.Subtract => DecimalSubtractExpressionFactoryMethod(left, right),
            _ => visitedExpression
        };

        static string ResolveFunctionNameFromExpressionType(ExpressionType expressionType)
            => expressionType switch
            {
                ExpressionType.Add => ""ef_add"",
                ExpressionType.Divide => ""ef_divide"",
                ExpressionType.Multiply => ""ef_multiply"",
                ExpressionType.Subtract => ""ef_add"",
                _ => throw new InvalidOperationException()
            };

        Expression DecimalArithmeticExpressionFactoryMethod(string name, SqlExpression left, SqlExpression right)
            => Dependencies.SqlExpressionFactory.Function(
                name,
                new[] { left, right },
                nullable: true,
                new[] { true, true },
                visitedExpression.Type);

        Expression DecimalSubtractExpressionFactoryMethod(SqlExpression left, SqlExpression right)
        {
            var subtrahend = Dependencies.SqlExpressionFactory.Function(
                ""ef_negate"",
                new[] { right },
                nullable: true,
                new[] { true },
                visitedExpression.Type);

            return DecimalArithmeticExpressionFactoryMethod(ResolveFunctionNameFromExpressionType(op), left, subtrahend);
        }
    }
}",0,439 334 2000 58 2001 123 437 457 441 2002 60 2003 44 2004 60 2005 640 2006 61 418 2007 60 2003 44 2004 60 2005 640 123 91 2003 46 2008 93 61 418 2009 60 2005 62 123 478 40 2010 41 44 478 40 2011 41 44 478 40 2012 41 125 44 91 2003 46 2013 93 61 418 2009 60 2005 62 123 478 40 2014 41 44 478 40 480 41 125 44 91 2003 46 2015 93 61 418 2009 60 2005 62 123 478 40 2016 41 44 478 40 2017 41 44 478 40 480 41 125 44 91 2003 46 2018 93 61 418 2009 60 2005 62 123 478 40 2019 41 44 478 40 2020 41 44 478 40 480 41 125 44 91 2003 46 2021 93 61 418 2009 60 2005 62 123 478 40 2022 41 44 478 40 2023 41 44 478 40 480 41 125 44 91 2003 46 2024 93 61 418 2009 60 2005 62 123 478 40 2025 41 44 478 40 2026 41 44 478 40 480 41 125 44 91 2003 46 2027 93 61 418 2009 60 2005 62 123 478 40 480 41 125 44 91 2003 46 2028 93 61 418 2009 60 2005 62 123 478 40 2029 41 44 478 40 480 41 125 44 91 2003 46 2030 93 61 418 2009 60 2005 62 123 478 40 2031 41 44 478 40 2032 41 44 478 40 2033 41 125 125 59 437 457 441 2004 60 2005 62 2034 61 418 2035 60 2005 62 123 478 40 345 41 44 478 40 356 41 44 478 40 384 41 125 59 612 439 2000 40 2036 2037 44 2038 2039 44 2040 2041 41 58 320 40 2037 44 2039 44 2041 41 123 125 612 438 431 2042 2043 40 2044 2045 41 123 392 40 2045 46 2046 614 2003 46 2047 605 2045 46 2048 46 2005 614 478 40 326 91 93 41 41 123 450 2049 40 2045 46 2048 41 407 2050 2051 63 2052 46 2053 46 2054 40 648 44 418 91 93 123 2051 125 44 2055 58 473 44 2056 58 418 91 93 123 473 125 44 478 40 404 41 41 58 2038 46 2057 59 125 490 2058 61 320 46 2043 40 2045 41 59 392 40 2058 614 2038 46 2059 41 123 450 2038 46 2059 59 125 392 40 2058 407 2060 2061 605 2061 46 2062 614 2003 46 2063 41 123 490 2064 61 2065 40 2061 46 2048 41 59 392 40 2064 614 478 40 345 41 41 123 450 2066 46 2067 46 2068 40 2069 58 648 44 418 91 93 123 2061 46 2048 125 44 2070 58 473 44 418 91 93 123 473 125 44 2058 46 2005 41 59 125 392 40 2064 614 478 40 2071 41 41 123 450 2038 46 2059 59 125 125 450 2058 59 125 612 438 431 2042 2072 40 2073 2074 41 123 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 392 40 33 40 320 46 2072 40 2074 41 407 2075 2076 41 41 123 450 2038 46 2077 59 125 392 40 2076 407 2078 2079 41 123 392 40 2079 46 2080 614 2003 46 2081 605 40 2034 46 2082 40 2083 40 2079 46 2084 41 41 606 2034 46 2082 40 2083 40 2079 46 2085 41 41 41 41 123 450 2086 46 2087 46 2088 40 648 44 418 91 93 123 2079 46 2084 44 2079 46 2085 125 44 2089 58 473 44 2090 58 418 91 93 123 473 44 473 125 44 2076 46 2005 44 2076 46 2091 41 59 125 392 40 2092 40 2079 41 41 123 450 2093 40 2076 44 2079 46 2080 44 2079 46 2084 44 2079 46 2085 41 59 125 392 40 2094 40 2079 41 41 123 450 2095 40 2076 44 2079 46 2080 44 2079 46 2084 44 2079 46 2085 41 59 125 392 40 2006 46 2096 40 2079 46 2080 44 430 490 2097 41 605 40 2097 46 2082 40 2083 40 2079 46 2084 41 41 606 2097 46 2082 40 2083 40 2079 46 2085 41 41 41 41 123 450 2038 46 2098 59 125 125 450 2076 59 125 612 439 431 2099 63 2100 40 2099 2101 41 123 490 2102 61 320 46 2100 40 2101 41 59 490 2103 61 2104 40 2102 41 59 392 40 2103 614 478 40 345 41 41 123 469 418 2105 40 2106 46 2107 40 2108 40 2109 46 2110 41 44 2103 46 2111 40 41 41 41 59 125 450 2102 59 125 612 439 431 2099 63 2112 40 2099 2101 41 123 490 2113 61 320 46 2112 40 2101 41 59 490 2114 61 2115 40 2113 41 59 392 40 2114 614 478 40 2116 41 606 2114 614 478 40 345 41 606 2114 614 478 40 2117 41 606 2114 614 478 40 480 41 41 123 469 418 2118 40 2119 46 2120 40 2121 40 2122 46 2123 41 44 2114 46 2124 40 41 41 41 59 125 450 2113 59 125 612 439 431 2099 63 2125 40 2099 2101 41 123 490 2126 61 320 46 2125 40 2101 41 59 490 2127 61 2128 40 2126 41 59 392 40 2127 614 478 40 2129 41 606 2127 614 478 40 345 41 606 2127 614 478 40 2130 41 606 2127 614 478 40 480 41 41 123 469 418 2131 40 2132 46 2133 40 2134 40 2135 46 2136 41 44 2127 46 2137 40 41 41 41 59 125 450 2126 59 125 612 439 431 2099 63 2138 40 2099 2101 41 123 490 2139 61 320 46 2138 40 2101 41 59 490 2140 61 2141 40 2139 41 59 392 40 2140 614 478 40 345 41 41 123 469 418 2142 40 2143 46 2144 40 2145 40 2146 46 2147 41 44 2140 46 2148 40 41 41 41 59 125 450 2139 59 125 437 457 2005 63 2149 40 2099 63 2150 41 619 2150 614 424 63 424 58 40 2150 46 2151 634 2152 634 2153 633 2150 46 2151 634 2154 633 2150 46 2005 41 59 437 457 323 2155 40 2156 2101 41 619 2149 40 2101 46 2157 41 614 478 40 345 41 605 2149 40 2101 46 2158 41 614 478 40 345 41 59 437 457 323 2159 40 2156 2160 41 619 2155 40 2160 41 605 418 91 93 123 2003 46 2161 44 2003 46 2162 44 2003 46 2163 44 2003 46 2164 125 46 2165 40 2160 46 2166 41 59 437 2042 2167 40 2099 2168 44 2003 2169 44 2099 2170 44 2099 2171 41 123 490 2172 61 2173 46 2174 46 2175 40 2176 58 648 44 418 91 93 123 2170 44 2171 125 44 2177 58 473 44 418 91 93 123 473 44 473 125 44 478 40 404 41 41 59 490 2178 61 2173 46 2174 46 2179 40 2180 58 1500 41 59 450 2169 464 123 2003 46 2181 619 2173 46 2174 46 2181 40 2170 58 2172 44 2171 58 2178 41 44 2003 46 2182 619 2173 46 2174 46 2182 40 2170 58 2172 44 2171 58 2178 41 44 2003 46 2183 619 2173 46 2174 46 2183 40 2170 58 2172 44 2171 58 2178 41 44 2003 46 2184 619 2173 46 2174 46 2184 40 2170 58 2172 44 2171 58 2178 41 44 2185 619 2168 125 59 125 437 457 323 2186 40 2156 2160 41 619 2155 40 2160 41 605 418 91 93 123 2003 46 2187 44 2003 46 2188 44 2003 46 2189 44 2003 46 2190 125 46 2165 40 2160 46 2166 41 59 437 2042 2191 40 2099 2168 44 2003 2169 44 2099 2170 44 2099 2171 41 123 450 2169 464 123 2003 46 2192 619 2193 40 2194 40 2169 41 44 2170 44 2171 41 44 2003 46 2195 619 2193 40 2194 40 2169 41 44 2170 44 2171 41 44 2003 46 2196 619 2193 40 2194 40 2169 41 44 2170 44 2171 41 44 2003 46 2197 619 2198 40 2170 44 2171 41 44 2199 619 2168 125 59 457 461 2200 40 2003 2201 41 619 2201 464 123 2003 46 2202 619 648 44 2003 46 2203 619 648 44 2003 46 2204 619 648 44 2003 46 2205 619 648 44 2206 619 469 418 2207 40 41 125 59 2042 2208 40 461 2209 44 2099 2170 44 2099 2171 41 619 2210 46 2211 46 2212 40 2209 44 418 91 93 123 2170 44 2171 125 44 2213 58 473 44 418 91 93 123 473 44 473 125 44 2168 46 2005 41 59 2042 2214 40 2099 2170 44 2099 2171 41 123 490 2215 61 2210 46 2211 46 2212 40 648 44 418 91 93 123 2171 125 44 2213 58 473 44 418 91 93 123 473 125 44 2168 46 2005 41 59 450 2208 40 2200 40 2169 41 44 2170 44 2215 41 59 125 125 125 
68867,C#,"public class SqliteQueryableMethodTranslatingExpressionVisitorFactory : IQueryableMethodTranslatingExpressionVisitorFactory
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public SqliteQueryableMethodTranslatingExpressionVisitorFactory(
        QueryableMethodTranslatingExpressionVisitorDependencies dependencies,
        RelationalQueryableMethodTranslatingExpressionVisitorDependencies relationalDependencies)
    {
        Dependencies = dependencies;
        RelationalDependencies = relationalDependencies;
    }

    /// <summary>
    ///     Dependencies for this service.
    /// </summary>
    protected virtual QueryableMethodTranslatingExpressionVisitorDependencies Dependencies { get; }

    /// <summary>
    ///     Relational provider-specific dependencies for this service.
    /// </summary>
    protected virtual RelationalQueryableMethodTranslatingExpressionVisitorDependencies RelationalDependencies { get; }

    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual QueryableMethodTranslatingExpressionVisitor Create(QueryCompilationContext queryCompilationContext)
        => new SqliteQueryableMethodTranslatingExpressionVisitor(Dependencies, RelationalDependencies, queryCompilationContext);
}",0,439 334 2000 58 2001 123 612 439 2000 40 2002 2003 44 2004 2005 41 123 2006 61 2003 59 2007 61 2005 59 125 612 438 491 2002 2008 123 2009 59 125 612 438 491 2004 2010 123 2011 59 125 612 439 491 2012 2013 40 2014 2015 41 619 418 2016 40 2008 44 2010 44 2015 41 59 125 
87297,C#,"    internal static class AutoStartupHelper
    {
        private static readonly string StartupFullPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.Startup),
            Path.ChangeExtension(Path.GetFileName(App.AppFullPath), "".lnk""));

        internal static void CreateAutorunShortcut()
        {
            if (App.IsUWP)
                return;

            try
            {
                RemoveAutorunShortcut();

                var lnk = (IShellLinkW) new ShellLink();

                lnk.SetPath(App.AppFullPath);
                lnk.SetArguments(""/autorun""); // silent
                lnk.SetIconLocation(App.AppFullPath, 0);
                lnk.SetWorkingDirectory(App.AppPath);
                ((IPersistFile) lnk).Save(StartupFullPath, false);
            }
            catch (Exception e)
            {
                ProcessHelper.WriteLog(e.ToString());
                TrayIconManager.ShowNotification("""", ""Failed to add QuickLook to Startup folder."");
            }
        }

        internal static void RemoveAutorunShortcut()
        {
            if (App.IsUWP)
                return;

            try
            {
                File.Delete(StartupFullPath);
            }
            catch (Exception e)
            {
                ProcessHelper.WriteLog(e.ToString());
                TrayIconManager.ShowNotification("""", ""Failed to delete QuickLook startup shortcut."");
            }
        }

        internal static bool IsAutorun()
        {
            if (App.IsUWP)
                return true;

            return File.Exists(StartupFullPath);
        }
    }",0,406 457 334 2000 123 437 457 441 461 2001 61 2002 46 2003 40 2004 46 2005 40 2004 46 2006 46 2007 41 44 2002 46 2008 40 2002 46 2009 40 2010 46 2011 41 44 648 41 41 59 406 457 492 2012 40 41 123 392 40 2010 46 2013 41 450 59 474 123 2014 40 41 59 490 2015 61 40 2016 41 418 2017 40 41 59 2015 46 2018 40 2010 46 2011 41 59 2015 46 2019 40 648 41 59 621 2015 46 2020 40 2010 46 2011 44 1500 41 59 2015 46 2021 40 2010 46 2022 41 59 40 40 2023 41 2015 41 46 2024 40 2001 44 380 41 59 125 329 40 2025 2026 41 123 2027 46 2028 40 2026 46 2029 40 41 41 59 2030 46 2031 40 648 44 648 41 59 125 125 406 457 492 2032 40 41 123 392 40 2010 46 2033 41 450 59 474 123 2034 46 2035 40 2001 41 59 125 329 40 2036 2037 41 123 2038 46 2039 40 2037 46 2040 40 41 41 59 2041 46 2042 40 648 44 648 41 59 125 125 406 457 323 2043 40 41 123 392 40 2010 46 2044 41 450 473 59 450 2045 46 2046 40 2001 41 59 125 125 
76152,C#,"    public class ResourceNotFoundException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""ResourceNotFoundException"" /> class.
        /// </summary>
        public ResourceNotFoundException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref=""ResourceNotFoundException"" /> class.
        /// </summary>
        /// <param name=""message"">The message.</param>
        public ResourceNotFoundException(string message)
            : base(message)
        {
        }
    }",0,439 334 2000 58 2001 123 612 439 2000 40 41 123 125 612 439 2000 40 461 2002 41 58 320 40 2002 41 123 125 125 
77221,C#,"    public class EpisodePathParserTest
    {
        [Theory]
        [InlineData(""/media/Foo/Foo-S01E01"", true, ""Foo"", 1, 1)]
        [InlineData(""/media/Foo - S04E011"", true, ""Foo"", 4, 11)]
        [InlineData(""/media/Foo/Foo s01x01"", true, ""Foo"", 1, 1)]
        [InlineData(""/media/Foo (2019)/Season 4/Foo (2019).S04E03"", true, ""Foo (2019)"", 4, 3)]
        [InlineData(""D:\\media\\Foo\\Foo-S01E01"", true, ""Foo"", 1, 1)]
        [InlineData(""D:\\media\\Foo - S04E011"", true, ""Foo"", 4, 11)]
        [InlineData(""D:\\media\\Foo\\Foo s01x01"", true, ""Foo"", 1, 1)]
        [InlineData(""D:\\media\\Foo (2019)\\Season 4\\Foo (2019).S04E03"", true, ""Foo (2019)"", 4, 3)]
        [InlineData(""/Season 2/Elementary - 02x03-04-15 - Ep Name.mp4"", false, ""Elementary"", 2, 3)]
        [InlineData(""/Season 1/seriesname S01E02 blah.avi"", false, ""seriesname"", 1, 2)]
        [InlineData(""/Running Man/Running Man S2017E368.mkv"", false, ""Running Man"", 2017, 368)]
        [InlineData(""/Season 1/seriesname 01x02 blah.avi"", false, ""seriesname"", 1, 2)]
        [InlineData(""/Season 25/The Simpsons.S25E09.Steal this episode.mp4"", false, ""The Simpsons"", 25, 9)]
        [InlineData(""/Season 1/seriesname S01x02 blah.avi"", false, ""seriesname"", 1, 2)]
        [InlineData(""/Season 2/Elementary - 02x03 - 02x04 - 02x15 - Ep Name.mp4"", false, ""Elementary"", 2, 3)]
        [InlineData(""/Season 1/seriesname S01xE02 blah.avi"", false, ""seriesname"", 1, 2)]
        [InlineData(""/Season 02/Elementary - 02x03 - x04 - x15 - Ep Name.mp4"", false, ""Elementary"", 2, 3)]
        [InlineData(""/Season 02/Elementary - 02x03x04x15 - Ep Name.mp4"", false, ""Elementary"", 2, 3)]
        [InlineData(""/Season 02/Elementary - 02x03-E15 - Ep Name.mp4"", false, ""Elementary"", 2, 3)]
        [InlineData(""/Season 1/Elementary - S01E23-E24-E26 - The Woman.mp4"", false, ""Elementary"", 1, 23)]
        [InlineData(""/The Wonder Years/The.Wonder.Years.S04.PDTV.x264-JCH/The Wonder Years s04e07 Christmas Party NTSC PDTV.avi"", false, ""The Wonder Years"", 4, 7)]
        // TODO: [InlineData(""/Castle Rock 2x01 Que el rio siga su curso [WEB-DL HULU 1080p h264 Dual DD5.1 Subs].mkv"", ""Castle Rock"", 2, 1)]
        // TODO: [InlineData(""/After Life 1x06 Episodio 6 [WEB-DL NF 1080p h264 Dual DD 5.1 Sub].mkv"", ""After Life"", 1, 6)]
        // TODO: [InlineData(""/Season 4/Uchuu.Senkan.Yamato.2199.E03.avi"", ""Uchuu Senkan Yamoto 2199"", 4, 3)]
        // TODO: [InlineData(""The Daily Show/The Daily Show 25x22 - [WEBDL-720p][AAC 2.0][x264] Noah Baumbach-TBS.mkv"", ""The Daily Show"", 25, 22)]
        // TODO: [InlineData(""Watchmen (2019)/Watchmen 1x03 [WEBDL-720p][EAC3 5.1][h264][-TBS] - She Was Killed by Space Junk.mkv"", ""Watchmen (2019)"", 1, 3)]
        // TODO: [InlineData(""/The.Legend.of.Condor.Heroes.2017.V2.web-dl.1080p.h264.aac-hdctv/The.Legend.of.Condor.Heroes.2017.E07.V2.web-dl.1080p.h264.aac-hdctv.mkv"", ""The Legend of Condor Heroes 2017"", 1, 7)]
        public void ParseEpisodesCorrectly(string path, bool isDirectory, string name, int season, int episode)
        {
            NamingOptions o = new NamingOptions();
            EpisodePathParser p = new EpisodePathParser(o);
            var res = p.Parse(path, isDirectory);

            Assert.True(res.Success);
            Assert.Equal(name, res.SeriesName);
            Assert.Equal(season, res.SeasonNumber);
            Assert.Equal(episode, res.EpisodeNumber);
        }

        [Theory]
        [InlineData(""/test/01-03.avi"", true, true)]
        public void EpisodePathParserTest_DifferentExpressionsParameters(string path, bool? isNamed, bool? isOptimistic)
        {
            NamingOptions o = new NamingOptions();
            EpisodePathParser p = new EpisodePathParser(o);
            var res = p.Parse(path, false, isNamed, isOptimistic);

            Assert.True(res.Success);
        }

        [Fact]
        public void EpisodePathParserTest_FalsePositivePixelRate()
        {
            NamingOptions o = new NamingOptions();
            EpisodePathParser p = new EpisodePathParser(o);
            var res = p.Parse(""Series Special (1920x1080).mkv"", false);

            Assert.False(res.Success);
        }

        [Fact]
        public void EpisodeResolverTest_WrongExtension()
        {
            var res = new EpisodeResolver(new NamingOptions()).Resolve(""test.mp3"", false);
            Assert.Null(res);
        }

        [Fact]
        public void EpisodeResolverTest_WrongExtensionStub()
        {
            var res = new EpisodeResolver(new NamingOptions()).Resolve(""dvd.disc"", false);
            Assert.NotNull(res);
            Assert.True(res!.IsStub);
        }

        /*
         * EpisodePathParser.cs:130 is currently unreachable, but the piece of code is useful and could be reached with addition of new EpisodeExpressions.
         * In order to preserve it but achieve 100% code coverage the test case below with made up expressions and filename is used.
         */
        [Fact]
        public void EpisodePathParserTest_EmptyDateParsers()
        {
            NamingOptions o = new NamingOptions()
            {
                EpisodeExpressions = new[] { new EpisodeExpression(""(([0-9]{4})-([0-9]{2})-([0-9]{2}) [0-9]{2}:[0-9]{2}:[0-9]{2})"", true) }
            };
            o.Compile();

            EpisodePathParser p = new EpisodePathParser(o);
            var res = p.Parse(""ABC_2019_10_21 11:00:00"", false);

            Assert.True(res.Success);
        }
    }",0,439 334 2000 123 91 2001 93 91 2002 40 648 44 473 44 648 44 1501 44 1501 41 93 91 2002 40 648 44 473 44 648 44 1502 44 1503 41 93 91 2002 40 648 44 473 44 648 44 1501 44 1501 41 93 91 2002 40 648 44 473 44 648 44 1502 44 1502 41 93 91 2002 40 648 44 473 44 648 44 1501 44 1501 41 93 91 2002 40 648 44 473 44 648 44 1502 44 1503 41 93 91 2002 40 648 44 473 44 648 44 1501 44 1501 41 93 91 2002 40 648 44 473 44 648 44 1502 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1502 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1501 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1505 44 1504 41 93 91 2002 40 648 44 380 44 648 44 1501 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1503 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1501 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1502 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1501 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1502 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1502 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1502 44 1502 41 93 91 2002 40 648 44 380 44 648 44 1501 44 1503 41 93 91 2002 40 648 44 380 44 648 44 1502 44 1502 41 93 621 621 621 621 621 621 439 492 2003 40 461 2004 44 323 2005 44 461 2006 44 404 2007 44 404 2008 41 123 2009 2010 61 418 2009 40 41 59 2011 2012 61 418 2011 40 2010 41 59 490 2013 61 2012 46 2014 40 2004 44 2005 41 59 2015 46 304 40 2013 46 2016 41 59 2015 46 2017 40 2006 44 2013 46 2018 41 59 2015 46 2017 40 2007 44 2013 46 2019 41 59 2015 46 2017 40 2008 44 2013 46 2020 41 59 125 91 2001 93 91 2002 40 648 44 473 44 473 41 93 439 492 2021 40 461 2004 44 323 63 2022 44 323 63 2023 41 123 2024 2025 61 418 2024 40 41 59 2026 2027 61 418 2026 40 2025 41 59 490 2028 61 2027 46 2029 40 2004 44 380 44 2022 44 2023 41 59 2030 46 304 40 2028 46 2031 41 59 125 91 2032 93 439 492 2033 40 41 123 2034 2035 61 418 2034 40 41 59 2036 2037 61 418 2036 40 2035 41 59 490 2038 61 2037 46 2039 40 648 44 380 41 59 2040 46 302 40 2038 46 2041 41 59 125 91 2032 93 439 492 2042 40 41 123 490 2043 61 418 2044 40 418 2045 40 41 41 46 2046 40 648 44 380 41 59 2047 46 2048 40 2043 41 59 125 91 2032 93 439 492 2049 40 41 123 490 2050 61 418 2051 40 418 2052 40 41 41 46 2053 40 648 44 380 41 59 2054 46 2055 40 2050 41 59 2054 46 304 40 2050 33 46 2056 41 59 125 604 91 2032 93 439 492 2057 40 41 123 2058 2059 61 418 2058 40 41 123 2060 61 418 91 93 123 418 2061 40 648 44 473 41 125 125 59 2059 46 2062 40 41 59 2063 2064 61 418 2063 40 2059 41 59 490 2065 61 2064 46 2066 40 648 44 380 41 59 2067 46 304 40 2065 46 2068 41 59 125 125 
77145,C#,"    public class EpisodeNumberTests
    {
        private readonly NamingOptions _namingOptions = new NamingOptions();

        [Theory]
        [InlineData(""Watchmen (2019)/Watchmen 1x03 [WEBDL-720p][EAC3 5.1][h264][-TBS] - She Was Killed by Space Junk.mkv"", 3)]
        [InlineData(""The Daily Show/The Daily Show 25x22 - [WEBDL-720p][AAC 2.0][x264] Noah Baumbach-TBS.mkv"", 22)]
        [InlineData(""Castle Rock 2x01 Que el rio siga su curso [WEB-DL HULU 1080p h264 Dual DD5.1 Subs].mkv"", 1)]
        [InlineData(""After Life 1x06 Episodio 6 [WEB-DL NF 1080p h264 Dual DD 5.1 Sub].mkv"", 6)]
        [InlineData(""Season 02/S02E03 blah.avi"", 3)]
        [InlineData(""Season 2/02x03 - 02x04 - 02x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 02/02x03 - x04 - x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 1/01x02 blah.avi"", 2)]
        [InlineData(""Season 1/S01x02 blah.avi"", 2)]
        [InlineData(""Season 1/S01E02 blah.avi"", 2)]
        [InlineData(""Season 2/Elementary - 02x03-04-15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 1/S01xE02 blah.avi"", 2)]
        [InlineData(""Season 1/seriesname S01E02 blah.avi"", 2)]
        [InlineData(""Season 2/Episode - 16.avi"", 16)]
        [InlineData(""Season 2/Episode 16.avi"", 16)]
        [InlineData(""Season 2/Episode 16 - Some Title.avi"", 16)]
        [InlineData(""Season 2/16 Some Title.avi"", 16)]
        [InlineData(""Season 2/16 - 12 Some Title.avi"", 16)]
        [InlineData(""Season 2/7 - 12 Angry Men.avi"", 7)]
        [InlineData(""Season 1/seriesname 01x02 blah.avi"", 2)]
        [InlineData(""Season 25/The Simpsons.S25E09.Steal this episode.mp4"", 9)]
        [InlineData(""Season 1/seriesname S01x02 blah.avi"", 2)]
        [InlineData(""Season 2/Elementary - 02x03 - 02x04 - 02x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 1/seriesname S01xE02 blah.avi"", 2)]
        [InlineData(""Season 02/Elementary - 02x03 - x04 - x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 02/Elementary - 02x03x04x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2/02x03-04-15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 02/02x03-E15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 02/Elementary - 02x03-E15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 1/Elementary - S01E23-E24-E26 - The Woman.mp4"", 23)]
        [InlineData(""Season 2009/S2009E23-E24-E26 - The Woman.mp4"", 23)]
        [InlineData(""Season 2009/2009x02 blah.avi"", 2)]
        [InlineData(""Season 2009/S2009x02 blah.avi"", 2)]
        [InlineData(""Season 2009/S2009E02 blah.avi"", 2)]
        [InlineData(""Season 2009/seriesname 2009x02 blah.avi"", 2)]
        [InlineData(""Season 2009/Elementary - 2009x03x04x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/2009x03x04x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/Elementary - 2009x03-E15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/S2009xE02 blah.avi"", 2)]
        [InlineData(""Season 2009/Elementary - S2009E23-E24-E26 - The Woman.mp4"", 23)]
        [InlineData(""Season 2009/seriesname S2009xE02 blah.avi"", 2)]
        [InlineData(""Season 2009/2009x03-E15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/seriesname S2009E02 blah.avi"", 2)]
        [InlineData(""Season 2009/2009x03 - 2009x04 - 2009x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/2009x03 - x04 - x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/seriesname S2009x02 blah.avi"", 2)]
        [InlineData(""Season 2009/Elementary - 2009x03 - 2009x04 - 2009x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/Elementary - 2009x03-04-15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/2009x03-04-15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 2009/Elementary - 2009x03 - x04 - x15 - Ep Name.mp4"", 3)]
        [InlineData(""Season 1/02 - blah-02 a.avi"", 2)]
        [InlineData(""Season 1/02 - blah.avi"", 2)]
        [InlineData(""Season 2/02 - blah 14 blah.avi"", 2)]
        [InlineData(""Season 2/02.avi"", 2)]
        [InlineData(""Season 2/2. Infestation.avi"", 2)]
        [InlineData(""The Wonder Years/The.Wonder.Years.S04.PDTV.x264-JCH/The Wonder Years s04e07 Christmas Party NTSC PDTV.avi"", 7)]
        [InlineData(""Running Man/Running Man S2017E368.mkv"", 368)]
        [InlineData(""Season 2/[HorribleSubs] Hunter X Hunter - 136 [720p].mkv"", 136)] // triple digit episode number
        [InlineData(""Log Horizon 2/[HorribleSubs] Log Horizon 2 - 03 [720p].mkv"", 3)] // digit in series name
        [InlineData(""Season 1/seriesname 05.mkv"", 5)] // no hyphen between series name and episode number
        [InlineData(""[BBT-RMX] Ranma ½ - 154 [50AC421A].mkv"", 154)] // hyphens in the pre-name info, triple digit episode number
        [InlineData(""Season 2/Episode 21 - 94 Meetings.mp4"", 21)] // Title starts with a number
        [InlineData(""/The.Legend.of.Condor.Heroes.2017.V2.web-dl.1080p.h264.aac-hdctv/The.Legend.of.Condor.Heroes.2017.E07.V2.web-dl.1080p.h264.aac-hdctv.mkv"", 7)]
        // [InlineData(""Case Closed (1996-2007)/Case Closed - 317.mkv"", 317)] // triple digit episode number
        // TODO: [InlineData(""Season 2/16 12 Some Title.avi"", 16)]
        // TODO: [InlineData(""Season 4/Uchuu.Senkan.Yamato.2199.E03.avi"", 3)]
        // TODO: [InlineData(""Season 2/7 12 Angry Men.avi"", 7)]
        // TODO: [InlineData(""Season 02/02x03x04x15 - Ep Name.mp4"", 2)]
        public void GetEpisodeNumberFromFileTest(string path, int? expected)
        {
            var result = new EpisodePathParser(_namingOptions)
                .Parse(path, false);

            Assert.Equal(expected, result.EpisodeNumber);
        }
    }",0,439 334 2000 123 437 441 2001 2002 61 418 2001 40 41 59 91 2003 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1501 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1503 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1502 41 93 91 2004 40 648 44 1504 41 93 91 2004 40 648 44 1504 41 93 621 91 2004 40 648 44 1502 41 93 621 91 2004 40 648 44 1502 41 93 621 91 2004 40 648 44 1504 41 93 621 91 2004 40 648 44 1503 41 93 621 91 2004 40 648 44 1502 41 93 621 621 621 621 621 439 492 2005 40 461 2006 44 404 63 2007 41 123 490 2008 61 418 2009 40 2002 41 46 2010 40 2006 44 380 41 59 2011 46 2012 40 2007 44 2008 46 2013 41 59 125 125 
76406,C#,"    public class NotificationRequest
    {
        public NotificationRequest()
        {
            UserIds = Array.Empty<Guid>();
            Date = DateTime.UtcNow;
        }

        public string Name { get; set; }

        public string Description { get; set; }

        public string Url { get; set; }

        public NotificationLevel Level { get; set; }

        public Guid[] UserIds { get; set; }

        public DateTime Date { get; set; }

        /// <summary>
        /// Gets or sets the corresponding type name used in configuration. Not for display.
        /// </summary>
        public string NotificationType { get; set; }

        public SendToUserType? SendToUserMode { get; set; }
    }",0,439 334 2000 123 439 2000 40 41 123 2001 61 2002 46 2003 60 2004 62 40 41 59 2005 61 2006 46 2007 59 125 439 461 2008 123 2009 59 2010 59 125 439 461 2011 123 2012 59 2013 59 125 439 461 2014 123 2015 59 2016 59 125 439 2017 2018 123 2019 59 2020 59 125 439 2021 91 93 2022 123 2023 59 2024 59 125 439 2025 2026 123 2027 59 2028 59 125 612 439 461 2029 123 2030 59 2031 59 125 439 2032 63 2033 123 2034 59 2035 59 125 125 
76175,C#,"    public class XbmcMetadataOptions
    {
        public XbmcMetadataOptions()
        {
            ReleaseDateFormat = ""yyyy-MM-dd"";

            SaveImagePathsInNfo = true;
            EnablePathSubstitution = true;
        }

        public string? UserId { get; set; }

        public string ReleaseDateFormat { get; set; }

        public bool SaveImagePathsInNfo { get; set; }

        public bool EnablePathSubstitution { get; set; }

        public bool EnableExtraThumbsDuplication { get; set; }
    }",0,439 334 2000 123 439 2000 40 41 123 2001 61 648 59 2002 61 473 59 2003 61 473 59 125 439 461 63 2004 123 2005 59 2006 59 125 439 461 2007 123 2008 59 2009 59 125 439 323 2010 123 2011 59 2012 59 125 439 323 2013 123 2014 59 2015 59 125 439 323 2016 123 2017 59 2018 59 125 125 
76604,C#,"        private static class ProgressHelpers
        {
            /// <summary>
            /// Reported after the folders immediate children are retrieved.
            /// </summary>
            public const int RetrievedChildren = 5;

            /// <summary>
            /// Reported after add, updating, or deleting child items from the LibraryManager.
            /// </summary>
            public const int UpdatedChildItems = 10;

            /// <summary>
            /// Reported once subfolders are scanned.
            /// When scanning subfolders, the progress will be between [UpdatedItems, ScannedSubfolders].
            /// </summary>
            public const int ScannedSubfolders = 50;

            /// <summary>
            /// Reported once metadata is refreshed.
            /// When refreshing metadata, the progress will be between [ScannedSubfolders, MetadataRefreshed].
            /// </summary>
            public const int RefreshedMetadata = 100;

            /// <summary>
            /// Gets the current progress given the previous step, next step, and progress in between.
            /// </summary>
            /// <param name=""previousProgressStep"">The previous progress step.</param>
            /// <param name=""nextProgressStep"">The next progress step.</param>
            /// <param name=""currentProgress"">The current progress step.</param>
            /// <returns>The progress.</returns>
            public static double GetProgress(int previousProgressStep, int nextProgressStep, double currentProgress)
            {
                return previousProgressStep + ((nextProgressStep - previousProgressStep) * (currentProgress / 100));
            }
        }",0,437 457 334 2000 123 612 439 341 404 2001 61 1502 59 612 439 341 404 2002 61 1502 59 612 439 341 404 2003 61 1503 59 612 439 341 404 2004 61 1503 59 612 439 457 356 2005 40 404 2006 44 404 2007 44 356 2008 41 123 450 2006 43 40 40 2007 45 2006 41 42 40 2008 47 1503 41 41 59 125 125 
