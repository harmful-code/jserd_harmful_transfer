id,language,text,smell,tokens
4148,Java,"        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                log.warn(""Graceful shutdown not completed in 10 sec. We trigger our timeout handler."");
                flushAndExit(resultHandler, EXIT_SUCCESS);
            }
        }, 10000);",0,418 2000 40 41 46 2001 40 418 2002 40 41 123 64 2003 439 492 2004 40 41 123 2005 46 2006 40 648 41 59 2007 40 2008 44 2009 41 59 125 125 44 1505 41 59 
31352,Java,"		public static final class TestBuilder {
			private final String field;
			@java.lang.SuppressWarnings(""all"")
			TestBuilder(final String field) {
				this.field = field;
			}
			@java.lang.SuppressWarnings(""all"")
			public static class TestBuilderBuilder {
				@java.lang.SuppressWarnings(""all"")
				private String field;
				@java.lang.SuppressWarnings(""all"")
				TestBuilderBuilder() {
				}
				/**
				 * @return {@code this}.
				 */
				@java.lang.SuppressWarnings(""all"")
				public BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder field(final String field) {
					this.field = field;
					return this;
				}
				@java.lang.SuppressWarnings(""all"")
				public BuilderNestedInEnum.TestEnum.TestBuilder build() {
					return new BuilderNestedInEnum.TestEnum.TestBuilder(this.field);
				}
				@java.lang.Override
				@java.lang.SuppressWarnings(""all"")
				public java.lang.String toString() {
					return ""BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder(field="" + this.field + "")"";
				}
			}
			@java.lang.SuppressWarnings(""all"")
			public static BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder builder() {
				return new BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder();
			}
			@java.lang.SuppressWarnings(""all"")
			public String getField() {
				return this.field;
			}
			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public boolean equals(final java.lang.Object o) {
				if (o == this) return true;
				if (!(o instanceof BuilderNestedInEnum.TestEnum.TestBuilder)) return false;
				final BuilderNestedInEnum.TestEnum.TestBuilder other = (BuilderNestedInEnum.TestEnum.TestBuilder) o;
				final java.lang.Object this$field = this.getField();
				final java.lang.Object other$field = other.getField();
				if (this$field == null ? other$field != null : !this$field.equals(other$field)) return false;
				return true;
			}
			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public int hashCode() {
				final int PRIME = 59;
				int result = 1;
				final java.lang.Object $field = this.getField();
				result = result * PRIME + ($field == null ? 43 : $field.hashCode());
				return result;
			}
			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""BuilderNestedInEnum.TestEnum.TestBuilder(field="" + this.getField() + "")"";
			}
		}",0,439 457 381 334 2000 123 437 381 2001 2002 59 64 2003 46 2004 46 2005 40 648 41 2000 40 381 2001 2002 41 123 467 46 2002 61 2002 59 125 64 2003 46 2004 46 2005 40 648 41 439 457 334 2006 123 64 2003 46 2004 46 2005 40 648 41 437 2001 2002 59 64 2003 46 2004 46 2005 40 648 41 2006 40 41 123 125 618 64 2003 46 2004 46 2005 40 648 41 439 2007 46 2008 46 2000 46 2006 2002 40 381 2001 2002 41 123 467 46 2002 61 2002 59 450 467 59 125 64 2003 46 2004 46 2005 40 648 41 439 2007 46 2008 46 2000 2009 40 41 123 450 418 2007 46 2008 46 2000 40 467 46 2002 41 59 125 64 2003 46 2004 46 2010 64 2003 46 2004 46 2005 40 648 41 439 2003 46 2004 46 2001 2011 40 41 123 450 648 43 467 46 2002 43 648 59 125 125 64 2003 46 2004 46 2005 40 648 41 439 457 2012 46 2013 46 2000 46 2006 2014 40 41 123 450 418 2012 46 2013 46 2000 46 2006 40 41 59 125 64 2003 46 2004 46 2005 40 648 41 439 2001 2015 40 41 123 450 467 46 2002 59 125 64 2003 46 2004 46 2016 64 2003 46 2004 46 2005 40 648 41 439 324 2017 40 381 2003 46 2004 46 2018 2019 41 123 392 40 2019 614 467 41 450 473 59 392 40 33 40 2019 402 2012 46 2013 46 2000 41 41 450 380 59 381 2012 46 2013 46 2000 2020 61 40 2012 46 2013 46 2000 41 2019 59 381 2003 46 2004 46 2018 467 36 2002 61 467 46 2015 40 41 59 381 2003 46 2004 46 2018 2020 36 2002 61 2020 46 2015 40 41 59 392 40 467 36 2002 614 424 63 2020 36 2002 631 424 58 33 467 36 2002 46 2017 40 2020 36 2002 41 41 450 380 59 450 473 59 125 64 2003 46 2004 46 2016 64 2003 46 2004 46 2005 40 648 41 439 404 2021 40 41 123 381 404 2022 61 1503 59 404 2023 61 1501 59 381 2003 46 2004 46 2018 36 2002 61 467 46 2015 40 41 59 2023 61 2023 42 2022 43 40 36 2002 614 424 63 1503 58 36 2002 46 2021 40 41 41 59 450 2023 59 125 64 2003 46 2004 46 2016 64 2003 46 2004 46 2005 40 648 41 439 2003 46 2004 46 2001 2024 40 41 123 450 648 43 467 46 2015 40 41 43 648 59 125 125 
29177,Java,"    private class EventParser extends GameXmlReader {

        @Override
        protected Path getSchemaFilePath() {
            return ServerSettings.dataPackDirectory().resolve(""data/xsd/eventConfig.xsd"");
        }

        @Override
        public void load() {
            parseDatapackFile(getConfigPath());
            releaseResources();
        }

        @Override
        public void parseDocument(Document doc, File f) {
            forEach(doc, ""event"", eventNode -> {
                var attrs = eventNode.getAttributes();
                name = parseString(attrs, ""name"");
                period = DateRange.parse(parseString(attrs, ""start-date""), parseString(attrs, ""end-date""));
                startMessage = parseString(attrs, ""start-message"");
                endMessage = parseString(attrs, ""end-message"");

                final var today = LocalDateTime.now();

                if(period.isWithinRange(today)) {
                    for(var node = eventNode.getFirstChild(); nonNull(node); node = node.getNextSibling()) {
                        switch (node.getNodeName()) {
                            case ""drop"" -> parseDrop(node);
                            case ""spawns"" -> parseSpawns(node);
                        }
                    }
                }

                forEach(eventNode, ""destroy-items-on-end"",
                        destroyNode -> itemsToDestroy.addAll(parseIntSet(destroyNode)));

            });
        }

        private void parseSpawns(Node node) {
            forEach(node, ""spawn"", spawnNode -> {
               final var npcId = parseInt(spawnNode.getAttributes(), ""npc"");

               if(!NpcData.getInstance().existsNpc(npcId)) {
                   LOGGER.warn(""{} event: Npc Id {} not found"", getScriptName(), npcId);
                   return;
               }
               spawnList.add(new NpcSpawn(npcId, parseLocation(spawnNode)));
            });
        }

        private void parseDrop(Node node) {
            forEach(node, ""item"", itemNode -> {
                final var attrs  = itemNode.getAttributes();
                final var id = parseInt(attrs, ""id"");
                final var min = parseInt(attrs, ""min"");
                final var max = parseInt(attrs, ""max"");
                final var chance = parseDouble(attrs, ""chance"");
                final var minLevel = parseInt(attrs, ""min-level"");
                final var maxLevel = parseInt(attrs, ""max-level"");
                final var monsters = parseIntSet(attrs, ""monsters"");

                dropList.add(new EventDropHolder(id, min, max, chance, minLevel, maxLevel, monsters));
            });
        }
    }",0,437 334 2000 378 2001 123 64 2002 438 2003 2004 40 41 123 450 2005 46 2006 40 41 46 2007 40 648 41 59 125 64 2002 439 492 2008 40 41 123 2009 40 2010 40 41 41 59 2011 40 41 59 125 64 2002 439 492 2012 40 2013 2014 44 2015 2016 41 123 2017 40 2014 44 648 44 2018 45 62 123 490 2019 61 2018 46 2020 40 41 59 2021 61 2022 40 2019 44 648 41 59 2023 61 2024 46 2025 40 2022 40 2019 44 648 41 44 2022 40 2019 44 648 41 41 59 2026 61 2022 40 2019 44 648 41 59 2027 61 2022 40 2019 44 648 41 59 381 490 2028 61 2029 46 2030 40 41 59 392 40 2023 46 2031 40 2028 41 41 123 385 40 490 2032 61 2018 46 2033 40 41 59 2034 40 2032 41 59 2032 61 2032 46 2035 40 41 41 123 464 40 2032 46 2036 40 41 41 123 328 648 45 62 2037 40 2032 41 59 328 648 45 62 2038 40 2032 41 59 125 125 125 2017 40 2018 44 648 44 2039 45 62 2040 46 2041 40 2042 40 2039 41 41 41 59 125 41 59 125 437 492 2043 40 2044 2045 41 123 2046 40 2045 44 648 44 2047 45 62 123 381 490 2048 61 2049 40 2047 46 2050 40 41 44 648 41 59 392 40 33 2051 46 2052 40 41 46 2053 40 2048 41 41 123 2054 46 2055 40 648 44 2056 40 41 44 2048 41 59 450 59 125 2057 46 2058 40 418 2059 40 2048 44 2060 40 2047 41 41 41 59 125 41 59 125 437 492 2061 40 2044 2045 41 123 2062 40 2045 44 648 44 2063 45 62 123 381 490 2064 61 2063 46 2065 40 41 59 381 490 2066 61 2067 40 2064 44 648 41 59 381 490 2068 61 2067 40 2064 44 648 41 59 381 490 2069 61 2067 40 2064 44 648 41 59 381 490 2070 61 2071 40 2064 44 648 41 59 381 490 2072 61 2067 40 2064 44 648 41 59 381 490 2073 61 2067 40 2064 44 648 41 59 381 490 2074 61 2075 40 2064 44 648 41 59 2076 46 2077 40 418 2078 40 2066 44 2068 44 2069 44 2070 44 2072 44 2073 44 2074 41 41 59 125 41 59 125 125 
30493,Java,"		VERBATIM {
			@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {
				return Javac.getDocComment(cu, node.get());
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 44 381 2006 2007 41 123 450 2008 46 2009 40 2005 44 2007 46 2010 40 41 41 59 125 125 44 
30497,Java,"		WITH {
			@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {
				return addReturnsUpdatedSelfIfNeeded(applySetter(cu, node, ""WITH|WITHER""));
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 44 381 2006 2007 41 123 450 2008 40 2009 40 2005 44 2007 44 648 41 41 59 125 125 44 
32331,Java,"    public static class NoopI implements LInstruction{
        @Override
        public void run(LExecutor exec){}
    }",0,439 457 334 2000 395 2001 123 64 2002 439 492 2003 40 2004 2005 41 123 125 125 
29179,Java,"    protected class ScheduleEnd implements Runnable {
        @Override
        public void run() {

            destroyItemsOnEnd();

            if(isNotEmpty(endMessage)) {
                Broadcast.toAllOnlinePlayers(endMessage);
            }

            if(enterAnnounceId != -1) {
                AnnouncementsManager.getInstance().deleteAnnouncement(enterAnnounceId);
            }
        }
    }",0,438 334 2000 395 2001 123 64 2002 439 492 2003 40 41 123 2004 40 41 59 392 40 2005 40 2006 41 41 123 2007 46 2008 40 2006 41 59 125 392 40 2009 631 45 1501 41 123 2010 46 2011 40 41 46 2012 40 2009 41 59 125 125 125 
30945,Java,"  public static @lombok.experimental.SuperBuilder class Parent {
    public static abstract @java.lang.SuppressWarnings(""all"") class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
      private @java.lang.SuppressWarnings(""all"") String foo$value;
      private @java.lang.SuppressWarnings(""all"") boolean foo$set;
      public ParentBuilder() {
        super();
      }
      protected abstract @java.lang.SuppressWarnings(""all"") B self();
      public abstract @java.lang.SuppressWarnings(""all"") C build();
      /**
       * @return {@code this}.
       */
      public @java.lang.SuppressWarnings(""all"") B foo(final String foo) {
        this.foo$value = foo;
        foo$set = true;
        return self();
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value) + "")"");
      }
    }
    private static final @java.lang.SuppressWarnings(""all"") class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
      private ParentBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
      }
    }
    private @lombok.Builder.Default String foo;
    private static @java.lang.SuppressWarnings(""all"") String $default$foo() {
      return doSth(Arrays.asList(1), Arrays.asList('a'));
    }
    protected @java.lang.SuppressWarnings(""all"") Parent(final SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> b) {
      super();
      if (b.foo$set)
          this.foo = b.foo$value;
      else
          this.foo = SuperBuilderWithDefaultsAndTargetTyping.Parent.$default$foo();
    }
    public static @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> builder() {
      return new SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl();
    }
  }",0,439 457 64 2000 46 2001 46 2002 334 2003 123 439 457 305 64 2004 46 2005 46 2006 40 648 41 334 2007 60 2008 378 2009 46 2003 44 2010 378 2009 46 2003 46 2007 60 2008 44 2010 641 123 437 64 2004 46 2005 46 2006 40 648 41 2011 2012 36 2013 59 437 64 2004 46 2005 46 2006 40 648 41 324 2012 36 2014 59 439 2007 40 41 123 463 40 41 59 125 438 305 64 2004 46 2005 46 2006 40 648 41 2010 2015 40 41 59 439 305 64 2004 46 2005 46 2006 40 648 41 2008 2016 40 41 59 618 439 64 2004 46 2005 46 2006 40 648 41 2010 2012 40 381 2011 2012 41 123 467 46 2012 36 2013 61 2012 59 2012 36 2014 61 473 59 450 2015 40 41 59 125 439 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 2004 46 2005 46 2011 2018 40 41 123 450 40 40 648 43 467 46 2012 36 2013 41 43 648 41 59 125 125 437 457 381 64 2004 46 2005 46 2006 40 648 41 334 2019 378 2009 46 2003 46 2007 60 2009 46 2003 44 2009 46 2003 46 2019 62 123 437 2019 40 41 123 463 40 41 59 125 438 64 2004 46 2005 46 2020 64 2004 46 2005 46 2006 40 648 41 2009 46 2003 46 2019 2021 40 41 123 450 467 59 125 439 64 2004 46 2005 46 2020 64 2004 46 2005 46 2006 40 648 41 2009 46 2003 2022 40 41 123 450 418 2009 46 2003 40 467 41 59 125 125 437 64 2000 46 2023 46 2024 2025 2026 59 437 457 64 2004 46 2005 46 2006 40 648 41 2025 36 349 36 2026 40 41 123 450 2027 40 2028 46 2029 40 1501 41 44 2028 46 2029 40 607 41 41 59 125 438 64 2004 46 2005 46 2006 40 648 41 2003 40 381 2009 46 2003 46 2007 60 63 44 63 62 2030 41 123 463 40 41 59 392 40 2030 46 2026 36 2031 41 467 46 2026 61 2030 46 2026 36 2032 59 360 467 46 2026 61 2009 46 2003 46 36 349 36 2026 40 41 59 125 439 457 64 2004 46 2005 46 2006 40 648 41 2009 46 2003 46 2007 60 63 44 63 62 2033 40 41 123 450 418 2009 46 2003 46 2019 40 41 59 125 125 
5259,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem,
                            PendingTradesListItem> column) {
                        return new TableCell<>() {
                            private Trade trade;
                            private JFXButton warnIconButton, trashIconButton;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    trade = newItem.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    cleanup();
                                }
                            }

                            private void update() {
                                if (isMaybeInvalidTrade(trade)) {
                                    Text warnIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE);
                                    Text trashIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ARROW_RIGHT_BOLD_BOX_OUTLINE);
                                    if (trade.isTxChainInvalid()) {
                                        trashIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        trashIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }

                                    warnIconButton = new JFXButton("""", warnIcon);
                                    warnIconButton.getStyleClass().add(""hidden-icon-button"");
                                    warnIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.warningIcon.tooltip"")));
                                    warnIconButton.setOnAction(e -> onShowInfoForInvalidTrade(trade));

                                    trashIconButton = new JFXButton("""", trashIcon);
                                    trashIconButton.getStyleClass().add(""hidden-icon-button"");
                                    trashIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.moveTradeToFailedIcon.tooltip"")));
                                    trashIconButton.setOnAction(e -> onMoveInvalidTradeToFailedTrades(trade));

                                    HBox hBox = new HBox();
                                    hBox.setSpacing(0);
                                    hBox.getChildren().addAll(warnIconButton, trashIconButton);
                                    setGraphic(hBox);
                                } else {
                                    cleanup();
                                }

                                updateMoveTradeToFailedColumnState();
                            }

                            private void cleanup() {
                                if (warnIconButton != null) {
                                    warnIconButton.setOnAction(null);
                                }
                                if (trashIconButton != null) {
                                    trashIconButton.setOnAction(null);
                                }
                                if (listener != null && trade != null) {
                                    trade.stateProperty().removeListener(listener);
                                }
                                setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 437 2009 2010 44 2011 59 437 2012 60 2007 46 2013 62 2014 59 64 2001 439 492 2015 40 2003 2016 44 324 362 41 123 463 46 2015 40 2016 44 362 41 59 392 40 33 362 605 2016 631 424 41 123 2008 61 2016 46 2017 40 41 59 2014 61 40 2018 44 2019 44 2020 41 45 62 2021 40 41 59 2008 46 2022 40 41 46 2023 40 2014 41 59 2021 40 41 59 125 360 123 2024 40 41 59 125 125 437 492 2025 40 41 123 392 40 2026 40 2008 41 41 123 2027 2028 61 2029 46 2030 40 2031 46 2032 41 59 2027 2033 61 2029 46 2030 40 2031 46 2034 41 59 392 40 2008 46 2035 40 41 41 123 2033 46 2036 40 41 46 2037 40 648 44 648 41 59 2028 46 2036 40 41 46 2037 40 648 44 648 41 59 125 360 123 2033 46 2038 40 41 46 2039 40 648 44 648 41 59 2028 46 2038 40 41 46 2039 40 648 44 648 41 59 125 2010 61 418 2009 40 648 44 2028 41 59 2010 46 2040 40 41 46 2041 40 648 41 59 2010 46 2042 40 418 2043 40 2044 46 2045 40 648 41 41 41 59 2010 46 2046 40 2047 45 62 2048 40 2008 41 41 59 2011 61 418 2009 40 648 44 2033 41 59 2011 46 2040 40 41 46 2041 40 648 41 59 2011 46 2042 40 418 2043 40 2044 46 2045 40 648 41 41 41 59 2011 46 2046 40 2047 45 62 2049 40 2008 41 41 59 2050 2051 61 418 2050 40 41 59 2051 46 2052 40 1500 41 59 2051 46 2053 40 41 46 2054 40 2010 44 2011 41 59 2055 40 2051 41 59 125 360 123 2056 40 41 59 125 2057 40 41 59 125 437 492 2058 40 41 123 392 40 2010 631 424 41 123 2010 46 2059 40 424 41 59 125 392 40 2011 631 424 41 123 2011 46 2060 40 424 41 59 125 392 40 2014 631 424 605 2008 631 424 41 123 2008 46 2061 40 41 46 2062 40 2014 41 59 125 2063 40 424 41 59 125 125 59 125 125 41 59 
5261,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getMyRole(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 418 2010 40 2011 46 2012 40 2008 41 41 41 59 360 2009 40 424 41 59 125 125 59 125 125 41 59 
3443,Java,"        selectedPaymentAccountsList.setCellFactory(new Callback<>() {
            @Override
            public ListCell<TraderDataItem> call(
                    ListView<TraderDataItem> param) {
                return new ListCell<>() {
                    @Override
                    protected void updateItem(TraderDataItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setText(item.getPaymentAccountPayload().getPaymentDetails());
                        } else {
                            setText(null);
                        }
                    }
                };
            }
        });",0,2000 46 2001 40 418 2002 60 62 40 41 123 64 2003 439 2004 60 2005 62 2006 40 2007 60 2005 62 2008 41 123 450 418 2004 60 62 40 41 123 64 2003 438 492 2009 40 2005 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 2011 40 2010 46 2012 40 41 46 2013 40 41 41 59 125 360 123 2014 40 424 41 59 125 125 125 59 125 125 41 59 
32928,Java,"                        new ThrowableAssert.ThrowingCallable() {
                            public void call() {
                                mock.clear();
                            }
                        })",0,418 2000 46 2001 40 41 123 439 492 2002 40 41 123 2003 46 2004 40 41 59 125 125 41 
5266,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    try {
                                        String volume = VolumeUtil.formatVolumeWithCode(item.getTrade().getVolume());
                                        setGraphic(new AutoTooltipLabel(volume));
                                    } catch (Throwable ignore) {
                                        log.debug(ignore.toString()); // Stupidity to make Codacy happy
                                    }
                                } else
                                    setGraphic(null);
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 474 123 2005 2006 61 2007 46 2008 40 2004 46 2009 40 41 46 2010 40 41 41 59 2011 40 418 2012 40 2006 41 41 59 125 329 40 2013 2014 41 123 2015 46 2016 40 2014 46 2017 40 41 41 59 621 125 125 360 2018 40 424 41 59 125 125 59 
29252,Java,"    private class PurgeThread implements Runnable{
        @Override
        public void run() {
            synchronized (authedClients) {
                var entries = authedClients.entrySet().iterator();
                while (entries.hasNext()) {
                    var entry = entries.next();
                    var client = entry.getValue();

                    if(!client.isJoinedGameSever() && client.getConnectionStartTime() + TimeUnit.MINUTES.toMillis(LOGIN_TIMEOUT) <= currentTimeMillis() || !client.isConnected()) {
                        client.close(REASON_ACCESS_FAILED_TRYA1);
                        entries.remove();
                    }
                }

                if(authedClients.isEmpty()) {
                    scheduledPurge.cancel(false);
                }
            }
        }
    }",0,437 334 2000 395 2001 123 64 2002 439 492 2003 40 41 123 465 40 2004 41 123 490 2005 61 2004 46 2006 40 41 46 2007 40 41 59 496 40 2005 46 2008 40 41 41 123 490 2009 61 2005 46 2010 40 41 59 490 2011 61 2009 46 2012 40 41 59 392 40 33 2011 46 2013 40 41 605 2011 46 2014 40 41 43 2015 46 2016 46 2017 40 2018 41 620 2019 40 41 606 33 2011 46 2020 40 41 41 123 2011 46 2021 40 2022 41 59 2005 46 2023 40 41 59 125 125 392 40 2004 46 2024 40 41 41 123 2025 46 2026 40 380 41 59 125 125 125 125 
29178,Java,"    protected static class NpcSpawn {
        protected final Location loc;
        protected final int npcId;

        protected NpcSpawn(int pNpcId, Location spawnLoc) {
            loc = spawnLoc;
            npcId = pNpcId;
        }
    }",0,438 457 334 2000 123 438 381 2001 2002 59 438 381 404 2003 59 438 2000 40 404 2004 44 2001 2005 41 123 2002 61 2005 59 2003 61 2004 59 125 125 
26129,Java,"public class FilterUtil {

    private static final Pattern XML_PATTERN = Pattern.compile("".+\\.xml$"", Pattern.CASE_INSENSITIVE);
    private static final Pattern HTML_PATTERN = Pattern.compile("".+\\.html?$"", Pattern.CASE_INSENSITIVE);
    private static final Pattern JAVA_PATTERN = Pattern.compile("".+\\.java?$"", Pattern.CASE_INSENSITIVE);

    public static boolean xmlFile(Path path) {
        return Files.isRegularFile(path) && XML_PATTERN.matcher(path.toString()).matches();
    }

    public static boolean xmlFile(File file) {
        return nonNull(file) && file.isFile() && XML_PATTERN.matcher(file.getName()).matches();
    }

    public static boolean htmlFile(Path path) {
        return Files.isRegularFile(path) && HTML_PATTERN.matcher(path.toString()).matches();
    }

    public static boolean javaFile(Path path) {
        return Files.isRegularFile(path) && JAVA_PATTERN.matcher(path.toString()).matches();
    }
}",0,439 334 2000 123 437 457 381 2001 2002 61 2001 46 2003 40 648 44 2001 46 2004 41 59 437 457 381 2001 2005 61 2001 46 2003 40 648 44 2001 46 2004 41 59 437 457 381 2001 2006 61 2001 46 2003 40 648 44 2001 46 2004 41 59 439 457 324 2007 40 2008 2009 41 123 450 2010 46 2011 40 2009 41 605 2002 46 2012 40 2009 46 2013 40 41 41 46 2014 40 41 59 125 439 457 324 2007 40 2015 2016 41 123 450 2017 40 2016 41 605 2016 46 2018 40 41 605 2002 46 2019 40 2016 46 2020 40 41 41 46 2021 40 41 59 125 439 457 324 2022 40 2008 2009 41 123 450 2023 46 2024 40 2009 41 605 2005 46 2025 40 2009 46 2026 40 41 41 46 2027 40 41 59 125 439 457 324 2028 40 2008 2009 41 123 450 2029 46 2030 40 2009 41 605 2006 46 2031 40 2009 46 2032 40 41 41 46 2033 40 41 59 125 125 
30506,Java,"			values.put(mName, new AnnotationValue(node, raws, expressions, guesses, true) {
				@Override public void setError(String message, int valueIdx) {
					if (valueIdx < 0) node.addError(message);
					else node.addError(message, positions.get(valueIdx));
				}
				
				@Override public void setWarning(String message, int valueIdx) {
					if (valueIdx < 0) node.addWarning(message);
					else node.addWarning(message, positions.get(valueIdx));
				}
			});",0,2000 46 2001 40 2002 44 418 2003 40 2004 44 2005 44 2006 44 2007 44 473 41 123 64 2008 439 492 2009 40 2010 2011 44 404 2012 41 123 392 40 2012 60 1500 41 2004 46 2013 40 2011 41 59 360 2004 46 2013 40 2011 44 2014 46 2015 40 2012 41 41 59 125 64 2008 439 492 2016 40 2010 2011 44 404 2012 41 123 392 40 2012 60 1500 41 2004 46 2017 40 2011 41 59 360 2004 46 2017 40 2011 44 2018 46 2019 40 2012 41 41 59 125 125 41 59 
30731,Java,"	@SuppressWarnings(""unused"")
	private static class EclipseInitializer {
		static void initializeEclipseBundles() throws Exception {
			// This code does not work yet, it's research-in-progress.
			// The problem is that parts of the eclipse handler (in `PatchValEclipse` and friends) do not work unless
			// an actual eclipse exists; PatchVal causes code to run that will end up running `ResourcesPlugin.getWorkspace()`, which
			// goes down a rabbit hole of pinging off of various static fields (or `getX()` calls which return static fields), all
			// of which are `null` until the plugin they belong to is properly initialized.
			// This code is work in progress to 'hack' the initialization of each plugin one-by-one, but I doubt this is the right
			// way to do it, as I bet it's fragile (will break when eclipse updates rather easily), and who knows how many fields
			// and things need to be initialized.
			// A better plan would be to start an actual, real eclipse, by telling `EclipseStarter.startup` to launch some sort of
			// application (or at least a bunch of bundles/products/apps, including the JDT). This will then take long enough that
			// it'll need to be cached and re-used for each test or the Eclipse test run would take far too long.
			
			BundleContext context = EclipseStarter.startup(new String[0], null);
			RegistryFactory.setDefaultRegistryProvider(new IRegistryProvider() {
				private final ExtensionRegistry REG = new ExtensionRegistry(null, null, null);
				@Override public IExtensionRegistry getRegistry() {
					return REG;
				}
			});
			new Activator().start(context);
			new PlatformActivator().start(context);
			for (Bundle b : context.getBundles()) System.out.println(""BUNDLE: "" + b.getSymbolicName());
			new ResourcesPlugin().start(context);
			JavaModelManager.getJavaModelManager().startup();
		}
	}",0,64 2000 40 648 41 437 457 334 2001 123 457 492 2002 40 41 470 2003 123 621 621 621 621 621 621 621 621 621 621 621 2004 2005 61 2006 46 2007 40 418 2008 91 1500 93 44 424 41 59 2009 46 2010 40 418 2011 40 41 123 437 381 2012 2013 61 418 2012 40 424 44 424 44 424 41 59 64 2014 439 2015 2016 40 41 123 450 2013 59 125 125 41 59 418 2017 40 41 46 2018 40 2005 41 59 418 2019 40 41 46 2018 40 2005 41 59 385 40 2020 2021 58 2005 46 2022 40 41 41 2023 46 430 46 2024 40 648 43 2021 46 2025 40 41 41 59 418 2026 40 41 46 2018 40 2005 41 59 2027 46 2028 40 41 46 2007 40 41 59 125 125 
27182,Java,"public final class ItemCrystallizationData extends GameXmlReader {
    private static final Logger LOGGER = LoggerFactory.getLogger(ItemCrystallizationData.class);

    private final Map<CrystalType, Map<CrystallizationType, List<ItemChanceHolder>>> crystallizationTemplates = new EnumMap<>(CrystalType.class);
    private final IntMap<CrystallizationDataHolder> items = new HashIntMap<>();

    private ItemCrystallizationData() {
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/crystallizable-items.xsd"");
    }

    @Override
    public void load() {
        crystallizationTemplates.clear();
        CrystalType.forEach(c -> crystallizationTemplates.put(c, new EnumMap<>(CrystallizationType.class)));

        items.clear();
        parseDatapackFile(""data/crystallizable-items.xml"");
        LOGGER.info(""Loaded {} crystallization templates."", crystallizationTemplates.size());
        LOGGER.info(""Loaded {} pre-defined crystallizable items."", items.size());

        // Generate remaining data.
        generateCrystallizationData();
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", listNode -> {
            for(Node node = listNode.getFirstChild(); nonNull(node); node = node.getNextSibling()) {
                switch (node.getNodeName()) {
                    case ""templates"" -> forEach(node, ""template"", this::parseTemplate);
                    case ""items"" -> forEach(node, ""item"", this::parseItem);
                }
            }
        });
    }

    private void parseTemplate(Node node) {
        forEach(node, ""template"", templateNode -> {
            var attr = templateNode.getAttributes();
            var crystalType = parseEnum(attr, CrystalType.class, ""crystalType"");
            var crystallizationType = parseEnum(attr, CrystallizationType.class, ""crystallizationType"");

            crystallizationTemplates.get(crystalType).put(crystallizationType, parseRewards(templateNode));
        });
    }

    private List<ItemChanceHolder> parseRewards(Node templateNode) {
        final List<ItemChanceHolder> crystallizeRewards = new ArrayList<>();

        forEach(templateNode, ""item"", itemNode -> {
            var attrs = itemNode.getAttributes();
            var itemId = parseInt(attrs, ""id"");
            var itemCount = parseLong(attrs, ""count"");
            var itemChance = parseFloat(attrs, ""chance"");
            crystallizeRewards.add(new ItemChanceHolder(itemId, itemChance, itemCount));
        });
        return crystallizeRewards;
    }

    private void parseItem(Node node) {
        forEach(node, ""item"", itemNode -> {
            final int id = parseInt(itemNode.getAttributes(), ""id"");
            items.put(id, new CrystallizationDataHolder(parseRewards(itemNode)));
        });
    }

    private List<ItemChanceHolder> calculateCrystallizeRewards(ItemTemplate item, List<ItemChanceHolder> crystallizeRewards) {
        if (isNull(crystallizeRewards)) {
            return null;
        }

        final List<ItemChanceHolder> rewards = new ArrayList<>();

        for (ItemChanceHolder reward : crystallizeRewards) {
            float chance = reward.getChance() * item.getCrystalCount();
            long count = reward.getCount();

            if (chance > 100.) {
                double countMul = Math.ceil(chance / 100.);
                chance /= countMul;
                count = (long) (count * countMul);
            }

            rewards.add(new ItemChanceHolder(reward.getId(), chance, count));
        }

        return rewards;
    }

    private void generateCrystallizationData() {
        final int previousCount = items.size();

        if(crystallizationTemplates.values().stream().flatMap(c -> c.values().stream()).anyMatch(Predicate.not(List::isEmpty))) {
            for (ItemTemplate item : ItemEngine.getInstance().getAllItems()) {
                // Check if the data has not been generated.
                if ((isWeapon(item) || isArmor(item)) && item.isCrystallizable() && !items.containsKey(item.getId())) {

                    final List<ItemChanceHolder> holder = crystallizationTemplates.get(item.getCrystalType()).get(isWeapon(item) ? CrystallizationType.WEAPON : CrystallizationType.ARMOR);

                    if (nonNull(holder)) {
                        items.put(item.getId(), new CrystallizationDataHolder(calculateCrystallizeRewards(item, holder)));
                    }
                }
            }
        }

        LOGGER.atInfo().addArgument(() -> items.size() - previousCount).log(""Generated {} crystallizable items from templates."");
    }

    /**
     * @param itemId
     * @return {@code CrystallizationData} for unenchanted items (enchanted items just have different crystal count, but same rewards),<br>
     * or {@code null} if there is no such data registered.
     */
    private CrystallizationDataHolder getCrystallizationData(int itemId) {
        return items.get(itemId);
    }

    /**
     * @param item to calculate its worth in crystals.
     * @return List of {@code ItemChanceHolder} for the rewards with altered crystal count.
     */
    public List<ItemChanceHolder> getCrystallizationRewards(Item item) {
        final List<ItemChanceHolder> result = new ArrayList<>();
        var data = getCrystallizationData(item.getId());
        if (nonNull(data)) {
            // If there are no crystals on the template, add such.
            if (data.getItems().stream().noneMatch(i -> i.getId() == item.getTemplate().getCrystalItemId())) {
                result.add(new ItemChanceHolder(item.getTemplate().getCrystalItemId(), 100, item.getCrystalCount()));
            }

            result.addAll(data.getItems());
        } else {
            // Add basic crystal reward.
            result.add(new ItemChanceHolder(item.getTemplate().getCrystalItemId(), 100, item.getCrystalCount()));
        }

        return result;
    }

    public static void init() {
        getInstance().load();
    }

    public static ItemCrystallizationData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final ItemCrystallizationData INSTANCE = new ItemCrystallizationData();
    }
}",0,439 381 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 44 2006 60 2008 44 2009 60 2010 644 2011 61 418 2012 60 62 40 2007 46 334 41 59 437 381 2013 60 2014 62 2015 61 418 2016 60 62 40 41 59 437 2000 40 41 123 125 64 2017 438 2018 2019 40 41 123 450 2020 46 2021 40 41 46 2022 40 648 41 59 125 64 2017 439 492 2023 40 41 123 2011 46 2024 40 41 59 2007 46 2025 40 2026 45 62 2011 46 2027 40 2026 44 418 2012 60 62 40 2008 46 334 41 41 41 59 2015 46 2024 40 41 59 2028 40 648 41 59 2003 46 2029 40 648 44 2011 46 2030 40 41 41 59 2003 46 2029 40 648 44 2015 46 2030 40 41 41 59 621 2031 40 41 59 2032 40 41 59 125 64 2017 439 492 2033 40 2034 2035 44 2036 2037 41 123 2038 40 2035 44 648 44 2039 45 62 123 385 40 2040 2041 61 2039 46 2042 40 41 59 2043 40 2041 41 59 2041 61 2041 46 2044 40 41 41 123 464 40 2041 46 2045 40 41 41 123 328 648 45 62 2038 40 2041 44 648 44 467 58 58 2046 41 59 328 648 45 62 2038 40 2041 44 648 44 467 58 58 2047 41 59 125 125 125 41 59 125 437 492 2048 40 2049 2050 41 123 2051 40 2050 44 648 44 2052 45 62 123 490 2053 61 2052 46 2054 40 41 59 490 2055 61 2056 40 2053 44 2007 46 334 44 648 41 59 490 2057 61 2056 40 2053 44 2008 46 334 44 648 41 59 2011 46 2058 40 2055 41 46 2059 40 2057 44 2060 40 2052 41 41 59 125 41 59 125 437 2009 60 2010 62 2061 40 2049 2062 41 123 381 2009 60 2010 62 2063 61 418 2064 60 62 40 41 59 2065 40 2062 44 648 44 2066 45 62 123 490 2067 61 2066 46 2068 40 41 59 490 2069 61 2070 40 2067 44 648 41 59 490 2071 61 2072 40 2067 44 648 41 59 490 2073 61 2074 40 2067 44 648 41 59 2063 46 2075 40 418 2010 40 2069 44 2073 44 2071 41 41 59 125 41 59 450 2063 59 125 437 492 2076 40 2049 2050 41 123 2077 40 2050 44 648 44 2078 45 62 123 381 404 2079 61 2080 40 2078 46 2081 40 41 44 648 41 59 2015 46 2082 40 2079 44 418 2014 40 2061 40 2078 41 41 41 59 125 41 59 125 437 2009 60 2010 62 2083 40 2084 2085 44 2009 60 2010 62 2086 41 123 392 40 2087 40 2086 41 41 123 450 424 59 125 381 2009 60 2010 62 2088 61 418 2089 60 62 40 41 59 385 40 2010 2090 58 2086 41 123 384 2091 61 2090 46 2092 40 41 42 2085 46 2093 40 41 59 413 2094 61 2090 46 2095 40 41 59 392 40 2091 62 1503 41 123 356 2096 61 2097 46 2098 40 2091 47 1503 41 59 2091 609 2096 59 2094 61 40 413 41 40 2094 42 2096 41 59 125 2088 46 2099 40 418 2010 40 2090 46 2100 40 41 44 2091 44 2094 41 41 59 125 450 2088 59 125 437 492 2101 40 41 123 381 404 2102 61 2015 46 2103 40 41 59 392 40 2011 46 2104 40 41 46 2105 40 41 46 2106 40 2107 45 62 2107 46 2104 40 41 46 2105 40 41 41 46 2108 40 2109 46 422 40 2009 58 58 2110 41 41 41 123 385 40 2084 2085 58 2111 46 2112 40 41 46 2113 40 41 41 123 621 392 40 40 2114 40 2085 41 606 2115 40 2085 41 41 605 2085 46 2116 40 41 605 33 2015 46 2117 40 2085 46 2118 40 41 41 41 123 381 2009 60 2010 62 2119 61 2011 46 2120 40 2085 46 2121 40 41 41 46 2120 40 2114 40 2085 41 63 2008 46 2122 58 2008 46 2123 41 59 392 40 2124 40 2119 41 41 123 2015 46 2125 40 2085 46 2118 40 41 44 418 2014 40 2083 40 2085 44 2119 41 41 41 59 125 125 125 125 2003 46 2126 40 41 46 2127 40 40 41 45 62 2015 46 2103 40 41 45 2102 41 46 2128 40 648 41 59 125 618 437 2014 2129 40 404 2130 41 123 450 2015 46 2131 40 2130 41 59 125 618 439 2009 60 2010 62 2132 40 2133 2085 41 123 381 2009 60 2010 62 2134 61 418 2135 60 62 40 41 59 490 2136 61 2129 40 2085 46 2137 40 41 41 59 392 40 2138 40 2136 41 41 123 621 392 40 2136 46 2139 40 41 46 2140 40 41 46 2141 40 2142 45 62 2142 46 2137 40 41 614 2085 46 2143 40 41 46 2144 40 41 41 41 123 2134 46 2145 40 418 2010 40 2085 46 2143 40 41 46 2144 40 41 44 1503 44 2085 46 2146 40 41 41 41 59 125 2134 46 2147 40 2136 46 2139 40 41 41 59 125 360 123 621 2134 46 2148 40 418 2010 40 2085 46 2149 40 41 46 2150 40 41 44 1503 44 2085 46 2151 40 41 41 41 59 125 450 2134 59 125 439 457 492 2152 40 41 123 2153 40 41 46 2023 40 41 59 125 439 457 2000 2154 40 41 123 450 2155 46 2156 59 125 437 457 334 2157 123 437 457 381 2000 2158 61 418 2000 40 41 59 125 125 
5255,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getPaymentMethod(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 418 2010 40 2011 46 2012 40 2008 41 41 41 59 360 2009 40 424 41 59 125 125 59 125 125 41 59 
30646,Java,"	@Provides
	public static class HandleNoArgsConstructor extends EclipseAnnotationHandler<NoArgsConstructor> {
		private static final String NAME = NoArgsConstructor.class.getSimpleName();
		private HandleConstructor handleConstructor = new HandleConstructor();
		
		@Override public void handle(AnnotationValues<NoArgsConstructor> annotation, Annotation ast, EclipseNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.NO_ARGS_CONSTRUCTOR_FLAG_USAGE, ""@NoArgsConstructor"", ConfigurationKeys.ANY_CONSTRUCTOR_FLAG_USAGE, ""any @xArgsConstructor"");
			
			EclipseNode typeNode = annotationNode.up();
			if (!checkLegality(typeNode, annotationNode, NAME)) return;
			NoArgsConstructor ann = annotation.getInstance();
			AccessLevel level = ann.access();
			String staticName = ann.staticName();
			if (level == AccessLevel.NONE) return;
			
			boolean force = ann.force();
			
			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, ""onConstructor"", ""@NoArgsConstructor(onConstructor"", annotationNode);
			
			handleConstructor.generateConstructor(typeNode, level, Collections.<EclipseNode>emptyList(), force, staticName, SkipIfConstructorExists.NO, onConstructor, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 2003 46 334 46 2006 40 41 59 437 2007 2008 61 418 2007 40 41 59 64 2009 439 492 2010 40 2011 60 2003 62 2012 44 2013 2014 44 2015 2016 41 123 2017 40 2016 44 2018 46 2019 44 648 44 2018 46 2020 44 648 41 59 2015 2021 61 2016 46 2022 40 41 59 392 40 33 2023 40 2021 44 2016 44 2005 41 41 450 59 2003 2024 61 2012 46 2025 40 41 59 2026 2027 61 2024 46 2028 40 41 59 2004 2029 61 2024 46 2029 40 41 59 392 40 2027 614 2026 46 2030 41 450 59 324 2031 61 2024 46 2031 40 41 59 2032 60 2013 62 2033 61 2034 40 2014 44 648 44 648 44 2016 41 59 2008 46 2035 40 2021 44 2027 44 2036 46 60 2015 62 2037 40 41 44 2031 44 2029 44 2038 46 2039 44 2033 44 2016 41 59 125 125 
30700,Java,"	public static class Parent {
		private String foo;

		@java.lang.SuppressWarnings(""all"")
		private static String $default$foo() {
			return doSth(Arrays.asList(1), Arrays.asList('a'));
		}


		@java.lang.SuppressWarnings(""all"")
		public static abstract class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
			@java.lang.SuppressWarnings(""all"")
			private boolean foo$set;
			@java.lang.SuppressWarnings(""all"")
			private String foo$value;

			@java.lang.SuppressWarnings(""all"")
			protected abstract B self();

			@java.lang.SuppressWarnings(""all"")
			public abstract C build();

			/**
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings(""all"")
			public B foo(final String foo) {
				this.foo$value = foo;
				foo$set = true;
				return self();
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value + "")"";
			}
		}


		@java.lang.SuppressWarnings(""all"")
		private static final class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
			@java.lang.SuppressWarnings(""all"")
			private ParentBuilderImpl() {
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
				return this;
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
				return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
			}
		}

		@java.lang.SuppressWarnings(""all"")
		protected Parent(final SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> b) {
			if (b.foo$set) this.foo = b.foo$value;
			 else this.foo = SuperBuilderWithDefaultsAndTargetTyping.Parent.$default$foo();
		}

		@java.lang.SuppressWarnings(""all"")
		public static SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<?, ?> builder() {
			return new SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl();
		}
	}",0,439 457 334 2000 123 437 2001 2002 59 64 2003 46 2004 46 2005 40 648 41 437 457 2001 36 349 36 2002 40 41 123 450 2006 40 2007 46 2008 40 1501 41 44 2007 46 2008 40 607 41 41 59 125 64 2003 46 2004 46 2005 40 648 41 439 457 305 334 2009 60 2010 378 2011 46 2000 44 2012 378 2011 46 2000 46 2009 60 2010 44 2012 641 123 64 2003 46 2004 46 2005 40 648 41 437 324 2002 36 2013 59 64 2003 46 2004 46 2005 40 648 41 437 2001 2002 36 2014 59 64 2003 46 2004 46 2005 40 648 41 438 305 2012 2015 40 41 59 64 2003 46 2004 46 2005 40 648 41 439 305 2010 2016 40 41 59 618 64 2003 46 2004 46 2005 40 648 41 439 2012 2002 40 381 2001 2002 41 123 467 46 2002 36 2014 61 2002 59 2002 36 2013 61 473 59 450 2015 40 41 59 125 64 2003 46 2004 46 2017 64 2003 46 2004 46 2005 40 648 41 439 2003 46 2004 46 2001 2018 40 41 123 450 648 43 467 46 2002 36 2014 43 648 59 125 125 64 2003 46 2004 46 2005 40 648 41 437 457 381 334 2019 378 2011 46 2000 46 2009 60 2011 46 2000 44 2011 46 2000 46 2019 62 123 64 2003 46 2004 46 2005 40 648 41 437 2019 40 41 123 125 64 2003 46 2004 46 2020 64 2003 46 2004 46 2005 40 648 41 438 2011 46 2000 46 2019 2021 40 41 123 450 467 59 125 64 2003 46 2004 46 2020 64 2003 46 2004 46 2005 40 648 41 439 2011 46 2000 2022 40 41 123 450 418 2011 46 2000 40 467 41 59 125 125 64 2003 46 2004 46 2005 40 648 41 438 2000 40 381 2011 46 2000 46 2009 60 63 44 63 62 2023 41 123 392 40 2023 46 2002 36 2024 41 467 46 2002 61 2023 46 2002 36 2025 59 360 467 46 2002 61 2011 46 2000 46 36 349 36 2002 40 41 59 125 64 2003 46 2004 46 2005 40 648 41 439 457 2011 46 2000 46 2009 60 63 44 63 62 2026 40 41 123 450 418 2011 46 2000 46 2019 40 41 59 125 125 
5248,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    final Trade trade = newItem.getTrade();
                                    final NodeAddress tradingPeerNodeAddress = trade.getTradingPeerNodeAddress();
                                    int numPastTrades = model.getNumPastTrades(trade);
                                    String role = Res.get(""peerInfoIcon.tooltip.tradePeer"");
                                    Node peerInfoIcon = new PeerInfoIconTrading(tradingPeerNodeAddress,
                                            role,
                                            numPastTrades,
                                            privateNotificationManager,
                                            trade,
                                            preferences,
                                            model.accountAgeWitnessService,
                                            useDevPrivilegeKeys);
                                    setPadding(new Insets(1, 0, 0, 0));
                                    setGraphic(peerInfoIcon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 33 362 605 2004 631 424 41 123 381 2005 2006 61 2004 46 2007 40 41 59 381 2008 2009 61 2006 46 2010 40 41 59 404 2011 61 2012 46 2013 40 2006 41 59 2014 2015 61 2016 46 2017 40 648 41 59 2018 2019 61 418 2020 40 2009 44 2015 44 2011 44 2021 44 2006 44 2022 44 2012 46 2023 44 2024 41 59 2025 40 418 2026 40 1501 44 1500 44 1500 44 1500 41 41 59 2027 40 2019 41 59 125 360 123 2028 40 424 41 59 125 125 125 59 
29550,Java,"public class BuilderDefaultsTargetTyping {
	String foo;

	static String doSth(java.util.List<Integer> i, java.util.List<Character> c) {
		return null;
	}

	@java.lang.SuppressWarnings(""all"")
	private static String $default$foo() {
		return doSth(Arrays.asList(1), Arrays.asList('a'));
	}

	@java.lang.SuppressWarnings(""all"")
	BuilderDefaultsTargetTyping(final String foo) {
		this.foo = foo;
	}


	@java.lang.SuppressWarnings(""all"")
	public static class BuilderDefaultsTargetTypingBuilder {
		@java.lang.SuppressWarnings(""all"")
		private boolean foo$set;
		@java.lang.SuppressWarnings(""all"")
		private String foo$value;

		@java.lang.SuppressWarnings(""all"")
		BuilderDefaultsTargetTypingBuilder() {
		}

		/**
		 * @return {@code this}.
		 */
		@java.lang.SuppressWarnings(""all"")
		public BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder foo(final String foo) {
			this.foo$value = foo;
			foo$set = true;
			return this;
		}

		@java.lang.SuppressWarnings(""all"")
		public BuilderDefaultsTargetTyping build() {
			String foo$value = this.foo$value;
			if (!this.foo$set) foo$value = BuilderDefaultsTargetTyping.$default$foo();
			return new BuilderDefaultsTargetTyping(foo$value);
		}

		@java.lang.Override
		@java.lang.SuppressWarnings(""all"")
		public java.lang.String toString() {
			return ""BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder(foo$value="" + this.foo$value + "")"";
		}
	}

	@java.lang.SuppressWarnings(""all"")
	public static BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder builder() {
		return new BuilderDefaultsTargetTyping.BuilderDefaultsTargetTypingBuilder();
	}
}",0,439 334 2000 123 2001 2002 59 457 2001 2003 40 2004 46 2005 46 2006 60 2007 62 2008 44 2004 46 2005 46 2006 60 2009 62 2010 41 123 450 424 59 125 64 2004 46 2011 46 2012 40 648 41 437 457 2001 36 349 36 2002 40 41 123 450 2003 40 2013 46 2014 40 1501 41 44 2013 46 2014 40 607 41 41 59 125 64 2004 46 2011 46 2012 40 648 41 2000 40 381 2001 2002 41 123 467 46 2002 61 2002 59 125 64 2004 46 2011 46 2012 40 648 41 439 457 334 2015 123 64 2004 46 2011 46 2012 40 648 41 437 324 2002 36 2016 59 64 2004 46 2011 46 2012 40 648 41 437 2001 2002 36 2017 59 64 2004 46 2011 46 2012 40 648 41 2015 40 41 123 125 618 64 2004 46 2011 46 2012 40 648 41 439 2000 46 2015 2002 40 381 2001 2002 41 123 467 46 2002 36 2017 61 2002 59 2002 36 2016 61 473 59 450 467 59 125 64 2004 46 2011 46 2012 40 648 41 439 2000 2018 40 41 123 2001 2002 36 2017 61 467 46 2002 36 2017 59 392 40 33 467 46 2002 36 2016 41 2002 36 2017 61 2000 46 36 349 36 2002 40 41 59 450 418 2000 40 2002 36 2017 41 59 125 64 2004 46 2011 46 2019 64 2004 46 2011 46 2012 40 648 41 439 2004 46 2011 46 2001 2020 40 41 123 450 648 43 467 46 2002 36 2017 43 648 59 125 125 64 2004 46 2011 46 2012 40 648 41 439 457 2000 46 2015 2021 40 41 123 450 418 2000 46 2015 40 41 59 125 125 
27758,Java,"public class SiegeScheduleData extends GameXmlReader {
    private static final Logger LOGGER = LoggerFactory.getLogger(SiegeScheduleData.class);

    private final List<SiegeScheduleDate> scheduleData = new ArrayList<>();

    private SiegeScheduleData() {
        load();
    }

    @Override
    protected Path getSchemaFilePath() {
        return Path.of(""config/xsd/siege-schedule.xsd"");
    }

    @Override
    public synchronized void load() {
        scheduleData.clear();
        parseFile(""config/siege-schedule.xml"");
        LOGGER.info(""Loaded: {}  siege schedulers."", scheduleData.size());
        if (scheduleData.isEmpty()) {
            scheduleData.add(new SiegeScheduleDate());
            LOGGER.info(""Loaded: default siege schedulers."");
        }
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", listNode -> forEach(listNode, ""schedule"", scheduleNode -> {
            var attrs = scheduleNode.getAttributes();
            var day = parseEnum(attrs, DayOfWeek.class, ""day"", DayOfWeek.SUNDAY);
            scheduleData.add(new SiegeScheduleDate(day, parseInt(attrs, ""hour""), parseInt(attrs, ""max-concurrent"")));
        }));
    }

    public List<SiegeScheduleDate> getScheduleDates() {
        return scheduleData;
    }

    public static SiegeScheduleData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final SiegeScheduleData INSTANCE = new SiegeScheduleData();
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 62 2008 61 418 2009 60 62 40 41 59 437 2000 40 41 123 2010 40 41 59 125 64 2011 438 2012 2013 40 41 123 450 2012 46 2014 40 648 41 59 125 64 2011 439 465 492 2015 40 41 123 2008 46 2016 40 41 59 2017 40 648 41 59 2003 46 2018 40 648 44 2008 46 2019 40 41 41 59 392 40 2008 46 2020 40 41 41 123 2008 46 2021 40 418 2007 40 41 41 59 2003 46 2018 40 648 41 59 125 2022 40 41 59 125 64 2011 439 492 2023 40 2024 2025 44 2026 2027 41 123 2028 40 2025 44 648 44 2029 45 62 2028 40 2029 44 648 44 2030 45 62 123 490 2031 61 2030 46 2032 40 41 59 490 2033 61 2034 40 2031 44 2035 46 334 44 648 44 2035 46 2036 41 59 2008 46 2037 40 418 2007 40 2033 44 2038 40 2031 44 648 41 44 2038 40 2031 44 648 41 41 41 59 125 41 41 59 125 439 2006 60 2007 62 2039 40 41 123 450 2008 59 125 439 457 2000 2040 40 41 123 450 2041 46 2042 59 125 437 457 334 2043 123 437 457 381 2000 2044 61 418 2000 40 41 59 125 125 
5251,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(DisplayUtils.formatDateTime(item.getTrade().getDate())));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 2009 40 418 2010 40 2011 46 2012 40 2008 46 2013 40 41 46 2014 40 41 41 41 41 59 125 360 123 2015 40 424 41 59 125 125 125 59 125 125 41 59 
3441,Java,"@Slf4j
public class SignPaymentAccountsWindow extends Overlay<SignPaymentAccountsWindow> {

    private Label descriptionLabel;
    private ComboBox<PaymentMethod> paymentMethodComboBox;
    private CheckBox signAllCheckbox;
    private DatePicker datePicker;
    private InputTextField privateKey;
    private ListView<TraderDataItem> selectedPaymentAccountsList = new ListView<>();
    private final AccountAgeWitnessService accountAgeWitnessService;
    private final ArbitratorManager arbitratorManager;
    private final ArbitrationManager arbitrationManager;
    private final MediationManager mediationManager;
    private final String appName;
    private final boolean useDevPrivilegeKeys;


    @Inject
    public SignPaymentAccountsWindow(AccountAgeWitnessService accountAgeWitnessService,
                                     ArbitratorManager arbitratorManager,
                                     ArbitrationManager arbitrationManager,
                                     MediationManager mediationManager,
                                     @Named(Config.APP_NAME) String appName,
                                     @Named(Config.USE_DEV_PRIVILEGE_KEYS) boolean useDevPrivilegeKeys) {
        this.accountAgeWitnessService = accountAgeWitnessService;
        this.arbitratorManager = arbitratorManager;
        this.arbitrationManager = arbitrationManager;
        this.mediationManager = mediationManager;
        this.appName = appName;
        this.useDevPrivilegeKeys = useDevPrivilegeKeys;
    }

    @Override
    public void show() {
        width = 1000;
        rowIndex = -1;
        createGridPane();

        // We want to have more space to read list entries... initial screen does not look so nice now, but
        // dynamically updating height of window is a bit tricky.... @christoph feel free to improve if you like...
        gridPane.setPrefHeight(600);

        gridPane.getColumnConstraints().get(1).setHgrow(Priority.NEVER);

        headLine(Res.get(""popup.accountSigning.selectAccounts.headline""));
        type = Type.Attention;

        addHeadLine();
        addSelectAccountsContent();
        addButtons();
        applyStyles();

        display();
    }

    private void addSelectAccountsContent() {
        descriptionLabel = addMultilineLabel(gridPane, ++rowIndex,
                Res.get(""popup.accountSigning.selectAccounts.description""));

        paymentMethodComboBox = addComboBox(gridPane, ++rowIndex, Res.get(""shared.selectPaymentMethod""));
        paymentMethodComboBox.setVisibleRowCount(11);
        paymentMethodComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(PaymentMethod paymentMethod) {
                return paymentMethod != null ? Res.get(paymentMethod.getId()) : """";
            }

            @Override
            public PaymentMethod fromString(String s) {
                return null;
            }
        });


        paymentMethodComboBox.setItems(FXCollections.observableArrayList(getPaymentMethods()));
        paymentMethodComboBox.setOnAction(e -> updateAccountSelectionState());

        signAllCheckbox = addLabelCheckBox(gridPane, ++rowIndex, Res.get(""popup.accountSigning.selectAccounts.signAll""));
        GridPane.setHalignment(signAllCheckbox, HPos.LEFT);
        signAllCheckbox.selectedProperty().addListener((observable, oldValue, newValue) -> {
            paymentMethodComboBox.setDisable(newValue);
            updateAccountSelectionState();
        });

        datePicker = addTopLabelDatePicker(gridPane, ++rowIndex,
                Res.get(""popup.accountSigning.selectAccounts.datePicker""),
                0).second;
        datePicker.setOnAction(e -> updateAccountSelectionState());
        datePicker.setValue(Instant.ofEpochMilli(new Date().getTime()).minus(60, ChronoUnit.DAYS)
                .atZone(ZoneId.systemDefault()).toLocalDate());
    }

    private List<PaymentMethod> getPaymentMethods() {
        return PaymentMethod.getPaymentMethods().stream()
                .filter(PaymentMethod::isFiat)
                .filter(PaymentMethod::hasChargebackRisk)
                .collect(Collectors.toList());
    }

    private void addECKeyField() {
        privateKey = addInputTextField(gridPane, ++rowIndex, Res.get(""popup.accountSigning.signAccounts.ECKey""));
        GridPane.setVgrow(privateKey, Priority.ALWAYS);
        GridPane.setValignment(privateKey, VPos.TOP);
    }

    private void updateAccountSelectionState() {
        actionButton.setDisable((!signAllCheckbox.isSelected() && paymentMethodComboBox.getSelectionModel().isEmpty()) ||
                datePicker.getValue() == null
        );
    }

    private void removeContent() {
        removeRowsFromGridPane(gridPane, 2, 3);
        rowIndex = 1;
    }

    private void addSelectedAccountsContent() {
        removeContent();
        Tuple3<Label, ListView<TraderDataItem>, VBox> selectedPaymentAccountsTuple =
                addTopLabelListView(gridPane,
                        ++rowIndex, Res.get(""popup.accountSigning.confirmSelectedAccounts.headline""));
        GridPane.setRowSpan(selectedPaymentAccountsTuple.third, 2);
        selectedPaymentAccountsList = selectedPaymentAccountsTuple.second;
        ObservableList<Dispute> disputesAsObservableList = useDevPrivilegeKeys ?
                mediationManager.getDisputesAsObservableList()
                : arbitrationManager.getDisputesAsObservableList();
        long safeDate = datePicker.getValue().atStartOfDay().toEpochSecond(ZoneOffset.UTC) * 1000;
        List<TraderDataItem> traderDataItemList;
        StringBuilder sb = new StringBuilder(""Summary for "").append(appName).append(""\n"");
        if (signAllCheckbox.isSelected()) {
            traderDataItemList = new ArrayList<>();
            getPaymentMethods().forEach(paymentMethod -> {
                List<TraderDataItem> list = accountAgeWitnessService.getTraderPaymentAccounts(
                        safeDate,
                        paymentMethod,
                        disputesAsObservableList);
                traderDataItemList.addAll(list);

                sb.append(""\nPayment method: "").append(Res.get(paymentMethod.getId()))
                        .append("" (No. of signed accounts: "").append(list.size()).append("")\n"");
                list.forEach(traderDataItem -> {
                    sb.append(""Account created: "")
                            .append(FormattingUtils.formatDateTime(new Date(traderDataItem.getAccountAgeWitness().getDate()), true))
                            .append("" Account: "")
                            .append(traderDataItem.getPaymentAccountPayload().getPaymentDetails()).append(""\n"");
                });
            });
            sb.append(""\nTotal accounts signed: "").append(traderDataItemList.size());
        } else {
            PaymentMethod paymentMethod = paymentMethodComboBox.getSelectionModel().getSelectedItem();
            traderDataItemList = accountAgeWitnessService.getTraderPaymentAccounts(
                    safeDate,
                    paymentMethod,
                    disputesAsObservableList);
            sb.append(""\nPayment method: "").append(Res.get(paymentMethod.getId()))
                    .append("" (No. of signed accounts: "").append(traderDataItemList.size()).append("")\n"");
            traderDataItemList.forEach(traderDataItem -> {
                sb.append(""Account created: "")
                        .append(FormattingUtils.formatDateTime(new Date(traderDataItem.getAccountAgeWitness().getDate()), true))
                        .append("" Account: "")
                        .append(traderDataItem.getPaymentAccountPayload().getPaymentDetails()).append(""\n"");
            });
        }
        log.info(sb.toString());
        Utilities.copyToClipboard(sb.toString());

        selectedPaymentAccountsList.setItems(FXCollections.observableArrayList(traderDataItemList));

        headLineLabel.setText(Res.get(""popup.accountSigning.confirmSelectedAccounts.headline""));
        descriptionLabel.setText(Res.get(""popup.accountSigning.confirmSelectedAccounts.description"",
                selectedPaymentAccountsList.getItems().size()));
        ((AutoTooltipButton) actionButton).updateText(Res.get(""popup.accountSigning.confirmSelectedAccounts.button""));

        updateAccountSelectionState();

        actionButton.setOnAction(e -> addAccountsToSignContent());

        selectedPaymentAccountsList.setCellFactory(new Callback<>() {
            @Override
            public ListCell<TraderDataItem> call(
                    ListView<TraderDataItem> param) {
                return new ListCell<>() {
                    @Override
                    protected void updateItem(TraderDataItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setText(item.getPaymentAccountPayload().getPaymentDetails());
                        } else {
                            setText(null);
                        }
                    }
                };
            }
        });
    }

    private void addAccountsToSignContent() {
        removeContent();
        addECKeyField();

        headLineLabel.setText(Res.get(""popup.accountSigning.signAccounts.headline""));
        descriptionLabel.setText(Res.get(""popup.accountSigning.signAccounts.description"", selectedPaymentAccountsList.getItems().size()));
        ((AutoTooltipButton) actionButton).updateText(Res.get(""popup.accountSigning.signAccounts.button""));
        actionButton.setOnAction(a -> {
            ECKey arbitratorKey = arbitratorManager.getRegistrationKey(privateKey.getText());
            if (arbitratorKey != null) {
                String arbitratorPubKeyAsHex = Utils.HEX.encode(arbitratorKey.getPubKey());
                boolean isKeyValid = arbitratorManager.isPublicKeyInList(arbitratorPubKeyAsHex);
                if (isKeyValid) {
                    selectedPaymentAccountsList.getItems().forEach(item ->
                            accountAgeWitnessService.arbitratorSignAccountAgeWitness(item.getTradeAmount(),
                                    item.getAccountAgeWitness(),
                                    arbitratorKey,
                                    item.getPeersPubKey()));
                    addSuccessContent();
                }
            } else {
                new Popup().error(Res.get(""popup.accountSigning.signAccounts.ECKey.error"")).onClose(this::hide).show();
            }

        });
    }

    private void addSuccessContent() {
        removeContent();
        GridPane.setVgrow(descriptionLabel, Priority.ALWAYS);
        GridPane.setValignment(descriptionLabel, VPos.TOP);

        closeButton.setVisible(false);
        closeButton.setManaged(false);
        headLineLabel.setText(Res.get(""popup.accountSigning.success.headline""));
        descriptionLabel.setText(Res.get(""popup.accountSigning.success.description"", selectedPaymentAccountsList.getItems().size()));
        ((AutoTooltipButton) actionButton).updateText(Res.get(""shared.ok""));
        actionButton.setOnAction(a -> hide());
    }

    @Override
    protected void addButtons() {

        Tuple2<Button, Button> buttonTuple = add2ButtonsAfterGroup(gridPane, ++rowIndex,
                Res.get(""popup.accountSigning.selectAccounts.headline""), Res.get(""shared.cancel""));

        actionButton = buttonTuple.first;
        actionButton.setDisable(true);
        actionButton.setOnAction(e -> addSelectedAccountsContent());

        closeButton = (AutoTooltipButton) buttonTuple.second;
        closeButton.setOnAction(e -> hide());

    }
}",0,64 2000 439 334 2001 378 2002 60 2001 62 123 437 2003 2004 59 437 2005 60 2006 62 2007 59 437 2008 2009 59 437 2010 2011 59 437 2012 2013 59 437 2014 60 2015 62 2016 61 418 2014 60 62 40 41 59 437 381 2017 2018 59 437 381 2019 2020 59 437 381 2021 2022 59 437 381 2023 2024 59 437 381 2025 2026 59 437 381 324 2027 59 64 2028 439 2001 40 2017 2018 44 2019 2020 44 2021 2022 44 2023 2024 44 64 2029 40 2030 46 2031 41 2025 2026 44 64 2029 40 2030 46 2032 41 324 2027 41 123 467 46 2018 61 2018 59 467 46 2020 61 2020 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2026 61 2026 59 467 46 2027 61 2027 59 125 64 2033 439 492 2034 40 41 123 2035 61 1504 59 2036 61 45 1501 59 2037 40 41 59 621 621 2038 46 2039 40 1504 41 59 2038 46 2040 40 41 46 2041 40 1501 41 46 2042 40 2043 46 2044 41 59 2045 40 2046 46 2041 40 648 41 41 59 2047 61 2048 46 2049 59 2050 40 41 59 2051 40 41 59 2052 40 41 59 2053 40 41 59 2054 40 41 59 125 437 492 2055 40 41 123 2004 61 2056 40 2057 44 637 2058 44 2059 46 2060 40 648 41 41 59 2007 61 2061 40 2057 44 637 2058 44 2059 46 2060 40 648 41 41 59 2007 46 2062 40 1503 41 59 2007 46 2063 40 418 2064 60 62 40 41 123 64 2033 439 2025 2065 40 2006 2066 41 123 450 2066 631 424 63 2059 46 2060 40 2066 46 2067 40 41 41 58 648 59 125 64 2033 439 2006 2068 40 2025 2069 41 123 450 424 59 125 125 41 59 2007 46 2070 40 2071 46 2072 40 2073 40 41 41 41 59 2007 46 2074 40 2075 45 62 2076 40 41 41 59 2009 61 2077 40 2057 44 637 2058 44 2059 46 2060 40 648 41 41 59 2078 46 2079 40 2009 44 2080 46 2081 41 59 2009 46 2082 40 41 46 2083 40 40 2084 44 2085 44 2086 41 45 62 123 2007 46 2087 40 2086 41 59 2076 40 41 59 125 41 59 2011 61 2088 40 2057 44 637 2058 44 2059 46 2060 40 648 41 44 1500 41 46 2089 59 2011 46 2074 40 2075 45 62 2076 40 41 41 59 2011 46 2090 40 2091 46 2092 40 418 2093 40 41 46 2094 40 41 41 46 2095 40 1503 44 2096 46 2097 41 46 2098 40 2099 46 2100 40 41 41 46 2101 40 41 41 59 125 437 2102 60 2006 62 2103 40 41 123 450 2006 46 2103 40 41 46 2104 40 41 46 2105 40 2006 58 58 2106 41 46 2105 40 2006 58 58 2107 41 46 2108 40 2109 46 2110 40 41 41 59 125 437 492 2111 40 41 123 2013 61 2112 40 2113 44 637 2114 44 2115 46 2116 40 648 41 41 59 2117 46 2118 40 2013 44 2119 46 2120 41 59 2117 46 2121 40 2013 44 2122 46 2123 41 59 125 437 492 2124 40 41 123 2125 46 2126 40 40 33 2009 46 2127 40 41 605 2007 46 2128 40 41 46 2129 40 41 41 606 2011 46 2130 40 41 614 424 41 59 125 437 492 2131 40 41 123 2132 40 2133 44 1502 44 1502 41 59 2134 61 1501 59 125 437 492 2135 40 41 123 2131 40 41 59 2136 60 2003 44 2014 60 2015 62 44 2137 62 2138 61 2139 40 2140 44 637 2141 44 2142 46 2143 40 648 41 41 59 2144 46 2145 40 2138 46 2146 44 1502 41 59 2016 61 2138 46 2147 59 2148 60 2149 62 2150 61 2027 63 2024 46 2151 40 41 58 2022 46 2151 40 41 59 413 2152 61 2011 46 2153 40 41 46 2154 40 41 46 2155 40 2156 46 2157 41 42 1504 59 2102 60 2015 62 2158 59 2159 2160 61 418 2159 40 648 41 46 2161 40 2026 41 46 2161 40 648 41 59 392 40 2009 46 2162 40 41 41 123 2158 61 418 2163 60 62 40 41 59 2103 40 41 46 2164 40 2165 45 62 123 2102 60 2015 62 411 61 2018 46 2166 40 2152 44 2165 44 2150 41 59 2158 46 2167 40 411 41 59 2160 46 2161 40 648 41 46 2161 40 2142 46 2143 40 2165 46 2168 40 41 41 41 46 2161 40 648 41 46 2161 40 411 46 2169 40 41 41 46 2161 40 648 41 59 411 46 2164 40 2170 45 62 123 2160 46 2161 40 648 41 46 2161 40 2171 46 2172 40 418 2173 40 2170 46 2174 40 41 46 2175 40 41 41 44 473 41 41 46 2161 40 648 41 46 2161 40 2170 46 2176 40 41 46 2177 40 41 41 46 2161 40 648 41 59 125 41 59 125 41 59 2160 46 2161 40 648 41 46 2161 40 2158 46 2178 40 41 41 59 125 360 123 2006 2179 61 2007 46 2180 40 41 46 2181 40 41 59 2158 61 2018 46 2182 40 2152 44 2179 44 2150 41 59 2160 46 2161 40 648 41 46 2161 40 2142 46 2143 40 2179 46 2183 40 41 41 41 46 2161 40 648 41 46 2161 40 2158 46 2184 40 41 41 46 2161 40 648 41 59 2158 46 2185 40 2186 45 62 123 2160 46 2161 40 648 41 46 2161 40 2187 46 2188 40 418 2189 40 2186 46 2190 40 41 46 2191 40 41 41 44 473 41 41 46 2161 40 648 41 46 2161 40 2186 46 2192 40 41 46 2193 40 41 41 46 2161 40 648 41 59 125 41 59 125 2194 46 2195 40 2160 46 2196 40 41 41 59 2197 46 2198 40 2160 46 2196 40 41 41 59 2016 46 2199 40 2200 46 2201 40 2158 41 41 59 2202 46 2203 40 2142 46 2143 40 648 41 41 59 2004 46 2203 40 2142 46 2143 40 648 44 2016 46 2204 40 41 46 2205 40 41 41 41 59 40 40 2206 41 2207 41 46 2208 40 2142 46 2143 40 648 41 41 59 2124 40 41 59 2207 46 2209 40 2210 45 62 2211 40 41 41 59 2016 46 2212 40 418 2213 60 62 40 41 123 64 2033 439 2214 60 2015 62 2215 40 2014 60 2015 62 2216 41 123 450 418 2214 60 62 40 41 123 64 2033 438 492 2217 40 2015 2218 44 324 362 41 123 463 46 2217 40 2218 44 362 41 59 392 40 2218 631 424 605 33 362 41 123 2203 40 2218 46 2219 40 41 46 2220 40 41 41 59 125 360 123 2203 40 424 41 59 125 125 125 59 125 125 41 59 125 437 492 2221 40 41 123 2131 40 41 59 2111 40 41 59 2222 46 2223 40 2224 46 2225 40 648 41 41 59 2004 46 2223 40 2224 46 2225 40 648 44 2016 46 2226 40 41 46 2227 40 41 41 41 59 40 40 2228 41 2229 41 46 2230 40 2224 46 2225 40 648 41 41 59 2229 46 2231 40 2232 45 62 123 2233 2234 61 2020 46 2235 40 2013 46 2236 40 41 41 59 392 40 2234 631 424 41 123 2025 2237 61 2238 46 2239 46 2240 40 2234 46 2241 40 41 41 59 324 2242 61 2020 46 2243 40 2237 41 59 392 40 2242 41 123 2016 46 2226 40 41 46 2244 40 2245 45 62 2018 46 2246 40 2245 46 2247 40 41 44 2245 46 2248 40 41 44 2234 44 2245 46 2249 40 41 41 41 59 2250 40 41 59 125 125 360 123 418 2251 40 41 46 371 40 2224 46 2225 40 648 41 41 46 2252 40 467 58 58 2253 41 46 2034 40 41 59 125 125 41 59 125 437 492 2254 40 41 123 2131 40 41 59 2255 46 2256 40 2004 44 2257 46 2258 41 59 2255 46 2259 40 2004 44 2260 46 2261 41 59 2262 46 2263 40 380 41 59 2262 46 2264 40 380 41 59 2265 46 2266 40 2267 46 2268 40 648 41 41 59 2004 46 2266 40 2267 46 2268 40 648 44 2016 46 2269 40 41 46 2270 40 41 41 41 59 40 40 2271 41 2272 41 46 2273 40 2267 46 2268 40 648 41 41 59 2272 46 2274 40 2275 45 62 2276 40 41 41 59 125 64 2033 438 492 2277 40 41 123 2278 60 2279 44 2279 62 2280 61 2281 40 2282 44 637 2283 44 2284 46 2285 40 648 41 44 2284 46 2285 40 648 41 41 59 2286 61 2280 46 2287 59 2286 46 2288 40 473 41 59 2286 46 2289 40 2290 45 62 2135 40 41 41 59 2291 61 40 2292 41 2280 46 2293 59 2291 46 2289 40 2290 45 62 2294 40 41 41 59 125 125 
27350,Java,"public final class InitialEquipmentData extends GameXmlReader {
    private static final Logger LOGGER = LoggerFactory.getLogger(InitialEquipmentData.class);
    private static final String NORMAL = ""data/stats/initialEquipment.xml"";
    private static final String EVENT = ""data/stats/initialEquipmentEvent.xml"";
    private final Map<ClassId, List<PcItemTemplate>> _initialEquipmentList = new EnumMap<>(ClassId.class);

    private InitialEquipmentData() {
        load();
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/initialEquipment.xsd"");
    }

    @Override
    public void load() {
        _initialEquipmentList.clear();
        parseDatapackFile(CharacterSettings.initialEquipEvent()  ? EVENT : NORMAL);
        LOGGER.info(""Loaded {} Initial Equipment data."", _initialEquipmentList.size());
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        for (Node n = doc.getFirstChild(); n != null; n = n.getNextSibling()) {
            if (""list"".equalsIgnoreCase(n.getNodeName())) {
                for (Node d = n.getFirstChild(); d != null; d = d.getNextSibling()) {
                    if (""equipment"".equalsIgnoreCase(d.getNodeName())) {
                        parseEquipment(d);
                    }
                }
            }
        }
    }

    /**
     * Parses the equipment.
     *
     * @param d parse an initial equipment and add it to {@link #_initialEquipmentList}
     */
    private void parseEquipment(Node d) {
        NamedNodeMap attrs = d.getAttributes();
        final ClassId classId = ClassId.getClassId(Integer.parseInt(attrs.getNamedItem(""classId"").getNodeValue()));
        final List<PcItemTemplate> equipList = new ArrayList<>();
        for (Node c = d.getFirstChild(); c != null; c = c.getNextSibling()) {
            if (""item"".equalsIgnoreCase(c.getNodeName())) {
                final StatsSet set = new StatsSet();
                attrs = c.getAttributes();
                for (int i = 0; i < attrs.getLength(); i++) {
                    final Node attr = attrs.item(i);
                    set.set(attr.getNodeName(), attr.getNodeValue());
                }
                equipList.add(new PcItemTemplate(set));
            }
        }
        _initialEquipmentList.put(classId, equipList);
    }

    /**
     * Gets the equipment list.
     *
     * @param cId the class Id for the required initial equipment.
     * @return the initial equipment for the given class Id.
     */
    public List<PcItemTemplate> getEquipmentList(ClassId cId) {
        return _initialEquipmentList.getOrDefault(cId, Collections.emptyList());
    }

    /**
     * Gets the equipment list.
     *
     * @param cId the class Id for the required initial equipment.
     * @return the initial equipment for the given class Id.
     */
    public List<PcItemTemplate> getEquipmentList(int cId) {
        return getEquipmentList(ClassId.getClassId(cId));
    }

    public static InitialEquipmentData getInstance() {
        return Singleton.INSTANCE;
    }
    private static class Singleton {
        protected static final InitialEquipmentData INSTANCE = new InitialEquipmentData();
    }
}",0,439 381 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 457 381 2006 2007 61 648 59 437 457 381 2006 2008 61 648 59 437 381 2009 60 2010 44 2011 60 2012 641 2013 61 418 2014 60 62 40 2010 46 334 41 59 437 2000 40 41 123 2015 40 41 59 125 64 2016 438 2017 2018 40 41 123 450 2019 46 2020 40 41 46 2021 40 648 41 59 125 64 2016 439 492 2022 40 41 123 2013 46 2023 40 41 59 2024 40 2025 46 2026 40 41 63 2008 58 2007 41 59 2003 46 2027 40 648 44 2013 46 2028 40 41 41 59 2029 40 41 59 125 64 2016 439 492 2030 40 2031 2032 44 2033 2034 41 123 385 40 2035 2036 61 2032 46 2037 40 41 59 2036 631 424 59 2036 61 2036 46 2038 40 41 41 123 392 40 648 46 2039 40 2036 46 2040 40 41 41 41 123 385 40 2035 2041 61 2036 46 2037 40 41 59 2041 631 424 59 2041 61 2041 46 2038 40 41 41 123 392 40 648 46 2039 40 2041 46 2040 40 41 41 41 123 2042 40 2041 41 59 125 125 125 125 125 618 437 492 2043 40 2044 2045 41 123 2046 2047 61 2045 46 2048 40 41 59 381 2010 2049 61 2010 46 2050 40 2051 46 2052 40 2047 46 2053 40 648 41 46 2054 40 41 41 41 59 381 2011 60 2012 62 2055 61 418 2056 60 62 40 41 59 385 40 2044 2057 61 2045 46 2058 40 41 59 2057 631 424 59 2057 61 2057 46 2059 40 41 41 123 392 40 648 46 2060 40 2057 46 2061 40 41 41 41 123 381 2062 2063 61 418 2062 40 41 59 2047 61 2057 46 2048 40 41 59 385 40 404 2064 61 1500 59 2064 60 2047 46 2065 40 41 59 2064 637 41 123 381 2044 2066 61 2047 46 2067 40 2064 41 59 2063 46 2063 40 2066 46 2061 40 41 44 2066 46 2054 40 41 41 59 125 2055 46 2068 40 418 2012 40 2063 41 41 59 125 125 2013 46 2069 40 2049 44 2055 41 59 125 618 439 2011 60 2012 62 2070 40 2010 2071 41 123 450 2013 46 2072 40 2071 44 2073 46 2074 40 41 41 59 125 618 439 2011 60 2012 62 2070 40 404 2071 41 123 450 2070 40 2010 46 2075 40 2071 41 41 59 125 439 457 2000 2076 40 41 123 450 2077 46 2078 59 125 437 457 334 2079 123 438 457 381 2000 2080 61 418 2000 40 41 59 125 125 
5330,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    AutoTooltipLabel autoTooltipLabel = new AutoTooltipLabel(model.getPriceDeviation(item));
                                    autoTooltipLabel.setOpacity(item.getOffer().isUseMarketBasedPrice() ? 1 : 0.4);
                                    setGraphic(autoTooltipLabel);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 2015 61 418 2014 40 2011 46 2016 40 2008 41 41 59 2015 46 2017 40 2008 46 2018 40 41 46 2019 40 41 63 1501 58 1499 41 59 2020 40 2015 41 59 125 360 123 2021 40 424 41 59 125 125 125 59 125 125 41 59 
5341,Java,"                        return new TableCell<>() {
                            private HyperlinkWithIcon field;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    field = new HyperlinkWithIcon(model.getOfferId(item));
                                    field.setOnAction(event -> {
                                        if (item.getOffer().isBsqSwapOffer()) {
                                            bsqSwapOfferDetailsWindow.show(item.getOffer());
                                        } else {
                                            offerDetailsWindow.show(item.getOffer());
                                        }
                                    });

                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                    setGraphic(field);
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 2002 61 418 2001 40 2007 46 2008 40 2006 41 41 59 2002 46 2009 40 373 45 62 123 392 40 2006 46 2010 40 41 46 2011 40 41 41 123 2012 46 2013 40 2006 46 2010 40 41 41 59 125 360 123 2014 46 2015 40 2006 46 2010 40 41 41 59 125 125 41 59 2002 46 2016 40 418 2017 40 2018 46 2019 40 648 41 41 41 59 2020 40 2002 41 59 125 360 123 2021 40 424 41 59 392 40 2002 631 424 41 2002 46 2022 40 424 41 59 125 125 125 59 
5338,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
32926,Java,"                        new ThrowableAssert.ThrowingCallable() {
                            public void call() {
                                mock.add("""");
                            }
                        })",0,418 2000 46 2001 40 41 123 439 492 2002 40 41 123 2003 46 2004 40 648 41 59 125 125 41 
5250,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);

                                if (!empty && newItem != null) {
                                    Trade trade = newItem.getTrade();
                                    String id = trade.getId();

                                    // We use maps for each trade to avoid multiple listener registrations when
                                    // switching views. With current implementation we avoid that but we do not
                                    // remove listeners when a trade is removed (completed) but that has no consequences
                                    // as we will not receive any message anyway from a closed trade. Supporting it
                                    // more correctly would require more effort and managing listener deactivation at
                                    // screen switches (currently we get the update called if we have selected another
                                    // view.
                                    Button button;
                                    if (!buttonByTrade.containsKey(id)) {
                                        button = FormBuilder.getIconButton(MaterialDesignIcon.COMMENT_MULTIPLE_OUTLINE);
                                        buttonByTrade.put(id, button);
                                        button.setTooltip(new Tooltip(Res.get(""tradeChat.openChat"")));
                                    } else {
                                        button = buttonByTrade.get(id);
                                    }

                                    JFXBadge badge;
                                    if (!badgeByTrade.containsKey(id)) {
                                        badge = new JFXBadge(button);
                                        badgeByTrade.put(id, badge);
                                        badge.setPosition(Pos.TOP_RIGHT);
                                    } else {
                                        badge = badgeByTrade.get(id);
                                    }

                                    button.setOnAction(e -> {
                                        tableView.getSelectionModel().select(this.getIndex());
                                        openChat(trade);
                                    });

                                    if (!listenerByTrade.containsKey(id)) {
                                        ListChangeListener<ChatMessage> listener = c -> updateChatMessageCount(trade, badge);
                                        listenerByTrade.put(id, listener);
                                        trade.getChatMessages().addListener(listener);
                                    }

                                    updateChatMessageCount(trade, badge);

                                    setGraphic(badge);
                                } else {
                                    setGraphic(null);
                                }
                            }

                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 33 362 605 2004 631 424 41 123 2005 2006 61 2004 46 2007 40 41 59 2008 2009 61 2006 46 2010 40 41 59 621 621 621 621 621 621 621 2011 2012 59 392 40 33 2013 46 2014 40 2009 41 41 123 2012 61 2015 46 2016 40 2017 46 2018 41 59 2013 46 2019 40 2009 44 2012 41 59 2012 46 2020 40 418 2021 40 2022 46 2023 40 648 41 41 41 59 125 360 123 2012 61 2013 46 2024 40 2009 41 59 125 2025 2026 59 392 40 33 2027 46 2014 40 2009 41 41 123 2026 61 418 2025 40 2012 41 59 2027 46 2028 40 2009 44 2026 41 59 2026 46 2029 40 2030 46 2031 41 59 125 360 123 2026 61 2027 46 2032 40 2009 41 59 125 2012 46 2033 40 2034 45 62 123 2035 46 2036 40 41 46 2037 40 467 46 2038 40 41 41 59 2039 40 2006 41 59 125 41 59 392 40 33 2040 46 2014 40 2009 41 41 123 2041 60 2042 62 2043 61 2044 45 62 2045 40 2006 44 2026 41 59 2040 46 2046 40 2009 44 2043 41 59 2006 46 2047 40 41 46 2048 40 2043 41 59 125 2049 40 2006 44 2026 41 59 2050 40 2026 41 59 125 360 123 2051 40 424 41 59 125 125 125 59 
5335,Java,"                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = getRegularIconButton(MaterialDesignIcon.CONTENT_COPY);
                                        button.setTooltip(new Tooltip(Res.get(""shared.duplicateOffer"")));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(event -> onDuplicateOffer(item.getOffer()));
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 2001 2002 59 64 2003 439 492 2004 40 381 2005 2006 44 324 362 41 123 463 46 2004 40 2006 44 362 41 59 392 40 2006 631 424 605 33 362 41 123 392 40 2002 614 424 41 123 2002 61 2007 40 2008 46 2009 41 59 2002 46 2010 40 418 2011 40 2012 46 2013 40 648 41 41 41 59 2014 40 2002 41 59 125 2002 46 2015 40 373 45 62 2016 40 2006 46 2017 40 41 41 41 59 125 360 123 2018 40 424 41 59 392 40 2002 631 424 41 123 2002 46 2019 40 424 41 59 2002 61 424 59 125 125 125 125 59 
3297,Java,"                        return new TableCell<>() {

                            @Override
                            public void updateItem(final VoteListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setText(DisplayUtils.formatDateTime(item.getBlindVoteDate()));
                                } else {
                                    setText("""");
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2006 46 2007 40 2004 46 2008 40 41 41 41 59 125 360 123 2009 40 648 41 59 125 125 125 59 
5263,Java,"                new Callback<>() {

                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem,
                            PendingTradesListItem> column) {
                        return new TableCell<>() {
                            private Trade trade;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    trade = item.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    setGraphic(null);
                                    if (trade != null && listener != null) {
                                        trade.stateProperty().removeListener(listener);
                                        trade = null;
                                        listener = null;
                                    }
                                }
                            }

                            private void update() {
                                HyperlinkWithIcon field;
                                if (trade == null) return;

                                if (isMaybeInvalidTrade(trade)) {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setIcon(FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE));
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.invalidTradeState.warning"")));
                                    if (trade.isTxChainInvalid()) {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }
                                } else {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                }
                                setGraphic(field);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 437 2007 2008 59 437 2009 60 2007 46 2010 62 2011 59 64 2001 439 492 2012 40 381 2003 2013 44 324 362 41 123 463 46 2012 40 2013 44 362 41 59 392 40 2013 631 424 605 33 362 41 123 2008 61 2013 46 2014 40 41 59 2011 61 40 2015 44 2016 44 2017 41 45 62 2018 40 41 59 2008 46 2019 40 41 46 2020 40 2011 41 59 2018 40 41 59 125 360 123 2021 40 424 41 59 392 40 2008 631 424 605 2011 631 424 41 123 2008 46 2022 40 41 46 2023 40 2011 41 59 2008 61 424 59 2011 61 424 59 125 125 125 437 492 2024 40 41 123 2025 2026 59 392 40 2008 614 424 41 450 59 392 40 2027 40 2008 41 41 123 2026 61 418 2025 40 2008 46 2028 40 41 41 59 2026 46 2029 40 2030 46 2031 40 2032 46 2033 41 41 59 2026 46 2034 40 373 45 62 2035 46 2036 40 2008 41 41 59 2026 46 2037 40 418 2038 40 2039 46 2040 40 648 41 41 41 59 392 40 2008 46 2041 40 41 41 123 2026 46 2042 40 41 46 2043 40 41 46 2044 40 648 44 648 41 59 125 360 123 2026 46 2045 40 41 46 2046 40 41 46 2047 40 648 44 648 41 59 125 125 360 123 2026 61 418 2025 40 2008 46 2048 40 41 41 59 2026 46 2049 40 373 45 62 2050 46 2051 40 2008 41 41 59 2026 46 2052 40 418 2053 40 2054 46 2055 40 648 41 41 41 59 125 2056 40 2026 41 59 125 125 59 125 125 41 59 
29406,Java,"	public static final class Val {
		private static final String BLOCK_SCOPE_SIG = ""org.eclipse.jdt.internal.compiler.lookup.BlockScope"";
		private static final String LOCAL_DECLARATION_SIG = ""org.eclipse.jdt.internal.compiler.ast.LocalDeclaration"";
		private static final String FOREACH_STATEMENT_SIG = ""org.eclipse.jdt.internal.compiler.ast.ForeachStatement"";
		
		private static final Method HANDLE_VAL_FOR_LOCAL_DECLARATION;
		private static final Method HANDLE_VAL_FOR_FOR_EACH;
		
		static {
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.agent.PatchVal"");
			HANDLE_VAL_FOR_LOCAL_DECLARATION = Util.findMethod(shadowed, ""handleValForLocalDeclaration"", LOCAL_DECLARATION_SIG, BLOCK_SCOPE_SIG);
			HANDLE_VAL_FOR_FOR_EACH = Util.findMethod(shadowed, ""handleValForForEach"", FOREACH_STATEMENT_SIG, BLOCK_SCOPE_SIG);
		}
		
		public static boolean handleValForLocalDeclaration(Object local, Object scope) {
			return (Boolean) Util.invokeMethod(HANDLE_VAL_FOR_LOCAL_DECLARATION, local, scope);
		}
		
		public static boolean handleValForForEach(Object forEach, Object scope) {
			return (Boolean) Util.invokeMethod(HANDLE_VAL_FOR_FOR_EACH, forEach, scope);
		}
		
		/** 
		 * Patches local declaration to not call .resolveType() on the initializer expression if we've already done so (calling it twice causes weird errors) 
		 * This and the next method must be transplanted so that the return type is loaded in the correct class loader
		 */
		public static TypeBinding skipResolveInitializerIfAlreadyCalled(Expression expr, BlockScope scope) {
			if (expr.resolvedType != null) return expr.resolvedType;
			try {
				return expr.resolveType(scope);
			} catch (NullPointerException e) {
				return null;
			} catch (ArrayIndexOutOfBoundsException e) {
				// This will occur internally due to for example 'val x = mth(""X"");', where mth takes 2 arguments.
				return null;
			}
		}
		
		public static TypeBinding skipResolveInitializerIfAlreadyCalled2(Expression expr, BlockScope scope, LocalDeclaration decl) {
			if (decl != null && LocalDeclaration.class.equals(decl.getClass()) && expr.resolvedType != null) return expr.resolvedType;
			try {
				return expr.resolveType(scope);
			} catch (NullPointerException e) {
				return null;
			} catch (ArrayIndexOutOfBoundsException e) {
				// This will occur internally due to for example 'val x = mth(""X"");', where mth takes 2 arguments.
				return null;
			}
		}
	}",0,439 457 381 334 2000 123 437 457 381 2001 2002 61 648 59 437 457 381 2001 2003 61 648 59 437 457 381 2001 2004 61 648 59 437 457 381 2005 2006 59 437 457 381 2005 2007 59 457 123 2008 60 63 62 2009 61 2010 46 2011 40 648 41 59 2006 61 2010 46 2012 40 2009 44 648 44 2003 44 2002 41 59 2007 61 2010 46 2012 40 2009 44 648 44 2004 44 2002 41 59 125 439 457 324 2013 40 2014 2015 44 2014 2016 41 123 450 40 2017 41 2018 46 2019 40 2006 44 2015 44 2016 41 59 125 439 457 324 2020 40 2014 2021 44 2014 2016 41 123 450 40 2022 41 2023 46 2024 40 2007 44 2021 44 2016 41 59 125 618 439 457 2025 2026 40 2027 2028 44 2029 2016 41 123 392 40 2028 46 2030 631 424 41 450 2028 46 2030 59 474 123 450 2028 46 2031 40 2016 41 59 125 329 40 2032 2033 41 123 450 424 59 125 329 40 2034 2033 41 123 621 450 424 59 125 125 439 457 2025 2035 40 2027 2028 44 2029 2016 44 2036 2037 41 123 392 40 2037 631 424 605 2036 46 334 46 2038 40 2037 46 2039 40 41 41 605 2028 46 2040 631 424 41 450 2028 46 2040 59 474 123 450 2028 46 2041 40 2016 41 59 125 329 40 2042 2043 41 123 450 424 59 125 329 40 2044 2043 41 123 621 450 424 59 125 125 125 
5265,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    try {
                                        String volume = VolumeUtil.formatVolumeWithCode(item.getTrade().getVolume());
                                        setGraphic(new AutoTooltipLabel(volume));
                                    } catch (Throwable ignore) {
                                        log.debug(ignore.toString()); // Stupidity to make Codacy happy
                                    }
                                } else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 123 474 123 2009 2010 61 2011 46 2012 40 2008 46 2013 40 41 46 2014 40 41 41 59 2015 40 418 2016 40 2010 41 41 59 125 329 40 2017 2018 41 123 2019 46 2020 40 2018 46 2021 40 41 41 59 621 125 125 360 2022 40 424 41 59 125 125 59 125 125 41 59 
30697,Java,"	public static class Child extends Parent {
		private String foo;

		@java.lang.SuppressWarnings(""all"")
		private static String $default$foo() {
			return doSth(Arrays.asList(1), Arrays.asList('a'));
		}


		@java.lang.SuppressWarnings(""all"")
		public static abstract class ChildBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Child, B extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
			@java.lang.SuppressWarnings(""all"")
			private boolean foo$set;
			@java.lang.SuppressWarnings(""all"")
			private String foo$value;

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected abstract B self();

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public abstract C build();

			/**
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings(""all"")
			public B foo(final String foo) {
				this.foo$value = foo;
				foo$set = true;
				return self();
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public java.lang.String toString() {
				return ""SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder(super="" + super.toString() + "", foo$value="" + this.foo$value + "")"";
			}
		}


		@java.lang.SuppressWarnings(""all"")
		private static final class ChildBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<SuperBuilderWithDefaultsAndTargetTyping.Child, SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl> {
			@java.lang.SuppressWarnings(""all"")
			private ChildBuilderImpl() {
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			protected SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl self() {
				return this;
			}

			@java.lang.Override
			@java.lang.SuppressWarnings(""all"")
			public SuperBuilderWithDefaultsAndTargetTyping.Child build() {
				return new SuperBuilderWithDefaultsAndTargetTyping.Child(this);
			}
		}

		@java.lang.SuppressWarnings(""all"")
		protected Child(final SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> b) {
			super(b);
			if (b.foo$set) this.foo = b.foo$value;
			 else this.foo = SuperBuilderWithDefaultsAndTargetTyping.Child.$default$foo();
		}

		@java.lang.SuppressWarnings(""all"")
		public static SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<?, ?> builder() {
			return new SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl();
		}
	}",0,439 457 334 2000 378 2001 123 437 2002 2003 59 64 2004 46 2005 46 2006 40 648 41 437 457 2002 36 349 36 2003 40 41 123 450 2007 40 2008 46 2009 40 1501 41 44 2008 46 2009 40 607 41 41 59 125 64 2004 46 2005 46 2006 40 648 41 439 457 305 334 2010 60 2011 378 2012 46 2000 44 2013 378 2012 46 2000 46 2010 60 2011 44 2013 641 378 2001 46 2014 60 2011 44 2013 62 123 64 2004 46 2005 46 2006 40 648 41 437 324 2003 36 2015 59 64 2004 46 2005 46 2006 40 648 41 437 2002 2003 36 2016 59 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 438 305 2013 2018 40 41 59 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 439 305 2011 2019 40 41 59 618 64 2004 46 2005 46 2006 40 648 41 439 2013 2003 40 381 2002 2003 41 123 467 46 2003 36 2016 61 2003 59 2003 36 2015 61 473 59 450 2018 40 41 59 125 64 2004 46 2005 46 2017 64 2004 46 2005 46 2006 40 648 41 439 2004 46 2005 46 2002 2020 40 41 123 450 648 43 463 46 2020 40 41 43 648 43 467 46 2003 36 2016 43 648 59 125 125 64 2004 46 2005 46 2006 40 648 41 437 457 381 334 2021 378 2012 46 2000 46 2010 60 2012 46 2000 44 2012 46 2000 46 2021 62 123 64 2004 46 2005 46 2006 40 648 41 437 2021 40 41 123 125 64 2004 46 2005 46 2022 64 2004 46 2005 46 2006 40 648 41 438 2012 46 2000 46 2021 2023 40 41 123 450 467 59 125 64 2004 46 2005 46 2022 64 2004 46 2005 46 2006 40 648 41 439 2012 46 2000 2024 40 41 123 450 418 2012 46 2000 40 467 41 59 125 125 64 2004 46 2005 46 2006 40 648 41 438 2000 40 381 2012 46 2000 46 2010 60 63 44 63 62 2025 41 123 463 40 2025 41 59 392 40 2025 46 2003 36 2026 41 467 46 2003 61 2025 46 2003 36 2027 59 360 467 46 2003 61 2012 46 2000 46 36 349 36 2003 40 41 59 125 64 2004 46 2005 46 2006 40 648 41 439 457 2012 46 2000 46 2010 60 63 44 63 62 2028 40 41 123 450 418 2012 46 2000 46 2021 40 41 59 125 125 
30746,Java,"class BuilderNestedInEnum {
  public enum TestEnum {
    public static final @lombok.Builder @lombok.Value class TestBuilder {
      public static @java.lang.SuppressWarnings(""all"") class TestBuilderBuilder {
        private @java.lang.SuppressWarnings(""all"") String field;
        @java.lang.SuppressWarnings(""all"") TestBuilderBuilder() {
          super();
        }
        /**
         * @return {@code this}.
         */
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder field(final String field) {
          this.field = field;
          return this;
        }
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder build() {
          return new BuilderNestedInEnum.TestEnum.TestBuilder(this.field);
        }
        public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
          return ((""BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder(field="" + this.field) + "")"");
        }
      }
      private final String field;
      @java.lang.SuppressWarnings(""all"") TestBuilder(final String field) {
        super();
        this.field = field;
      }
      public static @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder builder() {
        return new BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder();
      }
      public @java.lang.SuppressWarnings(""all"") String getField() {
        return this.field;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") boolean equals(final java.lang.Object o) {
        if ((o == this))
            return true;
        if ((! (o instanceof BuilderNestedInEnum.TestEnum.TestBuilder)))
            return false;
        final BuilderNestedInEnum.TestEnum.TestBuilder other = (BuilderNestedInEnum.TestEnum.TestBuilder) o;
        final java.lang.Object this$field = this.getField();
        final java.lang.Object other$field = other.getField();
        if (((this$field == null) ? (other$field != null) : (! this$field.equals(other$field))))
            return false;
        return true;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final java.lang.Object $field = this.getField();
        result = ((result * PRIME) + (($field == null) ? 43 : $field.hashCode()));
        return result;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""BuilderNestedInEnum.TestEnum.TestBuilder(field="" + this.getField()) + "")"");
      }
    }
    FOO(),
    BAR(),
    <clinit>() {
    }
    public TestEnum() {
      super();
    }
  }",0,334 2000 123 439 370 2001 123 439 457 381 64 2002 46 2003 64 2002 46 2004 334 2005 123 439 457 64 2006 46 2007 46 2008 40 648 41 334 2009 123 437 64 2006 46 2007 46 2008 40 648 41 2010 2011 59 64 2006 46 2007 46 2008 40 648 41 2009 40 41 123 463 40 41 59 125 618 439 64 2006 46 2007 46 2008 40 648 41 2000 46 2001 46 2005 46 2009 2011 40 381 2010 2011 41 123 467 46 2011 61 2011 59 450 467 59 125 439 64 2006 46 2007 46 2008 40 648 41 2000 46 2001 46 2005 2012 40 41 123 450 418 2000 46 2001 46 2005 40 467 46 2011 41 59 125 439 64 2006 46 2007 46 2013 64 2006 46 2007 46 2008 40 648 41 2006 46 2007 46 2010 2014 40 41 123 450 40 40 648 43 467 46 2011 41 43 648 41 59 125 125 437 381 2015 2016 59 64 2006 46 2007 46 2008 40 648 41 2005 40 381 2015 2016 41 123 463 40 41 59 467 46 2016 61 2016 59 125 439 457 64 2006 46 2007 46 2008 40 648 41 2000 46 2001 46 2005 46 2009 2017 40 41 123 450 418 2000 46 2001 46 2005 46 2009 40 41 59 125 439 64 2006 46 2007 46 2008 40 648 41 2015 2018 40 41 123 450 467 46 2016 59 125 439 64 2006 46 2007 46 2019 64 2006 46 2007 46 2008 40 648 41 324 2020 40 381 2006 46 2007 46 2021 2022 41 123 392 40 40 2022 614 467 41 41 450 473 59 392 40 40 33 40 2022 402 2000 46 2001 46 2005 41 41 41 450 380 59 381 2000 46 2001 46 2005 2023 61 40 2000 46 2001 46 2005 41 2022 59 381 2006 46 2007 46 2021 467 36 2016 61 467 46 2018 40 41 59 381 2006 46 2007 46 2021 2023 36 2016 61 2023 46 2018 40 41 59 392 40 40 40 467 36 2016 614 424 41 63 40 2023 36 2016 631 424 41 58 40 33 467 36 2016 46 2020 40 2023 36 2016 41 41 41 41 450 380 59 450 473 59 125 439 64 2006 46 2007 46 2019 64 2006 46 2007 46 2008 40 648 41 404 2024 40 41 123 381 404 2025 61 1503 59 404 2026 61 1501 59 381 2006 46 2007 46 2021 36 2016 61 467 46 2018 40 41 59 2026 61 40 40 2026 42 2025 41 43 40 40 36 2016 614 424 41 63 1503 58 36 2016 46 2024 40 41 41 41 59 450 2026 59 125 439 64 2006 46 2007 46 2019 64 2006 46 2007 46 2008 40 648 41 2006 46 2007 46 2015 2027 40 41 123 450 40 40 648 43 467 46 2018 40 41 41 43 648 41 59 125 125 2028 40 41 44 2029 40 41 44 60 2030 62 40 41 123 125 439 2001 40 41 123 463 40 41 59 125 125 
5245,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(formatter.formatCoin(item.getTrade().getAmount())));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 2008 631 424 605 33 362 41 2009 40 418 2010 40 2011 46 2012 40 2008 46 2013 40 41 46 2014 40 41 41 41 41 59 360 2009 40 424 41 59 125 125 59 125 125 41 59 
27181,Java,"public class EnchantItemOptionsData extends GameXmlReader {

    private static final Logger LOGGER = LoggerFactory.getLogger(EnchantItemOptionsData.class);

    private final IntMap<IntMap<EnchantOptions>> data = new HashIntMap<>();

    private EnchantItemOptionsData() {
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/xsd/EnchantItemOptions.xsd"");
    }

    @Override
    public synchronized void load() {
        data.clear();
        parseDatapackFile(""data/EnchantItemOptions.xml"");
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", list -> forEach(list, ""item"", itemNode -> forEach(itemNode, ""options"", optionsNode -> {
                var attr = optionsNode.getAttributes();
                var option = new EnchantOptions(parseInt(attr, ""level""));
                for (byte i = 0; i < 3 ; i++) {
                    option.setOption(i, parseInt(attr, ""option"" + (i+1)));
                }
                data.computeIfAbsent(parseInt(itemNode.getAttributes(), ""id""), id -> new HashIntMap<>()).put(option.getLevel(), option);
            })
        ));
        LOGGER.info(""Loaded {} Option Items."", data.size());
    }

    /**
     * @param itemId
     * @param enchantLevel
     * @return enchant effects information.
     */
    public EnchantOptions getOptions(int itemId, int enchantLevel) {
        if (!data.containsKey(itemId) || !data.get(itemId).containsKey(enchantLevel)) {
            return null;
        }
        return data.get(itemId).get(enchantLevel);
    }

    /**
     * @param item
     * @return enchant effects information.
     */
    public EnchantOptions getOptions(Item item) {
        return computeIfNonNull(item, i -> getOptions(i.getId(), i.getEnchantLevel()));
    }

    public static void init() {
        getInstance().load();
    }

    public static EnchantItemOptionsData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        protected static final EnchantItemOptionsData INSTANCE = new EnchantItemOptionsData();
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2006 60 2007 641 2008 61 418 2009 60 62 40 41 59 437 2000 40 41 123 125 64 2010 438 2011 2012 40 41 123 450 2013 46 2014 40 41 46 2015 40 648 41 59 125 64 2010 439 465 492 2016 40 41 123 2008 46 2017 40 41 59 2018 40 648 41 59 2019 40 41 59 125 64 2010 439 492 2020 40 2021 2022 44 2023 2024 41 123 2025 40 2022 44 648 44 411 45 62 2025 40 411 44 648 44 2026 45 62 2025 40 2026 44 648 44 2027 45 62 123 490 2028 61 2027 46 2029 40 41 59 490 2030 61 418 2007 40 2031 40 2028 44 648 41 41 59 385 40 326 2032 61 1500 59 2032 60 1502 59 2032 637 41 123 2030 46 2033 40 2032 44 2031 40 2028 44 648 43 40 2032 43 1501 41 41 41 59 125 2008 46 2034 40 2031 40 2026 46 2029 40 41 44 648 41 44 2035 45 62 418 2009 60 62 40 41 41 46 2036 40 2030 46 2037 40 41 44 2030 41 59 125 41 41 41 59 2003 46 2038 40 648 44 2008 46 2039 40 41 41 59 125 618 439 2007 2040 40 404 2041 44 404 2042 41 123 392 40 33 2008 46 2043 40 2041 41 606 33 2008 46 2044 40 2041 41 46 2043 40 2042 41 41 123 450 424 59 125 450 2008 46 2044 40 2041 41 46 2044 40 2042 41 59 125 618 439 2007 2040 40 2045 2046 41 123 450 2047 40 2046 44 2048 45 62 2040 40 2048 46 2049 40 41 44 2048 46 2050 40 41 41 41 59 125 439 457 492 2051 40 41 123 2052 40 41 46 2016 40 41 59 125 439 457 2000 2053 40 41 123 450 2054 46 2055 59 125 437 457 334 2056 123 438 457 381 2000 2057 61 418 2000 40 41 59 125 125 
5253,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 418 2010 40 2011 46 2012 40 2008 41 41 41 59 125 125 59 125 125 41 59 
5353,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getVolume(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5325,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getAmount(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 40 418 2011 40 2007 46 2012 40 2004 41 41 41 59 125 360 123 2013 40 424 41 59 125 125 125 59 
5264,Java,"                        return new TableCell<>() {
                            private Trade trade;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    trade = item.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    setGraphic(null);
                                    if (trade != null && listener != null) {
                                        trade.stateProperty().removeListener(listener);
                                        trade = null;
                                        listener = null;
                                    }
                                }
                            }

                            private void update() {
                                HyperlinkWithIcon field;
                                if (trade == null) return;

                                if (isMaybeInvalidTrade(trade)) {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setIcon(FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE));
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.invalidTradeState.warning"")));
                                    if (trade.isTxChainInvalid()) {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }
                                } else {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                }
                                setGraphic(field);
                            }
                        };",0,450 418 2000 60 62 40 41 123 437 2001 2002 59 437 2003 60 2001 46 2004 62 2005 59 64 2006 439 492 2007 40 381 2008 2009 44 324 362 41 123 463 46 2007 40 2009 44 362 41 59 392 40 2009 631 424 605 33 362 41 123 2002 61 2009 46 2010 40 41 59 2005 61 40 2011 44 2012 44 2013 41 45 62 2014 40 41 59 2002 46 2015 40 41 46 2016 40 2005 41 59 2014 40 41 59 125 360 123 2017 40 424 41 59 392 40 2002 631 424 605 2005 631 424 41 123 2002 46 2018 40 41 46 2019 40 2005 41 59 2002 61 424 59 2005 61 424 59 125 125 125 437 492 2020 40 41 123 2021 2022 59 392 40 2002 614 424 41 450 59 392 40 2023 40 2002 41 41 123 2022 61 418 2021 40 2002 46 2024 40 41 41 59 2022 46 2025 40 2026 46 2027 40 2028 46 2029 41 41 59 2022 46 2030 40 373 45 62 2031 46 2032 40 2002 41 41 59 2022 46 2033 40 418 2034 40 2035 46 2036 40 648 41 41 41 59 392 40 2002 46 2037 40 41 41 123 2022 46 2038 40 41 46 2039 40 41 46 2040 40 648 44 648 41 59 125 360 123 2022 46 2041 40 41 46 2042 40 41 46 2043 40 648 44 648 41 59 125 125 360 123 2022 61 418 2021 40 2002 46 2044 40 41 41 59 2022 46 2045 40 373 45 62 2046 46 2047 40 2002 41 41 59 2022 46 2048 40 418 2049 40 2050 46 2051 40 648 41 41 41 59 125 2052 40 2022 41 59 125 125 59 
30943,Java,"    public static abstract @java.lang.SuppressWarnings(""all"") class ParentBuilder<C extends SuperBuilderWithDefaultsAndTargetTyping.Parent, B extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<C, B>> {
      private @java.lang.SuppressWarnings(""all"") String foo$value;
      private @java.lang.SuppressWarnings(""all"") boolean foo$set;
      public ParentBuilder() {
        super();
      }
      protected abstract @java.lang.SuppressWarnings(""all"") B self();
      public abstract @java.lang.SuppressWarnings(""all"") C build();
      /**
       * @return {@code this}.
       */
      public @java.lang.SuppressWarnings(""all"") B foo(final String foo) {
        this.foo$value = foo;
        foo$set = true;
        return self();
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder(foo$value="" + this.foo$value) + "")"");
      }
    }",0,439 457 305 64 2000 46 2001 46 2002 40 648 41 334 2003 60 2004 378 2005 46 2006 44 2007 378 2005 46 2006 46 2003 60 2004 44 2007 641 123 437 64 2000 46 2001 46 2002 40 648 41 2008 2009 36 2010 59 437 64 2000 46 2001 46 2002 40 648 41 324 2009 36 2011 59 439 2003 40 41 123 463 40 41 59 125 438 305 64 2000 46 2001 46 2002 40 648 41 2007 2012 40 41 59 439 305 64 2000 46 2001 46 2002 40 648 41 2004 2013 40 41 59 618 439 64 2000 46 2001 46 2002 40 648 41 2007 2009 40 381 2008 2009 41 123 467 46 2009 36 2010 61 2009 59 2009 36 2011 61 473 59 450 2012 40 41 59 125 439 64 2000 46 2001 46 2014 64 2000 46 2001 46 2002 40 648 41 2000 46 2001 46 2008 2015 40 41 123 450 40 40 648 43 467 46 2009 36 2010 41 43 648 41 59 125 125 
5336,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (item.getOffer().isBsqSwapOffer()) {
                                        if (button != null) {
                                            button.setOnAction(null);
                                            button = null;
                                        }
                                        if (item.getOpenOffer().isBsqSwapOfferHasMissingFunds()) {
                                            Label label = new Label();
                                            Text icon = getRegularIconForLabel(MaterialDesignIcon.EYE_OFF, label);
                                            Tooltip.install(icon, new Tooltip(Res.get(""openOffer.bsqSwap.missingFunds"")));
                                            setGraphic(icon);
                                        } else {
                                            setGraphic(null);
                                        }
                                    } else {
                                        if (button == null) {
                                            button = getRegularIconButton(MaterialDesignIcon.PENCIL);
                                            button.setTooltip(new Tooltip(Res.get(""shared.editOffer"")));
                                            button.setOnAction(event -> onEditOpenOffer(item.getOpenOffer()));
                                            setGraphic(button);
                                        }
                                    }
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2010 46 2011 40 41 46 2012 40 41 41 123 392 40 2008 631 424 41 123 2008 46 2013 40 424 41 59 2008 61 424 59 125 392 40 2010 46 2014 40 41 46 2015 40 41 41 123 2016 2017 61 418 2016 40 41 59 2018 2019 61 2020 40 2021 46 2022 44 2017 41 59 2023 46 2024 40 2019 44 418 2023 40 2025 46 2026 40 648 41 41 41 59 2027 40 2019 41 59 125 360 123 2028 40 424 41 59 125 125 360 123 392 40 2008 614 424 41 123 2008 61 2029 40 2030 46 2031 41 59 2008 46 2032 40 418 2033 40 2034 46 2035 40 648 41 41 41 59 2008 46 2036 40 373 45 62 2037 40 2010 46 2038 40 41 41 41 59 2039 40 2008 41 59 125 125 125 360 123 2040 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2041 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
26672,Java,"public class TeleportersData extends GameXmlReader {

    private static final Logger LOGGER = LoggerFactory.getLogger(TeleportersData.class);
    private final IntMap<Map<String, TeleportHolder>> teleporters = new HashIntMap<>();

    private TeleportersData() {
        load();
    }

    @Override
    protected Path getSchemaFilePath() {
        return ServerSettings.dataPackDirectory().resolve(""data/teleporters/teleporterData.xsd"");
    }

    @Override
    public void load() {
        teleporters.clear();
        parseDatapackDirectory(""data/teleporters"", true);
        LOGGER.info(""Loaded: {} npc teleporters."", teleporters.size());
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        forEach(doc, ""list"", list -> forEach(list, ""npc"", npc -> {

            final var teleportList = new HashMap<String, TeleportHolder>();
            final int npcId = parseInt(npc.getAttributes(), ""id"");

            forEach(npc, node -> {
                switch (node.getNodeName()) {
                    case ""teleport"" -> parseTeleport(teleportList, npcId, node);
                    case ""npcs"" -> parseNpcs(teleportList, node);
                }
            });

            registerTeleportList(npcId, teleportList);
        }));
    }

    private void parseNpcs(final HashMap<String, TeleportHolder> teleportList, Node node) {
        forEach(node, ""npc"", npcNode -> registerTeleportList(parseInt(npcNode.getAttributes(), ""id""), teleportList));
    }

    private void parseTeleport(HashMap<String, TeleportHolder> teleportList, int npcId, Node node) {
        final NamedNodeMap nodeAttrs = node.getAttributes();

        final TeleportType type = parseEnum(nodeAttrs, TeleportType.class, ""type"");
        final String name = parseString(nodeAttrs, ""name"", type.name());

        final TeleportHolder holder = new TeleportHolder(name, type);
        forEach(node, ""location"", location -> holder.registerLocation(new StatsSet(parseAttributes(location))));

        if (nonNull(teleportList.putIfAbsent(name, holder))) {
            LOGGER.warn(""Duplicate teleport list ({}) has been found for NPC: {}"", name, npcId);
        }
    }

    /**
     * Register teleport data to global teleport list holder. Also show warning when any duplicate occurs.
     *
     * @param npcId    template id of teleporter
     * @param teleList teleport data to register
     */
    private void registerTeleportList(int npcId, Map<String, TeleportHolder> teleList) {
        teleporters.put(npcId, teleList);
    }

    /**
     * Gets teleport data for specified NPC and list name
     *
     * @param npcId    template id of teleporter
     * @param listName name of teleport list
     * @return {@link TeleportHolder} if found otherwise {@code null}
     */
    public TeleportHolder getHolder(int npcId, String listName) {
        return teleporters.getOrDefault(npcId, Collections.emptyMap()).get(listName);
    }

    public static TeleportersData getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final TeleportersData INSTANCE = new TeleportersData();
    }
}",0,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 60 2007 60 2008 44 2009 641 2010 61 418 2011 60 62 40 41 59 437 2000 40 41 123 2012 40 41 59 125 64 2013 438 2014 2015 40 41 123 450 2016 46 2017 40 41 46 2018 40 648 41 59 125 64 2013 439 492 2019 40 41 123 2010 46 2020 40 41 59 2021 40 648 44 473 41 59 2003 46 2022 40 648 44 2010 46 2023 40 41 41 59 2024 40 41 59 125 64 2013 439 492 2025 40 2026 2027 44 2028 2029 41 123 2030 40 2027 44 648 44 411 45 62 2030 40 411 44 648 44 2031 45 62 123 381 490 2032 61 418 2033 60 2008 44 2009 62 40 41 59 381 404 2034 61 2035 40 2031 46 2036 40 41 44 648 41 59 2030 40 2031 44 2037 45 62 123 464 40 2037 46 2038 40 41 41 123 328 648 45 62 2039 40 2032 44 2034 44 2037 41 59 328 648 45 62 2040 40 2032 44 2037 41 59 125 125 41 59 2041 40 2034 44 2032 41 59 125 41 41 59 125 437 492 2042 40 381 2043 60 2008 44 2009 62 2044 44 2045 2046 41 123 2047 40 2046 44 648 44 2048 45 62 2049 40 2050 40 2048 46 2051 40 41 44 648 41 44 2044 41 41 59 125 437 492 2052 40 2043 60 2008 44 2009 62 2044 44 404 2053 44 2045 2046 41 123 381 2054 2055 61 2046 46 2056 40 41 59 381 2057 2058 61 2059 40 2055 44 2057 46 334 44 648 41 59 381 2008 2060 61 2061 40 2055 44 648 44 2058 46 2060 40 41 41 59 381 2009 2062 61 418 2009 40 2060 44 2058 41 59 2063 40 2046 44 648 44 2064 45 62 2062 46 2065 40 418 2066 40 2067 40 2064 41 41 41 41 59 392 40 2068 40 2044 46 2069 40 2060 44 2062 41 41 41 123 2003 46 2070 40 648 44 2060 44 2053 41 59 125 125 618 437 492 2071 40 404 2053 44 2007 60 2008 44 2009 62 2072 41 123 2010 46 2073 40 2053 44 2072 41 59 125 618 439 2009 2074 40 404 2053 44 2008 2075 41 123 450 2010 46 2076 40 2053 44 2077 46 2078 40 41 41 46 2079 40 2075 41 59 125 439 457 2000 2080 40 41 123 450 2081 46 2082 59 125 437 457 334 2083 123 437 457 381 2000 2084 61 418 2000 40 41 59 125 125 
29952,Java,"	public static class ValidateTypesProcessor extends TreeProcessor {
		@Override void processCompilationUnit(final JCCompilationUnit unit) {
			final Stack<JCTree> parents = new Stack<JCTree>();
			parents.add(unit);
			
			unit.accept(new TreeScanner() {
				private JCTree parent;
				@Override public void scan(JCTree tree) {
					parent = parents.peek();
					
					parents.push(tree);
					super.scan(tree);
					parents.pop();
				}
				
				@Override public void visitClassDef(JCClassDecl tree) {
					// Skip anonymous or local classes, they have no symbol
					if (!(parent instanceof JCClassDecl || parent instanceof JCCompilationUnit)) return;
					
					validateSymbol(tree, tree.sym);
					super.visitClassDef(tree);
				};

				@Override public void visitMethodDef(JCMethodDecl tree) {
					validateSymbol(tree, tree.sym);
					super.visitMethodDef(tree);
				}
				
				@Override public void visitVarDef(JCVariableDecl tree) {
					// Skip local variables
					if (!(parent instanceof JCClassDecl || parent instanceof JCMethodDecl)) return;
					
					validateSymbol(tree, tree.sym);
					super.visitVarDef(tree);
				}
				
				private void validateSymbol(JCTree tree, Symbol sym) {
					if (sym == null) {
						fail(""Missing symbol for "" + tree);
					}
					// Only classes have enclosed elements, skip everything else
					if (!sym.owner.getKind().isClass()) return;
					
					if (!sym.owner.getEnclosedElements().contains(sym)) {
						fail(tree + "" not added to parent"");
					}
				}
			});
		}
	}",0,439 457 334 2000 378 2001 123 64 2002 492 2003 40 381 2004 2005 41 123 381 2006 60 2007 62 2008 61 418 2006 60 2007 62 40 41 59 2008 46 2009 40 2005 41 59 2005 46 2010 40 418 2011 40 41 123 437 2007 2012 59 64 2002 439 492 2013 40 2007 2014 41 123 2012 61 2008 46 2015 40 41 59 2008 46 2016 40 2014 41 59 463 46 2013 40 2014 41 59 2008 46 2017 40 41 59 125 64 2002 439 492 2018 40 2019 2014 41 123 621 392 40 33 40 2012 402 2019 606 2012 402 2004 41 41 450 59 2020 40 2014 44 2014 46 2021 41 59 463 46 2018 40 2014 41 59 125 59 64 2002 439 492 2022 40 2023 2014 41 123 2024 40 2014 44 2014 46 2025 41 59 463 46 2022 40 2014 41 59 125 64 2002 439 492 2026 40 2027 2014 41 123 621 392 40 33 40 2012 402 2019 606 2012 402 2023 41 41 450 59 2028 40 2014 44 2014 46 2029 41 59 463 46 2026 40 2014 41 59 125 437 492 2030 40 2007 2014 44 2031 2032 41 123 392 40 2032 614 424 41 123 2033 40 648 43 2014 41 59 125 621 392 40 33 2032 46 2034 46 2035 40 41 46 2036 40 41 41 450 59 392 40 33 2032 46 2034 46 2037 40 41 46 2038 40 2032 41 41 123 2039 40 2014 43 648 41 59 125 125 125 41 59 125 125 
30833,Java,"		WITH {
			@Override public String apply(final EclipseNode node) {
				return addReturnsUpdatedSelfIfNeeded(applySetter(node, ""WITH|WITHER""));
			}
		},",0,2000 123 64 2001 439 2002 2003 40 381 2004 2005 41 123 450 2006 40 2007 40 2005 44 648 41 41 59 125 125 44 
47127,Java,"        new Thread(""TermSessionInputReader[pid="" + mShellPid + ""]"") {
            @Override
            public void run() {
                try (InputStream termIn = new FileInputStream(terminalFileDescriptorWrapped)) {
                    final byte[] buffer = new byte[4096];
                    while (true) {
                        int read = termIn.read(buffer);
                        if (read == -1) return;
                        if (!mProcessToTerminalIOQueue.write(buffer, 0, read)) return;
                        mMainThreadHandler.sendEmptyMessage(MSG_NEW_INPUT);
                    }
                } catch (Exception e) {
                    // Ignore, just shutting down.
                }
            }
        }.start();",0,418 2000 40 648 43 2001 43 648 41 123 64 2002 439 492 2003 40 41 123 474 40 2004 2005 61 418 2006 40 2007 41 41 123 381 326 91 93 2008 61 418 326 91 1505 93 59 496 40 473 41 123 404 2009 61 2005 46 2009 40 2008 41 59 392 40 2009 614 45 1501 41 450 59 392 40 33 2010 46 2011 40 2008 44 1500 44 2009 41 41 450 59 2012 46 2013 40 2014 41 59 125 125 329 40 2015 2016 41 123 621 125 125 125 46 2017 40 41 59 
29402,Java,"	public static final class LombokDeps {
		public static final Method ADD_LOMBOK_NOTES;
		public static final Method POST_COMPILER_BYTES_STRING;
		public static final Method POST_COMPILER_OUTPUTSTREAM;
		public static final Method POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING;
		
		static {
			Class<?> shadowed = Util.shadowLoadClass(""lombok.eclipse.agent.PatchFixesShadowLoaded"");
			ADD_LOMBOK_NOTES = Util.findMethod(shadowed, ""addLombokNotesToEclipseAboutDialog"", String.class, String.class);
			POST_COMPILER_BYTES_STRING = Util.findMethod(shadowed, ""runPostCompiler"", byte[].class, String.class);
			POST_COMPILER_OUTPUTSTREAM = Util.findMethod(shadowed, ""runPostCompiler"", OutputStream.class);
			POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING = Util.findMethod(shadowed, ""runPostCompiler"", BufferedOutputStream.class, String.class, String.class);
		}
		
		public static String addLombokNotesToEclipseAboutDialog(String origReturnValue, String key) {
			try {
				return (String) Util.invokeMethod(LombokDeps.ADD_LOMBOK_NOTES, origReturnValue, key);
			} catch (Throwable t) {
				return origReturnValue;
			}
		}
		
		public static byte[] runPostCompiler(byte[] bytes, String fileName) {
			return (byte[]) Util.invokeMethod(LombokDeps.POST_COMPILER_BYTES_STRING, bytes, fileName);
		}
		
		public static OutputStream runPostCompiler(OutputStream out) throws IOException {
			return (OutputStream) Util.invokeMethod(LombokDeps.POST_COMPILER_OUTPUTSTREAM, out);
		}
		
		public static BufferedOutputStream runPostCompiler(BufferedOutputStream out, String path, String name) throws IOException {
			return (BufferedOutputStream) Util.invokeMethod(LombokDeps.POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING, out, path, name);
		}
	}",0,439 457 381 334 2000 123 439 457 381 2001 2002 59 439 457 381 2001 2003 59 439 457 381 2001 2004 59 439 457 381 2001 2005 59 457 123 2006 60 63 62 2007 61 2008 46 2009 40 648 41 59 2002 61 2008 46 2010 40 2007 44 648 44 2011 46 334 44 2011 46 334 41 59 2003 61 2008 46 2010 40 2007 44 648 44 326 91 93 46 334 44 2011 46 334 41 59 2004 61 2008 46 2010 40 2007 44 648 44 2012 46 334 41 59 2005 61 2008 46 2010 40 2007 44 648 44 2013 46 334 44 2011 46 334 44 2011 46 334 41 59 125 439 457 2014 2015 40 2014 2016 44 2014 2017 41 123 474 123 450 40 2014 41 2018 46 2019 40 2000 46 2002 44 2016 44 2017 41 59 125 329 40 2020 2021 41 123 450 2016 59 125 125 439 457 326 91 93 2022 40 326 91 93 2023 44 2014 2024 41 123 450 40 326 91 93 41 2025 46 2026 40 2000 46 2003 44 2023 44 2024 41 59 125 439 457 2027 2022 40 2027 430 41 470 2028 123 450 40 2027 41 2029 46 2030 40 2000 46 2004 44 430 41 59 125 439 457 2031 2022 40 2031 430 44 2014 2032 44 2014 2033 41 470 2028 123 450 40 2031 41 2034 46 2035 40 2000 46 2005 44 430 44 2032 44 2033 41 59 125 125 
47128,Java,"        new Thread(""TermSessionOutputWriter[pid="" + mShellPid + ""]"") {
            @Override
            public void run() {
                final byte[] buffer = new byte[4096];
                try (FileOutputStream termOut = new FileOutputStream(terminalFileDescriptorWrapped)) {
                    while (true) {
                        int bytesToWrite = mTerminalToProcessIOQueue.read(buffer, true);
                        if (bytesToWrite == -1) return;
                        termOut.write(buffer, 0, bytesToWrite);
                    }
                } catch (IOException e) {
                    // Ignore.
                }
            }
        }.start();",0,418 2000 40 648 43 2001 43 648 41 123 64 2002 439 492 2003 40 41 123 381 326 91 93 2004 61 418 326 91 1505 93 59 474 40 2005 2006 61 418 2005 40 2007 41 41 123 496 40 473 41 123 404 2008 61 2009 46 2010 40 2004 44 473 41 59 392 40 2008 614 45 1501 41 450 59 2006 46 2011 40 2004 44 1500 44 2008 41 59 125 125 329 40 2012 2013 41 123 621 125 125 125 46 2014 40 41 59 
30944,Java,"    private static final @java.lang.SuppressWarnings(""all"") class ParentBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilder<SuperBuilderWithDefaultsAndTargetTyping.Parent, SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl> {
      private ParentBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent.ParentBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Parent build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Parent(this);
      }
    }",0,437 457 381 64 2000 46 2001 46 2002 40 648 41 334 2003 378 2004 46 2005 46 2006 60 2004 46 2005 44 2004 46 2005 46 2003 62 123 437 2003 40 41 123 463 40 41 59 125 438 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 2004 46 2005 46 2003 2008 40 41 123 450 467 59 125 439 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 2004 46 2005 2009 40 41 123 450 418 2004 46 2005 40 467 41 59 125 125 
30818,Java,"	@Provides
	public static class HandleJulLog extends JavacAnnotationHandler<lombok.extern.java.Log> {
		@Override public void handle(AnnotationValues<lombok.extern.java.Log> annotation, JCAnnotation ast, JavacNode annotationNode) {
			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_JUL_FLAG_USAGE, ""@java.Log"", ConfigurationKeys.LOG_ANY_FLAG_USAGE, ""any @Log"");
			processAnnotation(LoggingFramework.JUL, annotation, annotationNode);
		}
	}",0,64 2000 439 457 334 2001 378 2002 60 2003 46 379 46 2004 46 2005 62 123 64 2006 439 492 2007 40 2008 60 2003 46 379 46 2004 46 2005 62 2009 44 2010 2011 44 2012 2013 41 123 2014 40 2013 44 2015 46 2016 44 648 44 2015 46 2017 44 648 41 59 2018 40 2019 46 2020 44 2009 44 2013 41 59 125 125 
30745,Java,"    public static final @lombok.Builder @lombok.Value class TestBuilder {
      public static @java.lang.SuppressWarnings(""all"") class TestBuilderBuilder {
        private @java.lang.SuppressWarnings(""all"") String field;
        @java.lang.SuppressWarnings(""all"") TestBuilderBuilder() {
          super();
        }
        /**
         * @return {@code this}.
         */
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder field(final String field) {
          this.field = field;
          return this;
        }
        public @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder build() {
          return new BuilderNestedInEnum.TestEnum.TestBuilder(this.field);
        }
        public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
          return ((""BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder(field="" + this.field) + "")"");
        }
      }
      private final String field;
      @java.lang.SuppressWarnings(""all"") TestBuilder(final String field) {
        super();
        this.field = field;
      }
      public static @java.lang.SuppressWarnings(""all"") BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder builder() {
        return new BuilderNestedInEnum.TestEnum.TestBuilder.TestBuilderBuilder();
      }
      public @java.lang.SuppressWarnings(""all"") String getField() {
        return this.field;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") boolean equals(final java.lang.Object o) {
        if ((o == this))
            return true;
        if ((! (o instanceof BuilderNestedInEnum.TestEnum.TestBuilder)))
            return false;
        final BuilderNestedInEnum.TestEnum.TestBuilder other = (BuilderNestedInEnum.TestEnum.TestBuilder) o;
        final java.lang.Object this$field = this.getField();
        final java.lang.Object other$field = other.getField();
        if (((this$field == null) ? (other$field != null) : (! this$field.equals(other$field))))
            return false;
        return true;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final java.lang.Object $field = this.getField();
        result = ((result * PRIME) + (($field == null) ? 43 : $field.hashCode()));
        return result;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") java.lang.String toString() {
        return ((""BuilderNestedInEnum.TestEnum.TestBuilder(field="" + this.getField()) + "")"");
      }
    }",0,439 457 381 64 2000 46 2001 64 2000 46 2002 334 2003 123 439 457 64 2004 46 2005 46 2006 40 648 41 334 2007 123 437 64 2004 46 2005 46 2006 40 648 41 2008 2009 59 64 2004 46 2005 46 2006 40 648 41 2007 40 41 123 463 40 41 59 125 618 439 64 2004 46 2005 46 2006 40 648 41 2010 46 2011 46 2003 46 2007 2009 40 381 2008 2009 41 123 467 46 2009 61 2009 59 450 467 59 125 439 64 2004 46 2005 46 2006 40 648 41 2010 46 2011 46 2003 2012 40 41 123 450 418 2010 46 2011 46 2003 40 467 46 2009 41 59 125 439 64 2004 46 2005 46 2013 64 2004 46 2005 46 2006 40 648 41 2004 46 2005 46 2008 2014 40 41 123 450 40 40 648 43 467 46 2009 41 43 648 41 59 125 125 437 381 2015 2016 59 64 2004 46 2005 46 2006 40 648 41 2003 40 381 2015 2016 41 123 463 40 41 59 467 46 2016 61 2016 59 125 439 457 64 2004 46 2005 46 2006 40 648 41 2017 46 2018 46 2003 46 2007 2019 40 41 123 450 418 2017 46 2018 46 2003 46 2007 40 41 59 125 439 64 2004 46 2005 46 2006 40 648 41 2015 2020 40 41 123 450 467 46 2016 59 125 439 64 2004 46 2005 46 2021 64 2004 46 2005 46 2006 40 648 41 324 2022 40 381 2004 46 2005 46 2023 2024 41 123 392 40 40 2024 614 467 41 41 450 473 59 392 40 40 33 40 2024 402 2017 46 2018 46 2003 41 41 41 450 380 59 381 2017 46 2018 46 2003 2025 61 40 2017 46 2018 46 2003 41 2024 59 381 2004 46 2005 46 2023 467 36 2016 61 467 46 2020 40 41 59 381 2004 46 2005 46 2023 2025 36 2016 61 2025 46 2020 40 41 59 392 40 40 40 467 36 2016 614 424 41 63 40 2025 36 2016 631 424 41 58 40 33 467 36 2016 46 2022 40 2025 36 2016 41 41 41 41 450 380 59 450 473 59 125 439 64 2004 46 2005 46 2021 64 2004 46 2005 46 2006 40 648 41 404 2026 40 41 123 381 404 2027 61 1503 59 404 2028 61 1501 59 381 2004 46 2005 46 2023 36 2016 61 467 46 2020 40 41 59 2028 61 40 40 2028 42 2027 41 43 40 40 36 2016 614 424 41 63 1503 58 36 2016 46 2026 40 41 41 41 59 450 2028 59 125 439 64 2004 46 2005 46 2021 64 2004 46 2005 46 2006 40 648 41 2004 46 2005 46 2015 2029 40 41 123 450 40 40 648 43 467 46 2020 40 41 41 43 648 41 59 125 125 
5346,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = getRegularIconButton(MaterialDesignIcon.DELETE_FOREVER, ""delete"");
                                        button.setTooltip(new Tooltip(Res.get(""shared.removeOffer"")));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(event -> onRemoveOpenOffer(item.getOpenOffer()));
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 2007 2008 59 64 2001 439 492 2009 40 381 2003 2010 44 324 362 41 123 463 46 2009 40 2010 44 362 41 59 392 40 2010 631 424 605 33 362 41 123 392 40 2008 614 424 41 123 2008 61 2011 40 2012 46 2013 44 648 41 59 2008 46 2014 40 418 2015 40 2016 46 2017 40 648 41 41 41 59 2018 40 2008 41 59 125 2008 46 2019 40 373 45 62 2020 40 2010 46 2021 40 41 41 41 59 125 360 123 2022 40 424 41 59 392 40 2008 631 424 41 123 2008 46 2023 40 424 41 59 2008 61 424 59 125 125 125 125 59 125 125 41 59 
3444,Java,"                return new ListCell<>() {
                    @Override
                    protected void updateItem(TraderDataItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setText(item.getPaymentAccountPayload().getPaymentDetails());
                        } else {
                            setText(null);
                        }
                    }
                };",0,450 418 2000 60 62 40 41 123 64 2001 438 492 2002 40 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2004 46 2006 40 41 46 2007 40 41 41 59 125 360 123 2008 40 424 41 59 125 125 125 59 
5331,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    AutoTooltipLabel autoTooltipLabel = new AutoTooltipLabel(model.getPriceDeviation(item));
                                    autoTooltipLabel.setOpacity(item.getOffer().isUseMarketBasedPrice() ? 1 : 0.4);
                                    setGraphic(autoTooltipLabel);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 2005 40 41 46 2006 40 648 41 59 392 40 2004 631 424 41 123 392 40 2007 46 2008 40 2004 41 41 2005 40 41 46 2009 40 648 41 59 2010 2011 61 418 2010 40 2007 46 2012 40 2004 41 41 59 2011 46 2013 40 2004 46 2014 40 41 46 2015 40 41 63 1501 58 1499 41 59 2016 40 2011 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 
29398,Java,"	public static abstract class TestParams {
		public abstract Compiler getCompiler();
		public abstract boolean printErrors();
		public abstract File getBeforeDirectory();
		public abstract File getAfterDirectory();
		public abstract File getMessagesDirectory();
		/** Version of the JDK dialect that the compiler can understand; for example, if you return '7', you should know what try-with-resources is. */
		public int getVersion() {
			return getCompiler().getVersion();
		}
		
		public boolean accept(File file) {
			return true;
		}
		
		public abstract boolean expectChanges();
		public String testNamePrefix() {
			return """";
		}
	}",0,439 457 305 334 2000 123 439 305 2001 2002 40 41 59 439 305 324 2003 40 41 59 439 305 2004 2005 40 41 59 439 305 2004 2006 40 41 59 439 305 2004 2007 40 41 59 618 439 404 2008 40 41 123 450 2002 40 41 46 2008 40 41 59 125 439 324 2009 40 2004 2010 41 123 450 473 59 125 439 305 324 2011 40 41 59 439 2012 2013 40 41 123 450 648 59 125 125 
4064,Java,"public class ClosedTradesViewModel extends ActivatableWithDataModel<ClosedTradesDataModel> implements ViewModel {
    private final ClosedTradableFormatter closedTradableFormatter;

    @Inject
    public ClosedTradesViewModel(ClosedTradesDataModel dataModel, ClosedTradableFormatter closedTradableFormatter) {
        super(dataModel);

        this.closedTradableFormatter = closedTradableFormatter;
    }

    String getTradeId(Tradable item) {
        return item.getShortId();
    }

    String getAmount(Tradable item) {
        return item != null ? closedTradableFormatter.getAmountAsString(item) : """";
    }

    String getPrice(Tradable item) {
        return item != null ? closedTradableFormatter.getPriceAsString(item) : """";
    }

    String getPriceDeviation(Tradable item) {
        return item != null ? closedTradableFormatter.getPriceDeviationAsString(item) : """";
    }

    String getVolume(Tradable item, boolean appendCode) {
        return item != null ? closedTradableFormatter.getVolumeAsString(item, appendCode) : """";
    }

    String getVolumeCurrency(Tradable item) {
        return item != null ? closedTradableFormatter.getVolumeCurrencyAsString(item) : """";
    }

    String getTxFee(Tradable item) {
        return item != null ? closedTradableFormatter.getTxFeeAsString(item) : """";
    }

    String getTradeFee(Tradable item, boolean appendCode) {
        return item != null ? closedTradableFormatter.getTradeFeeAsString(item, appendCode) : """";
    }

    String getBuyerSecurityDeposit(Tradable item) {
        return item != null ? closedTradableFormatter.getBuyerSecurityDepositAsString(item) : """";
    }

    String getSellerSecurityDeposit(Tradable item) {
        return item != null ? closedTradableFormatter.getSellerSecurityDepositAsString(item) : """";
    }

    String getDirectionLabel(Tradable item) {
        if ((item != null)) {
            OfferDirection direction = dataModel.getDirection(item.getOffer());
            String currencyCode = item.getOffer().getCurrencyCode();
            return DisplayUtils.getDirectionWithCode(direction, currencyCode);
        } else {
            return """";
        }
    }

    String getDate(Tradable item) {
        return DisplayUtils.formatDateTime(item.getDate());
    }

    String getMarketLabel(Tradable item) {
        return item != null ? CurrencyUtil.getCurrencyPair(item.getOffer().getCurrencyCode()) : """";
    }

    String getState(Tradable item) {
        return item != null ? closedTradableFormatter.getStateAsString(item) : """";
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Used in ClosedTradesSummaryWindow
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Coin getTotalTradeAmount() {
        return dataModel.getTotalAmount();
    }

    public String getTotalAmountWithVolume(Coin totalTradeAmount) {
        return dataModel.getVolumeInUserFiatCurrency(totalTradeAmount)
                .map(volume -> closedTradableFormatter.getTotalAmountWithVolumeAsString(totalTradeAmount, volume))
                .orElse("""");
    }

    public Map<String, String> getTotalVolumeByCurrency() {
        return closedTradableFormatter.getTotalVolumeByCurrencyAsString(dataModel.getList());
    }

    public String getTotalTxFee(Coin totalTradeAmount) {
        Coin totalTxFee = dataModel.getTotalTxFee();
        return closedTradableFormatter.getTotalTxFeeAsString(totalTradeAmount, totalTxFee);
    }

    public String getTotalTradeFeeInBtc(Coin totalTradeAmount) {
        Coin totalTradeFee = dataModel.getTotalTradeFee(true);
        return closedTradableFormatter.getTotalTradeFeeInBtcAsString(totalTradeAmount, totalTradeFee);
    }

    public String getTotalTradeFeeInBsq(Coin totalTradeAmount) {
        return dataModel.getVolume(totalTradeAmount, ""USD"")
                .filter(v -> v.getValue() > 0)
                .map(tradeAmountVolume -> {
                    Coin totalTradeFee = dataModel.getTotalTradeFee(false);
                    Volume bsqVolumeInUsd = dataModel.getBsqVolumeInUsdWithAveragePrice(totalTradeFee); // with 4 decimal
                    return closedTradableFormatter.getTotalTradeFeeInBsqAsString(totalTradeFee,
                            tradeAmountVolume,
                            bsqVolumeInUsd);
                })
                .orElse("""");
    }
}",0,439 334 2000 378 2001 60 2002 62 395 2003 123 437 381 2004 2005 59 64 2006 439 2000 40 2002 2007 44 2004 2005 41 123 463 40 2007 41 59 467 46 2005 61 2005 59 125 2008 2009 40 2010 2011 41 123 450 2011 46 2012 40 41 59 125 2008 2013 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2014 40 2011 41 58 648 59 125 2008 2015 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2016 40 2011 41 58 648 59 125 2008 2017 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2018 40 2011 41 58 648 59 125 2008 2019 40 2010 2011 44 324 2020 41 123 450 2011 631 424 63 2005 46 2021 40 2011 44 2020 41 58 648 59 125 2008 2022 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2023 40 2011 41 58 648 59 125 2008 2024 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2025 40 2011 41 58 648 59 125 2008 2026 40 2010 2011 44 324 2020 41 123 450 2011 631 424 63 2005 46 2027 40 2011 44 2020 41 58 648 59 125 2008 2028 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2029 40 2011 41 58 648 59 125 2008 2030 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2031 40 2011 41 58 648 59 125 2008 2032 40 2010 2011 41 123 392 40 40 2011 631 424 41 41 123 2033 2034 61 2007 46 2035 40 2011 46 2036 40 41 41 59 2008 2037 61 2011 46 2036 40 41 46 2038 40 41 59 450 2039 46 2040 40 2034 44 2037 41 59 125 360 123 450 648 59 125 125 2008 2041 40 2010 2011 41 123 450 2042 46 2043 40 2011 46 2041 40 41 41 59 125 2008 2044 40 2010 2011 41 123 450 2011 631 424 63 2045 46 2046 40 2011 46 2047 40 41 46 2048 40 41 41 58 648 59 125 2008 2049 40 2010 2011 41 123 450 2011 631 424 63 2005 46 2050 40 2011 41 58 648 59 125 621 621 621 439 2051 2052 40 41 123 450 2007 46 2053 40 41 59 125 439 2008 2054 40 2051 2055 41 123 450 2007 46 2056 40 2055 41 46 2057 40 2058 45 62 2005 46 2059 40 2055 44 2058 41 41 46 2060 40 648 41 59 125 439 2061 60 2008 44 2008 62 2062 40 41 123 450 2005 46 2063 40 2007 46 2064 40 41 41 59 125 439 2008 2065 40 2051 2055 41 123 2051 2066 61 2007 46 2065 40 41 59 450 2005 46 2067 40 2055 44 2066 41 59 125 439 2008 2068 40 2051 2055 41 123 2051 2069 61 2007 46 2070 40 473 41 59 450 2005 46 2071 40 2055 44 2069 41 59 125 439 2008 2072 40 2051 2055 41 123 450 2007 46 2019 40 2055 44 648 41 46 2073 40 2074 45 62 2074 46 2075 40 41 62 1500 41 46 2076 40 2077 45 62 123 2051 2078 61 2007 46 2079 40 380 41 59 2080 2081 61 2007 46 2082 40 2078 41 59 621 450 2005 46 2083 40 2078 44 2077 44 2081 41 59 125 41 46 2084 40 648 41 59 125 125 
32265,Java,"    public static class SenseI implements LInstruction{
        public int from, to, type;

        public SenseI(int from, int to, int type){
            this.from = from;
            this.to = to;
            this.type = type;
        }

        public SenseI(){
        }

        @Override
        public void run(LExecutor exec){
            Object target = exec.obj(from);
            Object sense = exec.obj(type);

            if(target == null && sense == LAccess.dead){
                exec.setnum(to, 1);
                return;
            }

            //note that remote units/buildings can be sensed as well
            if(target instanceof Senseable se){
                if(sense instanceof Content co){
                    exec.setnum(to, se.sense(co));
                }else if(sense instanceof LAccess la){
                    Object objOut = se.senseObject(la);

                    if(objOut == Senseable.noSensed){
                        //numeric output
                        exec.setnum(to, se.sense(la));
                    }else{
                        //object output
                        exec.setobj(to, objOut);
                    }
                }
            }else{
                exec.setobj(to, null);
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 404 388 44 2002 44 2003 59 439 2000 40 404 388 44 404 2002 44 404 2003 41 123 467 46 388 61 388 59 467 46 2002 61 2002 59 467 46 2003 61 2003 59 125 439 2000 40 41 123 125 64 2004 439 492 2005 40 2006 2007 41 123 2008 2009 61 2007 46 2010 40 388 41 59 2008 2011 61 2007 46 2010 40 2003 41 59 392 40 2009 614 424 605 2011 614 2012 46 2013 41 123 2007 46 2014 40 2002 44 1501 41 59 450 59 125 621 392 40 2009 402 2015 2016 41 123 392 40 2011 402 2017 2018 41 123 2007 46 2019 40 2002 44 2016 46 2011 40 2018 41 41 59 125 360 392 40 2011 402 2012 2020 41 123 2008 2021 61 2016 46 2022 40 2020 41 59 392 40 2021 614 2015 46 2023 41 123 621 2007 46 2024 40 2002 44 2016 46 2011 40 2020 41 41 59 125 360 123 621 2007 46 2025 40 2002 44 2021 41 59 125 125 125 360 123 2007 46 2026 40 2002 44 424 41 59 125 125 125 
5350,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");
                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getTriggerPrice(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
30924,Java,"class ExtensionMethodFunctional {
	public void test() {
		String test = ""test"";
		test = ExtensionMethodFunctional.Extensions.map(test, s -> ExtensionMethodFunctional.Extensions.reverse(s));
		ExtensionMethodFunctional.Extensions.consume(test, s -> System.out.println(""1: "" + s), s -> System.out.println(""2: "" + s));
		ExtensionMethodFunctional.Extensions.consume(test, System.out::println, System.out::println);
		ExtensionMethodFunctional.Extensions.toList1(Stream.of(""a"", ""b"", ""c"").map(String::toUpperCase));
		List<Integer> i2 = ExtensionMethodFunctional.Extensions.toList2(Stream.of(""a"", ""b"", ""c"").map(String::toUpperCase));
	}

	static class Extensions {
		public static <T, R> R map(T value, Function<T, R> mapper) {
			return mapper.apply(value);
		}

		public static String reverse(String string) {
			return new StringBuilder(string).reverse().toString();
		}

		@SafeVarargs
		public static <T> void consume(T o, Consumer<T>... consumer) {
			for (int i = 0; i < consumer.length; i++) {
				consumer[i].accept(o);
			}
		}
		
		public static <T> List<T> toList1(Stream<T> stream) {
			return (List<T>) stream.collect(Collectors.toList());
		}

		public static <T, U> List<U> toList2(Stream<T> stream) {
			return null;
		}
	}
}",0,334 2000 123 439 492 2001 40 41 123 2002 2001 61 648 59 2001 61 2000 46 2003 46 2004 40 2001 44 2005 45 62 2000 46 2003 46 2006 40 2005 41 41 59 2000 46 2003 46 2007 40 2001 44 2005 45 62 2008 46 430 46 2009 40 648 43 2005 41 44 2005 45 62 2008 46 430 46 2009 40 648 43 2005 41 41 59 2000 46 2003 46 2007 40 2001 44 2008 46 430 58 58 2009 44 2008 46 430 58 58 2009 41 59 2000 46 2003 46 2010 40 2011 46 2012 40 648 44 648 44 648 41 46 2004 40 2002 58 58 2013 41 41 59 2014 60 2015 62 2016 61 2000 46 2003 46 2017 40 2011 46 2012 40 648 44 648 44 648 41 46 2004 40 2002 58 58 2013 41 41 59 125 457 334 2018 123 439 457 60 2019 44 2020 62 2020 2021 40 2019 2022 44 2023 60 2019 44 2020 62 2024 41 123 450 2024 46 2025 40 2022 41 59 125 439 457 2026 2027 40 2026 461 41 123 450 418 2028 40 461 41 46 2027 40 41 46 2029 40 41 59 125 64 2030 439 457 60 2019 62 492 2031 40 2019 2032 44 2033 60 2019 62 613 2034 41 123 385 40 404 2035 61 1500 59 2035 60 2034 46 2036 59 2035 637 41 123 2034 91 2035 93 46 2037 40 2032 41 59 125 125 439 457 60 2019 62 2038 60 2019 62 2039 40 2040 60 2019 62 2041 41 123 450 40 2038 60 2019 62 41 2041 46 2042 40 2043 46 2044 40 41 41 59 125 439 457 60 2019 44 2045 62 2038 60 2045 62 2046 40 2040 60 2019 62 2041 41 123 450 424 59 125 125 125 
31327,Java,"		sm.setFilter(new Filter() {
			@Override public boolean shouldTransform(ClassLoader loader, String className, Class<?> classBeingDefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {
				if (loader != null && loader.getClass().getName().startsWith(""org.sonar.classloader."")) return false; // Relevant to bug #2351
				if (!(loader instanceof URLClassLoader)) return true;
				ClassLoader parent = loader.getParent();
				if (parent == null) return true;
				return !parent.getClass().getName().startsWith(""org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader"");
			}
		});",0,2000 46 2001 40 418 2002 40 41 123 64 2003 439 324 2004 40 2005 2006 44 2007 2008 44 2009 60 63 62 2010 44 2011 2012 44 326 91 93 2013 41 123 392 40 2006 631 424 605 2006 46 2014 40 41 46 2015 40 41 46 2016 40 648 41 41 450 380 59 621 392 40 33 40 2006 402 2017 41 41 450 473 59 2005 2018 61 2006 46 2019 40 41 59 392 40 2018 614 424 41 450 473 59 450 33 2018 46 2014 40 41 46 2015 40 41 46 2016 40 648 41 59 125 125 41 59 
47129,Java,"        new Thread(""TermSessionWaiter[pid="" + mShellPid + ""]"") {
            @Override
            public void run() {
                int processExitCode = JNI.waitFor(mShellPid);
                mMainThreadHandler.sendMessage(mMainThreadHandler.obtainMessage(MSG_PROCESS_EXITED, processExitCode));
            }
        }.start();",0,418 2000 40 648 43 2001 43 648 41 123 64 2002 439 492 2003 40 41 123 404 2004 61 2005 46 2006 40 2001 41 59 2007 46 2008 40 2007 46 2009 40 2010 44 2004 41 41 59 125 125 46 2011 40 41 59 
32258,Java,"    public static class GetLinkI implements LInstruction{
        public int output, index;

        public GetLinkI(int output, int index){
            this.index = index;
            this.output = output;
        }

        public GetLinkI(){
        }

        @Override
        public void run(LExecutor exec){
            int address = exec.numi(index);

            exec.setobj(output, address >= 0 && address < exec.links.length ? exec.links[address] : null);
        }
    }",0,439 457 334 2000 395 2001 123 439 404 2002 44 2003 59 439 2000 40 404 2002 44 404 2003 41 123 467 46 2003 61 2003 59 467 46 2002 61 2002 59 125 439 2000 40 41 123 125 64 2004 439 492 2005 40 2006 2007 41 123 404 2008 61 2007 46 2009 40 2003 41 59 2007 46 2010 40 2002 44 2008 615 1500 605 2008 60 2007 46 2011 46 2012 63 2007 46 2011 91 2008 93 58 424 41 59 125 125 
30734,Java,"	private static final class TestCompilationUnitEclipse extends org.eclipse.jdt.internal.core.CompilationUnit {
		private final char[] source;
		private final char[] mainTypeName;
		
		private TestCompilationUnitEclipse(String name, String source) {
			super(null, name, null);
			this.source = source.toCharArray();
			
			char[] fileNameCharArray = getFileName();
			int start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;
			int end = CharOperation.lastIndexOf('.', fileNameCharArray);
			if (end == -1) {
				end = fileNameCharArray.length;
			}
			mainTypeName = CharOperation.subarray(fileNameCharArray, start, end);
		}
		
		@Override public char[] getContents() {
			return source;
		}
		
		@Override public char[] getMainTypeName() {
			return mainTypeName;
		}
		
		@Override public boolean ignoreOptionalProblems() {
			return false;
		}
		
		@Override public char[][] getPackageName() {
			return null;
		}
		
		@Override public char[] getModuleName() {
			return null;
		}
	}",0,437 457 381 334 2000 378 2001 46 2002 46 2003 46 406 46 2004 46 2005 123 437 381 330 91 93 2006 59 437 381 330 91 93 2007 59 437 2000 40 2008 2009 44 2008 2006 41 123 463 40 424 44 2009 44 424 41 59 467 46 2006 61 2006 46 2010 40 41 59 330 91 93 2011 61 2012 40 41 59 404 2013 61 2014 46 2015 40 2016 46 2017 44 2011 41 43 1501 59 404 2018 61 2014 46 2015 40 607 44 2011 41 59 392 40 2018 614 45 1501 41 123 2018 61 2011 46 2019 59 125 2007 61 2014 46 2020 40 2011 44 2013 44 2018 41 59 125 64 2021 439 330 91 93 2022 40 41 123 450 2006 59 125 64 2021 439 330 91 93 2023 40 41 123 450 2007 59 125 64 2021 439 324 2024 40 41 123 450 380 59 125 64 2021 439 330 91 93 91 93 2025 40 41 123 450 424 59 125 64 2021 439 330 91 93 2026 40 41 123 450 424 59 125 125 
5332,Java,"                new Callback<>() {
                    @Override
                    public TableCell<OpenOfferListItem, OpenOfferListItem> call(
                            TableColumn<OpenOfferListItem, OpenOfferListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OpenOfferListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                getStyleClass().removeAll(""offer-disabled"");

                                if (item != null) {
                                    if (model.isNotPublished(item)) getStyleClass().add(""offer-disabled"");
                                    setGraphic(new AutoTooltipLabel(model.getDirectionLabel(item)));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 381 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 2009 40 41 46 2010 40 648 41 59 392 40 2008 631 424 41 123 392 40 2011 46 2012 40 2008 41 41 2009 40 41 46 2013 40 648 41 59 2014 40 418 2015 40 2011 46 2016 40 2008 41 41 41 59 125 360 123 2017 40 424 41 59 125 125 125 59 125 125 41 59 
30941,Java,"    private static final @java.lang.SuppressWarnings(""all"") class ChildBuilderImpl extends SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilder<SuperBuilderWithDefaultsAndTargetTyping.Child, SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl> {
      private ChildBuilderImpl() {
        super();
      }
      protected @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child.ChildBuilderImpl self() {
        return this;
      }
      public @java.lang.Override @java.lang.SuppressWarnings(""all"") SuperBuilderWithDefaultsAndTargetTyping.Child build() {
        return new SuperBuilderWithDefaultsAndTargetTyping.Child(this);
      }
    }",0,437 457 381 64 2000 46 2001 46 2002 40 648 41 334 2003 378 2004 46 2005 46 2006 60 2004 46 2005 44 2004 46 2005 46 2003 62 123 437 2003 40 41 123 463 40 41 59 125 438 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 2004 46 2005 46 2003 2008 40 41 123 450 467 59 125 439 64 2000 46 2001 46 2007 64 2000 46 2001 46 2002 40 648 41 2004 46 2005 2009 40 41 123 450 418 2004 46 2005 40 467 41 59 125 125 
29950,Java,"	public static class ValidatePositionProcessor extends TreeProcessor {
		private final int version;
		
		public ValidatePositionProcessor(int version) {
			this.version = version;
		}
		
		private String craftFailMsg(String problematicNode, Deque<JCTree> astContext) {
			StringBuilder msg = new StringBuilder(problematicNode).append("" position of node not set: "");
			for (JCTree t : astContext) {
				msg.append(""\n  "").append(t.getClass().getSimpleName());
				String asStr = t.toString();
				if (asStr.length() < 80) msg.append("": "").append(asStr);
				else if (t instanceof JCClassDecl) msg.append("": "").append(((JCClassDecl) t).name);
				else if (t instanceof JCMethodDecl) msg.append("": "").append(((JCMethodDecl) t).name);
				else if (t instanceof JCVariableDecl) msg.append("": "").append(((JCVariableDecl) t).name);
			}
			return msg.append(""\n-------"").toString();
		}
		
		@Override void processCompilationUnit(final JCCompilationUnit unit) {
			final Deque<JCTree> astContext = new ArrayDeque<JCTree>();
			unit.accept(new TreeScanner() {
				@Override public void scan(JCTree tree) {
					if (tree == null) return;
					if (tree instanceof JCMethodDecl && (((JCMethodDecl) tree).mods.flags & Flags.GENERATEDCONSTR) != 0) return;
					astContext.push(tree);
					try {
						if (tree instanceof JCModifiers) return;
						
						if (!Javac.validateDocComment(unit, tree)) {
							fail(""Start position of doc comment ("" + Javac.getDocComment(unit, tree) + "") of "" + tree + "" not set"");
						}
						
						boolean check = true;
						if (version < 8 && tree instanceof TypeBoundKind) {
							// TypeBoundKind works differently in java6, and as a consequence,
							// the position is not set properly.
							// Given status of j6/j7, not worth properly testing.
							check = false;
						}
						if (version < 8 && tree instanceof JCIdent) {
							// explicit `super()` invocations do not appear to have end pos in j6/7.
							if (""super"".equals("""" + ((JCIdent) tree).name)) check = false;
						}
						
						if (tree instanceof JCVariableDecl && (((JCVariableDecl) tree).mods.flags & Javac.GENERATED_MEMBER) != 0) return;
						
						if (check && tree.pos == -1) fail(craftFailMsg(""Start"", astContext));
						
						if (check && Javac.getEndPosition(tree, unit) == -1) {
							fail(craftFailMsg(""End"", astContext));
						}
					} finally {
						try {
							super.scan(tree);
						} finally {
							astContext.pop();
						}
					}
				}
				
				@Override public void visitMethodDef(JCMethodDecl tree) {
					super.visitMethodDef(tree);
				}
				
				@Override public void visitVarDef(JCVariableDecl tree) {
					if ((tree.mods.flags & Flags.ENUM) != 0) return;
					super.visitVarDef(tree);
				}
				
				@Override public void visitAnnotation(JCAnnotation tree) {
					scan(tree.annotationType);
					// Javac parser maps @Annotation(""val"") to @Annotation(value = ""val"") but does not add an end position for the new JCIdent...
					if (tree.args.length() == 1 && tree.args.head instanceof JCAssign && ((JCIdent)((JCAssign) tree.args.head).lhs).name.toString().equals(""value"")) {
						scan(((JCAssign) tree.args.head).rhs);
					} else {
						scan(tree.args);
					}
				}
			});
		}
	}",0,439 457 334 2000 378 2001 123 437 381 404 2002 59 439 2000 40 404 2002 41 123 467 46 2002 61 2002 59 125 437 2003 2004 40 2003 2005 44 2006 60 2007 62 2008 41 123 2009 2010 61 418 2009 40 2005 41 46 2011 40 648 41 59 385 40 2007 2012 58 2008 41 123 2010 46 2011 40 648 41 46 2011 40 2012 46 2013 40 41 46 2014 40 41 41 59 2003 2015 61 2012 46 2016 40 41 59 392 40 2015 46 2017 40 41 60 1503 41 2010 46 2011 40 648 41 46 2011 40 2015 41 59 360 392 40 2012 402 2018 41 2010 46 2011 40 648 41 46 2011 40 40 40 2018 41 2012 41 46 2019 41 59 360 392 40 2012 402 2020 41 2010 46 2011 40 648 41 46 2011 40 40 40 2020 41 2012 41 46 2019 41 59 360 392 40 2012 402 2021 41 2010 46 2011 40 648 41 46 2011 40 40 40 2021 41 2012 41 46 2019 41 59 125 450 2010 46 2011 40 648 41 46 2022 40 41 59 125 64 2023 492 2024 40 381 2025 2026 41 123 381 2006 60 2007 62 2008 61 418 2027 60 2007 62 40 41 59 2026 46 2028 40 418 2029 40 41 123 64 2023 439 492 2030 40 2007 2031 41 123 392 40 2031 614 424 41 450 59 392 40 2031 402 2032 605 40 40 40 2032 41 2031 41 46 2033 46 2034 38 2035 46 2036 41 631 1500 41 450 59 2008 46 2037 40 2031 41 59 474 123 392 40 2031 402 2038 41 450 59 392 40 33 2039 46 2040 40 2026 44 2031 41 41 123 2041 40 648 43 2039 46 2042 40 2026 44 2031 41 43 648 43 2031 43 648 41 59 125 324 2043 61 473 59 392 40 2002 60 1502 605 2031 402 2044 41 123 621 621 621 2043 61 380 59 125 392 40 2002 60 1502 605 2031 402 2045 41 123 621 392 40 648 46 2046 40 648 43 40 40 2045 41 2031 41 46 2047 41 41 2043 61 380 59 125 392 40 2031 402 2048 605 40 40 40 2048 41 2031 41 46 2033 46 2034 38 2039 46 2049 41 631 1500 41 450 59 392 40 2043 605 2031 46 2050 614 45 1501 41 2051 40 2004 40 648 44 2008 41 41 59 392 40 2043 605 2039 46 2052 40 2031 44 2026 41 614 45 1501 41 123 2051 40 2004 40 648 44 2008 41 41 59 125 125 382 123 474 123 463 46 2030 40 2031 41 59 125 382 123 2008 46 2053 40 41 59 125 125 125 64 2023 439 492 2054 40 2055 2031 41 123 463 46 2054 40 2031 41 59 125 64 2023 439 492 2056 40 2057 2031 41 123 392 40 40 2031 46 2058 46 2059 38 2060 46 2061 41 631 1500 41 450 59 463 46 2056 40 2031 41 59 125 64 2023 439 492 2062 40 2063 2031 41 123 2030 40 2031 46 2064 41 59 621 392 40 2031 46 2065 46 2066 40 41 614 1501 605 2031 46 2065 46 2067 402 2068 605 40 40 2069 41 40 40 2068 41 2031 46 2065 46 2067 41 46 2070 41 46 2071 46 2072 40 41 46 2073 40 648 41 41 123 2030 40 40 40 2068 41 2031 46 2065 46 2067 41 46 2074 41 59 125 360 123 2030 40 2031 46 2065 41 59 125 125 125 41 59 125 125 
32259,Java,"    public static class JumpI implements LInstruction{
        public ConditionOp op = ConditionOp.notEqual;
        public int value, compare, address;

        public JumpI(ConditionOp op, int value, int compare, int address){
            this.op = op;
            this.value = value;
            this.compare = compare;
            this.address = address;
        }

        public JumpI(){
        }

        @Override
        public void run(LExecutor exec){
            if(address != -1){
                Var va = exec.var(value);
                Var vb = exec.var(compare);
                boolean cmp;

                if(op == ConditionOp.strictEqual){
                    cmp = va.isobj == vb.isobj && ((va.isobj && va.objval == vb.objval) || (!va.isobj && va.numval == vb.numval));
                }else if(op.objFunction != null && va.isobj && vb.isobj){
                    //use object function if both are objects
                    cmp = op.objFunction.get(exec.obj(value), exec.obj(compare));
                }else{
                    cmp = op.function.get(exec.num(value), exec.num(compare));
                }

                if(cmp){
                    exec.var(varCounter).numval = address;
                }
            }
        }
    }",0,439 457 334 2000 395 2001 123 439 2002 2003 61 2002 46 2004 59 439 404 2005 44 2006 44 2007 59 439 2000 40 2002 2003 44 404 2005 44 404 2006 44 404 2007 41 123 467 46 2003 61 2003 59 467 46 2005 61 2005 59 467 46 2006 61 2006 59 467 46 2007 61 2007 59 125 439 2000 40 41 123 125 64 2008 439 492 2009 40 2010 2011 41 123 392 40 2007 631 45 1501 41 123 2012 2013 61 2011 46 490 40 2005 41 59 2012 2014 61 2011 46 490 40 2006 41 59 324 2015 59 392 40 2003 614 2002 46 2016 41 123 2015 61 2013 46 2017 614 2014 46 2017 605 40 40 2013 46 2017 605 2013 46 2018 614 2014 46 2018 41 606 40 33 2013 46 2017 605 2013 46 2019 614 2014 46 2019 41 41 59 125 360 392 40 2003 46 2020 631 424 605 2013 46 2021 605 2014 46 2021 41 123 621 2015 61 2003 46 2020 46 2022 40 2011 46 2023 40 2005 41 44 2011 46 2023 40 2006 41 41 59 125 360 123 2015 61 2003 46 389 46 2024 40 2011 46 2025 40 2005 41 44 2011 46 2025 40 2006 41 41 59 125 392 40 2015 41 123 2011 46 490 40 2026 41 46 2027 61 2007 59 125 125 125 125 
30737,Java,"		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {
			@Override public void acceptResult(CompilationResult result) {
				compilationResult_.set(result);
			}
		};",0,2000 2001 61 418 2000 40 41 123 64 2002 439 492 2003 40 2004 2005 41 123 2006 46 2007 40 2005 41 59 125 125 59 
28407,Java,"        new GameXmlReader() {
            @Override
            protected Path getSchemaFilePath() {
                return ServerSettings.dataPackDirectory().resolve(""data/xsd/statBonus.xsd"");
            }

            @Override
            public void load() {
                parseDatapackFile(""data/stats/statBonus.xml"");
            }

            @Override
            public void parseDocument(Document doc, File f) {
                forEach(doc, ""list"", listNode -> forEach(listNode, ""stat"", statNode -> {
                    final var baseStat = parseEnum(statNode.getAttributes(), BaseStats.class, ""type"");
                    for(var node = statNode.getFirstChild(); nonNull(node); node = node.getNextSibling()){
                        switch (node.getNodeName()) {
                            case ""enhancement"" -> parseStatEnhancement(baseStat, node);
                            case ""bonus"" -> parseStatBonus(baseStat, node);
                        }
                    }
                }));
            }

            private void parseStatBonus(BaseStats baseStat, Node bonusNode) {
                forEach(bonusNode, ""value"", statValue -> {
                    final int index = parseInt(statValue.getAttributes(), ""level"");
                    final double bonus = Double.parseDouble(statValue.getTextContent());
                    baseStat.setValue(index, bonus);
                });
            }

            private void parseStatEnhancement(BaseStats baseStat, Node node) {
                final var attr = node.getAttributes();
                baseStat.enhancementSkillId = parseInt(attr, ""skill-id"");
                baseStat.enhancementFirstLevel = parseInt(attr, ""first-level"");
                baseStat.enhancementSecondLevel = parseInt(attr, ""second-level"");
                baseStat.enhancementThirdLevel = parseInt(attr, ""third-level"");
            }
        }.load();",0,418 2000 40 41 123 64 2001 438 2002 2003 40 41 123 450 2004 46 2005 40 41 46 2006 40 648 41 59 125 64 2001 439 492 2007 40 41 123 2008 40 648 41 59 125 64 2001 439 492 2009 40 2010 2011 44 2012 2013 41 123 2014 40 2011 44 648 44 2015 45 62 2014 40 2015 44 648 44 2016 45 62 123 381 490 2017 61 2018 40 2016 46 2019 40 41 44 2020 46 334 44 648 41 59 385 40 490 2021 61 2016 46 2022 40 41 59 2023 40 2021 41 59 2021 61 2021 46 2024 40 41 41 123 464 40 2021 46 2025 40 41 41 123 328 648 45 62 2026 40 2017 44 2021 41 59 328 648 45 62 2027 40 2017 44 2021 41 59 125 125 125 41 41 59 125 437 492 2028 40 2029 2030 44 2031 2032 41 123 2033 40 2032 44 648 44 2034 45 62 123 381 404 2035 61 2036 40 2034 46 2037 40 41 44 648 41 59 381 356 2038 61 2039 46 2040 40 2034 46 2041 40 41 41 59 2030 46 2042 40 2035 44 2038 41 59 125 41 59 125 437 492 2043 40 2029 2030 44 2031 2044 41 123 381 490 2045 61 2044 46 2046 40 41 59 2030 46 2047 61 2048 40 2045 44 648 41 59 2030 46 2049 61 2048 40 2045 44 648 41 59 2030 46 2050 61 2048 40 2045 44 648 41 59 2030 46 2051 61 2048 40 2045 44 648 41 59 125 125 46 2052 40 41 59 
5249,Java,"                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);

                                if (!empty && newItem != null) {
                                    Trade trade = newItem.getTrade();
                                    String id = trade.getId();

                                    // We use maps for each trade to avoid multiple listener registrations when
                                    // switching views. With current implementation we avoid that but we do not
                                    // remove listeners when a trade is removed (completed) but that has no consequences
                                    // as we will not receive any message anyway from a closed trade. Supporting it
                                    // more correctly would require more effort and managing listener deactivation at
                                    // screen switches (currently we get the update called if we have selected another
                                    // view.
                                    Button button;
                                    if (!buttonByTrade.containsKey(id)) {
                                        button = FormBuilder.getIconButton(MaterialDesignIcon.COMMENT_MULTIPLE_OUTLINE);
                                        buttonByTrade.put(id, button);
                                        button.setTooltip(new Tooltip(Res.get(""tradeChat.openChat"")));
                                    } else {
                                        button = buttonByTrade.get(id);
                                    }

                                    JFXBadge badge;
                                    if (!badgeByTrade.containsKey(id)) {
                                        badge = new JFXBadge(button);
                                        badgeByTrade.put(id, badge);
                                        badge.setPosition(Pos.TOP_RIGHT);
                                    } else {
                                        badge = badgeByTrade.get(id);
                                    }

                                    button.setOnAction(e -> {
                                        tableView.getSelectionModel().select(this.getIndex());
                                        openChat(trade);
                                    });

                                    if (!listenerByTrade.containsKey(id)) {
                                        ListChangeListener<ChatMessage> listener = c -> updateChatMessageCount(trade, badge);
                                        listenerByTrade.put(id, listener);
                                        trade.getChatMessages().addListener(listener);
                                    }

                                    updateChatMessageCount(trade, badge);

                                    setGraphic(badge);
                                } else {
                                    setGraphic(null);
                                }
                            }

                        };
                    }
                });",0,418 2000 60 62 40 41 123 64 2001 439 2002 60 2003 44 2003 62 2004 40 2005 60 2003 44 2003 62 2006 41 123 450 418 2002 60 62 40 41 123 64 2001 439 492 2007 40 2003 2008 44 324 362 41 123 463 46 2007 40 2008 44 362 41 59 392 40 33 362 605 2008 631 424 41 123 2009 2010 61 2008 46 2011 40 41 59 2012 2013 61 2010 46 2014 40 41 59 621 621 621 621 621 621 621 2015 2016 59 392 40 33 2017 46 2018 40 2013 41 41 123 2016 61 2019 46 2020 40 2021 46 2022 41 59 2017 46 2023 40 2013 44 2016 41 59 2016 46 2024 40 418 2025 40 2026 46 2027 40 648 41 41 41 59 125 360 123 2016 61 2017 46 2028 40 2013 41 59 125 2029 2030 59 392 40 33 2031 46 2018 40 2013 41 41 123 2030 61 418 2029 40 2016 41 59 2031 46 2032 40 2013 44 2030 41 59 2030 46 2033 40 2034 46 2035 41 59 125 360 123 2030 61 2031 46 2036 40 2013 41 59 125 2016 46 2037 40 2038 45 62 123 2039 46 2040 40 41 46 2041 40 467 46 2042 40 41 41 59 2043 40 2010 41 59 125 41 59 392 40 33 2044 46 2018 40 2013 41 41 123 2045 60 2046 62 2047 61 2048 45 62 2049 40 2010 44 2030 41 59 2044 46 2050 40 2013 44 2047 41 59 2010 46 2051 40 41 46 2052 40 2047 41 59 125 2053 40 2010 44 2030 41 59 2054 40 2030 41 59 125 360 123 2055 40 424 41 59 125 125 125 59 125 125 41 59 
16490,Java,"public class DefaultRenderersFactory implements RenderersFactory {

  /**
   * The default maximum duration for which a video renderer can attempt to seamlessly join an
   * ongoing playback.
   */
  public static final long DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS = 5000;

  /**
   * Modes for using extension renderers. One of {@link #EXTENSION_RENDERER_MODE_OFF}, {@link
   * #EXTENSION_RENDERER_MODE_ON} or {@link #EXTENSION_RENDERER_MODE_PREFER}.
   */
  @Documented
  @Retention(RetentionPolicy.SOURCE)
  @IntDef({EXTENSION_RENDERER_MODE_OFF, EXTENSION_RENDERER_MODE_ON, EXTENSION_RENDERER_MODE_PREFER})
  public @interface ExtensionRendererMode {}
  /** Do not allow use of extension renderers. */
  public static final int EXTENSION_RENDERER_MODE_OFF = 0;
  /**
   * Allow use of extension renderers. Extension renderers are indexed after core renderers of the
   * same type. A {@link TrackSelector} that prefers the first suitable renderer will therefore
   * prefer to use a core renderer to an extension renderer in the case that both are able to play a
   * given track.
   */
  public static final int EXTENSION_RENDERER_MODE_ON = 1;
  /**
   * Allow use of extension renderers. Extension renderers are indexed before core renderers of the
   * same type. A {@link TrackSelector} that prefers the first suitable renderer will therefore
   * prefer to use an extension renderer to a core renderer in the case that both are able to play a
   * given track.
   */
  public static final int EXTENSION_RENDERER_MODE_PREFER = 2;

  /**
   * The maximum number of frames that can be dropped between invocations of {@link
   * VideoRendererEventListener#onDroppedFrames(int, long)}.
   */
  public static final int MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY = 50;

  private static final String TAG = ""DefaultRenderersFactory"";

  private final Context context;
  private final DefaultMediaCodecAdapterFactory codecAdapterFactory;
  @ExtensionRendererMode private int extensionRendererMode;
  private long allowedVideoJoiningTimeMs;
  private boolean enableDecoderFallback;
  private MediaCodecSelector mediaCodecSelector;
  private boolean enableFloatOutput;
  private boolean enableAudioTrackPlaybackParams;
  private boolean enableOffload;

  /** @param context A {@link Context}. */
  public DefaultRenderersFactory(Context context) {
    this.context = context;
    codecAdapterFactory = new DefaultMediaCodecAdapterFactory();
    extensionRendererMode = EXTENSION_RENDERER_MODE_OFF;
    allowedVideoJoiningTimeMs = DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS;
    mediaCodecSelector = MediaCodecSelector.DEFAULT;
  }

  /**
   * @deprecated Use {@link #DefaultRenderersFactory(Context)} and {@link
   *     #setExtensionRendererMode(int)}.
   */
  @Deprecated
  @SuppressWarnings(""deprecation"")
  public DefaultRenderersFactory(
      Context context, @ExtensionRendererMode int extensionRendererMode) {
    this(context, extensionRendererMode, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
  }

  /**
   * @deprecated Use {@link #DefaultRenderersFactory(Context)}, {@link
   *     #setExtensionRendererMode(int)} and {@link #setAllowedVideoJoiningTimeMs(long)}.
   */
  @Deprecated
  public DefaultRenderersFactory(
      Context context,
      @ExtensionRendererMode int extensionRendererMode,
      long allowedVideoJoiningTimeMs) {
    this.context = context;
    this.extensionRendererMode = extensionRendererMode;
    this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
    mediaCodecSelector = MediaCodecSelector.DEFAULT;
    codecAdapterFactory = new DefaultMediaCodecAdapterFactory();
  }

  /**
   * Sets the extension renderer mode, which determines if and how available extension renderers are
   * used. Note that extensions must be included in the application build for them to be considered
   * available.
   *
   * <p>The default value is {@link #EXTENSION_RENDERER_MODE_OFF}.
   *
   * @param extensionRendererMode The extension renderer mode.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory setExtensionRendererMode(
      @ExtensionRendererMode int extensionRendererMode) {
    this.extensionRendererMode = extensionRendererMode;
    return this;
  }

  /**
   * Enables {@link com.google.android.exoplayer2.mediacodec.MediaCodecRenderer} instances to
   * operate their {@link MediaCodec} in asynchronous mode and perform asynchronous queueing.
   *
   * <p>This feature can be enabled only on devices with API versions &gt;= 23. For devices with
   * older API versions, this method is a no-op.
   *
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory forceEnableMediaCodecAsynchronousQueueing() {
    codecAdapterFactory.forceEnableAsynchronous();
    return this;
  }

  /**
   * Disables {@link com.google.android.exoplayer2.mediacodec.MediaCodecRenderer} instances from
   * operating their {@link MediaCodec} in asynchronous mode and perform asynchronous queueing.
   * {@link MediaCodec} instances will be operated synchronous mode.
   *
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory forceDisableMediaCodecAsynchronousQueueing() {
    codecAdapterFactory.forceDisableAsynchronous();
    return this;
  }

  /**
   * Enable synchronizing codec interactions with asynchronous buffer queueing.
   *
   * <p>This method is experimental, and will be renamed or removed in a future release.
   *
   * @param enabled Whether codec interactions will be synchronized with asynchronous buffer
   *     queueing.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory experimentalSetSynchronizeCodecInteractionsWithQueueingEnabled(
      boolean enabled) {
    codecAdapterFactory.experimentalSetSynchronizeCodecInteractionsWithQueueingEnabled(enabled);
    return this;
  }

  /**
   * Enable calling {@link MediaCodec#start} immediately after {@link MediaCodec#flush} on the
   * playback thread, when operating the codec in asynchronous mode. If disabled, {@link
   * MediaCodec#start} will be called by the callback thread after pending callbacks are handled.
   *
   * <p>By default, this feature is disabled.
   *
   * <p>This method is experimental, and will be renamed or removed in a future release.
   *
   * @param enabled Whether {@link MediaCodec#start} will be called on the playback thread
   *     immediately after {@link MediaCodec#flush}.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory experimentalSetImmediateCodecStartAfterFlushEnabled(
      boolean enabled) {
    codecAdapterFactory.experimentalSetImmediateCodecStartAfterFlushEnabled(enabled);
    return this;
  }

  /**
   * Sets whether to enable fallback to lower-priority decoders if decoder initialization fails.
   * This may result in using a decoder that is less efficient or slower than the primary decoder.
   *
   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
   *     initialization fails.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory setEnableDecoderFallback(boolean enableDecoderFallback) {
    this.enableDecoderFallback = enableDecoderFallback;
    return this;
  }

  /**
   * Sets a {@link MediaCodecSelector} for use by {@link MediaCodec} based renderers.
   *
   * <p>The default value is {@link MediaCodecSelector#DEFAULT}.
   *
   * @param mediaCodecSelector The {@link MediaCodecSelector}.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory setMediaCodecSelector(MediaCodecSelector mediaCodecSelector) {
    this.mediaCodecSelector = mediaCodecSelector;
    return this;
  }

  /**
   * Sets whether floating point audio should be output when possible.
   *
   * <p>Enabling floating point output disables audio processing, but may allow for higher quality
   * audio output.
   *
   * <p>The default value is {@code false}.
   *
   * @param enableFloatOutput Whether to enable use of floating point audio output, if available.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory setEnableAudioFloatOutput(boolean enableFloatOutput) {
    this.enableFloatOutput = enableFloatOutput;
    return this;
  }

  /**
   * Sets whether audio should be played using the offload path.
   *
   * <p>Audio offload disables ExoPlayer audio processing, but significantly reduces the energy
   * consumption of the playback when {@link
   * ExoPlayer#experimentalSetOffloadSchedulingEnabled(boolean) offload scheduling} is enabled.
   *
   * <p>Most Android devices can only support one offload {@link android.media.AudioTrack} at a time
   * and can invalidate it at any time. Thus an app can never be guaranteed that it will be able to
   * play in offload.
   *
   * <p>The default value is {@code false}.
   *
   * @param enableOffload Whether to enable use of audio offload for supported formats, if
   *     available.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory setEnableAudioOffload(boolean enableOffload) {
    this.enableOffload = enableOffload;
    return this;
  }

  /**
   * Sets whether to enable setting playback speed using {@link
   * android.media.AudioTrack#setPlaybackParams(PlaybackParams)}, which is supported from API level
   * 23, rather than using application-level audio speed adjustment. This setting has no effect on
   * builds before API level 23 (application-level speed adjustment will be used in all cases).
   *
   * <p>If enabled and supported, new playback speed settings will take effect more quickly because
   * they are applied at the audio mixer, rather than at the point of writing data to the track.
   *
   * <p>When using this mode, the maximum supported playback speed is limited by the size of the
   * audio track's buffer. If the requested speed is not supported the player's event listener will
   * be notified twice on setting playback speed, once with the requested speed, then again with the
   * old playback speed reflecting the fact that the requested speed was not supported.
   *
   * @param enableAudioTrackPlaybackParams Whether to enable setting playback speed using {@link
   *     android.media.AudioTrack#setPlaybackParams(PlaybackParams)}.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory setEnableAudioTrackPlaybackParams(
      boolean enableAudioTrackPlaybackParams) {
    this.enableAudioTrackPlaybackParams = enableAudioTrackPlaybackParams;
    return this;
  }

  /**
   * Sets the maximum duration for which video renderers can attempt to seamlessly join an ongoing
   * playback.
   *
   * <p>The default value is {@link #DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS}.
   *
   * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
   *     seamlessly join an ongoing playback, in milliseconds.
   * @return This factory, for convenience.
   */
  public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoiningTimeMs) {
    this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
    return this;
  }

  @Override
  public Renderer[] createRenderers(
      Handler eventHandler,
      VideoRendererEventListener videoRendererEventListener,
      AudioRendererEventListener audioRendererEventListener,
      TextOutput textRendererOutput,
      MetadataOutput metadataRendererOutput) {
    ArrayList<Renderer> renderersList = new ArrayList<>();
    buildVideoRenderers(
        context,
        extensionRendererMode,
        mediaCodecSelector,
        enableDecoderFallback,
        eventHandler,
        videoRendererEventListener,
        allowedVideoJoiningTimeMs,
        renderersList);
    @Nullable
    AudioSink audioSink =
        buildAudioSink(context, enableFloatOutput, enableAudioTrackPlaybackParams, enableOffload);
    if (audioSink != null) {
      buildAudioRenderers(
          context,
          extensionRendererMode,
          mediaCodecSelector,
          enableDecoderFallback,
          audioSink,
          eventHandler,
          audioRendererEventListener,
          renderersList);
    }
    buildTextRenderers(
        context,
        textRendererOutput,
        eventHandler.getLooper(),
        extensionRendererMode,
        renderersList);
    buildMetadataRenderers(
        context,
        metadataRendererOutput,
        eventHandler.getLooper(),
        extensionRendererMode,
        renderersList);
    buildCameraMotionRenderers(context, extensionRendererMode, renderersList);
    buildMiscellaneousRenderers(context, eventHandler, extensionRendererMode, renderersList);
    return renderersList.toArray(new Renderer[0]);
  }

  /**
   * Builds video renderers for use by the player.
   *
   * @param context The {@link Context} associated with the player.
   * @param extensionRendererMode The extension renderer mode.
   * @param mediaCodecSelector A decoder selector.
   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
   *     initialization fails. This may result in using a decoder that is slower/less efficient than
   *     the primary decoder.
   * @param eventHandler A handler associated with the main thread's looper.
   * @param eventListener An event listener.
   * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
   *     seamlessly join an ongoing playback, in milliseconds.
   * @param out An array to which the built renderers should be appended.
   */
  protected void buildVideoRenderers(
      Context context,
      @ExtensionRendererMode int extensionRendererMode,
      MediaCodecSelector mediaCodecSelector,
      boolean enableDecoderFallback,
      Handler eventHandler,
      VideoRendererEventListener eventListener,
      long allowedVideoJoiningTimeMs,
      ArrayList<Renderer> out) {
    MediaCodecVideoRenderer videoRenderer =
        new MediaCodecVideoRenderer(
            context,
            getCodecAdapterFactory(),
            mediaCodecSelector,
            allowedVideoJoiningTimeMs,
            enableDecoderFallback,
            eventHandler,
            eventListener,
            MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
    out.add(videoRenderer);

    if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
      return;
    }
    int extensionRendererIndex = out.size();
    if (extensionRendererMode == EXTENSION_RENDERER_MODE_PREFER) {
      extensionRendererIndex--;
    }

    try {
      // Full class names used for constructor args so the LINT rule triggers if any of them move.
      Class<?> clazz = Class.forName(""com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer"");
      Constructor<?> constructor =
          clazz.getConstructor(
              long.class,
              android.os.Handler.class,
              com.google.android.exoplayer2.video.VideoRendererEventListener.class,
              int.class);
      Renderer renderer =
          (Renderer)
              constructor.newInstance(
                  allowedVideoJoiningTimeMs,
                  eventHandler,
                  eventListener,
                  MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
      out.add(extensionRendererIndex++, renderer);
      Log.i(TAG, ""Loaded LibvpxVideoRenderer."");
    } catch (ClassNotFoundException e) {
      // Expected if the app was built without the extension.
    } catch (Exception e) {
      // The extension is present, but instantiation failed.
      throw new RuntimeException(""Error instantiating VP9 extension"", e);
    }

    try {
      // Full class names used for constructor args so the LINT rule triggers if any of them move.
      Class<?> clazz = Class.forName(""com.google.android.exoplayer2.ext.av1.Libgav1VideoRenderer"");
      Constructor<?> constructor =
          clazz.getConstructor(
              long.class,
              android.os.Handler.class,
              com.google.android.exoplayer2.video.VideoRendererEventListener.class,
              int.class);
      Renderer renderer =
          (Renderer)
              constructor.newInstance(
                  allowedVideoJoiningTimeMs,
                  eventHandler,
                  eventListener,
                  MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
      out.add(extensionRendererIndex++, renderer);
      Log.i(TAG, ""Loaded Libgav1VideoRenderer."");
    } catch (ClassNotFoundException e) {
      // Expected if the app was built without the extension.
    } catch (Exception e) {
      // The extension is present, but instantiation failed.
      throw new RuntimeException(""Error instantiating AV1 extension"", e);
    }
  }

  /**
   * Builds audio renderers for use by the player.
   *
   * @param context The {@link Context} associated with the player.
   * @param extensionRendererMode The extension renderer mode.
   * @param mediaCodecSelector A decoder selector.
   * @param enableDecoderFallback Whether to enable fallback to lower-priority decoders if decoder
   *     initialization fails. This may result in using a decoder that is slower/less efficient than
   *     the primary decoder.
   * @param audioSink A sink to which the renderers will output.
   * @param eventHandler A handler to use when invoking event listeners and outputs.
   * @param eventListener An event listener.
   * @param out An array to which the built renderers should be appended.
   */
  protected void buildAudioRenderers(
      Context context,
      @ExtensionRendererMode int extensionRendererMode,
      MediaCodecSelector mediaCodecSelector,
      boolean enableDecoderFallback,
      AudioSink audioSink,
      Handler eventHandler,
      AudioRendererEventListener eventListener,
      ArrayList<Renderer> out) {
    MediaCodecAudioRenderer audioRenderer =
        new MediaCodecAudioRenderer(
            context,
            getCodecAdapterFactory(),
            mediaCodecSelector,
            enableDecoderFallback,
            eventHandler,
            eventListener,
            audioSink);
    out.add(audioRenderer);

    if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
      return;
    }
    int extensionRendererIndex = out.size();
    if (extensionRendererMode == EXTENSION_RENDERER_MODE_PREFER) {
      extensionRendererIndex--;
    }

    try {
      // Full class names used for constructor args so the LINT rule triggers if any of them move.
      Class<?> clazz = Class.forName(""com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer"");
      Constructor<?> constructor =
          clazz.getConstructor(
              android.os.Handler.class,
              com.google.android.exoplayer2.audio.AudioRendererEventListener.class,
              com.google.android.exoplayer2.audio.AudioSink.class);
      Renderer renderer =
          (Renderer) constructor.newInstance(eventHandler, eventListener, audioSink);
      out.add(extensionRendererIndex++, renderer);
      Log.i(TAG, ""Loaded LibopusAudioRenderer."");
    } catch (ClassNotFoundException e) {
      // Expected if the app was built without the extension.
    } catch (Exception e) {
      // The extension is present, but instantiation failed.
      throw new RuntimeException(""Error instantiating Opus extension"", e);
    }

    try {
      // Full class names used for constructor args so the LINT rule triggers if any of them move.
      Class<?> clazz = Class.forName(""com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer"");
      Constructor<?> constructor =
          clazz.getConstructor(
              android.os.Handler.class,
              com.google.android.exoplayer2.audio.AudioRendererEventListener.class,
              com.google.android.exoplayer2.audio.AudioSink.class);
      Renderer renderer =
          (Renderer) constructor.newInstance(eventHandler, eventListener, audioSink);
      out.add(extensionRendererIndex++, renderer);
      Log.i(TAG, ""Loaded LibflacAudioRenderer."");
    } catch (ClassNotFoundException e) {
      // Expected if the app was built without the extension.
    } catch (Exception e) {
      // The extension is present, but instantiation failed.
      throw new RuntimeException(""Error instantiating FLAC extension"", e);
    }

    try {
      // Full class names used for constructor args so the LINT rule triggers if any of them move.
      Class<?> clazz =
          Class.forName(""com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer"");
      Constructor<?> constructor =
          clazz.getConstructor(
              android.os.Handler.class,
              com.google.android.exoplayer2.audio.AudioRendererEventListener.class,
              com.google.android.exoplayer2.audio.AudioSink.class);
      Renderer renderer =
          (Renderer) constructor.newInstance(eventHandler, eventListener, audioSink);
      out.add(extensionRendererIndex++, renderer);
      Log.i(TAG, ""Loaded FfmpegAudioRenderer."");
    } catch (ClassNotFoundException e) {
      // Expected if the app was built without the extension.
    } catch (Exception e) {
      // The extension is present, but instantiation failed.
      throw new RuntimeException(""Error instantiating FFmpeg extension"", e);
    }
  }

  /**
   * Builds text renderers for use by the player.
   *
   * @param context The {@link Context} associated with the player.
   * @param output An output for the renderers.
   * @param outputLooper The looper associated with the thread on which the output should be called.
   * @param extensionRendererMode The extension renderer mode.
   * @param out An array to which the built renderers should be appended.
   */
  protected void buildTextRenderers(
      Context context,
      TextOutput output,
      Looper outputLooper,
      @ExtensionRendererMode int extensionRendererMode,
      ArrayList<Renderer> out) {
    out.add(new TextRenderer(output, outputLooper));
  }

  /**
   * Builds metadata renderers for use by the player.
   *
   * @param context The {@link Context} associated with the player.
   * @param output An output for the renderers.
   * @param outputLooper The looper associated with the thread on which the output should be called.
   * @param extensionRendererMode The extension renderer mode.
   * @param out An array to which the built renderers should be appended.
   */
  protected void buildMetadataRenderers(
      Context context,
      MetadataOutput output,
      Looper outputLooper,
      @ExtensionRendererMode int extensionRendererMode,
      ArrayList<Renderer> out) {
    out.add(new MetadataRenderer(output, outputLooper));
  }

  /**
   * Builds camera motion renderers for use by the player.
   *
   * @param context The {@link Context} associated with the player.
   * @param extensionRendererMode The extension renderer mode.
   * @param out An array to which the built renderers should be appended.
   */
  protected void buildCameraMotionRenderers(
      Context context, @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
    out.add(new CameraMotionRenderer());
  }

  /**
   * Builds any miscellaneous renderers used by the player.
   *
   * @param context The {@link Context} associated with the player.
   * @param eventHandler A handler to use when invoking event listeners and outputs.
   * @param extensionRendererMode The extension renderer mode.
   * @param out An array to which the built renderers should be appended.
   */
  protected void buildMiscellaneousRenderers(
      Context context,
      Handler eventHandler,
      @ExtensionRendererMode int extensionRendererMode,
      ArrayList<Renderer> out) {
    // Do nothing.
  }

  /**
   * Builds an {@link AudioSink} to which the audio renderers will output.
   *
   * @param context The {@link Context} associated with the player.
   * @param enableFloatOutput Whether to enable use of floating point audio output, if available.
   * @param enableAudioTrackPlaybackParams Whether to enable setting playback speed using {@link
   *     android.media.AudioTrack#setPlaybackParams(PlaybackParams)}, if supported.
   * @param enableOffload Whether to enable use of audio offload for supported formats, if
   *     available.
   * @return The {@link AudioSink} to which the audio renderers will output. May be {@code null} if
   *     no audio renderers are required. If {@code null} is returned then {@link
   *     #buildAudioRenderers} will not be called.
   */
  @Nullable
  protected AudioSink buildAudioSink(
      Context context,
      boolean enableFloatOutput,
      boolean enableAudioTrackPlaybackParams,
      boolean enableOffload) {
    return new DefaultAudioSink(
        AudioCapabilities.getCapabilities(context),
        new DefaultAudioProcessorChain(),
        enableFloatOutput,
        enableAudioTrackPlaybackParams,
        enableOffload
            ? DefaultAudioSink.OFFLOAD_MODE_ENABLED_GAPLESS_REQUIRED
            : DefaultAudioSink.OFFLOAD_MODE_DISABLED);
  }

  /**
   * Returns the {@link MediaCodecAdapter.Factory} that will be used when creating {@link
   * com.google.android.exoplayer2.mediacodec.MediaCodecRenderer} instances.
   */
  protected MediaCodecAdapter.Factory getCodecAdapterFactory() {
    return codecAdapterFactory;
  }
}",1,439 334 2000 395 2001 123 618 439 457 381 413 2002 61 1505 59 618 64 2003 64 2004 40 2005 46 2006 41 64 2007 40 123 2008 44 2009 44 2010 125 41 439 64 405 2011 123 125 618 439 457 381 404 2012 61 1500 59 618 439 457 381 404 2013 61 1501 59 618 439 457 381 404 2014 61 1502 59 618 439 457 381 404 2015 61 1503 59 437 457 381 2016 2017 61 648 59 437 381 2018 2019 59 437 381 2020 2021 59 64 2011 437 404 2022 59 437 413 2023 59 437 324 2024 59 437 2025 2026 59 437 324 2027 59 437 324 2028 59 437 324 2029 59 618 439 2000 40 2018 2019 41 123 467 46 2019 61 2019 59 2021 61 418 2020 40 41 59 2022 61 2012 59 2023 61 2002 59 2026 61 2025 46 2030 59 125 618 64 2031 64 2032 40 648 41 439 2000 40 2018 2019 44 64 2011 404 2022 41 123 467 40 2019 44 2022 44 2002 41 59 125 618 64 2031 439 2000 40 2018 2019 44 64 2011 404 2022 44 413 2023 41 123 467 46 2019 61 2019 59 467 46 2022 61 2022 59 467 46 2023 61 2023 59 2026 61 2025 46 2033 59 2021 61 418 2020 40 41 59 125 618 439 2000 2034 40 64 2011 404 2022 41 123 467 46 2022 61 2022 59 450 467 59 125 618 439 2000 2035 40 41 123 2021 46 2036 40 41 59 450 467 59 125 618 439 2000 2037 40 41 123 2021 46 2038 40 41 59 450 467 59 125 618 439 2000 2039 40 324 2040 41 123 2021 46 2039 40 2040 41 59 450 467 59 125 618 439 2000 2041 40 324 2040 41 123 2021 46 2041 40 2040 41 59 450 467 59 125 618 439 2000 2042 40 324 2024 41 123 467 46 2024 61 2024 59 450 467 59 125 618 439 2000 2043 40 2025 2026 41 123 467 46 2026 61 2026 59 450 467 59 125 618 439 2000 2044 40 324 2027 41 123 467 46 2027 61 2027 59 450 467 59 125 618 439 2000 2045 40 324 2029 41 123 467 46 2029 61 2029 59 450 467 59 125 618 439 2000 2046 40 324 2028 41 123 467 46 2028 61 2028 59 450 467 59 125 618 439 2000 2047 40 413 2023 41 123 467 46 2023 61 2023 59 450 467 59 125 64 2048 439 2049 91 93 2050 40 2051 2052 44 2053 2054 44 2055 2056 44 2057 2058 44 2059 2060 41 123 2061 60 2049 62 2062 61 418 2061 60 62 40 41 59 2063 40 2019 44 2022 44 2026 44 2024 44 2052 44 2054 44 2023 44 2062 41 59 64 2064 2065 2066 61 2067 40 2019 44 2027 44 2028 44 2029 41 59 392 40 2066 631 424 41 123 2068 40 2019 44 2022 44 2026 44 2024 44 2066 44 2052 44 2056 44 2062 41 59 125 2069 40 2019 44 2058 44 2052 46 2070 40 41 44 2022 44 2062 41 59 2071 40 2019 44 2060 44 2052 46 2070 40 41 44 2022 44 2062 41 59 2072 40 2019 44 2022 44 2062 41 59 2073 40 2019 44 2052 44 2022 44 2062 41 59 450 2062 46 2074 40 418 2049 91 1500 93 41 59 125 618 438 492 2075 40 2018 2019 44 64 2011 404 2022 44 2025 2026 44 324 2024 44 2051 2052 44 2053 2076 44 413 2023 44 2077 60 2049 62 430 41 123 2078 2079 61 418 2078 40 2019 44 2080 40 41 44 2026 44 2023 44 2024 44 2052 44 2076 44 2015 41 59 430 46 2081 40 2079 41 59 392 40 2022 614 2012 41 123 450 59 125 404 2082 61 430 46 2083 40 41 59 392 40 2022 614 2014 41 123 2082 629 59 125 474 123 621 2084 60 63 62 2085 61 2084 46 2086 40 648 41 59 2087 60 63 62 2088 61 2085 46 2089 40 413 46 334 44 2090 46 2091 46 2051 46 334 44 2092 46 2093 46 2090 46 2094 46 2095 46 2053 46 334 44 404 46 334 41 59 2049 2096 61 40 2049 41 2088 46 2097 40 2023 44 2052 44 2076 44 2015 41 59 430 46 2081 40 2082 637 44 2096 41 59 2098 46 2099 40 2017 44 648 41 59 125 329 40 2100 2101 41 123 621 125 329 40 2102 2101 41 123 621 469 418 2103 40 648 44 2101 41 59 125 474 123 621 2104 60 63 62 2105 61 2104 46 2106 40 648 41 59 2107 60 63 62 2108 61 2105 46 2109 40 413 46 334 44 2110 46 2111 46 2051 46 334 44 2112 46 2113 46 2110 46 2114 46 2115 46 2053 46 334 44 404 46 334 41 59 2049 2116 61 40 2049 41 2108 46 2117 40 2023 44 2052 44 2076 44 2015 41 59 430 46 2081 40 2082 637 44 2116 41 59 2118 46 2119 40 2017 44 648 41 59 125 329 40 2100 2101 41 123 621 125 329 40 2102 2101 41 123 621 469 418 2120 40 648 44 2101 41 59 125 125 618 438 492 2121 40 2018 2019 44 64 2011 404 2022 44 2025 2026 44 324 2024 44 2122 2123 44 2051 2052 44 2055 2076 44 2077 60 2049 62 430 41 123 2124 2125 61 418 2124 40 2019 44 2126 40 41 44 2026 44 2024 44 2052 44 2076 44 2123 41 59 430 46 2127 40 2125 41 59 392 40 2022 614 2012 41 123 450 59 125 404 2128 61 430 46 2129 40 41 59 392 40 2022 614 2014 41 123 2128 629 59 125 474 123 621 2130 60 63 62 2131 61 2130 46 2132 40 648 41 59 2133 60 63 62 2134 61 2131 46 2135 40 2136 46 2137 46 2051 46 334 44 2138 46 2139 46 2136 46 2140 46 2141 46 2055 46 334 44 2138 46 2139 46 2136 46 2140 46 2141 46 2122 46 334 41 59 2049 2142 61 40 2049 41 2134 46 2143 40 2052 44 2076 44 2123 41 59 430 46 2127 40 2128 637 44 2142 41 59 2144 46 2145 40 2017 44 648 41 59 125 329 40 2146 2147 41 123 621 125 329 40 2148 2147 41 123 621 469 418 2149 40 648 44 2147 41 59 125 474 123 621 2150 60 63 62 2151 61 2150 46 2152 40 648 41 59 2153 60 63 62 2154 61 2151 46 2155 40 2156 46 2157 46 2051 46 334 44 2158 46 2159 46 2156 46 2160 46 2161 46 2055 46 334 44 2158 46 2159 46 2156 46 2160 46 2161 46 2122 46 334 41 59 2049 2162 61 40 2049 41 2154 46 2163 40 2052 44 2076 44 2123 41 59 430 46 2127 40 2128 637 44 2162 41 59 2164 46 2165 40 2017 44 648 41 59 125 329 40 2146 2147 41 123 621 125 329 40 2148 2147 41 123 621 469 418 2166 40 648 44 2147 41 59 125 474 123 621 2167 60 63 62 2168 61 2167 46 2169 40 648 41 59 2170 60 63 62 2171 61 2168 46 2172 40 2173 46 2174 46 2051 46 334 44 2175 46 2176 46 2173 46 2177 46 2178 46 2055 46 334 44 2175 46 2176 46 2173 46 2177 46 2178 46 2122 46 334 41 59 2049 2179 61 40 2049 41 2171 46 2180 40 2052 44 2076 44 2123 41 59 430 46 2127 40 2128 637 44 2179 41 59 2181 46 2182 40 2017 44 648 41 59 125 329 40 2146 2147 41 123 621 125 329 40 2148 2147 41 123 621 469 418 2183 40 648 44 2147 41 59 125 125 618 438 492 2184 40 2018 2019 44 2057 2185 44 2186 2187 44 64 2011 404 2022 44 2077 60 2049 62 430 41 123 430 46 2188 40 418 2189 40 2185 44 2187 41 41 59 125 618 438 492 2190 40 2018 2019 44 2059 2185 44 2186 2187 44 64 2011 404 2022 44 2077 60 2049 62 430 41 123 430 46 2191 40 418 2192 40 2185 44 2187 41 41 59 125 618 438 492 2193 40 2018 2019 44 64 2011 404 2022 44 2077 60 2049 62 430 41 123 430 46 2194 40 418 2195 40 41 41 59 125 618 438 492 2196 40 2018 2019 44 2051 2052 44 64 2011 404 2022 44 2077 60 2049 62 430 41 123 621 125 618 64 2197 438 2122 2198 40 2018 2019 44 324 2027 44 324 2028 44 324 2029 41 123 450 418 2199 40 2200 46 2201 40 2019 41 44 418 2202 40 41 44 2027 44 2028 44 2029 63 2199 46 2203 58 2199 46 2204 41 59 125 618 438 2205 46 2206 2207 40 41 123 450 2021 59 125 125 
26528,Java,"public final class AuthClient extends Client<Connection<AuthClient>> {

    private static final Logger LOGGER = LoggerFactory.getLogger(AuthClient.class);

    private final long _connectionStartTime;
    private final Map<Integer,Integer> charactersOnServer = new HashMap<>();

    private AuthCrypt crypter;
    private ScrambledKeyPair _scrambledPair;
    private byte[] _blowfishKey;
    private int _sessionId;
    private SessionKey _sessionKey;

    private Account account;
    private AuthClientState state;
    private boolean isJoinedGameSever;
    private long requestedServersInfo;


    public AuthClient(Connection<AuthClient> con) {
		super(con);
		state = AuthClientState.CONNECTED;
		_connectionStartTime = System.currentTimeMillis();
		AuthController.getInstance().registerClient(this);
	}


    @Override
    public boolean decrypt(Buffer data, int offset, int size) {
        boolean decrypted;
        try  {
            decrypted = crypter.decrypt(data, offset, size);
        }
        catch (IOException e) {
            LOGGER.error(e.getMessage(), e);
            close();
            return false;
        }

        if (!decrypted) {
            LOGGER.warn(""Closing connection! Wrong checksum from client: {}"", this);
            close();
        }
        return decrypted;
    }

    @Override
    public boolean encrypt(Buffer data, int offset, int size) {
	    try {
	       return crypter.encrypt(data, offset, size);
        } catch (IOException e) {
	        LOGGER.error(e.getMessage(), e);
	        return false;
        }
    }

	public void sendPacket(AuthServerPacket lsp) {
	    writePacket(lsp);
	}

    public void close(LoginFailReason reason) {
        sendPacket(new LoginFail(reason));
	}
	
	public void close(PlayFailReason reason) {
		close(new PlayFail(reason));
	}

	public void close(AccountKicked.AccountKickedReason reason) {
        close(new AccountKicked(reason));
	}

    @Override
    public void onConnected() {
        sendPacket(new Init());
    }

	@Override
	protected void onDisconnection() {
        LOGGER.debug(""DISCONNECTED: {}"", toString());

        if(!isJoinedGameSever && nonNull(account)) {
            AuthController.getInstance().removeAuthedClient(account.getLogin());
        }
	}

    public void addCharactersOnServer(int serverId, int players) {
        charactersOnServer.put(serverId, players);
    }

    public Map<Integer, Integer> getCharactersOnServer() {
        return charactersOnServer;
    }

    public int getPlayersOnServer(int serverId) {
        return charactersOnServer.getOrDefault(serverId, 0);
    }

    public void joinGameserver() {
        isJoinedGameSever = true;
    }

    public boolean isJoinedGameSever() {
        return isJoinedGameSever;
    }

    AuthClientState getState()
    {
        return state;
    }

    public void setState(AuthClientState state) {
        this.state = state;
    }

    public byte[] getBlowfishKey() {
        return _blowfishKey;
    }

    public byte[] getScrambledModulus() {
        return _scrambledPair.getScrambledModulus();
    }

    public PrivateKey getRSAPrivateKey() {
        return _scrambledPair.getPair().getPrivate();
    }

    public Account getAccount() {
        return account;
    }

    public void setAccount(Account account) {
        this.account = account;
    }

    public int getAccessLevel() {
        return nonNull(account) ? account.getAccessLevel() : -1;
    }

    public int getLastServer() {
        return nonNull(account) ? account.getLastServer(): -1;
    }

    public int getSessionId() {
        return _sessionId;
    }

    public void setSessionKey(SessionKey sessionKey)
    {
        _sessionKey = sessionKey;
    }

    public SessionKey getSessionKey() {
        return _sessionKey;
    }

    public long getConnectionStartTime() {
        return _connectionStartTime;
    }

    public void setKeyPar(ScrambledKeyPair keyPair) {
        _scrambledPair = keyPair;
    }

    public void setBlowfishKey(byte[] blowfishKey) {
        _blowfishKey = blowfishKey;
    }

    public void setSessionId(int sessionId) {
        _sessionId = sessionId;
    }

    public void setCrypt(AuthCrypt crypt) {
        crypter =  crypt;
    }

    public void setRequestedServerInfo(long count) {
        this.requestedServersInfo = count;
    }

    public long getRequestedServersInfo() {
        return requestedServersInfo;
    }

    @Override
    public String toString() {
        String address =  getHostAddress();
        if (getState() == AUTHED_LOGIN) {
            return ""["" + getAccount().getLogin() + "" ("" + (address.equals("""") ? ""disconnect"" : address) + "")]"";
        }
        return ""["" + (address.equals("""") ? ""disconnect"" : address) + ""]"";
    }
}",1,439 381 334 2000 378 2001 60 2002 60 2000 641 123 437 457 381 2003 2004 61 2005 46 2006 40 2000 46 334 41 59 437 381 413 2007 59 437 381 2008 60 2009 44 2009 62 2010 61 418 2011 60 62 40 41 59 437 2012 2013 59 437 2014 2015 59 437 326 91 93 2016 59 437 404 2017 59 437 2018 2019 59 437 2020 2021 59 437 2022 2023 59 437 324 2024 59 437 413 2025 59 439 2000 40 2002 60 2000 62 2026 41 123 463 40 2026 41 59 2023 61 2022 46 2027 59 2007 61 2028 46 2029 40 41 59 2030 46 2031 40 41 46 2032 40 467 41 59 125 64 2033 439 324 2034 40 2035 2036 44 404 2037 44 404 2038 41 123 324 2039 59 474 123 2039 61 2013 46 2034 40 2036 44 2037 44 2038 41 59 125 329 40 2040 2041 41 123 2004 46 371 40 2041 46 2042 40 41 44 2041 41 59 2043 40 41 59 450 380 59 125 392 40 33 2039 41 123 2004 46 2044 40 648 44 467 41 59 2045 40 41 59 125 450 2039 59 125 64 2033 439 324 2046 40 2035 2036 44 404 2037 44 404 2038 41 123 474 123 450 2013 46 2046 40 2036 44 2037 44 2038 41 59 125 329 40 2047 2048 41 123 2004 46 371 40 2048 46 2049 40 41 44 2048 41 59 450 380 59 125 125 439 492 2050 40 2051 2052 41 123 2053 40 2052 41 59 125 439 492 2054 40 2055 2056 41 123 2050 40 418 2057 40 2056 41 41 59 125 439 492 2054 40 2058 2056 41 123 2054 40 418 2059 40 2056 41 41 59 125 439 492 2054 40 2060 46 2061 2056 41 123 2054 40 418 2060 40 2056 41 41 59 125 64 2033 439 492 2062 40 41 123 2050 40 418 2063 40 41 41 59 125 64 2033 438 492 2064 40 41 123 2004 46 2065 40 648 44 2066 40 41 41 59 392 40 33 2024 605 2067 40 2021 41 41 123 2068 46 2069 40 41 46 2070 40 2021 46 2071 40 41 41 59 125 125 439 492 2072 40 404 2073 44 404 2074 41 123 2010 46 2075 40 2073 44 2074 41 59 125 439 2008 60 2009 44 2009 62 2076 40 41 123 450 2010 59 125 439 404 2077 40 404 2073 41 123 450 2010 46 2078 40 2073 44 1500 41 59 125 439 492 2079 40 41 123 2024 61 473 59 125 439 324 2024 40 41 123 450 2024 59 125 2022 2080 40 41 123 450 2023 59 125 439 492 2081 40 2022 2023 41 123 467 46 2023 61 2023 59 125 439 326 91 93 2082 40 41 123 450 2016 59 125 439 326 91 93 2083 40 41 123 450 2015 46 2083 40 41 59 125 439 2084 2085 40 41 123 450 2015 46 2086 40 41 46 2087 40 41 59 125 439 2020 2088 40 41 123 450 2021 59 125 439 492 2089 40 2020 2021 41 123 467 46 2021 61 2021 59 125 439 404 2090 40 41 123 450 2091 40 2021 41 63 2021 46 2090 40 41 58 45 1501 59 125 439 404 2092 40 41 123 450 2093 40 2021 41 63 2021 46 2092 40 41 58 45 1501 59 125 439 404 2094 40 41 123 450 2017 59 125 439 492 2095 40 2018 2096 41 123 2019 61 2096 59 125 439 2018 2097 40 41 123 450 2019 59 125 439 413 2098 40 41 123 450 2007 59 125 439 492 2099 40 2014 2100 41 123 2015 61 2100 59 125 439 492 2101 40 326 91 93 2102 41 123 2016 61 2102 59 125 439 492 2103 40 404 2104 41 123 2017 61 2104 59 125 439 492 2105 40 2012 2106 41 123 2013 61 2106 59 125 439 492 2107 40 413 2108 41 123 467 46 2025 61 2108 59 125 439 413 2109 40 41 123 450 2025 59 125 64 2033 439 2110 2111 40 41 123 2110 2112 61 2113 40 41 59 392 40 2080 40 41 614 2114 41 123 450 648 43 2088 40 41 46 2115 40 41 43 648 43 40 2112 46 2116 40 648 41 63 648 58 2112 41 43 648 59 125 450 648 43 40 2112 46 2117 40 648 41 63 648 58 2112 41 43 648 59 125 125 
30366,Java,"public class OnXJava7StyleOn8 {
  @interface Foo {
    String value() default """";
  }
  @interface Bar {
    String stuff() default """";
  }
  @interface Array {
    String[] value() default {};
  }
  @lombok.Getter() String a;
  @lombok.Setter() String b;
  @lombok.Setter() String c;
  @lombok.Setter() String d;
  @lombok.Getter() String e;
  @lombok.Getter() String f;
  @lombok.Getter() String g;
  @lombok.Getter() String h;
  @lombok.Getter() String i;
  public OnXJava7StyleOn8() {
    super();
  }
  public @Foo @java.lang.SuppressWarnings(""all"") String getA() {
    return this.a;
  }
  public @Foo() @java.lang.SuppressWarnings(""all"") void setB(final String b) {
    this.b = b;
  }
  public @java.lang.SuppressWarnings(""all"") void setC(final @Foo(""a"") String c) {
    this.c = c;
  }
  public @java.lang.SuppressWarnings(""all"") void setD(final @Bar(stuff = ""b"") String d) {
    this.d = d;
  }
  public @Foo(value = ""c"") @Bar(stuff = ""d"") @java.lang.SuppressWarnings(""all"") String getE() {
    return this.e;
  }
  public @Array @java.lang.SuppressWarnings(""all"") String getF() {
    return this.f;
  }
  public @Array() @java.lang.SuppressWarnings(""all"") String getG() {
    return this.g;
  }
  public @Array({}) @java.lang.SuppressWarnings(""all"") String getH() {
    return this.h;
  }
  public @Array({""a"", ""b""}) @java.lang.SuppressWarnings(""all"") String getI() {
    return this.i;
  }
}",1,439 334 2000 123 64 405 2001 123 2002 2003 40 41 349 648 59 125 64 405 2004 123 2005 2006 40 41 349 648 59 125 64 405 2007 123 2008 91 93 2009 40 41 349 123 125 59 125 64 2010 46 2011 40 41 2012 2013 59 64 2010 46 2014 40 41 2012 2015 59 64 2010 46 2014 40 41 2012 2016 59 64 2010 46 2014 40 41 2012 2017 59 64 2010 46 2011 40 41 2012 2018 59 64 2010 46 2011 40 41 2012 2019 59 64 2010 46 2011 40 41 2012 2020 59 64 2010 46 2011 40 41 2012 2021 59 64 2010 46 2011 40 41 2012 2022 59 439 2000 40 41 123 463 40 41 59 125 439 64 2001 64 2023 46 2024 46 2025 40 648 41 2012 2026 40 41 123 450 467 46 2013 59 125 439 64 2001 40 41 64 2023 46 2024 46 2025 40 648 41 492 2027 40 381 2012 2015 41 123 467 46 2015 61 2015 59 125 439 64 2023 46 2024 46 2025 40 648 41 492 2028 40 381 64 2001 40 648 41 2012 2016 41 123 467 46 2016 61 2016 59 125 439 64 2023 46 2024 46 2025 40 648 41 492 2029 40 381 64 2004 40 2030 61 648 41 2012 2017 41 123 467 46 2017 61 2017 59 125 439 64 2001 40 2031 61 648 41 64 2004 40 2030 61 648 41 64 2023 46 2024 46 2025 40 648 41 2012 2032 40 41 123 450 467 46 2018 59 125 439 64 2007 64 2023 46 2024 46 2025 40 648 41 2012 2033 40 41 123 450 467 46 2019 59 125 439 64 2007 40 41 64 2023 46 2024 46 2025 40 648 41 2012 2034 40 41 123 450 467 46 2020 59 125 439 64 2007 40 123 125 41 64 2023 46 2024 46 2025 40 648 41 2012 2035 40 41 123 450 467 46 2021 59 125 439 64 2007 40 123 648 44 648 125 41 64 2023 46 2024 46 2025 40 648 41 2012 2036 40 41 123 450 467 46 2022 59 125 125 
30650,Java,"public class OnXJava8Style {
	@interface Foo {
		String value() default """";
	}
	@interface Bar {
		String stuff() default """";
	}

	@interface Array {
		String[] value() default {};
	}
	String a;
	String b;
	String c;
	String d;
	String e;
	String f;
	String g;
	String h;
	String i;
	@Foo
	@java.lang.SuppressWarnings(""all"")
	public String getA() {
		return this.a;
	}
	@Foo
	@java.lang.SuppressWarnings(""all"")
	public void setB(final String b) {
		this.b = b;
	}
	@java.lang.SuppressWarnings(""all"")
	public void setC(@Foo(""a"") final String c) {
		this.c = c;
	}
	@java.lang.SuppressWarnings(""all"")
	public void setD(@Bar(stuff = ""b"") final String d) {
		this.d = d;
	}
	@Foo(""c"")
	@Bar(stuff = ""d"")
	@java.lang.SuppressWarnings(""all"")
	public String getE() {
		return this.e;
	}
	@Array
	@java.lang.SuppressWarnings(""all"")
	public String getF() {
		return this.f;
	}

	@Array
	@java.lang.SuppressWarnings(""all"")
	public String getG() {
		return this.g;
	}

	@Array({})
	@java.lang.SuppressWarnings(""all"")
	public String getH() {
		return this.h;
	}

	@Array({""a"", ""b""})
	@java.lang.SuppressWarnings(""all"")
	public String getI() {
		return this.i;
	}
}",1,439 334 2000 123 64 405 2001 123 2002 2003 40 41 349 648 59 125 64 405 2004 123 2005 2006 40 41 349 648 59 125 64 405 2007 123 2008 91 93 2009 40 41 349 123 125 59 125 2010 2011 59 2010 2012 59 2010 2013 59 2010 2014 59 2010 2015 59 2010 2016 59 2010 2017 59 2010 2018 59 2010 2019 59 64 2001 64 2020 46 2021 46 2022 40 648 41 439 2010 2023 40 41 123 450 467 46 2011 59 125 64 2001 64 2020 46 2021 46 2022 40 648 41 439 492 2024 40 381 2010 2012 41 123 467 46 2012 61 2012 59 125 64 2020 46 2021 46 2022 40 648 41 439 492 2025 40 64 2001 40 648 41 381 2010 2013 41 123 467 46 2013 61 2013 59 125 64 2020 46 2021 46 2022 40 648 41 439 492 2026 40 64 2004 40 2027 61 648 41 381 2010 2014 41 123 467 46 2014 61 2014 59 125 64 2001 40 648 41 64 2004 40 2027 61 648 41 64 2020 46 2021 46 2022 40 648 41 439 2010 2028 40 41 123 450 467 46 2015 59 125 64 2007 64 2020 46 2021 46 2022 40 648 41 439 2010 2029 40 41 123 450 467 46 2016 59 125 64 2007 64 2020 46 2021 46 2022 40 648 41 439 2010 2030 40 41 123 450 467 46 2017 59 125 64 2007 40 123 125 41 64 2020 46 2021 46 2022 40 648 41 439 2010 2031 40 41 123 450 467 46 2018 59 125 64 2007 40 123 648 44 648 125 41 64 2020 46 2021 46 2022 40 648 41 439 2010 2032 40 41 123 450 467 46 2019 59 125 125 
2689,Java,"public class MovementParkour extends Movement {

    private static final BetterBlockPos[] EMPTY = new BetterBlockPos[]{};

    private final EnumFacing direction;
    private final int dist;
    private final boolean ascend;

    private MovementParkour(IBaritone baritone, BetterBlockPos src, int dist, EnumFacing dir, boolean ascend) {
        super(baritone, src, src.offset(dir, dist).up(ascend ? 1 : 0), EMPTY, src.offset(dir, dist).down(ascend ? 0 : 1));
        this.direction = dir;
        this.dist = dist;
        this.ascend = ascend;
    }

    public static MovementParkour cost(CalculationContext context, BetterBlockPos src, EnumFacing direction) {
        MutableMoveResult res = new MutableMoveResult();
        cost(context, src.x, src.y, src.z, direction, res);
        int dist = Math.abs(res.x - src.x) + Math.abs(res.z - src.z);
        return new MovementParkour(context.getBaritone(), src, dist, direction, res.y > src.y);
    }

    public static void cost(CalculationContext context, int x, int y, int z, EnumFacing dir, MutableMoveResult res) {
        if (!context.allowParkour) {
            return;
        }
        if (y == 256 && !context.allowJumpAt256) {
            return;
        }

        int xDiff = dir.getXOffset();
        int zDiff = dir.getZOffset();
        if (!MovementHelper.fullyPassable(context, x + xDiff, y, z + zDiff)) {
            // most common case at the top -- the adjacent block isn't air
            return;
        }
        IBlockState adj = context.get(x + xDiff, y - 1, z + zDiff);
        if (MovementHelper.canWalkOn(context.bsi, x + xDiff, y - 1, z + zDiff, adj)) { // don't parkour if we could just traverse (for now)
            // second most common case -- we could just traverse not parkour
            return;
        }
        if (MovementHelper.avoidWalkingInto(adj.getBlock()) && adj.getBlock() != Blocks.WATER && adj.getBlock() != Blocks.FLOWING_WATER) { // magma sucks
            return;
        }
        if (!MovementHelper.fullyPassable(context, x + xDiff, y + 1, z + zDiff)) {
            return;
        }
        if (!MovementHelper.fullyPassable(context, x + xDiff, y + 2, z + zDiff)) {
            return;
        }
        if (!MovementHelper.fullyPassable(context, x, y + 2, z)) {
            return;
        }
        IBlockState standingOn = context.get(x, y - 1, z);
        if (standingOn.getBlock() == Blocks.VINE || standingOn.getBlock() == Blocks.LADDER || standingOn.getBlock() instanceof BlockStairs || MovementHelper.isBottomSlab(standingOn) || standingOn.getBlock() instanceof BlockLiquid) {
            return;
        }
        int maxJump;
        if (standingOn.getBlock() == Blocks.SOUL_SAND) {
            maxJump = 2; // 1 block gap
        } else {
            if (context.canSprint) {
                maxJump = 4;
            } else {
                maxJump = 3;
            }
        }
        
        // check parkour jumps from smallest to largest for obstacles/walls and landing positions
        int verifiedMaxJump = 1; // i - 1 (when i = 2)
        for (int i = 2; i <= maxJump; i++) {
            int destX = x + xDiff * i;
            int destZ = z + zDiff * i;
            
            // check head/feet
            if (!MovementHelper.fullyPassable(context, destX, y + 1, destZ)) {
                break;
            }
            if (!MovementHelper.fullyPassable(context, destX, y + 2, destZ)) {
                break;
            }
            
            // check for ascend landing position
            IBlockState destInto = context.bsi.get0(destX, y, destZ);
            if (!MovementHelper.fullyPassable(context.bsi.access, context.bsi.isPassableBlockPos.setPos(destX, y, destZ), destInto)) {
                if (i <= 3 && context.allowParkourAscend && context.canSprint && MovementHelper.canWalkOn(context.bsi, destX, y, destZ, destInto) && checkOvershootSafety(context.bsi, destX + xDiff, y + 1, destZ + zDiff)) {
                    res.x = destX;
                    res.y = y + 1;
                    res.z = destZ;
                    res.cost = i * SPRINT_ONE_BLOCK_COST + context.jumpPenalty;
                    return;
                }
                break;
            }
            
            // check for flat landing position
            IBlockState landingOn = context.bsi.get0(destX, y - 1, destZ);
            // farmland needs to be canWalkOn otherwise farm can never work at all, but we want to specifically disallow ending a jump on farmland haha
            if (landingOn.getBlock() != Blocks.FARMLAND && MovementHelper.canWalkOn(context.bsi, destX, y - 1, destZ, landingOn)) {
                if (checkOvershootSafety(context.bsi, destX + xDiff, y, destZ + zDiff)) {
                    res.x = destX;
                    res.y = y;
                    res.z = destZ;
                    res.cost = costFromJumpDistance(i) + context.jumpPenalty;
                    return;
                }
                break;
            }
            
            if (!MovementHelper.fullyPassable(context, destX, y + 3, destZ)) {
                break;
            }
            
            verifiedMaxJump = i;
        }
        
        // parkour place starts here
        if (!context.allowParkourPlace) {
            return;
        }
        // check parkour jumps from largest to smallest for positions to place blocks
        for (int i = verifiedMaxJump; i > 1; i--) {
            int destX = x + i * xDiff;
            int destZ = z + i * zDiff;
            IBlockState toReplace = context.get(destX, y - 1, destZ);
            double placeCost = context.costOfPlacingAt(destX, y - 1, destZ, toReplace);
            if (placeCost >= COST_INF) {
                continue;
            }
            if (!MovementHelper.isReplaceable(destX, y - 1, destZ, toReplace, context.bsi)) {
                continue;
            }
            if (!checkOvershootSafety(context.bsi, destX + xDiff, y, destZ + zDiff)) {
                continue;
            }
            for (int j = 0; j < 5; j++) {
                int againstX = destX + HORIZONTALS_BUT_ALSO_DOWN_____SO_EVERY_DIRECTION_EXCEPT_UP[j].getXOffset();
                int againstY = y - 1 + HORIZONTALS_BUT_ALSO_DOWN_____SO_EVERY_DIRECTION_EXCEPT_UP[j].getYOffset();
                int againstZ = destZ + HORIZONTALS_BUT_ALSO_DOWN_____SO_EVERY_DIRECTION_EXCEPT_UP[j].getZOffset();
                if (againstX == destX - xDiff && againstZ == destZ - zDiff) { // we can't turn around that fast
                    continue;
                }
                if (MovementHelper.canPlaceAgainst(context.bsi, againstX, againstY, againstZ)) {
                    res.x = destX;
                    res.y = y;
                    res.z = destZ;
                    res.cost = costFromJumpDistance(i) + placeCost + context.jumpPenalty;
                    return;
                }
            }
        }
    }

    private static boolean checkOvershootSafety(BlockStateInterface bsi, int x, int y, int z) {
        // we're going to walk into these two blocks after the landing of the parkour anyway, so make sure they aren't avoidWalkingInto
        return !MovementHelper.avoidWalkingInto(bsi.get0(x, y, z).getBlock()) && !MovementHelper.avoidWalkingInto(bsi.get0(x, y + 1, z).getBlock());
    }

    private static double costFromJumpDistance(int dist) {
        switch (dist) {
            case 2:
                return WALK_ONE_BLOCK_COST * 2; // IDK LOL
            case 3:
                return WALK_ONE_BLOCK_COST * 3;
            case 4:
                return SPRINT_ONE_BLOCK_COST * 4;
            default:
                throw new IllegalStateException(""LOL "" + dist);
        }
    }


    @Override
    public double calculateCost(CalculationContext context) {
        MutableMoveResult res = new MutableMoveResult();
        cost(context, src.x, src.y, src.z, direction, res);
        if (res.x != dest.x || res.y != dest.y || res.z != dest.z) {
            return COST_INF;
        }
        return res.cost;
    }

    @Override
    protected Set<BetterBlockPos> calculateValidPositions() {
        Set<BetterBlockPos> set = new HashSet<>();
        for (int i = 0; i <= dist; i++) {
            for (int y = 0; y < 2; y++) {
                set.add(src.offset(direction, i).up(y));
            }
        }
        return set;
    }

    @Override
    public boolean safeToCancel(MovementState state) {
        // once this movement is instantiated, the state is default to PREPPING
        // but once it's ticked for the first time it changes to RUNNING
        // since we don't really know anything about momentum, it suffices to say Parkour can only be canceled on the 0th tick
        return state.getStatus() != MovementStatus.RUNNING;
    }

    @Override
    public MovementState updateState(MovementState state) {
        super.updateState(state);
        if (state.getStatus() != MovementStatus.RUNNING) {
            return state;
        }
        if (ctx.playerFeet().y < src.y) {
            // we have fallen
            logDebug(""sorry"");
            return state.setStatus(MovementStatus.UNREACHABLE);
        }
        if (dist >= 4 || ascend) {
            state.setInput(Input.SPRINT, true);
        }
        MovementHelper.moveTowards(ctx, state, dest);
        if (ctx.playerFeet().equals(dest)) {
            Block d = BlockStateInterface.getBlock(ctx, dest);
            if (d == Blocks.VINE || d == Blocks.LADDER) {
                // it physically hurt me to add support for parkour jumping onto a vine
                // but i did it anyway
                return state.setStatus(MovementStatus.SUCCESS);
            }
            if (ctx.player().posY - ctx.playerFeet().getY() < 0.094) { // lilypads
                state.setStatus(MovementStatus.SUCCESS);
            }
        } else if (!ctx.playerFeet().equals(src)) {
            if (ctx.playerFeet().equals(src.offset(direction)) || ctx.player().posY - src.y > 0.0001) {
                if (!MovementHelper.canWalkOn(ctx, dest.down()) && !ctx.player().onGround && MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), true, false) == PlaceResult.READY_TO_PLACE) {
                    // go in the opposite order to check DOWN before all horizontals -- down is preferable because you don't have to look to the side while in midair, which could mess up the trajectory
                    state.setInput(Input.CLICK_RIGHT, true);
                }
                // prevent jumping too late by checking for ascend
                if (dist == 3 && !ascend) { // this is a 2 block gap, dest = src + direction * 3
                    double xDiff = (src.x + 0.5) - ctx.player().posX;
                    double zDiff = (src.z + 0.5) - ctx.player().posZ;
                    double distFromStart = Math.max(Math.abs(xDiff), Math.abs(zDiff));
                    if (distFromStart < 0.7) {
                        return state;
                    }
                }

                state.setInput(Input.JUMP, true);
            } else if (!ctx.playerFeet().equals(dest.offset(direction, -1))) {
                state.setInput(Input.SPRINT, false);
                if (ctx.playerFeet().equals(src.offset(direction, -1))) {
                    MovementHelper.moveTowards(ctx, state, src);
                } else {
                    MovementHelper.moveTowards(ctx, state, src.offset(direction, -1));
                }
            }
        }
        return state;
    }
}",1,439 334 2000 378 2001 123 437 457 381 2002 91 93 2003 61 418 2002 91 93 123 125 59 437 381 2004 2005 59 437 381 404 2006 59 437 381 324 2007 59 437 2000 40 2008 2009 44 2002 2010 44 404 2006 44 2004 2011 44 324 2007 41 123 463 40 2009 44 2010 44 2010 46 2012 40 2011 44 2006 41 46 2013 40 2007 63 1501 58 1500 41 44 2003 44 2010 46 2012 40 2011 44 2006 41 46 2014 40 2007 63 1500 58 1501 41 41 59 467 46 2005 61 2011 59 467 46 2006 61 2006 59 467 46 2007 61 2007 59 125 439 457 2000 2015 40 2016 2017 44 2002 2010 44 2004 2005 41 123 2018 2019 61 418 2018 40 41 59 2015 40 2017 44 2010 46 2020 44 2010 46 2021 44 2010 46 2022 44 2005 44 2019 41 59 404 2006 61 2023 46 2024 40 2019 46 2020 45 2010 46 2020 41 43 2023 46 2024 40 2019 46 2022 45 2010 46 2022 41 59 450 418 2000 40 2017 46 2025 40 41 44 2010 44 2006 44 2005 44 2019 46 2021 62 2010 46 2021 41 59 125 439 457 492 2015 40 2016 2017 44 404 2026 44 404 2027 44 404 2028 44 2004 2011 44 2029 2030 41 123 392 40 33 2017 46 2031 41 123 450 59 125 392 40 2027 614 1504 605 33 2017 46 2032 41 123 450 59 125 404 2033 61 2011 46 2034 40 41 59 404 2035 61 2011 46 2036 40 41 59 392 40 33 2037 46 2038 40 2017 44 2026 43 2033 44 2027 44 2028 43 2035 41 41 123 621 450 59 125 2039 2040 61 2017 46 2041 40 2026 43 2033 44 2027 45 1501 44 2028 43 2035 41 59 392 40 2037 46 2042 40 2017 46 2043 44 2026 43 2033 44 2027 45 1501 44 2028 43 2035 44 2040 41 41 123 621 621 450 59 125 392 40 2037 46 2044 40 2040 46 2045 40 41 41 605 2040 46 2045 40 41 631 2046 46 2047 605 2040 46 2045 40 41 631 2046 46 2048 41 123 621 450 59 125 392 40 33 2037 46 2038 40 2017 44 2026 43 2033 44 2027 43 1501 44 2028 43 2035 41 41 123 450 59 125 392 40 33 2037 46 2038 40 2017 44 2026 43 2033 44 2027 43 1502 44 2028 43 2035 41 41 123 450 59 125 392 40 33 2037 46 2038 40 2017 44 2026 44 2027 43 1502 44 2028 41 41 123 450 59 125 2039 2049 61 2017 46 2041 40 2026 44 2027 45 1501 44 2028 41 59 392 40 2049 46 2045 40 41 614 2046 46 2050 606 2049 46 2045 40 41 614 2046 46 2051 606 2049 46 2045 40 41 402 2052 606 2037 46 2053 40 2049 41 606 2049 46 2045 40 41 402 2054 41 123 450 59 125 404 2055 59 392 40 2049 46 2045 40 41 614 2046 46 2056 41 123 2055 61 1502 59 621 125 360 123 392 40 2017 46 2057 41 123 2055 61 1502 59 125 360 123 2055 61 1502 59 125 125 621 404 2058 61 1501 59 621 385 40 404 2059 61 1502 59 2059 620 2055 59 2059 637 41 123 404 2060 61 2026 43 2033 42 2059 59 404 2061 61 2028 43 2035 42 2059 59 621 392 40 33 2037 46 2038 40 2017 44 2060 44 2027 43 1501 44 2061 41 41 123 325 59 125 392 40 33 2037 46 2038 40 2017 44 2060 44 2027 43 1502 44 2061 41 41 123 325 59 125 621 2039 2062 61 2017 46 2043 46 2063 40 2060 44 2027 44 2061 41 59 392 40 33 2037 46 2038 40 2017 46 2043 46 2064 44 2017 46 2043 46 2065 46 2066 40 2060 44 2027 44 2061 41 44 2062 41 41 123 392 40 2059 620 1502 605 2017 46 2067 605 2017 46 2068 605 2037 46 2042 40 2017 46 2043 44 2060 44 2027 44 2061 44 2062 41 605 2069 40 2017 46 2043 44 2060 43 2033 44 2027 43 1501 44 2061 43 2035 41 41 123 2030 46 2026 61 2060 59 2030 46 2027 61 2027 43 1501 59 2030 46 2028 61 2061 59 2030 46 2015 61 2059 42 2070 43 2017 46 2071 59 450 59 125 325 59 125 621 2039 2072 61 2017 46 2043 46 2063 40 2060 44 2027 45 1501 44 2061 41 59 621 392 40 2072 46 2045 40 41 631 2046 46 2073 605 2037 46 2042 40 2017 46 2043 44 2060 44 2027 45 1501 44 2061 44 2072 41 41 123 392 40 2074 40 2017 46 2043 44 2060 43 2033 44 2027 44 2061 43 2035 41 41 123 2030 46 2026 61 2060 59 2030 46 2027 61 2027 59 2030 46 2028 61 2061 59 2030 46 2015 61 2075 40 2059 41 43 2017 46 2076 59 450 59 125 325 59 125 392 40 33 2037 46 2038 40 2017 44 2060 44 2027 43 1502 44 2061 41 41 123 325 59 125 2058 61 2059 59 125 621 392 40 33 2017 46 2077 41 123 450 59 125 621 385 40 404 2059 61 2058 59 2059 62 1501 59 2059 629 41 123 404 2078 61 2026 43 2059 42 2033 59 404 2079 61 2028 43 2059 42 2035 59 2039 2080 61 2017 46 2041 40 2078 44 2027 45 1501 44 2079 41 59 356 2081 61 2017 46 2082 40 2078 44 2027 45 1501 44 2079 44 2080 41 59 392 40 2081 615 2083 41 123 344 59 125 392 40 33 2037 46 2084 40 2078 44 2027 45 1501 44 2079 44 2080 44 2017 46 2043 41 41 123 344 59 125 392 40 33 2085 40 2017 46 2043 44 2078 43 2033 44 2027 44 2079 43 2035 41 41 123 344 59 125 385 40 404 2086 61 1500 59 2086 60 1502 59 2086 637 41 123 404 2087 61 2078 43 2088 91 2086 93 46 2034 40 41 59 404 2089 61 2027 45 1501 43 2088 91 2086 93 46 2090 40 41 59 404 2091 61 2079 43 2088 91 2086 93 46 2036 40 41 59 392 40 2087 614 2078 45 2033 605 2091 614 2079 45 2035 41 123 621 344 59 125 392 40 2037 46 2092 40 2017 46 2043 44 2087 44 2089 44 2091 41 41 123 2030 46 2026 61 2078 59 2030 46 2027 61 2027 59 2030 46 2028 61 2079 59 2030 46 2015 61 2093 40 2059 41 43 2081 43 2017 46 2094 59 450 59 125 125 125 125 437 457 324 2095 40 2096 2097 44 404 2026 44 404 2027 44 404 2028 41 123 621 450 33 2098 46 2099 40 2097 46 2100 40 2026 44 2027 44 2028 41 46 2101 40 41 41 605 33 2098 46 2099 40 2097 46 2100 40 2026 44 2027 43 1501 44 2028 41 46 2101 40 41 41 59 125 437 457 356 2102 40 404 2006 41 123 464 40 2006 41 123 328 1502 58 450 2103 42 1502 59 621 328 1502 58 450 2103 42 1502 59 328 1502 58 450 2104 42 1502 59 349 58 469 418 2105 40 648 43 2006 41 59 125 125 64 2106 439 356 2107 40 2016 2017 41 123 2029 2030 61 418 2029 40 41 59 2015 40 2017 44 2010 46 2026 44 2010 46 2027 44 2010 46 2028 44 2005 44 2030 41 59 392 40 2030 46 2026 631 2108 46 2026 606 2030 46 2027 631 2108 46 2027 606 2030 46 2028 631 2108 46 2028 41 123 450 2109 59 125 450 2030 46 2015 59 125 64 2106 438 2110 60 2002 62 2111 40 41 123 2110 60 2002 62 2112 61 418 2113 60 62 40 41 59 385 40 404 2114 61 1500 59 2114 620 2006 59 2114 637 41 123 385 40 404 2027 61 1500 59 2027 60 1502 59 2027 637 41 123 2112 46 2115 40 2010 46 2116 40 2005 44 2114 41 46 2117 40 2027 41 41 59 125 125 450 2112 59 125 64 2106 439 324 2118 40 2119 2120 41 123 621 621 621 450 2120 46 2121 40 41 631 2122 46 2123 59 125 64 2106 439 2119 2124 40 2119 2120 41 123 463 46 2124 40 2120 41 59 392 40 2120 46 2125 40 41 631 2126 46 2127 41 123 450 2120 59 125 392 40 2128 46 2129 40 41 46 2027 60 2010 46 2027 41 123 621 2130 40 648 41 59 450 2120 46 2131 40 2126 46 2132 41 59 125 392 40 2006 615 1502 606 2007 41 123 2120 46 2133 40 2134 46 2135 44 473 41 59 125 2136 46 2137 40 2128 44 2120 44 2138 41 59 392 40 2128 46 2129 40 41 46 2139 40 2138 41 41 123 2140 2141 61 2096 46 2142 40 2128 44 2138 41 59 392 40 2141 614 2143 46 2144 606 2141 614 2143 46 2145 41 123 621 621 450 2120 46 2146 40 2126 46 2147 41 59 125 392 40 2128 46 2148 40 41 46 2149 45 2128 46 2129 40 41 46 2150 40 41 60 1498 41 123 621 2120 46 2151 40 2126 46 2152 41 59 125 125 360 392 40 33 2128 46 2129 40 41 46 2139 40 2010 41 41 123 392 40 2128 46 2129 40 41 46 2139 40 2010 46 2153 40 2005 41 41 606 2128 46 2154 40 41 46 2155 45 2010 46 2027 62 1496 41 123 392 40 33 2136 46 2156 40 2128 44 2138 46 2157 40 41 41 605 33 2128 46 2154 40 41 46 2158 605 2136 46 2159 40 2120 44 2009 44 2138 46 2157 40 41 44 473 44 380 41 614 2160 46 2161 41 123 621 2120 46 2162 40 2163 46 2164 44 473 41 59 125 621 392 40 2006 614 1502 605 33 2007 41 123 621 356 2165 61 40 2010 46 2026 43 1499 41 45 2128 46 2154 40 41 46 2166 59 356 2167 61 40 2010 46 2028 43 1499 41 45 2128 46 2154 40 41 46 2168 59 356 2169 61 2170 46 2171 40 2170 46 2172 40 2165 41 44 2170 46 2172 40 2167 41 41 59 392 40 2169 60 1499 41 123 450 2120 59 125 125 2120 46 2173 40 2174 46 2175 44 473 41 59 125 360 392 40 33 2128 46 2129 40 41 46 2139 40 2138 46 2153 40 2005 44 45 1501 41 41 41 123 2120 46 2176 40 2177 46 2178 44 380 41 59 392 40 2128 46 2129 40 41 46 2139 40 2010 46 2153 40 2005 44 45 1501 41 41 41 123 2136 46 2137 40 2128 44 2120 44 2010 41 59 125 360 123 2136 46 2137 40 2128 44 2120 44 2010 46 2153 40 2005 44 45 1501 41 41 59 125 125 125 450 2120 59 125 125 
4652,Java,"@Slf4j
class TxOutputParser {
    private static final int ACTIVATE_HARD_FORK_1_HEIGHT_MAINNET = 605000;
    private static final int ACTIVATE_HARD_FORK_1_HEIGHT_TESTNET = 1583054;
    private static final int ACTIVATE_HARD_FORK_1_HEIGHT_REGTEST = 1;

    private final DaoStateService daoStateService;
    // Setters
    @Getter
    @Setter
    private long availableInputValue = 0;
    @Setter
    private int unlockBlockHeight;
    @Setter
    @Getter
    private Optional<TxOutput> optionalSpentLockupTxOutput = Optional.empty();

    // Getters
    @Getter
    private boolean bsqOutputFound;
    @Getter
    private Optional<OpReturnType> optionalOpReturnType = Optional.empty();
    @Getter
    private Optional<TempTxOutput> optionalIssuanceCandidate = Optional.empty();
    @Getter
    private Optional<TempTxOutput> optionalBlindVoteLockStakeOutput = Optional.empty();
    @Getter
    private Optional<TempTxOutput> optionalVoteRevealUnlockStakeOutput = Optional.empty();
    @Getter
    private Optional<TempTxOutput> optionalLockupOutput = Optional.empty();
    private Optional<Integer> optionalOpReturnIndex = Optional.empty();

    // Private
    private int lockTime;
    private final List<TempTxOutput> utxoCandidates = new ArrayList<>();
    private boolean prohibitMoreBsqOutputs = false;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    TxOutputParser(DaoStateService daoStateService) {
        this.daoStateService = daoStateService;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    void processOpReturnOutput(TempTxOutput tempTxOutput) {
        byte[] opReturnData = tempTxOutput.getOpReturnData();
        checkNotNull(opReturnData, ""opReturnData must not be null"");
        TxOutputType txOutputType = OpReturnParser.getTxOutputType(tempTxOutput);
        tempTxOutput.setTxOutputType(txOutputType);

        optionalOpReturnType = getMappedOpReturnType(txOutputType);

        optionalOpReturnType.ifPresent(e -> optionalOpReturnIndex = Optional.of(tempTxOutput.getIndex()));

        // If we have a LOCKUP opReturn output we save the lockTime to apply it later to the LOCKUP output.
        // We keep that data in that other output as it makes parsing of the UNLOCK tx easier.
        optionalOpReturnType.filter(opReturnType -> opReturnType == OpReturnType.LOCKUP)
                .ifPresent(opReturnType -> lockTime = BondConsensus.getLockTime(opReturnData));
    }

    void processTxOutput(TempTxOutput tempTxOutput) {
        // We don not expect here an opReturn output as we do not get called on the last output. Any opReturn at
        // another output index is invalid.
        if (tempTxOutput.isOpReturnOutput()) {
            tempTxOutput.setTxOutputType(TxOutputType.INVALID_OUTPUT);
            return;
        }

        if (!daoStateService.isConfiscatedOutput(tempTxOutput.getKey())) {
            long txOutputValue = tempTxOutput.getValue();
            int index = tempTxOutput.getIndex();
            if (isUnlockBondTx(tempTxOutput.getValue(), index)) {
                // We need to handle UNLOCK transactions separately as they don't follow the pattern on spending BSQ
                // The LOCKUP BSQ is burnt unless the output exactly matches the input, that would cause the
                // output to not be BSQ output at all
                handleUnlockBondTx(tempTxOutput);
            } else if (isBtcOutputOfBurnFeeTx(tempTxOutput)) {
                // In case we have the opReturn for a burn fee tx all outputs after 1st output are considered BTC
                handleBtcOutput(tempTxOutput, index);
            } else if (isHardForkActivated(tempTxOutput) && isIssuanceCandidateTxOutput(tempTxOutput)) {
                // After the hard fork activation we fix a bug with a transaction which would have interpreted the
                // issuance output as BSQ if the availableInputValue was >= issuance amount.
                // Such a tx was never created but as we don't know if it will happen before activation date we cannot
                // enforce the bug fix which represents a rule change before the activation date.
                handleIssuanceCandidateOutput(tempTxOutput);
            } else if (availableInputValue > 0 && availableInputValue >= txOutputValue) {
                if (isHardForkActivated(tempTxOutput) && prohibitMoreBsqOutputs) {
                    handleBtcOutput(tempTxOutput, index);
                } else {
                    handleBsqOutput(tempTxOutput, index, txOutputValue);
                }
            } else {
                handleBtcOutput(tempTxOutput, index);
            }
        } else {
            log.warn(""TxOutput {} is confiscated "", tempTxOutput.getKey());
            // We only burn that output
            availableInputValue -= tempTxOutput.getValue();

            // We must not set prohibitMoreBsqOutputs at confiscation transactions as optional
            // BSQ change output (output 2) must not be confiscated.
            tempTxOutput.setTxOutputType(TxOutputType.BTC_OUTPUT);
        }
    }

    void commitUTXOCandidates() {
        utxoCandidates.forEach(output -> daoStateService.addUnspentTxOutput(TxOutput.fromTempOutput(output)));
    }

    /**
     * This sets all outputs to BTC_OUTPUT and doesn't add any txOutputs to the unspentTxOutput map in daoStateService
     */
    void invalidateUTXOCandidates() {
        // We do not need to apply prohibitMoreBsqOutputs as all spendable outputs are set to BTC_OUTPUT anyway.
        utxoCandidates.forEach(output -> output.setTxOutputType(TxOutputType.BTC_OUTPUT));
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Whether a transaction is a valid unlock bond transaction or not.
     *
     * @param txOutputValue The value of the current output, in satoshis.
     * @param index         The index of the output.
     * @return True if the transaction is an unlock transaction, false otherwise.
     */
    private boolean isUnlockBondTx(long txOutputValue, int index) {
        // We require that the input value is exact the available value and the output value
        return index == 0 &&
                availableInputValue == txOutputValue &&
                optionalSpentLockupTxOutput.isPresent() &&
                optionalSpentLockupTxOutput.get().getValue() == txOutputValue;
    }

    private void handleUnlockBondTx(TempTxOutput txOutput) {
        checkArgument(optionalSpentLockupTxOutput.isPresent(), ""optionalSpentLockupTxOutput must be present"");
        availableInputValue -= optionalSpentLockupTxOutput.get().getValue();

        txOutput.setTxOutputType(TxOutputType.UNLOCK_OUTPUT);
        txOutput.setUnlockBlockHeight(unlockBlockHeight);
        utxoCandidates.add(txOutput);

        bsqOutputFound = true;

        // We do not permit more BSQ outputs after the unlock txo as we don't expect additional BSQ outputs.
        prohibitMoreBsqOutputs = true;
    }

    private boolean isBtcOutputOfBurnFeeTx(TempTxOutput tempTxOutput) {
        if (optionalOpReturnType.isPresent()) {
            int index = tempTxOutput.getIndex();
            switch (optionalOpReturnType.get()) {
                case UNDEFINED:
                    break;
                case PROPOSAL:
                    if (isHardForkActivated(tempTxOutput)) {
                        // We enforce a mandatory BSQ change output.
                        // We need that as similar to ASSET_LISTING_FEE and PROOF_OF_BURN
                        // we could not distinguish between 2 structurally same transactions otherwise (only way here
                        // would be to check the proposal fee as that is known from the params).
                        return index >= 1;
                    }
                    break;
                case COMPENSATION_REQUEST:
                    break;
                case REIMBURSEMENT_REQUEST:
                    break;
                case BLIND_VOTE:
                    if (isHardForkActivated(tempTxOutput)) {
                        // After the hard fork activation we fix a bug with a transaction which would have interpreted the
                        // burned vote fee output as BSQ if the vote fee was >= miner fee.
                        // Such a tx was never created but as we don't know if it will happen before activation date we cannot
                        // enforce the bug fix which represents a rule change before the activation date.

                        // If it is the vote stake output we return false.
                        if (index == 0) {
                            return false;
                        }

                        // There must be a vote fee left
                        if (availableInputValue <= 0) {
                            return false;
                        }

                        // Burned BSQ output is last output before opReturn.
                        // We could have also a BSQ change output as last output before opReturn but that will
                        // be detected at blindVoteFee check.
                        // We always have the BSQ change before the burned BSQ output if both are present.
                        checkArgument(optionalOpReturnIndex.isPresent());
                        if (index != optionalOpReturnIndex.get() - 1) {
                            return false;
                        }

                        // Without checking the fee we would not be able to distinguish between 2 structurally same transactions, one
                        // where the output is burned BSQ and one where it is a BSQ change output.
                        long blindVoteFee = daoStateService.getParamValueAsCoin(Param.BLIND_VOTE_FEE, tempTxOutput.getBlockHeight()).value;
                        return availableInputValue == blindVoteFee;
                    }
                    break;
                case VOTE_REVEAL:
                    break;
                case LOCKUP:
                    break;
                case ASSET_LISTING_FEE:
                case PROOF_OF_BURN:
                    // Asset listing fee and proof of burn tx are structurally the same.

                    // We need to require one BSQ change output as we could otherwise not be able to distinguish between 2
                    // structurally same transactions where only the BSQ fee is different. In case of asset listing fee and proof of
                    // burn it is a user input, so it is not known to the parser, instead we derive the burned fee from the parser.
                    // In case of proposal fee we could derive it from the params.

                    // Case 1: 10 BSQ fee to burn
                    // In: 17 BSQ
                    // Out: BSQ change 7 BSQ -> valid BSQ
                    // Out: OpReturn
                    // Miner fee: 1000 sat  (10 BSQ burned)


                    // Case 2: 17 BSQ fee to burn
                    // In: 17 BSQ
                    // Out: burned BSQ change 7 BSQ -> BTC (7 BSQ burned)
                    // Out: OpReturn
                    // Miner fee: 1000 sat  (10 BSQ burned)
                    return index >= 1;
            }
        }
        return false;
    }

    private boolean isIssuanceCandidateTxOutput(TempTxOutput tempTxOutput) {
        // If we have BSQ left as fee and we are at the second output we interpret it as a compensation request output.
        return availableInputValue > 0 &&
                tempTxOutput.getIndex() == 1 &&
                optionalOpReturnType.isPresent() &&
                (optionalOpReturnType.get() == OpReturnType.COMPENSATION_REQUEST ||
                        optionalOpReturnType.get() == OpReturnType.REIMBURSEMENT_REQUEST);
    }

    private void handleIssuanceCandidateOutput(TempTxOutput tempTxOutput) {
        // We do not permit more BSQ outputs after the issuance candidate.
        prohibitMoreBsqOutputs = true;

        // We store the candidate but we don't apply the TxOutputType yet as we need to verify the fee after all
        // outputs are parsed and check the phase. The TxParser will do that....
        optionalIssuanceCandidate = Optional.of(tempTxOutput);
    }

    private void handleBsqOutput(TempTxOutput txOutput, int index, long txOutputValue) {
        // Update the input balance.
        availableInputValue -= txOutputValue;

        boolean isFirstOutput = index == 0;

        OpReturnType opReturnTypeCandidate = null;
        if (optionalOpReturnType.isPresent())
            opReturnTypeCandidate = optionalOpReturnType.get();

        TxOutputType txOutputType;
        if (isFirstOutput && opReturnTypeCandidate == OpReturnType.BLIND_VOTE) {
            txOutputType = TxOutputType.BLIND_VOTE_LOCK_STAKE_OUTPUT;
            optionalBlindVoteLockStakeOutput = Optional.of(txOutput);
        } else if (isFirstOutput && opReturnTypeCandidate == OpReturnType.VOTE_REVEAL) {
            txOutputType = TxOutputType.VOTE_REVEAL_UNLOCK_STAKE_OUTPUT;
            optionalVoteRevealUnlockStakeOutput = Optional.of(txOutput);

            // We do not permit more BSQ outputs after the VOTE_REVEAL_UNLOCK_STAKE_OUTPUT.
            prohibitMoreBsqOutputs = true;
        } else if (isFirstOutput && opReturnTypeCandidate == OpReturnType.LOCKUP) {
            txOutputType = TxOutputType.LOCKUP_OUTPUT;

            // We store the lockTime in the output which will be used as input for a unlock tx.
            // That makes parsing of that data easier as if we would need to access it from the opReturn output of
            // that tx.
            txOutput.setLockTime(lockTime);
            optionalLockupOutput = Optional.of(txOutput);
        } else {
            txOutputType = TxOutputType.BSQ_OUTPUT;
        }
        txOutput.setTxOutputType(txOutputType);
        utxoCandidates.add(txOutput);

        bsqOutputFound = true;
    }

    private void handleBtcOutput(TempTxOutput txOutput, int index) {
        if (isHardForkActivated(txOutput)) {
            txOutput.setTxOutputType(TxOutputType.BTC_OUTPUT);

            // For regular transactions we don't permit BSQ outputs after a BTC output was detected.
            prohibitMoreBsqOutputs = true;
        } else {
            // If we have BSQ left as fee and we are at the second output it might be a compensation request output.
            // We store the candidate but we don't apply the TxOutputType yet as we need to verify the fee after all
            // outputs are parsed and check the phase. The TxParser will do that....
            if (availableInputValue > 0 &&
                    index == 1 &&
                    optionalOpReturnType.isPresent() &&
                    (optionalOpReturnType.get() == OpReturnType.COMPENSATION_REQUEST ||
                            optionalOpReturnType.get() == OpReturnType.REIMBURSEMENT_REQUEST)) {
                optionalIssuanceCandidate = Optional.of(txOutput);

                // We do not permit more BSQ outputs after the issuance candidate.
                prohibitMoreBsqOutputs = true;
            } else {
                txOutput.setTxOutputType(TxOutputType.BTC_OUTPUT);

                // For regular transactions we don't permit BSQ outputs after a BTC output was detected.
                prohibitMoreBsqOutputs = true;
            }
        }
    }

    private boolean isHardForkActivated(TempTxOutput tempTxOutput) {
        return tempTxOutput.getBlockHeight() >= getActivateHardFork1Height();
    }

    private int getActivateHardFork1Height() {
        return Config.baseCurrencyNetwork().isMainnet() ? ACTIVATE_HARD_FORK_1_HEIGHT_MAINNET :
                Config.baseCurrencyNetwork().isTestnet() ? ACTIVATE_HARD_FORK_1_HEIGHT_TESTNET :
                        ACTIVATE_HARD_FORK_1_HEIGHT_REGTEST;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Static
    ///////////////////////////////////////////////////////////////////////////////////////////

    @SuppressWarnings(""WeakerAccess"")
    @VisibleForTesting
    static Optional<OpReturnType> getMappedOpReturnType(TxOutputType outputType) {
        switch (outputType) {
            case PROPOSAL_OP_RETURN_OUTPUT:
                return Optional.of(OpReturnType.PROPOSAL);
            case COMP_REQ_OP_RETURN_OUTPUT:
                return Optional.of(OpReturnType.COMPENSATION_REQUEST);
            case REIMBURSEMENT_OP_RETURN_OUTPUT:
                return Optional.of(OpReturnType.REIMBURSEMENT_REQUEST);
            case BLIND_VOTE_OP_RETURN_OUTPUT:
                return Optional.of(OpReturnType.BLIND_VOTE);
            case VOTE_REVEAL_OP_RETURN_OUTPUT:
                return Optional.of(OpReturnType.VOTE_REVEAL);
            case LOCKUP_OP_RETURN_OUTPUT:
                return Optional.of(OpReturnType.LOCKUP);
            case ASSET_LISTING_FEE_OP_RETURN_OUTPUT:
                return Optional.of(OpReturnType.ASSET_LISTING_FEE);
            case PROOF_OF_BURN_OP_RETURN_OUTPUT:
                return Optional.of(OpReturnType.PROOF_OF_BURN);
            default:
                return Optional.empty();
        }
    }
}",1,64 2000 334 2001 123 437 457 381 404 2002 61 1507 59 437 457 381 404 2003 61 1508 59 437 457 381 404 2004 61 1501 59 437 381 2005 2006 59 621 64 2007 64 2008 437 413 2009 61 1500 59 64 2008 437 404 2010 59 64 2008 64 2007 437 2011 60 2012 62 2013 61 2011 46 362 40 41 59 621 64 2007 437 324 2014 59 64 2007 437 2011 60 2015 62 2016 61 2011 46 362 40 41 59 64 2007 437 2011 60 2017 62 2018 61 2011 46 362 40 41 59 64 2007 437 2011 60 2017 62 2019 61 2011 46 362 40 41 59 64 2007 437 2011 60 2017 62 2020 61 2011 46 362 40 41 59 64 2007 437 2011 60 2017 62 2021 61 2011 46 362 40 41 59 437 2011 60 2022 62 2023 61 2011 46 362 40 41 59 621 437 404 2024 59 437 381 2025 60 2017 62 2026 61 418 2027 60 62 40 41 59 437 324 2028 61 380 59 621 621 621 2001 40 2005 2006 41 123 467 46 2006 61 2006 59 125 621 621 621 492 2029 40 2017 2030 41 123 326 91 93 2031 61 2030 46 2032 40 41 59 2033 40 2031 44 648 41 59 2034 2035 61 2036 46 2037 40 2030 41 59 2030 46 2038 40 2035 41 59 2016 61 2039 40 2035 41 59 2016 46 2040 40 2041 45 62 2023 61 2011 46 2042 40 2030 46 2043 40 41 41 41 59 621 621 2016 46 2044 40 2045 45 62 2045 614 2015 46 2046 41 46 2040 40 2045 45 62 2024 61 2047 46 2048 40 2031 41 41 59 125 492 2049 40 2017 2030 41 123 621 621 392 40 2030 46 2050 40 41 41 123 2030 46 2051 40 2052 46 2053 41 59 450 59 125 392 40 33 2006 46 2054 40 2030 46 2055 40 41 41 41 123 413 2056 61 2030 46 2057 40 41 59 404 2058 61 2030 46 2059 40 41 59 392 40 2060 40 2030 46 2057 40 41 44 2058 41 41 123 621 621 621 2061 40 2030 41 59 125 360 392 40 2062 40 2030 41 41 123 621 2063 40 2030 44 2058 41 59 125 360 392 40 2064 40 2030 41 605 2065 40 2030 41 41 123 621 621 621 621 2066 40 2030 41 59 125 360 392 40 2009 62 1500 605 2009 615 2056 41 123 392 40 2064 40 2030 41 605 2028 41 123 2067 40 2030 44 2058 41 59 125 360 123 2068 40 2030 44 2058 44 2056 41 59 125 125 360 123 2069 40 2030 44 2058 41 59 125 125 360 123 2070 46 2071 40 648 44 2030 46 2055 40 41 41 59 621 2009 628 2030 46 2072 40 41 59 621 621 2030 46 2073 40 2074 46 2075 41 59 125 125 492 2076 40 41 123 2026 46 2077 40 2078 45 62 2006 46 2079 40 2012 46 2080 40 2078 41 41 41 59 125 618 492 2081 40 41 123 621 2026 46 2082 40 2083 45 62 2083 46 2084 40 2085 46 2086 41 41 59 125 621 621 621 618 437 324 2087 40 413 2088 44 404 2089 41 123 621 450 2089 614 1500 605 2009 614 2088 605 2013 46 2090 40 41 605 2013 46 2091 40 41 46 2092 40 41 614 2088 59 125 437 492 2093 40 2017 2094 41 123 2095 40 2013 46 2096 40 41 44 648 41 59 2009 628 2013 46 2097 40 41 46 2098 40 41 59 2094 46 2099 40 2100 46 2101 41 59 2094 46 2102 40 2010 41 59 2026 46 2103 40 2094 41 59 2014 61 473 59 621 2028 61 473 59 125 437 324 2104 40 2017 2030 41 123 392 40 2016 46 2105 40 41 41 123 404 2089 61 2030 46 2106 40 41 59 464 40 2016 46 2107 40 41 41 123 328 2108 58 325 59 328 2109 58 392 40 2110 40 2030 41 41 123 621 621 621 621 450 2089 615 1501 59 125 325 59 328 2111 58 325 59 328 2112 58 325 59 328 2113 58 392 40 2110 40 2030 41 41 123 621 621 621 621 621 392 40 2089 614 1500 41 123 450 380 59 125 621 392 40 2009 620 1500 41 123 450 380 59 125 621 621 621 621 2114 40 2023 46 2105 40 41 41 59 392 40 2089 631 2023 46 2107 40 41 45 1501 41 123 450 380 59 125 621 621 413 2115 61 2006 46 2116 40 2117 46 2118 44 2030 46 2119 40 41 41 46 2120 59 450 2009 614 2115 59 125 325 59 328 2121 58 325 59 328 2122 58 325 59 328 2123 58 328 2124 58 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 450 2089 615 1501 59 125 125 450 380 59 125 437 324 2125 40 2017 2030 41 123 621 450 2009 62 1500 605 2030 46 2126 40 41 614 1501 605 2016 46 2127 40 41 605 40 2016 46 2128 40 41 614 2015 46 2129 606 2016 46 2128 40 41 614 2015 46 2130 41 59 125 437 492 2131 40 2017 2030 41 123 621 2028 61 473 59 621 621 2018 61 2011 46 2132 40 2030 41 59 125 437 492 2133 40 2017 2094 44 404 2089 44 413 2088 41 123 621 2009 628 2088 59 324 2134 61 2089 614 1500 59 2015 2135 61 424 59 392 40 2016 46 2136 40 41 41 2135 61 2016 46 2137 40 41 59 2138 2139 59 392 40 2134 605 2135 614 2015 46 2140 41 123 2139 61 2138 46 2141 59 2019 61 2011 46 2142 40 2094 41 59 125 360 392 40 2134 605 2135 614 2015 46 2143 41 123 2139 61 2138 46 2144 59 2020 61 2011 46 2145 40 2094 41 59 621 2028 61 473 59 125 360 392 40 2134 605 2135 614 2015 46 2146 41 123 2139 61 2138 46 2147 59 621 621 621 2094 46 2148 40 2024 41 59 2021 61 2011 46 2149 40 2094 41 59 125 360 123 2139 61 2138 46 2150 59 125 2094 46 2151 40 2139 41 59 2026 46 2152 40 2094 41 59 2014 61 473 59 125 437 492 2153 40 2017 2094 44 404 2089 41 123 392 40 2154 40 2094 41 41 123 2094 46 2155 40 2156 46 2157 41 59 621 2028 61 473 59 125 360 123 621 621 621 392 40 2009 62 1500 605 2089 614 1501 605 2016 46 2158 40 41 605 40 2016 46 2159 40 41 614 2015 46 2160 606 2016 46 2159 40 41 614 2015 46 2161 41 41 123 2018 61 2011 46 2162 40 2094 41 59 621 2028 61 473 59 125 360 123 2094 46 2163 40 2164 46 2165 41 59 621 2028 61 473 59 125 125 125 437 324 2166 40 2017 2030 41 123 450 2030 46 2167 40 41 615 2168 40 41 59 125 437 404 2169 40 41 123 450 2170 46 2171 40 41 46 2172 40 41 63 2002 58 2170 46 2171 40 41 46 2173 40 41 63 2003 58 2004 59 125 621 621 621 64 2174 40 648 41 64 2175 457 2011 60 2015 62 2176 40 2177 2178 41 123 464 40 2178 41 123 328 2179 58 450 2011 46 2180 40 2015 46 2181 41 59 328 2182 58 450 2011 46 2180 40 2015 46 2183 41 59 328 2184 58 450 2011 46 2180 40 2015 46 2185 41 59 328 2186 58 450 2011 46 2180 40 2015 46 2187 41 59 328 2188 58 450 2011 46 2180 40 2015 46 2189 41 59 328 2190 58 450 2011 46 2180 40 2015 46 2191 41 59 328 2192 58 450 2011 46 2180 40 2015 46 2193 41 59 328 2194 58 450 2011 46 2180 40 2015 46 2195 41 59 349 58 450 2011 46 362 40 41 59 125 125 125 
31373,Java,"public class OnXJava7Style {
  @interface Foo {
    String value() default """";
  }
  @interface Bar {
    String stuff() default """";
  }
  @interface Array {
    String[] value() default {};
  }
  @lombok.Getter() String a;
  @lombok.Setter() String b;
  @lombok.Setter() String c;
  @lombok.Setter() String d;
  @lombok.Getter() String e;
  @lombok.Getter() String f;
  @lombok.Getter() String g;
  @lombok.Getter() String h;
  @lombok.Getter() String i;
  public OnXJava7Style() {
    super();
  }
  public @Foo @java.lang.SuppressWarnings(""all"") String getA() {
    return this.a;
  }
  public @Foo() @java.lang.SuppressWarnings(""all"") void setB(final String b) {
    this.b = b;
  }
  public @java.lang.SuppressWarnings(""all"") void setC(final @Foo(""a"") String c) {
    this.c = c;
  }
  public @java.lang.SuppressWarnings(""all"") void setD(final @Bar(stuff = ""b"") String d) {
    this.d = d;
  }
  public @Foo(value = ""c"") @Bar(stuff = ""d"") @java.lang.SuppressWarnings(""all"") String getE() {
    return this.e;
  }
  public @Array @java.lang.SuppressWarnings(""all"") String getF() {
    return this.f;
  }
  public @Array() @java.lang.SuppressWarnings(""all"") String getG() {
    return this.g;
  }
  public @Array({}) @java.lang.SuppressWarnings(""all"") String getH() {
    return this.h;
  }
  public @Array({""a"", ""b""}) @java.lang.SuppressWarnings(""all"") String getI() {
    return this.i;
  }
}",1,439 334 2000 123 64 405 2001 123 2002 2003 40 41 349 648 59 125 64 405 2004 123 2005 2006 40 41 349 648 59 125 64 405 2007 123 2008 91 93 2009 40 41 349 123 125 59 125 64 2010 46 2011 40 41 2012 2013 59 64 2010 46 2014 40 41 2012 2015 59 64 2010 46 2014 40 41 2012 2016 59 64 2010 46 2014 40 41 2012 2017 59 64 2010 46 2011 40 41 2012 2018 59 64 2010 46 2011 40 41 2012 2019 59 64 2010 46 2011 40 41 2012 2020 59 64 2010 46 2011 40 41 2012 2021 59 64 2010 46 2011 40 41 2012 2022 59 439 2000 40 41 123 463 40 41 59 125 439 64 2001 64 2023 46 2024 46 2025 40 648 41 2012 2026 40 41 123 450 467 46 2013 59 125 439 64 2001 40 41 64 2023 46 2024 46 2025 40 648 41 492 2027 40 381 2012 2015 41 123 467 46 2015 61 2015 59 125 439 64 2023 46 2024 46 2025 40 648 41 492 2028 40 381 64 2001 40 648 41 2012 2016 41 123 467 46 2016 61 2016 59 125 439 64 2023 46 2024 46 2025 40 648 41 492 2029 40 381 64 2004 40 2030 61 648 41 2012 2017 41 123 467 46 2017 61 2017 59 125 439 64 2001 40 2031 61 648 41 64 2004 40 2030 61 648 41 64 2023 46 2024 46 2025 40 648 41 2012 2032 40 41 123 450 467 46 2018 59 125 439 64 2007 64 2023 46 2024 46 2025 40 648 41 2012 2033 40 41 123 450 467 46 2019 59 125 439 64 2007 40 41 64 2023 46 2024 46 2025 40 648 41 2012 2034 40 41 123 450 467 46 2020 59 125 439 64 2007 40 123 125 41 64 2023 46 2024 46 2025 40 648 41 2012 2035 40 41 123 450 467 46 2021 59 125 439 64 2007 40 123 648 44 648 125 41 64 2023 46 2024 46 2025 40 648 41 2012 2036 40 41 123 450 467 46 2022 59 125 125 
2966,Java,"@Slf4j
public class AccountAgeWitnessService {
    private static final Date RELEASE = Utilities.getUTCDate(2017, GregorianCalendar.NOVEMBER, 11);
    private static final long SAFE_ACCOUNT_AGE_DATE = Utilities.getUTCDate(2019, GregorianCalendar.MARCH, 1).getTime();

    public enum AccountAge {
        UNVERIFIED,
        LESS_ONE_MONTH,
        ONE_TO_TWO_MONTHS,
        TWO_MONTHS_OR_MORE
    }

    public enum SignState {
        UNSIGNED(Res.get(""offerbook.timeSinceSigning.notSigned"")),
        ARBITRATOR(Res.get(""offerbook.timeSinceSigning.info.arbitrator"")),
        PEER_INITIAL(Res.get(""offerbook.timeSinceSigning.info.peer"")),
        PEER_LIMIT_LIFTED(Res.get(""offerbook.timeSinceSigning.info.peerLimitLifted"")),
        PEER_SIGNER(Res.get(""offerbook.timeSinceSigning.info.signer"")),
        BANNED(Res.get(""offerbook.timeSinceSigning.info.banned""));

        private String displayString;
        private String hash = """";
        private long daysUntilLimitLifted = 0;

        SignState(String displayString) {
            this.displayString = displayString;
        }

        public SignState addHash(String hash) {
            this.hash = hash;
            return this;
        }

        public SignState setDaysUntilLimitLifted(long days) {
            this.daysUntilLimitLifted = days;
            return this;
        }

        public String getDisplayString() {
            if (!hash.isEmpty()) { // Only showing in DEBUG mode
                return displayString + "" "" + hash;
            }
            return String.format(displayString, daysUntilLimitLifted);
        }

        public boolean isLimitLifted() {
            return this == PEER_LIMIT_LIFTED || this == PEER_SIGNER || this == ARBITRATOR;
        }

    }

    private final KeyRing keyRing;
    private final P2PService p2PService;
    private final User user;
    private final SignedWitnessService signedWitnessService;
    private final ChargeBackRisk chargeBackRisk;
    private final AccountAgeWitnessStorageService accountAgeWitnessStorageService;
    private final Clock clock;
    private final FilterManager filterManager;
    @Getter
    private final AccountAgeWitnessUtils accountAgeWitnessUtils;

    private final Map<P2PDataStorage.ByteArray, AccountAgeWitness> accountAgeWitnessMap = new HashMap<>();

    // The accountAgeWitnessMap is very large (70k items) and access is a bit expensive. We usually only access less
    // than 100 items, those who have offers online. So we use a cache for a fast lookup and only if
    // not found there we use the accountAgeWitnessMap and put then the new item into our cache.
    private final Map<P2PDataStorage.ByteArray, AccountAgeWitness> accountAgeWitnessCache = new ConcurrentHashMap<>();


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////


    @Inject
    public AccountAgeWitnessService(KeyRing keyRing,
                                    P2PService p2PService,
                                    User user,
                                    SignedWitnessService signedWitnessService,
                                    ChargeBackRisk chargeBackRisk,
                                    AccountAgeWitnessStorageService accountAgeWitnessStorageService,
                                    AppendOnlyDataStoreService appendOnlyDataStoreService,
                                    Clock clock,
                                    FilterManager filterManager) {
        this.keyRing = keyRing;
        this.p2PService = p2PService;
        this.user = user;
        this.signedWitnessService = signedWitnessService;
        this.chargeBackRisk = chargeBackRisk;
        this.accountAgeWitnessStorageService = accountAgeWitnessStorageService;
        this.clock = clock;
        this.filterManager = filterManager;

        accountAgeWitnessUtils = new AccountAgeWitnessUtils(
                this,
                signedWitnessService,
                keyRing);

        // We need to add that early (before onAllServicesInitialized) as it will be used at startup.
        appendOnlyDataStoreService.addService(accountAgeWitnessStorageService);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void onAllServicesInitialized() {
        p2PService.getP2PDataStorage().addAppendOnlyDataStoreListener(payload -> {
            if (payload instanceof AccountAgeWitness)
                addToMap((AccountAgeWitness) payload);
        });

        // At startup the P2PDataStorage initializes earlier, otherwise we get the listener called.
        accountAgeWitnessStorageService.getMapOfAllData().values().stream()
                .filter(e -> e instanceof AccountAgeWitness)
                .map(e -> (AccountAgeWitness) e)
                .forEach(this::addToMap);

        if (p2PService.isBootstrapped()) {
            onBootStrapped();
        } else {
            p2PService.addP2PServiceListener(new BootstrapListener() {
                @Override
                public void onUpdatedDataReceived() {
                    onBootStrapped();
                }
            });
        }
    }

    private void onBootStrapped() {
        republishAllFiatAccounts();
        signAndPublishSameNameAccounts();
    }


    // At startup we re-publish the witness data of all fiat accounts to ensure we got our data well distributed.
    private void republishAllFiatAccounts() {
        if (user.getPaymentAccounts() != null)
            user.getPaymentAccounts().stream()
                    .filter(account -> !(account instanceof AssetAccount))
                    .forEach(account -> {
                        AccountAgeWitness myWitness = getMyWitness(account.getPaymentAccountPayload());
                        // We only publish if the date of our witness is inside the date tolerance.
                        // It would be rejected otherwise from the peers.
                        if (myWitness.isDateInTolerance(clock)) {
                            // We delay with a random interval of 20-60 sec to ensure to be better connected and don't
                            // stress the P2P network with publishing all at once at startup time.
                            int delayInSec = 20 + new Random().nextInt(40);
                            UserThread.runAfter(() ->
                                    p2PService.addPersistableNetworkPayload(myWitness, true), delayInSec);
                        }
                    });
    }

    @VisibleForTesting
    public void addToMap(AccountAgeWitness accountAgeWitness) {
        accountAgeWitnessMap.putIfAbsent(accountAgeWitness.getHashAsByteArray(), accountAgeWitness);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Generic
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void publishMyAccountAgeWitness(PaymentAccountPayload paymentAccountPayload) {
        AccountAgeWitness accountAgeWitness = getMyWitness(paymentAccountPayload);
        P2PDataStorage.ByteArray hash = accountAgeWitness.getHashAsByteArray();

        // We use first our fast lookup cache. If its in accountAgeWitnessCache it is also in accountAgeWitnessMap
        // and we do not publish.
        if (accountAgeWitnessCache.containsKey(hash)) {
            return;
        }

        if (!accountAgeWitnessMap.containsKey(hash)) {
            p2PService.addPersistableNetworkPayload(accountAgeWitness, false);
        }
    }

    public byte[] getPeerAccountAgeWitnessHash(Trade trade) {
        return findTradePeerWitness(trade)
                .map(AccountAgeWitness::getHash)
                .orElse(null);
    }

    byte[] getAccountInputDataWithSalt(PaymentAccountPayload paymentAccountPayload) {
        return Utilities.concatenateByteArrays(paymentAccountPayload.getAgeWitnessInputData(),
                paymentAccountPayload.getSalt());
    }

    @VisibleForTesting
    public AccountAgeWitness getNewWitness(PaymentAccountPayload paymentAccountPayload, PubKeyRing pubKeyRing) {
        byte[] accountInputDataWithSalt = getAccountInputDataWithSalt(paymentAccountPayload);
        byte[] hash = Hash.getSha256Ripemd160hash(Utilities.concatenateByteArrays(accountInputDataWithSalt,
                pubKeyRing.getSignaturePubKeyBytes()));
        return new AccountAgeWitness(hash, new Date().getTime());
    }

    Optional<AccountAgeWitness> findWitness(PaymentAccountPayload paymentAccountPayload,
                                            PubKeyRing pubKeyRing) {
        if (paymentAccountPayload == null) {
            return Optional.empty();
        }

        byte[] accountInputDataWithSalt = getAccountInputDataWithSalt(paymentAccountPayload);
        byte[] hash = Hash.getSha256Ripemd160hash(Utilities.concatenateByteArrays(accountInputDataWithSalt,
                pubKeyRing.getSignaturePubKeyBytes()));

        return getWitnessByHash(hash);
    }

    public Optional<AccountAgeWitness> findWitness(Offer offer) {
        final Optional<String> accountAgeWitnessHash = offer.getAccountAgeWitnessHashAsHex();
        return accountAgeWitnessHash.isPresent() ?
                getWitnessByHashAsHex(accountAgeWitnessHash.get()) :
                Optional.empty();
    }

    private Optional<AccountAgeWitness> findTradePeerWitness(Trade trade) {
        TradingPeer tradingPeer = trade.getProcessModel().getTradePeer();
        return (tradingPeer == null ||
                tradingPeer.getPaymentAccountPayload() == null ||
                tradingPeer.getPubKeyRing() == null) ?
                Optional.empty() :
                findWitness(tradingPeer.getPaymentAccountPayload(), tradingPeer.getPubKeyRing());
    }

    private Optional<AccountAgeWitness> getWitnessByHash(byte[] hash) {
        P2PDataStorage.ByteArray hashAsByteArray = new P2PDataStorage.ByteArray(hash);

        // First we look up in our fast lookup cache
        if (accountAgeWitnessCache.containsKey(hashAsByteArray)) {
            return Optional.of(accountAgeWitnessCache.get(hashAsByteArray));
        }

        if (accountAgeWitnessMap.containsKey(hashAsByteArray)) {
            AccountAgeWitness accountAgeWitness = accountAgeWitnessMap.get(hashAsByteArray);

            // We add it to our fast lookup cache
            accountAgeWitnessCache.put(hashAsByteArray, accountAgeWitness);

            return Optional.of(accountAgeWitness);
        }

        return Optional.empty();
    }

    private Optional<AccountAgeWitness> getWitnessByHashAsHex(String hashAsHex) {
        return getWitnessByHash(Utilities.decodeFromHex(hashAsHex));
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Witness age
    ///////////////////////////////////////////////////////////////////////////////////////////

    public long getAccountAge(AccountAgeWitness accountAgeWitness, Date now) {
        log.debug(""getAccountAge now={}, accountAgeWitness.getDate()={}"", now.getTime(), accountAgeWitness.getDate());
        return now.getTime() - accountAgeWitness.getDate();
    }

    // Return -1 if no witness found
    public long getAccountAge(PaymentAccountPayload paymentAccountPayload, PubKeyRing pubKeyRing) {
        return findWitness(paymentAccountPayload, pubKeyRing)
                .map(accountAgeWitness -> getAccountAge(accountAgeWitness, new Date()))
                .orElse(-1L);
    }

    public long getAccountAge(Offer offer) {
        return findWitness(offer)
                .map(accountAgeWitness -> getAccountAge(accountAgeWitness, new Date()))
                .orElse(-1L);
    }

    public long getAccountAge(Trade trade) {
        return findTradePeerWitness(trade)
                .map(accountAgeWitness -> getAccountAge(accountAgeWitness, new Date()))
                .orElse(-1L);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Signed age
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Return -1 if not signed
    public long getWitnessSignAge(AccountAgeWitness accountAgeWitness, Date now) {
        List<Long> dates = signedWitnessService.getVerifiedWitnessDateList(accountAgeWitness);
        if (dates.isEmpty()) {
            return -1L;
        } else {
            return now.getTime() - dates.get(0);
        }
    }

    // Return -1 if not signed
    public long getWitnessSignAge(Offer offer, Date now) {
        return findWitness(offer)
                .map(witness -> getWitnessSignAge(witness, now))
                .orElse(-1L);
    }

    public long getWitnessSignAge(Trade trade, Date now) {
        return findTradePeerWitness(trade)
                .map(witness -> getWitnessSignAge(witness, now))
                .orElse(-1L);
    }

    public AccountAge getPeersAccountAgeCategory(long peersAccountAge) {
        return getAccountAgeCategory(peersAccountAge);
    }

    private AccountAge getAccountAgeCategory(long accountAge) {
        if (accountAge < 0) {
            return AccountAge.UNVERIFIED;
        } else if (accountAge < TimeUnit.DAYS.toMillis(30)) {
            return AccountAge.LESS_ONE_MONTH;
        } else if (accountAge < TimeUnit.DAYS.toMillis(60)) {
            return AccountAge.ONE_TO_TWO_MONTHS;
        } else {
            return AccountAge.TWO_MONTHS_OR_MORE;
        }
    }

    // Get trade limit based on a time schedule
    // Buying of BTC with a payment method that has chargeback risk will use a low trade limit schedule
    // All selling and all other fiat payment methods use the normal trade limit schedule
    // Non fiat always has max limit
    // Account types that can get signed will use time since signing, other methods use time since account age creation
    // when measuring account age
    private long getTradeLimit(Coin maxTradeLimit,
                               String currencyCode,
                               AccountAgeWitness accountAgeWitness,
                               AccountAge accountAgeCategory,
                               OfferDirection direction,
                               PaymentMethod paymentMethod) {
        if (CurrencyUtil.isCryptoCurrency(currencyCode) ||
                !PaymentMethod.hasChargebackRisk(paymentMethod, currencyCode) ||
                direction == OfferDirection.SELL) {
            return maxTradeLimit.value;
        }

        long limit = OfferRestrictions.TOLERATED_SMALL_TRADE_AMOUNT.value;
        var factor = signedBuyFactor(accountAgeCategory);
        if (factor > 0) {
            limit = MathUtils.roundDoubleToLong((double) maxTradeLimit.value * factor);
        }

        log.debug(""limit={}, factor={}, accountAgeWitnessHash={}"",
                Coin.valueOf(limit).toFriendlyString(),
                factor,
                Utilities.bytesAsHexString(accountAgeWitness.getHash()));
        return limit;
    }

    private double signedBuyFactor(AccountAge accountAgeCategory) {
        switch (accountAgeCategory) {
            case TWO_MONTHS_OR_MORE:
                return 1;
            case ONE_TO_TWO_MONTHS:
                return 0.5;
            case LESS_ONE_MONTH:
            case UNVERIFIED:
            default:
                return 0;
        }
    }

    private double normalFactor() {
        return 1;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Trade limit exceptions
    ///////////////////////////////////////////////////////////////////////////////////////////

    private boolean isImmature(AccountAgeWitness accountAgeWitness) {
        return accountAgeWitness.getDate() > SAFE_ACCOUNT_AGE_DATE;
    }

    public boolean myHasTradeLimitException(PaymentAccount myPaymentAccount) {
        return hasTradeLimitException(getMyWitness(myPaymentAccount.getPaymentAccountPayload()));
    }

    // There are no trade limits on accounts that
    // - are mature
    // - were signed by an arbitrator
    private boolean hasTradeLimitException(AccountAgeWitness accountAgeWitness) {
        return !isImmature(accountAgeWitness) || signedWitnessService.isSignedByArbitrator(accountAgeWitness);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // My witness
    ///////////////////////////////////////////////////////////////////////////////////////////

    public AccountAgeWitness getMyWitness(PaymentAccountPayload paymentAccountPayload) {
        final Optional<AccountAgeWitness> accountAgeWitnessOptional =
                findWitness(paymentAccountPayload, keyRing.getPubKeyRing());
        return accountAgeWitnessOptional.orElseGet(() -> getNewWitness(paymentAccountPayload, keyRing.getPubKeyRing()));
    }

    private byte[] getMyWitnessHash(PaymentAccountPayload paymentAccountPayload) {
        return getMyWitness(paymentAccountPayload).getHash();
    }

    public String getMyWitnessHashAsHex(PaymentAccountPayload paymentAccountPayload) {
        return Utilities.bytesAsHexString(getMyWitnessHash(paymentAccountPayload));
    }

    public long getMyAccountAge(PaymentAccountPayload paymentAccountPayload) {
        return getAccountAge(getMyWitness(paymentAccountPayload), new Date());
    }

    public long getMyTradeLimit(PaymentAccount paymentAccount, String currencyCode, OfferDirection direction) {
        if (paymentAccount == null)
            return 0;

        AccountAgeWitness accountAgeWitness = getMyWitness(paymentAccount.getPaymentAccountPayload());
        Coin maxTradeLimit = paymentAccount.getPaymentMethod().getMaxTradeLimitAsCoin(currencyCode);
        if (hasTradeLimitException(accountAgeWitness)) {
            return maxTradeLimit.value;
        }
        final long accountSignAge = getWitnessSignAge(accountAgeWitness, new Date());
        AccountAge accountAgeCategory = getAccountAgeCategory(accountSignAge);

        return getTradeLimit(maxTradeLimit,
                currencyCode,
                accountAgeWitness,
                accountAgeCategory,
                direction,
                paymentAccount.getPaymentMethod());
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Verification
    ///////////////////////////////////////////////////////////////////////////////////////////

    public boolean verifyAccountAgeWitness(Trade trade,
                                           PaymentAccountPayload peersPaymentAccountPayload,
                                           Date peersCurrentDate,
                                           PubKeyRing peersPubKeyRing,
                                           byte[] nonce,
                                           byte[] signature,
                                           ErrorMessageHandler errorMessageHandler) {
        final Optional<AccountAgeWitness> accountAgeWitnessOptional =
                findWitness(peersPaymentAccountPayload, peersPubKeyRing);
        // If we don't find a stored witness data we create a new dummy object which makes is easier to reuse the
        // below validation methods. This peersWitness object is not used beside for validation. Some of the
        // validation calls are pointless in the case we create a new Witness ourselves but the verifyPeersTradeLimit
        // need still be called, so we leave also the rest for sake of simplicity.
        AccountAgeWitness peersWitness;
        if (accountAgeWitnessOptional.isPresent()) {
            peersWitness = accountAgeWitnessOptional.get();
        } else {
            peersWitness = getNewWitness(peersPaymentAccountPayload, peersPubKeyRing);
            log.warn(""We did not find the peers witness data. That is expected with peers using an older version."");
        }

        // Check if date in witness is not older than the release date of that feature (was added in v0.6)
        if (!isDateAfterReleaseDate(peersWitness.getDate(), RELEASE, errorMessageHandler))
            return false;

        // Check if peer current date is in tolerance range
        if (!verifyPeersCurrentDate(peersCurrentDate, errorMessageHandler))
            return false;

        final byte[] peersAccountInputDataWithSalt = Utilities.concatenateByteArrays(
                peersPaymentAccountPayload.getAgeWitnessInputData(), peersPaymentAccountPayload.getSalt());
        byte[] hash = Hash.getSha256Ripemd160hash(Utilities.concatenateByteArrays(peersAccountInputDataWithSalt,
                peersPubKeyRing.getSignaturePubKeyBytes()));

        // Check if the hash in the witness data matches the hash derived from the data provided by the peer
        final byte[] peersWitnessHash = peersWitness.getHash();
        if (!verifyWitnessHash(peersWitnessHash, hash, errorMessageHandler))
            return false;

        // Check if the peers trade limit is not less than the trade amount
        if (!verifyPeersTradeLimit(trade.getOffer(), trade.getAmount(), peersWitness, peersCurrentDate,
                errorMessageHandler)) {
            log.error(""verifyPeersTradeLimit failed: peersPaymentAccountPayload {}"", peersPaymentAccountPayload);
            return false;
        }
        // Check if the signature is correct
        return verifySignature(peersPubKeyRing.getSignaturePubKey(), nonce, signature, errorMessageHandler);
    }

    public boolean verifyPeersTradeAmount(Offer offer,
                                          Coin tradeAmount,
                                          ErrorMessageHandler errorMessageHandler) {
        checkNotNull(offer);

        // In case we don't find the witness we check if the trade amount is above the
        // TOLERATED_SMALL_TRADE_AMOUNT (0.01 BTC) and only in that case return false.
        return findWitness(offer)
                .map(witness -> verifyPeersTradeLimit(offer, tradeAmount, witness, new Date(), errorMessageHandler))
                .orElse(isToleratedSmalleAmount(tradeAmount));
    }

    private boolean isToleratedSmalleAmount(Coin tradeAmount) {
        return tradeAmount.value <= OfferRestrictions.TOLERATED_SMALL_TRADE_AMOUNT.value;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Package scope verification subroutines
    ///////////////////////////////////////////////////////////////////////////////////////////

    boolean isDateAfterReleaseDate(long witnessDateAsLong,
                                   Date ageWitnessReleaseDate,
                                   ErrorMessageHandler errorMessageHandler) {
        // Release date minus 1 day as tolerance for not synced clocks
        Date releaseDateWithTolerance = new Date(ageWitnessReleaseDate.getTime() - TimeUnit.DAYS.toMillis(1));
        final Date witnessDate = new Date(witnessDateAsLong);
        final boolean result = witnessDate.after(releaseDateWithTolerance);
        if (!result) {
            final String msg = ""Witness date is set earlier than release date of ageWitness feature. "" +
                    ""ageWitnessReleaseDate="" + ageWitnessReleaseDate + "", witnessDate="" + witnessDate;
            log.warn(msg);
            errorMessageHandler.handleErrorMessage(msg);
        }
        return result;
    }

    private boolean verifyPeersCurrentDate(Date peersCurrentDate, ErrorMessageHandler errorMessageHandler) {
        boolean result = Math.abs(peersCurrentDate.getTime() - new Date().getTime()) <= TimeUnit.DAYS.toMillis(1);
        if (!result) {
            String msg = ""Peers current date is further than 1 day off to our current date. "" +
                    ""PeersCurrentDate="" + peersCurrentDate + ""; myCurrentDate="" + new Date();
            log.warn(msg);
            errorMessageHandler.handleErrorMessage(msg);
        }
        return result;
    }

    private boolean verifyWitnessHash(byte[] witnessHash,
                                      byte[] hash,
                                      ErrorMessageHandler errorMessageHandler) {
        final boolean result = Arrays.equals(witnessHash, hash);
        if (!result) {
            final String msg = ""witnessHash is not matching peers hash. "" +
                    ""witnessHash="" + Utilities.bytesAsHexString(witnessHash) + "", hash="" + Utilities.bytesAsHexString(hash);
            log.warn(msg);
            errorMessageHandler.handleErrorMessage(msg);
        }
        return result;
    }

    private boolean verifyPeersTradeLimit(Offer offer,
                                          Coin tradeAmount,
                                          AccountAgeWitness peersWitness,
                                          Date peersCurrentDate,
                                          ErrorMessageHandler errorMessageHandler) {
        checkNotNull(offer);
        final String currencyCode = offer.getCurrencyCode();
        final Coin defaultMaxTradeLimit = offer.getPaymentMethod().getMaxTradeLimitAsCoin(currencyCode);
        long peersCurrentTradeLimit = defaultMaxTradeLimit.value;
        if (!hasTradeLimitException(peersWitness)) {
            final long accountSignAge = getWitnessSignAge(peersWitness, peersCurrentDate);
            AccountAge accountAgeCategory = getPeersAccountAgeCategory(accountSignAge);
            OfferDirection direction = offer.isMyOffer(keyRing) ?
                    offer.getMirroredDirection() : offer.getDirection();
            peersCurrentTradeLimit = getTradeLimit(defaultMaxTradeLimit, currencyCode, peersWitness,
                    accountAgeCategory, direction, offer.getPaymentMethod());
        }
        // Makers current trade limit cannot be smaller than that in the offer
        boolean result = tradeAmount.value <= peersCurrentTradeLimit;
        if (!result) {
            String msg = ""The peers trade limit is less than the traded amount.\n"" +
                    ""tradeAmount="" + tradeAmount.toFriendlyString() +
                    ""\nPeers trade limit="" + Coin.valueOf(peersCurrentTradeLimit).toFriendlyString() +
                    ""\nOffer ID="" + offer.getShortId() +
                    ""\nPaymentMethod="" + offer.getPaymentMethod().getId() +
                    ""\nCurrencyCode="" + offer.getCurrencyCode();
            log.warn(msg);
            errorMessageHandler.handleErrorMessage(msg);
        }
        return result;
    }

    boolean verifySignature(PublicKey peersPublicKey,
                            byte[] nonce,
                            byte[] signature,
                            ErrorMessageHandler errorMessageHandler) {
        boolean result;
        try {
            result = Sig.verify(peersPublicKey, nonce, signature);
        } catch (CryptoException e) {
            log.warn(e.toString());
            result = false;
        }
        if (!result) {
            final String msg = ""Signature of nonce is not correct. "" +
                    ""peersPublicKey="" + peersPublicKey + "", nonce(hex)="" + Utilities.bytesAsHexString(nonce) +
                    "", signature="" + Utilities.bytesAsHexString(signature);
            log.warn(msg);
            errorMessageHandler.handleErrorMessage(msg);
        }
        return result;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Witness signing
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void arbitratorSignAccountAgeWitness(Coin tradeAmount,
                                                AccountAgeWitness accountAgeWitness,
                                                ECKey key,
                                                PublicKey peersPubKey) {
        signedWitnessService.signAndPublishAccountAgeWitness(tradeAmount, accountAgeWitness, key, peersPubKey);
    }

    public String arbitratorSignOrphanWitness(AccountAgeWitness accountAgeWitness,
                                              ECKey ecKey,
                                              long time) {
        // TODO Is not found signedWitness considered an error case?
        //  Previous code version was throwing an exception in case no signedWitness was found...

        // signAndPublishAccountAgeWitness returns an empty string in success case and error otherwise
        return signedWitnessService.getSignedWitnessSet(accountAgeWitness).stream()
                .findAny()
                .map(SignedWitness::getWitnessOwnerPubKey)
                .map(witnessOwnerPubKey ->
                        signedWitnessService.signAndPublishAccountAgeWitness(accountAgeWitness, ecKey,
                                witnessOwnerPubKey, time)
                )
                .orElse(""No signedWitness found"");
    }

    public String arbitratorSignOrphanPubKey(ECKey key,
                                             byte[] peersPubKey,
                                             long childSignTime) {
        return signedWitnessService.signTraderPubKey(key, peersPubKey, childSignTime);
    }

    public void arbitratorSignAccountAgeWitness(AccountAgeWitness accountAgeWitness,
                                                ECKey key,
                                                byte[] tradersPubKey,
                                                long time) {
        signedWitnessService.signAndPublishAccountAgeWitness(accountAgeWitness, key, tradersPubKey, time);
    }

    public Optional<SignedWitness> traderSignAndPublishPeersAccountAgeWitness(Trade trade) {
        AccountAgeWitness peersWitness = findTradePeerWitness(trade).orElse(null);
        Coin tradeAmount = trade.getAmount();
        checkNotNull(trade.getProcessModel().getTradePeer().getPubKeyRing(), ""Peer must have a keyring"");
        PublicKey peersPubKey = trade.getProcessModel().getTradePeer().getPubKeyRing().getSignaturePubKey();
        checkNotNull(peersWitness, ""Not able to find peers witness, unable to sign for trade {}"",
                trade.toString());
        checkNotNull(tradeAmount, ""Trade amount must not be null"");
        checkNotNull(peersPubKey, ""Peers pub key must not be null"");

        try {
            return signedWitnessService.signAndPublishAccountAgeWitness(tradeAmount, peersWitness, peersPubKey);
        } catch (CryptoException e) {
            log.warn(""Trader failed to sign witness, exception {}"", e.toString());
        }
        return Optional.empty();
    }

    public boolean publishOwnSignedWitness(SignedWitness signedWitness) {
        return signedWitnessService.publishOwnSignedWitness(signedWitness);
    }

    // Arbitrator signing
    public List<TraderDataItem> getTraderPaymentAccounts(long safeDate,
                                                         PaymentMethod paymentMethod,
                                                         List<Dispute> disputes) {
        return disputes.stream()
                .filter(dispute -> dispute.getContract().getPaymentMethodId().equals(paymentMethod.getId()))
                .filter(this::isNotFiltered)
                .filter(this::hasChargebackRisk)
                .filter(this::isBuyerWinner)
                .flatMap(this::getTraderData)
                .filter(Objects::nonNull)
                .filter(traderDataItem ->
                        !signedWitnessService.isSignedAccountAgeWitness(traderDataItem.getAccountAgeWitness()))
                .filter(traderDataItem -> traderDataItem.getAccountAgeWitness().getDate() < safeDate)
                .distinct()
                .collect(Collectors.toList());
    }

    private boolean isNotFiltered(Dispute dispute) {
        boolean isFiltered = filterManager.isNodeAddressBanned(dispute.getContract().getBuyerNodeAddress()) ||
                filterManager.isNodeAddressBanned(dispute.getContract().getSellerNodeAddress()) ||
                filterManager.isCurrencyBanned(dispute.getContract().getOfferPayload().getCurrencyCode()) ||
                filterManager.isPaymentMethodBanned(
                        PaymentMethod.getPaymentMethod(dispute.getContract().getPaymentMethodId())) ||
                filterManager.arePeersPaymentAccountDataBanned(dispute.getContract().getBuyerPaymentAccountPayload()) ||
                filterManager.arePeersPaymentAccountDataBanned(
                        dispute.getContract().getSellerPaymentAccountPayload()) ||
                filterManager.isWitnessSignerPubKeyBanned(
                        Utils.HEX.encode(dispute.getContract().getBuyerPubKeyRing().getSignaturePubKeyBytes())) ||
                filterManager.isWitnessSignerPubKeyBanned(
                        Utils.HEX.encode(dispute.getContract().getSellerPubKeyRing().getSignaturePubKeyBytes()));
        return !isFiltered;
    }

    @VisibleForTesting
    public boolean hasChargebackRisk(Dispute dispute) {
        return chargeBackRisk.hasChargebackRisk(dispute.getContract().getPaymentMethodId(),
                dispute.getContract().getOfferPayload().getCurrencyCode());
    }

    private boolean isBuyerWinner(Dispute dispute) {
        if (!dispute.isClosed() || dispute.getDisputeResultProperty() == null)
            return false;
        return dispute.getDisputeResultProperty().get().getWinner() == DisputeResult.Winner.BUYER;
    }

    private Stream<TraderDataItem> getTraderData(Dispute dispute) {
        Coin tradeAmount = dispute.getContract().getTradeAmount();

        PubKeyRing buyerPubKeyRing = dispute.getContract().getBuyerPubKeyRing();
        PubKeyRing sellerPubKeyRing = dispute.getContract().getSellerPubKeyRing();

        PaymentAccountPayload buyerPaymentAccountPaload = dispute.getContract().getBuyerPaymentAccountPayload();
        PaymentAccountPayload sellerPaymentAccountPaload = dispute.getContract().getSellerPaymentAccountPayload();

        TraderDataItem buyerData = findWitness(buyerPaymentAccountPaload, buyerPubKeyRing)
                .map(witness -> new TraderDataItem(
                        buyerPaymentAccountPaload,
                        witness,
                        tradeAmount,
                        buyerPubKeyRing.getSignaturePubKey()))
                .orElse(null);
        TraderDataItem sellerData = findWitness(sellerPaymentAccountPaload, sellerPubKeyRing)
                .map(witness -> new TraderDataItem(
                        sellerPaymentAccountPaload,
                        witness,
                        tradeAmount,
                        sellerPubKeyRing.getSignaturePubKey()))
                .orElse(null);
        return Stream.of(buyerData, sellerData);
    }

    public boolean hasSignedWitness(Offer offer) {
        return findWitness(offer)
                .map(signedWitnessService::isSignedAccountAgeWitness)
                .orElse(false);
    }

    public boolean peerHasSignedWitness(Trade trade) {
        return findTradePeerWitness(trade)
                .map(signedWitnessService::isSignedAccountAgeWitness)
                .orElse(false);
    }

    public boolean accountIsSigner(AccountAgeWitness accountAgeWitness) {
        return signedWitnessService.isSignerAccountAgeWitness(accountAgeWitness);
    }

    public boolean tradeAmountIsSufficient(Coin tradeAmount) {
        return signedWitnessService.isSufficientTradeAmountForSigning(tradeAmount);
    }

    public SignState getSignState(Offer offer) {
        return findWitness(offer)
                .map(this::getSignState)
                .orElse(SignState.UNSIGNED);
    }

    public SignState getSignState(Trade trade) {
        return findTradePeerWitness(trade)
                .map(this::getSignState)
                .orElse(SignState.UNSIGNED);
    }

    public SignState getSignState(AccountAgeWitness accountAgeWitness) {
        // Add hash to sign state info when running in debug mode
        String hash = log.isDebugEnabled() ? Utilities.bytesAsHexString(accountAgeWitness.getHash()) + ""\n"" +
                signedWitnessService.ownerPubKeyAsString(accountAgeWitness) : """";
        if (signedWitnessService.isFilteredWitness(accountAgeWitness)) {
            return SignState.BANNED.addHash(hash);
        }
        if (signedWitnessService.isSignedByArbitrator(accountAgeWitness)) {
            return SignState.ARBITRATOR.addHash(hash);
        } else {
            final long accountSignAge = getWitnessSignAge(accountAgeWitness, new Date());
            switch (getAccountAgeCategory(accountSignAge)) {
                case TWO_MONTHS_OR_MORE:
                case ONE_TO_TWO_MONTHS:
                    return SignState.PEER_SIGNER.addHash(hash);
                case LESS_ONE_MONTH:
                    return SignState.PEER_INITIAL.addHash(hash)
                            .setDaysUntilLimitLifted(30 - TimeUnit.MILLISECONDS.toDays(accountSignAge));
                case UNVERIFIED:
                default:
                    return SignState.UNSIGNED.addHash(hash);
            }
        }
    }

    public Set<AccountAgeWitness> getOrphanSignedWitnesses() {
        return signedWitnessService.getRootSignedWitnessSet(false).stream()
                .map(signedWitness -> getWitnessByHash(signedWitness.getAccountAgeWitnessHash()).orElse(null))
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }

    public void signAndPublishSameNameAccounts() {
        // Collect accounts that have ownerId to sign unsigned accounts with the same ownderId
        var signerAccounts = Objects.requireNonNull(user.getPaymentAccounts()).stream()
                .filter(account -> account.getOwnerId() != null &&
                        accountIsSigner(getMyWitness(account.getPaymentAccountPayload())))
                .collect(Collectors.toSet());
        var unsignedAccounts = user.getPaymentAccounts().stream()
                .filter(account -> account.getOwnerId() != null &&
                        !signedWitnessService.isSignedAccountAgeWitness(
                                getMyWitness(account.getPaymentAccountPayload())))
                .collect(Collectors.toSet());

        signerAccounts.forEach(signer -> unsignedAccounts.forEach(unsigned -> {
            if (signer.getOwnerId().equals(unsigned.getOwnerId())) {
                try {
                    signedWitnessService.selfSignAndPublishAccountAgeWitness(
                            getMyWitness(unsigned.getPaymentAccountPayload()));
                } catch (CryptoException e) {
                    log.warn(""Self signing failed, exception {}"", e.toString());
                }
            }
        }));
    }

    public Set<SignedWitness> getUnsignedSignerPubKeys() {
        return signedWitnessService.getUnsignedSignerPubKeys();
    }

    public boolean isSignWitnessTrade(Trade trade) {
        checkNotNull(trade, ""trade must not be null"");
        checkNotNull(trade.getOffer(), ""offer must not be null"");
        Contract contract = checkNotNull(trade.getContract());
        PaymentAccountPayload sellerPaymentAccountPayload = contract.getSellerPaymentAccountPayload();
        AccountAgeWitness myWitness = getMyWitness(sellerPaymentAccountPayload);

        getAccountAgeWitnessUtils().witnessDebugLog(trade, myWitness);

        return accountIsSigner(myWitness) &&
                !peerHasSignedWitness(trade) &&
                tradeAmountIsSufficient(trade.getAmount());
    }

    public String getSignInfoFromAccount(PaymentAccount paymentAccount) {
        var pubKey = keyRing.getSignatureKeyPair().getPublic();
        var witness = getMyWitness(paymentAccount.getPaymentAccountPayload());
        return Utilities.bytesAsHexString(witness.getHash()) + "","" + Utilities.bytesAsHexString(pubKey.getEncoded());
    }

    public Tuple2<AccountAgeWitness, byte[]> getSignInfoFromString(String signInfo) {
        var parts = signInfo.split("","");
        if (parts.length != 2) {
            return null;
        }
        byte[] pubKeyHash;
        Optional<AccountAgeWitness> accountAgeWitness;
        try {
            var accountAgeWitnessHash = Utilities.decodeFromHex(parts[0]);
            pubKeyHash = Utilities.decodeFromHex(parts[1]);
            accountAgeWitness = getWitnessByHash(accountAgeWitnessHash);
            return accountAgeWitness
                    .map(ageWitness -> new Tuple2<>(ageWitness, pubKeyHash))
                    .orElse(null);
        } catch (Exception e) {
            return null;
        }
    }
}",1,64 2000 439 334 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 1505 44 2006 46 2007 44 1503 41 59 437 457 381 413 2008 61 2004 46 2005 40 1505 44 2006 46 2009 44 1501 41 46 2010 40 41 59 439 370 2011 123 2012 44 2013 44 2014 44 2015 125 439 370 2016 123 2017 40 2018 46 2019 40 648 41 41 44 2020 40 2018 46 2019 40 648 41 41 44 2021 40 2018 46 2019 40 648 41 41 44 2022 40 2018 46 2019 40 648 41 41 44 2023 40 2018 46 2019 40 648 41 41 44 2024 40 2018 46 2019 40 648 41 41 59 437 2025 2026 59 437 2025 2027 61 648 59 437 413 2028 61 1500 59 2016 40 2025 2026 41 123 467 46 2026 61 2026 59 125 439 2016 2029 40 2025 2027 41 123 467 46 2027 61 2027 59 450 467 59 125 439 2016 2030 40 413 2031 41 123 467 46 2028 61 2031 59 450 467 59 125 439 2025 2032 40 41 123 392 40 33 2027 46 2033 40 41 41 123 621 450 2026 43 648 43 2027 59 125 450 2025 46 2034 40 2026 44 2028 41 59 125 439 324 2035 40 41 123 450 467 614 2022 606 467 614 2023 606 467 614 2020 59 125 125 437 381 2036 2037 59 437 381 2038 2039 59 437 381 2040 2041 59 437 381 2042 2043 59 437 381 2044 2045 59 437 381 2046 2047 59 437 381 2048 2049 59 437 381 2050 2051 59 64 2052 437 381 2053 2054 59 437 381 2055 60 2056 46 2057 44 2058 62 2059 61 418 2060 60 62 40 41 59 621 621 621 437 381 2055 60 2056 46 2057 44 2058 62 2061 61 418 2062 60 62 40 41 59 621 621 621 64 2063 439 2001 40 2036 2037 44 2038 2039 44 2040 2041 44 2042 2043 44 2044 2045 44 2046 2047 44 2064 2065 44 2048 2049 44 2050 2051 41 123 467 46 2037 61 2037 59 467 46 2039 61 2039 59 467 46 2041 61 2041 59 467 46 2043 61 2043 59 467 46 2045 61 2045 59 467 46 2047 61 2047 59 467 46 2049 61 2049 59 467 46 2051 61 2051 59 2054 61 418 2053 40 467 44 2043 44 2037 41 59 621 2065 46 2066 40 2047 41 59 125 621 621 621 439 492 2067 40 41 123 2039 46 2068 40 41 46 2069 40 2070 45 62 123 392 40 2070 402 2058 41 2071 40 40 2058 41 2070 41 59 125 41 59 621 2047 46 2072 40 41 46 2073 40 41 46 2074 40 41 46 2075 40 2076 45 62 2076 402 2058 41 46 2077 40 2076 45 62 40 2058 41 2076 41 46 2078 40 467 58 58 2079 41 59 392 40 2039 46 2080 40 41 41 123 2081 40 41 59 125 360 123 2039 46 2082 40 418 2083 40 41 123 64 2084 439 492 2085 40 41 123 2086 40 41 59 125 125 41 59 125 125 437 492 2087 40 41 123 2088 40 41 59 2089 40 41 59 125 621 437 492 2090 40 41 123 392 40 2041 46 2091 40 41 631 424 41 2041 46 2091 40 41 46 2092 40 41 46 2093 40 2094 45 62 33 40 2094 402 2095 41 41 46 2096 40 2094 45 62 123 2058 2097 61 2098 40 2094 46 2099 40 41 41 59 621 621 392 40 2097 46 2100 40 2049 41 41 123 621 621 404 2101 61 1503 43 418 2102 40 41 46 2103 40 1503 41 59 2104 46 2105 40 40 41 45 62 2039 46 2106 40 2097 44 473 41 44 2101 41 59 125 125 41 59 125 64 2107 439 492 2108 40 2058 2109 41 123 2059 46 2110 40 2109 46 2111 40 41 44 2109 41 59 125 621 621 621 439 492 2112 40 2113 2114 41 123 2058 2109 61 2115 40 2114 41 59 2056 46 2057 2116 61 2109 46 2117 40 41 59 621 621 392 40 2061 46 2118 40 2116 41 41 123 450 59 125 392 40 33 2059 46 2118 40 2116 41 41 123 2039 46 2119 40 2109 44 380 41 59 125 125 439 326 91 93 2120 40 2121 2122 41 123 450 2123 40 2122 41 46 2124 40 2058 58 58 2125 41 46 2126 40 424 41 59 125 326 91 93 2127 40 2113 2114 41 123 450 2004 46 2128 40 2114 46 2129 40 41 44 2114 46 2130 40 41 41 59 125 64 2107 439 2058 2131 40 2113 2114 44 2132 2133 41 123 326 91 93 2134 61 2127 40 2114 41 59 326 91 93 2135 61 2136 46 2137 40 2004 46 2138 40 2134 44 2133 46 2139 40 41 41 41 59 450 418 2058 40 2135 44 418 2002 40 41 46 2010 40 41 41 59 125 2140 60 2058 62 2141 40 2113 2114 44 2132 2133 41 123 392 40 2114 614 424 41 123 450 2140 46 362 40 41 59 125 326 91 93 2142 61 2127 40 2114 41 59 326 91 93 2143 61 2144 46 2145 40 2004 46 2146 40 2142 44 2133 46 2147 40 41 41 41 59 450 2148 40 2143 41 59 125 439 2140 60 2058 62 2141 40 2149 2150 41 123 381 2140 60 2151 62 2152 61 2150 46 2153 40 41 59 450 2152 46 2154 40 41 63 2155 40 2152 46 2156 40 41 41 58 2140 46 362 40 41 59 125 437 2140 60 2058 62 2157 40 2121 2122 41 123 2158 2159 61 2122 46 2160 40 41 46 2161 40 41 59 450 40 2159 614 424 606 2159 46 2162 40 41 614 424 606 2159 46 2163 40 41 614 424 41 63 2140 46 362 40 41 58 2141 40 2159 46 2162 40 41 44 2159 46 2163 40 41 41 59 125 437 2140 60 2058 62 2164 40 326 91 93 2165 41 123 2056 46 2057 2166 61 418 2056 46 2057 40 2165 41 59 621 392 40 2061 46 2167 40 2166 41 41 123 450 2140 46 2168 40 2061 46 2169 40 2166 41 41 59 125 392 40 2059 46 2167 40 2166 41 41 123 2058 2109 61 2059 46 2170 40 2166 41 59 621 2061 46 2171 40 2166 44 2109 41 59 450 2140 46 2172 40 2109 41 59 125 450 2140 46 362 40 41 59 125 437 2140 60 2058 62 2173 40 2174 2175 41 123 450 2164 40 2004 46 2176 40 2175 41 41 59 125 621 621 621 439 413 2177 40 2058 2109 44 2002 2178 41 123 2179 46 2180 40 648 44 2178 46 2010 40 41 44 2109 46 2181 40 41 41 59 450 2178 46 2010 40 41 45 2109 46 2181 40 41 59 125 621 439 413 2177 40 2113 2114 44 2132 2133 41 123 450 2141 40 2114 44 2133 41 46 2182 40 2109 45 62 2177 40 2109 44 418 2002 40 41 41 41 46 2183 40 45 1501 41 59 125 439 413 2177 40 2149 2150 41 123 450 2141 40 2150 41 46 2184 40 2109 45 62 2177 40 2109 44 418 2002 40 41 41 41 46 2185 40 45 1501 41 59 125 439 413 2177 40 2121 2122 41 123 450 2157 40 2122 41 46 2186 40 2109 45 62 2177 40 2109 44 418 2002 40 41 41 41 46 2187 40 45 1501 41 59 125 621 621 621 621 439 413 2188 40 2058 2109 44 2002 2178 41 123 2189 60 2190 62 2191 61 2043 46 2192 40 2109 41 59 392 40 2191 46 2193 40 41 41 123 450 45 1501 59 125 360 123 450 2178 46 2010 40 41 45 2191 46 2194 40 1500 41 59 125 125 621 439 413 2188 40 2149 2150 44 2002 2178 41 123 450 2141 40 2150 41 46 2195 40 2196 45 62 2188 40 2196 44 2178 41 41 46 2197 40 45 1501 41 59 125 439 413 2188 40 2121 2122 44 2002 2178 41 123 450 2157 40 2122 41 46 2198 40 2199 45 62 2188 40 2199 44 2178 41 41 46 2200 40 45 1501 41 59 125 439 2011 2201 40 413 2202 41 123 450 2203 40 2202 41 59 125 437 2011 2204 40 413 2205 41 123 392 40 2205 60 1500 41 123 450 2011 46 2206 59 125 360 392 40 2205 60 2207 46 2208 46 2209 40 1503 41 41 123 450 2011 46 2210 59 125 360 392 40 2205 60 2207 46 2208 46 2209 40 1503 41 41 123 450 2011 46 2211 59 125 360 123 450 2011 46 2212 59 125 125 621 621 621 621 621 621 437 413 2213 40 2214 2215 44 2174 2216 44 2058 2109 44 2011 2217 44 2218 2219 44 2220 2221 41 123 392 40 2222 46 2223 40 2216 41 606 33 2220 46 2224 40 2221 44 2216 41 606 2219 614 2218 46 2225 41 123 450 2215 46 2226 59 125 413 2227 61 2228 46 2229 46 2230 59 490 2231 61 2232 40 2217 41 59 392 40 2231 62 1500 41 123 2227 61 2233 46 2234 40 40 356 41 2215 46 2230 42 2231 41 59 125 2235 46 2236 40 648 44 2214 46 2237 40 2227 41 46 2238 40 41 44 2231 44 2004 46 2239 40 2109 46 2240 40 41 41 41 59 450 2227 59 125 437 356 2241 40 2011 2217 41 123 464 40 2217 41 123 328 2242 58 450 1501 59 328 2243 58 450 1499 59 328 2244 58 328 2245 58 349 58 450 1500 59 125 125 437 356 2246 40 41 123 450 1501 59 125 621 621 621 437 324 2247 40 2058 2109 41 123 450 2109 46 2248 40 41 62 2008 59 125 439 324 2249 40 2250 2251 41 123 450 2252 40 2253 40 2251 46 2254 40 41 41 41 59 125 621 621 621 437 324 2255 40 2058 2109 41 123 450 33 2247 40 2109 41 606 2043 46 2256 40 2109 41 59 125 621 621 621 439 2058 2257 40 2113 2114 41 123 381 2140 60 2058 62 2258 61 2141 40 2114 44 2037 46 2259 40 41 41 59 450 2258 46 2260 40 40 41 45 62 2131 40 2114 44 2037 46 2259 40 41 41 41 59 125 437 326 91 93 2261 40 2113 2114 41 123 450 2257 40 2114 41 46 2262 40 41 59 125 439 2174 2263 40 2113 2114 41 123 450 2004 46 2264 40 2261 40 2114 41 41 59 125 439 413 2265 40 2113 2114 41 123 450 2177 40 2257 40 2114 41 44 418 2002 40 41 41 59 125 439 413 2266 40 2250 2267 44 2174 2216 44 2218 2219 41 123 392 40 2267 614 424 41 450 1500 59 2058 2109 61 2257 40 2267 46 2268 40 41 41 59 2214 2215 61 2267 46 2269 40 41 46 2270 40 2216 41 59 392 40 2255 40 2109 41 41 123 450 2215 46 2271 59 125 381 413 2272 61 2188 40 2109 44 418 2002 40 41 41 59 2011 2217 61 2204 40 2272 41 59 450 2213 40 2215 44 2216 44 2109 44 2217 44 2219 44 2267 46 2269 40 41 41 59 125 621 621 621 439 324 2273 40 2121 2122 44 2113 2274 44 2002 2275 44 2132 2276 44 326 91 93 2277 44 326 91 93 2278 44 2279 2280 41 123 381 2140 60 2058 62 2281 61 2141 40 2274 44 2276 41 59 621 621 621 621 2058 2282 59 392 40 2281 46 2283 40 41 41 123 2282 61 2281 46 2284 40 41 59 125 360 123 2282 61 2131 40 2274 44 2276 41 59 2285 46 2286 40 648 41 59 125 621 392 40 33 2287 40 2282 46 2288 40 41 44 2003 44 2280 41 41 450 380 59 621 392 40 33 2289 40 2275 44 2280 41 41 450 380 59 381 326 91 93 2290 61 2004 46 2291 40 2274 46 2292 40 41 44 2274 46 2293 40 41 41 59 326 91 93 2165 61 2294 46 2295 40 2004 46 2291 40 2290 44 2276 46 2296 40 41 41 41 59 621 381 326 91 93 2297 61 2282 46 2298 40 41 59 392 40 33 2299 40 2297 44 2165 44 2280 41 41 450 380 59 621 392 40 33 2300 40 2122 46 2301 40 41 44 2122 46 2302 40 41 44 2282 44 2275 44 2280 41 41 123 2303 46 371 40 648 44 2274 41 59 450 380 59 125 621 450 2304 40 2276 46 2305 40 41 44 2277 44 2278 44 2280 41 59 125 439 324 2306 40 2149 2150 44 2214 2307 44 2279 2280 41 123 2308 40 2150 41 59 621 621 450 2141 40 2150 41 46 2309 40 2310 45 62 2311 40 2150 44 2307 44 2310 44 418 2002 40 41 44 2280 41 41 46 2312 40 2313 40 2307 41 41 59 125 437 324 2314 40 2214 2307 41 123 450 2307 46 2315 620 2316 46 2317 46 2315 59 125 621 621 621 324 2318 40 413 2319 44 2002 2320 44 2279 2280 41 123 621 2002 2321 61 418 2002 40 2320 46 2010 40 41 45 2322 46 2323 46 2324 40 1501 41 41 59 381 2002 2325 61 418 2002 40 2319 41 59 381 324 2326 61 2325 46 2327 40 2321 41 59 392 40 33 2326 41 123 381 2174 2328 61 648 43 648 43 2320 43 648 43 2325 59 2329 46 2330 40 2328 41 59 2280 46 2331 40 2328 41 59 125 450 2326 59 125 437 324 2332 40 2002 2275 44 2279 2280 41 123 324 2333 61 2334 46 2335 40 2275 46 2010 40 41 45 418 2002 40 41 46 2010 40 41 41 620 2336 46 2337 46 2338 40 1501 41 59 392 40 33 2333 41 123 2174 2339 61 648 43 648 43 2275 43 648 43 418 2002 40 41 59 2340 46 2341 40 2339 41 59 2280 46 2342 40 2339 41 59 125 450 2333 59 125 437 324 2343 40 326 91 93 2344 44 326 91 93 2165 44 2279 2280 41 123 381 324 2345 61 2346 46 2347 40 2344 44 2165 41 59 392 40 33 2345 41 123 381 2174 2348 61 648 43 648 43 2004 46 2349 40 2344 41 43 648 43 2004 46 2349 40 2165 41 59 2350 46 2351 40 2348 41 59 2280 46 2352 40 2348 41 59 125 450 2345 59 125 437 324 2353 40 2149 2150 44 2214 2307 44 2058 2354 44 2002 2275 44 2279 2280 41 123 2355 40 2150 41 59 381 2174 2216 61 2150 46 2356 40 41 59 381 2214 2357 61 2150 46 2358 40 41 46 2359 40 2216 41 59 413 2360 61 2357 46 2361 59 392 40 33 2255 40 2354 41 41 123 381 413 2362 61 2188 40 2354 44 2275 41 59 2011 2217 61 2201 40 2362 41 59 2218 2219 61 2150 46 2363 40 2037 41 63 2150 46 2364 40 41 58 2150 46 2365 40 41 59 2360 61 2213 40 2357 44 2216 44 2354 44 2217 44 2219 44 2150 46 2358 40 41 41 59 125 621 324 2366 61 2307 46 2361 620 2360 59 392 40 33 2366 41 123 2174 2367 61 648 43 648 43 2307 46 2368 40 41 43 648 43 2214 46 2369 40 2360 41 46 2368 40 41 43 648 43 2150 46 2370 40 41 43 648 43 2150 46 2358 40 41 46 2371 40 41 43 648 43 2150 46 2356 40 41 59 2372 46 2373 40 2367 41 59 2280 46 2374 40 2367 41 59 125 450 2366 59 125 324 2375 40 2376 2377 44 326 91 93 2277 44 326 91 93 2278 44 2279 2280 41 123 324 2378 59 474 123 2378 61 2379 46 2380 40 2377 44 2277 44 2278 41 59 125 329 40 2381 2382 41 123 2383 46 2384 40 2382 46 2385 40 41 41 59 2378 61 380 59 125 392 40 33 2378 41 123 381 2174 2386 61 648 43 648 43 2377 43 648 43 2004 46 2387 40 2277 41 43 648 43 2004 46 2387 40 2278 41 59 2388 46 2389 40 2386 41 59 2280 46 2390 40 2386 41 59 125 450 2378 59 125 621 621 621 439 492 2391 40 2214 2307 44 2058 2109 44 2392 2393 44 2376 2394 41 123 2043 46 2395 40 2307 44 2109 44 2393 44 2394 41 59 125 439 2174 2396 40 2058 2109 44 2392 2397 44 413 2398 41 123 621 621 621 450 2043 46 2399 40 2109 41 46 2400 40 41 46 2401 40 41 46 2402 40 2403 58 58 2404 41 46 2402 40 2405 45 62 2043 46 2406 40 2109 44 2397 44 2405 44 2398 41 41 46 2407 40 648 41 59 125 439 2174 2408 40 2392 2393 44 326 91 93 2394 44 413 2409 41 123 450 2043 46 2410 40 2393 44 2394 44 2409 41 59 125 439 492 2391 40 2058 2109 44 2392 2393 44 326 91 93 2411 44 413 2398 41 123 2043 46 2412 40 2109 44 2393 44 2411 44 2398 41 59 125 439 2140 60 2413 62 2414 40 2121 2122 41 123 2058 2354 61 2157 40 2122 41 46 2415 40 424 41 59 2214 2307 61 2122 46 2416 40 41 59 2417 40 2122 46 2418 40 41 46 2419 40 41 46 2420 40 41 44 648 41 59 2376 2394 61 2122 46 2418 40 41 46 2419 40 41 46 2420 40 41 46 2421 40 41 59 2417 40 2354 44 648 44 2122 46 2422 40 41 41 59 2417 40 2307 44 648 41 59 2417 40 2394 44 648 41 59 474 123 450 2043 46 2423 40 2307 44 2354 44 2394 41 59 125 329 40 2424 2425 41 123 2426 46 2427 40 648 44 2425 46 2422 40 41 41 59 125 450 2140 46 362 40 41 59 125 439 324 2428 40 2413 2429 41 123 450 2043 46 2428 40 2429 41 59 125 621 439 2430 60 2431 62 2432 40 413 2433 44 2220 2221 44 2430 60 2434 62 2435 41 123 450 2435 46 2436 40 41 46 2437 40 2438 45 62 2438 46 2439 40 41 46 2440 40 41 46 2441 40 2221 46 2442 40 41 41 41 46 2437 40 467 58 58 2443 41 46 2437 40 467 58 58 2444 41 46 2437 40 467 58 58 2445 41 46 2446 40 467 58 58 2447 41 46 2437 40 2448 58 58 2449 41 46 2437 40 2450 45 62 33 2043 46 2451 40 2450 46 2452 40 41 41 41 46 2437 40 2450 45 62 2450 46 2452 40 41 46 2453 40 41 60 2433 41 46 2454 40 41 46 2455 40 2456 46 2457 40 41 41 59 125 437 324 2458 40 2434 2459 41 123 324 2460 61 2051 46 2461 40 2459 46 2462 40 41 46 2463 40 41 41 606 2051 46 2461 40 2459 46 2462 40 41 46 2464 40 41 41 606 2051 46 2465 40 2459 46 2462 40 41 46 2466 40 41 46 2467 40 41 41 606 2051 46 2468 40 2220 46 2469 40 2459 46 2462 40 41 46 2470 40 41 41 41 606 2051 46 2471 40 2459 46 2462 40 41 46 2472 40 41 41 606 2051 46 2471 40 2459 46 2462 40 41 46 2473 40 41 41 606 2051 46 2474 40 2475 46 2476 46 2477 40 2459 46 2462 40 41 46 2478 40 41 46 2479 40 41 41 41 606 2051 46 2474 40 2475 46 2476 46 2477 40 2459 46 2462 40 41 46 2480 40 41 46 2479 40 41 41 41 59 450 33 2460 59 125 64 2107 439 324 2481 40 2434 2459 41 123 450 2045 46 2481 40 2459 46 2482 40 41 46 2483 40 41 44 2459 46 2482 40 41 46 2484 40 41 46 2485 40 41 41 59 125 437 324 2486 40 2434 2459 41 123 392 40 33 2459 46 2487 40 41 606 2459 46 2488 40 41 614 424 41 450 380 59 450 2459 46 2488 40 41 46 2489 40 41 46 2490 40 41 614 2491 46 2492 46 2493 59 125 437 2494 60 2431 62 2495 40 2434 2459 41 123 2214 2307 61 2459 46 2496 40 41 46 2497 40 41 59 2132 2498 61 2459 46 2496 40 41 46 2499 40 41 59 2132 2500 61 2459 46 2496 40 41 46 2501 40 41 59 2113 2502 61 2459 46 2496 40 41 46 2503 40 41 59 2113 2504 61 2459 46 2496 40 41 46 2505 40 41 59 2431 2506 61 2141 40 2502 44 2498 41 46 2507 40 2508 45 62 418 2431 40 2502 44 2508 44 2307 44 2498 46 2509 40 41 41 41 46 2510 40 424 41 59 2431 2511 61 2141 40 2504 44 2500 41 46 2507 40 2508 45 62 418 2431 40 2504 44 2508 44 2307 44 2500 46 2509 40 41 41 41 46 2510 40 424 41 59 450 2494 46 2512 40 2506 44 2511 41 59 125 439 324 2513 40 2149 2150 41 123 450 2141 40 2150 41 46 2514 40 2043 58 58 2515 41 46 2516 40 380 41 59 125 439 324 2517 40 2121 2122 41 123 450 2157 40 2122 41 46 2518 40 2043 58 58 2519 41 46 2520 40 380 41 59 125 439 324 2521 40 2058 2109 41 123 450 2043 46 2522 40 2109 41 59 125 439 324 2523 40 2214 2307 41 123 450 2043 46 2524 40 2307 41 59 125 439 2016 2525 40 2149 2150 41 123 450 2141 40 2150 41 46 2526 40 467 58 58 2525 41 46 2527 40 2016 46 2528 41 59 125 439 2016 2525 40 2121 2122 41 123 450 2157 40 2122 41 46 2529 40 467 58 58 2525 41 46 2530 40 2016 46 2531 41 59 125 439 2016 2525 40 2058 2109 41 123 621 2174 2165 61 2532 46 2533 40 41 63 2004 46 2534 40 2109 46 2535 40 41 41 43 648 43 2043 46 2536 40 2109 41 58 648 59 392 40 2043 46 2537 40 2109 41 41 123 450 2016 46 2538 46 2539 40 2165 41 59 125 392 40 2043 46 2540 40 2109 41 41 123 450 2016 46 2541 46 2542 40 2165 41 59 125 360 123 381 413 2543 61 2188 40 2109 44 418 2002 40 41 41 59 464 40 2204 40 2543 41 41 123 328 2544 58 328 2545 58 450 2016 46 2546 46 2547 40 2165 41 59 328 2548 58 450 2016 46 2549 46 2547 40 2165 41 46 2550 40 1503 45 2551 46 2552 46 2553 40 2543 41 41 59 328 2554 58 349 58 450 2016 46 2555 46 2547 40 2165 41 59 125 125 125 439 2556 60 2058 62 2557 40 41 123 450 2043 46 2558 40 380 41 46 2559 40 41 46 2560 40 2429 45 62 2164 40 2429 46 2561 40 41 41 46 2562 40 424 41 41 46 2563 40 2564 58 58 2565 41 46 2566 40 2567 46 2568 40 41 41 59 125 439 492 2569 40 41 123 621 490 2570 61 2571 46 2572 40 2041 46 2573 40 41 41 46 2574 40 41 46 2575 40 2576 45 62 2576 46 2577 40 41 631 424 605 2521 40 2257 40 2576 46 2578 40 41 41 41 41 46 2579 40 2580 46 2581 40 41 41 59 490 2582 61 2041 46 2573 40 41 46 2574 40 41 46 2575 40 2576 45 62 2576 46 2577 40 41 631 424 605 33 2043 46 2583 40 2257 40 2576 46 2578 40 41 41 41 41 46 2579 40 2580 46 2581 40 41 41 59 2570 46 2584 40 2585 45 62 2582 46 2584 40 486 45 62 123 392 40 2585 46 2577 40 41 46 2586 40 486 46 2577 40 41 41 41 123 474 123 2043 46 2587 40 2257 40 486 46 2578 40 41 41 41 59 125 329 40 2588 2589 41 123 2590 46 2591 40 648 44 2589 46 2592 40 41 41 59 125 125 125 41 41 59 125 439 2556 60 2413 62 2593 40 41 123 450 2043 46 2593 40 41 59 125 439 324 2594 40 2121 2122 41 123 2595 40 2122 44 648 41 59 2595 40 2122 46 2596 40 41 44 648 41 59 2597 2598 61 2595 40 2122 46 2599 40 41 41 59 2113 2600 61 2598 46 2601 40 41 59 2058 2602 61 2257 40 2600 41 59 2603 40 41 46 2604 40 2122 44 2602 41 59 450 2521 40 2602 41 605 33 2517 40 2122 41 605 2523 40 2122 46 2605 40 41 41 59 125 439 2174 2606 40 2250 2267 41 123 490 2607 61 2037 46 2608 40 41 46 2609 40 41 59 490 2610 61 2257 40 2267 46 2611 40 41 41 59 450 2004 46 2612 40 2610 46 2613 40 41 41 43 648 43 2004 46 2612 40 2607 46 2614 40 41 41 59 125 439 2615 60 2058 44 326 91 93 62 2616 40 2174 2617 41 123 490 2618 61 2617 46 2619 40 648 41 59 392 40 2618 46 2620 631 1502 41 123 450 424 59 125 326 91 93 2621 59 2140 60 2058 62 2109 59 474 123 490 2622 61 2004 46 2623 40 2618 91 1500 93 41 59 2621 61 2004 46 2623 40 2618 91 1501 93 41 59 2109 61 2164 40 2622 41 59 450 2109 46 2624 40 2625 45 62 418 2615 60 62 40 2625 44 2621 41 41 46 2626 40 424 41 59 125 329 40 2627 2628 41 123 450 424 59 125 125 125 
4174,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(getPriceAndPercentage(item));
                                } else {
                                    setGraphic(null);
                                }
                            }

                            private HBox getPriceAndPercentage(OfferBookListItem item) {
                                Offer offer = item.getOffer();
                                boolean useMarketBasedPrice = offer.isUseMarketBasedPrice();
                                MaterialDesignIcon icon = useMarketBasedPrice ? MaterialDesignIcon.CHART_LINE : MaterialDesignIcon.LOCK;
                                String info;

                                if (useMarketBasedPrice) {
                                    double marketPriceMargin = offer.getMarketPriceMargin();
                                    if (marketPriceMargin == 0) {
                                        if (offer.isBuyOffer()) {
                                            info = Res.get(""offerbook.info.sellAtMarketPrice"");
                                        } else {
                                            info = Res.get(""offerbook.info.buyAtMarketPrice"");
                                        }
                                    } else {
                                        String absolutePriceMargin = model.getAbsolutePriceMargin(offer);
                                        if (marketPriceMargin > 0) {
                                            if (offer.isBuyOffer()) {
                                                info = Res.get(""offerbook.info.sellBelowMarketPrice"", absolutePriceMargin);
                                            } else {
                                                info = Res.get(""offerbook.info.buyAboveMarketPrice"", absolutePriceMargin);
                                            }
                                        } else {
                                            if (offer.isBuyOffer()) {
                                                info = Res.get(""offerbook.info.sellAboveMarketPrice"", absolutePriceMargin);
                                            } else {
                                                info = Res.get(""offerbook.info.buyBelowMarketPrice"", absolutePriceMargin);
                                            }
                                        }
                                    }
                                } else {
                                    if (offer.isBuyOffer()) {
                                        info = Res.get(""offerbook.info.sellAtFixedPrice"");
                                    } else {
                                        info = Res.get(""offerbook.info.buyAtFixedPrice"");
                                    }
                                }
                                InfoAutoTooltipLabel priceLabel = new InfoAutoTooltipLabel(model.getPrice(item),
                                        icon, ContentDisplay.RIGHT, info);
                                priceLabel.setTextAlignment(TextAlignment.RIGHT);
                                AutoTooltipLabel percentageLabel = new AutoTooltipLabel(model.getPriceAsPercentage(item));
                                percentageLabel.setOpacity(useMarketBasedPrice ? 1 : 0.4);

                                HBox hBox = new HBox();
                                hBox.setSpacing(5);
                                hBox.getChildren().addAll(priceLabel, percentageLabel);
                                hBox.setPadding(new Insets(7, 0, 0, 0));
                                return hBox;
                            }
                        };",1,450 418 2000 60 62 40 41 123 64 2001 439 492 2002 40 381 2003 2004 44 324 362 41 123 463 46 2002 40 2004 44 362 41 59 392 40 2004 631 424 605 33 362 41 123 2005 40 2006 40 2004 41 41 59 125 360 123 2007 40 424 41 59 125 125 437 2008 2009 40 2003 2004 41 123 2010 2011 61 2004 46 2012 40 41 59 324 2013 61 2011 46 2014 40 41 59 2015 2016 61 2013 63 2015 46 2017 58 2015 46 2018 59 2019 2020 59 392 40 2013 41 123 356 2021 61 2011 46 2022 40 41 59 392 40 2021 614 1500 41 123 392 40 2011 46 2023 40 41 41 123 2020 61 2024 46 2025 40 648 41 59 125 360 123 2020 61 2026 46 2027 40 648 41 59 125 125 360 123 2019 2028 61 2029 46 2030 40 2011 41 59 392 40 2021 62 1500 41 123 392 40 2011 46 2031 40 41 41 123 2020 61 2032 46 2033 40 648 44 2028 41 59 125 360 123 2020 61 2034 46 2035 40 648 44 2028 41 59 125 125 360 123 392 40 2011 46 2036 40 41 41 123 2020 61 2037 46 2038 40 648 44 2028 41 59 125 360 123 2020 61 2039 46 2040 40 648 44 2028 41 59 125 125 125 125 360 123 392 40 2011 46 2041 40 41 41 123 2020 61 2042 46 2043 40 648 41 59 125 360 123 2020 61 2044 46 2045 40 648 41 59 125 125 2046 2047 61 418 2046 40 2048 46 2049 40 2004 41 44 2016 44 2050 46 2051 44 2020 41 59 2047 46 2052 40 2053 46 2051 41 59 2054 2055 61 418 2054 40 2048 46 2056 40 2004 41 41 59 2055 46 2057 40 2013 63 1501 58 1499 41 59 2008 2058 61 418 2008 40 41 59 2058 46 2059 40 1502 41 59 2058 46 2060 40 41 46 2061 40 2047 44 2055 41 59 2058 46 2062 40 418 2063 40 1502 44 1500 44 1500 44 1500 41 41 59 450 2058 59 125 125 59 
3213,Java,"public class PendingTradesDataModel extends ActivatableDataModel {
    @Getter
    public final TradeManager tradeManager;
    public final BtcWalletService btcWalletService;
    public final MediationManager mediationManager;
    public final RefundManager refundManager;
    private final P2PService p2PService;
    private final WalletsSetup walletsSetup;
    @Getter
    private final AccountAgeWitnessService accountAgeWitnessService;
    public final DaoFacade daoFacade;
    public final Navigation navigation;
    public final WalletPasswordWindow walletPasswordWindow;
    private final NotificationCenter notificationCenter;
    private final OfferUtil offerUtil;

    final ObservableList<PendingTradesListItem> list = FXCollections.observableArrayList();
    private final ListChangeListener<Trade> tradesListChangeListener;
    private boolean isMaker;

    final ObjectProperty<PendingTradesListItem> selectedItemProperty = new SimpleObjectProperty<>();
    public final StringProperty txId = new SimpleStringProperty();

    @Getter
    private final TraderChatManager traderChatManager;
    public final Preferences preferences;
    private boolean activated;
    private ChangeListener<Trade.State> tradeStateChangeListener;
    private Trade selectedTrade;
    @Getter
    private final PubKeyRing pubKeyRing;

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, initialization
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public PendingTradesDataModel(TradeManager tradeManager,
                                  BtcWalletService btcWalletService,
                                  PubKeyRing pubKeyRing,
                                  MediationManager mediationManager,
                                  RefundManager refundManager,
                                  TraderChatManager traderChatManager,
                                  Preferences preferences,
                                  P2PService p2PService,
                                  WalletsSetup walletsSetup,
                                  AccountAgeWitnessService accountAgeWitnessService,
                                  DaoFacade daoFacade,
                                  Navigation navigation,
                                  WalletPasswordWindow walletPasswordWindow,
                                  NotificationCenter notificationCenter,
                                  OfferUtil offerUtil) {
        this.tradeManager = tradeManager;
        this.btcWalletService = btcWalletService;
        this.pubKeyRing = pubKeyRing;
        this.mediationManager = mediationManager;
        this.refundManager = refundManager;
        this.traderChatManager = traderChatManager;
        this.preferences = preferences;
        this.p2PService = p2PService;
        this.walletsSetup = walletsSetup;
        this.accountAgeWitnessService = accountAgeWitnessService;
        this.daoFacade = daoFacade;
        this.navigation = navigation;
        this.walletPasswordWindow = walletPasswordWindow;
        this.notificationCenter = notificationCenter;
        this.offerUtil = offerUtil;

        tradesListChangeListener = change -> onListChanged();
        notificationCenter.setSelectItemByTradeIdConsumer(this::selectItemByTradeId);
    }

    @Override
    protected void activate() {
        tradeManager.getObservableList().addListener(tradesListChangeListener);
        onListChanged();
        if (selectedItemProperty.get() != null)
            notificationCenter.setSelectedTradeId(selectedItemProperty.get().getTrade().getId());

        activated = true;
    }

    @Override
    protected void deactivate() {
        tradeManager.getObservableList().removeListener(tradesListChangeListener);
        notificationCenter.setSelectedTradeId(null);
        activated = false;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // UI actions
    ///////////////////////////////////////////////////////////////////////////////////////////

    void onSelectItem(PendingTradesListItem item) {
        doSelectItem(item);
    }

    public void onPaymentStarted(ResultHandler resultHandler, ErrorMessageHandler errorMessageHandler) {
        Trade trade = getTrade();
        checkNotNull(trade, ""trade must not be null"");
        checkArgument(trade instanceof BuyerTrade, ""Check failed: trade instanceof BuyerTrade. Was: "" + trade.getClass().getSimpleName());
        ((BuyerProtocol) tradeManager.getTradeProtocol(trade)).onPaymentStarted(resultHandler, errorMessageHandler);
    }

    public void onFiatPaymentReceived(ResultHandler resultHandler, ErrorMessageHandler errorMessageHandler) {
        Trade trade = getTrade();
        checkNotNull(trade, ""trade must not be null"");
        checkArgument(trade instanceof SellerTrade, ""Trade must be instance of SellerTrade"");
        ((SellerProtocol) tradeManager.getTradeProtocol(trade)).onPaymentReceived(resultHandler, errorMessageHandler);
    }

    public void onWithdrawRequest(String toAddress,
                                  Coin amount,
                                  Coin fee,
                                  KeyParameter aesKey,
                                  @Nullable String memo,
                                  ResultHandler resultHandler,
                                  FaultHandler faultHandler) {
        checkNotNull(getTrade(), ""trade must not be null"");

        if (toAddress != null && toAddress.length() > 0) {
            tradeManager.onWithdrawRequest(
                    toAddress,
                    amount,
                    fee,
                    aesKey,
                    getTrade(),
                    memo,
                    () -> {
                        resultHandler.handleResult();
                        selectBestItem();
                    },
                    (errorMessage, throwable) -> {
                        log.error(errorMessage);
                        faultHandler.handleFault(errorMessage, throwable);
                    });
        } else {
            faultHandler.handleFault(Res.get(""portfolio.pending.noReceiverAddressDefined""), null);
        }
    }

    public void onOpenDispute() {
        tryOpenDispute(false);
    }

    public void onOpenSupportTicket() {
        tryOpenDispute(true);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Nullable
    public Trade getTrade() {
        return selectedItemProperty.get() != null ? selectedItemProperty.get().getTrade() : null;
    }

    @Nullable
    Offer getOffer() {
        return getTrade() != null ? getTrade().getOffer() : null;
    }

    private boolean isBuyOffer() {
        return getOffer() != null && offerUtil.isBuyOffer(getOffer().getDirection());
    }

    boolean isBuyer() {
        return (isMaker(getOffer()) && isBuyOffer())
                || (!isMaker(getOffer()) && !isBuyOffer());
    }

    boolean isMaker(Offer offer) {
        return tradeManager.isMyOffer(offer);
    }

    public boolean isMaker() {
        return isMaker;
    }

    Coin getTradeFeeInBTC() {
        Trade trade = getTrade();
        if (trade != null) {
            Offer offer = trade.getOffer();
            if (isMaker()) {
                if (offer != null) {
                    if (offer.isCurrencyForMakerFeeBtc())
                        return offer.getMakerFee();
                    else
                        return Coin.ZERO;// getTradeFeeAsBsq is used for BSQ
                } else {
                    log.error(""offer is null"");
                    return Coin.ZERO;
                }
            } else {
                if (trade.isCurrencyForTakerFeeBtc())
                    return trade.getTakerFee();
                else
                    return Coin.ZERO; // getTradeFeeAsBsq is used for BSQ
            }
        } else {
            log.error(""Trade is null at getTotalFees"");
            return Coin.ZERO;
        }
    }

    Coin getTxFee() {
        Trade trade = getTrade();
        if (trade != null) {
            if (isMaker()) {
                Offer offer = trade.getOffer();
                if (offer != null) {
                    if (offer.isCurrencyForMakerFeeBtc())
                        return offer.getTxFee();
                    else
                        return offer.getTxFee().subtract(offer.getMakerFee()); // BSQ will be used as part of the miner fee
                } else {
                    log.error(""offer is null"");
                    return Coin.ZERO;
                }
            } else {
                if (trade.isCurrencyForTakerFeeBtc())
                    return trade.getTradeTxFee().multiply(3);
                else
                    return trade.getTradeTxFee().multiply(3).subtract(trade.getTakerFee()); // BSQ will be used as part of the miner fee
            }
        } else {
            log.error(""Trade is null at getTotalFees"");
            return Coin.ZERO;
        }
    }

    Coin getTradeFeeAsBsq() {
        Trade trade = getTrade();
        if (trade != null) {
            if (isMaker()) {
                Offer offer = trade.getOffer();
                if (offer != null) {
                    if (offer.isCurrencyForMakerFeeBtc()) {
                        return Coin.ZERO; // getTradeFeeInBTC is used for BTC
                    } else {
                        return offer.getMakerFee();
                    }
                } else {
                    log.error(""offer is null"");
                    return Coin.ZERO;
                }
            } else {
                if (trade.isCurrencyForTakerFeeBtc())
                    return Coin.ZERO; // getTradeFeeInBTC is used for BTC
                else
                    return trade.getTakerFee();
            }
        } else {
            log.error(""Trade is null at getTotalFees"");
            return Coin.ZERO;
        }
    }

    @Nullable
    public PaymentAccountPayload getSellersPaymentAccountPayload() {
        if (getTrade() != null && getTrade().getContract() != null)
            return getTrade().getContract().getSellerPaymentAccountPayload();
        else
            return null;
    }

    @Nullable
    public PaymentAccountPayload getBuyersPaymentAccountPayload() {
        if (getTrade() != null && getTrade().getContract() != null)
            return getTrade().getContract().getBuyerPaymentAccountPayload();
        else
            return null;
    }

    public String getReference() {
        return getOffer() != null ? getOffer().getShortId() : """";
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onListChanged() {
        list.clear();
        list.addAll(tradeManager.getObservableList().stream()
                .map(PendingTradesListItem::new)
                .collect(Collectors.toList()));

        // we sort by date, earliest first
        list.sort((o1, o2) -> o2.getTrade().getDate().compareTo(o1.getTrade().getDate()));

        selectBestItem();
    }

    private void selectBestItem() {
        if (list.size() == 1)
            doSelectItem(list.get(0));
        else if (list.size() > 1 && (selectedItemProperty.get() == null || !list.contains(selectedItemProperty.get())))
            doSelectItem(list.get(0));
        else if (list.size() == 0)
            doSelectItem(null);
    }

    private void selectItemByTradeId(String tradeId) {
        if (activated) {
            list.stream().filter(e -> e.getTrade().getId().equals(tradeId)).findAny().ifPresent(this::doSelectItem);
        }
    }

    private void doSelectItem(@Nullable PendingTradesListItem item) {
        if (selectedTrade != null)
            selectedTrade.stateProperty().removeListener(tradeStateChangeListener);

        if (item != null) {
            selectedTrade = item.getTrade();
            if (selectedTrade == null) {
                log.error(""selectedTrade is null"");
                return;
            }

            Transaction depositTx = selectedTrade.getDepositTx();
            String tradeId = selectedTrade.getId();
            tradeStateChangeListener = (observable, oldValue, newValue) -> {
                if (depositTx != null) {
                    txId.set(depositTx.getTxId().toString());
                    notificationCenter.setSelectedTradeId(tradeId);
                    selectedTrade.stateProperty().removeListener(tradeStateChangeListener);
                } else {
                    txId.set("""");
                }
            };
            selectedTrade.stateProperty().addListener(tradeStateChangeListener);

            Offer offer = selectedTrade.getOffer();
            if (offer == null) {
                log.error(""offer is null"");
                return;
            }

            isMaker = tradeManager.isMyOffer(offer);
            if (depositTx != null) {
                txId.set(depositTx.getTxId().toString());
            } else {
                txId.set("""");
            }
            notificationCenter.setSelectedTradeId(tradeId);
        } else {
            selectedTrade = null;
            txId.set("""");
            notificationCenter.setSelectedTradeId(null);
        }
        selectedItemProperty.set(item);
    }

    private void tryOpenDispute(boolean isSupportTicket) {
        Trade trade = getTrade();
        if (trade == null) {
            log.error(""Trade is null"");
            return;
        }

        doOpenDispute(isSupportTicket, trade.getDepositTx());
    }

    private void doOpenDispute(boolean isSupportTicket, Transaction depositTx) {
        // We do not support opening a dispute if the deposit tx is null. Traders have to use the support channel at keybase
        // in such cases. The mediators or arbitrators could not help anyway with a payout in such cases.
        if (depositTx == null) {
            log.error(""Deposit tx must not be null"");
            new Popup().instruction(Res.get(""portfolio.pending.error.depositTxNull"")).show();
            return;
        }
        String depositTxId = depositTx.getTxId().toString();

        Trade trade = getTrade();
        if (trade == null) {
            log.warn(""trade is null at doOpenDispute"");
            return;
        }

        Offer offer = trade.getOffer();
        if (offer == null) {
            log.warn(""offer is null at doOpenDispute"");
            return;
        }

        if (!GUIUtil.isBootstrappedOrShowPopup(p2PService)) {
            return;
        }

        byte[] payoutTxSerialized = null;
        String payoutTxHashAsString = null;
        Transaction payoutTx = trade.getPayoutTx();
        if (payoutTx != null) {
            payoutTxSerialized = payoutTx.bitcoinSerialize();
            payoutTxHashAsString = payoutTx.getTxId().toString();
        }
        Trade.DisputeState disputeState = trade.getDisputeState();
        DisputeManager<? extends DisputeList<Dispute>> disputeManager;
        long lockTime = trade.getDelayedPayoutTx() == null ? trade.getLockTime() : trade.getDelayedPayoutTx().getLockTime();
        long remainingLockTime = lockTime - btcWalletService.getBestChainHeight();
        // In case we re-open a dispute we allow Trade.DisputeState.MEDIATION_REQUESTED
        boolean useMediation = disputeState == Trade.DisputeState.NO_DISPUTE ||
                (disputeState == Trade.DisputeState.MEDIATION_REQUESTED && remainingLockTime > 0);
        // In case we re-open a dispute we allow Trade.DisputeState.REFUND_REQUESTED
        boolean useRefundAgent = disputeState == Trade.DisputeState.MEDIATION_CLOSED ||
                disputeState == Trade.DisputeState.REFUND_REQUESTED || remainingLockTime <= 0;

        AtomicReference<String> donationAddressString = new AtomicReference<>("""");
        Transaction delayedPayoutTx = trade.getDelayedPayoutTx();
        try {
            TradeDataValidation.validateDelayedPayoutTx(trade,
                    delayedPayoutTx,
                    daoFacade,
                    btcWalletService,
                    donationAddressString::set);
        } catch (TradeDataValidation.ValidationException e) {
            // The peer sent us an invalid donation address. We do not return here as we don't want to break
            // mediation/arbitration and log only the issue. The dispute agent will run validation as well and will get
            // a popup displayed to react.
            log.error(""DelayedPayoutTxValidation failed. {}"", e.toString());

            if (useRefundAgent) {
                // We don't allow to continue and publish payout tx and open refund agent case.
                // In case it was caused by some bug we want to prevent a wrong payout. In case its a scam attempt we
                // want to protect the refund agent.
                return;
            }
        }

        ResultHandler resultHandler;
        if (useMediation) {
            // If no dispute state set we start with mediation
            resultHandler = () -> navigation.navigateTo(MainView.class, SupportView.class, MediationClientView.class);
            disputeManager = mediationManager;
            PubKeyRing mediatorPubKeyRing = trade.getMediatorPubKeyRing();
            checkNotNull(mediatorPubKeyRing, ""mediatorPubKeyRing must not be null"");
            byte[] depositTxSerialized = depositTx.bitcoinSerialize();
            Dispute dispute = new Dispute(new Date().getTime(),
                    trade.getId(),
                    pubKeyRing.hashCode(), // traderId
                    (offer.getDirection() == OfferDirection.BUY) == isMaker,
                    isMaker,
                    pubKeyRing,
                    trade.getDate().getTime(),
                    trade.getMaxTradePeriodDate().getTime(),
                    trade.getContract(),
                    trade.getContractHash(),
                    depositTxSerialized,
                    payoutTxSerialized,
                    depositTxId,
                    payoutTxHashAsString,
                    trade.getContractAsJson(),
                    trade.getMakerContractSignature(),
                    trade.getTakerContractSignature(),
                    mediatorPubKeyRing,
                    isSupportTicket,
                    SupportType.MEDIATION);
            dispute.setExtraData(""counterCurrencyTxId"", trade.getCounterCurrencyTxId());
            dispute.setExtraData(""counterCurrencyExtraData"", trade.getCounterCurrencyExtraData());

            dispute.setDonationAddressOfDelayedPayoutTx(donationAddressString.get());
            if (delayedPayoutTx != null) {
                dispute.setDelayedPayoutTxId(delayedPayoutTx.getTxId().toString());
            }

            trade.setDisputeState(Trade.DisputeState.MEDIATION_REQUESTED);
            sendOpenDisputeMessage(disputeManager, resultHandler, dispute);
            tradeManager.requestPersistence();
        } else if (useRefundAgent) {
            resultHandler = () -> navigation.navigateTo(MainView.class, SupportView.class, RefundClientView.class);

            if (delayedPayoutTx == null) {
                log.error(""Delayed payout tx is missing"");
                return;
            }

            // We only require for refund agent a confirmed deposit tx. For mediation we tolerate a unconfirmed tx as
            // no harm can be done to the mediator (refund agent who would accept a invalid deposit tx might reimburse
            // the traders but the funds never have been spent).
            TransactionConfidence confidenceForTxId = btcWalletService.getConfidenceForTxId(depositTxId);
            if (confidenceForTxId == null || confidenceForTxId.getConfidenceType() != TransactionConfidence.ConfidenceType.BUILDING) {
                log.error(""Confidence for deposit tx must be BUILDING, confidenceForTxId={}"", confidenceForTxId);
                new Popup().instruction(Res.get(""portfolio.pending.error.depositTxNotConfirmed"")).show();
                return;
            }

            if (remainingLockTime > 0) {
                new Popup().instruction(Res.get(""portfolio.pending.timeLockNotOver"",
                        FormattingUtils.getDateFromBlockHeight(remainingLockTime), remainingLockTime))
                        .show();
                return;
            }

            disputeManager = refundManager;
            PubKeyRing refundAgentPubKeyRing = trade.getRefundAgentPubKeyRing();
            checkNotNull(refundAgentPubKeyRing, ""refundAgentPubKeyRing must not be null"");
            byte[] depositTxSerialized = depositTx.bitcoinSerialize();
            String depositTxHashAsString = depositTx.getTxId().toString();
            Dispute dispute = new Dispute(new Date().getTime(),
                    trade.getId(),
                    pubKeyRing.hashCode(), // traderId
                    (offer.getDirection() == OfferDirection.BUY) == isMaker,
                    isMaker,
                    pubKeyRing,
                    trade.getDate().getTime(),
                    trade.getMaxTradePeriodDate().getTime(),
                    trade.getContract(),
                    trade.getContractHash(),
                    depositTxSerialized,
                    payoutTxSerialized,
                    depositTxHashAsString,
                    payoutTxHashAsString,
                    trade.getContractAsJson(),
                    trade.getMakerContractSignature(),
                    trade.getTakerContractSignature(),
                    refundAgentPubKeyRing,
                    isSupportTicket,
                    SupportType.REFUND);
            dispute.setExtraData(""counterCurrencyTxId"", trade.getCounterCurrencyTxId());
            dispute.setExtraData(""counterCurrencyExtraData"", trade.getCounterCurrencyExtraData());

            String tradeId = dispute.getTradeId();
            mediationManager.findDispute(tradeId)
                    .ifPresent(mediatorsDispute -> {
                        DisputeResult mediatorsDisputeResult = mediatorsDispute.getDisputeResultProperty().get();
                        ChatMessage mediatorsResultMessage = mediatorsDisputeResult == null ? null : mediatorsDisputeResult.getChatMessage();
                        if (mediatorsResultMessage != null) {
                            String mediatorAddress = Res.get(""support.mediatorsAddress"",
                                    mediatorsDispute.getContract().getRefundAgentNodeAddress().getFullAddress());
                            String message = mediatorAddress + ""\n\n"" + mediatorsResultMessage.getMessage();
                            dispute.setMediatorsDisputeResult(message);
                        }
                    });

            dispute.setDonationAddressOfDelayedPayoutTx(donationAddressString.get());
            dispute.setDelayedPayoutTxId(delayedPayoutTx.getTxId().toString());
            trade.setDisputeState(Trade.DisputeState.REFUND_REQUESTED);

            ((DisputeProtocol) tradeManager.getTradeProtocol(trade)).onPublishDelayedPayoutTx(() -> {
                        log.info(""DelayedPayoutTx published and message sent to peer"");
                        sendOpenDisputeMessage(disputeManager, resultHandler, dispute);
                    },
                    errorMessage -> new Popup().error(errorMessage).show());
        } else {
            log.warn(""Invalid dispute state {}"", disputeState.name());
        }
        tradeManager.requestPersistence();
    }

    public boolean isReadyForTxBroadcast() {
        return GUIUtil.isReadyForTxBroadcastOrShowPopup(p2PService, walletsSetup);
    }

    public boolean isBootstrappedOrShowPopup() {
        return GUIUtil.isBootstrappedOrShowPopup(p2PService);
    }

    public void onMoveInvalidTradeToFailedTrades(Trade trade) {
        tradeManager.onMoveInvalidTradeToFailedTrades(trade);
    }

    public boolean isSignWitnessTrade() {
        return accountAgeWitnessService.isSignWitnessTrade(selectedTrade);
    }

    private void sendOpenDisputeMessage(DisputeManager<? extends DisputeList<Dispute>> disputeManager,
                                        ResultHandler resultHandler,
                                        Dispute dispute) {
        disputeManager.sendOpenNewDisputeMessage(dispute,
                false,
                resultHandler,
                (errorMessage, throwable) -> {
                    if ((throwable instanceof DisputeAlreadyOpenException)) {
                        errorMessage += ""\n\n"" + Res.get(""portfolio.pending.openAgainDispute.msg"");
                        new Popup().warning(errorMessage)
                                .actionButtonText(Res.get(""portfolio.pending.openAgainDispute.button""))
                                .onAction(() -> disputeManager.sendOpenNewDisputeMessage(dispute,
                                        true,
                                        resultHandler,
                                        (e, t) -> log.error(e)))
                                .closeButtonText(Res.get(""shared.cancel""))
                                .show();
                    } else {
                        new Popup().warning(errorMessage).show();
                    }
                });
    }
}",1,439 334 2000 378 2001 123 64 2002 439 381 2003 2004 59 439 381 2005 2006 59 439 381 2007 2008 59 439 381 2009 2010 59 437 381 2011 2012 59 437 381 2013 2014 59 64 2002 437 381 2015 2016 59 439 381 2017 2018 59 439 381 2019 2020 59 439 381 2021 2022 59 437 381 2023 2024 59 437 381 2025 2026 59 381 2027 60 2028 62 411 61 2029 46 2030 40 41 59 437 381 2031 60 2032 62 2033 59 437 324 2034 59 381 2035 60 2028 62 2036 61 418 2037 60 62 40 41 59 439 381 2038 2039 61 418 2040 40 41 59 64 2002 437 381 2041 2042 59 439 381 2043 2044 59 437 324 2045 59 437 2046 60 2032 46 2047 62 2048 59 437 2032 2049 59 64 2002 437 381 2050 2051 59 621 621 621 64 2052 439 2000 40 2003 2004 44 2005 2006 44 2050 2051 44 2007 2008 44 2009 2010 44 2041 2042 44 2043 2044 44 2011 2012 44 2013 2014 44 2015 2016 44 2017 2018 44 2019 2020 44 2021 2022 44 2023 2024 44 2025 2026 41 123 467 46 2004 61 2004 59 467 46 2006 61 2006 59 467 46 2051 61 2051 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 467 46 2042 61 2042 59 467 46 2044 61 2044 59 467 46 2012 61 2012 59 467 46 2014 61 2014 59 467 46 2016 61 2016 59 467 46 2018 61 2018 59 467 46 2020 61 2020 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2026 61 2026 59 2033 61 2053 45 62 2054 40 41 59 2024 46 2055 40 467 58 58 2056 41 59 125 64 2057 438 492 2058 40 41 123 2004 46 2059 40 41 46 2060 40 2033 41 59 2061 40 41 59 392 40 2036 46 2062 40 41 631 424 41 2024 46 2063 40 2036 46 2062 40 41 46 2064 40 41 46 2065 40 41 41 59 2045 61 473 59 125 64 2057 438 492 2066 40 41 123 2004 46 2067 40 41 46 2068 40 2033 41 59 2024 46 2069 40 424 41 59 2045 61 380 59 125 621 621 621 492 2070 40 2028 2071 41 123 2072 40 2071 41 59 125 439 492 2073 40 2074 2075 44 2076 2077 41 123 2032 2078 61 2079 40 41 59 2080 40 2078 44 648 41 59 2081 40 2078 402 2082 44 648 43 2078 46 2083 40 41 46 2084 40 41 41 59 40 40 2085 41 2004 46 2086 40 2078 41 41 46 2073 40 2075 44 2077 41 59 125 439 492 2087 40 2074 2075 44 2076 2077 41 123 2032 2088 61 2089 40 41 59 2090 40 2088 44 648 41 59 2091 40 2088 402 2092 44 648 41 59 40 40 2093 41 2004 46 2094 40 2088 41 41 46 2095 40 2075 44 2077 41 59 125 439 492 2096 40 2097 2098 44 2099 2100 44 2099 2101 44 2102 2103 44 64 2104 2097 2105 44 2074 2075 44 2106 2107 41 123 2108 40 2109 40 41 44 648 41 59 392 40 2098 631 424 605 2098 46 2110 40 41 62 1500 41 123 2004 46 2096 40 2098 44 2100 44 2101 44 2103 44 2109 40 41 44 2105 44 40 41 45 62 123 2075 46 2111 40 41 59 2112 40 41 59 125 44 40 2113 44 2114 41 45 62 123 2115 46 371 40 2113 41 59 2107 46 2116 40 2113 44 2114 41 59 125 41 59 125 360 123 2107 46 2117 40 2118 46 2119 40 648 41 44 424 41 59 125 125 439 492 2120 40 41 123 2121 40 380 41 59 125 439 492 2122 40 41 123 2123 40 473 41 59 125 621 621 621 64 2104 439 2032 2124 40 41 123 450 2036 46 2125 40 41 631 424 63 2036 46 2125 40 41 46 2124 40 41 58 424 59 125 64 2104 2126 2127 40 41 123 450 2124 40 41 631 424 63 2124 40 41 46 2127 40 41 58 424 59 125 437 324 2128 40 41 123 450 2127 40 41 631 424 605 2026 46 2128 40 2127 40 41 46 2129 40 41 41 59 125 324 2130 40 41 123 450 40 2034 40 2127 40 41 41 605 2128 40 41 41 606 40 33 2034 40 2127 40 41 41 605 33 2128 40 41 41 59 125 324 2034 40 2126 2131 41 123 450 2004 46 2132 40 2131 41 59 125 439 324 2034 40 41 123 450 2034 59 125 2099 2133 40 41 123 2032 2134 61 2124 40 41 59 392 40 2134 631 424 41 123 2126 2131 61 2134 46 2127 40 41 59 392 40 2034 40 41 41 123 392 40 2131 631 424 41 123 392 40 2131 46 2135 40 41 41 450 2131 46 2136 40 41 59 360 450 2099 46 2137 59 621 125 360 123 2138 46 371 40 648 41 59 450 2099 46 2139 59 125 125 360 123 392 40 2134 46 2140 40 41 41 450 2134 46 2141 40 41 59 360 450 2099 46 2142 59 621 125 125 360 123 2143 46 371 40 648 41 59 450 2099 46 2144 59 125 125 2099 2145 40 41 123 2032 2146 61 2124 40 41 59 392 40 2146 631 424 41 123 392 40 2034 40 41 41 123 2126 2131 61 2146 46 2127 40 41 59 392 40 2131 631 424 41 123 392 40 2131 46 2147 40 41 41 450 2131 46 2145 40 41 59 360 450 2131 46 2145 40 41 46 2148 40 2131 46 2149 40 41 41 59 621 125 360 123 2150 46 371 40 648 41 59 450 2099 46 2151 59 125 125 360 123 392 40 2146 46 2152 40 41 41 450 2146 46 2153 40 41 46 2154 40 1502 41 59 360 450 2146 46 2153 40 41 46 2154 40 1502 41 46 2155 40 2146 46 2156 40 41 41 59 621 125 125 360 123 2157 46 371 40 648 41 59 450 2099 46 2158 59 125 125 2099 2159 40 41 123 2032 2160 61 2124 40 41 59 392 40 2160 631 424 41 123 392 40 2034 40 41 41 123 2126 2131 61 2160 46 2127 40 41 59 392 40 2131 631 424 41 123 392 40 2131 46 2161 40 41 41 123 450 2099 46 2162 59 621 125 360 123 450 2131 46 2163 40 41 59 125 125 360 123 2164 46 371 40 648 41 59 450 2099 46 2165 59 125 125 360 123 392 40 2160 46 2166 40 41 41 450 2099 46 2167 59 621 360 450 2160 46 2168 40 41 59 125 125 360 123 2169 46 371 40 648 41 59 450 2099 46 2170 59 125 125 64 2104 439 2171 2172 40 41 123 392 40 2124 40 41 631 424 605 2124 40 41 46 2173 40 41 631 424 41 450 2124 40 41 46 2173 40 41 46 2174 40 41 59 360 450 424 59 125 64 2104 439 2171 2175 40 41 123 392 40 2124 40 41 631 424 605 2124 40 41 46 2176 40 41 631 424 41 450 2124 40 41 46 2176 40 41 46 2177 40 41 59 360 450 424 59 125 439 2097 2178 40 41 123 450 2127 40 41 631 424 63 2127 40 41 46 2179 40 41 58 648 59 125 621 621 621 437 492 2180 40 41 123 411 46 2181 40 41 59 411 46 2182 40 2004 46 2183 40 41 46 2184 40 41 46 2185 40 2028 58 58 418 41 46 2186 40 2187 46 2188 40 41 41 41 59 621 411 46 2189 40 40 2190 44 2191 41 45 62 2191 46 2124 40 41 46 2192 40 41 46 2193 40 2190 46 2124 40 41 46 2192 40 41 41 41 59 2194 40 41 59 125 437 492 2195 40 41 123 392 40 411 46 2196 40 41 614 1501 41 2197 40 411 46 2198 40 1500 41 41 59 360 392 40 411 46 2196 40 41 62 1501 605 40 2036 46 2198 40 41 614 424 606 33 411 46 2199 40 2036 46 2198 40 41 41 41 41 2197 40 411 46 2198 40 1500 41 41 59 360 392 40 411 46 2196 40 41 614 1500 41 2197 40 424 41 59 125 437 492 2200 40 2097 2201 41 123 392 40 2045 41 123 411 46 2202 40 41 46 2203 40 2204 45 62 2204 46 2124 40 41 46 2205 40 41 46 2206 40 2201 41 41 46 2207 40 41 46 2208 40 467 58 58 2209 41 59 125 125 437 492 2210 40 64 2104 2028 2071 41 123 392 40 2049 631 424 41 2049 46 2211 40 41 46 2212 40 2048 41 59 392 40 2071 631 424 41 123 2049 61 2071 46 2124 40 41 59 392 40 2049 614 424 41 123 2213 46 371 40 648 41 59 450 59 125 2214 2215 61 2049 46 2216 40 41 59 2097 2201 61 2049 46 2217 40 41 59 2048 61 40 2218 44 2219 44 2220 41 45 62 123 392 40 2215 631 424 41 123 2039 46 2221 40 2215 46 2222 40 41 46 2223 40 41 41 59 2024 46 2224 40 2201 41 59 2049 46 2211 40 41 46 2212 40 2048 41 59 125 360 123 2039 46 2225 40 648 41 59 125 125 59 2049 46 2211 40 41 46 2226 40 2048 41 59 2126 2131 61 2049 46 2127 40 41 59 392 40 2131 614 424 41 123 2227 46 371 40 648 41 59 450 59 125 2034 61 2004 46 2228 40 2131 41 59 392 40 2215 631 424 41 123 2039 46 2229 40 2215 46 2230 40 41 46 2231 40 41 41 59 125 360 123 2039 46 2232 40 648 41 59 125 2024 46 2233 40 2201 41 59 125 360 123 2049 61 424 59 2039 46 2234 40 648 41 59 2024 46 2235 40 424 41 59 125 2036 46 2236 40 2071 41 59 125 437 492 2237 40 324 2238 41 123 2032 2239 61 2124 40 41 59 392 40 2239 614 424 41 123 2240 46 371 40 648 41 59 450 59 125 2241 40 2238 44 2239 46 2242 40 41 41 59 125 437 492 2243 40 324 2238 44 2244 2245 41 123 621 621 392 40 2245 614 424 41 123 2246 46 371 40 648 41 59 418 2247 40 41 46 2248 40 2249 46 2250 40 648 41 41 46 2251 40 41 59 450 59 125 2097 2252 61 2245 46 2253 40 41 46 2254 40 41 59 2032 2255 61 2124 40 41 59 392 40 2255 614 424 41 123 2256 46 2257 40 648 41 59 450 59 125 2126 2131 61 2255 46 2127 40 41 59 392 40 2131 614 424 41 123 2258 46 2259 40 648 41 59 450 59 125 392 40 33 2260 46 2261 40 2012 41 41 123 450 59 125 326 91 93 2262 61 424 59 2097 2263 61 424 59 2244 2264 61 2255 46 2265 40 41 59 392 40 2264 631 424 41 123 2262 61 2264 46 2266 40 41 59 2263 61 2264 46 2253 40 41 46 2254 40 41 59 125 2032 46 2267 2268 61 2255 46 2269 40 41 59 2270 60 63 378 2271 60 2272 641 2273 59 413 2274 61 2255 46 2275 40 41 614 424 63 2255 46 2276 40 41 58 2255 46 2275 40 41 46 2276 40 41 59 413 2277 61 2274 45 2006 46 2278 40 41 59 621 324 2279 61 2268 614 2032 46 2267 46 2280 606 40 2268 614 2032 46 2267 46 2281 605 2277 62 1500 41 59 621 324 2282 61 2268 614 2032 46 2267 46 2283 606 2268 614 2032 46 2267 46 2284 606 2277 620 1500 59 2285 60 2097 62 2286 61 418 2285 60 62 40 648 41 59 2244 2287 61 2255 46 2275 40 41 59 474 123 2288 46 2289 40 2255 44 2287 44 2018 44 2006 44 2286 58 58 2290 41 59 125 329 40 2291 46 2292 2293 41 123 621 621 621 2294 46 371 40 648 44 2293 46 2254 40 41 41 59 392 40 2282 41 123 621 621 621 450 59 125 125 2074 2075 59 392 40 2279 41 123 621 2075 61 40 41 45 62 2020 46 2295 40 2296 46 334 44 2297 46 334 44 2298 46 334 41 59 2273 61 2008 59 2050 2299 61 2255 46 2300 40 41 59 2301 40 2299 44 648 41 59 326 91 93 2302 61 2245 46 2303 40 41 59 2272 2304 61 418 2272 40 418 2305 40 41 46 2306 40 41 44 2255 46 2307 40 41 44 2051 46 2308 40 41 44 621 40 2131 46 2309 40 41 614 2310 46 2311 41 614 2034 44 2034 44 2051 44 2255 46 2312 40 41 46 2306 40 41 44 2255 46 2313 40 41 46 2306 40 41 44 2255 46 2314 40 41 44 2255 46 2315 40 41 44 2302 44 2262 44 2252 44 2263 44 2255 46 2316 40 41 44 2255 46 2317 40 41 44 2255 46 2318 40 41 44 2299 44 2238 44 2319 46 2320 41 59 2304 46 2321 40 648 44 2255 46 2322 40 41 41 59 2304 46 2321 40 648 44 2255 46 2323 40 41 41 59 2304 46 2324 40 2286 46 2325 40 41 41 59 392 40 2287 631 424 41 123 2304 46 2326 40 2287 46 2253 40 41 46 2254 40 41 41 59 125 2255 46 2327 40 2032 46 2267 46 2281 41 59 2328 40 2273 44 2075 44 2304 41 59 2004 46 2329 40 41 59 125 360 392 40 2282 41 123 2075 61 40 41 45 62 2020 46 2330 40 2331 46 334 44 2332 46 334 44 2333 46 334 41 59 392 40 2287 614 424 41 123 2334 46 371 40 648 41 59 450 59 125 621 621 621 2335 2336 61 2006 46 2337 40 2252 41 59 392 40 2336 614 424 606 2336 46 2338 40 41 631 2335 46 2339 46 2340 41 123 2341 46 371 40 648 44 2336 41 59 418 2342 40 41 46 2343 40 2344 46 2345 40 648 41 41 46 2346 40 41 59 450 59 125 392 40 2277 62 1500 41 123 418 2347 40 41 46 2348 40 2349 46 2350 40 648 44 2351 46 2352 40 2277 41 44 2277 41 41 46 2353 40 41 59 450 59 125 2273 61 2010 59 2050 2354 61 2255 46 2355 40 41 59 2356 40 2354 44 648 41 59 326 91 93 2357 61 2245 46 2358 40 41 59 2097 2359 61 2245 46 2253 40 41 46 2254 40 41 59 2272 2360 61 418 2272 40 418 2361 40 41 46 2362 40 41 44 2255 46 2363 40 41 44 2051 46 2364 40 41 44 621 40 2131 46 2365 40 41 614 2366 46 2367 41 614 2034 44 2034 44 2051 44 2255 46 2368 40 41 46 2362 40 41 44 2255 46 2369 40 41 46 2362 40 41 44 2255 46 2370 40 41 44 2255 46 2371 40 41 44 2357 44 2262 44 2359 44 2263 44 2255 46 2372 40 41 44 2255 46 2373 40 41 44 2255 46 2374 40 41 44 2354 44 2238 44 2375 46 2376 41 59 2360 46 2377 40 648 44 2255 46 2378 40 41 41 59 2360 46 2377 40 648 44 2255 46 2379 40 41 41 59 2097 2201 61 2360 46 2380 40 41 59 2008 46 2381 40 2201 41 46 2382 40 2383 45 62 123 2384 2385 61 2383 46 2386 40 41 46 2387 40 41 59 2388 2389 61 2385 614 424 63 424 58 2385 46 2390 40 41 59 392 40 2389 631 424 41 123 2097 2391 61 2392 46 2387 40 648 44 2383 46 2370 40 41 46 2393 40 41 46 2394 40 41 41 59 2097 2395 61 2391 43 648 43 2389 46 2396 40 41 59 2360 46 2397 40 2395 41 59 125 125 41 59 2360 46 2398 40 2286 46 2399 40 41 41 59 2360 46 2400 40 2287 46 2253 40 41 46 2254 40 41 41 59 2255 46 2401 40 2032 46 2267 46 2284 41 59 40 40 2402 41 2004 46 2403 40 2255 41 41 46 2404 40 40 41 45 62 123 2405 46 2406 40 648 41 59 2407 40 2273 44 2075 44 2360 41 59 125 44 2408 45 62 418 2409 40 41 46 371 40 2408 41 46 2410 40 41 41 59 125 360 123 2411 46 2412 40 648 44 2268 46 2413 40 41 41 59 125 2004 46 2414 40 41 59 125 439 324 2415 40 41 123 450 2416 46 2417 40 2012 44 2014 41 59 125 439 324 2418 40 41 123 450 2419 46 2418 40 2012 41 59 125 439 492 2420 40 2032 2421 41 123 2004 46 2420 40 2421 41 59 125 439 324 2422 40 41 123 450 2016 46 2422 40 2049 41 59 125 437 492 2423 40 2424 60 63 378 2425 60 2426 641 2427 44 2074 2075 44 2426 2428 41 123 2427 46 2429 40 2428 44 380 44 2075 44 40 2430 44 2431 41 45 62 123 392 40 40 2431 402 2432 41 41 123 2430 636 648 43 2433 46 2434 40 648 41 59 418 2435 40 41 46 494 40 2430 41 46 2436 40 2433 46 2434 40 648 41 41 46 2437 40 40 41 45 62 2427 46 2429 40 2428 44 473 44 2075 44 40 2438 44 2439 41 45 62 2440 46 371 40 2438 41 41 41 46 2441 40 2433 46 2434 40 648 41 41 46 2442 40 41 59 125 360 123 418 2443 40 41 46 494 40 2430 41 46 2444 40 41 59 125 125 41 59 125 125 
5463,Java,"public class ManualPayoutTxWindow extends Overlay<ManualPayoutTxWindow> {
    private static final int HEX_HASH_LENGTH = 32 * 2;
    private static final int HEX_PUBKEY_LENGTH = 33 * 2;
    private static final Logger log = LoggerFactory.getLogger(ManualPayoutTxWindow.class);
    private final TradeWalletService tradeWalletService;
    private final P2PService p2PService;
    private final MediationManager mediationManager;
    private final Preferences preferences;
    private final WalletsSetup walletsSetup;
    private final WalletsManager walletsManager;
    GridPane inputsGridPane;
    GridPane importTxGridPane;
    GridPane exportTxGridPane;
    GridPane signTxGridPane;
    GridPane buildTxGridPane;
    GridPane signVerifyMsgGridPane;
    CheckBox depositTxLegacy, recentTickets;
    ComboBox<String> mediationDropDown;
    ObservableList<Dispute> disputeObservableList;
    InputTextField depositTxHex;
    InputTextField amountInMultisig;
    InputTextField buyerPayoutAmount;
    InputTextField sellerPayoutAmount;
    InputTextField txFee;
    InputTextField txFeePct;
    InputTextField buyerAddressString;
    InputTextField sellerAddressString;
    InputTextField buyerPubKeyAsHex;
    InputTextField sellerPubKeyAsHex;
    InputTextField buyerSignatureAsHex;
    InputTextField sellerSignatureAsHex;
    InputTextField privateKeyHex;
    InputTextField signatureHex;
    TextArea importHex;
    TextArea exportHex;
    TextArea finalSignedTxHex;
    private ChangeListener<Boolean> txFeeListener, amountInMultisigListener, buyerPayoutAmountListener, sellerPayoutAmountListener;

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Public API
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public ManualPayoutTxWindow(TradeWalletService tradeWalletService,
                                P2PService p2PService,
                                MediationManager mediationManager,
                                Preferences preferences,
                                WalletsSetup walletsSetup,
                                WalletsManager walletsManager) {
        this.tradeWalletService = tradeWalletService;
        this.p2PService = p2PService;
        this.mediationManager = mediationManager;
        this.preferences = preferences;
        this.walletsSetup = walletsSetup;
        this.walletsManager = walletsManager;
        type = Type.Attention;
    }

    public void show() {
        if (headLine == null)
            headLine = ""Emergency MultiSig payout tool""; // We dont translate here as it is for dev only purpose

        width = 1068;
        createGridPane();
        addHeadLine();
        addContent();
        addButtons();
        applyStyles();
        txFeeListener = (observable, oldValue, newValue) -> {
            calculateTxFee();
        };
        buyerPayoutAmountListener = (observable, oldValue, newValue) -> {
            calculateTxFee();
        };
        sellerPayoutAmountListener = (observable, oldValue, newValue) -> {
            calculateTxFee();
        };
        amountInMultisigListener = (observable, oldValue, newValue) -> {
            calculateTxFee();
        };
        txFee.focusedProperty().addListener(txFeeListener);
        buyerPayoutAmount.focusedProperty().addListener(buyerPayoutAmountListener);
        sellerPayoutAmount.focusedProperty().addListener(sellerPayoutAmountListener);
        amountInMultisig.focusedProperty().addListener(amountInMultisigListener);
        display();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Protected
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    protected void setupKeyHandler(Scene scene) {
        if (!hideCloseButton) {
            scene.setOnKeyPressed(e -> {
                if (e.getCode() == KeyCode.ESCAPE) {
                    e.consume();
                    doClose();
                }
            });
        }
    }

    @Override
    protected void createGridPane() {
        gridPane = new GridPane();
        gridPane.setHgap(15);
        gridPane.setVgap(15);
        gridPane.setPadding(new Insets(64, 64, 64, 64));
        gridPane.setPrefWidth(width);
        ColumnConstraints columnConstraints1 = new ColumnConstraints();
        ColumnConstraints columnConstraints2 = new ColumnConstraints();
        columnConstraints1.setPercentWidth(25);
        columnConstraints2.setPercentWidth(75);
        gridPane.getColumnConstraints().addAll(columnConstraints1, columnConstraints2);
    }

    @Override
    protected void cleanup() {
        txFee.focusedProperty().removeListener(txFeeListener);
        buyerPayoutAmount.focusedProperty().removeListener(buyerPayoutAmountListener);
        sellerPayoutAmount.focusedProperty().removeListener(sellerPayoutAmountListener);
        amountInMultisig.focusedProperty().removeListener(amountInMultisigListener);
        super.cleanup();
    }

    private void addContent() {
        rowIndex = 1;
        this.disableActionButton = true;
        addLeftPanelButtons();
        addInputsPane();
        addImportPane();
        addExportPane();
        addSignPane();
        addBuildPane();
        signVerifyMsgGridPane = addSignVerifyMsgPane(new GridPane());
        hideAllPanes();
        inputsGridPane.setVisible(true);

        // Notes:
        // Open with alt+g
        // Priv key is only visible if pw protection is removed (wallet details data (alt+j))
        // Take missing buyerPubKeyAsHex and sellerPubKeyAsHex from contract data!
        // Lookup sellerPrivateKeyAsHex associated with sellerPubKeyAsHex (or buyers) in wallet details data
        // sellerPubKeys/buyerPubKeys are auto generated if used the fields below
    }

    private void addLeftPanelButtons() {
        Button buttonInputs = new AutoTooltipButton(""Inputs"");
        Button buttonImport = new AutoTooltipButton(""Import"");
        Button buttonExport = new AutoTooltipButton(""Export"");
        Button buttonSign = new AutoTooltipButton(""Sign"");
        Button buttonBuild = new AutoTooltipButton(""Build"");
        Button buttonSignVerifyMsg = new AutoTooltipButton(""Sign/Verify Msg"");
        VBox vBox = new VBox(12, buttonInputs, buttonImport, buttonExport, buttonSign, buttonBuild, buttonSignVerifyMsg);
        vBox.getChildren().forEach(button -> ((Button) button).setPrefWidth(500));
        gridPane.add(vBox, 0, rowIndex);
        buttonInputs.getStyleClass().add(""action-button"");
        buttonInputs.setOnAction(e -> { // just show the inputs pane
            hideAllPanes();
            vBox.getChildren().forEach(button -> button.getStyleClass().remove(""action-button""));
            buttonInputs.getStyleClass().add(""action-button"");
            inputsGridPane.setVisible(true);
        });
        buttonImport.setOnAction(e -> { // just show the import pane
            hideAllPanes();
            vBox.getChildren().forEach(button -> button.getStyleClass().remove(""action-button""));
            buttonImport.getStyleClass().add(""action-button"");
            importTxGridPane.setVisible(true);
            importHex.setText("""");
        });
        buttonExport.setOnAction(e -> { // show export pane and fill in the data
            hideAllPanes();
            vBox.getChildren().forEach(button -> button.getStyleClass().remove(""action-button""));
            buttonExport.getStyleClass().add(""action-button"");
            exportTxGridPane.setVisible(true);
            exportHex.setText(generateExportText());
        });
        buttonSign.setOnAction(e -> {   // just show the sign pane
            hideAllPanes();
            vBox.getChildren().forEach(button -> button.getStyleClass().remove(""action-button""));
            buttonSign.getStyleClass().add(""action-button"");
            signTxGridPane.setVisible(true);
            privateKeyHex.setText("""");
            signatureHex.setText("""");
        });
        buttonBuild.setOnAction(e -> {  // just show the build pane
            hideAllPanes();
            vBox.getChildren().forEach(button -> button.getStyleClass().remove(""action-button""));
            buttonBuild.getStyleClass().add(""action-button"");
            buildTxGridPane.setVisible(true);
            finalSignedTxHex.setText("""");
        });
        buttonSignVerifyMsg.setOnAction(e -> {  // just show the sign msg pane
            hideAllPanes();
            vBox.getChildren().forEach(button -> button.getStyleClass().remove(""action-button""));
            buttonSignVerifyMsg.getStyleClass().add(""action-button"");
            signVerifyMsgGridPane.setVisible(true);
        });
    }

    private void addInputsPane() {
        inputsGridPane = new GridPane();
        gridPane.add(inputsGridPane, 1, rowIndex);
        int rowIndexA = 0;

        depositTxLegacy = addCheckBox(inputsGridPane, rowIndexA, ""depositTxLegacy"");

        Tooltip tooltip = new Tooltip(Res.get(""txIdTextField.blockExplorerIcon.tooltip""));
        Label blockExplorerIcon = new Label();
        blockExplorerIcon.getStyleClass().addAll(""icon"", ""highlight"");
        blockExplorerIcon.setTooltip(tooltip);
        AwesomeDude.setIcon(blockExplorerIcon, AwesomeIcon.EXTERNAL_LINK);
        blockExplorerIcon.setMinWidth(20);
        blockExplorerIcon.setOnMouseClicked(mouseEvent -> openBlockExplorer(depositTxHex.getText()));
        depositTxHex = addInputTextField(inputsGridPane, rowIndexA, ""depositTxId"");
        HBox hBoxTx = new HBox(12, depositTxHex, blockExplorerIcon);
        hBoxTx.setAlignment(Pos.BASELINE_LEFT);
        hBoxTx.setPrefWidth(800);
        inputsGridPane.add(new Label(""""), 0, ++rowIndexA);  // spacer
        inputsGridPane.add(hBoxTx, 0, ++rowIndexA);

        amountInMultisig = addInputTextField(inputsGridPane, ++rowIndexA, ""amountInMultisig"");
        inputsGridPane.add(new Label(""""), 0, ++rowIndexA);  // spacer
        buyerPayoutAmount = addInputTextField(inputsGridPane, rowIndexA, ""buyerPayoutAmount"");
        sellerPayoutAmount = addInputTextField(inputsGridPane, rowIndexA, ""sellerPayoutAmount"");
        txFee = addInputTextField(inputsGridPane, rowIndexA, ""Tx fee"");
        txFee.setEditable(false);
        txFeePct = addInputTextField(inputsGridPane, rowIndexA, ""Tx fee %"");
        txFeePct.setEditable(false);
        PercentageNumberValidator validator = new PercentageNumberValidator();
        validator.setMaxValue(10D);
        txFeePct.setValidator(validator);

        HBox hBox = new HBox(12, buyerPayoutAmount, sellerPayoutAmount, txFee, txFeePct);
        hBox.setAlignment(Pos.BASELINE_LEFT);
        hBox.setPrefWidth(800);
        inputsGridPane.add(hBox, 0, ++rowIndexA);
        buyerAddressString = addInputTextField(inputsGridPane, ++rowIndexA, ""buyerPayoutAddress"");
        sellerAddressString = addInputTextField(inputsGridPane, ++rowIndexA, ""sellerPayoutAddress"");
        buyerPubKeyAsHex = addInputTextField(inputsGridPane, ++rowIndexA, ""buyerPubKeyAsHex"");
        sellerPubKeyAsHex = addInputTextField(inputsGridPane, ++rowIndexA, ""sellerPubKeyAsHex"");
        depositTxHex.setPrefWidth(800);
        depositTxLegacy.setAllowIndeterminate(false);
        depositTxLegacy.setSelected(false);
        depositTxHex.setValidator(new LengthValidator(HEX_HASH_LENGTH, HEX_HASH_LENGTH));
        buyerAddressString.setValidator(new LengthValidator(20, 80));
        sellerAddressString.setValidator(new LengthValidator(20, 80));
        buyerPubKeyAsHex.setValidator(new LengthValidator(HEX_PUBKEY_LENGTH, HEX_PUBKEY_LENGTH));
        sellerPubKeyAsHex.setValidator(new LengthValidator(HEX_PUBKEY_LENGTH, HEX_PUBKEY_LENGTH));
    }

    private void addImportPane() {
        int rowIndexB = 0;
        importTxGridPane = new GridPane();
        gridPane.add(importTxGridPane, 1, rowIndex);
        importHex = new BisqTextArea();
        importHex.setEditable(true);
        importHex.setWrapText(true);
        importHex.setPrefSize(800, 150);
        importTxGridPane.add(importHex, 0, ++rowIndexB);
        importTxGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer
        Button buttonImport = new AutoTooltipButton(""Import From String"");
        buttonImport.setOnAction(e -> {
            // here we need to populate the ""inputs"" fields from the data contained in the TextArea
            if (doImport(importHex.getText())) {
                // switch back to the inputs pane
                hideAllPanes();
                inputsGridPane.setVisible(true);
            }
        });
        HBox hBox = new HBox(12, buttonImport);
        hBox.setAlignment(Pos.BASELINE_CENTER);
        hBox.setPrefWidth(800);
        importTxGridPane.add(hBox, 0, ++rowIndexB);
        importTxGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer

        final Separator separator = new Separator(Orientation.HORIZONTAL);
        separator.setPadding(new Insets(10, 10, 10, 10));
        importTxGridPane.add(separator, 0, ++rowIndexB);

        importTxGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer
        final Tuple2<Label, ComboBox<String>> xTuple = addTopLabelComboBox(importTxGridPane, rowIndexB, ""Mediation Ticket"", """", 0);
        mediationDropDown = xTuple.second;
        recentTickets = addCheckBox(importTxGridPane, rowIndexB, ""Recent Tickets"");
        recentTickets.setSelected(true);
        HBox hBox2 = new HBox(12, mediationDropDown, recentTickets);
        hBox2.setAlignment(Pos.BASELINE_CENTER);
        hBox2.setPrefWidth(800);
        importTxGridPane.add(hBox2, 0, ++rowIndexB);
        populateMediationTicketCombo(recentTickets.isSelected());
        recentTickets.setOnAction(e -> {
            populateMediationTicketCombo(recentTickets.isSelected());
        });
        importTxGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer
        Button buttonImportTicket = new AutoTooltipButton(""Import From Mediation Ticket"");
        buttonImportTicket.setOnAction(e -> {
            // here we need to populate the ""inputs"" fields from the chosen mediator ticket
            importFromMediationTicket(mediationDropDown.getValue());
        });
        HBox hBox3 = new HBox(12, buttonImportTicket);
        hBox3.setAlignment(Pos.BASELINE_CENTER);
        hBox3.setPrefWidth(800);
        importTxGridPane.add(hBox3, 0, ++rowIndexB);
    }

    private void addExportPane() {
        exportTxGridPane = new GridPane();
        gridPane.add(exportTxGridPane, 1, rowIndex);
        exportHex = new BisqTextArea();
        exportHex.setEditable(false);
        exportHex.setWrapText(true);
        exportHex.setPrefSize(800, 250);
        exportTxGridPane.add(exportHex, 0, 1);
    }

    private void addSignPane() {
        int rowIndexB = 0;
        signTxGridPane = new GridPane();
        gridPane.add(signTxGridPane, 1, rowIndex);
        privateKeyHex = addInputTextField(inputsGridPane, ++rowIndexB, ""privateKeyHex"");
        signTxGridPane.add(privateKeyHex, 0, ++rowIndexB);
        signatureHex = addInputTextField(signTxGridPane, ++rowIndexB, ""signatureHex"");
        signatureHex.setPrefWidth(800);
        signatureHex.setEditable(false);
        Label copyIcon = new Label();
        copyIcon.setTooltip(new Tooltip(Res.get(""txIdTextField.copyIcon.tooltip"")));
        AwesomeDude.setIcon(copyIcon, AwesomeIcon.COPY);
        copyIcon.getStyleClass().addAll(""icon"", ""highlight"");
        copyIcon.setMinWidth(20);
        copyIcon.setOnMouseClicked(mouseEvent -> Utilities.copyToClipboard(signatureHex.getText()));
        HBox hBoxSig = new HBox(12, signatureHex, copyIcon);
        hBoxSig.setAlignment(Pos.BASELINE_LEFT);
        hBoxSig.setPrefWidth(800);
        signTxGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer
        signTxGridPane.add(hBoxSig, 0, ++rowIndexB);
        signTxGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer
        Button buttonLocate = new AutoTooltipButton(""Locate key in wallet"");
        Button buttonSign = new AutoTooltipButton(""Generate Signature"");
        HBox hBox = new HBox(12, buttonLocate, buttonSign);
        hBox.setAlignment(Pos.BASELINE_CENTER);
        hBox.setPrefWidth(800);
        signTxGridPane.add(hBox, 0, ++rowIndexB);
        buttonLocate.setOnAction(e -> {
            if (!validateInputFields()) {
                signatureHex.setText(""You need to fill in the inputs tab first"");
                return;
            }
            String walletInfo = walletsManager.getWalletsAsString(true);
            String privateKeyText = findPrivForPubOrAddress(walletInfo, buyerPubKeyAsHex.getText());
            if (privateKeyText == null) {
                privateKeyText = findPrivForPubOrAddress(walletInfo, sellerPubKeyAsHex.getText());
            }
            if (privateKeyText == null) {
                privateKeyText = ""Not found in wallet"";
            }
            privateKeyHex.setText(privateKeyText);
        });
        buttonSign.setOnAction(e -> {
            signatureHex.setText(generateSignature());
        });
    }

    private void addBuildPane() {
        buildTxGridPane = new GridPane();
        gridPane.add(buildTxGridPane, 1, rowIndex);
        int rowIndexA = 0;
        buyerSignatureAsHex = addInputTextField(buildTxGridPane, ++rowIndexA, ""buyerSignatureAsHex"");
        sellerSignatureAsHex = addInputTextField(buildTxGridPane, ++rowIndexA, ""sellerSignatureAsHex"");
        buildTxGridPane.add(new Label(""""), 0, ++rowIndexA);  // spacer
        finalSignedTxHex = new BisqTextArea();
        finalSignedTxHex.setEditable(false);
        finalSignedTxHex.setWrapText(true);
        finalSignedTxHex.setPrefSize(800, 250);
        buildTxGridPane.add(finalSignedTxHex, 0, ++rowIndexA);
        buildTxGridPane.add(new Label(""""), 0, ++rowIndexA);  // spacer
        Button buttonBuild = new AutoTooltipButton(""Build"");
        Button buttonBroadcast = new AutoTooltipButton(""Broadcast"");
        HBox hBox = new HBox(12, buttonBuild, buttonBroadcast);
        hBox.setAlignment(Pos.BASELINE_CENTER);
        hBox.setPrefWidth(800);
        buildTxGridPane.add(hBox, 0, ++rowIndexA);
        buttonBuild.setOnAction(e -> {
            finalSignedTxHex.setText(buildFinalTx(false));
        });
        buttonBroadcast.setOnAction(e -> {
            finalSignedTxHex.setText(buildFinalTx(true));
        });
    }

    private GridPane addSignVerifyMsgPane(GridPane myGridPane) {
        int rowIndexB = 0;
        gridPane.add(myGridPane, 1, rowIndex);
        TextArea messageText = new BisqTextArea();
        messageText.setPromptText(""Message"");
        messageText.setEditable(true);
        messageText.setWrapText(true);
        messageText.setPrefSize(800, 150);
        myGridPane.add(messageText, 0, ++rowIndexB);
        myGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer
        InputTextField address = addInputTextField(myGridPane, ++rowIndexB, ""Address"");
        myGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer
        TextArea messageSig = new BisqTextArea();
        messageSig.setPromptText(""Signature"");
        messageSig.setEditable(true);
        messageSig.setWrapText(true);
        messageSig.setPrefSize(800, 65);
        myGridPane.add(messageSig, 0, ++rowIndexB);
        myGridPane.add(new Label(""""), 0, ++rowIndexB);  // spacer
        Button buttonSign = new AutoTooltipButton(""Sign"");
        Button buttonVerify = new AutoTooltipButton(""Verify"");
        HBox buttonBox = new HBox(12, buttonSign, buttonVerify);
        buttonBox.setAlignment(Pos.BASELINE_CENTER);
        buttonBox.setPrefWidth(800);
        myGridPane.add(buttonBox, 0, ++rowIndexB);

        buttonSign.setOnAction(e -> {
            String walletInfo = walletsManager.getWalletsAsString(true);
            String privKeyHex = findPrivForPubOrAddress(walletInfo, address.getText());
            if (privKeyHex == null) {
                messageSig.setText("""");
                new Popup().information(""Key not found in wallet"").show();
            } else {
                ECKey myPrivateKey = ECKey.fromPrivate(Utils.HEX.decode(privKeyHex));
                String signatureBase64 = myPrivateKey.signMessage(messageText.getText());
                messageSig.setText(signatureBase64);
            }
        });
        buttonVerify.setOnAction(e -> {
            try {
                ECKey key = ECKey.signedMessageToKey(messageText.getText(), messageSig.getText());
                Address address1 = Address.fromKey(Config.baseCurrencyNetworkParameters(), key, Script.ScriptType.P2PKH);
                Address address2 = Address.fromKey(Config.baseCurrencyNetworkParameters(), key, Script.ScriptType.P2WPKH);
                if (address.getText().equalsIgnoreCase(address1.toString()) ||
                        address.getText().equalsIgnoreCase(address2.toString())) {
                    new Popup().information(""Signature verified"").show();
                } else {
                    new Popup().warning(""Wrong signature"").show();
                }
            } catch (SignatureException ex) {
                log.warn(ex.toString());
                new Popup().warning(""Wrong signature"").show();
            }
        });
        return myGridPane;
    }

    private void hideAllPanes() {
        inputsGridPane.setVisible(false);
        importTxGridPane.setVisible(false);
        exportTxGridPane.setVisible(false);
        signTxGridPane.setVisible(false);
        buildTxGridPane.setVisible(false);
        signVerifyMsgGridPane.setVisible(false);
    }

    private void populateMediationTicketCombo(boolean recentTicketsOnly) {
        Instant twoWeeksAgo = Instant.ofEpochSecond(Instant.now().getEpochSecond() - TimeUnit.DAYS.toSeconds(14));
        disputeObservableList = mediationManager.getDisputesAsObservableList();
        ObservableList<String> disputeIds = FXCollections.observableArrayList();
        for (Dispute dispute :disputeObservableList) {
            if (dispute.getDisputePayoutTxId() != null)    // only show disputes not paid out
                continue;
            if (recentTicketsOnly && dispute.getOpeningDate().toInstant().isBefore(twoWeeksAgo))
                continue;
            if (!disputeIds.contains(dispute.getTradeId()))
                disputeIds.add(dispute.getTradeId());
        }
        disputeIds.sort((a, b) -> a.compareTo(b));
        mediationDropDown.setItems(disputeIds);
    }

    private void clearInputFields() {
        depositTxHex.setText("""");
        amountInMultisig.setText("""");
        buyerPayoutAmount.setText("""");
        sellerPayoutAmount.setText("""");
        buyerAddressString.setText("""");
        sellerAddressString.setText("""");
        buyerPubKeyAsHex.setText("""");
        sellerPubKeyAsHex.setText("""");
    }

    private boolean validateInputFields() {
        return (depositTxHex.getText().length() == HEX_HASH_LENGTH &&
                amountInMultisig.getText().length() > 0 &&
                buyerPayoutAmount.getText().length() > 0 &&
                sellerPayoutAmount.getText().length() > 0 &&
                txFee.getText().length() > 0 &&
                buyerAddressString.getText().length() > 0 &&
                sellerAddressString.getText().length() > 0 &&
                buyerPubKeyAsHex.getText().length() == HEX_PUBKEY_LENGTH &&
                sellerPubKeyAsHex.getText().length() == HEX_PUBKEY_LENGTH &&
                txFeePct.getValidator().validate(txFeePct.getText()).isValid);
    }

    private boolean validateInputFieldsAndSignatures() {
        return (validateInputFields() &&
                buyerSignatureAsHex.getText().length() > 0 &&
                sellerSignatureAsHex.getText().length() > 0);
    }

    private Coin getInputFieldAsCoin(InputTextField inputTextField) {
        try {
            return Coin.parseCoin(inputTextField.getText().trim());
        } catch (RuntimeException ignore) {
        }
        return Coin.ZERO;
    }

    private void calculateTxFee() {
        if (buyerPayoutAmount.getText().length() > 0 &&
                sellerPayoutAmount.getText().length() > 0 &&
                amountInMultisig.getText().length() > 0) {
            Coin txFeeValue = getInputFieldAsCoin(amountInMultisig)
                    .subtract(getInputFieldAsCoin(buyerPayoutAmount))
                    .subtract(getInputFieldAsCoin(sellerPayoutAmount));
            txFee.setText(txFeeValue.toPlainString());
            double feePercent = (double) txFeeValue.value / getInputFieldAsCoin(amountInMultisig).value;
            txFeePct.setText(String.format(""%.2f"", feePercent * 100));
        }
    }

    private void openBlockExplorer(String txId) {
        if (txId.length() != HEX_HASH_LENGTH)
            return;
        if (preferences != null) {
            BlockChainExplorer blockChainExplorer = preferences.getBlockChainExplorer();
            GUIUtil.openWebPage(blockChainExplorer.txUrl + txId, false);
        }
    }

    private String findPrivForPubOrAddress(String walletInfo, String searchKey) {
        // split the walletInfo into lines, strip whitespace
        // look for lines beginning ""  addr:"" followed by ""DeterministicKey{pub HEX="" .... "", priv HEX=""
        int lineIndex = 0;
        while (lineIndex < walletInfo.length() && lineIndex != -1) {
            lineIndex = walletInfo.indexOf(""  addr:"", lineIndex);
            if (lineIndex == -1) {
                return  null;
            }
            int toIndex = walletInfo.indexOf(""}"", lineIndex);
            if (toIndex == -1) {
                return  null;
            }
            String candidate1 = walletInfo.substring(lineIndex, toIndex);
            lineIndex = toIndex;
            // do we have the search key?
            if (candidate1.indexOf(searchKey, 0) > -1) {
                int startOfPriv = candidate1.indexOf(""priv HEX="", 0);
                if (startOfPriv > -1) {
                    return candidate1.substring(startOfPriv + 9, startOfPriv + 9 + HEX_HASH_LENGTH);
                }
            }
        }
        return null;
    }

    private String generateExportText() {
        // check that all input fields have been entered, except signatures
        ArrayList<String> fieldList = new ArrayList<>();
        fieldList.add(depositTxLegacy.isSelected() ? ""legacy"" : ""segwit"");
        fieldList.add(depositTxHex.getText());
        fieldList.add(amountInMultisig.getText());
        fieldList.add(buyerPayoutAmount.getText());
        fieldList.add(sellerPayoutAmount.getText());
        fieldList.add(buyerAddressString.getText());
        fieldList.add(sellerAddressString.getText());
        fieldList.add(buyerPubKeyAsHex.getText());
        fieldList.add(sellerPubKeyAsHex.getText());
        for (String item : fieldList) {
            if (item.length() < 1) {
                return ""You need to fill in the inputs first"";
            }
        }
        String listString = String.join("":"", fieldList);
        String base64encoded = Base64.encode(listString.getBytes());
        return base64encoded;
    }

    private boolean doImport(String importedText) {
        try {
            clearInputFields();
            String decoded = new String(Base64.decode(importedText.replaceAll(""\\s+"", """")), Charset.forName(""UTF-8""));
            String splitArray[] = decoded.split("":"");
            if (splitArray.length < 9) {
                importHex.setText(""Import failed - data format incorrect"");
                return false;
            }
            int fieldIndex = 0;
            depositTxLegacy.setSelected(splitArray[fieldIndex++].equalsIgnoreCase(""legacy""));
            depositTxHex.setText(splitArray[fieldIndex++]);
            amountInMultisig.setText(splitArray[fieldIndex++]);
            buyerPayoutAmount.setText(splitArray[fieldIndex++]);
            sellerPayoutAmount.setText(splitArray[fieldIndex++]);
            buyerAddressString.setText(splitArray[fieldIndex++]);
            sellerAddressString.setText(splitArray[fieldIndex++]);
            buyerPubKeyAsHex.setText(splitArray[fieldIndex++]);
            sellerPubKeyAsHex.setText(splitArray[fieldIndex++]);
            calculateTxFee();
        } catch (IllegalArgumentException e) {
            importHex.setText(""Import failed - base64 string incorrect"");
            return false;
        }
        return true;
    }

    private void importFromMediationTicket(String tradeId) {
        clearInputFields();
        Optional<Dispute> optionalDispute = mediationManager.findDispute(tradeId);
        if (optionalDispute.isPresent()) {
            Dispute dispute = optionalDispute.get();
            depositTxHex.setText(dispute.getDepositTxId());
            if (dispute.disputeResultProperty().get() != null) {
                buyerPayoutAmount.setText(dispute.disputeResultProperty().get().getBuyerPayoutAmount().toPlainString());
                sellerPayoutAmount.setText(dispute.disputeResultProperty().get().getSellerPayoutAmount().toPlainString());
            }
            buyerAddressString.setText(dispute.getContract().getBuyerPayoutAddressString());
            sellerAddressString.setText(dispute.getContract().getSellerPayoutAddressString());
            buyerPubKeyAsHex.setText(Utils.HEX.encode(dispute.getContract().getBuyerMultiSigPubKey()));
            sellerPubKeyAsHex.setText(Utils.HEX.encode(dispute.getContract().getSellerMultiSigPubKey()));
            // switch back to the inputs pane
            hideAllPanes();
            inputsGridPane.setVisible(true);
            UserThread.execute(() -> new Popup().warning(""Ticket imported.  You still need to enter the multisig amount and specify if it is a legacy Tx"").show());
        }
    }

    private String generateSignature() {
        calculateTxFee();
        // check that all input fields have been entered, except signatures
        if (!validateInputFields() || privateKeyHex.getText().length() < 1) {
            return ""You need to fill in the inputs first"";
        }

        String retVal = """";
        try {
            Tuple2<String, String> combined = tradeWalletService.emergencyBuildPayoutTxFrom2of2MultiSig(depositTxHex.getText(),
                    getInputFieldAsCoin(buyerPayoutAmount),
                    getInputFieldAsCoin(sellerPayoutAmount),
                    getInputFieldAsCoin(txFee),
                    buyerAddressString.getText(),
                    sellerAddressString.getText(),
                    buyerPubKeyAsHex.getText(),
                    sellerPubKeyAsHex.getText(),
                    depositTxLegacy.isSelected());
            String redeemScriptHex = combined.first;
            String unsignedTxHex =  combined.second;
            retVal = tradeWalletService.emergencyGenerateSignature(
                    unsignedTxHex,
                    redeemScriptHex,
                    getInputFieldAsCoin(amountInMultisig),
                    privateKeyHex.getText());
        } catch (IllegalArgumentException ee) {
            log.error(ee.toString());
            ee.printStackTrace();
            UserThread.execute(() -> new Popup().warning(ee.toString()).show());
        }
        return retVal;
    }

    private String buildFinalTx(boolean broadcastIt) {
        String retVal = """";
        calculateTxFee();
        // check that all input fields have been entered, including signatures
        if (!validateInputFieldsAndSignatures()) {
            retVal = ""You need to fill in the inputs first"";
        } else {
            try {
                // grab data from the inputs pane, build an unsigned tx and write it to the TextArea
                Tuple2<String, String> combined = tradeWalletService.emergencyBuildPayoutTxFrom2of2MultiSig(depositTxHex.getText(),
                        getInputFieldAsCoin(buyerPayoutAmount),
                        getInputFieldAsCoin(sellerPayoutAmount),
                        getInputFieldAsCoin(txFee),
                        buyerAddressString.getText(),
                        sellerAddressString.getText(),
                        buyerPubKeyAsHex.getText(),
                        sellerPubKeyAsHex.getText(),
                        depositTxLegacy.isSelected());
                String redeemScriptHex = combined.first;
                String unsignedTxHex =  combined.second;
                Tuple2<String, String> txIdAndHex = tradeWalletService.emergencyApplySignatureToPayoutTxFrom2of2MultiSig(
                        unsignedTxHex,
                        redeemScriptHex,
                        buyerSignatureAsHex.getText(),
                        sellerSignatureAsHex.getText(),
                        depositTxLegacy.isSelected());
                retVal = ""txId:{"" + txIdAndHex.first + ""}\r\ntxHex:{"" + txIdAndHex.second + ""}"";

                if (broadcastIt) {
                    TxBroadcaster.Callback callback = new TxBroadcaster.Callback() {
                        @Override
                        public void onSuccess(@Nullable Transaction result) {
                            log.info(""onSuccess"");
                            UserThread.execute(() -> {
                                String txId = result != null ? result.getTxId().toString() : ""null"";
                                new Popup().information(""Transaction successfully published. Transaction ID: "" + txId).show();
                            });
                        }
                        @Override
                        public void onFailure(TxBroadcastException exception) {
                            log.error(exception.toString());
                            UserThread.execute(() -> new Popup().warning(exception.toString()).show());
                        }
                    };

                    if (GUIUtil.isReadyForTxBroadcastOrShowPopup(p2PService, walletsSetup)) {
                        try {
                            tradeWalletService.emergencyPublishPayoutTxFrom2of2MultiSig(
                                    txIdAndHex.second,
                                    callback);
                        } catch (AddressFormatException | WalletException | TransactionVerificationException ee) {
                            log.error(ee.toString());
                            ee.printStackTrace();
                            UserThread.execute(() -> new Popup().warning(ee.toString()).show());
                        }
                    }
                }
            } catch (IllegalArgumentException | SignatureDecodeException | VerificationException ee) {
                log.error(ee.toString());
                ee.printStackTrace();
                retVal = ee.toString();
            }
        }
        return retVal;
    }

}",1,439 334 2000 378 2001 60 2000 62 123 437 457 381 404 2002 61 1503 42 1502 59 437 457 381 404 2003 61 1503 42 1502 59 437 457 381 2004 2005 61 2006 46 2007 40 2000 46 334 41 59 437 381 2008 2009 59 437 381 2010 2011 59 437 381 2012 2013 59 437 381 2014 2015 59 437 381 2016 2017 59 437 381 2018 2019 59 2020 2021 59 2020 2022 59 2020 2023 59 2020 2024 59 2020 2025 59 2020 2026 59 2027 2028 44 2029 59 2030 60 2031 62 2032 59 2033 60 2034 62 2035 59 2036 2037 59 2036 2038 59 2036 2039 59 2036 2040 59 2036 2041 59 2036 2042 59 2036 2043 59 2036 2044 59 2036 2045 59 2036 2046 59 2036 2047 59 2036 2048 59 2036 2049 59 2036 2050 59 2051 2052 59 2051 2053 59 2051 2054 59 437 2055 60 2056 62 2057 44 2058 44 2059 44 2060 59 621 621 621 64 2061 439 2000 40 2008 2009 44 2010 2011 44 2012 2013 44 2014 2015 44 2016 2017 44 2018 2019 41 123 467 46 2009 61 2009 59 467 46 2011 61 2011 59 467 46 2013 61 2013 59 467 46 2015 61 2015 59 467 46 2017 61 2017 59 467 46 2019 61 2019 59 2062 61 2063 46 2064 59 125 439 492 2065 40 41 123 392 40 2066 614 424 41 2066 61 648 59 621 2067 61 1505 59 2068 40 41 59 2069 40 41 59 2070 40 41 59 2071 40 41 59 2072 40 41 59 2057 61 40 2073 44 2074 44 2075 41 45 62 123 2076 40 41 59 125 59 2059 61 40 2073 44 2074 44 2075 41 45 62 123 2077 40 41 59 125 59 2060 61 40 2073 44 2074 44 2075 41 45 62 123 2078 40 41 59 125 59 2058 61 40 2073 44 2074 44 2075 41 45 62 123 2079 40 41 59 125 59 2041 46 2080 40 41 46 2081 40 2057 41 59 2039 46 2080 40 41 46 2081 40 2059 41 59 2040 46 2080 40 41 46 2081 40 2060 41 59 2038 46 2080 40 41 46 2081 40 2058 41 59 2082 40 41 59 125 621 621 621 64 2083 438 492 2084 40 2085 2086 41 123 392 40 33 2087 41 123 2086 46 2088 40 2089 45 62 123 392 40 2089 46 2090 40 41 614 2091 46 2092 41 123 2089 46 2093 40 41 59 2094 40 41 59 125 125 41 59 125 125 64 2083 438 492 2095 40 41 123 2096 61 418 2020 40 41 59 2096 46 2097 40 1503 41 59 2096 46 2098 40 1503 41 59 2096 46 2099 40 418 2100 40 1503 44 1503 44 1503 44 1503 41 41 59 2096 46 2101 40 2102 41 59 2103 2104 61 418 2103 40 41 59 2103 2105 61 418 2103 40 41 59 2104 46 2106 40 1503 41 59 2105 46 2106 40 1503 41 59 2096 46 2107 40 41 46 2108 40 2104 44 2105 41 59 125 64 2083 438 492 2109 40 41 123 2041 46 2110 40 41 46 2111 40 2057 41 59 2039 46 2110 40 41 46 2111 40 2059 41 59 2040 46 2110 40 41 46 2111 40 2060 41 59 2038 46 2110 40 41 46 2111 40 2058 41 59 463 46 2109 40 41 59 125 437 492 2112 40 41 123 2113 61 1501 59 467 46 2114 61 473 59 2115 40 41 59 2116 40 41 59 2117 40 41 59 2118 40 41 59 2119 40 41 59 2120 40 41 59 2026 61 2121 40 418 2020 40 41 41 59 2122 40 41 59 2021 46 2123 40 473 41 59 621 621 621 621 621 621 125 437 492 2124 40 41 123 2125 2126 61 418 2127 40 648 41 59 2125 2128 61 418 2127 40 648 41 59 2125 2129 61 418 2127 40 648 41 59 2125 2130 61 418 2127 40 648 41 59 2125 2131 61 418 2127 40 648 41 59 2125 2132 61 418 2127 40 648 41 59 2133 2134 61 418 2133 40 1503 44 2126 44 2128 44 2129 44 2130 44 2131 44 2132 41 59 2134 46 2135 40 41 46 2136 40 2137 45 62 40 40 2125 41 2137 41 46 2138 40 1504 41 41 59 2139 46 2140 40 2134 44 1500 44 2141 41 59 2126 46 2142 40 41 46 2140 40 648 41 59 2126 46 2143 40 2144 45 62 123 621 2145 40 41 59 2134 46 2135 40 41 46 2136 40 2137 45 62 2137 46 2142 40 41 46 2146 40 648 41 41 59 2126 46 2142 40 41 46 2140 40 648 41 59 2021 46 2147 40 473 41 59 125 41 59 2128 46 2143 40 2144 45 62 123 621 2148 40 41 59 2134 46 2135 40 41 46 2136 40 2137 45 62 2137 46 2142 40 41 46 2149 40 648 41 41 59 2128 46 2142 40 41 46 2140 40 648 41 59 2022 46 2150 40 473 41 59 2052 46 2151 40 648 41 59 125 41 59 2129 46 2143 40 2144 45 62 123 621 2152 40 41 59 2134 46 2135 40 41 46 2136 40 2137 45 62 2137 46 2142 40 41 46 2153 40 648 41 41 59 2129 46 2142 40 41 46 2140 40 648 41 59 2023 46 2154 40 473 41 59 2053 46 2155 40 2156 40 41 41 59 125 41 59 2130 46 2143 40 2144 45 62 123 621 2157 40 41 59 2134 46 2135 40 41 46 2136 40 2137 45 62 2137 46 2142 40 41 46 2158 40 648 41 41 59 2130 46 2142 40 41 46 2140 40 648 41 59 2024 46 2159 40 473 41 59 2049 46 2160 40 648 41 59 2050 46 2160 40 648 41 59 125 41 59 2131 46 2143 40 2144 45 62 123 621 2161 40 41 59 2134 46 2135 40 41 46 2136 40 2137 45 62 2137 46 2142 40 41 46 2162 40 648 41 41 59 2131 46 2142 40 41 46 2140 40 648 41 59 2025 46 2163 40 473 41 59 2054 46 2164 40 648 41 59 125 41 59 2132 46 2143 40 2144 45 62 123 621 2165 40 41 59 2134 46 2135 40 41 46 2136 40 2137 45 62 2137 46 2142 40 41 46 2166 40 648 41 41 59 2132 46 2142 40 41 46 2140 40 648 41 59 2026 46 2167 40 473 41 59 125 41 59 125 437 492 2168 40 41 123 2021 61 418 2020 40 41 59 2169 46 2170 40 2021 44 1501 44 2171 41 59 404 2172 61 1500 59 2028 61 2173 40 2021 44 2172 44 648 41 59 2174 2175 61 418 2174 40 2176 46 2177 40 648 41 41 59 2178 2179 61 418 2178 40 41 59 2179 46 2180 40 41 46 2181 40 648 44 648 41 59 2179 46 2182 40 2175 41 59 2183 46 2184 40 2179 44 2185 46 2186 41 59 2179 46 2187 40 1503 41 59 2179 46 2188 40 2189 45 62 2190 40 2037 46 2191 40 41 41 41 59 2037 61 2192 40 2021 44 2172 44 648 41 59 2193 2194 61 418 2193 40 1503 44 2037 44 2179 41 59 2194 46 2195 40 2196 46 2197 41 59 2194 46 2198 40 1504 41 59 2021 46 2170 40 418 2178 40 648 41 44 1500 44 637 2172 41 59 621 2021 46 2170 40 2194 44 1500 44 637 2172 41 59 2038 61 2192 40 2021 44 637 2172 44 648 41 59 2021 46 2170 40 418 2178 40 648 41 44 1500 44 637 2172 41 59 621 2039 61 2192 40 2021 44 2172 44 648 41 59 2040 61 2192 40 2021 44 2172 44 648 41 59 2041 61 2192 40 2021 44 2172 44 648 41 59 2041 46 2199 40 380 41 59 2042 61 2192 40 2021 44 2172 44 648 41 59 2042 46 2199 40 380 41 59 2200 2201 61 418 2200 40 41 59 2201 46 2202 40 1502 41 59 2042 46 2203 40 2201 41 59 2193 2204 61 418 2193 40 1503 44 2039 44 2040 44 2041 44 2042 41 59 2204 46 2195 40 2196 46 2197 41 59 2204 46 2198 40 1504 41 59 2021 46 2170 40 2204 44 1500 44 637 2172 41 59 2043 61 2192 40 2021 44 637 2172 44 648 41 59 2044 61 2192 40 2021 44 637 2172 44 648 41 59 2045 61 2192 40 2021 44 637 2172 44 648 41 59 2046 61 2192 40 2021 44 637 2172 44 648 41 59 2037 46 2198 40 1504 41 59 2028 46 2205 40 380 41 59 2028 46 2206 40 380 41 59 2037 46 2203 40 418 2207 40 2002 44 2002 41 41 59 2043 46 2203 40 418 2207 40 1503 44 1503 41 41 59 2044 46 2203 40 418 2207 40 1503 44 1503 41 41 59 2045 46 2203 40 418 2207 40 2003 44 2003 41 41 59 2046 46 2203 40 418 2207 40 2003 44 2003 41 41 59 125 437 492 2208 40 41 123 404 2209 61 1500 59 2022 61 418 2020 40 41 59 2210 46 2211 40 2022 44 1501 44 2212 41 59 2052 61 418 2213 40 41 59 2052 46 2214 40 473 41 59 2052 46 2215 40 473 41 59 2052 46 2216 40 1504 44 1504 41 59 2022 46 2211 40 2052 44 1500 44 637 2209 41 59 2022 46 2211 40 418 2217 40 648 41 44 1500 44 637 2209 41 59 621 2218 2219 61 418 2220 40 648 41 59 2219 46 2221 40 2222 45 62 123 621 392 40 2223 40 2052 46 2224 40 41 41 41 123 621 2225 40 41 59 2021 46 2226 40 473 41 59 125 125 41 59 2227 2228 61 418 2227 40 1503 44 2219 41 59 2228 46 2229 40 2230 46 2231 41 59 2228 46 2232 40 1504 41 59 2022 46 2211 40 2228 44 1500 44 637 2209 41 59 2022 46 2211 40 418 2217 40 648 41 44 1500 44 637 2209 41 59 621 381 2233 2234 61 418 2233 40 2235 46 2236 41 59 2234 46 2237 40 418 2238 40 1502 44 1502 44 1502 44 1502 41 41 59 2022 46 2211 40 2234 44 1500 44 637 2209 41 59 2022 46 2211 40 418 2217 40 648 41 44 1500 44 637 2209 41 59 621 381 2239 60 2217 44 2030 60 2031 641 2240 61 2241 40 2022 44 2209 44 648 44 648 44 1500 41 59 2032 61 2240 46 2242 59 2029 61 2243 40 2022 44 2209 44 648 41 59 2029 46 2244 40 473 41 59 2227 2245 61 418 2227 40 1503 44 2032 44 2029 41 59 2245 46 2229 40 2230 46 2231 41 59 2245 46 2232 40 1504 41 59 2022 46 2211 40 2245 44 1500 44 637 2209 41 59 2246 40 2029 46 2247 40 41 41 59 2029 46 2221 40 2222 45 62 123 2246 40 2029 46 2247 40 41 41 59 125 41 59 2022 46 2211 40 418 2217 40 648 41 44 1500 44 637 2209 41 59 621 2218 2248 61 418 2220 40 648 41 59 2248 46 2221 40 2222 45 62 123 621 2249 40 2032 46 2250 40 41 41 59 125 41 59 2227 2251 61 418 2227 40 1503 44 2248 41 59 2251 46 2229 40 2230 46 2231 41 59 2251 46 2232 40 1504 41 59 2022 46 2211 40 2251 44 1500 44 637 2209 41 59 125 437 492 2252 40 41 123 2023 61 418 2020 40 41 59 2253 46 2254 40 2023 44 1501 44 2255 41 59 2053 61 418 2256 40 41 59 2053 46 2257 40 380 41 59 2053 46 2258 40 473 41 59 2053 46 2259 40 1504 44 1504 41 59 2023 46 2254 40 2053 44 1500 44 1501 41 59 125 437 492 2260 40 41 123 404 2261 61 1500 59 2024 61 418 2020 40 41 59 2262 46 2263 40 2024 44 1501 44 2264 41 59 2049 61 2265 40 2021 44 637 2261 44 648 41 59 2024 46 2263 40 2049 44 1500 44 637 2261 41 59 2050 61 2265 40 2024 44 637 2261 44 648 41 59 2050 46 2266 40 1504 41 59 2050 46 2267 40 380 41 59 2268 2269 61 418 2268 40 41 59 2269 46 2270 40 418 2271 40 2272 46 2273 40 648 41 41 41 59 2274 46 2275 40 2269 44 2276 46 2277 41 59 2269 46 2278 40 41 46 2279 40 648 44 648 41 59 2269 46 2280 40 1503 41 59 2269 46 2281 40 2282 45 62 2283 46 2284 40 2050 46 2285 40 41 41 41 59 2286 2287 61 418 2286 40 1503 44 2050 44 2269 41 59 2287 46 2288 40 2289 46 2290 41 59 2287 46 2266 40 1504 41 59 2024 46 2263 40 418 2268 40 648 41 44 1500 44 637 2261 41 59 621 2024 46 2263 40 2287 44 1500 44 637 2261 41 59 2024 46 2263 40 418 2268 40 648 41 44 1500 44 637 2261 41 59 621 2291 2292 61 418 2293 40 648 41 59 2291 2294 61 418 2293 40 648 41 59 2286 2295 61 418 2286 40 1503 44 2292 44 2294 41 59 2295 46 2288 40 2289 46 2296 41 59 2295 46 2266 40 1504 41 59 2024 46 2263 40 2295 44 1500 44 637 2261 41 59 2292 46 2297 40 2298 45 62 123 392 40 33 2299 40 41 41 123 2050 46 2300 40 648 41 59 450 59 125 2031 2301 61 2019 46 2302 40 473 41 59 2031 2303 61 2304 40 2301 44 2045 46 2285 40 41 41 59 392 40 2303 614 424 41 123 2303 61 2304 40 2301 44 2046 46 2285 40 41 41 59 125 392 40 2303 614 424 41 123 2303 61 648 59 125 2049 46 2305 40 2303 41 59 125 41 59 2294 46 2297 40 2298 45 62 123 2050 46 2306 40 2307 40 41 41 59 125 41 59 125 437 492 2308 40 41 123 2025 61 418 2020 40 41 59 2309 46 2310 40 2025 44 1501 44 2311 41 59 404 2312 61 1500 59 2047 61 2313 40 2025 44 637 2312 44 648 41 59 2048 61 2313 40 2025 44 637 2312 44 648 41 59 2025 46 2310 40 418 2314 40 648 41 44 1500 44 637 2312 41 59 621 2054 61 418 2315 40 41 59 2054 46 2316 40 380 41 59 2054 46 2317 40 473 41 59 2054 46 2318 40 1504 44 1504 41 59 2025 46 2310 40 2054 44 1500 44 637 2312 41 59 2025 46 2310 40 418 2314 40 648 41 44 1500 44 637 2312 41 59 621 2319 2320 61 418 2321 40 648 41 59 2319 2322 61 418 2321 40 648 41 59 2323 2324 61 418 2323 40 1503 44 2320 44 2322 41 59 2324 46 2325 40 2326 46 2327 41 59 2324 46 2328 40 1504 41 59 2025 46 2310 40 2324 44 1500 44 637 2312 41 59 2320 46 2329 40 2330 45 62 123 2054 46 2331 40 2332 40 380 41 41 59 125 41 59 2322 46 2329 40 2330 45 62 123 2054 46 2333 40 2334 40 473 41 41 59 125 41 59 125 437 2020 2335 40 2020 2336 41 123 404 2337 61 1500 59 2338 46 2339 40 2336 44 1501 44 2340 41 59 2051 2341 61 418 2342 40 41 59 2341 46 2343 40 648 41 59 2341 46 2344 40 473 41 59 2341 46 2345 40 473 41 59 2341 46 2346 40 1504 44 1504 41 59 2336 46 2339 40 2341 44 1500 44 637 2337 41 59 2336 46 2339 40 418 2347 40 648 41 44 1500 44 637 2337 41 59 621 2036 2348 61 2349 40 2336 44 637 2337 44 648 41 59 2336 46 2339 40 418 2347 40 648 41 44 1500 44 637 2337 41 59 621 2051 2350 61 418 2342 40 41 59 2350 46 2343 40 648 41 59 2350 46 2344 40 473 41 59 2350 46 2345 40 473 41 59 2350 46 2346 40 1504 44 1503 41 59 2336 46 2339 40 2350 44 1500 44 637 2337 41 59 2336 46 2339 40 418 2347 40 648 41 44 1500 44 637 2337 41 59 621 2351 2352 61 418 2353 40 648 41 59 2351 2354 61 418 2353 40 648 41 59 2355 2356 61 418 2355 40 1503 44 2352 44 2354 41 59 2356 46 2357 40 2358 46 2359 41 59 2356 46 2360 40 1504 41 59 2336 46 2339 40 2356 44 1500 44 637 2337 41 59 2352 46 2361 40 2362 45 62 123 2031 2363 61 2019 46 2364 40 473 41 59 2031 2365 61 2366 40 2363 44 2348 46 2367 40 41 41 59 392 40 2365 614 424 41 123 2350 46 2368 40 648 41 59 418 2369 40 41 46 2370 40 648 41 46 2065 40 41 59 125 360 123 2371 2372 61 2371 46 2373 40 2374 46 2375 46 2376 40 2365 41 41 59 2031 2377 61 2372 46 2378 40 2341 46 2367 40 41 41 59 2350 46 2379 40 2377 41 59 125 125 41 59 2354 46 2361 40 2362 45 62 123 474 123 2380 2381 61 2380 46 2382 40 2341 46 2383 40 41 44 2350 46 2383 40 41 41 59 2384 2385 61 2384 46 2386 40 2387 46 2388 40 41 44 2381 44 2389 46 2390 46 2391 41 59 2384 2392 61 2384 46 2386 40 2387 46 2388 40 41 44 2381 44 2389 46 2390 46 2393 41 59 392 40 2348 46 2383 40 41 46 2394 40 2385 46 2395 40 41 41 606 2348 46 2383 40 41 46 2394 40 2392 46 2395 40 41 41 41 123 418 2396 40 41 46 2397 40 648 41 46 2065 40 41 59 125 360 123 418 2398 40 41 46 494 40 648 41 46 2065 40 41 59 125 125 329 40 2399 2400 41 123 2005 46 2401 40 2400 46 2402 40 41 41 59 418 2403 40 41 46 494 40 648 41 46 2065 40 41 59 125 125 41 59 450 2336 59 125 437 492 2404 40 41 123 2021 46 2405 40 380 41 59 2022 46 2405 40 380 41 59 2023 46 2405 40 380 41 59 2024 46 2405 40 380 41 59 2025 46 2405 40 380 41 59 2026 46 2405 40 380 41 59 125 437 492 2406 40 324 2407 41 123 2408 2409 61 2408 46 2410 40 2408 46 2411 40 41 46 2412 40 41 45 2413 46 2414 46 2415 40 1503 41 41 59 2035 61 2013 46 2416 40 41 59 2033 60 2031 62 2417 61 2418 46 2419 40 41 59 385 40 2034 2420 58 2035 41 123 392 40 2420 46 2421 40 41 631 424 41 621 344 59 392 40 2407 605 2420 46 2422 40 41 46 2423 40 41 46 2424 40 2409 41 41 344 59 392 40 33 2417 46 2425 40 2420 46 2426 40 41 41 41 2417 46 2427 40 2420 46 2426 40 41 41 59 125 2417 46 2428 40 40 2429 44 2430 41 45 62 2429 46 2431 40 2430 41 41 59 2032 46 2432 40 2417 41 59 125 437 492 2433 40 41 123 2037 46 2434 40 648 41 59 2038 46 2434 40 648 41 59 2039 46 2434 40 648 41 59 2040 46 2434 40 648 41 59 2043 46 2434 40 648 41 59 2044 46 2434 40 648 41 59 2045 46 2434 40 648 41 59 2046 46 2434 40 648 41 59 125 437 324 2435 40 41 123 450 40 2037 46 2436 40 41 46 2437 40 41 614 2002 605 2038 46 2436 40 41 46 2437 40 41 62 1500 605 2039 46 2436 40 41 46 2437 40 41 62 1500 605 2040 46 2436 40 41 46 2437 40 41 62 1500 605 2041 46 2436 40 41 46 2437 40 41 62 1500 605 2043 46 2436 40 41 46 2437 40 41 62 1500 605 2044 46 2436 40 41 46 2437 40 41 62 1500 605 2045 46 2436 40 41 46 2437 40 41 614 2003 605 2046 46 2436 40 41 46 2437 40 41 614 2003 605 2042 46 2438 40 41 46 2439 40 2042 46 2436 40 41 41 46 2440 41 59 125 437 324 2441 40 41 123 450 40 2435 40 41 605 2047 46 2442 40 41 46 2443 40 41 62 1500 605 2048 46 2442 40 41 46 2443 40 41 62 1500 41 59 125 437 2444 2445 40 2036 2446 41 123 474 123 450 2444 46 2447 40 2446 46 2448 40 41 46 2449 40 41 41 59 125 329 40 2450 2451 41 123 125 450 2444 46 2452 59 125 437 492 2453 40 41 123 392 40 2039 46 2454 40 41 46 2455 40 41 62 1500 605 2040 46 2454 40 41 46 2455 40 41 62 1500 605 2038 46 2454 40 41 46 2455 40 41 62 1500 41 123 2444 2456 61 2445 40 2038 41 46 2457 40 2445 40 2039 41 41 46 2457 40 2445 40 2040 41 41 59 2041 46 2458 40 2456 46 2459 40 41 41 59 356 2460 61 40 356 41 2456 46 2461 47 2445 40 2038 41 46 2461 59 2042 46 2458 40 2031 46 2462 40 648 44 2460 42 1503 41 41 59 125 125 437 492 2463 40 2031 2464 41 123 392 40 2464 46 2465 40 41 631 2002 41 450 59 392 40 2015 631 424 41 123 2466 2467 61 2015 46 2468 40 41 59 2469 46 2470 40 2467 46 2471 43 2464 44 380 41 59 125 125 437 2031 2472 40 2031 2473 44 2031 2474 41 123 621 621 404 2475 61 1500 59 496 40 2475 60 2473 46 2476 40 41 605 2475 631 45 1501 41 123 2475 61 2473 46 2477 40 648 44 2475 41 59 392 40 2475 614 45 1501 41 123 450 424 59 125 404 2478 61 2473 46 2477 40 648 44 2475 41 59 392 40 2478 614 45 1501 41 123 450 424 59 125 2031 2479 61 2473 46 2480 40 2475 44 2478 41 59 2475 61 2478 59 621 392 40 2479 46 2477 40 2474 44 1500 41 62 45 1501 41 123 404 2481 61 2479 46 2477 40 648 44 1500 41 59 392 40 2481 62 45 1501 41 123 450 2479 46 2480 40 2481 43 1502 44 2481 43 1502 43 2002 41 59 125 125 125 450 424 59 125 437 2031 2482 40 41 123 621 2483 60 2031 62 2484 61 418 2483 60 62 40 41 59 2484 46 2485 40 2028 46 2486 40 41 63 648 58 648 41 59 2484 46 2485 40 2037 46 2487 40 41 41 59 2484 46 2485 40 2038 46 2487 40 41 41 59 2484 46 2485 40 2039 46 2487 40 41 41 59 2484 46 2485 40 2040 46 2487 40 41 41 59 2484 46 2485 40 2043 46 2487 40 41 41 59 2484 46 2485 40 2044 46 2487 40 41 41 59 2484 46 2485 40 2045 46 2487 40 41 41 59 2484 46 2485 40 2046 46 2487 40 41 41 59 385 40 2031 2488 58 2484 41 123 392 40 2488 46 2489 40 41 60 1501 41 123 450 648 59 125 125 2031 2490 61 2031 46 2491 40 648 44 2484 41 59 2031 2492 61 2493 46 2494 40 2490 46 2495 40 41 41 59 450 2492 59 125 437 324 2496 40 2031 2497 41 123 474 123 2433 40 41 59 2031 2498 61 418 2031 40 2499 46 2500 40 2497 46 2501 40 648 44 648 41 41 44 2502 46 2503 40 648 41 41 59 2031 2504 91 93 61 2498 46 2505 40 648 41 59 392 40 2504 46 2506 60 1502 41 123 2052 46 2507 40 648 41 59 450 380 59 125 404 2508 61 1500 59 2028 46 2509 40 2504 91 2508 637 93 46 2510 40 648 41 41 59 2037 46 2511 40 2504 91 2508 637 93 41 59 2038 46 2511 40 2504 91 2508 637 93 41 59 2039 46 2511 40 2504 91 2508 637 93 41 59 2040 46 2511 40 2504 91 2508 637 93 41 59 2043 46 2511 40 2504 91 2508 637 93 41 59 2044 46 2511 40 2504 91 2508 637 93 41 59 2045 46 2511 40 2504 91 2508 637 93 41 59 2046 46 2511 40 2504 91 2508 637 93 41 59 2453 40 41 59 125 329 40 2512 2513 41 123 2052 46 2514 40 648 41 59 450 380 59 125 450 473 59 125 437 492 2515 40 2031 2516 41 123 2433 40 41 59 2517 60 2034 62 2518 61 2013 46 2519 40 2516 41 59 392 40 2518 46 2520 40 41 41 123 2034 2521 61 2518 46 2522 40 41 59 2037 46 2523 40 2521 46 2524 40 41 41 59 392 40 2521 46 2525 40 41 46 2522 40 41 631 424 41 123 2039 46 2523 40 2521 46 2525 40 41 46 2522 40 41 46 2526 40 41 46 2527 40 41 41 59 2040 46 2523 40 2521 46 2525 40 41 46 2522 40 41 46 2528 40 41 46 2527 40 41 41 59 125 2043 46 2523 40 2521 46 2529 40 41 46 2530 40 41 41 59 2044 46 2523 40 2521 46 2529 40 41 46 2531 40 41 41 59 2045 46 2523 40 2532 46 2533 46 2534 40 2521 46 2529 40 41 46 2535 40 41 41 41 59 2046 46 2523 40 2532 46 2533 46 2534 40 2521 46 2529 40 41 46 2536 40 41 41 41 59 621 2404 40 41 59 2021 46 2537 40 473 41 59 2538 46 2539 40 40 41 45 62 418 2540 40 41 46 494 40 648 41 46 2065 40 41 41 59 125 125 437 2031 2541 40 41 123 2453 40 41 59 621 392 40 33 2435 40 41 606 2049 46 2542 40 41 46 2543 40 41 60 1501 41 123 450 648 59 125 2031 2544 61 648 59 474 123 2545 60 2031 44 2031 62 2546 61 2009 46 2547 40 2037 46 2542 40 41 44 2445 40 2039 41 44 2445 40 2040 41 44 2445 40 2041 41 44 2043 46 2542 40 41 44 2044 46 2542 40 41 44 2045 46 2542 40 41 44 2046 46 2542 40 41 44 2028 46 2548 40 41 41 59 2031 2549 61 2546 46 2550 59 2031 2551 61 2546 46 2552 59 2544 61 2009 46 2553 40 2551 44 2549 44 2445 40 2038 41 44 2049 46 2542 40 41 41 59 125 329 40 2554 2555 41 123 2005 46 371 40 2555 46 2556 40 41 41 59 2555 46 2557 40 41 59 2558 46 2559 40 40 41 45 62 418 2560 40 41 46 494 40 2555 46 2556 40 41 41 46 2065 40 41 41 59 125 450 2544 59 125 437 2031 2561 40 324 2562 41 123 2031 2563 61 648 59 2453 40 41 59 621 392 40 33 2441 40 41 41 123 2563 61 648 59 125 360 123 474 123 621 2564 60 2031 44 2031 62 2565 61 2009 46 2566 40 2037 46 2567 40 41 44 2445 40 2039 41 44 2445 40 2040 41 44 2445 40 2041 41 44 2043 46 2567 40 41 44 2044 46 2567 40 41 44 2045 46 2567 40 41 44 2046 46 2567 40 41 44 2028 46 2568 40 41 41 59 2031 2569 61 2565 46 2570 59 2031 2571 61 2565 46 2572 59 2564 60 2031 44 2031 62 2573 61 2009 46 2574 40 2571 44 2569 44 2047 46 2567 40 41 44 2048 46 2567 40 41 44 2028 46 2568 40 41 41 59 2563 61 648 43 2573 46 2570 43 648 43 2573 46 2572 43 648 59 392 40 2562 41 123 2575 46 2576 2577 61 418 2575 46 2576 40 41 123 64 2083 439 492 2578 40 64 2579 2580 2581 41 123 2005 46 2582 40 648 41 59 2583 46 2584 40 40 41 45 62 123 2031 2464 61 2581 631 424 63 2581 46 2585 40 41 46 2586 40 41 58 648 59 418 2587 40 41 46 2588 40 648 43 2464 41 46 2065 40 41 59 125 41 59 125 64 2083 439 492 2589 40 2590 2591 41 123 2005 46 371 40 2591 46 2592 40 41 41 59 2593 46 2594 40 40 41 45 62 418 2595 40 41 46 494 40 2591 46 2592 40 41 41 46 2065 40 41 41 59 125 125 59 392 40 2596 46 2597 40 2011 44 2017 41 41 123 474 123 2009 46 2598 40 2573 46 2572 44 2577 41 59 125 329 40 2599 124 2600 124 2601 2602 41 123 2005 46 371 40 2602 46 2603 40 41 41 59 2602 46 2604 40 41 59 2605 46 2606 40 40 41 45 62 418 2607 40 41 46 494 40 2602 46 2603 40 41 41 46 2065 40 41 41 59 125 125 125 125 329 40 2608 124 2609 124 2610 2611 41 123 2005 46 371 40 2611 46 2612 40 41 41 59 2611 46 2613 40 41 59 2563 61 2611 46 2612 40 41 59 125 125 450 2563 59 125 125 
4411,Java,"@FxmlView
public class BsqTxView extends ActivatableView<GridPane, Void> implements BsqBalanceListener, DaoStateListener,
        BsqWalletService.WalletTransactionsChangeListener {

    private TableView<BsqTxListItem> tableView;
    private AutoTooltipButton exportButton;

    private final DaoFacade daoFacade;
    private final DaoStateService daoStateService;
    private final BsqFormatter bsqFormatter;
    private final BsqWalletService bsqWalletService;
    private final BtcWalletService btcWalletService;
    private final BsqBalanceUtil bsqBalanceUtil;
    private final Preferences preferences;
    private final TradableRepository tradableRepository;
    private final BsqTradeDetailsWindow bsqTradeDetailsWindow;

    private final ObservableList<BsqTxListItem> observableList = FXCollections.observableArrayList();
    // Need to be DoubleProperty as we pass it as reference
    private final SortedList<BsqTxListItem> sortedList = new SortedList<>(observableList);
    private int gridRow = 0;
    private Label chainHeightLabel;
    private ProgressBar chainSyncIndicator;
    private ChangeListener<Number> walletChainHeightListener;
    private Timer updateAnyChainHeightTimer;
    private int walletChainHeight;
    private int blockHeightBeforeProcessing;
    private int missingBlocks;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    private BsqTxView(DaoFacade daoFacade,
                      DaoStateService daoStateService,
                      BsqWalletService bsqWalletService,
                      Preferences preferences,
                      BtcWalletService btcWalletService,
                      BsqBalanceUtil bsqBalanceUtil,
                      BsqFormatter bsqFormatter,
                      TradableRepository tradableRepository,
                      BsqTradeDetailsWindow bsqTradeDetailsWindow) {
        this.daoFacade = daoFacade;
        this.daoStateService = daoStateService;
        this.bsqFormatter = bsqFormatter;
        this.bsqWalletService = bsqWalletService;
        this.preferences = preferences;
        this.btcWalletService = btcWalletService;
        this.bsqBalanceUtil = bsqBalanceUtil;
        this.tradableRepository = tradableRepository;
        this.bsqTradeDetailsWindow = bsqTradeDetailsWindow;
    }

    @Override
    public void initialize() {
        gridRow = bsqBalanceUtil.addGroup(root, gridRow);

        tableView = new TableView<>();
        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        addDateColumn();
        addTxIdColumn();
        addInformationColumn();
        addAmountColumn();
        addConfidenceColumn();
        addTxTypeColumn();

        chainSyncIndicator = new JFXProgressBar();
        chainSyncIndicator.setPrefWidth(120);
        if (DevEnv.isDaoActivated())
            chainSyncIndicator.setProgress(-1);
        else
            chainSyncIndicator.setProgress(0);
        chainSyncIndicator.setPadding(new Insets(-6, 0, -10, 5));

        chainHeightLabel = FormBuilder.addLabel(root, ++gridRow, """");
        chainHeightLabel.setId(""num-offers"");
        chainHeightLabel.setPadding(new Insets(-5, 0, -10, 5));
        exportButton = new AutoTooltipButton();
        exportButton.updateText(Res.get(""shared.exportCSV""));

        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.getChildren().addAll(chainHeightLabel, chainSyncIndicator, spacer, exportButton);

        VBox vBox = new VBox();
        vBox.setSpacing(10);
        GridPane.setVgrow(vBox, Priority.ALWAYS);
        GridPane.setRowIndex(vBox, ++gridRow);
        GridPane.setColumnSpan(vBox, 3);
        GridPane.setRowSpan(vBox, 2);
        GridPane.setMargin(vBox, new Insets(40, -10, 5, -10));
        vBox.getChildren().addAll(tableView, hBox);
        VBox.setVgrow(tableView, Priority.ALWAYS);
        root.getChildren().add(vBox);

        walletChainHeightListener = (observable, oldValue, newValue) -> {
            walletChainHeight = bsqWalletService.getBestChainHeight();
            onUpdateAnyChainHeight();
        };
    }

    @Override
    protected void activate() {
        bsqBalanceUtil.activate();
        bsqWalletService.addWalletTransactionsChangeListener(this);
        bsqWalletService.addBsqBalanceListener(this);
        btcWalletService.getChainHeightProperty().addListener(walletChainHeightListener);

        sortedList.comparatorProperty().bind(tableView.comparatorProperty());
        tableView.setItems(sortedList);

        daoFacade.addBsqStateListener(this);

        updateList();

        walletChainHeight = bsqWalletService.getBestChainHeight();
        blockHeightBeforeProcessing = daoFacade.getChainHeight();
        missingBlocks = walletChainHeight - blockHeightBeforeProcessing;
        if (!daoStateService.isParseBlockChainComplete()) {
            updateAnyChainHeightTimer = UserThread.runPeriodically(this::onUpdateAnyChainHeight, 100, TimeUnit.MILLISECONDS);
        }
        onUpdateAnyChainHeight();

        exportButton.setOnAction(event -> {
            CSVEntryConverter<BsqTxListItem> headerConverter = item -> {
                ObservableList<TableColumn<BsqTxListItem, ?>> tableColumns = tableView.getColumns();
                String[] columns = new String[8];
                columns[0] = ((AutoTooltipLabel) tableColumns.get(0).getGraphic()).getText();
                columns[1] = ((AutoTooltipLabel) tableColumns.get(1).getGraphic()).getText();
                // Table col 2 (information is split up into 3 different ones for cvs)
                columns[2] = Res.get(""shared.details"");
                columns[3] = Res.get(""shared.address"");
                columns[4] = Res.get(""funds.tx.receivedFunds"");
                columns[5] = ((AutoTooltipLabel) tableColumns.get(3).getGraphic()).getText();
                columns[6] = ((AutoTooltipLabel) tableColumns.get(4).getGraphic()).getText();
                columns[7] = ((AutoTooltipLabel) tableColumns.get(5).getGraphic()).getText();
                return columns;
            };
            CSVEntryConverter<BsqTxListItem> contentConverter = item -> {
                String[] columns = new String[8];
                columns[0] = item.getDateAsString();
                columns[1] = item.getTxId();
                columns[2] = item.getDirection();
                columns[3] = item.getAddress();
                columns[4] = String.valueOf(item.isReceived());
                columns[5] = item.getAmountAsString();
                columns[6] = String.valueOf(item.getConfirmations());
                columns[7] = item.getTxType().name();
                return columns;
            };

            GUIUtil.exportCSV(""BSQ_transactions.csv"", headerConverter, contentConverter,
                    new BsqTxListItem(), sortedList, (Stage) root.getScene().getWindow());
        });
    }

    @Override
    protected void deactivate() {
        bsqBalanceUtil.deactivate();
        sortedList.comparatorProperty().unbind();
        bsqWalletService.removeWalletTransactionsChangeListener(this);
        bsqWalletService.removeBsqBalanceListener(this);
        btcWalletService.getChainHeightProperty().removeListener(walletChainHeightListener);
        daoFacade.removeBsqStateListener(this);
        exportButton.setOnAction(null);

        observableList.forEach(BsqTxListItem::cleanup);

        if (updateAnyChainHeightTimer != null) {
            updateAnyChainHeightTimer.stop();
            updateAnyChainHeightTimer = null;
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // BsqBalanceListener
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onUpdateBalances(Coin availableBalance,
                                 Coin availableNonBsqBalance,
                                 Coin unverifiedBalance,
                                 Coin unconfirmedChangeBalance,
                                 Coin lockedForVotingBalance,
                                 Coin lockedInBondsBalance,
                                 Coin unlockingBondsBalance) {
        updateList();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // DaoStateListener
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onParseBlockCompleteAfterBatchProcessing(Block block) {
        onUpdateAnyChainHeight();
    }

    @Override
    public void onParseBlockChainComplete() {
        if (updateAnyChainHeightTimer != null) {
            updateAnyChainHeightTimer.stop();
            updateAnyChainHeightTimer = null;
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // BsqWalletService.WalletTransactionsChangeListener
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onWalletTransactionsChange() {
        updateList();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    // If chain height from wallet or from the BSQ blockchain parsing changed we update our state.
    private void onUpdateAnyChainHeight() {
        int currentBlockHeight = daoFacade.getChainHeight();
        if (walletChainHeight > 0) {
            int processedBlocks = currentBlockHeight - blockHeightBeforeProcessing;
            double progress = (double) processedBlocks / (double) missingBlocks;
            boolean synced = walletChainHeight == currentBlockHeight;
            chainSyncIndicator.setVisible(!synced);
            chainSyncIndicator.setManaged(!synced);
            if (synced) {
                chainHeightLabel.setText(Res.get(""dao.wallet.chainHeightSynced"", currentBlockHeight));
            } else {
                chainSyncIndicator.setProgress(progress);
                if (walletChainHeight > currentBlockHeight) {
                    // Normally we get the latest block height from BitcoinJ as the target height,
                    // and we request BSQ blocks from seed nodes up to latest block
                    chainHeightLabel.setText(Res.get(""dao.wallet.chainHeightSyncing"",
                            currentBlockHeight,
                            walletChainHeight));
                } else {
                    // Our wallet chain height is behind our BSQ chain height. That can be the case at SPV resync or if
                    // we updated manually our DaoStateStore with a newer version. We do not want to show sync state
                    // as we do not know at that moment if we are missing blocks. Once Btc wallet has synced we will
                    // trigger a check and request more blocks in case we are the lite node.
                    chainSyncIndicator.setVisible(false);
                    chainSyncIndicator.setManaged(false);
                    chainHeightLabel.setText(Res.get(""dao.wallet.chainHeightSynced"", currentBlockHeight));
                }
            }
        } else {
            chainHeightLabel.setText(Res.get(""dao.wallet.chainHeightSyncing"",
                    currentBlockHeight,
                    walletChainHeight));
        }
        updateList();
    }

    private void updateList() {
        observableList.forEach(BsqTxListItem::cleanup);

        List<Transaction> walletTransactions = bsqWalletService.getClonedWalletTransactions();
        List<BsqTxListItem> items = walletTransactions.stream()
                .map(transaction -> {
                    return new BsqTxListItem(transaction,
                            bsqWalletService,
                            btcWalletService,
                            daoFacade,
                            // Use tx.getIncludedInBestChainAt() when available, otherwise use tx.getUpdateTime()
                            transaction.getIncludedInBestChainAt() != null ? transaction.getIncludedInBestChainAt() : transaction.getUpdateTime(),
                            bsqFormatter,
                            tradableRepository);
                })
                .collect(Collectors.toList());
        observableList.setAll(items);
    }

    private boolean isValidType(TxType txType) {
        switch (txType) {
            case UNDEFINED:
            case UNDEFINED_TX_TYPE:
            case UNVERIFIED:
            case INVALID:
                return false;
            case GENESIS:
            case TRANSFER_BSQ:
            case PAY_TRADE_FEE:
            case PROPOSAL:
            case COMPENSATION_REQUEST:
            case REIMBURSEMENT_REQUEST:
            case BLIND_VOTE:
            case VOTE_REVEAL:
            case LOCKUP:
            case UNLOCK:
            case ASSET_LISTING_FEE:
            case PROOF_OF_BURN:
                return true;
            case IRREGULAR:
                return false;
            default:
                return false;
        }
    }

    private void addDateColumn() {
        TableColumn<BsqTxListItem, BsqTxListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.dateTime""));
        column.setCellValueFactory(item -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setMinWidth(180);
        column.setMaxWidth(column.getMinWidth() + 20);
        column.getStyleClass().add(""first-column"");

        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                            BsqTxListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setText(item.getDateAsString());
                                } else {
                                    setText("""");
                                }
                            }
                        };
                    }
                });
        tableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(BsqTxListItem::getDate));
        column.setSortType(TableColumn.SortType.DESCENDING);
        tableView.getSortOrder().add(column);
    }

    private void addTxIdColumn() {
        TableColumn<BsqTxListItem, BsqTxListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.txId""));

        column.setCellValueFactory(item -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setMinWidth(60);
        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                            BsqTxListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> openTxInBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });
        tableView.getColumns().add(column);
    }

    private void addInformationColumn() {
        TableColumn<BsqTxListItem, BsqTxListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.details""));
        column.setCellValueFactory(item -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setMinWidth(160);
        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                            BsqTxListItem> column) {
                        return new TableCell<>() {

                            private AddressWithIconAndDirection field;

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    TxType txType = item.getTxType();
                                    String labelString = Res.get(""dao.tx.type.enum."" + txType.name());
                                    Label label;
                                    if (item.getConfirmations() > 0 && isValidType(txType)) {
                                        if (item.getOptionalBsqTrade().isPresent()) {
                                            if (field != null)
                                                field.setOnAction(null);

                                            BsqSwapTrade bsqSwapTrade = item.getOptionalBsqTrade().get();
                                            String text = Res.get(""dao.tx.bsqSwapTrade"", bsqSwapTrade.getShortId());
                                            HyperlinkWithIcon hyperlinkWithIcon = new HyperlinkWithIcon(text, AwesomeIcon.INFO_SIGN);
                                            hyperlinkWithIcon.setOnAction(e -> bsqTradeDetailsWindow.show(bsqSwapTrade));
                                            hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                            setGraphic(hyperlinkWithIcon);
                                        } else if (txType == TxType.COMPENSATION_REQUEST &&
                                                daoFacade.isIssuanceTx(item.getTxId(), IssuanceType.COMPENSATION)) {
                                            if (field != null)
                                                field.setOnAction(null);

                                            labelString = Res.get(""dao.tx.issuanceFromCompReq"");
                                            label = new AutoTooltipLabel(labelString);
                                            setGraphic(label);
                                        } else if (txType == TxType.REIMBURSEMENT_REQUEST &&
                                                daoFacade.isIssuanceTx(item.getTxId(), IssuanceType.REIMBURSEMENT)) {
                                            if (field != null)
                                                field.setOnAction(null);

                                            labelString = Res.get(""dao.tx.issuanceFromReimbursement"");
                                            label = new AutoTooltipLabel(labelString);
                                            setGraphic(label);
                                        } else if (item.isBurnedBsqTx() || item.getAmount().isZero()) {
                                            if (field != null)
                                                field.setOnAction(null);

                                            if (txType == TxType.TRANSFER_BSQ &&
                                                    item.getAmount().isZero() &&
                                                    item.getTxType() != TxType.UNLOCK) {
                                                labelString = Res.get(""funds.tx.direction.self"");
                                            }

                                            label = new AutoTooltipLabel(labelString);
                                            setGraphic(label);
                                        } else {
                                            // Received
                                            String addressString = item.getAddress();
                                            field = new AddressWithIconAndDirection(item.getDirection(), addressString,
                                                    item.isReceived());
                                            field.setOnAction(event -> openAddressInBlockExplorer(item));
                                            field.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", addressString)));
                                            setGraphic(field);
                                        }
                                    } else {
                                        if (item.isWithdrawalToBTCWallet())
                                            labelString = Res.get(""dao.tx.withdrawnFromWallet"");

                                        label = new AutoTooltipLabel(labelString);
                                        setGraphic(label);
                                    }
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };
                    }
                });
        tableView.getColumns().add(column);
    }

    private void addAmountColumn() {
        TableColumn<BsqTxListItem, BsqTxListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.amountWithCur"", ""BSQ""));
        column.setMinWidth(120);
        column.setMaxWidth(column.getMinWidth());

        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {

            @Override
            public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                    BsqTxListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final BsqTxListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            TxType txType = item.getTxType();

                            String bsqAmount = Res.get(""shared.na"");

                            if (item.getConfirmations() > 0) {
                                if (isValidType(txType))
                                    bsqAmount = item.getAmountAsString();
                                else if (item.isWithdrawalToBTCWallet())
                                    bsqAmount = bsqFormatter.formatBSQSatoshis(0L);
                            }

                            setText(bsqAmount);
                        } else
                            setText("""");
                    }
                };
            }
        });
        tableView.getColumns().add(column);
    }

    private void addConfidenceColumn() {
        TableColumn<BsqTxListItem, BsqTxListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.confirmations""));
        column.setMinWidth(130);
        column.setMaxWidth(column.getMinWidth());

        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {

            @Override
            public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                    BsqTxListItem> column) {
                return new TableCell<>() {

                    @Override
                    public void updateItem(final BsqTxListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setGraphic(item.getTxConfidenceIndicator());
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });
        tableView.getColumns().add(column);
    }

    private void addTxTypeColumn() {
        TableColumn<BsqTxListItem, BsqTxListItem> column = new AutoTooltipTableColumn<>(Res.get(""dao.wallet.tx.type""));
        column.setCellValueFactory(item -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setMinWidth(70);
        column.setMaxWidth(column.getMinWidth());
        column.getStyleClass().add(""last-column"");
        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<BsqTxListItem, BsqTxListItem> call(TableColumn<BsqTxListItem,
                            BsqTxListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final BsqTxListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    String style;
                                    AwesomeIcon awesomeIcon;
                                    TxType txType = item.getTxType();
                                    String toolTipText = Res.get(""dao.tx.type.enum."" + txType.name());
                                    boolean doRotate = false;
                                    switch (txType) {
                                        case UNDEFINED_TX_TYPE:
                                            awesomeIcon = AwesomeIcon.REMOVE_CIRCLE;
                                            style = ""dao-tx-type-unverified-icon"";
                                            break;
                                        case UNVERIFIED:
                                            awesomeIcon = AwesomeIcon.QUESTION_SIGN;
                                            style = ""dao-tx-type-unverified-icon"";
                                            break;
                                        case INVALID:
                                            awesomeIcon = AwesomeIcon.WARNING_SIGN;
                                            style = ""dao-tx-type-invalid-icon"";
                                            break;
                                        case GENESIS:
                                            awesomeIcon = AwesomeIcon.ROCKET;
                                            style = ""dao-tx-type-genesis-icon"";
                                            break;
                                        case TRANSFER_BSQ:
                                            if (item.getAmount().isZero()) {
                                                awesomeIcon = AwesomeIcon.RETWEET;
                                                style = ""dao-tx-type-self-icon"";
                                            } else {
                                                awesomeIcon = item.isReceived() ? AwesomeIcon.SIGNIN : AwesomeIcon.SIGNOUT;
                                                doRotate = item.isReceived();
                                                style = item.isReceived() ? ""dao-tx-type-received-funds-icon"" : ""dao-tx-type-sent-funds-icon"";
                                                toolTipText = item.isReceived() ?
                                                        Res.get(""dao.tx.type.enum.received."" + txType.name()) :
                                                        Res.get(""dao.tx.type.enum.sent."" + txType.name());
                                            }
                                            break;
                                        case PAY_TRADE_FEE:
                                            // We do not detect a BSQ swap tx. It is considered a PAY_TRADE_FEE tx
                                            // which is correct as well as it pays a trade fee.
                                            // Locally we can derive the information to distinguish a BSQ swap tx
                                            // by looking up our closed trades. Globally (like on the explorer) we do
                                            // not have the data to make that distinction.
                                            if (item.isBsqSwapTx()) {
                                                awesomeIcon = AwesomeIcon.EXCHANGE;
                                                style = ""dao-tx-type-bsq-swap-icon"";
                                                toolTipText = Res.get(""dao.tx.bsqSwapTx"");
                                            } else {
                                                awesomeIcon = AwesomeIcon.LEAF;
                                                style = ""dao-tx-type-trade-fee-icon"";
                                            }
                                            break;
                                        case PROPOSAL:
                                        case COMPENSATION_REQUEST:
                                            String txId = item.getTxId();
                                            if (daoFacade.isIssuanceTx(txId, IssuanceType.COMPENSATION)) {
                                                awesomeIcon = AwesomeIcon.MONEY;
                                                style = ""dao-tx-type-issuance-icon"";
                                                int issuanceBlockHeight = daoFacade.getIssuanceBlockHeight(txId);
                                                long blockTime = daoFacade.getBlockTime(issuanceBlockHeight);
                                                String formattedDate = DisplayUtils.formatDateTime(new Date(blockTime));
                                                toolTipText = Res.get(""dao.tx.issuanceFromCompReq.tooltip"", formattedDate);
                                            } else {
                                                awesomeIcon = AwesomeIcon.FILE_TEXT;
                                                style = ""dao-tx-type-proposal-fee-icon"";
                                            }
                                            break;
                                        case REIMBURSEMENT_REQUEST:
                                            txId = item.getTxId();
                                            if (daoFacade.isIssuanceTx(txId, IssuanceType.REIMBURSEMENT)) {
                                                awesomeIcon = AwesomeIcon.MONEY;
                                                style = ""dao-tx-type-issuance-icon"";
                                                int issuanceBlockHeight = daoFacade.getIssuanceBlockHeight(txId);
                                                long blockTime = daoFacade.getBlockTime(issuanceBlockHeight);
                                                String formattedDate = DisplayUtils.formatDateTime(new Date(blockTime));
                                                toolTipText = Res.get(""dao.tx.issuanceFromReimbursement.tooltip"", formattedDate);
                                            } else {
                                                awesomeIcon = AwesomeIcon.FILE_TEXT;
                                                style = ""dao-tx-type-proposal-fee-icon"";
                                            }
                                            break;
                                        case BLIND_VOTE:
                                            awesomeIcon = AwesomeIcon.EYE_CLOSE;
                                            style = ""dao-tx-type-vote-icon"";
                                            break;
                                        case VOTE_REVEAL:
                                            awesomeIcon = AwesomeIcon.EYE_OPEN;
                                            style = ""dao-tx-type-vote-reveal-icon"";
                                            break;
                                        case LOCKUP:
                                            awesomeIcon = AwesomeIcon.LOCK;
                                            style = ""dao-tx-type-lockup-icon"";
                                            break;
                                        case UNLOCK:
                                            awesomeIcon = AwesomeIcon.UNLOCK;
                                            style = ""dao-tx-type-unlock-icon"";
                                            break;
                                        case ASSET_LISTING_FEE:
                                            awesomeIcon = AwesomeIcon.FILE_TEXT;
                                            style = ""dao-tx-type-proposal-fee-icon"";
                                            break;
                                        case PROOF_OF_BURN:
                                            awesomeIcon = AwesomeIcon.FILE_TEXT;
                                            style = ""dao-tx-type-proposal-fee-icon"";
                                            break;
                                        case IRREGULAR:
                                            awesomeIcon = AwesomeIcon.WARNING_SIGN;
                                            style = ""dao-tx-type-invalid-icon"";
                                            break;
                                        default:
                                            awesomeIcon = AwesomeIcon.QUESTION_SIGN;
                                            style = ""dao-tx-type-unverified-icon"";
                                            break;
                                    }
                                    Label label = FormBuilder.getIcon(awesomeIcon);
                                    label.getStyleClass().addAll(""icon"", style);
                                    label.setTooltip(new Tooltip(toolTipText));
                                    if (doRotate)
                                        label.setRotate(180);
                                    setGraphic(label);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });

        tableView.getColumns().add(column);
    }

    private void openTxInBlockExplorer(BsqTxListItem item) {
        if (item.getTxId() != null)
            GUIUtil.openWebPage(preferences.getBsqBlockChainExplorer().txUrl + item.getTxId(), false);
    }

    private void openAddressInBlockExplorer(BsqTxListItem item) {
        if (item.getAddress() != null) {
            GUIUtil.openWebPage(preferences.getBsqBlockChainExplorer().addressUrl + item.getAddress(), false);
        }
    }
}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 395 2005 44 2006 44 2007 46 2008 123 437 2009 60 2010 62 2011 59 437 2012 2013 59 437 381 2014 2015 59 437 381 2016 2017 59 437 381 2018 2019 59 437 381 2007 2020 59 437 381 2021 2022 59 437 381 2023 2024 59 437 381 2025 2026 59 437 381 2027 2028 59 437 381 2029 2030 59 437 381 2031 60 2010 62 2032 61 2033 46 2034 40 41 59 621 437 381 2035 60 2010 62 2036 61 418 2035 60 62 40 2032 41 59 437 404 2037 61 1500 59 437 2038 2039 59 437 2040 2041 59 437 2042 60 2043 62 2044 59 437 2045 2046 59 437 404 2047 59 437 404 2048 59 437 404 2049 59 621 621 621 64 2050 437 2001 40 2014 2015 44 2016 2017 44 2007 2020 44 2025 2026 44 2021 2022 44 2023 2024 44 2018 2019 44 2027 2028 44 2029 2030 41 123 467 46 2015 61 2015 59 467 46 2017 61 2017 59 467 46 2019 61 2019 59 467 46 2020 61 2020 59 467 46 2026 61 2026 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2028 61 2028 59 467 46 2030 61 2030 59 125 64 2051 439 492 2052 40 41 123 2037 61 2024 46 2053 40 2054 44 2037 41 59 2011 61 418 2009 60 62 40 41 59 2011 46 2055 40 2009 46 2056 41 59 2057 40 41 59 2058 40 41 59 2059 40 41 59 2060 40 41 59 2061 40 41 59 2062 40 41 59 2041 61 418 2063 40 41 59 2041 46 2064 40 1504 41 59 392 40 2065 46 2066 40 41 41 2041 46 2067 40 45 1501 41 59 360 2041 46 2067 40 1500 41 59 2041 46 2068 40 418 2069 40 45 1502 44 1500 44 45 1502 44 1502 41 41 59 2039 61 2070 46 2071 40 2054 44 637 2037 44 648 41 59 2039 46 2072 40 648 41 59 2039 46 2068 40 418 2069 40 45 1502 44 1500 44 45 1502 44 1502 41 41 59 2013 61 418 2012 40 41 59 2013 46 2073 40 2074 46 2075 40 648 41 41 59 2076 2077 61 418 2076 40 41 59 2078 46 2079 40 2077 44 2080 46 2081 41 59 2078 2082 61 418 2078 40 41 59 2082 46 2083 40 1502 41 59 2082 46 2084 40 41 46 2085 40 2039 44 2041 44 2077 44 2013 41 59 2086 2087 61 418 2086 40 41 59 2087 46 2083 40 1502 41 59 2003 46 2088 40 2087 44 2080 46 2081 41 59 2003 46 2089 40 2087 44 637 2037 41 59 2003 46 2090 40 2087 44 1502 41 59 2003 46 2091 40 2087 44 1502 41 59 2003 46 2092 40 2087 44 418 2069 40 1503 44 45 1502 44 1502 44 45 1502 41 41 59 2087 46 2084 40 41 46 2085 40 2011 44 2082 41 59 2086 46 2088 40 2011 44 2080 46 2081 41 59 2054 46 2084 40 41 46 2093 40 2087 41 59 2044 61 40 2094 44 2095 44 2096 41 45 62 123 2047 61 2020 46 2097 40 41 59 2098 40 41 59 125 59 125 64 2051 438 492 2099 40 41 123 2024 46 2099 40 41 59 2020 46 2100 40 467 41 59 2020 46 2101 40 467 41 59 2022 46 2102 40 41 46 2103 40 2044 41 59 2036 46 2104 40 41 46 2105 40 2011 46 2104 40 41 41 59 2011 46 2106 40 2036 41 59 2015 46 2107 40 467 41 59 2108 40 41 59 2047 61 2020 46 2109 40 41 59 2048 61 2015 46 2110 40 41 59 2049 61 2047 45 2048 59 392 40 33 2017 46 2111 40 41 41 123 2046 61 2112 46 2113 40 467 58 58 2114 44 1503 44 2115 46 2116 41 59 125 2117 40 41 59 2013 46 2118 40 373 45 62 123 2119 60 2010 62 2120 61 2121 45 62 123 2031 60 2122 60 2010 44 63 641 2123 61 2011 46 2124 40 41 59 2125 91 93 2126 61 418 2125 91 1502 93 59 2126 91 1500 93 61 40 40 2127 41 2123 46 2128 40 1500 41 46 2129 40 41 41 46 2130 40 41 59 2126 91 1501 93 61 40 40 2127 41 2123 46 2128 40 1501 41 46 2129 40 41 41 46 2130 40 41 59 621 2126 91 1502 93 61 2131 46 2128 40 648 41 59 2126 91 1502 93 61 2131 46 2128 40 648 41 59 2126 91 1502 93 61 2131 46 2128 40 648 41 59 2126 91 1502 93 61 40 40 2127 41 2123 46 2128 40 1502 41 46 2129 40 41 41 46 2130 40 41 59 2126 91 1502 93 61 40 40 2127 41 2123 46 2128 40 1502 41 46 2129 40 41 41 46 2130 40 41 59 2126 91 1502 93 61 40 40 2127 41 2123 46 2128 40 1502 41 46 2129 40 41 41 46 2130 40 41 59 450 2126 59 125 59 2119 60 2010 62 2132 61 2121 45 62 123 2133 91 93 2134 61 418 2133 91 1502 93 59 2134 91 1500 93 61 2121 46 2135 40 41 59 2134 91 1501 93 61 2121 46 2136 40 41 59 2134 91 1502 93 61 2121 46 2137 40 41 59 2134 91 1502 93 61 2121 46 2138 40 41 59 2134 91 1502 93 61 2133 46 2139 40 2121 46 2140 40 41 41 59 2134 91 1502 93 61 2121 46 2141 40 41 59 2134 91 1502 93 61 2133 46 2139 40 2121 46 2142 40 41 41 59 2134 91 1502 93 61 2121 46 2143 40 41 46 2144 40 41 59 450 2134 59 125 59 2145 46 2146 40 648 44 2120 44 2132 44 418 2010 40 41 44 2036 44 40 2147 41 2148 46 2149 40 41 46 2150 40 41 41 59 125 41 59 125 64 2051 438 492 2151 40 41 123 2024 46 2151 40 41 59 2036 46 2152 40 41 46 2153 40 41 59 2020 46 2154 40 467 41 59 2020 46 2155 40 467 41 59 2022 46 2156 40 41 46 2157 40 2044 41 59 2015 46 2158 40 467 41 59 2013 46 2159 40 424 41 59 2032 46 2160 40 2010 58 58 2161 41 59 392 40 2046 631 424 41 123 2046 46 2162 40 41 59 2046 61 424 59 125 125 621 621 621 64 2051 439 492 2163 40 2164 2165 44 2164 2166 44 2164 2167 44 2164 2168 44 2164 2169 44 2164 2170 44 2164 2171 41 123 2172 40 41 59 125 621 621 621 64 2051 439 492 2173 40 2174 2175 41 123 2176 40 41 59 125 64 2051 439 492 2177 40 41 123 392 40 2046 631 424 41 123 2046 46 2178 40 41 59 2046 61 424 59 125 125 621 621 621 64 2051 439 492 2179 40 41 123 2180 40 41 59 125 621 621 621 621 437 492 2181 40 41 123 404 2182 61 2015 46 2183 40 41 59 392 40 2047 62 1500 41 123 404 2184 61 2182 45 2048 59 356 2185 61 40 356 41 2184 47 40 356 41 2049 59 324 2186 61 2047 614 2182 59 2041 46 2187 40 33 2186 41 59 2041 46 2188 40 33 2186 41 59 392 40 2186 41 123 2039 46 2189 40 2190 46 2191 40 648 44 2182 41 41 59 125 360 123 2041 46 2192 40 2185 41 59 392 40 2047 62 2182 41 123 621 621 2039 46 2193 40 2194 46 2195 40 648 44 2182 44 2047 41 41 59 125 360 123 621 621 621 621 2041 46 2187 40 380 41 59 2041 46 2188 40 380 41 59 2039 46 2196 40 2197 46 2198 40 648 44 2182 41 41 59 125 125 125 360 123 2039 46 2199 40 2200 46 2201 40 648 44 2182 44 2047 41 41 59 125 2202 40 41 59 125 437 492 2203 40 41 123 2032 46 2204 40 2010 58 58 2205 41 59 2206 60 2207 62 2208 61 2020 46 2209 40 41 59 2206 60 2010 62 2210 61 2208 46 2211 40 41 46 2212 40 2213 45 62 123 450 418 2010 40 2213 44 2020 44 2022 44 2015 44 621 2213 46 2214 40 41 631 424 63 2213 46 2214 40 41 58 2213 46 2215 40 41 44 2019 44 2028 41 59 125 41 46 2216 40 2217 46 2218 40 41 41 59 2032 46 2219 40 2210 41 59 125 437 324 2220 40 2221 2222 41 123 464 40 2222 41 123 328 2223 58 328 2224 58 328 2225 58 328 2226 58 450 380 59 328 2227 58 328 2228 58 328 2229 58 328 2230 58 328 2231 58 328 2232 58 328 2233 58 328 2234 58 328 2235 58 328 2236 58 328 2237 58 328 2238 58 450 473 59 328 2239 58 450 380 59 349 58 450 380 59 125 125 437 492 2240 40 41 123 2241 60 2010 44 2010 62 2242 61 418 2243 60 62 40 2244 46 2245 40 648 41 41 59 2242 46 2246 40 2247 45 62 418 2248 60 62 40 2247 46 2249 40 41 41 41 59 2242 46 2250 40 1504 41 59 2242 46 2251 40 2242 46 2252 40 41 43 1503 41 59 2242 46 2253 40 41 46 2254 40 648 41 59 2242 46 2255 40 418 2256 60 62 40 41 123 64 2051 439 2257 60 2010 44 2010 62 2258 40 2241 60 2010 44 2010 62 2242 41 123 450 418 2257 60 62 40 41 123 64 2051 439 492 2259 40 381 2010 2247 44 324 362 41 123 463 46 2259 40 2247 44 362 41 59 392 40 2247 631 424 605 33 362 41 123 2260 40 2247 46 2261 40 41 41 59 125 360 123 2262 40 648 41 59 125 125 125 59 125 125 41 59 2011 46 2263 40 41 46 2254 40 2242 41 59 2242 46 2264 40 2265 46 2266 40 2010 58 58 2267 41 41 59 2242 46 2268 40 2241 46 2269 46 2270 41 59 2011 46 2271 40 41 46 2254 40 2242 41 59 125 437 492 2272 40 41 123 2273 60 2010 44 2010 62 2274 61 418 2275 60 62 40 2276 46 2277 40 648 41 41 59 2274 46 2278 40 2279 45 62 418 2280 60 62 40 2279 46 2281 40 41 41 41 59 2274 46 2282 40 1503 41 59 2274 46 2283 40 418 2284 60 62 40 41 123 64 2051 439 2285 60 2010 44 2010 62 2286 40 2273 60 2010 44 2010 62 2274 41 123 450 418 2285 60 62 40 41 123 437 2287 2288 59 64 2051 439 492 2289 40 381 2010 2279 44 324 362 41 123 463 46 2289 40 2279 44 362 41 59 621 392 40 2279 631 424 605 33 362 41 123 2290 2291 61 2279 46 2292 40 41 59 2288 61 418 2293 40 2291 41 59 2288 46 2294 40 373 45 62 2295 40 2279 41 41 59 2288 46 2296 40 418 2297 40 2276 46 2277 40 648 44 2291 41 41 41 59 2298 40 2288 41 59 125 360 123 2299 40 424 41 59 392 40 2288 631 424 41 2288 46 2300 40 424 41 59 125 125 125 59 125 125 41 59 2011 46 2301 40 41 46 2302 40 2274 41 59 125 437 492 2303 40 41 123 2304 60 2010 44 2010 62 2305 61 418 2306 60 62 40 2307 46 2308 40 648 41 41 59 2305 46 2309 40 2310 45 62 418 2311 60 62 40 2310 46 2312 40 41 41 41 59 2305 46 2313 40 1504 41 59 2305 46 2314 40 418 2315 60 62 40 41 123 64 2051 439 2316 60 2010 44 2010 62 2317 40 2304 60 2010 44 2010 62 2305 41 123 450 418 2316 60 62 40 41 123 437 2318 2319 59 64 2051 439 492 2320 40 381 2010 2310 44 324 362 41 123 463 46 2320 40 2310 44 362 41 59 392 40 2310 631 424 605 33 362 41 123 2221 2222 61 2310 46 2321 40 41 59 2322 2323 61 2307 46 2308 40 648 43 2222 46 2324 40 41 41 59 2038 2325 59 392 40 2310 46 2326 40 41 62 1500 605 2220 40 2222 41 41 123 392 40 2310 46 2327 40 41 46 2328 40 41 41 123 392 40 2319 631 424 41 2319 46 2329 40 424 41 59 2330 2331 61 2310 46 2327 40 41 46 2308 40 41 59 2322 2332 61 2307 46 2308 40 648 44 2331 46 2333 40 41 41 59 2334 2335 61 418 2334 40 2332 44 2336 46 2337 41 59 2335 46 2329 40 2338 45 62 2030 46 2339 40 2331 41 41 59 2335 46 2340 40 418 2341 40 2307 46 2308 40 648 41 41 41 59 2342 40 2335 41 59 125 360 392 40 2222 614 2221 46 2343 605 2015 46 2344 40 2310 46 2345 40 41 44 2346 46 2347 41 41 123 392 40 2319 631 424 41 2319 46 2348 40 424 41 59 2323 61 2307 46 2308 40 648 41 59 2325 61 418 2349 40 2323 41 59 2350 40 2325 41 59 125 360 392 40 2222 614 2221 46 2351 605 2015 46 2344 40 2310 46 2345 40 41 44 2346 46 2352 41 41 123 392 40 2319 631 424 41 2319 46 2353 40 424 41 59 2323 61 2307 46 2308 40 648 41 59 2325 61 418 2354 40 2323 41 59 2355 40 2325 41 59 125 360 392 40 2310 46 2356 40 41 606 2310 46 2357 40 41 46 2358 40 41 41 123 392 40 2319 631 424 41 2319 46 2359 40 424 41 59 392 40 2222 614 2221 46 2360 605 2310 46 2357 40 41 46 2358 40 41 605 2310 46 2321 40 41 631 2221 46 2361 41 123 2323 61 2307 46 2308 40 648 41 59 125 2325 61 418 2362 40 2323 41 59 2363 40 2325 41 59 125 360 123 621 2322 2364 61 2310 46 2365 40 41 59 2319 61 418 2318 40 2310 46 2366 40 41 44 2364 44 2310 46 2367 40 41 41 59 2319 46 2368 40 373 45 62 2369 40 2310 41 41 59 2319 46 2370 40 418 2371 40 2307 46 2308 40 648 44 2364 41 41 41 59 2372 40 2319 41 59 125 125 360 123 392 40 2310 46 2373 40 41 41 2323 61 2307 46 2308 40 648 41 59 2325 61 418 2374 40 2323 41 59 2375 40 2325 41 59 125 125 360 123 2376 40 424 41 59 392 40 2319 631 424 41 2319 46 2377 40 424 41 59 125 125 125 59 125 125 41 59 2011 46 2378 40 41 46 2379 40 2305 41 59 125 437 492 2380 40 41 123 2381 60 2010 44 2010 62 2382 61 418 2383 60 62 40 2384 46 2385 40 648 44 648 41 41 59 2382 46 2386 40 1504 41 59 2382 46 2387 40 2382 46 2388 40 41 41 59 2382 46 2389 40 40 2390 41 45 62 418 2391 60 62 40 2390 46 2392 40 41 41 41 59 2382 46 2393 40 418 2394 60 62 40 41 123 64 2051 439 2395 60 2010 44 2010 62 2396 40 2381 60 2010 44 2010 62 2382 41 123 450 418 2395 60 62 40 41 123 64 2051 439 492 2397 40 381 2010 2390 44 324 362 41 123 463 46 2397 40 2390 44 362 41 59 392 40 2390 631 424 605 33 362 41 123 2221 2222 61 2390 46 2398 40 41 59 2399 2400 61 2384 46 2385 40 648 41 59 392 40 2390 46 2401 40 41 62 1500 41 123 392 40 2220 40 2222 41 41 2400 61 2390 46 2402 40 41 59 360 392 40 2390 46 2403 40 41 41 2400 61 2019 46 2404 40 1500 41 59 125 2405 40 2400 41 59 125 360 2406 40 648 41 59 125 125 59 125 125 41 59 2011 46 2407 40 41 46 2408 40 2382 41 59 125 437 492 2409 40 41 123 2410 60 2010 44 2010 62 2411 61 418 2412 60 62 40 2413 46 2414 40 648 41 41 59 2411 46 2415 40 1504 41 59 2411 46 2416 40 2411 46 2417 40 41 41 59 2411 46 2418 40 40 2419 41 45 62 418 2420 60 62 40 2419 46 2421 40 41 41 41 59 2411 46 2422 40 418 2423 60 62 40 41 123 64 2051 439 2424 60 2010 44 2010 62 2425 40 2410 60 2010 44 2010 62 2411 41 123 450 418 2424 60 62 40 41 123 64 2051 439 492 2426 40 381 2010 2419 44 324 362 41 123 463 46 2426 40 2419 44 362 41 59 392 40 2419 631 424 605 33 362 41 123 2427 40 2419 46 2428 40 41 41 59 125 360 123 2429 40 424 41 59 125 125 125 59 125 125 41 59 2011 46 2430 40 41 46 2431 40 2411 41 59 125 437 492 2432 40 41 123 2433 60 2010 44 2010 62 2434 61 418 2435 60 62 40 2436 46 2437 40 648 41 41 59 2434 46 2438 40 2439 45 62 418 2440 60 62 40 2439 46 2441 40 41 41 41 59 2434 46 2442 40 1503 41 59 2434 46 2443 40 2434 46 2444 40 41 41 59 2434 46 2445 40 41 46 2446 40 648 41 59 2434 46 2447 40 418 2448 60 62 40 41 123 64 2051 439 2449 60 2010 44 2010 62 2450 40 2433 60 2010 44 2010 62 2434 41 123 450 418 2449 60 62 40 41 123 64 2051 439 492 2451 40 381 2010 2439 44 324 362 41 123 463 46 2451 40 2439 44 362 41 59 392 40 2439 631 424 605 33 362 41 123 2452 2453 59 2454 2455 59 2221 2222 61 2439 46 2456 40 41 59 2452 2457 61 2436 46 2437 40 648 43 2222 46 2458 40 41 41 59 324 2459 61 380 59 464 40 2222 41 123 328 2460 58 2455 61 2454 46 2461 59 2453 61 648 59 325 59 328 2462 58 2455 61 2454 46 2463 59 2453 61 648 59 325 59 328 2464 58 2455 61 2454 46 2465 59 2453 61 648 59 325 59 328 2466 58 2455 61 2454 46 2467 59 2453 61 648 59 325 59 328 2468 58 392 40 2439 46 2469 40 41 46 2470 40 41 41 123 2455 61 2454 46 2471 59 2453 61 648 59 125 360 123 2455 61 2439 46 2472 40 41 63 2454 46 2473 58 2454 46 2474 59 2459 61 2439 46 2472 40 41 59 2453 61 2439 46 2472 40 41 63 648 58 648 59 2457 61 2439 46 2472 40 41 63 2436 46 2437 40 648 43 2222 46 2458 40 41 41 58 2436 46 2437 40 648 43 2222 46 2458 40 41 41 59 125 325 59 328 2475 58 621 621 621 621 621 392 40 2439 46 2476 40 41 41 123 2455 61 2454 46 2477 59 2453 61 648 59 2457 61 2436 46 2437 40 648 41 59 125 360 123 2455 61 2454 46 2478 59 2453 61 648 59 125 325 59 328 2479 58 328 2480 58 2452 2481 61 2439 46 2482 40 41 59 392 40 2015 46 2483 40 2481 44 2484 46 2485 41 41 123 2455 61 2454 46 2486 59 2453 61 648 59 404 2487 61 2015 46 2488 40 2481 41 59 413 2489 61 2015 46 2490 40 2487 41 59 2452 2491 61 2492 46 2493 40 418 2494 40 2489 41 41 59 2457 61 2436 46 2437 40 648 44 2491 41 59 125 360 123 2455 61 2454 46 2495 59 2453 61 648 59 125 325 59 328 2496 58 2481 61 2439 46 2482 40 41 59 392 40 2015 46 2483 40 2481 44 2484 46 2497 41 41 123 2455 61 2454 46 2498 59 2453 61 648 59 404 2499 61 2015 46 2500 40 2481 41 59 413 2501 61 2015 46 2502 40 2499 41 59 2452 2503 61 2504 46 2505 40 418 2506 40 2501 41 41 59 2457 61 2436 46 2437 40 648 44 2503 41 59 125 360 123 2455 61 2454 46 2507 59 2453 61 648 59 125 325 59 328 2508 58 2455 61 2454 46 2509 59 2453 61 648 59 325 59 328 2510 58 2455 61 2454 46 2511 59 2453 61 648 59 325 59 328 2512 58 2455 61 2454 46 2513 59 2453 61 648 59 325 59 328 2514 58 2455 61 2454 46 2514 59 2453 61 648 59 325 59 328 2515 58 2455 61 2454 46 2516 59 2453 61 648 59 325 59 328 2517 58 2455 61 2454 46 2516 59 2453 61 648 59 325 59 328 2518 58 2455 61 2454 46 2465 59 2453 61 648 59 325 59 349 58 2455 61 2454 46 2463 59 2453 61 648 59 325 59 125 2038 2519 61 2520 46 2521 40 2455 41 59 2519 46 2445 40 41 46 2522 40 648 44 2453 41 59 2519 46 2523 40 418 2524 40 2457 41 41 59 392 40 2459 41 2519 46 2525 40 1504 41 59 2526 40 2519 41 59 125 360 123 2527 40 424 41 59 125 125 125 59 125 125 41 59 2011 46 2528 40 41 46 2446 40 2434 41 59 125 437 492 2529 40 2010 2530 41 123 392 40 2530 46 2531 40 41 631 424 41 2532 46 2533 40 2026 46 2534 40 41 46 2535 43 2530 46 2531 40 41 44 380 41 59 125 437 492 2536 40 2010 2530 41 123 392 40 2530 46 2537 40 41 631 424 41 123 2538 46 2539 40 2026 46 2540 40 41 46 2541 43 2530 46 2537 40 41 44 380 41 59 125 125 125 
4160,Java,"@FxmlView
public class OfferBookView extends ActivatableViewAndModel<GridPane, OfferBookViewModel> {

    private final Navigation navigation;
    private final OfferDetailsWindow offerDetailsWindow;
    private final BsqSwapOfferDetailsWindow bsqSwapOfferDetailsWindow;
    private final CoinFormatter formatter;
    private final PrivateNotificationManager privateNotificationManager;
    private final boolean useDevPrivilegeKeys;
    private final AccountAgeWitnessService accountAgeWitnessService;
    private final SignedWitnessService signedWitnessService;

    private AutocompleteComboBox<TradeCurrency> currencyComboBox;
    private AutocompleteComboBox<PaymentMethod> paymentMethodComboBox;
    private AutoTooltipButton createOfferButton;
    private AutoTooltipSlideToggleButton matchingOffersToggle;
    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> amountColumn;
    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> volumeColumn;
    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> marketColumn;
    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> priceColumn;
    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> depositColumn;
    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> signingStateColumn;
    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> avatarColumn;
    private TableView<OfferBookListItem> tableView;

    private int gridRow = 0;
    private Label nrOfOffersLabel;
    private ListChangeListener<OfferBookListItem> offerListListener;
    private ChangeListener<Number> priceFeedUpdateCounterListener;
    private Subscription currencySelectionSubscriber;
    private static final int SHOW_ALL = 0;
    private Label disabledCreateOfferButtonTooltip;

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    OfferBookView(OfferBookViewModel model,
                  Navigation navigation,
                  OfferDetailsWindow offerDetailsWindow,
                  BsqSwapOfferDetailsWindow bsqSwapOfferDetailsWindow,
                  @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter formatter,
                  PrivateNotificationManager privateNotificationManager,
                  @Named(Config.USE_DEV_PRIVILEGE_KEYS) boolean useDevPrivilegeKeys,
                  AccountAgeWitnessService accountAgeWitnessService,
                  SignedWitnessService signedWitnessService) {
        super(model);

        this.navigation = navigation;
        this.offerDetailsWindow = offerDetailsWindow;
        this.bsqSwapOfferDetailsWindow = bsqSwapOfferDetailsWindow;
        this.formatter = formatter;
        this.privateNotificationManager = privateNotificationManager;
        this.useDevPrivilegeKeys = useDevPrivilegeKeys;
        this.accountAgeWitnessService = accountAgeWitnessService;
        this.signedWitnessService = signedWitnessService;
    }

    @Override
    public void initialize() {
        root.setPadding(new Insets(15, 15, 5, 15));

        final TitledGroupBg titledGroupBg = addTitledGroupBg(root, gridRow, 2, Res.get(""offerbook.availableOffers""));
        titledGroupBg.getStyleClass().add(""last"");

        HBox offerToolsBox = new HBox();
        offerToolsBox.setAlignment(Pos.BOTTOM_LEFT);
        offerToolsBox.setSpacing(10);
        offerToolsBox.setPadding(new Insets(10, 0, 0, 0));

        Tuple3<VBox, Label, AutocompleteComboBox<TradeCurrency>> currencyBoxTuple = FormBuilder.addTopLabelAutocompleteComboBox(
                Res.get(""offerbook.filterByCurrency""));
        currencyComboBox = currencyBoxTuple.third;
        currencyComboBox.setPrefWidth(270);

        Tuple3<VBox, Label, AutocompleteComboBox<PaymentMethod>> paymentBoxTuple = FormBuilder.addTopLabelAutocompleteComboBox(
                Res.get(""offerbook.filterByPaymentMethod""));
        paymentMethodComboBox = paymentBoxTuple.third;
        paymentMethodComboBox.setCellFactory(GUIUtil.getPaymentMethodCellFactory());
        paymentMethodComboBox.setPrefWidth(270);

        matchingOffersToggle = new AutoTooltipSlideToggleButton();
        matchingOffersToggle.setText(Res.get(""offerbook.matchingOffers""));
        HBox.setMargin(matchingOffersToggle, new Insets(7, 0, -9, -15));

        createOfferButton = new AutoTooltipButton();
        createOfferButton.setMinHeight(40);
        createOfferButton.setGraphicTextGap(10);

        disabledCreateOfferButtonTooltip = new Label("""");
        disabledCreateOfferButtonTooltip.setMinSize(Region.USE_PREF_SIZE, Region.USE_PREF_SIZE);
        disabledCreateOfferButtonTooltip.setMaxSize(Region.USE_PREF_SIZE, Region.USE_PREF_SIZE);
        disabledCreateOfferButtonTooltip.prefWidthProperty().bind(createOfferButton.widthProperty());
        disabledCreateOfferButtonTooltip.prefHeightProperty().bind(createOfferButton.heightProperty());
        disabledCreateOfferButtonTooltip.setTooltip(new Tooltip(Res.get(""offerbook.createOfferDisabled.tooltip"")));
        disabledCreateOfferButtonTooltip.setManaged(false);
        disabledCreateOfferButtonTooltip.setVisible(false);

        var createOfferButtonStack = new StackPane(createOfferButton, disabledCreateOfferButtonTooltip);

        offerToolsBox.getChildren().addAll(currencyBoxTuple.first, paymentBoxTuple.first,
                matchingOffersToggle, getSpacer(), createOfferButtonStack);

        GridPane.setHgrow(offerToolsBox, Priority.ALWAYS);
        GridPane.setRowIndex(offerToolsBox, gridRow);
        GridPane.setColumnSpan(offerToolsBox, 2);
        GridPane.setMargin(offerToolsBox, new Insets(Layout.FIRST_ROW_DISTANCE, 0, 0, 0));
        root.getChildren().add(offerToolsBox);

        tableView = new TableView<>();

        GridPane.setRowIndex(tableView, ++gridRow);
        GridPane.setColumnIndex(tableView, 0);
        GridPane.setColumnSpan(tableView, 2);
        GridPane.setMargin(tableView, new Insets(10, 0, -10, 0));
        GridPane.setVgrow(tableView, Priority.ALWAYS);
        root.getChildren().add(tableView);

        marketColumn = getMarketColumn();

        priceColumn = getPriceColumn();
        tableView.getColumns().add(priceColumn);
        amountColumn = getAmountColumn();
        tableView.getColumns().add(amountColumn);
        volumeColumn = getVolumeColumn();
        tableView.getColumns().add(volumeColumn);
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> paymentMethodColumn = getPaymentMethodColumn();
        tableView.getColumns().add(paymentMethodColumn);
        depositColumn = getDepositColumn();
        tableView.getColumns().add(depositColumn);
        signingStateColumn = getSigningStateColumn();
        tableView.getColumns().add(signingStateColumn);
        avatarColumn = getAvatarColumn();
        tableView.getColumns().add(getActionColumn());
        tableView.getColumns().add(avatarColumn);

        tableView.getSortOrder().add(priceColumn);
        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        Label placeholder = new AutoTooltipLabel(Res.get(""table.placeholder.noItems"", Res.get(""shared.multipleOffers"")));
        placeholder.setWrapText(true);
        tableView.setPlaceholder(placeholder);

        marketColumn.setComparator(Comparator.comparing(
                o -> CurrencyUtil.getCurrencyPair(o.getOffer().getCurrencyCode()),
                Comparator.nullsFirst(Comparator.naturalOrder())
        ));

        // We sort by % so we can also sort if SHOW ALL is selected
        Comparator<OfferBookListItem> marketBasedPriceComparator = (o1, o2) -> {
            Optional<Double> marketBasedPrice1 = model.getMarketBasedPrice(o1.getOffer());
            Optional<Double> marketBasedPrice2 = model.getMarketBasedPrice(o2.getOffer());
            if (marketBasedPrice1.isPresent() && marketBasedPrice2.isPresent()) {
                return Double.compare(marketBasedPrice1.get(), marketBasedPrice2.get());
            } else {
                return 0;
            }
        };
        // If we do not have a % price we use only fix price and sort by that
        priceColumn.setComparator(marketBasedPriceComparator.thenComparing((o1, o2) -> {
            Price price2 = o2.getOffer().getPrice();
            Price price1 = o1.getOffer().getPrice();
            if (price2 == null || price1 == null) {
                return 0;
            }
            if (model.getDirection() == OfferDirection.SELL) {
                return price1.compareTo(price2);
            } else {
                return price2.compareTo(price1);
            }
        }));

        amountColumn.setComparator(Comparator.comparing(o -> o.getOffer().getMinAmount()));
        volumeColumn.setComparator(Comparator.comparing(o -> o.getOffer().getMinVolume(), Comparator.nullsFirst(Comparator.naturalOrder())));
        paymentMethodColumn.setComparator(Comparator.comparing(o -> Res.get(o.getOffer().getPaymentMethod().getId())));
        avatarColumn.setComparator(Comparator.comparing(o -> model.getNumTrades(o.getOffer())));
        depositColumn.setComparator(Comparator.comparing(item -> {
            boolean isSellOffer = item.getOffer().getDirection() == OfferDirection.SELL;
            Coin deposit = isSellOffer ?
                    item.getOffer().getBuyerSecurityDeposit() :
                    item.getOffer().getSellerSecurityDeposit();

            double amountValue = item.getOffer().getAmount().getValue();
            if ((deposit == null || amountValue == 0)) {
                return 0d;
            } else {
                return deposit.getValue() / amountValue;
            }

        }, Comparator.nullsFirst(Comparator.naturalOrder())));

        signingStateColumn.setComparator(Comparator.comparing(e -> e.getWitnessAgeData(accountAgeWitnessService, signedWitnessService), Comparator.nullsFirst(Comparator.naturalOrder())));

        nrOfOffersLabel = new AutoTooltipLabel("""");
        nrOfOffersLabel.setId(""num-offers"");
        GridPane.setHalignment(nrOfOffersLabel, HPos.LEFT);
        GridPane.setVgrow(nrOfOffersLabel, Priority.NEVER);
        GridPane.setValignment(nrOfOffersLabel, VPos.TOP);
        GridPane.setRowIndex(nrOfOffersLabel, ++gridRow);
        GridPane.setColumnIndex(nrOfOffersLabel, 0);
        GridPane.setMargin(nrOfOffersLabel, new Insets(10, 0, 0, 0));
        root.getChildren().add(nrOfOffersLabel);

        offerListListener = c -> nrOfOffersLabel.setText(Res.get(""offerbook.nrOffers"", model.getOfferList().size()));

        // Fixes incorrect ordering of Available offers:
        // https://github.com/bisq-network/bisq-desktop/issues/588
        priceFeedUpdateCounterListener = (observable, oldValue, newValue) -> tableView.sort();
    }

    @Override
    protected void activate() {
        currencyComboBox.setCellFactory(GUIUtil.getTradeCurrencyCellFactory(Res.get(""shared.oneOffer""),
                Res.get(""shared.multipleOffers""),
                (model.getDirection() == OfferDirection.BUY ? model.getSellOfferCounts() : model.getBuyOfferCounts())));

        currencyComboBox.setConverter(new CurrencyStringConverter(currencyComboBox));
        currencyComboBox.getEditor().getStyleClass().add(""combo-box-editor-bold"");

        currencyComboBox.setAutocompleteItems(model.getTradeCurrencies());
        currencyComboBox.setVisibleRowCount(Math.min(currencyComboBox.getItems().size(), 10));

        currencyComboBox.setOnChangeConfirmed(e -> {
            if (currencyComboBox.getEditor().getText().isEmpty())
                currencyComboBox.getSelectionModel().select(SHOW_ALL);
            model.onSetTradeCurrency(currencyComboBox.getSelectionModel().getSelectedItem());
        });
        updateCurrencyComboBoxFromModel();

        currencyComboBox.getEditor().setText(new CurrencyStringConverter(currencyComboBox).toString(currencyComboBox.getSelectionModel().getSelectedItem()));

        matchingOffersToggle.setSelected(model.useOffersMatchingMyAccountsFilter);
        matchingOffersToggle.disableProperty().bind(model.disableMatchToggle);
        matchingOffersToggle.setOnAction(e -> model.onShowOffersMatchingMyAccounts(matchingOffersToggle.isSelected()));

        volumeColumn.sortableProperty().bind(model.showAllTradeCurrenciesProperty.not());
        model.getOfferList().comparatorProperty().bind(tableView.comparatorProperty());

        amountColumn.sortTypeProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue == TableColumn.SortType.DESCENDING) {
                amountColumn.setComparator(Comparator.comparing(o -> o.getOffer().getAmount(), Comparator.nullsFirst(Comparator.naturalOrder())));
            } else {
                amountColumn.setComparator(Comparator.comparing(o -> o.getOffer().getMinAmount(), Comparator.nullsFirst(Comparator.naturalOrder())));
            }
        });
        volumeColumn.sortTypeProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue == TableColumn.SortType.DESCENDING) {
                volumeColumn.setComparator(Comparator.comparing(o -> o.getOffer().getVolume(), Comparator.nullsFirst(Comparator.naturalOrder())));
            } else {
                volumeColumn.setComparator(Comparator.comparing(o -> o.getOffer().getMinVolume(), Comparator.nullsFirst(Comparator.naturalOrder())));
            }
        });

        paymentMethodComboBox.setConverter(new PaymentMethodStringConverter(paymentMethodComboBox));
        paymentMethodComboBox.getEditor().getStyleClass().add(""combo-box-editor-bold"");

        paymentMethodComboBox.setAutocompleteItems(model.getPaymentMethods());
        paymentMethodComboBox.setVisibleRowCount(Math.min(paymentMethodComboBox.getItems().size(), 10));

        paymentMethodComboBox.setOnChangeConfirmed(e -> {
            if (paymentMethodComboBox.getEditor().getText().isEmpty())
                paymentMethodComboBox.getSelectionModel().select(SHOW_ALL);
            model.onSetPaymentMethod(paymentMethodComboBox.getSelectionModel().getSelectedItem());
            updateCurrencyComboBoxFromModel();
            updateSigningStateColumn();
        });

        if (model.showAllPaymentMethods)
            paymentMethodComboBox.getSelectionModel().select(SHOW_ALL);
        else
            paymentMethodComboBox.getSelectionModel().select(model.selectedPaymentMethod);
        paymentMethodComboBox.getEditor().setText(new PaymentMethodStringConverter(paymentMethodComboBox).toString(paymentMethodComboBox.getSelectionModel().getSelectedItem()));

        createOfferButton.setOnAction(e -> onCreateOffer());

        MonadicBinding<Void> currencySelectionBinding = EasyBind.combine(
                model.showAllTradeCurrenciesProperty, model.tradeCurrencyCode,
                (showAll, code) -> {
                    setDirectionTitles();
                    if (showAll) {
                        volumeColumn.setTitleWithHelpText(Res.get(""shared.amountMinMax""), Res.get(""shared.amountHelp""));
                        priceColumn.setTitle(Res.get(""shared.price""));
                        priceColumn.getStyleClass().remove(""first-column"");

                        if (!tableView.getColumns().contains(marketColumn))
                            tableView.getColumns().add(0, marketColumn);
                    } else {
                        volumeColumn.setTitleWithHelpText(Res.get(""offerbook.volume"", code), Res.get(""shared.amountHelp""));
                        priceColumn.setTitle(CurrencyUtil.getPriceWithCurrencyCode(code));
                        priceColumn.getStyleClass().add(""first-column"");

                        tableView.getColumns().remove(marketColumn);
                    }

                    updateSigningStateColumn();

                    return null;
                });

        currencySelectionSubscriber = currencySelectionBinding.subscribe((observable, oldValue, newValue) -> {
        });

        tableView.setItems(model.getOfferList());

        model.getOfferList().addListener(offerListListener);
        nrOfOffersLabel.setText(Res.get(""offerbook.nrOffers"", model.getOfferList().size()));

        model.priceFeedService.updateCounterProperty().addListener(priceFeedUpdateCounterListener);
    }

    private void updateCurrencyComboBoxFromModel() {
        if (model.showAllTradeCurrenciesProperty.get()) {
            currencyComboBox.getSelectionModel().select(SHOW_ALL);
        } else {
            currencyComboBox.getSelectionModel().select(model.getSelectedTradeCurrency());
        }
    }

    private void updateSigningStateColumn() {
        if (model.hasSelectionAccountSigning()) {
            if (!tableView.getColumns().contains(signingStateColumn)) {
                tableView.getColumns().add(tableView.getColumns().indexOf(depositColumn) + 1, signingStateColumn);
            }
        } else {
            tableView.getColumns().remove(signingStateColumn);
        }
    }

    @Override
    protected void deactivate() {
        createOfferButton.setOnAction(null);
        matchingOffersToggle.setOnAction(null);
        matchingOffersToggle.disableProperty().unbind();
        model.getOfferList().comparatorProperty().unbind();

        volumeColumn.sortableProperty().unbind();
        priceColumn.sortableProperty().unbind();
        amountColumn.sortableProperty().unbind();
        model.getOfferList().comparatorProperty().unbind();

        model.getOfferList().removeListener(offerListListener);
        model.priceFeedService.updateCounterProperty().removeListener(priceFeedUpdateCounterListener);

        currencySelectionSubscriber.unsubscribe();
    }

    static class CurrencyStringConverter extends StringConverter<TradeCurrency> {
        private final ComboBox<TradeCurrency> comboBox;

        CurrencyStringConverter(ComboBox<TradeCurrency> comboBox) {
            this.comboBox = comboBox;
        }

        @Override
        public String toString(TradeCurrency item) {
            return item != null ? asString(item) : """";
        }

        @Override
        public TradeCurrency fromString(String query) {
            if (comboBox.getItems().isEmpty())
                return null;
            if (query.isEmpty())
                return specialShowAllItem();
            return comboBox.getItems().stream().
                    filter(item -> asString(item).equals(query)).
                    findAny().orElse(null);
        }

        private String asString(TradeCurrency item) {
            if (isSpecialShowAllItem(item))
                return Res.get(GUIUtil.SHOW_ALL_FLAG);
            if (isSpecialEditItem(item))
                return Res.get(GUIUtil.EDIT_FLAG);
            return item.getCode() + ""  -  "" + item.getName();
        }

        private boolean isSpecialShowAllItem(TradeCurrency item) {
            return item.getCode().equals(GUIUtil.SHOW_ALL_FLAG);
        }

        private boolean isSpecialEditItem(TradeCurrency item) {
            return item.getCode().equals(GUIUtil.EDIT_FLAG);
        }

        private TradeCurrency specialShowAllItem() {
            return comboBox.getItems().get(SHOW_ALL);
        }
    }

    static class PaymentMethodStringConverter extends StringConverter<PaymentMethod> {
        private final ComboBox<PaymentMethod> comboBox;

        PaymentMethodStringConverter(ComboBox<PaymentMethod> comboBox) {
            this.comboBox = comboBox;
        }

        @Override
        public String toString(PaymentMethod item) {
            return item != null ? asString(item) : """";
        }

        @Override
        public PaymentMethod fromString(String query) {
            if (comboBox.getItems().isEmpty())
                return null;
            if (query.isEmpty())
                return specialShowAllItem();
            return comboBox.getItems().stream().
                    filter(item -> asString(item).equals(query)).
                    findAny().orElse(null);
        }

        private String asString(PaymentMethod item) {
            if (isSpecialShowAllItem(item))
                return Res.get(GUIUtil.SHOW_ALL_FLAG);
            return Res.get(item.getId());
        }

        private boolean isSpecialShowAllItem(PaymentMethod item) {
            return item.getId().equals(GUIUtil.SHOW_ALL_FLAG);
        }

        private PaymentMethod specialShowAllItem() {
            return comboBox.getItems().get(SHOW_ALL);
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void enableCreateOfferButton() {
        createOfferButton.setDisable(false);
        disabledCreateOfferButtonTooltip.setManaged(false);
        disabledCreateOfferButtonTooltip.setVisible(false);
    }

    private void disableCreateOfferButton() {
        createOfferButton.setDisable(true);
        disabledCreateOfferButtonTooltip.setManaged(true);
        disabledCreateOfferButtonTooltip.setVisible(true);

        model.onCreateOffer();
    }

    public void setDirection(OfferDirection direction) {
        model.initWithDirection(direction);
        ImageView iconView = new ImageView();

        createOfferButton.setGraphic(iconView);
        iconView.setId(direction == OfferDirection.SELL ? ""image-sell-white"" : ""image-buy-white"");
        createOfferButton.setId(direction == OfferDirection.SELL ? ""sell-button-big"" : ""buy-button-big"");
        avatarColumn.setTitle(direction == OfferDirection.SELL ? Res.get(""shared.buyerUpperCase"") : Res.get(""shared.sellerUpperCase""));
        setDirectionTitles();
    }

    private void setDirectionTitles() {
        TradeCurrency selectedTradeCurrency = model.getSelectedTradeCurrency();
        if (selectedTradeCurrency != null) {
            OfferDirection direction = model.getDirection();
            String offerButtonText;
            String code = selectedTradeCurrency.getCode();

            if (model.showAllTradeCurrenciesProperty.get()) {
                offerButtonText = direction == OfferDirection.BUY ?
                        Res.get(""offerbook.createOfferToBuy"",
                                Res.getBaseCurrencyCode()) :
                        Res.get(""offerbook.createOfferToSell"",
                                Res.getBaseCurrencyCode());
            } else if (selectedTradeCurrency instanceof FiatCurrency) {
                offerButtonText = direction == OfferDirection.BUY ?
                        Res.get(""offerbook.createOfferToBuy.withFiat"",
                                Res.getBaseCurrencyCode(), code) :
                        Res.get(""offerbook.createOfferToSell.forFiat"", Res.getBaseCurrencyCode(), code);

            } else {
                offerButtonText = direction == OfferDirection.BUY ?
                        Res.get(""offerbook.createOfferToBuy.withCrypto"",
                                code, Res.getBaseCurrencyCode()) :
                        Res.get(""offerbook.createOfferToSell.forCrypto"", code, Res.getBaseCurrencyCode());
            }
            createOfferButton.updateText(offerButtonText);
        }
    }

    public void setOfferActionHandler(OfferView.OfferActionHandler offerActionHandler) {
        model.setOfferActionHandler(offerActionHandler);
    }

    public void onTabSelected(boolean isSelected) {
        model.onTabSelected(isSelected);

        if (isSelected) {
            updateCurrencyComboBoxFromModel();
            root.requestFocus();
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // UI actions
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onCreateOffer() {
        if (model.canCreateOrTakeOffer()) {
            if (!model.hasPaymentAccountForCurrency()) {
                new Popup().headLine(Res.get(""offerbook.warning.noTradingAccountForCurrency.headline""))
                        .instruction(Res.get(""offerbook.warning.noTradingAccountForCurrency.msg""))
                        .actionButtonText(Res.get(""offerbook.yesCreateOffer""))
                        .onAction(this::disableCreateOfferButton)
                        .secondaryActionButtonText(Res.get(""offerbook.setupNewAccount""))
                        .onSecondaryAction(() -> {
                            navigation.setReturnPath(navigation.getCurrentPath());
                            navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
                        })
                        .width(725)
                        .show();
                return;
            }

            disableCreateOfferButton();
        }
    }

    private void onShowInfo(Offer offer, OfferFilterService.Result result) {
        switch (result) {
            case API_DISABLED:
                DevEnv.logErrorAndThrowIfDevMode(""We are in desktop and in the taker position "" +
                        ""viewing offers, so it cannot be that we got that result as we are not an API user."");
                break;
            case HAS_NO_PAYMENT_ACCOUNT_VALID_FOR_OFFER:
                openPopupForMissingAccountSetup(offer);
                break;
            case HAS_NOT_SAME_PROTOCOL_VERSION:
                new Popup().warning(Res.get(""offerbook.warning.wrongTradeProtocol"")).show();
                break;
            case IS_IGNORED:
                new Popup().warning(Res.get(""offerbook.warning.userIgnored"")).show();
                break;
            case IS_OFFER_BANNED:
                new Popup().warning(Res.get(""offerbook.warning.offerBlocked"")).show();
                break;
            case IS_CURRENCY_BANNED:
                new Popup().warning(Res.get(""offerbook.warning.currencyBanned"")).show();
                break;
            case IS_PAYMENT_METHOD_BANNED:
                new Popup().warning(Res.get(""offerbook.warning.paymentMethodBanned"")).show();
                break;
            case IS_NODE_ADDRESS_BANNED:
                new Popup().warning(Res.get(""offerbook.warning.nodeBlocked"")).show();
                break;
            case REQUIRE_UPDATE_TO_NEW_VERSION:
                new Popup().warning(Res.get(""offerbook.warning.requireUpdateToNewVersion"")).show();
                break;
            case IS_INSUFFICIENT_COUNTERPARTY_TRADE_LIMIT:
                new Popup().warning(Res.get(""offerbook.warning.counterpartyTradeRestrictions"")).show();
                break;
            case IS_MY_INSUFFICIENT_TRADE_LIMIT:
                Optional<PaymentAccount> account = model.getMostMaturePaymentAccountForOffer(offer);
                if (account.isPresent()) {
                    long tradeLimit = model.accountAgeWitnessService.getMyTradeLimit(account.get(),
                            offer.getCurrencyCode(), offer.getMirroredDirection());
                    new Popup()
                            .warning(Res.get(""popup.warning.tradeLimitDueAccountAgeRestriction.buyer"",
                                    formatter.formatCoinWithCode(Coin.valueOf(tradeLimit)),
                                    Res.get(""offerbook.warning.newVersionAnnouncement"")))
                            .show();
                } else {
                    DevEnv.logErrorAndThrowIfDevMode(""We don't found a payment account but got called the "" +
                            ""isInsufficientTradeLimit case."");
                }
                break;
            case HIDE_BSQ_SWAPS_DUE_DAO_DEACTIVATED:
                new Popup().warning(Res.get(""offerbook.warning.hideBsqSwapsDueDaoDeactivated"")).show();
                break;
            case VALID:
            default:
                break;
        }
    }

    private void onTakeOffer(Offer offer) {
        if (model.canCreateOrTakeOffer()) {
            if (offer.getDirection() == OfferDirection.SELL &&
                    offer.getPaymentMethod().getId().equals(PaymentMethod.CASH_DEPOSIT.getId())) {
                new Popup().confirmation(Res.get(""popup.info.cashDepositInfo"", offer.getBankId()))
                        .actionButtonText(Res.get(""popup.info.cashDepositInfo.confirm""))
                        .onAction(() -> model.onTakeOffer(offer))
                        .show();
            } else {
                model.onTakeOffer(offer);
            }
        }
    }

    private void onRemoveOpenOffer(Offer offer) {
        if (model.isBootstrappedOrShowPopup()) {
            String key = ""RemoveOfferWarning"";
            if (DontShowAgainLookup.showAgain(key)) {
                new Popup().warning(Res.get(""popup.warning.removeOffer"", model.getMakerFeeAsString(offer)))
                        .actionButtonText(Res.get(""shared.removeOffer""))
                        .onAction(() -> doRemoveOffer(offer))
                        .closeButtonText(Res.get(""shared.dontRemoveOffer""))
                        .dontShowAgainId(key)
                        .show();
            } else {
                doRemoveOffer(offer);
            }
        }
    }

    private void doRemoveOffer(Offer offer) {
        String key = ""WithdrawFundsAfterRemoveOfferInfo"";
        model.onRemoveOpenOffer(offer,
                () -> {
                    log.debug(Res.get(""offerbook.removeOffer.success""));
                    if (DontShowAgainLookup.showAgain(key))
                        new Popup().instruction(Res.get(""offerbook.withdrawFundsHint"", Res.get(""navigation.funds.availableForWithdrawal"")))
                                .actionButtonTextWithGoTo(""navigation.funds.availableForWithdrawal"")
                                .onAction(() -> navigation.navigateTo(MainView.class, FundsView.class, WithdrawalView.class))
                                .dontShowAgainId(key)
                                .show();
                },
                (message) -> {
                    log.error(message);
                    new Popup().warning(Res.get(""offerbook.removeOffer.failed"", message)).show();
                });
    }

    private void openPopupForMissingAccountSetup(Offer offer) {
        String headline = Res.get(""offerbook.warning.noMatchingAccount.headline"");

        if (offer.getCurrencyCode().equals(""BSQ"")) {
            new Popup().headLine(headline)
                    .instruction(Res.get(""offerbook.warning.noMatchingBsqAccount.msg""))
                    .actionButtonText(Res.get(""offerbook.takeOffer.createAccount""))
                    .onAction(() -> {
                        var bsqAccount = model.createBsqAccount(offer);
                        var message = Res.get(""offerbook.info.accountCreated.message"", bsqAccount.getAccountName());
                        if (model.isInstantPaymentMethod(offer)) {
                            message += Res.get(""offerbook.info.accountCreated.tradeInstant"");
                        }
                        message += Res.get(""offerbook.info.accountCreated.takeOffer"");
                        new Popup().headLine(Res.get(""offerbook.info.accountCreated.headline""))
                                .information(message)
                                .onClose(() -> model.onTakeOffer(offer))
                                .show();
                    }).show();
        } else {

            var accountViewClass = CurrencyUtil.isFiatCurrency(offer.getCurrencyCode()) ? FiatAccountsView.class : AltCoinAccountsView.class;

            new Popup().headLine(headline)
                    .instruction(Res.get(""offerbook.warning.noMatchingAccount.msg""))
                    .actionButtonTextWithGoTo(""navigation.account"")
                    .onAction(() -> {
                        navigation.setReturnPath(navigation.getCurrentPath());
                        navigation.navigateTo(MainView.class, AccountView.class, accountViewClass);
                    }).show();
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Table
    ///////////////////////////////////////////////////////////////////////////////////////////

    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> getAmountColumn() {
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.BTCMinMax""), Res.get(""shared.amountHelp""));
        column.setMinWidth(100);
        column.getStyleClass().add(""number-column"");
        column.setCellValueFactory((offer) -> new ReadOnlyObjectWrapper<>(offer.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(
                            TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new ColoredDecimalPlacesWithZerosText(model.getAmount(item), GUIUtil.AMOUNT_DECIMALS_WITH_ZEROS));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
        return column;
    }

    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> getMarketColumn() {
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.market"")) {
            {
                setMinWidth(40);
            }
        };
        column.getStyleClass().addAll(""number-column"", ""first-column"");
        column.setCellValueFactory((offer) -> new ReadOnlyObjectWrapper<>(offer.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(
                            TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty)
                                    setText(CurrencyUtil.getCurrencyPair(item.getOffer().getCurrencyCode()));
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        return column;
    }

    private ObservableValue<OfferBookListItem> asPriceDependentObservable(OfferBookListItem item) {
        return item.getOffer().isUseMarketBasedPrice()
                ? EasyBind.map(model.priceFeedService.updateCounterProperty(), n -> item)
                : new ReadOnlyObjectWrapper<>(item);
    }

    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> getPriceColumn() {
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>("""") {
            {
                setMinWidth(130);
            }
        };
        column.getStyleClass().add(""number-column"");
        column.setCellValueFactory(offer -> asPriceDependentObservable(offer.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(
                            TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    setGraphic(getPriceAndPercentage(item));
                                } else {
                                    setGraphic(null);
                                }
                            }

                            private HBox getPriceAndPercentage(OfferBookListItem item) {
                                Offer offer = item.getOffer();
                                boolean useMarketBasedPrice = offer.isUseMarketBasedPrice();
                                MaterialDesignIcon icon = useMarketBasedPrice ? MaterialDesignIcon.CHART_LINE : MaterialDesignIcon.LOCK;
                                String info;

                                if (useMarketBasedPrice) {
                                    double marketPriceMargin = offer.getMarketPriceMargin();
                                    if (marketPriceMargin == 0) {
                                        if (offer.isBuyOffer()) {
                                            info = Res.get(""offerbook.info.sellAtMarketPrice"");
                                        } else {
                                            info = Res.get(""offerbook.info.buyAtMarketPrice"");
                                        }
                                    } else {
                                        String absolutePriceMargin = model.getAbsolutePriceMargin(offer);
                                        if (marketPriceMargin > 0) {
                                            if (offer.isBuyOffer()) {
                                                info = Res.get(""offerbook.info.sellBelowMarketPrice"", absolutePriceMargin);
                                            } else {
                                                info = Res.get(""offerbook.info.buyAboveMarketPrice"", absolutePriceMargin);
                                            }
                                        } else {
                                            if (offer.isBuyOffer()) {
                                                info = Res.get(""offerbook.info.sellAboveMarketPrice"", absolutePriceMargin);
                                            } else {
                                                info = Res.get(""offerbook.info.buyBelowMarketPrice"", absolutePriceMargin);
                                            }
                                        }
                                    }
                                } else {
                                    if (offer.isBuyOffer()) {
                                        info = Res.get(""offerbook.info.sellAtFixedPrice"");
                                    } else {
                                        info = Res.get(""offerbook.info.buyAtFixedPrice"");
                                    }
                                }
                                InfoAutoTooltipLabel priceLabel = new InfoAutoTooltipLabel(model.getPrice(item),
                                        icon, ContentDisplay.RIGHT, info);
                                priceLabel.setTextAlignment(TextAlignment.RIGHT);
                                AutoTooltipLabel percentageLabel = new AutoTooltipLabel(model.getPriceAsPercentage(item));
                                percentageLabel.setOpacity(useMarketBasedPrice ? 1 : 0.4);

                                HBox hBox = new HBox();
                                hBox.setSpacing(5);
                                hBox.getChildren().addAll(priceLabel, percentageLabel);
                                hBox.setPadding(new Insets(7, 0, 0, 0));
                                return hBox;
                            }
                        };
                    }
                });
        return column;
    }

    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> getVolumeColumn() {
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>("""") {
            {
                setMinWidth(125);
            }
        };
        column.getStyleClass().add(""number-column"");
        column.setCellValueFactory(offer -> asPriceDependentObservable(offer.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(
                            TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    if (item.getOffer().getPrice() == null) {
                                        setText(Res.get(""shared.na""));
                                        setGraphic(null);
                                    } else {
                                        setText("""");
                                        setGraphic(new ColoredDecimalPlacesWithZerosText(model.getVolume(item),
                                                model.getNumberOfDecimalsForVolume(item)));
                                    }
                                } else {
                                    setText("""");
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
        return column;
    }

    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> getPaymentMethodColumn() {
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.paymentMethod"")) {
            {
                setMinWidth(80);
            }
        };

        column.getStyleClass().add(""number-column"");
        column.setCellValueFactory((offer) -> new ReadOnlyObjectWrapper<>(offer.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon field;

                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {

                                    Offer offer = item.getOffer();
                                    if (model.isOfferBanned(offer)) {
                                        setGraphic(new AutoTooltipLabel(model.getPaymentMethod(item)));
                                    } else {
                                        if (offer.isXmrAutoConf()) {
                                            field = new HyperlinkWithIcon(model.getPaymentMethod(item), AwesomeIcon.ROCKET);
                                        } else {
                                            field = new HyperlinkWithIcon(model.getPaymentMethod(item));
                                        }
                                        field.setOnAction(event -> {
                                            if (offer.isBsqSwapOffer()) {
                                                bsqSwapOfferDetailsWindow.show(offer);
                                            } else {
                                                offerDetailsWindow.show(offer);
                                            }
                                        });
                                        field.setTooltip(new Tooltip(model.getPaymentMethodToolTip(item)));
                                        setGraphic(field);
                                    }
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };
                    }
                });
        return column;
    }


    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> getDepositColumn() {
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>(
                Res.get(""offerbook.deposit""),
                Res.get(""offerbook.deposit.help"")) {
            {
                setMinWidth(70);
                setSortable(true);
            }
        };

        column.getStyleClass().add(""number-column"");
        column.setCellValueFactory((offer) -> new ReadOnlyObjectWrapper<>(offer.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(
                            TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    var isSellOffer = item.getOffer().getDirection() == OfferDirection.SELL;
                                    var deposit = isSellOffer ? item.getOffer().getBuyerSecurityDeposit() :
                                            item.getOffer().getSellerSecurityDeposit();
                                    if (deposit == null) {
                                        setText(Res.get(""shared.na""));
                                        setGraphic(null);
                                    } else {
                                        setText("""");
                                        setGraphic(new ColoredDecimalPlacesWithZerosText(model.formatDepositString(
                                                deposit, item.getOffer().getAmount().getValue()),
                                                GUIUtil.AMOUNT_DECIMALS_WITH_ZEROS));
                                    }
                                } else {
                                    setText("""");
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
        return column;
    }

    private TableColumn<OfferBookListItem, OfferBookListItem> getActionColumn() {
        TableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>(Res.get(""shared.actions"")) {
            {
                setMinWidth(180);
                setSortable(false);
            }
        };
        column.getStyleClass().addAll(""last-column"", ""avatar-column"");
        column.setCellValueFactory((offer) -> new ReadOnlyObjectWrapper<>(offer.getValue()));
        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            final ImageView iconView = new ImageView();
                            final AutoTooltipButton button = new AutoTooltipButton();
                            OfferFilterService.Result canTakeOfferResult = null;

                            {
                                button.setGraphic(iconView);
                                button.setMinWidth(200);
                                button.setMaxWidth(Double.MAX_VALUE);
                                button.setGraphicTextGap(10);
                            }

                            @Override
                            public void updateItem(final OfferBookListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                TableRow<OfferBookListItem> tableRow = getTableRow();
                                if (item != null && !empty) {
                                    Offer offer = item.getOffer();
                                    boolean myOffer = model.isMyOffer(offer);

                                    if (tableRow != null) {
                                        canTakeOfferResult = model.offerFilterService.canTakeOffer(offer, false);
                                        tableRow.setOpacity(canTakeOfferResult.isValid() || myOffer ? 1 : 0.4);

                                        if (myOffer) {
                                            button.setDefaultButton(false);
                                            tableRow.setOnMousePressed(null);
                                        } else if (canTakeOfferResult.isValid()) {
                                            // set first row button as default
                                            button.setDefaultButton(getIndex() == 0);
                                            tableRow.setOnMousePressed(null);
                                        } else {
                                            button.setDefaultButton(false);
                                            tableRow.setOnMousePressed(e -> {
                                                // ugly hack to get the icon clickable when deactivated
                                                if (!(e.getTarget() instanceof ImageView || e.getTarget() instanceof Canvas))
                                                    onShowInfo(offer, canTakeOfferResult);
                                            });
                                        }
                                    }

                                    String title;
                                    if (myOffer) {
                                        iconView.setId(""image-remove"");
                                        title = Res.get(""shared.remove"");
                                        button.setId(null);
                                        button.setStyle(CssTheme.isDarkTheme() ? ""-fx-text-fill: white"" : ""-fx-text-fill: #444444"");
                                        button.setOnAction(e -> onRemoveOpenOffer(offer));
                                    } else {
                                        boolean isSellOffer = offer.getDirection() == OfferDirection.SELL;
                                        iconView.setId(isSellOffer ? ""image-buy-white"" : ""image-sell-white"");
                                        button.setId(isSellOffer ? ""buy-button"" : ""sell-button"");
                                        button.setStyle(""-fx-text-fill: white"");
                                        if (isSellOffer) {
                                            title = CurrencyUtil.isFiatCurrency(offer.getCurrencyCode()) ?
                                                    Res.get(""offerbook.takeOfferToBuy"", offer.getBaseCurrencyCode()) :
                                                    Res.get(""offerbook.takeOfferToSell"", offer.getCurrencyCode());
                                        } else {
                                            title = CurrencyUtil.isFiatCurrency(offer.getCurrencyCode()) ?
                                                    Res.get(""offerbook.takeOfferToSell"", offer.getBaseCurrencyCode()) :
                                                    Res.get(""offerbook.takeOfferToBuy"", offer.getCurrencyCode());
                                        }
                                        button.setTooltip(new Tooltip(Res.get(""offerbook.takeOfferButton.tooltip"", model.getDirectionLabelTooltip(offer))));
                                        button.setOnAction(e -> onTakeOffer(offer));
                                    }

                                    if (!myOffer) {
                                        if (canTakeOfferResult == null) {
                                            canTakeOfferResult = model.offerFilterService.canTakeOffer(offer, false);
                                        }

                                        if (!canTakeOfferResult.isValid()) {
                                            button.setOnAction(e -> onShowInfo(offer, canTakeOfferResult));
                                        }
                                    }

                                    button.updateText(title);
                                    setPadding(new Insets(0, 15, 0, 0));
                                    setGraphic(button);
                                } else {
                                    setGraphic(null);
                                    button.setOnAction(null);
                                    if (tableRow != null) {
                                        tableRow.setOpacity(1);
                                        tableRow.setOnMousePressed(null);
                                    }
                                }
                            }
                        };
                    }
                });
        return column;
    }

    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> getSigningStateColumn() {
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>(
                Res.get(""offerbook.timeSinceSigning""),
                Res.get(""offerbook.timeSinceSigning.help"",
                        SignedWitnessService.SIGNER_AGE_DAYS,
                        formatter.formatCoinWithCode(OfferRestrictions.TOLERATED_SMALL_TRADE_AMOUNT))) {
            {
                setMinWidth(60);
                setSortable(true);
            }
        };

        column.getStyleClass().add(""number-column"");
        column.setCellValueFactory((offer) -> new ReadOnlyObjectWrapper<>(offer.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<OfferBookListItem, OfferBookListItem> call(TableColumn<OfferBookListItem, OfferBookListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final OfferBookListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            var witnessAgeData = item.getWitnessAgeData(accountAgeWitnessService, signedWitnessService);
                            var label = witnessAgeData.isSigningRequired()
                                    ? new AccountStatusTooltipLabel(witnessAgeData, formatter)
                                    : new InfoAutoTooltipLabel(witnessAgeData.getDisplayString(), witnessAgeData.getIcon(), ContentDisplay.RIGHT, witnessAgeData.getInfo());
                            setGraphic(label);
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });
        return column;
    }

    private AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> getAvatarColumn() {
        AutoTooltipTableColumn<OfferBookListItem, OfferBookListItem> column = new AutoTooltipTableColumn<>(Res.get(""offerbook.trader"")) {
            {
                setMinWidth(60);
                setMaxWidth(60);
                setSortable(true);
            }
        };
        column.getStyleClass().addAll(""last-column"", ""avatar-column"");
        column.setCellValueFactory((offer) -> new ReadOnlyObjectWrapper<>(offer.getValue()));
        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<OfferBookListItem, OfferBookListItem> call(TableColumn<OfferBookListItem, OfferBookListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final OfferBookListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (newItem != null && !empty) {
                                    final Offer offer = newItem.getOffer();
                                    final NodeAddress makersNodeAddress = offer.getOwnerNodeAddress();
                                    String role = Res.get(""peerInfoIcon.tooltip.maker"");
                                    int numTrades = model.getNumTrades(offer);
                                    PeerInfoIconTrading peerInfoIcon = new PeerInfoIconTrading(makersNodeAddress,
                                            role,
                                            numTrades,
                                            privateNotificationManager,
                                            offer,
                                            model.preferences,
                                            model.accountAgeWitnessService,
                                            useDevPrivilegeKeys);
                                    setGraphic(peerInfoIcon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
        return column;
    }

    @NotNull
    private Region getSpacer() {
        final Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        return spacer;
    }
}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 123 437 381 2005 2006 59 437 381 2007 2008 59 437 381 2009 2010 59 437 381 2011 2012 59 437 381 2013 2014 59 437 381 324 2015 59 437 381 2016 2017 59 437 381 2018 2019 59 437 2020 60 2021 62 2022 59 437 2020 60 2023 62 2024 59 437 2025 2026 59 437 2027 2028 59 437 2029 60 2030 44 2030 62 2031 59 437 2029 60 2030 44 2030 62 2032 59 437 2029 60 2030 44 2030 62 2033 59 437 2029 60 2030 44 2030 62 2034 59 437 2029 60 2030 44 2030 62 2035 59 437 2029 60 2030 44 2030 62 2036 59 437 2029 60 2030 44 2030 62 2037 59 437 2038 60 2030 62 2039 59 437 404 2040 61 1500 59 437 2041 2042 59 437 2043 60 2030 62 2044 59 437 2045 60 2046 62 2047 59 437 2048 2049 59 437 457 381 404 2050 61 1500 59 437 2041 2051 59 621 621 621 64 2052 2001 40 2004 2053 44 2005 2006 44 2007 2008 44 2009 2010 44 64 2054 40 2055 46 2056 41 2011 2012 44 2013 2014 44 64 2054 40 2057 46 2058 41 324 2015 44 2016 2017 44 2018 2019 41 123 463 40 2053 41 59 467 46 2006 61 2006 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 467 46 2012 61 2012 59 467 46 2014 61 2014 59 467 46 2015 61 2015 59 467 46 2017 61 2017 59 467 46 2019 61 2019 59 125 64 2059 439 492 2060 40 41 123 2061 46 2062 40 418 2063 40 1503 44 1503 44 1502 44 1503 41 41 59 381 2064 2065 61 2066 40 2061 44 2040 44 1502 44 2067 46 2068 40 648 41 41 59 2065 46 2069 40 41 46 2070 40 648 41 59 2071 2072 61 418 2071 40 41 59 2072 46 2073 40 2074 46 2075 41 59 2072 46 2076 40 1502 41 59 2072 46 2062 40 418 2063 40 1502 44 1500 44 1500 44 1500 41 41 59 2077 60 2078 44 2041 44 2020 60 2021 641 2079 61 2080 46 2081 40 2067 46 2068 40 648 41 41 59 2022 61 2079 46 2082 59 2022 46 2083 40 1504 41 59 2077 60 2078 44 2041 44 2020 60 2023 641 2084 61 2080 46 2081 40 2067 46 2068 40 648 41 41 59 2024 61 2084 46 2082 59 2024 46 2085 40 2086 46 2087 40 41 41 59 2024 46 2083 40 1504 41 59 2028 61 418 2027 40 41 59 2028 46 2088 40 2067 46 2068 40 648 41 41 59 2071 46 2089 40 2028 44 418 2063 40 1502 44 1500 44 45 1502 44 45 1503 41 41 59 2026 61 418 2025 40 41 59 2026 46 2090 40 1503 41 59 2026 46 2091 40 1502 41 59 2051 61 418 2041 40 648 41 59 2051 46 2092 40 2093 46 2094 44 2093 46 2094 41 59 2051 46 2095 40 2093 46 2094 44 2093 46 2094 41 59 2051 46 2096 40 41 46 2097 40 2026 46 2098 40 41 41 59 2051 46 2099 40 41 46 2097 40 2026 46 2100 40 41 41 59 2051 46 2101 40 418 2102 40 2067 46 2068 40 648 41 41 41 59 2051 46 2103 40 380 41 59 2051 46 2104 40 380 41 59 490 2105 61 418 2106 40 2026 44 2051 41 59 2072 46 2107 40 41 46 2108 40 2079 46 2109 44 2084 46 2109 44 2028 44 2110 40 41 44 2105 41 59 2003 46 2111 40 2072 44 2112 46 2113 41 59 2003 46 2114 40 2072 44 2040 41 59 2003 46 2115 40 2072 44 1502 41 59 2003 46 2089 40 2072 44 418 2063 40 2116 46 2117 44 1500 44 1500 44 1500 41 41 59 2061 46 2107 40 41 46 2070 40 2072 41 59 2039 61 418 2038 60 62 40 41 59 2003 46 2114 40 2039 44 637 2040 41 59 2003 46 2118 40 2039 44 1500 41 59 2003 46 2115 40 2039 44 1502 41 59 2003 46 2089 40 2039 44 418 2063 40 1502 44 1500 44 45 1502 44 1500 41 41 59 2003 46 2119 40 2039 44 2112 46 2113 41 59 2061 46 2107 40 41 46 2070 40 2039 41 59 2033 61 2120 40 41 59 2034 61 2121 40 41 59 2039 46 2122 40 41 46 2070 40 2034 41 59 2031 61 2123 40 41 59 2039 46 2122 40 41 46 2070 40 2031 41 59 2032 61 2124 40 41 59 2039 46 2122 40 41 46 2070 40 2032 41 59 2029 60 2030 44 2030 62 2125 61 2126 40 41 59 2039 46 2122 40 41 46 2070 40 2125 41 59 2035 61 2127 40 41 59 2039 46 2122 40 41 46 2070 40 2035 41 59 2036 61 2128 40 41 59 2039 46 2122 40 41 46 2070 40 2036 41 59 2037 61 2129 40 41 59 2039 46 2122 40 41 46 2070 40 2130 40 41 41 59 2039 46 2122 40 41 46 2070 40 2037 41 59 2039 46 2131 40 41 46 2070 40 2034 41 59 2039 46 2132 40 2038 46 2133 41 59 2041 2134 61 418 2135 40 2067 46 2068 40 648 44 2067 46 2068 40 648 41 41 41 59 2134 46 2136 40 473 41 59 2039 46 2137 40 2134 41 59 2033 46 2138 40 2139 46 2140 40 2141 45 62 2142 46 2143 40 2141 46 2144 40 41 46 2145 40 41 41 44 2139 46 2146 40 2139 46 2147 40 41 41 41 41 59 621 2139 60 2030 62 2148 61 40 2149 44 2150 41 45 62 123 2151 60 2152 62 2153 61 2053 46 2154 40 2149 46 2144 40 41 41 59 2151 60 2152 62 2155 61 2053 46 2154 40 2150 46 2144 40 41 41 59 392 40 2153 46 2156 40 41 605 2155 46 2156 40 41 41 123 450 2152 46 2157 40 2153 46 2068 40 41 44 2155 46 2068 40 41 41 59 125 360 123 450 1500 59 125 125 59 621 2034 46 2138 40 2148 46 2158 40 40 2149 44 2150 41 45 62 123 2159 2160 61 2150 46 2144 40 41 46 2161 40 41 59 2159 2162 61 2149 46 2144 40 41 46 2161 40 41 59 392 40 2160 614 424 606 2162 614 424 41 123 450 1500 59 125 392 40 2053 46 2163 40 41 614 2164 46 2165 41 123 450 2162 46 2166 40 2160 41 59 125 360 123 450 2160 46 2167 40 2162 41 59 125 125 41 41 59 2031 46 2138 40 2139 46 2140 40 2141 45 62 2141 46 2144 40 41 46 2168 40 41 41 41 59 2032 46 2138 40 2139 46 2140 40 2141 45 62 2141 46 2144 40 41 46 2169 40 41 44 2139 46 2146 40 2139 46 2147 40 41 41 41 41 59 2125 46 2138 40 2139 46 2140 40 2141 45 62 2067 46 2068 40 2141 46 2144 40 41 46 2170 40 41 46 2171 40 41 41 41 41 59 2037 46 2138 40 2139 46 2140 40 2141 45 62 2053 46 2172 40 2141 46 2144 40 41 41 41 41 59 2035 46 2138 40 2139 46 2140 40 2173 45 62 123 324 2174 61 2173 46 2144 40 41 46 2175 40 41 614 2176 46 2177 59 2178 2179 61 2174 63 2173 46 2144 40 41 46 2180 40 41 58 2173 46 2144 40 41 46 2181 40 41 59 356 2182 61 2173 46 2144 40 41 46 2183 40 41 46 2184 40 41 59 392 40 40 2179 614 424 606 2182 614 1500 41 41 123 450 1500 59 125 360 123 450 2179 46 2184 40 41 47 2182 59 125 125 44 2139 46 2146 40 2139 46 2147 40 41 41 41 41 59 2036 46 2138 40 2139 46 2140 40 2185 45 62 2185 46 2186 40 2017 44 2019 41 44 2139 46 2146 40 2139 46 2147 40 41 41 41 41 59 2042 61 418 2135 40 648 41 59 2042 46 2187 40 648 41 59 2003 46 2188 40 2042 44 2189 46 2190 41 59 2003 46 2119 40 2042 44 2112 46 2191 41 59 2003 46 2192 40 2042 44 2193 46 2194 41 59 2003 46 2114 40 2042 44 637 2040 41 59 2003 46 2118 40 2042 44 1500 41 59 2003 46 2089 40 2042 44 418 2063 40 1502 44 1500 44 1500 44 1500 41 41 59 2061 46 2107 40 41 46 2070 40 2042 41 59 2044 61 2195 45 62 2042 46 2088 40 2067 46 2068 40 648 44 2053 46 2196 40 41 46 2197 40 41 41 41 59 621 621 2047 61 40 2198 44 2199 44 2200 41 45 62 2039 46 2201 40 41 59 125 64 2059 438 492 2202 40 41 123 2022 46 2203 40 2204 46 2205 40 2206 46 2207 40 648 41 44 2206 46 2207 40 648 41 44 40 2053 46 2208 40 41 614 2209 46 2210 63 2053 46 2211 40 41 58 2053 46 2212 40 41 41 41 41 59 2022 46 2213 40 418 2214 40 2022 41 41 59 2022 46 2215 40 41 46 2216 40 41 46 2217 40 648 41 59 2022 46 2218 40 2053 46 2219 40 41 41 59 2022 46 2220 40 2221 46 2222 40 2022 46 2223 40 41 46 2224 40 41 44 1502 41 41 59 2022 46 2225 40 2226 45 62 123 392 40 2022 46 2215 40 41 46 2227 40 41 46 2228 40 41 41 2022 46 2229 40 41 46 2230 40 2050 41 59 2053 46 2231 40 2022 46 2229 40 41 46 2232 40 41 41 59 125 41 59 2233 40 41 59 2022 46 2215 40 41 46 2234 40 418 2214 40 2022 41 46 2235 40 2022 46 2236 40 41 46 2237 40 41 41 41 59 2028 46 2238 40 2053 46 2239 41 59 2028 46 2240 40 41 46 2241 40 2053 46 2242 41 59 2028 46 2243 40 2226 45 62 2053 46 2244 40 2028 46 2245 40 41 41 41 59 2032 46 2246 40 41 46 2241 40 2053 46 2247 46 422 40 41 41 59 2053 46 2248 40 41 46 2249 40 41 46 2241 40 2039 46 2249 40 41 41 59 2031 46 2250 40 41 46 2251 40 40 2252 44 2253 44 2254 41 45 62 123 392 40 2254 614 2255 46 2256 46 2257 41 123 2031 46 2258 40 2259 46 2260 40 2261 45 62 2261 46 2262 40 41 46 2263 40 41 44 2259 46 2264 40 2259 46 2265 40 41 41 41 41 59 125 360 123 2031 46 2266 40 2267 46 2268 40 2269 45 62 2269 46 2270 40 41 46 2271 40 41 44 2267 46 2272 40 2267 46 2273 40 41 41 41 41 59 125 125 41 59 2032 46 2250 40 41 46 2251 40 40 2252 44 2253 44 2254 41 45 62 123 392 40 2254 614 2274 46 2275 46 2276 41 123 2032 46 2277 40 2278 46 2279 40 2280 45 62 2280 46 2281 40 41 46 2282 40 41 44 2278 46 2283 40 2278 46 2284 40 41 41 41 41 59 125 360 123 2032 46 2285 40 2286 46 2287 40 2288 45 62 2288 46 2289 40 41 46 2290 40 41 44 2286 46 2291 40 2286 46 2292 40 41 41 41 41 59 125 125 41 59 2024 46 2213 40 418 2293 40 2024 41 41 59 2024 46 2215 40 41 46 2216 40 41 46 2217 40 648 41 59 2024 46 2218 40 2053 46 2294 40 41 41 59 2024 46 2220 40 2221 46 2222 40 2024 46 2223 40 41 46 2224 40 41 44 1502 41 41 59 2024 46 2225 40 2226 45 62 123 392 40 2024 46 2215 40 41 46 2295 40 41 46 2296 40 41 41 2024 46 2236 40 41 46 2297 40 2050 41 59 2053 46 2298 40 2024 46 2236 40 41 46 2237 40 41 41 59 2233 40 41 59 2299 40 41 59 125 41 59 392 40 2053 46 2300 41 2024 46 2236 40 41 46 2301 40 2050 41 59 360 2024 46 2236 40 41 46 2301 40 2053 46 2302 41 59 2024 46 2215 40 41 46 2234 40 418 2293 40 2024 41 46 2235 40 2024 46 2236 40 41 46 2237 40 41 41 41 59 2026 46 2243 40 2226 45 62 2303 40 41 41 59 2304 60 2305 62 2306 61 2307 46 2308 40 2053 46 2247 44 2053 46 2309 44 40 2310 44 2311 41 45 62 123 2312 40 41 59 392 40 2310 41 123 2032 46 2313 40 2206 46 2207 40 648 41 44 2206 46 2207 40 648 41 41 59 2034 46 2314 40 2206 46 2207 40 648 41 41 59 2034 46 2216 40 41 46 2315 40 648 41 59 392 40 33 2039 46 2316 40 41 46 2317 40 2033 41 41 2039 46 2316 40 41 46 2217 40 1500 44 2033 41 59 125 360 123 2032 46 2318 40 2206 46 2207 40 648 44 2311 41 44 2206 46 2207 40 648 41 41 59 2034 46 2319 40 2320 46 2321 40 2311 41 41 59 2034 46 2216 40 41 46 2217 40 648 41 59 2039 46 2322 40 41 46 2323 40 2033 41 59 125 2324 40 41 59 450 424 59 125 41 59 2049 61 2306 46 2325 40 40 2252 44 2253 44 2254 41 45 62 123 125 41 59 2039 46 2326 40 2053 46 2248 40 41 41 59 2053 46 2248 40 41 46 2251 40 2044 41 59 2042 46 2234 40 2206 46 2207 40 648 44 2053 46 2248 40 41 46 2224 40 41 41 41 59 2053 46 2327 46 2328 40 41 46 2251 40 2047 41 59 125 437 492 2329 40 41 123 392 40 2053 46 2330 46 2331 40 41 41 123 2022 46 2332 40 41 46 2333 40 2050 41 59 125 360 123 2022 46 2334 40 41 46 2335 40 2053 46 2336 40 41 41 59 125 125 437 492 2337 40 41 123 392 40 2053 46 2338 40 41 41 123 392 40 33 2039 46 2339 40 41 46 2340 40 2036 41 41 123 2039 46 2339 40 41 46 2341 40 2039 46 2339 40 41 46 2342 40 2035 41 43 1501 44 2036 41 59 125 125 360 123 2039 46 2343 40 41 46 2344 40 2036 41 59 125 125 64 2059 438 492 2345 40 41 123 2026 46 2346 40 424 41 59 2028 46 2346 40 424 41 59 2028 46 2347 40 41 46 2348 40 41 59 2053 46 2349 40 41 46 2350 40 41 46 2348 40 41 59 2032 46 2351 40 41 46 2348 40 41 59 2034 46 2351 40 41 46 2348 40 41 59 2031 46 2351 40 41 46 2348 40 41 59 2053 46 2349 40 41 46 2350 40 41 46 2348 40 41 59 2053 46 2349 40 41 46 2352 40 2044 41 59 2053 46 2353 46 2354 40 41 46 2352 40 2047 41 59 2049 46 2355 40 41 59 125 457 334 2356 378 2357 60 2021 62 123 437 381 2358 60 2021 62 2359 59 2356 40 2358 60 2021 62 2359 41 123 467 46 2359 61 2359 59 125 64 2059 439 2360 2361 40 2021 2362 41 123 450 2362 631 424 63 2363 40 2362 41 58 648 59 125 64 2059 439 2021 2364 40 2360 2365 41 123 392 40 2359 46 2366 40 41 46 2367 40 41 41 450 424 59 392 40 2365 46 2367 40 41 41 450 2368 40 41 59 450 2359 46 2366 40 41 46 2369 40 41 46 2370 40 2362 45 62 2371 40 2362 41 46 2372 40 2365 41 41 46 2373 40 41 46 2374 40 424 41 59 125 437 2360 2375 40 2021 2362 41 123 392 40 2376 40 2362 41 41 450 2377 46 2378 40 2379 46 2380 41 59 392 40 2381 40 2362 41 41 450 2377 46 2378 40 2379 46 2382 41 59 450 2362 46 2383 40 41 43 648 43 2362 46 2384 40 41 59 125 437 324 2385 40 2021 2362 41 123 450 2362 46 2386 40 41 46 2387 40 2388 46 2389 41 59 125 437 324 2390 40 2021 2362 41 123 450 2362 46 2391 40 41 46 2392 40 2393 46 2394 41 59 125 437 2021 2395 40 41 123 450 2359 46 2396 40 41 46 2397 40 2050 41 59 125 125 457 334 2398 378 2357 60 2023 62 123 437 381 2399 60 2023 62 2400 59 2398 40 2399 60 2023 62 2400 41 123 467 46 2400 61 2400 59 125 64 2059 439 2401 2402 40 2023 2403 41 123 450 2403 631 424 63 2404 40 2403 41 58 648 59 125 64 2059 439 2023 2405 40 2401 2406 41 123 392 40 2400 46 2407 40 41 46 2408 40 41 41 450 424 59 392 40 2406 46 2408 40 41 41 450 2409 40 41 59 450 2400 46 2407 40 41 46 2410 40 41 46 2411 40 2403 45 62 2412 40 2403 41 46 2413 40 2406 41 41 46 2414 40 41 46 2415 40 424 41 59 125 437 2401 2416 40 2023 2403 41 123 392 40 2417 40 2403 41 41 450 2418 46 2419 40 2420 46 2421 41 59 450 2418 46 2419 40 2403 46 2422 40 41 41 59 125 437 324 2423 40 2023 2403 41 123 450 2403 46 2424 40 41 46 2425 40 2426 46 2427 41 59 125 437 2023 2428 40 41 123 450 2400 46 2429 40 41 46 2430 40 2050 41 59 125 125 621 621 621 439 492 2431 40 41 123 2026 46 2432 40 380 41 59 2051 46 2433 40 380 41 59 2051 46 2434 40 380 41 59 125 437 492 2435 40 41 123 2026 46 2436 40 473 41 59 2051 46 2437 40 473 41 59 2051 46 2438 40 473 41 59 2053 46 2439 40 41 59 125 439 492 2440 40 2441 2442 41 123 2053 46 2443 40 2442 41 59 2444 2445 61 418 2444 40 41 59 2026 46 2446 40 2445 41 59 2445 46 2447 40 2442 614 2441 46 2448 63 648 58 648 41 59 2026 46 2447 40 2442 614 2441 46 2448 63 648 58 648 41 59 2037 46 2449 40 2442 614 2441 46 2448 63 2450 46 2451 40 648 41 58 2450 46 2451 40 648 41 41 59 2452 40 41 59 125 437 492 2453 40 41 123 2021 2454 61 2053 46 2455 40 41 59 392 40 2454 631 424 41 123 2441 2442 61 2053 46 2456 40 41 59 2457 2458 59 2457 2459 61 2454 46 2460 40 41 59 392 40 2053 46 2461 46 2462 40 41 41 123 2458 61 2442 614 2441 46 2463 63 2464 46 2462 40 648 44 2464 46 2465 40 41 41 58 2464 46 2462 40 648 44 2464 46 2465 40 41 41 59 125 360 392 40 2454 402 2466 41 123 2458 61 2442 614 2441 46 2467 63 2468 46 2462 40 648 44 2468 46 2469 40 41 44 2459 41 58 2468 46 2462 40 648 44 2468 46 2469 40 41 44 2459 41 59 125 360 123 2458 61 2442 614 2441 46 2470 63 2471 46 2462 40 648 44 2459 44 2471 46 2472 40 41 41 58 2471 46 2462 40 648 44 2459 44 2471 46 2472 40 41 41 59 125 2026 46 2473 40 2458 41 59 125 125 439 492 2474 40 2475 46 2476 2477 41 123 2053 46 2474 40 2477 41 59 125 439 492 2478 40 324 2479 41 123 2053 46 2478 40 2479 41 59 392 40 2479 41 123 2329 40 41 59 2480 46 2481 40 41 59 125 125 621 621 621 437 492 2482 40 41 123 392 40 2053 46 2483 40 41 41 123 392 40 33 2053 46 2484 40 41 41 123 418 2485 40 41 46 2486 40 2487 46 2488 40 648 41 41 46 2489 40 2487 46 2488 40 648 41 41 46 2490 40 2487 46 2488 40 648 41 41 46 2491 40 467 58 58 2435 41 46 2492 40 2487 46 2488 40 648 41 41 46 2493 40 40 41 45 62 123 2006 46 2494 40 2006 46 2495 40 41 41 59 2006 46 2496 40 2497 46 334 44 2498 46 334 44 2499 46 334 41 59 125 41 46 2500 40 1504 41 46 2501 40 41 59 450 59 125 2435 40 41 59 125 125 437 492 2502 40 2503 2504 44 2505 46 2506 2507 41 123 464 40 2507 41 123 328 2508 58 2509 46 2510 40 648 43 648 41 59 325 59 328 2511 58 2512 40 2504 41 59 325 59 328 2513 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2518 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2519 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2520 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2521 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2522 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2523 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2524 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2525 58 2526 60 2527 62 2528 61 2053 46 2529 40 2504 41 59 392 40 2528 46 2530 40 41 41 123 413 2531 61 2053 46 2017 46 2532 40 2528 46 2516 40 41 44 2504 46 2533 40 41 44 2504 46 2534 40 41 41 59 418 2514 40 41 46 494 40 2515 46 2516 40 648 44 2012 46 2535 40 2536 46 2537 40 2531 41 41 44 2515 46 2516 40 648 41 41 41 46 2517 40 41 59 125 360 123 2509 46 2510 40 648 43 648 41 59 125 325 59 328 2538 58 418 2514 40 41 46 494 40 2515 46 2516 40 648 41 41 46 2517 40 41 59 325 59 328 2539 58 349 58 325 59 125 125 437 492 2540 40 2503 2504 41 123 392 40 2053 46 2541 40 41 41 123 392 40 2504 46 2542 40 41 614 2441 46 2543 605 2504 46 2544 40 41 46 2545 40 41 46 2546 40 2023 46 2547 46 2545 40 41 41 41 123 418 2548 40 41 46 2549 40 2550 46 2551 40 648 44 2504 46 2552 40 41 41 41 46 2553 40 2550 46 2551 40 648 41 41 46 2554 40 40 41 45 62 2053 46 2540 40 2504 41 41 46 2555 40 41 59 125 360 123 2053 46 2540 40 2504 41 59 125 125 125 437 492 2556 40 2503 2504 41 123 392 40 2053 46 2557 40 41 41 123 2558 2559 61 648 59 392 40 2560 46 2561 40 2559 41 41 123 418 2562 40 41 46 494 40 2563 46 2564 40 648 44 2053 46 2565 40 2504 41 41 41 46 2566 40 2563 46 2564 40 648 41 41 46 2567 40 40 41 45 62 2568 40 2504 41 41 46 2569 40 2563 46 2564 40 648 41 41 46 2570 40 2559 41 46 2571 40 41 59 125 360 123 2572 40 2504 41 59 125 125 125 437 492 2573 40 2503 2504 41 123 2574 2575 61 648 59 2053 46 2556 40 2504 44 40 41 45 62 123 2576 46 2577 40 2578 46 2579 40 648 41 41 59 392 40 2580 46 2581 40 2575 41 41 418 2582 40 41 46 2583 40 2578 46 2579 40 648 44 2578 46 2579 40 648 41 41 41 46 2584 40 648 41 46 2585 40 40 41 45 62 2006 46 2586 40 2587 46 334 44 2588 46 334 44 2589 46 334 41 41 46 2590 40 2575 41 46 2591 40 41 59 125 44 40 2592 41 45 62 123 2593 46 371 40 2592 41 59 418 2594 40 41 46 494 40 2595 46 2596 40 648 44 2592 41 41 46 2597 40 41 59 125 41 59 125 437 492 2598 40 2503 2504 41 123 2599 2600 61 2601 46 2602 40 648 41 59 392 40 2504 46 2603 40 41 46 2604 40 648 41 41 123 418 2605 40 41 46 2606 40 2600 41 46 2607 40 2601 46 2602 40 648 41 41 46 2608 40 2601 46 2602 40 648 41 41 46 2609 40 40 41 45 62 123 490 2610 61 2053 46 2611 40 2504 41 59 490 2612 61 2601 46 2602 40 648 44 2610 46 2613 40 41 41 59 392 40 2053 46 2614 40 2504 41 41 123 2612 636 2601 46 2602 40 648 41 59 125 2612 636 2601 46 2602 40 648 41 59 418 2605 40 41 46 2606 40 2601 46 2602 40 648 41 41 46 2615 40 2612 41 46 2616 40 40 41 45 62 2053 46 2540 40 2504 41 41 46 2617 40 41 59 125 41 46 2618 40 41 59 125 360 123 490 2619 61 2620 46 2621 40 2504 46 2603 40 41 41 63 2622 46 334 58 2623 46 334 59 418 2624 40 41 46 2625 40 2600 41 46 2626 40 2601 46 2602 40 648 41 41 46 2627 40 648 41 46 2628 40 40 41 45 62 123 2006 46 2629 40 2006 46 2630 40 41 41 59 2006 46 2631 40 2632 46 334 44 2633 46 334 44 2619 41 59 125 41 46 2634 40 41 59 125 125 621 621 621 437 2029 60 2030 44 2030 62 2635 40 41 123 2029 60 2030 44 2030 62 2636 61 418 2029 60 62 40 2637 46 2638 40 648 41 44 2637 46 2638 40 648 41 41 59 2636 46 2639 40 1503 41 59 2636 46 2640 40 41 46 2641 40 648 41 59 2636 46 2642 40 40 2504 41 45 62 418 2643 60 62 40 2504 46 2644 40 41 41 41 59 2636 46 2645 40 418 2646 60 62 40 41 123 64 2059 439 2647 60 2030 44 2030 62 2648 40 2649 60 2030 44 2030 62 2636 41 123 450 418 2647 60 62 40 41 123 64 2059 439 492 2650 40 381 2030 2651 44 324 362 41 123 463 46 2650 40 2651 44 362 41 59 392 40 2651 631 424 605 33 362 41 2652 40 418 2653 40 2053 46 2654 40 2651 41 44 2655 46 2656 41 41 59 360 2652 40 424 41 59 125 125 59 125 125 41 59 450 2636 59 125 437 2029 60 2030 44 2030 62 2657 40 41 123 2029 60 2030 44 2030 62 2658 61 418 2029 60 62 40 2659 46 2660 40 648 41 41 123 123 2661 40 1503 41 59 125 125 59 2658 46 2662 40 41 46 2663 40 648 44 648 41 59 2658 46 2664 40 40 2504 41 45 62 418 2665 60 62 40 2504 46 2666 40 41 41 41 59 2658 46 2667 40 418 2668 60 62 40 41 123 64 2059 439 2669 60 2030 44 2030 62 2670 40 2671 60 2030 44 2030 62 2658 41 123 450 418 2669 60 62 40 41 123 64 2059 439 492 2672 40 381 2030 2673 44 324 362 41 123 463 46 2672 40 2673 44 362 41 59 392 40 2673 631 424 605 33 362 41 2674 40 2675 46 2676 40 2673 46 2677 40 41 46 2678 40 41 41 41 59 360 2674 40 648 41 59 125 125 59 125 125 41 59 450 2658 59 125 437 2679 60 2030 62 2680 40 2030 2681 41 123 450 2681 46 2682 40 41 46 2683 40 41 63 2684 46 2685 40 2053 46 2686 46 2687 40 41 44 2688 45 62 2681 41 58 418 2689 60 62 40 2681 41 59 125 437 2029 60 2030 44 2030 62 2690 40 41 123 2029 60 2030 44 2030 62 2691 61 418 2029 60 62 40 648 41 123 123 2692 40 1504 41 59 125 125 59 2691 46 2693 40 41 46 2694 40 648 41 59 2691 46 2695 40 2504 45 62 2680 40 2504 46 2696 40 41 41 41 59 2691 46 2697 40 418 2698 60 62 40 41 123 64 2059 439 2699 60 2030 44 2030 62 2700 40 2701 60 2030 44 2030 62 2691 41 123 450 418 2699 60 62 40 41 123 64 2059 439 492 2702 40 381 2030 2681 44 324 362 41 123 463 46 2702 40 2681 44 362 41 59 392 40 2681 631 424 605 33 362 41 123 2703 40 2704 40 2681 41 41 59 125 360 123 2705 40 424 41 59 125 125 437 2706 2707 40 2030 2681 41 123 2503 2504 61 2681 46 2708 40 41 59 324 2709 61 2504 46 2710 40 41 59 2711 2712 61 2709 63 2711 46 2713 58 2711 46 2714 59 2715 2716 59 392 40 2709 41 123 356 2717 61 2504 46 2718 40 41 59 392 40 2717 614 1500 41 123 392 40 2504 46 2719 40 41 41 123 2716 61 2720 46 2721 40 648 41 59 125 360 123 2716 61 2722 46 2723 40 648 41 59 125 125 360 123 2715 2724 61 2053 46 2725 40 2504 41 59 392 40 2717 62 1500 41 123 392 40 2504 46 2726 40 41 41 123 2716 61 2727 46 2728 40 648 44 2724 41 59 125 360 123 2716 61 2729 46 2730 40 648 44 2724 41 59 125 125 360 123 392 40 2504 46 2731 40 41 41 123 2716 61 2732 46 2733 40 648 44 2724 41 59 125 360 123 2716 61 2734 46 2735 40 648 44 2724 41 59 125 125 125 125 360 123 392 40 2504 46 2736 40 41 41 123 2716 61 2737 46 2738 40 648 41 59 125 360 123 2716 61 2739 46 2740 40 648 41 59 125 125 2741 2742 61 418 2741 40 2053 46 2743 40 2681 41 44 2712 44 2744 46 2745 44 2716 41 59 2742 46 2746 40 2747 46 2745 41 59 2748 2749 61 418 2748 40 2053 46 2750 40 2681 41 41 59 2749 46 2751 40 2709 63 1501 58 1499 41 59 2706 2752 61 418 2706 40 41 59 2752 46 2753 40 1502 41 59 2752 46 2754 40 41 46 2755 40 2742 44 2749 41 59 2752 46 2756 40 418 2757 40 1502 44 1500 44 1500 44 1500 41 41 59 450 2752 59 125 125 59 125 125 41 59 450 2691 59 125 437 2029 60 2030 44 2030 62 2758 40 41 123 2029 60 2030 44 2030 62 2759 61 418 2029 60 62 40 648 41 123 123 2760 40 1504 41 59 125 125 59 2759 46 2761 40 41 46 2762 40 648 41 59 2759 46 2763 40 2504 45 62 2680 40 2504 46 2764 40 41 41 41 59 2759 46 2765 40 418 2766 60 62 40 41 123 64 2059 439 2767 60 2030 44 2030 62 2768 40 2769 60 2030 44 2030 62 2759 41 123 450 418 2767 60 62 40 41 123 64 2059 439 492 2770 40 381 2030 2681 44 324 362 41 123 463 46 2770 40 2681 44 362 41 59 392 40 2681 631 424 605 33 362 41 123 392 40 2681 46 2771 40 41 46 2772 40 41 614 424 41 123 2773 40 2774 46 2775 40 648 41 41 59 2776 40 424 41 59 125 360 123 2777 40 648 41 59 2778 40 418 2779 40 2053 46 2780 40 2681 41 44 2053 46 2781 40 2681 41 41 41 59 125 125 360 123 2782 40 648 41 59 2783 40 424 41 59 125 125 125 59 125 125 41 59 450 2759 59 125 437 2029 60 2030 44 2030 62 2784 40 41 123 2029 60 2030 44 2030 62 2785 61 418 2029 60 62 40 2786 46 2787 40 648 41 41 123 123 2788 40 1503 41 59 125 125 59 2785 46 2789 40 41 46 2790 40 648 41 59 2785 46 2791 40 40 2504 41 45 62 418 2792 60 62 40 2504 46 2793 40 41 41 41 59 2785 46 2794 40 418 2795 60 62 40 41 123 64 2059 439 2796 60 2030 44 2030 62 2797 40 2798 60 2030 44 2030 62 2785 41 123 450 418 2796 60 62 40 41 123 437 2799 2800 59 64 2059 439 492 2801 40 381 2030 2681 44 324 362 41 123 463 46 2801 40 2681 44 362 41 59 392 40 2681 631 424 605 33 362 41 123 2503 2504 61 2681 46 2802 40 41 59 392 40 2053 46 2803 40 2504 41 41 123 2804 40 418 2805 40 2053 46 2806 40 2681 41 41 41 59 125 360 123 392 40 2504 46 2807 40 41 41 123 2800 61 418 2799 40 2053 46 2808 40 2681 41 44 2809 46 2810 41 59 125 360 123 2800 61 418 2799 40 2053 46 2811 40 2681 41 41 59 125 2800 46 2812 40 373 45 62 123 392 40 2504 46 2813 40 41 41 123 2010 46 2814 40 2504 41 59 125 360 123 2008 46 2815 40 2504 41 59 125 125 41 59 2800 46 2816 40 418 2817 40 2053 46 2818 40 2681 41 41 41 59 2819 40 2800 41 59 125 125 360 123 2820 40 424 41 59 392 40 2800 631 424 41 2800 46 2821 40 424 41 59 125 125 125 59 125 125 41 59 450 2785 59 125 437 2029 60 2030 44 2030 62 2822 40 41 123 2029 60 2030 44 2030 62 2823 61 418 2029 60 62 40 2824 46 2825 40 648 41 44 2824 46 2825 40 648 41 41 123 123 2826 40 1503 41 59 2827 40 473 41 59 125 125 59 2823 46 2828 40 41 46 2829 40 648 41 59 2823 46 2830 40 40 2504 41 45 62 418 2831 60 62 40 2504 46 2832 40 41 41 41 59 2823 46 2833 40 418 2834 60 62 40 41 123 64 2059 439 2835 60 2030 44 2030 62 2836 40 2837 60 2030 44 2030 62 2823 41 123 450 418 2835 60 62 40 41 123 64 2059 439 492 2838 40 381 2030 2681 44 324 362 41 123 463 46 2838 40 2681 44 362 41 59 392 40 2681 631 424 605 33 362 41 123 490 2839 61 2681 46 2840 40 41 46 2841 40 41 614 2441 46 2842 59 490 2843 61 2839 63 2681 46 2840 40 41 46 2844 40 41 58 2681 46 2840 40 41 46 2845 40 41 59 392 40 2843 614 424 41 123 2846 40 2824 46 2825 40 648 41 41 59 2847 40 424 41 59 125 360 123 2848 40 648 41 59 2849 40 418 2850 40 2053 46 2851 40 2843 44 2681 46 2840 40 41 46 2852 40 41 46 2832 40 41 41 44 2853 46 2854 41 41 59 125 125 360 123 2855 40 648 41 59 2856 40 424 41 59 125 125 125 59 125 125 41 59 450 2823 59 125 437 2857 60 2030 44 2030 62 2858 40 41 123 2857 60 2030 44 2030 62 2859 61 418 2029 60 62 40 2860 46 2861 40 648 41 41 123 123 2862 40 1504 41 59 2863 40 380 41 59 125 125 59 2859 46 2864 40 41 46 2865 40 648 44 648 41 59 2859 46 2866 40 40 2504 41 45 62 418 2867 60 62 40 2504 46 2868 40 41 41 41 59 2859 46 2869 40 418 2870 60 62 40 41 123 64 2059 439 2871 60 2030 44 2030 62 2872 40 2857 60 2030 44 2030 62 2859 41 123 450 418 2871 60 62 40 41 123 381 2873 2874 61 418 2873 40 41 59 381 2025 2875 61 418 2025 40 41 59 2505 46 2506 2876 61 424 59 123 2875 46 2877 40 2874 41 59 2875 46 2878 40 1504 41 59 2875 46 2879 40 2880 46 2881 41 59 2875 46 2882 40 1502 41 59 125 64 2059 439 492 2883 40 381 2030 2681 44 324 362 41 123 463 46 2883 40 2681 44 362 41 59 2884 60 2030 62 2885 61 2886 40 41 59 392 40 2681 631 424 605 33 362 41 123 2503 2504 61 2681 46 2887 40 41 59 324 2888 61 2053 46 2889 40 2504 41 59 392 40 2885 631 424 41 123 2876 61 2053 46 2890 46 2891 40 2504 44 380 41 59 2885 46 2892 40 2876 46 2893 40 41 606 2888 63 1501 58 1499 41 59 392 40 2888 41 123 2875 46 2894 40 380 41 59 2885 46 2895 40 424 41 59 125 360 392 40 2876 46 2893 40 41 41 123 621 2875 46 2896 40 2897 40 41 614 1500 41 59 2885 46 2898 40 424 41 59 125 360 123 2875 46 2899 40 380 41 59 2885 46 2900 40 2901 45 62 123 621 392 40 33 40 2901 46 2902 40 41 402 2873 606 2901 46 2902 40 41 402 2903 41 41 2502 40 2504 44 2876 41 59 125 41 59 125 125 2904 2905 59 392 40 2888 41 123 2874 46 2906 40 648 41 59 2905 61 2860 46 2861 40 648 41 59 2875 46 2906 40 424 41 59 2875 46 2907 40 2908 46 2909 40 41 63 648 58 648 41 59 2875 46 2910 40 2911 45 62 2556 40 2504 41 41 59 125 360 123 324 2912 61 2504 46 2913 40 41 614 2441 46 2914 59 2874 46 2915 40 2912 63 648 58 648 41 59 2875 46 2915 40 2912 63 648 58 648 41 59 2875 46 2916 40 648 41 59 392 40 2912 41 123 2905 61 2917 46 2918 40 2504 46 2919 40 41 41 63 2860 46 2861 40 648 44 2504 46 2920 40 41 41 58 2860 46 2861 40 648 44 2504 46 2919 40 41 41 59 125 360 123 2905 61 2921 46 2922 40 2504 46 2923 40 41 41 63 2860 46 2861 40 648 44 2504 46 2924 40 41 41 58 2860 46 2861 40 648 44 2504 46 2923 40 41 41 59 125 2875 46 2925 40 418 2926 40 2860 46 2861 40 648 44 2053 46 2927 40 2504 41 41 41 41 59 2875 46 2928 40 2929 45 62 2540 40 2504 41 41 59 125 392 40 33 2888 41 123 392 40 2876 614 424 41 123 2876 61 2053 46 2930 46 2931 40 2504 44 380 41 59 125 392 40 33 2876 46 2932 40 41 41 123 2875 46 2933 40 2934 45 62 2502 40 2504 44 2876 41 41 59 125 125 2875 46 2935 40 2905 41 59 2936 40 418 2937 40 1500 44 1503 44 1500 44 1500 41 41 59 2938 40 2875 41 59 125 360 123 2939 40 424 41 59 2875 46 2940 40 424 41 59 392 40 2885 631 424 41 123 2885 46 2941 40 1501 41 59 2885 46 2942 40 424 41 59 125 125 125 125 59 125 125 41 59 450 2859 59 125 437 2029 60 2030 44 2030 62 2943 40 41 123 2029 60 2030 44 2030 62 2944 61 418 2029 60 62 40 2945 46 2946 40 648 41 44 2945 46 2946 40 648 44 2018 46 2947 44 2012 46 2948 40 2949 46 2950 41 41 41 123 123 2951 40 1503 41 59 2952 40 473 41 59 125 125 59 2944 46 2953 40 41 46 2954 40 648 41 59 2944 46 2955 40 40 2504 41 45 62 418 2956 60 62 40 2504 46 2957 40 41 41 41 59 2944 46 2958 40 418 2959 60 62 40 41 123 64 2059 439 2960 60 2030 44 2030 62 2961 40 2857 60 2030 44 2030 62 2944 41 123 450 418 2960 60 62 40 41 123 64 2059 439 492 2962 40 381 2030 2681 44 324 362 41 123 463 46 2962 40 2681 44 362 41 59 392 40 2681 631 424 605 33 362 41 123 490 2963 61 2681 46 2964 40 2017 44 2019 41 59 490 2965 61 2963 46 2966 40 41 63 418 2967 40 2963 44 2012 41 58 418 2968 40 2963 46 2969 40 41 44 2963 46 2970 40 41 44 2971 46 2972 44 2963 46 2973 40 41 41 59 2974 40 2965 41 59 125 360 123 2975 40 424 41 59 125 125 125 59 125 125 41 59 450 2944 59 125 437 2029 60 2030 44 2030 62 2976 40 41 123 2029 60 2030 44 2030 62 2977 61 418 2029 60 62 40 2978 46 2979 40 648 41 41 123 123 2980 40 1503 41 59 2981 40 1503 41 59 2982 40 473 41 59 125 125 59 2977 46 2983 40 41 46 2984 40 648 44 648 41 59 2977 46 2985 40 40 2504 41 45 62 418 2986 60 62 40 2504 46 2987 40 41 41 41 59 2977 46 2988 40 418 2989 60 62 40 41 123 64 2059 439 2990 60 2030 44 2030 62 2991 40 2857 60 2030 44 2030 62 2977 41 123 450 418 2990 60 62 40 41 123 64 2059 439 492 2992 40 381 2030 2993 44 324 362 41 123 463 46 2992 40 2993 44 362 41 59 392 40 2993 631 424 605 33 362 41 123 381 2503 2504 61 2993 46 2994 40 41 59 381 2995 2996 61 2504 46 2997 40 41 59 2998 2999 61 2978 46 2979 40 648 41 59 404 3000 61 2053 46 3001 40 2504 41 59 3002 3003 61 418 3002 40 2996 44 2999 44 3000 44 2014 44 2504 44 2053 46 3004 44 2053 46 2017 44 2015 41 59 3005 40 3003 41 59 125 360 123 3006 40 424 41 59 125 125 125 59 125 125 41 59 450 2977 59 125 64 3007 437 3008 3009 40 41 123 381 3008 3010 61 418 3008 40 41 59 3011 46 3012 40 3010 44 3013 46 3014 41 59 450 3010 59 125 125 
2593,Java,"public class ToolSet {

    /**
     * A cache mapping a {@link Block} to how long it will take to break
     * with this toolset, given the optimum tool is used.
     */
    private final Map<Block, Double> breakStrengthCache;

    /**
     * My buddy leijurv owned me so we have this to not create a new lambda instance.
     */
    private final Function<Block, Double> backendCalculation;

    private final EntityPlayerSP player;

    public ToolSet(EntityPlayerSP player) {
        breakStrengthCache = new HashMap<>();
        this.player = player;

        if (Baritone.settings().considerPotionEffects.value) {
            double amplifier = potionAmplifier();
            Function<Double, Double> amplify = x -> amplifier * x;
            backendCalculation = amplify.compose(this::getBestDestructionTime);
        } else {
            backendCalculation = this::getBestDestructionTime;
        }
    }

    /**
     * Using the best tool on the hotbar, how fast we can mine this block
     *
     * @param state the blockstate to be mined
     * @return the speed of how fast we'll mine it. 1/(time in ticks)
     */
    public double getStrVsBlock(IBlockState state) {
        return breakStrengthCache.computeIfAbsent(state.getBlock(), backendCalculation);
    }

    /**
     * Evaluate the material cost of a possible tool. The priority matches the
     * listed order in the Item.ToolMaterial enum.
     *
     * @param itemStack a possibly empty ItemStack
     * @return values range from -1 to 4
     */
    private int getMaterialCost(ItemStack itemStack) {
        if (itemStack.getItem() instanceof ItemTool) {
            ItemTool tool = (ItemTool) itemStack.getItem();
            return ToolMaterial.valueOf(tool.getToolMaterialName()).ordinal();
        } else {
            return -1;
        }
    }

    public boolean hasSilkTouch(ItemStack stack) {
        return EnchantmentHelper.getEnchantmentLevel(Enchantments.SILK_TOUCH, stack) > 0;
    }

    /**
     * Calculate which tool on the hotbar is best for mining, depending on an override setting,
     * related to auto tool movement cost, it will either return current selected slot, or the best slot.
     *
     * @param b the blockstate to be mined
     * @return An int containing the index in the tools array that worked best
     */

    public int getBestSlot(Block b, boolean preferSilkTouch) {
        return getBestSlot(b, preferSilkTouch, false);
    }

    public int getBestSlot(Block b, boolean preferSilkTouch, boolean pathingCalculation) {

        /*
        If we actually want know what efficiency our held item has instead of the best one
        possible, this lets us make pathing depend on the actual tool to be used (if auto tool is disabled)
        */
        if (!Baritone.settings().autoTool.value && pathingCalculation) {
            return player.inventory.currentItem;
        }

        int best = 0;
        double highestSpeed = Double.NEGATIVE_INFINITY;
        int lowestCost = Integer.MIN_VALUE;
        boolean bestSilkTouch = false;
        IBlockState blockState = b.getDefaultState();
        for (int i = 0; i < 9; i++) {
            ItemStack itemStack = player.inventory.getStackInSlot(i);
            if (!Baritone.settings().useSwordToMine.value && itemStack.getItem() instanceof ItemSword) {
                continue;
            }
          
            if (Baritone.settings().itemSaver.value && (itemStack.getItemDamage() + Baritone.settings().itemSaverThreshold.value) >= itemStack.getMaxDamage() && itemStack.getMaxDamage() > 1) {
                continue;
            }
            double speed = calculateSpeedVsBlock(itemStack, blockState);
            boolean silkTouch = hasSilkTouch(itemStack);
            if (speed > highestSpeed) {
                highestSpeed = speed;
                best = i;
                lowestCost = getMaterialCost(itemStack);
                bestSilkTouch = silkTouch;
            } else if (speed == highestSpeed) {
                int cost = getMaterialCost(itemStack);
                if ((cost < lowestCost && (silkTouch || !bestSilkTouch)) ||
                        (preferSilkTouch && !bestSilkTouch && silkTouch)) {
                    highestSpeed = speed;
                    best = i;
                    lowestCost = cost;
                    bestSilkTouch = silkTouch;
                }
            }
        }
        return best;
    }

    /**
     * Calculate how effectively a block can be destroyed
     *
     * @param b the blockstate to be mined
     * @return A double containing the destruction ticks with the best tool
     */
    private double getBestDestructionTime(Block b) {
        ItemStack stack = player.inventory.getStackInSlot(getBestSlot(b, false, true));
        return calculateSpeedVsBlock(stack, b.getDefaultState()) * avoidanceMultiplier(b);
    }

    private double avoidanceMultiplier(Block b) {
        return Baritone.settings().blocksToAvoidBreaking.value.contains(b) ? Baritone.settings().avoidBreakingMultiplier.value : 1;
    }

    /**
     * Calculates how long would it take to mine the specified block given the best tool
     * in this toolset is used. A negative value is returned if the specified block is unbreakable.
     *
     * @param item  the item to mine it with
     * @param state the blockstate to be mined
     * @return how long it would take in ticks
     */
    public static double calculateSpeedVsBlock(ItemStack item, IBlockState state) {
        float hardness = state.getBlockHardness(null, null);
        if (hardness < 0) {
            return -1;
        }

        float speed = item.getDestroySpeed(state);
        if (speed > 1) {
            int effLevel = EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, item);
            if (effLevel > 0 && !item.isEmpty()) {
                speed += effLevel * effLevel + 1;
            }
        }

        speed /= hardness;
        if (state.getMaterial().isToolNotRequired() || (!item.isEmpty() && item.canHarvestBlock(state))) {
            return speed / 30;
        } else {
            return speed / 100;
        }
    }

    /**
     * Calculates any modifier to breaking time based on status effects.
     *
     * @return a double to scale block breaking speed.
     */
    private double potionAmplifier() {
        double speed = 1;
        if (player.isPotionActive(MobEffects.HASTE)) {
            speed *= 1 + (player.getActivePotionEffect(MobEffects.HASTE).getAmplifier() + 1) * 0.2;
        }
        if (player.isPotionActive(MobEffects.MINING_FATIGUE)) {
            switch (player.getActivePotionEffect(MobEffects.MINING_FATIGUE).getAmplifier()) {
                case 0:
                    speed *= 0.3;
                    break;
                case 1:
                    speed *= 0.09;
                    break;
                case 2:
                    speed *= 0.0027; // you might think that 0.09*0.3 = 0.027 so that should be next, that would make too much sense. it's 0.0027.
                    break;
                default:
                    speed *= 0.00081;
                    break;
            }
        }
        return speed;
    }
}",1,439 334 2000 123 618 437 381 2001 60 2002 44 2003 62 2004 59 618 437 381 2005 60 2002 44 2003 62 2006 59 437 381 2007 2008 59 439 2000 40 2007 2008 41 123 2004 61 418 2009 60 62 40 41 59 467 46 2008 61 2008 59 392 40 2010 46 2011 40 41 46 2012 46 2013 41 123 356 2014 61 2015 40 41 59 2005 60 2003 44 2003 62 2016 61 2017 45 62 2014 42 2017 59 2006 61 2016 46 2018 40 467 58 58 2019 41 59 125 360 123 2006 61 467 58 58 2020 59 125 125 618 439 356 2021 40 2022 2023 41 123 450 2004 46 2024 40 2023 46 2025 40 41 44 2006 41 59 125 618 437 404 2026 40 2027 2028 41 123 392 40 2028 46 2029 40 41 402 2030 41 123 2030 2031 61 40 2030 41 2028 46 2029 40 41 59 450 2032 46 2033 40 2031 46 2034 40 41 41 46 2035 40 41 59 125 360 123 450 45 1501 59 125 125 439 324 2036 40 2027 2037 41 123 450 2038 46 2039 40 2040 46 2041 44 2037 41 62 1500 59 125 618 439 404 2042 40 2002 2043 44 324 2044 41 123 450 2042 40 2043 44 2044 44 380 41 59 125 439 404 2042 40 2002 2043 44 324 2044 44 324 2045 41 123 604 392 40 33 2046 46 2047 40 41 46 2048 46 2049 605 2045 41 123 450 2008 46 2050 46 2051 59 125 404 2052 61 1500 59 356 2053 61 2003 46 2054 59 404 2055 61 2056 46 2057 59 324 2058 61 380 59 2022 2059 61 2043 46 2060 40 41 59 385 40 404 2061 61 1500 59 2061 60 1502 59 2061 637 41 123 2027 2028 61 2008 46 2062 46 2063 40 2061 41 59 392 40 33 2046 46 2047 40 41 46 2064 46 2049 605 2028 46 2065 40 41 402 2066 41 123 344 59 125 392 40 2046 46 2047 40 41 46 2067 46 2049 605 40 2028 46 2068 40 41 43 2046 46 2047 40 41 46 2069 46 2049 41 615 2028 46 2070 40 41 605 2028 46 2070 40 41 62 1501 41 123 344 59 125 356 2071 61 2072 40 2028 44 2059 41 59 324 2073 61 2036 40 2028 41 59 392 40 2071 62 2053 41 123 2053 61 2071 59 2052 61 2061 59 2055 61 2026 40 2028 41 59 2058 61 2073 59 125 360 392 40 2071 614 2053 41 123 404 2074 61 2026 40 2028 41 59 392 40 40 2074 60 2055 605 40 2073 606 33 2058 41 41 606 40 2044 605 33 2058 605 2073 41 41 123 2053 61 2071 59 2052 61 2061 59 2055 61 2074 59 2058 61 2073 59 125 125 125 450 2052 59 125 618 437 356 2075 40 2002 2043 41 123 2027 2037 61 2008 46 2076 46 2077 40 2042 40 2043 44 380 44 473 41 41 59 450 2078 40 2037 44 2043 46 2079 40 41 41 42 2080 40 2043 41 59 125 437 356 2081 40 2002 2043 41 123 450 2082 46 2083 40 41 46 2084 46 2085 46 2086 40 2043 41 63 2082 46 2083 40 41 46 2087 46 2085 58 1501 59 125 618 439 457 356 2088 40 2027 2089 44 2022 2023 41 123 384 2090 61 2023 46 2091 40 424 44 424 41 59 392 40 2090 60 1500 41 123 450 45 1501 59 125 384 2092 61 2089 46 2093 40 2023 41 59 392 40 2092 62 1501 41 123 404 2094 61 2095 46 2096 40 2097 46 2098 44 2089 41 59 392 40 2094 62 1500 605 33 2089 46 2099 40 41 41 123 2092 636 2094 42 2094 43 1501 59 125 125 2092 609 2090 59 392 40 2023 46 2100 40 41 46 2101 40 41 606 40 33 2089 46 2102 40 41 605 2089 46 2103 40 2023 41 41 41 123 450 2092 47 1503 59 125 360 123 450 2092 47 1503 59 125 125 618 437 356 2104 40 41 123 356 2105 61 1501 59 392 40 2008 46 2106 40 2107 46 2108 41 41 123 2105 649 1501 43 40 2008 46 2109 40 2107 46 2108 41 46 2110 40 41 43 1501 41 42 1499 59 125 392 40 2008 46 2106 40 2107 46 2111 41 41 123 464 40 2008 46 2112 40 2107 46 2111 41 46 2113 40 41 41 123 328 1500 58 2105 649 1499 59 325 59 328 1501 58 2105 649 1498 59 325 59 328 1502 58 2105 649 1497 59 621 325 59 349 58 2105 649 1496 59 325 59 125 125 450 2105 59 125 125 
4112,Java,"@Slf4j
public class SignedWitnessService {
    public static final long SIGNER_AGE_DAYS = 30;
    private static final long SIGNER_AGE = SIGNER_AGE_DAYS * ChronoUnit.DAYS.getDuration().toMillis();
    public static final Coin MINIMUM_TRADE_AMOUNT_FOR_SIGNING = Coin.parseCoin(""0.0025"");

    private final KeyRing keyRing;
    private final P2PService p2PService;
    private final ArbitratorManager arbitratorManager;
    private final SignedWitnessStorageService signedWitnessStorageService;
    private final User user;
    private final FilterManager filterManager;

    private final Map<P2PDataStorage.ByteArray, SignedWitness> signedWitnessMap = new HashMap<>();

    // This map keeps all SignedWitnesses with the same AccountAgeWitnessHash in a Set.
    // This avoids iterations over the signedWitnessMap for getting the set of such SignedWitnesses.
    private final Map<P2PDataStorage.ByteArray, Set<SignedWitness>> signedWitnessSetByAccountAgeWitnessHash = new HashMap<>();

    // Iterating over all SignedWitnesses and do a byte array comparison is a bit expensive and
    // it is called at filtering the offer book many times, so we use a lookup map for fast
    // access to the set of SignedWitness which match the ownerPubKey.
    private final Map<P2PDataStorage.ByteArray, Set<SignedWitness>> signedWitnessSetByOwnerPubKey = new HashMap<>();

    // The signature verification calls are rather expensive and called at filtering the offer book many times,
    // so we cache the results using the hash as key. The hash is created from the accountAgeWitnessHash and the
    // signature.
    private final Map<P2PDataStorage.ByteArray, Boolean> verifySignatureWithDSAKeyResultCache = new HashMap<>();
    private final Map<P2PDataStorage.ByteArray, Boolean> verifySignatureWithECKeyResultCache = new HashMap<>();


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public SignedWitnessService(KeyRing keyRing,
                                P2PService p2PService,
                                ArbitratorManager arbitratorManager,
                                SignedWitnessStorageService signedWitnessStorageService,
                                AppendOnlyDataStoreService appendOnlyDataStoreService,
                                User user,
                                FilterManager filterManager) {
        this.keyRing = keyRing;
        this.p2PService = p2PService;
        this.arbitratorManager = arbitratorManager;
        this.signedWitnessStorageService = signedWitnessStorageService;
        this.user = user;
        this.filterManager = filterManager;

        // We need to add that early (before onAllServicesInitialized) as it will be used at startup.
        appendOnlyDataStoreService.addService(signedWitnessStorageService);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void onAllServicesInitialized() {
        p2PService.getP2PDataStorage().addAppendOnlyDataStoreListener(payload -> {
            if (payload instanceof SignedWitness)
                addToMap((SignedWitness) payload);
        });

        // At startup the P2PDataStorage initializes earlier, otherwise we get the listener called.
        signedWitnessStorageService.getMap().values().forEach(e -> {
            if (e instanceof SignedWitness)
                addToMap((SignedWitness) e);
        });

        if (p2PService.isBootstrapped()) {
            onBootstrapComplete();
        } else {
            p2PService.addP2PServiceListener(new BootstrapListener() {
                @Override
                public void onUpdatedDataReceived() {
                    onBootstrapComplete();
                }
            });
        }
        // TODO: Enable cleaning of signed witness list when necessary
        // cleanSignedWitnesses();
    }

    private void onBootstrapComplete() {
        if (user.getRegisteredArbitrator() != null) {
            UserThread.runAfter(this::doRepublishAllSignedWitnesses, 60);
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Collection<SignedWitness> getSignedWitnessMapValues() {
        return signedWitnessMap.values();
    }

    /**
     * List of dates as long when accountAgeWitness was signed
     *
     * Witnesses that were added but are no longer considered signed won't be shown
     */
    public List<Long> getVerifiedWitnessDateList(AccountAgeWitness accountAgeWitness) {
        if (!isSignedAccountAgeWitness(accountAgeWitness)) {
            return new ArrayList<>();
        }
        return getSignedWitnessSet(accountAgeWitness).stream()
                .filter(this::verifySignature)
                .map(SignedWitness::getDate)
                .sorted()
                .collect(Collectors.toList());
    }

    /**
     * List of dates as long when accountAgeWitness was signed
     * Not verifying that signatures are correct
     */
    public List<Long> getWitnessDateList(AccountAgeWitness accountAgeWitness) {
        // We do not validate as it would not make sense to cheat one self...
        return getSignedWitnessSet(accountAgeWitness).stream()
                .map(SignedWitness::getDate)
                .sorted()
                .collect(Collectors.toList());
    }

    public boolean isSignedByArbitrator(AccountAgeWitness accountAgeWitness) {
        return getSignedWitnessSet(accountAgeWitness).stream()
                .map(SignedWitness::isSignedByArbitrator)
                .findAny()
                .orElse(false);
    }

    public boolean isFilteredWitness(AccountAgeWitness accountAgeWitness) {
        return getSignedWitnessSet(accountAgeWitness).stream()
                .map(SignedWitness::getWitnessOwnerPubKey)
                .anyMatch(ownerPubKey -> filterManager.isWitnessSignerPubKeyBanned(Utils.HEX.encode(ownerPubKey)));
    }

    private byte[] ownerPubKey(AccountAgeWitness accountAgeWitness) {
        return getSignedWitnessSet(accountAgeWitness).stream()
                .map(SignedWitness::getWitnessOwnerPubKey)
                .findFirst()
                .orElse(null);
    }

    public String ownerPubKeyAsString(AccountAgeWitness accountAgeWitness) {
        return getSignedWitnessSet(accountAgeWitness).stream()
                .map(signedWitness -> Utils.HEX.encode(signedWitness.getWitnessOwnerPubKey()))
                .findFirst()
                .orElse("""");
    }

    @VisibleForTesting
    public Set<SignedWitness> getSignedWitnessSetByOwnerPubKey(byte[] ownerPubKey) {
        return getSignedWitnessMapValues().stream()
                .filter(e -> Arrays.equals(e.getWitnessOwnerPubKey(), ownerPubKey))
                .collect(Collectors.toSet());
    }

    public boolean publishOwnSignedWitness(SignedWitness signedWitness) {
        if (!Arrays.equals(signedWitness.getWitnessOwnerPubKey(), keyRing.getPubKeyRing().getSignaturePubKeyBytes()) ||
                !verifySigner(signedWitness)) {
            return false;
        }

        log.info(""Publish own signedWitness {}"", signedWitness);
        publishSignedWitness(signedWitness);
        return true;
    }

    // Arbitrators sign with EC key
    public void signAndPublishAccountAgeWitness(Coin tradeAmount,
                                                AccountAgeWitness accountAgeWitness,
                                                ECKey key,
                                                PublicKey peersPubKey) {
        signAndPublishAccountAgeWitness(tradeAmount, accountAgeWitness, key, peersPubKey.getEncoded(), new Date().getTime());
    }

    // Arbitrators sign with EC key
    public String signAndPublishAccountAgeWitness(AccountAgeWitness accountAgeWitness,
                                                  ECKey key,
                                                  byte[] peersPubKey,
                                                  long time) {
        var witnessPubKey = peersPubKey == null ? ownerPubKey(accountAgeWitness) : peersPubKey;
        return signAndPublishAccountAgeWitness(MINIMUM_TRADE_AMOUNT_FOR_SIGNING, accountAgeWitness, key, witnessPubKey, time);
    }

    // Arbitrators sign with EC key
    public String signTraderPubKey(ECKey key,
                                   byte[] peersPubKey,
                                   long childSignTime) {
        var time = childSignTime - SIGNER_AGE - 1;
        var dummyAccountAgeWitness = new AccountAgeWitness(Hash.getRipemd160hash(peersPubKey), time);
        return signAndPublishAccountAgeWitness(MINIMUM_TRADE_AMOUNT_FOR_SIGNING, dummyAccountAgeWitness, key, peersPubKey, time);
    }

    // Arbitrators sign with EC key
    private String signAndPublishAccountAgeWitness(Coin tradeAmount,
                                                   AccountAgeWitness accountAgeWitness,
                                                   ECKey key,
                                                   byte[] peersPubKey,
                                                   long time) {
        if (isSignedAccountAgeWitness(accountAgeWitness)) {
            var err = ""Arbitrator trying to sign already signed accountagewitness "" + accountAgeWitness.toString();
            log.warn(err);
            return err;
        }
        if (peersPubKey == null) {
            var err = ""Trying to sign accountAgeWitness "" + accountAgeWitness.toString() + ""\nwith owner pubkey=null"";
            log.warn(err);
            return err;
        }

        String accountAgeWitnessHashAsHex = Utilities.encodeToHex(accountAgeWitness.getHash());
        String signatureBase64 = key.signMessage(accountAgeWitnessHashAsHex);
        SignedWitness signedWitness = new SignedWitness(SignedWitness.VerificationMethod.ARBITRATOR,
                accountAgeWitness.getHash(),
                signatureBase64.getBytes(Charsets.UTF_8),
                key.getPubKey(),
                peersPubKey,
                time,
                tradeAmount.value);
        publishSignedWitness(signedWitness);
        log.info(""Arbitrator signed witness {}"", signedWitness.toString());
        return """";
    }

    public void selfSignAndPublishAccountAgeWitness(AccountAgeWitness accountAgeWitness) throws CryptoException {
        log.info(""Sign own accountAgeWitness {}"", accountAgeWitness);
        signAndPublishAccountAgeWitness(MINIMUM_TRADE_AMOUNT_FOR_SIGNING, accountAgeWitness,
                keyRing.getSignatureKeyPair().getPublic());
    }

    // Any peer can sign with DSA key
    public Optional<SignedWitness> signAndPublishAccountAgeWitness(Coin tradeAmount,
                                                                   AccountAgeWitness accountAgeWitness,
                                                                   PublicKey peersPubKey) throws CryptoException {
        if (isSignedAccountAgeWitness(accountAgeWitness)) {
            log.warn(""Trader trying to sign already signed accountagewitness {}"", accountAgeWitness.toString());
            return Optional.empty();
        }

        if (!isSufficientTradeAmountForSigning(tradeAmount)) {
            log.warn(""Trader tried to sign account with too little trade amount"");
            return Optional.empty();
        }

        byte[] signature = Sig.sign(keyRing.getSignatureKeyPair().getPrivate(), accountAgeWitness.getHash());
        SignedWitness signedWitness = new SignedWitness(SignedWitness.VerificationMethod.TRADE,
                accountAgeWitness.getHash(),
                signature,
                keyRing.getSignatureKeyPair().getPublic().getEncoded(),
                peersPubKey.getEncoded(),
                new Date().getTime(),
                tradeAmount.value);
        publishSignedWitness(signedWitness);
        log.info(""Trader signed witness {}"", signedWitness.toString());
        return Optional.of(signedWitness);
    }

    public boolean verifySignature(SignedWitness signedWitness) {
        if (signedWitness.isSignedByArbitrator()) {
            return verifySignatureWithECKey(signedWitness);
        } else {
            return verifySignatureWithDSAKey(signedWitness);
        }
    }

    private boolean verifySignatureWithECKey(SignedWitness signedWitness) {
        P2PDataStorage.ByteArray hash = new P2PDataStorage.ByteArray(signedWitness.getHash());
        if (verifySignatureWithECKeyResultCache.containsKey(hash)) {
            return verifySignatureWithECKeyResultCache.get(hash);
        }
        try {
            String message = Utilities.encodeToHex(signedWitness.getAccountAgeWitnessHash());
            String signatureBase64 = new String(signedWitness.getSignature(), Charsets.UTF_8);
            ECKey key = ECKey.fromPublicOnly(signedWitness.getSignerPubKey());
            if (arbitratorManager.isPublicKeyInList(Utilities.encodeToHex(key.getPubKey()))) {
                key.verifyMessage(message, signatureBase64);
                verifySignatureWithECKeyResultCache.put(hash, true);
                return true;
            } else {
                log.warn(""Provided EC key is not in list of valid arbitrators."");
                verifySignatureWithECKeyResultCache.put(hash, false);
                return false;
            }
        } catch (SignatureException e) {
            log.warn(""verifySignature signedWitness failed. signedWitness={}"", signedWitness);
            log.warn(""Caused by "", e);
            verifySignatureWithECKeyResultCache.put(hash, false);
            return false;
        }
    }

    private boolean verifySignatureWithDSAKey(SignedWitness signedWitness) {
        P2PDataStorage.ByteArray hash = new P2PDataStorage.ByteArray(signedWitness.getHash());
        if (verifySignatureWithDSAKeyResultCache.containsKey(hash)) {
            return verifySignatureWithDSAKeyResultCache.get(hash);
        }
        try {
            PublicKey signaturePubKey = Sig.getPublicKeyFromBytes(signedWitness.getSignerPubKey());
            Sig.verify(signaturePubKey, signedWitness.getAccountAgeWitnessHash(), signedWitness.getSignature());
            verifySignatureWithDSAKeyResultCache.put(hash, true);
            return true;
        } catch (CryptoException e) {
            log.warn(""verifySignature signedWitness failed. signedWitness={}"", signedWitness);
            log.warn(""Caused by "", e);
            verifySignatureWithDSAKeyResultCache.put(hash, false);
            return false;
        }
    }

    public Set<SignedWitness> getSignedWitnessSet(AccountAgeWitness accountAgeWitness) {
        P2PDataStorage.ByteArray key = new P2PDataStorage.ByteArray(accountAgeWitness.getHash());
        return signedWitnessSetByAccountAgeWitnessHash.getOrDefault(key, new HashSet<>());
    }

    // SignedWitness objects signed by arbitrators
    public Set<SignedWitness> getArbitratorsSignedWitnessSet(AccountAgeWitness accountAgeWitness) {
        return getSignedWitnessSet(accountAgeWitness).stream()
                .filter(SignedWitness::isSignedByArbitrator)
                .collect(Collectors.toSet());
    }

    // SignedWitness objects signed by any other peer
    public Set<SignedWitness> getTrustedPeerSignedWitnessSet(AccountAgeWitness accountAgeWitness) {
        return getSignedWitnessSet(accountAgeWitness).stream()
                .filter(e -> !e.isSignedByArbitrator())
                .collect(Collectors.toSet());
    }

    public Set<SignedWitness> getRootSignedWitnessSet(boolean includeSignedByArbitrator) {
        return getSignedWitnessMapValues().stream()
                .filter(witness -> getSignedWitnessSetByOwnerPubKey(witness.getSignerPubKey(), new Stack<>()).isEmpty())
                .filter(witness -> includeSignedByArbitrator ||
                        witness.getVerificationMethod() != SignedWitness.VerificationMethod.ARBITRATOR)
                .collect(Collectors.toSet());
    }

    // Find first (in time) SignedWitness per missing signer
    public Set<SignedWitness> getUnsignedSignerPubKeys() {
        var oldestUnsignedSigners = new HashMap<P2PDataStorage.ByteArray, SignedWitness>();
        getRootSignedWitnessSet(false).forEach(signedWitness ->
                oldestUnsignedSigners.compute(new P2PDataStorage.ByteArray(signedWitness.getSignerPubKey()),
                        (key, oldValue) -> oldValue == null ? signedWitness :
                                oldValue.getDate() > signedWitness.getDate() ? signedWitness : oldValue));
        return new HashSet<>(oldestUnsignedSigners.values());
    }

    // We go one level up by using the signer Key to lookup for SignedWitness objects which contain the signerKey as
    // witnessOwnerPubKey
    private Set<SignedWitness> getSignedWitnessSetByOwnerPubKey(byte[] ownerPubKey,
                                                                Stack<P2PDataStorage.ByteArray> excluded) {
        P2PDataStorage.ByteArray key = new P2PDataStorage.ByteArray(ownerPubKey);
        if (signedWitnessSetByOwnerPubKey.containsKey(key)) {
            return signedWitnessSetByOwnerPubKey.get(key).stream()
                    .filter(e -> !excluded.contains(new P2PDataStorage.ByteArray(e.getSignerPubKey())))
                    .collect(Collectors.toSet());

        } else {
            return new HashSet<>();
        }
    }

    public boolean isSignedAccountAgeWitness(AccountAgeWitness accountAgeWitness) {
        return isSignerAccountAgeWitness(accountAgeWitness, new Date().getTime() + SIGNER_AGE);
    }

    public boolean isSignerAccountAgeWitness(AccountAgeWitness accountAgeWitness) {
        return isSignerAccountAgeWitness(accountAgeWitness, new Date().getTime());
    }

    public boolean isSufficientTradeAmountForSigning(Coin tradeAmount) {
        return !tradeAmount.isLessThan(MINIMUM_TRADE_AMOUNT_FOR_SIGNING);
    }

    private boolean verifySigner(SignedWitness signedWitness) {
        return getSignedWitnessSetByOwnerPubKey(signedWitness.getWitnessOwnerPubKey(), new Stack<>()).stream()
                .anyMatch(w -> isValidSignerWitnessInternal(w, signedWitness.getDate(), new Stack<>()));
    }

    /**
     * Checks whether the accountAgeWitness has a valid signature from a peer/arbitrator and is allowed to sign
     * other accounts.
     *
     * @param accountAgeWitness accountAgeWitness
     * @param time              time of signing
     * @return true if accountAgeWitness is allowed to sign at time, false otherwise.
     */
    private boolean isSignerAccountAgeWitness(AccountAgeWitness accountAgeWitness, long time) {
        Stack<P2PDataStorage.ByteArray> excludedPubKeys = new Stack<>();
        Set<SignedWitness> signedWitnessSet = getSignedWitnessSet(accountAgeWitness);
        for (SignedWitness signedWitness : signedWitnessSet) {
            if (isValidSignerWitnessInternal(signedWitness, time, excludedPubKeys)) {
                return true;
            }
        }
        // If we have not returned in the loops or they have been empty we have not found a valid signer.
        return false;
    }

    /**
     * Helper to isValidAccountAgeWitness(accountAgeWitness)
     *
     * @param signedWitness                the signedWitness to validate
     * @param childSignedWitnessDateMillis the date the child SignedWitness was signed or current time if it is a leaf.
     * @param excludedPubKeys              stack to prevent recursive loops
     * @return true if signedWitness is valid, false otherwise.
     */
    private boolean isValidSignerWitnessInternal(SignedWitness signedWitness,
                                                 long childSignedWitnessDateMillis,
                                                 Stack<P2PDataStorage.ByteArray> excludedPubKeys) {
        if (filterManager.isWitnessSignerPubKeyBanned(Utils.HEX.encode(signedWitness.getWitnessOwnerPubKey()))) {
            return false;
        }
        if (!verifySignature(signedWitness)) {
            return false;
        }
        if (signedWitness.isSignedByArbitrator()) {
            // If signed by an arbitrator we don't have to check anything else.
            return true;
        } else {
            if (!verifyDate(signedWitness, childSignedWitnessDateMillis)) {
                return false;
            }
            if (excludedPubKeys.size() >= 2000) {
                // Prevent DoS attack: an attacker floods the SignedWitness db with a long chain that takes lots of time to verify.
                return false;
            }
            excludedPubKeys.push(new P2PDataStorage.ByteArray(signedWitness.getSignerPubKey()));
            excludedPubKeys.push(new P2PDataStorage.ByteArray(signedWitness.getWitnessOwnerPubKey()));
            // Iterate over signedWitness signers
            Set<SignedWitness> signerSignedWitnessSet = getSignedWitnessSetByOwnerPubKey(signedWitness.getSignerPubKey(), excludedPubKeys);
            for (SignedWitness signerSignedWitness : signerSignedWitnessSet) {
                if (isValidSignerWitnessInternal(signerSignedWitness, signedWitness.getDate(), excludedPubKeys)) {
                    return true;
                }
            }
            excludedPubKeys.pop();
            excludedPubKeys.pop();
        }
        // If we have not returned in the loops or they have been empty we have not found a valid signer.
        return false;
    }

    private boolean verifyDate(SignedWitness signedWitness, long childSignedWitnessDateMillis) {
        long childSignedWitnessDateMinusChargebackPeriodMillis = Instant.ofEpochMilli(
                childSignedWitnessDateMillis).minus(SIGNER_AGE, ChronoUnit.MILLIS).toEpochMilli();
        long signedWitnessDateMillis = signedWitness.getDate();
        return signedWitnessDateMillis <= childSignedWitnessDateMinusChargebackPeriodMillis;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    @VisibleForTesting
    public void addToMap(SignedWitness signedWitness) {
        signedWitnessMap.putIfAbsent(signedWitness.getHashAsByteArray(), signedWitness);

        P2PDataStorage.ByteArray accountAgeWitnessHash = new P2PDataStorage.ByteArray(signedWitness.getAccountAgeWitnessHash());
        signedWitnessSetByAccountAgeWitnessHash.putIfAbsent(accountAgeWitnessHash, new HashSet<>());
        signedWitnessSetByAccountAgeWitnessHash.get(accountAgeWitnessHash).add(signedWitness);

        P2PDataStorage.ByteArray ownerPubKey = new P2PDataStorage.ByteArray(signedWitness.getWitnessOwnerPubKey());
        signedWitnessSetByOwnerPubKey.putIfAbsent(ownerPubKey, new HashSet<>());
        signedWitnessSetByOwnerPubKey.get(ownerPubKey).add(signedWitness);
    }

    private void publishSignedWitness(SignedWitness signedWitness) {
        if (!signedWitnessMap.containsKey(signedWitness.getHashAsByteArray())) {
            log.info(""broadcast signed witness {}"", signedWitness.toString());
            // We set reBroadcast to true to achieve better resilience.
            p2PService.addPersistableNetworkPayload(signedWitness, true);
            addToMap(signedWitness);
        }
    }

    private void doRepublishAllSignedWitnesses() {
        getSignedWitnessMapValues()
                .forEach(signedWitness -> p2PService.addPersistableNetworkPayload(signedWitness, true));
    }

    @VisibleForTesting
    public void removeSignedWitness(SignedWitness signedWitness) {
        signedWitnessMap.remove(signedWitness.getHashAsByteArray());

        P2PDataStorage.ByteArray accountAgeWitnessHash = new P2PDataStorage.ByteArray(signedWitness.getAccountAgeWitnessHash());
        if (signedWitnessSetByAccountAgeWitnessHash.containsKey(accountAgeWitnessHash)) {
            Set<SignedWitness> set = signedWitnessSetByAccountAgeWitnessHash.get(accountAgeWitnessHash);
            set.remove(signedWitness);
            if (set.isEmpty()) {
                signedWitnessSetByAccountAgeWitnessHash.remove(accountAgeWitnessHash);
            }
        }

        P2PDataStorage.ByteArray ownerPubKey = new P2PDataStorage.ByteArray(signedWitness.getWitnessOwnerPubKey());
        if (signedWitnessSetByOwnerPubKey.containsKey(ownerPubKey)) {
            Set<SignedWitness> set = signedWitnessSetByOwnerPubKey.get(ownerPubKey);
            set.remove(signedWitness);
            if (set.isEmpty()) {
                signedWitnessSetByOwnerPubKey.remove(ownerPubKey);
            }
        }
    }

    // Remove SignedWitnesses that are signed by TRADE that also have an ARBITRATOR signature
    // for the same ownerPubKey and AccountAgeWitnessHash
//    private void cleanSignedWitnesses() {
//        var orphans = getRootSignedWitnessSet(false);
//        var signedWitnessesCopy = new HashSet<>(signedWitnessMap.values());
//        signedWitnessesCopy.forEach(sw -> orphans.forEach(orphan -> {
//            if (sw.getVerificationMethod() == SignedWitness.VerificationMethod.ARBITRATOR &&
//                    Arrays.equals(sw.getWitnessOwnerPubKey(), orphan.getWitnessOwnerPubKey()) &&
//                    Arrays.equals(sw.getAccountAgeWitnessHash(), orphan.getAccountAgeWitnessHash())) {
//                signedWitnessMap.remove(orphan.getHashAsByteArray());
//                log.info(""Remove duplicate SignedWitness: {}"", orphan.toString());
//            }
//        }));
//    }
}",1,64 2000 439 334 2001 123 439 457 381 413 2002 61 1503 59 437 457 381 413 2003 61 2002 42 2004 46 2005 46 2006 40 41 46 2007 40 41 59 439 457 381 2008 2009 61 2008 46 2010 40 648 41 59 437 381 2011 2012 59 437 381 2013 2014 59 437 381 2015 2016 59 437 381 2017 2018 59 437 381 2019 2020 59 437 381 2021 2022 59 437 381 2023 60 2024 46 2025 44 2026 62 2027 61 418 2028 60 62 40 41 59 621 621 437 381 2023 60 2024 46 2025 44 2029 60 2026 641 2030 61 418 2028 60 62 40 41 59 621 621 621 437 381 2023 60 2024 46 2025 44 2029 60 2026 641 2031 61 418 2028 60 62 40 41 59 621 621 621 437 381 2023 60 2024 46 2025 44 2032 62 2033 61 418 2028 60 62 40 41 59 437 381 2023 60 2024 46 2025 44 2032 62 2034 61 418 2028 60 62 40 41 59 621 621 621 64 2035 439 2001 40 2011 2012 44 2013 2014 44 2015 2016 44 2017 2018 44 2036 2037 44 2019 2020 44 2021 2022 41 123 467 46 2012 61 2012 59 467 46 2014 61 2014 59 467 46 2016 61 2016 59 467 46 2018 61 2018 59 467 46 2020 61 2020 59 467 46 2022 61 2022 59 621 2037 46 2038 40 2018 41 59 125 621 621 621 439 492 2039 40 41 123 2014 46 2040 40 41 46 2041 40 2042 45 62 123 392 40 2042 402 2026 41 2043 40 40 2026 41 2042 41 59 125 41 59 621 2018 46 2044 40 41 46 2045 40 41 46 2046 40 2047 45 62 123 392 40 2047 402 2026 41 2048 40 40 2026 41 2047 41 59 125 41 59 392 40 2014 46 2049 40 41 41 123 2050 40 41 59 125 360 123 2014 46 2051 40 418 2052 40 41 123 64 2053 439 492 2054 40 41 123 2055 40 41 59 125 125 41 59 125 621 621 125 437 492 2056 40 41 123 392 40 2020 46 2057 40 41 631 424 41 123 2058 46 2059 40 467 58 58 2060 44 1503 41 59 125 125 621 621 621 439 2061 60 2026 62 2062 40 41 123 450 2027 46 2063 40 41 59 125 618 439 2064 60 2065 62 2066 40 2067 2068 41 123 392 40 33 2069 40 2068 41 41 123 450 418 2070 60 62 40 41 59 125 450 2071 40 2068 41 46 2072 40 41 46 2073 40 467 58 58 2074 41 46 2075 40 2026 58 58 2076 41 46 2077 40 41 46 2078 40 2079 46 2080 40 41 41 59 125 618 439 2064 60 2065 62 2081 40 2067 2068 41 123 621 450 2082 40 2068 41 46 2083 40 41 46 2084 40 2026 58 58 2085 41 46 2086 40 41 46 2087 40 2088 46 2089 40 41 41 59 125 439 324 2090 40 2067 2068 41 123 450 2091 40 2068 41 46 2092 40 41 46 2093 40 2026 58 58 2090 41 46 2094 40 41 46 2095 40 380 41 59 125 439 324 2096 40 2067 2068 41 123 450 2097 40 2068 41 46 2098 40 41 46 2099 40 2026 58 58 2100 41 46 2101 40 2102 45 62 2022 46 2103 40 2104 46 2105 46 2106 40 2102 41 41 41 59 125 437 326 91 93 2107 40 2067 2068 41 123 450 2108 40 2068 41 46 2109 40 41 46 2110 40 2026 58 58 2111 41 46 2112 40 41 46 2113 40 424 41 59 125 439 2114 2115 40 2067 2068 41 123 450 2116 40 2068 41 46 2117 40 41 46 2118 40 2119 45 62 2120 46 2121 46 2122 40 2119 46 2123 40 41 41 41 46 2124 40 41 46 2125 40 648 41 59 125 64 2126 439 2029 60 2026 62 2127 40 326 91 93 2107 41 123 450 2062 40 41 46 2128 40 41 46 2129 40 2130 45 62 2131 46 2132 40 2130 46 2133 40 41 44 2107 41 41 46 2134 40 2135 46 2136 40 41 41 59 125 439 324 2137 40 2026 2138 41 123 392 40 33 2139 46 2140 40 2138 46 2141 40 41 44 2012 46 2142 40 41 46 2143 40 41 41 606 33 2144 40 2138 41 41 123 450 380 59 125 2145 46 2146 40 648 44 2138 41 59 2147 40 2138 41 59 450 473 59 125 621 439 492 2148 40 2008 2149 44 2067 2068 44 2150 2151 44 2152 2153 41 123 2148 40 2149 44 2068 44 2151 44 2153 46 2154 40 41 44 418 2155 40 41 46 2156 40 41 41 59 125 621 439 2114 2148 40 2067 2068 44 2150 2151 44 326 91 93 2153 44 413 2157 41 123 490 2158 61 2153 614 424 63 2107 40 2068 41 58 2153 59 450 2148 40 2009 44 2068 44 2151 44 2158 44 2157 41 59 125 621 439 2114 2159 40 2150 2151 44 326 91 93 2153 44 413 2160 41 123 490 2157 61 2160 45 2003 45 1501 59 490 2161 61 418 2067 40 2162 46 2163 40 2153 41 44 2157 41 59 450 2148 40 2009 44 2161 44 2151 44 2153 44 2157 41 59 125 621 437 2114 2148 40 2008 2149 44 2067 2068 44 2150 2151 44 326 91 93 2153 44 413 2157 41 123 392 40 2164 40 2068 41 41 123 490 2165 61 648 43 2068 46 2166 40 41 59 2167 46 2168 40 2165 41 59 450 2165 59 125 392 40 2153 614 424 41 123 490 2169 61 648 43 2068 46 2170 40 41 43 648 59 2171 46 2172 40 2169 41 59 450 2169 59 125 2114 2173 61 2174 46 2175 40 2068 46 2176 40 41 41 59 2114 2177 61 2151 46 2178 40 2173 41 59 2026 2138 61 418 2026 40 2026 46 2179 46 2180 44 2068 46 2176 40 41 44 2177 46 2181 40 2182 46 2183 41 44 2151 46 2184 40 41 44 2153 44 2157 44 2149 46 2185 41 59 2186 40 2138 41 59 2187 46 2188 40 648 44 2138 46 2189 40 41 41 59 450 648 59 125 439 492 2190 40 2067 2068 41 470 2191 123 2192 46 2193 40 648 44 2068 41 59 2148 40 2009 44 2068 44 2012 46 2194 40 41 46 2195 40 41 41 59 125 621 439 2196 60 2026 62 2148 40 2008 2149 44 2067 2068 44 2152 2153 41 470 2191 123 392 40 2197 40 2068 41 41 123 2198 46 2199 40 648 44 2068 46 2200 40 41 41 59 450 2196 46 362 40 41 59 125 392 40 33 2201 40 2149 41 41 123 2202 46 2203 40 648 41 59 450 2196 46 362 40 41 59 125 326 91 93 2204 61 2205 46 2206 40 2012 46 2207 40 41 46 2208 40 41 44 2068 46 2209 40 41 41 59 2026 2138 61 418 2026 40 2026 46 2210 46 2211 44 2068 46 2209 40 41 44 2204 44 2012 46 2207 40 41 46 2212 40 41 46 2213 40 41 44 2153 46 2213 40 41 44 418 2214 40 41 46 2215 40 41 44 2149 46 2216 41 59 2217 40 2138 41 59 2218 46 2219 40 648 44 2138 46 2220 40 41 41 59 450 2196 46 2221 40 2138 41 59 125 439 324 2222 40 2026 2138 41 123 392 40 2138 46 2090 40 41 41 123 450 2223 40 2138 41 59 125 360 123 450 2224 40 2138 41 59 125 125 437 324 2225 40 2026 2138 41 123 2024 46 2025 2226 61 418 2024 46 2025 40 2138 46 2227 40 41 41 59 392 40 2034 46 2228 40 2226 41 41 123 450 2034 46 2229 40 2226 41 59 125 474 123 2114 2230 61 2231 46 2232 40 2138 46 2233 40 41 41 59 2114 2234 61 418 2114 40 2138 46 2235 40 41 44 2236 46 2237 41 59 2150 2151 61 2150 46 2238 40 2138 46 2239 40 41 41 59 392 40 2016 46 2240 40 2231 46 2232 40 2151 46 2241 40 41 41 41 41 123 2151 46 2242 40 2230 44 2234 41 59 2034 46 2243 40 2226 44 473 41 59 450 473 59 125 360 123 2244 46 2245 40 648 41 59 2034 46 2246 40 2226 44 380 41 59 450 380 59 125 125 329 40 2247 2248 41 123 2249 46 2250 40 648 44 2138 41 59 2249 46 2250 40 648 44 2248 41 59 2034 46 2251 40 2226 44 380 41 59 450 380 59 125 125 437 324 2252 40 2026 2138 41 123 2024 46 2025 2253 61 418 2024 46 2025 40 2138 46 2254 40 41 41 59 392 40 2033 46 2255 40 2253 41 41 123 450 2033 46 2256 40 2253 41 59 125 474 123 2152 2257 61 2258 46 2259 40 2138 46 2260 40 41 41 59 2258 46 2261 40 2257 44 2138 46 2262 40 41 44 2138 46 2263 40 41 41 59 2033 46 2264 40 2253 44 473 41 59 450 473 59 125 329 40 2191 2265 41 123 2266 46 2267 40 648 44 2138 41 59 2266 46 2267 40 648 44 2265 41 59 2033 46 2268 40 2253 44 380 41 59 450 380 59 125 125 439 2029 60 2026 62 2269 40 2067 2068 41 123 2024 46 2025 2151 61 418 2024 46 2025 40 2068 46 2270 40 41 41 59 450 2030 46 2271 40 2151 44 418 2272 60 62 40 41 41 59 125 621 439 2029 60 2026 62 2273 40 2067 2068 41 123 450 2269 40 2068 41 46 2274 40 41 46 2275 40 2026 58 58 2090 41 46 2276 40 2277 46 2278 40 41 41 59 125 621 439 2029 60 2026 62 2279 40 2067 2068 41 123 450 2269 40 2068 41 46 2280 40 41 46 2281 40 2282 45 62 33 2282 46 2090 40 41 41 46 2283 40 2284 46 2285 40 41 41 59 125 439 2029 60 2026 62 2286 40 324 2287 41 123 450 2062 40 41 46 2288 40 41 46 2289 40 2290 45 62 2127 40 2290 46 2291 40 41 44 418 2292 60 62 40 41 41 46 2293 40 41 41 46 2289 40 2290 45 62 2287 606 2290 46 2294 40 41 631 2026 46 2295 46 2296 41 46 2297 40 2298 46 2299 40 41 41 59 125 621 439 2029 60 2026 62 2300 40 41 123 490 2301 61 418 2028 60 2024 46 2025 44 2026 62 40 41 59 2286 40 380 41 46 2302 40 2138 45 62 2301 46 2303 40 418 2024 46 2025 40 2138 46 2304 40 41 41 44 40 2151 44 2305 41 45 62 2305 614 424 63 2138 58 2305 46 2306 40 41 62 2138 46 2306 40 41 63 2138 58 2305 41 41 59 450 418 2307 60 62 40 2301 46 2308 40 41 41 59 125 621 621 437 2029 60 2026 62 2127 40 326 91 93 2107 44 2309 60 2024 46 2025 62 2310 41 123 2024 46 2025 2151 61 418 2024 46 2025 40 2107 41 59 392 40 2031 46 2311 40 2151 41 41 123 450 2031 46 2312 40 2151 41 46 2313 40 41 46 2314 40 2315 45 62 33 2310 46 2316 40 418 2024 46 2025 40 2315 46 2317 40 41 41 41 41 46 2318 40 2319 46 2320 40 41 41 59 125 360 123 450 418 2321 60 62 40 41 59 125 125 439 324 2322 40 2067 2068 41 123 450 2323 40 2068 44 418 2324 40 41 46 2325 40 41 43 2003 41 59 125 439 324 2326 40 2067 2068 41 123 450 2326 40 2068 44 418 2327 40 41 46 2328 40 41 41 59 125 439 324 2329 40 2008 2149 41 123 450 33 2149 46 2330 40 2009 41 59 125 437 324 2331 40 2026 2138 41 123 450 2127 40 2138 46 2332 40 41 44 418 2309 60 62 40 41 41 46 2333 40 41 46 2334 40 2335 45 62 2336 40 2335 44 2138 46 2337 40 41 44 418 2309 60 62 40 41 41 41 59 125 618 437 324 2326 40 2067 2068 44 413 2157 41 123 2309 60 2024 46 2025 62 2338 61 418 2309 60 62 40 41 59 2029 60 2026 62 2339 61 2269 40 2068 41 59 385 40 2026 2138 58 2339 41 123 392 40 2340 40 2138 44 2157 44 2338 41 41 123 450 473 59 125 125 621 450 380 59 125 618 437 324 2341 40 2026 2138 44 413 2342 44 2309 60 2024 46 2025 62 2343 41 123 392 40 2022 46 2344 40 2345 46 2346 46 2347 40 2138 46 2348 40 41 41 41 41 123 450 380 59 125 392 40 33 2222 40 2138 41 41 123 450 380 59 125 392 40 2138 46 2090 40 41 41 123 621 450 473 59 125 360 123 392 40 33 2349 40 2138 44 2342 41 41 123 450 380 59 125 392 40 2343 46 2350 40 41 615 1505 41 123 621 450 380 59 125 2343 46 2351 40 418 2024 46 2025 40 2138 46 2352 40 41 41 41 59 2343 46 2351 40 418 2024 46 2025 40 2138 46 2348 40 41 41 41 59 621 2029 60 2026 62 2353 61 2127 40 2138 46 2352 40 41 44 2343 41 59 385 40 2026 2354 58 2353 41 123 392 40 2341 40 2354 44 2138 46 2355 40 41 44 2343 41 41 123 450 473 59 125 125 2343 46 2356 40 41 59 2343 46 2356 40 41 59 125 621 450 380 59 125 437 324 2357 40 2026 2138 44 413 2342 41 123 413 2358 61 2359 46 2360 40 2342 41 46 2361 40 2003 44 2004 46 2362 41 46 2363 40 41 59 413 2364 61 2138 46 2365 40 41 59 450 2364 620 2358 59 125 621 621 621 64 2126 439 492 2366 40 2026 2138 41 123 2027 46 2367 40 2138 46 2368 40 41 44 2138 41 59 2024 46 2025 2369 61 418 2024 46 2025 40 2138 46 2370 40 41 41 59 2030 46 2367 40 2369 44 418 2371 60 62 40 41 41 59 2030 46 2372 40 2369 41 46 2373 40 2138 41 59 2024 46 2025 2107 61 418 2024 46 2025 40 2138 46 2374 40 41 41 59 2031 46 2367 40 2107 44 418 2371 60 62 40 41 41 59 2031 46 2372 40 2107 41 46 2373 40 2138 41 59 125 437 492 2375 40 2026 2138 41 123 392 40 33 2027 46 2376 40 2138 46 2377 40 41 41 41 123 2378 46 2379 40 648 44 2138 46 2380 40 41 41 59 621 2014 46 2381 40 2138 44 473 41 59 2366 40 2138 41 59 125 125 437 492 2382 40 41 123 2062 40 41 46 2383 40 2138 45 62 2014 46 2384 40 2138 44 473 41 41 59 125 64 2126 439 492 2385 40 2026 2138 41 123 2027 46 2386 40 2138 46 2387 40 41 41 59 2024 46 2025 2388 61 418 2024 46 2025 40 2138 46 2389 40 41 41 59 392 40 2030 46 2390 40 2388 41 41 123 2029 60 2026 62 2391 61 2030 46 2392 40 2388 41 59 2391 46 2386 40 2138 41 59 392 40 2391 46 2393 40 41 41 123 2030 46 2386 40 2388 41 59 125 125 2024 46 2025 2107 61 418 2024 46 2025 40 2138 46 2394 40 41 41 59 392 40 2031 46 2390 40 2107 41 41 123 2029 60 2026 62 2395 61 2031 46 2396 40 2107 41 59 2395 46 2386 40 2138 41 59 392 40 2395 46 2397 40 41 41 123 2031 46 2386 40 2107 41 59 125 125 125 621 621 621 621 621 621 621 621 621 621 621 621 621 621 125 
26372,Java,"public class AuthController {

    private static final Logger LOGGER = LoggerFactory.getLogger(AuthController.class);
    private static final Logger LOGIN_HISTORY = LoggerFactory.getLogger(""loginHistory"");
    private static final int LOGIN_TIMEOUT = 3;
    private static final Pattern USERNAME_PATTERN = Pattern.compile(usernameTemplate());
    private static final String ACCOUNT_LOGIN_FAILED = ""Account Login Failed {} : {}"";

    private final Map<String, AuthClient> authedClients = new ConcurrentHashMap<>();
    private final Map<String, FailedLoginAttempt> bruteForceProtection = new HashMap<>();
    private final BanManager banManager;
    private final int key;

    private KeyGenerator blowfishKeysGenerator;
    private ScheduledFuture<?> scheduledPurge;

    private ScrambledKeyPair[] _keyPairs;

    private AuthController() {
        banManager = BanManager.getInstance();
        try {
            load();
        } catch (GeneralSecurityException e) {
            LOGGER.error(e.getMessage(), e);
        }
        key = Rnd.nextSecureInt();
    }

    private void load() throws GeneralSecurityException {
        LOGGER.info(""Loading Auth Controller..."");
        blowfishKeysGenerator = KeyGenerator.getInstance(""Blowfish"");
        initializeScrambledKeys();
    }

    private void initializeScrambledKeys() throws GeneralSecurityException {
        var keygen = KeyPairGenerator.getInstance(""RSA"");
        var spec = new RSAKeyGenParameterSpec(1024, RSAKeyGenParameterSpec.F4);
        keygen.initialize(spec);

        _keyPairs = new ScrambledKeyPair[10];

        for (int i = 0; i < 10; i++) {
            _keyPairs[i] = new ScrambledKeyPair(keygen.generateKeyPair());
        }
        LOGGER.info(""Cached 10 KeyPairs for RSA communication"");

        testCipher((RSAPrivateKey) _keyPairs[0].getPair().getPrivate());
    }

    private void testCipher(RSAPrivateKey key) throws GeneralSecurityException {
        Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/nopadding"");
        rsaCipher.init(Cipher.DECRYPT_MODE, key);
    }

    public void registerClient(AuthClient client) {
        client.setKeyPar(getScrambledRSAKeyPair());
        var blowfishKey  = getBlowfishKey();
        client.setBlowfishKey(blowfishKey);
        client.setSessionId(Rnd.nextSecureInt());
        var cripter = new AuthCrypt();
        cripter.setKey(blowfishKey);
        client.setCrypt(cripter);

        if(isNull(scheduledPurge) || scheduledPurge.isCancelled()) {
            scheduledPurge = ThreadPool.scheduleAtFixedDelay(new PurgeThread(), LOGIN_TIMEOUT, LOGIN_TIMEOUT, TimeUnit.MINUTES);
        }
    }

    private void assignSessionKeyToClient(AuthClient client) {
        var sessionKey = new SessionKey(Rnd.nextSecureInt(), this.key, Rnd.nextSecureInt(), Rnd.nextSecureInt());
        client.setSessionKey(sessionKey);
        authedClients.put(client.getAccount().getLogin(), client);
    }

    public void removeAuthedClient(String account) {
        if(isNullOrEmpty(account)) {
            return;
        }
        authedClients.remove(account);
    }

    public void authenticate(AuthClient client, String username, String password) {
        if(!isValidUserName(username)) {
            client.close(REASON_ACCOUNT_INFO_INCORR);
            LOGIN_HISTORY.debug(""Invalid Username"");
            return;
        }

        var account = getDAO(AccountDAO.class).findById(username);
        if(nonNull(account)) {
           verifyAccountInfo(client, account, password);
        } else if(isAutoCreateAccount()) {
            createNewAccount(client, username, password);
        } else {
            LOGIN_HISTORY.debug(""Username no found"");
            client.close(REASON_ACCOUNT_INFO_INCORR);
        }
    }

    private void verifyAccountInfo(AuthClient client, Account account, String password) {
        try {
            if(hash(password).equals(account.getPassword())) {
                if(account.isBanned()) {
                    client.close(REASON_PERMANENTLY_BANNED);
                    LOGIN_HISTORY.info(ACCOUNT_LOGIN_FAILED, account.getLogin(), ""Banned Account"");
                } else if( verifyAccountInUse(account)) {
                    client.close(REASON_ACCOUNT_IN_USE);
                    LOGIN_HISTORY.info(ACCOUNT_LOGIN_FAILED, account.getLogin(), ""Account Already In Use"");
                } else {
                    processAuth(client, account);
                }
            } else {
                client.close(REASON_ACCOUNT_INFO_INCORR);
                addLoginFailed(account, password, client);
                LOGIN_HISTORY.info(ACCOUNT_LOGIN_FAILED, account.getLogin(), ""Wrong Username or Password"");
            }
        } catch (NoSuchAlgorithmException e) {
            LOGGER.error(e.getMessage(), e);
            client.close(REASON_SYSTEM_ERROR);
        }
    }

    private boolean verifyAccountInUse(Account account) {
        var result = false;
        var authedClient = authedClients.get(account.getLogin());
        if(nonNull(authedClient)) {
            authedClient.close(REASON_ACCOUNT_IN_USE);
            removeAuthedClient(account.getLogin());
            result = true;
        }

        for (var gameServer : GameServerManager.getInstance().getRegisteredGameServers().values()) {
            if(nonNull(gameServer) && gameServer.isAccountInUse(account.getLogin())) {
                gameServer.disconnectAccount(account.getLogin());
                result = true;
            }
        }
        return result;
    }

    private void processAuth(AuthClient client, Account account) {
        updateClientInfo(client, account);
        requestAccountInfo(client, account);
        if(client.getRequestedServersInfo() == 0) {
            client.sendPacket(new LoginOk());
        }
        bruteForceProtection.remove(account.getLogin());
        LOGIN_HISTORY.info(""Account Logged {}"", account.getLogin());
    }

    private void requestAccountInfo(AuthClient client, Account account) {
        var gameservers = GameServerManager.getInstance().getRegisteredGameServers().values().stream().filter(ServerInfo::isAuthed).toList();
        client.setRequestedServerInfo(gameservers.size());
        gameservers.forEach(gameServer -> gameServer.requestAccountInfo(account.getLogin()));
    }

    private void updateClientInfo(AuthClient client, Account account) {
        client.setAccount(account);
        assignSessionKeyToClient(client);
        client.setState(AUTHED_LOGIN);
        account.setLastAccess(currentTimeMillis());
        account.setLastIP(client.getHostAddress());
        getDAO(AccountDAO.class).updateAccess(account.getLogin(), account.getLastAccess(), client.getHostAddress());
    }

    private void createNewAccount(AuthClient client, String username, String password) {
        try {
            var account = new Account(username, hash(password), currentTimeMillis(), client.getHostAddress());
            getDAO(AccountDAO.class).save(account);
            processAuth(client, account);
        } catch (NoSuchAlgorithmException e) {
            LOGGER.error(e.getMessage(), e);
        }
    }

    public void addAccountCharactersInfo(int serverId, String account, int players) {
        AuthClient client = authedClients.get(account);
        if (nonNull(client)) {
            client.addCharactersOnServer(serverId, players);
            if(client.getCharactersOnServer().size() == client.getRequestedServersInfo()) {
                client.sendPacket(new LoginOk());
            }
        }
    }

    public SessionKey getKeyForAccount(String account) {
        AuthClient client = authedClients.get(account);
        if (nonNull(client)) {
            return client.getSessionKey();
        }
        return null;
    }

    public boolean isLoginPossible(AuthClient client, int serverId) {
        var gsi = GameServerManager.getInstance().getRegisteredGameServerById(serverId);
        int access = client.getAccessLevel();
        if (nonNull(gsi) && gsi.isAuthed()) {
            boolean loginOk = ((gsi.onlineAccounts() < gsi.maxAccounts()) && (gsi.status() != ServerStatus.STATUS_GM_ONLY)) || (access >= AuthServerSettings.gmMinimumLevel());

            if (loginOk && (client.getLastServer() != serverId)) {
                if(getDAO(AccountDAO.class).updateLastServer(client.getAccount().getLogin(), serverId) < 1) {
                    LOGGER.warn(""Could not set lastServer of account {} "", client.getAccount().getLogin());
                }
            }
            return loginOk;
        }
        return false;
    }

    public void setAccountAccessLevel(String login, short accessLevel) {
        if(getDAO(AccountDAO.class).updateAccessLevel(login, accessLevel) < 1) {
            LOGGER.warn(""Could not set accessLevel of account {}"", login);
        }
    }

    private void addLoginFailed(Account account, String password, AuthClient client) {
        FailedLoginAttempt failedAttempt = bruteForceProtection.get(account.getLogin());
        if(nonNull(failedAttempt)) {
            failedAttempt.increaseCounter(password);
        } else {
            failedAttempt = new FailedLoginAttempt(password);
            bruteForceProtection.put(account.getLogin(), failedAttempt);
        }

        if(failedAttempt.getCount() >= authTriesBeforeBan())  {
            LOGGER.info(""Banning {} for {} seconds due to {} invalid user/pass attempts"", client.getHostAddress(), loginBlockAfterBan(), failedAttempt.getCount());
            banManager.addBannedAdress(client.getHostAddress(), currentTimeMillis() + loginBlockAfterBan() * 1000L);
        }
    }

    private ScrambledKeyPair getScrambledRSAKeyPair() {
        return _keyPairs[Rnd.get(10)];
    }

    private byte[] getBlowfishKey() {
        return blowfishKeysGenerator.generateKey().getEncoded();
    }

    private boolean isValidUserName(String username) {
        return USERNAME_PATTERN.matcher(username).matches();
    }

    public boolean isBannedAddress(String address) {
        return banManager.isBanned(address);
    }

    public static AuthController getInstance() {
        return Singleton.INSTANCE;
    }

    public int getKey() {
        return key;
    }

    private static class Singleton {
        private static final AuthController INSTANCE = new AuthController();
    }

    private static class FailedLoginAttempt {

        private int _count = 1;
        private long _lastAttempTime;
        private String _lastPassword;

        FailedLoginAttempt(String lastPassword) {
            _lastAttempTime = currentTimeMillis();
            _lastPassword = lastPassword;
        }

        void increaseCounter(String password) {
            if (!_lastPassword.equals(password)) {
                // check if theres a long time since last wrong try
                if ((currentTimeMillis() - _lastAttempTime) < (300 * 1000)) {
                    _count++;
                } else {
                    _count = 1;

                }
                _lastPassword = password;
            }
            _lastAttempTime = currentTimeMillis();
        }

        int getCount() {
            return _count;
        }
    }

    private class PurgeThread implements Runnable{
        @Override
        public void run() {
            synchronized (authedClients) {
                var entries = authedClients.entrySet().iterator();
                while (entries.hasNext()) {
                    var entry = entries.next();
                    var client = entry.getValue();

                    if(!client.isJoinedGameSever() && client.getConnectionStartTime() + TimeUnit.MINUTES.toMillis(LOGIN_TIMEOUT) <= currentTimeMillis() || !client.isConnected()) {
                        client.close(REASON_ACCESS_FAILED_TRYA1);
                        entries.remove();
                    }
                }

                if(authedClients.isEmpty()) {
                    scheduledPurge.cancel(false);
                }
            }
        }
    }
}",1,439 334 2000 123 437 457 381 2001 2002 61 2003 46 2004 40 2000 46 334 41 59 437 457 381 2001 2005 61 2003 46 2004 40 648 41 59 437 457 381 404 2006 61 1502 59 437 457 381 2007 2008 61 2007 46 2009 40 2010 40 41 41 59 437 457 381 2011 2012 61 648 59 437 381 2013 60 2011 44 2014 62 2015 61 418 2016 60 62 40 41 59 437 381 2013 60 2011 44 2017 62 2018 61 418 2019 60 62 40 41 59 437 381 2020 2021 59 437 381 404 2022 59 437 2023 2024 59 437 2025 60 63 62 2026 59 437 2027 91 93 2028 59 437 2000 40 41 123 2021 61 2020 46 2029 40 41 59 474 123 2030 40 41 59 125 329 40 2031 2032 41 123 2002 46 371 40 2032 46 2033 40 41 44 2032 41 59 125 2022 61 2034 46 2035 40 41 59 125 437 492 2036 40 41 470 2037 123 2002 46 2038 40 648 41 59 2024 61 2023 46 2039 40 648 41 59 2040 40 41 59 125 437 492 2041 40 41 470 2037 123 490 2042 61 2043 46 2044 40 648 41 59 490 2045 61 418 2046 40 1505 44 2046 46 2047 41 59 2042 46 2048 40 2045 41 59 2028 61 418 2027 91 1502 93 59 385 40 404 2049 61 1500 59 2049 60 1502 59 2049 637 41 123 2028 91 2049 93 61 418 2027 40 2042 46 2050 40 41 41 59 125 2002 46 2051 40 648 41 59 2052 40 40 2053 41 2028 91 1500 93 46 2054 40 41 46 2055 40 41 41 59 125 437 492 2056 40 2057 2022 41 470 2037 123 2058 2059 61 2058 46 2060 40 648 41 59 2059 46 2061 40 2058 46 2062 44 2022 41 59 125 439 492 2063 40 2014 2064 41 123 2064 46 2065 40 2066 40 41 41 59 490 2067 61 2068 40 41 59 2064 46 2069 40 2067 41 59 2064 46 2070 40 2071 46 2072 40 41 41 59 490 2073 61 418 2074 40 41 59 2073 46 2075 40 2067 41 59 2064 46 2076 40 2073 41 59 392 40 2077 40 2026 41 606 2026 46 2078 40 41 41 123 2026 61 2079 46 2080 40 418 2081 40 41 44 2006 44 2006 44 2082 46 2083 41 59 125 125 437 492 2084 40 2014 2064 41 123 490 2085 61 418 2086 40 2087 46 2088 40 41 44 467 46 2022 44 2087 46 2088 40 41 44 2087 46 2088 40 41 41 59 2064 46 2089 40 2085 41 59 2015 46 2090 40 2064 46 2091 40 41 46 2092 40 41 44 2064 41 59 125 439 492 2093 40 2011 2094 41 123 392 40 2095 40 2094 41 41 123 450 59 125 2015 46 2096 40 2094 41 59 125 439 492 2097 40 2014 2064 44 2011 2098 44 2011 2099 41 123 392 40 33 2100 40 2098 41 41 123 2064 46 2101 40 2102 41 59 2005 46 2103 40 648 41 59 450 59 125 490 2094 61 2104 40 2105 46 334 41 46 2106 40 2098 41 59 392 40 2107 40 2094 41 41 123 2108 40 2064 44 2094 44 2099 41 59 125 360 392 40 2109 40 41 41 123 2110 40 2064 44 2098 44 2099 41 59 125 360 123 2005 46 2111 40 648 41 59 2064 46 2112 40 2113 41 59 125 125 437 492 2114 40 2014 2064 44 2115 2094 44 2011 2099 41 123 474 123 392 40 2116 40 2099 41 46 2117 40 2094 46 2118 40 41 41 41 123 392 40 2094 46 2119 40 41 41 123 2064 46 2120 40 2121 41 59 2005 46 2122 40 2012 44 2094 46 2123 40 41 44 648 41 59 125 360 392 40 2124 40 2094 41 41 123 2064 46 2125 40 2126 41 59 2005 46 2127 40 2012 44 2094 46 2128 40 41 44 648 41 59 125 360 123 2129 40 2064 44 2094 41 59 125 125 360 123 2064 46 2130 40 2131 41 59 2132 40 2094 44 2099 44 2064 41 59 2005 46 2133 40 2012 44 2094 46 2134 40 41 44 648 41 59 125 125 329 40 2135 2136 41 123 2002 46 371 40 2136 46 2137 40 41 44 2136 41 59 2064 46 2138 40 2139 41 59 125 125 437 324 2140 40 2115 2094 41 123 490 2141 61 380 59 490 2142 61 2015 46 2143 40 2094 46 2144 40 41 41 59 392 40 2145 40 2142 41 41 123 2142 46 2146 40 2147 41 59 2093 40 2094 46 2144 40 41 41 59 2141 61 473 59 125 385 40 490 2148 58 2149 46 2150 40 41 46 2151 40 41 46 2152 40 41 41 123 392 40 2145 40 2148 41 605 2148 46 2153 40 2094 46 2144 40 41 41 41 123 2148 46 2154 40 2094 46 2144 40 41 41 59 2141 61 473 59 125 125 450 2141 59 125 437 492 2155 40 2014 2064 44 2115 2094 41 123 2156 40 2064 44 2094 41 59 2157 40 2064 44 2094 41 59 392 40 2064 46 2158 40 41 614 1500 41 123 2064 46 2159 40 418 2160 40 41 41 59 125 2018 46 2161 40 2094 46 2162 40 41 41 59 2005 46 2163 40 648 44 2094 46 2162 40 41 41 59 125 437 492 2164 40 2014 2064 44 2115 2094 41 123 490 2165 61 2166 46 2167 40 41 46 2168 40 41 46 2169 40 41 46 2170 40 41 46 2171 40 2172 58 58 2173 41 46 2174 40 41 59 2064 46 2175 40 2165 46 2176 40 41 41 59 2165 46 2177 40 2178 45 62 2178 46 2164 40 2094 46 2179 40 41 41 41 59 125 437 492 2180 40 2014 2064 44 2115 2094 41 123 2064 46 2181 40 2094 41 59 2084 40 2064 41 59 2064 46 2182 40 2183 41 59 2094 46 2184 40 2185 40 41 41 59 2094 46 2186 40 2064 46 2187 40 41 41 59 2188 40 2189 46 334 41 46 2190 40 2094 46 2191 40 41 44 2094 46 2192 40 41 44 2064 46 2187 40 41 41 59 125 437 492 2193 40 2014 2064 44 2011 2098 44 2011 2099 41 123 474 123 490 2094 61 418 2115 40 2098 44 2194 40 2099 41 44 2195 40 41 44 2064 46 2196 40 41 41 59 2197 40 2198 46 334 41 46 2199 40 2094 41 59 2155 40 2064 44 2094 41 59 125 329 40 2200 2201 41 123 2002 46 371 40 2201 46 2202 40 41 44 2201 41 59 125 125 439 492 2203 40 404 2204 44 2011 2094 44 404 2205 41 123 2014 2064 61 2015 46 2206 40 2094 41 59 392 40 2207 40 2064 41 41 123 2064 46 2208 40 2204 44 2205 41 59 392 40 2064 46 2209 40 41 46 2210 40 41 614 2064 46 2211 40 41 41 123 2064 46 2212 40 418 2213 40 41 41 59 125 125 125 439 2214 2215 40 2011 2094 41 123 2014 2064 61 2015 46 2216 40 2094 41 59 392 40 2217 40 2064 41 41 123 450 2064 46 2218 40 41 59 125 450 424 59 125 439 324 2219 40 2014 2064 44 404 2204 41 123 490 2220 61 2221 46 2222 40 41 46 2223 40 2204 41 59 404 2224 61 2064 46 2225 40 41 59 392 40 2226 40 2220 41 605 2220 46 2227 40 41 41 123 324 2228 61 40 40 2220 46 2229 40 41 60 2220 46 2230 40 41 41 605 40 2220 46 2231 40 41 631 2232 46 2233 41 41 606 40 2224 615 2234 46 2235 40 41 41 59 392 40 2228 605 40 2064 46 2236 40 41 631 2204 41 41 123 392 40 2237 40 2238 46 334 41 46 2239 40 2064 46 2240 40 41 46 2241 40 41 44 2204 41 60 1501 41 123 2002 46 2242 40 648 44 2064 46 2240 40 41 46 2241 40 41 41 59 125 125 450 2228 59 125 450 380 59 125 439 492 2243 40 2011 2244 44 453 2245 41 123 392 40 2246 40 2247 46 334 41 46 2248 40 2244 44 2245 41 60 1501 41 123 2002 46 2249 40 648 44 2244 41 59 125 125 437 492 2250 40 2115 2094 44 2011 2099 44 2014 2064 41 123 2017 2251 61 2018 46 2252 40 2094 46 2253 40 41 41 59 392 40 2254 40 2251 41 41 123 2251 46 2255 40 2099 41 59 125 360 123 2251 61 418 2017 40 2099 41 59 2018 46 2256 40 2094 46 2253 40 41 44 2251 41 59 125 392 40 2251 46 2257 40 41 615 2258 40 41 41 123 2002 46 2259 40 648 44 2064 46 2260 40 41 44 2261 40 41 44 2251 46 2257 40 41 41 59 2021 46 2262 40 2064 46 2260 40 41 44 2263 40 41 43 2261 40 41 42 1504 41 59 125 125 437 2027 2264 40 41 123 450 2028 91 2265 46 2266 40 1502 41 93 59 125 437 326 91 93 2267 40 41 123 450 2024 46 2268 40 41 46 2269 40 41 59 125 437 324 2270 40 2011 2098 41 123 450 2008 46 2271 40 2098 41 46 2272 40 41 59 125 439 324 2273 40 2011 2274 41 123 450 2021 46 2275 40 2274 41 59 125 439 457 2000 2276 40 41 123 450 2277 46 2278 59 125 439 404 2279 40 41 123 450 2022 59 125 437 457 334 2280 123 437 457 381 2000 2281 61 418 2000 40 41 59 125 437 457 334 2017 123 437 404 2282 61 1501 59 437 413 2283 59 437 2011 2284 59 2017 40 2011 2285 41 123 2283 61 2286 40 41 59 2284 61 2285 59 125 492 2287 40 2011 2099 41 123 392 40 33 2284 46 2288 40 2099 41 41 123 621 392 40 40 2289 40 41 45 2283 41 60 40 1504 42 1504 41 41 123 2282 637 59 125 360 123 2282 61 1501 59 125 2284 61 2099 59 125 2283 61 2290 40 41 59 125 404 2291 40 41 123 450 2282 59 125 125 437 334 2292 395 2293 123 64 2294 439 492 2295 40 41 123 465 40 2015 41 123 490 2296 61 2015 46 2297 40 41 46 2298 40 41 59 496 40 2296 46 2299 40 41 41 123 490 2300 61 2296 46 2301 40 41 59 490 2064 61 2300 46 2302 40 41 59 392 40 33 2064 46 2303 40 41 605 2064 46 2304 40 41 43 2305 46 2306 46 2307 40 2006 41 620 2308 40 41 606 33 2064 46 2309 40 41 41 123 2064 46 2310 40 2311 41 59 2296 46 2312 40 41 59 125 125 392 40 2015 46 2313 40 41 41 123 2026 46 2314 40 380 41 59 125 125 125 125 125 
30330,Java,"public class OnXJava7Style {
	@interface Foo {
		String value() default """";
	}
	@interface Bar {
		String stuff() default """";
	}
	@interface Array {
		String[] value() default {};
	}
	String a;
	String b;
	String c;
	String d;
	String e;
	String f;
	String g;
	String h;
	String i;
	@Foo
	@java.lang.SuppressWarnings(""all"")
	public String getA() {
		return this.a;
	}
	@Foo
	@java.lang.SuppressWarnings(""all"")
	public void setB(final String b) {
		this.b = b;
	}
	@java.lang.SuppressWarnings(""all"")
	public void setC(@Foo(""a"") final String c) {
		this.c = c;
	}
	@java.lang.SuppressWarnings(""all"")
	public void setD(@Bar(stuff = ""b"") final String d) {
		this.d = d;
	}
	@Foo(""c"")
	@Bar(stuff = ""d"")
	@java.lang.SuppressWarnings(""all"")
	public String getE() {
		return this.e;
	}
	@Array
	@java.lang.SuppressWarnings(""all"")
	public String getF() {
		return this.f;
	}

	@Array
	@java.lang.SuppressWarnings(""all"")
	public String getG() {
		return this.g;
	}

	@Array({})
	@java.lang.SuppressWarnings(""all"")
	public String getH() {
		return this.h;
	}

	@Array({""a"", ""b""})
	@java.lang.SuppressWarnings(""all"")
	public String getI() {
		return this.i;
	}
}",1,439 334 2000 123 64 405 2001 123 2002 2003 40 41 349 648 59 125 64 405 2004 123 2005 2006 40 41 349 648 59 125 64 405 2007 123 2008 91 93 2009 40 41 349 123 125 59 125 2010 2011 59 2010 2012 59 2010 2013 59 2010 2014 59 2010 2015 59 2010 2016 59 2010 2017 59 2010 2018 59 2010 2019 59 64 2001 64 2020 46 2021 46 2022 40 648 41 439 2010 2023 40 41 123 450 467 46 2011 59 125 64 2001 64 2020 46 2021 46 2022 40 648 41 439 492 2024 40 381 2010 2012 41 123 467 46 2012 61 2012 59 125 64 2020 46 2021 46 2022 40 648 41 439 492 2025 40 64 2001 40 648 41 381 2010 2013 41 123 467 46 2013 61 2013 59 125 64 2020 46 2021 46 2022 40 648 41 439 492 2026 40 64 2004 40 2027 61 648 41 381 2010 2014 41 123 467 46 2014 61 2014 59 125 64 2001 40 648 41 64 2004 40 2027 61 648 41 64 2020 46 2021 46 2022 40 648 41 439 2010 2028 40 41 123 450 467 46 2015 59 125 64 2007 64 2020 46 2021 46 2022 40 648 41 439 2010 2029 40 41 123 450 467 46 2016 59 125 64 2007 64 2020 46 2021 46 2022 40 648 41 439 2010 2030 40 41 123 450 467 46 2017 59 125 64 2007 40 123 125 41 64 2020 46 2021 46 2022 40 648 41 439 2010 2031 40 41 123 450 467 46 2018 59 125 64 2007 40 123 648 44 648 125 41 64 2020 46 2021 46 2022 40 648 41 439 2010 2032 40 41 123 450 467 46 2019 59 125 125 
33701,Java,"public class BDDMockitoTest extends TestBase {

    @Mock IMethods mock;

    @Test
    public void should_stub() throws Exception {
        given(mock.simpleMethod(""foo"")).willReturn(""bar"");

        Assertions.assertThat(mock.simpleMethod(""foo"")).isEqualTo(""bar"");
        Assertions.assertThat(mock.simpleMethod(""whatever"")).isEqualTo(null);
    }

    @Test
    public void should_stub_with_throwable() throws Exception {
        given(mock.simpleMethod(""foo"")).willThrow(new SomethingWasWrong());

        try {
            Assertions.assertThat(mock.simpleMethod(""foo"")).isEqualTo(""foo"");
            fail();
        } catch (SomethingWasWrong expected) {
        }
    }

    @Test
    public void should_stub_with_throwable_class() throws Exception {
        given(mock.simpleMethod(""foo"")).willThrow(SomethingWasWrong.class);

        try {
            Assertions.assertThat(mock.simpleMethod(""foo"")).isEqualTo(""foo"");
            fail();
        } catch (SomethingWasWrong expected) {
        }
    }

    @Test
    @SuppressWarnings(""unchecked"")
    public void should_stub_with_throwable_classes() throws Exception {
        // unavoidable 'unchecked generic array creation' warning (from JDK7 onward)
        given(mock.simpleMethod(""foo""))
                .willThrow(SomethingWasWrong.class, AnotherThingWasWrong.class);

        try {
            Assertions.assertThat(mock.simpleMethod(""foo"")).isEqualTo(""foo"");
            fail();
        } catch (SomethingWasWrong expected) {
        }
    }

    @Test
    public void should_stub_with_answer() throws Exception {
        given(mock.simpleMethod(anyString()))
                .willAnswer(
                        new Answer<String>() {
                            public String answer(InvocationOnMock invocation) throws Throwable {
                                return invocation.getArgument(0);
                            }
                        });

        Assertions.assertThat(mock.simpleMethod(""foo"")).isEqualTo(""foo"");
    }

    @Test
    public void should_stub_with_will_answer_alias() throws Exception {
        given(mock.simpleMethod(anyString()))
                .will(
                        new Answer<String>() {
                            public String answer(InvocationOnMock invocation) throws Throwable {
                                return invocation.getArgument(0);
                            }
                        });

        Assertions.assertThat(mock.simpleMethod(""foo"")).isEqualTo(""foo"");
    }

    @Test
    public void should_stub_consecutively() throws Exception {
        given(mock.simpleMethod(anyString())).willReturn(""foo"").willReturn(""bar"");

        Assertions.assertThat(mock.simpleMethod(""whatever"")).isEqualTo(""foo"");
        Assertions.assertThat(mock.simpleMethod(""whatever"")).isEqualTo(""bar"");
    }

    @Test
    public void should_return_consecutively() throws Exception {
        given(mock.objectReturningMethodNoArgs()).willReturn(""foo"", ""bar"", 12L, new byte[0]);

        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(""foo"");
        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(""bar"");
        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(12L);
        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(new byte[0]);
    }

    @Test
    public void should_stub_consecutively_with_call_real_method() throws Exception {
        MethodsImpl mock = mock(MethodsImpl.class);
        willReturn(""foo"").willCallRealMethod().given(mock).simpleMethod();

        Assertions.assertThat(mock.simpleMethod()).isEqualTo(""foo"");
        Assertions.assertThat(mock.simpleMethod()).isEqualTo(null);
    }

    @Test
    public void should_stub_void() throws Exception {
        willThrow(new SomethingWasWrong()).given(mock).voidMethod();

        try {
            mock.voidMethod();
            fail();
        } catch (SomethingWasWrong expected) {
        }
    }

    @Test
    public void should_stub_void_with_exception_class() throws Exception {
        willThrow(SomethingWasWrong.class).given(mock).voidMethod();

        try {
            mock.voidMethod();
            fail();
        } catch (SomethingWasWrong expected) {
        }
    }

    @Test
    @SuppressWarnings(""unchecked"")
    public void should_stub_void_with_exception_classes() throws Exception {
        willThrow(SomethingWasWrong.class, AnotherThingWasWrong.class).given(mock).voidMethod();

        try {
            mock.voidMethod();
            fail();
        } catch (SomethingWasWrong expected) {
        }
    }

    @Test
    public void should_stub_void_consecutively() throws Exception {
        willDoNothing().willThrow(new SomethingWasWrong()).given(mock).voidMethod();

        mock.voidMethod();
        try {
            mock.voidMethod();
            fail();
        } catch (SomethingWasWrong expected) {
        }
    }

    @Test
    public void should_stub_void_consecutively_with_exception_class() throws Exception {
        willDoNothing().willThrow(SomethingWasWrong.class).given(mock).voidMethod();

        mock.voidMethod();
        try {
            mock.voidMethod();
            fail();
        } catch (SomethingWasWrong expected) {
        }
    }

    @Test
    public void should_stub_using_do_return_style() throws Exception {
        willReturn(""foo"").given(mock).simpleMethod(""bar"");

        Assertions.assertThat(mock.simpleMethod(""boooo"")).isEqualTo(null);
        Assertions.assertThat(mock.simpleMethod(""bar"")).isEqualTo(""foo"");
    }

    @Test
    public void should_stub_using_do_answer_style() throws Exception {
        willAnswer(
                        new Answer<String>() {
                            public String answer(InvocationOnMock invocation) throws Throwable {
                                return invocation.getArgument(0);
                            }
                        })
                .given(mock)
                .simpleMethod(anyString());

        Assertions.assertThat(mock.simpleMethod(""foo"")).isEqualTo(""foo"");
    }

    @Test
    public void should_stub_by_delegating_to_real_method() throws Exception {
        // given
        Dog dog = mock(Dog.class);
        // when
        willCallRealMethod().given(dog).bark();
        // then
        Assertions.assertThat(dog.bark()).isEqualTo(""woof"");
    }

    @Test
    public void should_stub_by_delegating_to_real_method_using_typical_stubbing_syntax()
            throws Exception {
        // given
        Dog dog = mock(Dog.class);
        // when
        given(dog.bark()).willCallRealMethod();
        // then
        Assertions.assertThat(dog.bark()).isEqualTo(""woof"");
    }

    @Test
    public void should_all_stubbed_mock_reference_access() throws Exception {
        Set<?> expectedMock = mock(Set.class);

        Set<?> returnedMock = given(expectedMock.isEmpty()).willReturn(false).getMock();

        Assertions.assertThat(returnedMock).isEqualTo(expectedMock);
    }

    @Test(expected = NotAMockException.class)
    public void should_validate_mock_when_verifying() {
        then(""notMock"").should();
    }

    @Test(expected = NotAMockException.class)
    public void should_validate_mock_when_verifying_with_expected_number_of_invocations() {
        then(""notMock"").should(times(19));
    }

    @Test(expected = NotAMockException.class)
    public void should_validate_mock_when_verifying_no_more_interactions() {
        then(""notMock"").should();
    }

    @Test(expected = WantedButNotInvoked.class)
    public void should_fail_for_expected_behavior_that_did_not_happen() {
        then(mock).should().booleanObjectReturningMethod();
    }

    @Test
    public void should_pass_for_expected_behavior_that_happened() {
        mock.booleanObjectReturningMethod();

        then(mock).should().booleanObjectReturningMethod();
        then(mock).shouldHaveNoMoreInteractions();
    }

    @Test
    public void should_validate_that_mock_had_no_interactions() {
        then(mock).shouldHaveNoInteractions();
    }

    @Test
    public void should_fail_when_mock_had_more_interactions_than_expected() {
        mock.booleanObjectReturningMethod();
        mock.byteObjectReturningMethod();

        then(mock).should().booleanObjectReturningMethod();
        try {
            then(mock).shouldHaveNoMoreInteractions();
            fail(""should have reported that no more interactions were wanted"");
        } catch (NoInteractionsWanted expected) {
        }
    }

    @Test
    public void should_pass_for_interactions_that_happened_in_correct_order() {
        mock.booleanObjectReturningMethod();
        mock.arrayReturningMethod();

        InOrder inOrder = inOrder(mock);
        then(mock).should(inOrder).booleanObjectReturningMethod();
        then(mock).should(inOrder).arrayReturningMethod();
    }

    @Test
    public void should_fail_for_interactions_that_were_in_wrong_order() {
        InOrder inOrder = inOrder(mock);

        mock.arrayReturningMethod();
        mock.booleanObjectReturningMethod();

        then(mock).should(inOrder).booleanObjectReturningMethod();
        try {
            then(mock).should(inOrder).arrayReturningMethod();
            fail(""should have raise in order verification failure on second verify call"");
        } catch (VerificationInOrderFailure expected) {
        }
    }

    @Test(expected = WantedButNotInvoked.class)
    public void should_fail_when_checking_order_of_interactions_that_did_not_happen() {
        then(mock).should(inOrder(mock)).booleanObjectReturningMethod();
    }

    @Test
    public void should_pass_fluent_bdd_scenario() {
        Bike bike = new Bike();
        Person person = mock(Person.class);
        Police police = mock(Police.class);

        person.ride(bike);
        person.ride(bike);

        then(person).should(times(2)).ride(bike);
        then(police).shouldHaveNoInteractions();
    }

    @Test
    public void should_pass_fluent_bdd_scenario_with_ordered_verification() {
        Bike bike = new Bike();
        Car car = new Car();
        Person person = mock(Person.class);

        person.drive(car);
        person.ride(bike);
        person.ride(bike);

        InOrder inOrder = inOrder(person);
        then(person).should(inOrder).drive(car);
        then(person).should(inOrder, times(2)).ride(bike);
    }

    @Test
    public void should_pass_fluent_bdd_scenario_with_ordered_verification_for_two_mocks() {
        Car car = new Car();
        Person person = mock(Person.class);
        Police police = mock(Police.class);

        person.drive(car);
        person.drive(car);
        police.chase(car);

        InOrder inOrder = inOrder(person, police);
        then(person).should(inOrder, times(2)).drive(car);
        then(police).should(inOrder).chase(car);
    }

    static class Person {

        void ride(Bike bike) {}

        void drive(Car car) {}
    }

    static class Bike {}

    static class Car {}

    static class Police {

        void chase(Car car) {}
    }

    class Dog {

        public String bark() {
            return ""woof"";
        }
    }

    private class SomethingWasWrong extends RuntimeException {}

    private class AnotherThingWasWrong extends RuntimeException {}
}",1,439 334 2000 378 2001 123 64 2002 2003 2004 59 64 2005 439 492 2006 40 41 470 2007 123 2008 40 2004 46 2009 40 648 41 41 46 2010 40 648 41 59 2011 46 2012 40 2004 46 2009 40 648 41 41 46 2013 40 648 41 59 2011 46 2012 40 2004 46 2009 40 648 41 41 46 2013 40 424 41 59 125 64 2005 439 492 2014 40 41 470 2007 123 2015 40 2004 46 2016 40 648 41 41 46 2017 40 418 2018 40 41 41 59 474 123 2019 46 2020 40 2004 46 2016 40 648 41 41 46 2021 40 648 41 59 2022 40 41 59 125 329 40 2018 2023 41 123 125 125 64 2005 439 492 2024 40 41 470 2007 123 2025 40 2004 46 2026 40 648 41 41 46 2027 40 2028 46 334 41 59 474 123 2029 46 2030 40 2004 46 2026 40 648 41 41 46 2031 40 648 41 59 2032 40 41 59 125 329 40 2028 2033 41 123 125 125 64 2005 64 2034 40 648 41 439 492 2035 40 41 470 2007 123 621 2036 40 2004 46 2037 40 648 41 41 46 2038 40 2039 46 334 44 2040 46 334 41 59 474 123 2041 46 2042 40 2004 46 2037 40 648 41 41 46 2043 40 648 41 59 2044 40 41 59 125 329 40 2039 2045 41 123 125 125 64 2005 439 492 2046 40 41 470 2007 123 2047 40 2004 46 2048 40 2049 40 41 41 41 46 2050 40 418 2051 60 2052 62 40 41 123 439 2052 2053 40 2054 2055 41 470 2056 123 450 2055 46 2057 40 1500 41 59 125 125 41 59 2058 46 2059 40 2004 46 2048 40 648 41 41 46 2060 40 648 41 59 125 64 2005 439 492 2061 40 41 470 2007 123 2062 40 2004 46 2063 40 2064 40 41 41 41 46 2065 40 418 2066 60 2067 62 40 41 123 439 2067 2068 40 2069 2070 41 470 2071 123 450 2070 46 2072 40 1500 41 59 125 125 41 59 2073 46 2074 40 2004 46 2063 40 648 41 41 46 2075 40 648 41 59 125 64 2005 439 492 2076 40 41 470 2007 123 2077 40 2004 46 2078 40 2079 40 41 41 41 46 2080 40 648 41 46 2080 40 648 41 59 2081 46 2082 40 2004 46 2078 40 648 41 41 46 2083 40 648 41 59 2081 46 2082 40 2004 46 2078 40 648 41 41 46 2083 40 648 41 59 125 64 2005 439 492 2084 40 41 470 2007 123 2085 40 2004 46 2086 40 41 41 46 2087 40 648 44 648 44 1503 44 418 326 91 1500 93 41 59 2088 46 2089 40 2004 46 2086 40 41 41 46 2090 40 648 41 59 2088 46 2089 40 2004 46 2086 40 41 41 46 2090 40 648 41 59 2088 46 2089 40 2004 46 2086 40 41 41 46 2090 40 1503 41 59 2088 46 2089 40 2004 46 2086 40 41 41 46 2090 40 418 326 91 1500 93 41 59 125 64 2005 439 492 2091 40 41 470 2007 123 2092 2004 61 2004 40 2092 46 334 41 59 2093 40 648 41 46 2094 40 41 46 2095 40 2004 41 46 2096 40 41 59 2097 46 2098 40 2004 46 2096 40 41 41 46 2099 40 648 41 59 2097 46 2098 40 2004 46 2096 40 41 41 46 2099 40 424 41 59 125 64 2005 439 492 2100 40 41 470 2007 123 2101 40 418 2102 40 41 41 46 2103 40 2004 41 46 2104 40 41 59 474 123 2004 46 2104 40 41 59 2105 40 41 59 125 329 40 2102 2106 41 123 125 125 64 2005 439 492 2107 40 41 470 2007 123 2108 40 2109 46 334 41 46 2110 40 2004 41 46 2111 40 41 59 474 123 2004 46 2111 40 41 59 2112 40 41 59 125 329 40 2109 2113 41 123 125 125 64 2005 64 2034 40 648 41 439 492 2114 40 41 470 2007 123 2115 40 2116 46 334 44 2117 46 334 41 46 2118 40 2004 41 46 2119 40 41 59 474 123 2004 46 2119 40 41 59 2120 40 41 59 125 329 40 2116 2121 41 123 125 125 64 2005 439 492 2122 40 41 470 2007 123 2123 40 41 46 2124 40 418 2125 40 41 41 46 2126 40 2004 41 46 2127 40 41 59 2004 46 2127 40 41 59 474 123 2004 46 2127 40 41 59 2128 40 41 59 125 329 40 2125 2129 41 123 125 125 64 2005 439 492 2130 40 41 470 2007 123 2131 40 41 46 2132 40 2133 46 334 41 46 2134 40 2004 41 46 2135 40 41 59 2004 46 2135 40 41 59 474 123 2004 46 2135 40 41 59 2136 40 41 59 125 329 40 2133 2137 41 123 125 125 64 2005 439 492 2138 40 41 470 2007 123 2139 40 648 41 46 2140 40 2004 41 46 2141 40 648 41 59 2142 46 2143 40 2004 46 2141 40 648 41 41 46 2144 40 424 41 59 2142 46 2143 40 2004 46 2141 40 648 41 41 46 2144 40 648 41 59 125 64 2005 439 492 2145 40 41 470 2007 123 2146 40 418 2147 60 2148 62 40 41 123 439 2148 2149 40 2150 2151 41 470 2152 123 450 2151 46 2153 40 1500 41 59 125 125 41 46 2154 40 2004 41 46 2155 40 2156 40 41 41 59 2157 46 2158 40 2004 46 2155 40 648 41 41 46 2159 40 648 41 59 125 64 2005 439 492 2160 40 41 470 2007 123 621 2161 2162 61 2004 40 2161 46 334 41 59 621 2163 40 41 46 2164 40 2162 41 46 2165 40 41 59 621 2166 46 2167 40 2162 46 2165 40 41 41 46 2168 40 648 41 59 125 64 2005 439 492 2169 40 41 470 2007 123 621 2170 2171 61 2004 40 2170 46 334 41 59 621 2172 40 2171 46 2173 40 41 41 46 2174 40 41 59 621 2175 46 2176 40 2171 46 2173 40 41 41 46 2177 40 648 41 59 125 64 2005 439 492 2178 40 41 470 2007 123 2179 60 63 62 2180 61 2004 40 2179 46 334 41 59 2179 60 63 62 2181 61 2182 40 2180 46 2183 40 41 41 46 2184 40 380 41 46 2185 40 41 59 2186 46 2187 40 2181 41 46 2188 40 2180 41 59 125 64 2005 40 2189 61 2190 46 334 41 439 492 2191 40 41 123 2192 40 648 41 46 2193 40 41 59 125 64 2005 40 2189 61 2190 46 334 41 439 492 2194 40 41 123 2195 40 648 41 46 2196 40 2197 40 1503 41 41 59 125 64 2005 40 2189 61 2190 46 334 41 439 492 2198 40 41 123 2199 40 648 41 46 2200 40 41 59 125 64 2005 40 2189 61 2201 46 334 41 439 492 2202 40 41 123 2203 40 2004 41 46 2204 40 41 46 2205 40 41 59 125 64 2005 439 492 2206 40 41 123 2004 46 2207 40 41 59 2208 40 2004 41 46 2209 40 41 46 2207 40 41 59 2208 40 2004 41 46 2210 40 41 59 125 64 2005 439 492 2211 40 41 123 2212 40 2004 41 46 2213 40 41 59 125 64 2005 439 492 2214 40 41 123 2004 46 2215 40 41 59 2004 46 2216 40 41 59 2217 40 2004 41 46 2218 40 41 46 2215 40 41 59 474 123 2217 40 2004 41 46 2219 40 41 59 2220 40 648 41 59 125 329 40 2221 2189 41 123 125 125 64 2005 439 492 2222 40 41 123 2004 46 2223 40 41 59 2004 46 2224 40 41 59 2225 2226 61 2226 40 2004 41 59 2227 40 2004 41 46 2228 40 2226 41 46 2223 40 41 59 2227 40 2004 41 46 2228 40 2226 41 46 2224 40 41 59 125 64 2005 439 492 2229 40 41 123 2230 2231 61 2231 40 2004 41 59 2004 46 2232 40 41 59 2004 46 2233 40 41 59 2234 40 2004 41 46 2235 40 2231 41 46 2233 40 41 59 474 123 2234 40 2004 41 46 2235 40 2231 41 46 2232 40 41 59 2236 40 648 41 59 125 329 40 2237 2189 41 123 125 125 64 2005 40 2189 61 2201 46 334 41 439 492 2238 40 41 123 2239 40 2004 41 46 2240 40 2241 40 2004 41 41 46 2242 40 41 59 125 64 2005 439 492 2243 40 41 123 2244 2245 61 418 2244 40 41 59 2246 2247 61 2004 40 2246 46 334 41 59 2248 2249 61 2004 40 2248 46 334 41 59 2247 46 2250 40 2245 41 59 2247 46 2250 40 2245 41 59 2251 40 2247 41 46 2252 40 2253 40 1502 41 41 46 2250 40 2245 41 59 2251 40 2249 41 46 2254 40 41 59 125 64 2005 439 492 2255 40 41 123 2256 2257 61 418 2256 40 41 59 2258 2259 61 418 2258 40 41 59 2260 2261 61 2004 40 2260 46 334 41 59 2261 46 2262 40 2259 41 59 2261 46 2263 40 2257 41 59 2261 46 2263 40 2257 41 59 2264 2265 61 2265 40 2261 41 59 2266 40 2261 41 46 2267 40 2265 41 46 2262 40 2259 41 59 2266 40 2261 41 46 2267 40 2265 44 2268 40 1502 41 41 46 2263 40 2257 41 59 125 64 2005 439 492 2269 40 41 123 2270 2271 61 418 2270 40 41 59 2272 2273 61 2004 40 2272 46 334 41 59 2274 2275 61 2004 40 2274 46 334 41 59 2273 46 2276 40 2271 41 59 2273 46 2276 40 2271 41 59 2275 46 2277 40 2271 41 59 2278 2279 61 2279 40 2273 44 2275 41 59 2280 40 2273 41 46 2281 40 2279 44 2282 40 1502 41 41 46 2276 40 2271 41 59 2280 40 2275 41 46 2281 40 2279 41 46 2277 40 2271 41 59 125 457 334 2283 123 492 2284 40 2285 2286 41 123 125 492 2287 40 2288 2289 41 123 125 125 457 334 2290 123 125 457 334 2291 123 125 457 334 2292 123 492 2293 40 2291 2294 41 123 125 125 334 2295 123 439 2296 2297 40 41 123 450 648 59 125 125 437 334 2298 378 2299 123 125 437 334 2300 378 2299 123 125 125 
32610,Java,"@SuppressWarnings(""unchecked"")
public class MockitoCore {

    private static final DoNotMockEnforcer DO_NOT_MOCK_ENFORCER = Plugins.getDoNotMockEnforcer();
    private static final Set<Class<?>> MOCKABLE_CLASSES =
            Collections.synchronizedSet(new HashSet<>());

    public boolean isTypeMockable(Class<?> typeToMock) {
        return typeMockabilityOf(typeToMock).mockable();
    }

    public <T> T mock(Class<T> typeToMock, MockSettings settings) {
        if (!(settings instanceof MockSettingsImpl)) {
            throw new IllegalArgumentException(
                    ""Unexpected implementation of '""
                            + settings.getClass().getCanonicalName()
                            + ""'\n""
                            + ""At the moment, you cannot provide your own implementations of that class."");
        }
        MockSettingsImpl impl = (MockSettingsImpl) settings;
        MockCreationSettings<T> creationSettings = impl.build(typeToMock);
        checkDoNotMockAnnotation(creationSettings.getTypeToMock(), creationSettings);
        T mock = createMock(creationSettings);
        mockingProgress().mockingStarted(mock, creationSettings);
        return mock;
    }

    private void checkDoNotMockAnnotation(
            Class<?> typeToMock, MockCreationSettings<?> creationSettings) {
        checkDoNotMockAnnotationForType(typeToMock);
        for (Class<?> aClass : creationSettings.getExtraInterfaces()) {
            checkDoNotMockAnnotationForType(aClass);
        }
    }

    private static void checkDoNotMockAnnotationForType(Class<?> type) {
        // Object and interfaces do not have a super class
        if (type == null) {
            return;
        }

        if (MOCKABLE_CLASSES.contains(type)) {
            return;
        }

        String warning = DO_NOT_MOCK_ENFORCER.checkTypeForDoNotMockViolation(type);
        if (warning != null) {
            throw new DoNotMockException(warning);
        }

        checkDoNotMockAnnotationForType(type.getSuperclass());
        for (Class<?> aClass : type.getInterfaces()) {
            checkDoNotMockAnnotationForType(aClass);
        }

        MOCKABLE_CLASSES.add(type);
    }

    public <T> MockedStatic<T> mockStatic(Class<T> classToMock, MockSettings settings) {
        if (!MockSettingsImpl.class.isInstance(settings)) {
            throw new IllegalArgumentException(
                    ""Unexpected implementation of '""
                            + settings.getClass().getCanonicalName()
                            + ""'\n""
                            + ""At the moment, you cannot provide your own implementations of that class."");
        }
        MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);
        MockCreationSettings<T> creationSettings = impl.buildStatic(classToMock);
        MockMaker.StaticMockControl<T> control = createStaticMock(classToMock, creationSettings);
        control.enable();
        mockingProgress().mockingStarted(classToMock, creationSettings);
        return new MockedStaticImpl<>(control);
    }

    public <T> MockedConstruction<T> mockConstruction(
            Class<T> typeToMock,
            Function<MockedConstruction.Context, ? extends MockSettings> settingsFactory,
            MockedConstruction.MockInitializer<T> mockInitializer) {
        Function<MockedConstruction.Context, MockCreationSettings<T>> creationSettings =
                context -> {
                    MockSettings value = settingsFactory.apply(context);
                    if (!MockSettingsImpl.class.isInstance(value)) {
                        throw new IllegalArgumentException(
                                ""Unexpected implementation of '""
                                        + value.getClass().getCanonicalName()
                                        + ""'\n""
                                        + ""At the moment, you cannot provide your own implementations of that class."");
                    }
                    MockSettingsImpl impl = MockSettingsImpl.class.cast(value);
                    return impl.build(typeToMock);
                };
        MockMaker.ConstructionMockControl<T> control =
                createConstructionMock(typeToMock, creationSettings, mockInitializer);
        control.enable();
        return new MockedConstructionImpl<>(control);
    }

    public <T> OngoingStubbing<T> when(T methodCall) {
        MockingProgress mockingProgress = mockingProgress();
        mockingProgress.stubbingStarted();
        @SuppressWarnings(""unchecked"")
        OngoingStubbing<T> stubbing = (OngoingStubbing<T>) mockingProgress.pullOngoingStubbing();
        if (stubbing == null) {
            mockingProgress.reset();
            throw missingMethodInvocation();
        }
        return stubbing;
    }

    public <T> T verify(T mock, VerificationMode mode) {
        if (mock == null) {
            throw nullPassedToVerify();
        }
        MockingDetails mockingDetails = mockingDetails(mock);
        if (!mockingDetails.isMock()) {
            throw notAMockPassedToVerify(mock.getClass());
        }
        assertNotStubOnlyMock(mock);
        MockHandler handler = mockingDetails.getMockHandler();
        mock =
                (T)
                        VerificationStartedNotifier.notifyVerificationStarted(
                                handler.getMockSettings().getVerificationStartedListeners(),
                                mockingDetails);

        MockingProgress mockingProgress = mockingProgress();
        VerificationMode actualMode = mockingProgress.maybeVerifyLazily(mode);
        mockingProgress.verificationStarted(
                new MockAwareVerificationMode(
                        mock, actualMode, mockingProgress.verificationListeners()));
        return mock;
    }

    public <T> void reset(T... mocks) {
        MockingProgress mockingProgress = mockingProgress();
        mockingProgress.validateState();
        mockingProgress.reset();
        mockingProgress.resetOngoingStubbing();

        for (T m : mocks) {
            resetMock(m);
        }
    }

    public <T> void clearInvocations(T... mocks) {
        MockingProgress mockingProgress = mockingProgress();
        mockingProgress.validateState();
        mockingProgress.reset();
        mockingProgress.resetOngoingStubbing();

        for (T m : mocks) {
            getInvocationContainer(m).clearInvocations();
        }
    }

    public void verifyNoMoreInteractions(Object... mocks) {
        assertMocksNotEmpty(mocks);
        mockingProgress().validateState();
        for (Object mock : mocks) {
            try {
                if (mock == null) {
                    throw nullPassedToVerifyNoMoreInteractions();
                }
                InvocationContainerImpl invocations = getInvocationContainer(mock);
                assertNotStubOnlyMock(mock);
                VerificationDataImpl data = new VerificationDataImpl(invocations, null);
                noMoreInteractions().verify(data);
            } catch (NotAMockException e) {
                throw notAMockPassedToVerifyNoMoreInteractions();
            }
        }
    }

    public void verifyNoInteractions(Object... mocks) {
        assertMocksNotEmpty(mocks);
        mockingProgress().validateState();
        for (Object mock : mocks) {
            try {
                if (mock == null) {
                    throw nullPassedToVerifyNoMoreInteractions();
                }
                InvocationContainerImpl invocations = getInvocationContainer(mock);
                assertNotStubOnlyMock(mock);
                VerificationDataImpl data = new VerificationDataImpl(invocations, null);
                noInteractions().verify(data);
            } catch (NotAMockException e) {
                throw notAMockPassedToVerifyNoMoreInteractions();
            }
        }
    }

    public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext) {
        mockingProgress().validateState();
        VerificationDataInOrder data =
                new VerificationDataInOrderImpl(
                        inOrderContext, VerifiableInvocationsFinder.find(mocks), null);
        VerificationModeFactory.noMoreInteractions().verifyInOrder(data);
    }

    private void assertMocksNotEmpty(Object[] mocks) {
        if (mocks == null || mocks.length == 0) {
            throw mocksHaveToBePassedToVerifyNoMoreInteractions();
        }
    }

    private void assertNotStubOnlyMock(Object mock) {
        if (getMockHandler(mock).getMockSettings().isStubOnly()) {
            throw stubPassedToVerify(mock);
        }
    }

    public InOrder inOrder(Object... mocks) {
        if (mocks == null || mocks.length == 0) {
            throw mocksHaveToBePassedWhenCreatingInOrder();
        }
        for (Object mock : mocks) {
            if (mock == null) {
                throw nullPassedWhenCreatingInOrder();
            }
            if (!isMock(mock)) {
                throw notAMockPassedWhenCreatingInOrder();
            }
            assertNotStubOnlyMock(mock);
        }
        return new InOrderImpl(Arrays.asList(mocks));
    }

    public Stubber stubber() {
        return stubber(null);
    }

    public Stubber stubber(Strictness strictness) {
        MockingProgress mockingProgress = mockingProgress();
        mockingProgress.stubbingStarted();
        mockingProgress.resetOngoingStubbing();
        return new StubberImpl(strictness);
    }

    public void validateMockitoUsage() {
        mockingProgress().validateState();
    }

    /**
     * For testing purposes only. Is not the part of main API.
     *
     * @return last invocation
     */
    public Invocation getLastInvocation() {
        OngoingStubbingImpl ongoingStubbing =
                ((OngoingStubbingImpl) mockingProgress().pullOngoingStubbing());
        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();
        return allInvocations.get(allInvocations.size() - 1);
    }

    public Object[] ignoreStubs(Object... mocks) {
        for (Object m : mocks) {
            InvocationContainerImpl container = getInvocationContainer(m);
            List<Invocation> ins = container.getInvocations();
            for (Invocation in : ins) {
                if (in.stubInfo() != null) {
                    in.ignoreForVerification();
                }
            }
        }
        return mocks;
    }

    public MockingDetails mockingDetails(Object toInspect) {
        return new DefaultMockingDetails(toInspect);
    }

    public LenientStubber lenient() {
        return new DefaultLenientStubber();
    }

    public void clearAllCaches() {
        MockUtil.clearAllCaches();
    }
}",1,64 2000 40 648 41 439 334 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 41 59 437 457 381 2006 60 2007 60 63 641 2008 61 2009 46 2010 40 418 2011 60 62 40 41 41 59 439 324 2012 40 2007 60 63 62 2013 41 123 450 2014 40 2013 41 46 2015 40 41 59 125 439 60 2016 62 2016 2017 40 2007 60 2016 62 2013 44 2018 2019 41 123 392 40 33 40 2019 402 2020 41 41 123 469 418 2021 40 648 43 2019 46 2022 40 41 46 2023 40 41 43 648 43 648 41 59 125 2020 2024 61 40 2020 41 2019 59 2025 60 2016 62 2026 61 2024 46 2027 40 2013 41 59 2028 40 2026 46 2029 40 41 44 2026 41 59 2016 2017 61 2030 40 2026 41 59 2031 40 41 46 2032 40 2017 44 2026 41 59 450 2017 59 125 437 492 2033 40 2007 60 63 62 2013 44 2034 60 63 62 2035 41 123 2036 40 2013 41 59 385 40 2007 60 63 62 2037 58 2035 46 2038 40 41 41 123 2036 40 2037 41 59 125 125 437 457 492 2039 40 2007 60 63 62 2040 41 123 621 392 40 2040 614 424 41 123 450 59 125 392 40 2008 46 2041 40 2040 41 41 123 450 59 125 2042 494 61 2003 46 2043 40 2040 41 59 392 40 494 631 424 41 123 469 418 2044 40 494 41 59 125 2039 40 2040 46 2045 40 41 41 59 385 40 2007 60 63 62 2046 58 2040 46 2047 40 41 41 123 2039 40 2046 41 59 125 2008 46 2048 40 2040 41 59 125 439 60 2016 62 2049 60 2016 62 2050 40 2007 60 2016 62 2051 44 2018 2019 41 123 392 40 33 2052 46 334 46 2053 40 2019 41 41 123 469 418 2054 40 648 43 2019 46 2055 40 41 46 2056 40 41 43 648 43 648 41 59 125 2052 2057 61 2052 46 334 46 2058 40 2019 41 59 2034 60 2016 62 2035 61 2057 46 2059 40 2051 41 59 2060 46 2061 60 2016 62 2062 61 2063 40 2051 44 2035 41 59 2062 46 2064 40 41 59 2065 40 41 46 2066 40 2051 44 2035 41 59 450 418 2067 60 62 40 2062 41 59 125 439 60 2016 62 2068 60 2016 62 2069 40 2007 60 2016 62 2013 44 2070 60 2068 46 2071 44 63 378 2018 62 2072 44 2068 46 2073 60 2016 62 2074 41 123 2070 60 2068 46 2071 44 2034 60 2016 641 2035 61 2075 45 62 123 2018 2076 61 2072 46 2077 40 2075 41 59 392 40 33 2078 46 334 46 2079 40 2076 41 41 123 469 418 2080 40 648 43 2076 46 2081 40 41 46 2082 40 41 43 648 43 648 41 59 125 2078 2083 61 2078 46 334 46 2084 40 2076 41 59 450 2083 46 2085 40 2013 41 59 125 59 2086 46 2087 60 2016 62 2088 61 2089 40 2013 44 2035 44 2074 41 59 2088 46 2090 40 41 59 450 418 2091 60 62 40 2088 41 59 125 439 60 2016 62 2092 60 2016 62 2093 40 2016 2094 41 123 2095 2096 61 2096 40 41 59 2096 46 2097 40 41 59 64 2000 40 648 41 2092 60 2016 62 2098 61 40 2092 60 2016 62 41 2096 46 2099 40 41 59 392 40 2098 614 424 41 123 2096 46 2100 40 41 59 469 2101 40 41 59 125 450 2098 59 125 439 60 2016 62 2016 2102 40 2016 2017 44 2103 2104 41 123 392 40 2017 614 424 41 123 469 2105 40 41 59 125 2106 2107 61 2107 40 2017 41 59 392 40 33 2107 46 2108 40 41 41 123 469 2109 40 2017 46 2110 40 41 41 59 125 2111 40 2017 41 59 2112 2113 61 2107 46 2114 40 41 59 2017 61 40 2016 41 2115 46 2116 40 2113 46 2117 40 41 46 2118 40 41 44 2107 41 59 2119 2120 61 2120 40 41 59 2103 2121 61 2120 46 2122 40 2104 41 59 2120 46 2123 40 418 2124 40 2017 44 2121 44 2120 46 2125 40 41 41 41 59 450 2017 59 125 439 60 2016 62 492 2126 40 2016 613 2127 41 123 2128 2129 61 2129 40 41 59 2129 46 2130 40 41 59 2129 46 2126 40 41 59 2129 46 2131 40 41 59 385 40 2016 2132 58 2127 41 123 2133 40 2132 41 59 125 125 439 60 2016 62 492 2134 40 2016 613 2127 41 123 2135 2136 61 2136 40 41 59 2136 46 2137 40 41 59 2136 46 2126 40 41 59 2136 46 2138 40 41 59 385 40 2016 2139 58 2127 41 123 2140 40 2139 41 46 2134 40 41 59 125 125 439 492 2141 40 2142 613 2127 41 123 2143 40 2127 41 59 2144 40 41 46 2145 40 41 59 385 40 2142 2017 58 2127 41 123 474 123 392 40 2017 614 424 41 123 469 2146 40 41 59 125 2147 2148 61 2149 40 2017 41 59 2150 40 2017 41 59 2151 2152 61 418 2151 40 2148 44 424 41 59 2153 40 41 46 2102 40 2152 41 59 125 329 40 2154 2155 41 123 469 2156 40 41 59 125 125 125 439 492 2157 40 2142 613 2127 41 123 2158 40 2127 41 59 2159 40 41 46 2160 40 41 59 385 40 2142 2017 58 2127 41 123 474 123 392 40 2017 614 424 41 123 469 2161 40 41 59 125 2162 2163 61 2164 40 2017 41 59 2165 40 2017 41 59 2166 2167 61 418 2166 40 2163 44 424 41 59 2168 40 41 46 2102 40 2167 41 59 125 329 40 2169 2170 41 123 469 2171 40 41 59 125 125 125 439 492 2172 40 2173 60 2142 62 2127 44 2174 2175 41 123 2176 40 41 46 2177 40 41 59 2178 2179 61 418 2180 40 2175 44 2181 46 2182 40 2127 41 44 424 41 59 2183 46 2184 40 41 46 2185 40 2179 41 59 125 437 492 2186 40 2142 91 93 2127 41 123 392 40 2127 614 424 606 2127 46 2187 614 1500 41 123 469 2188 40 41 59 125 125 437 492 2189 40 2142 2017 41 123 392 40 2190 40 2017 41 46 2191 40 41 46 2192 40 41 41 123 469 2193 40 2017 41 59 125 125 439 2194 2195 40 2142 613 2127 41 123 392 40 2127 614 424 606 2127 46 2196 614 1500 41 123 469 2197 40 41 59 125 385 40 2142 2017 58 2127 41 123 392 40 2017 614 424 41 123 469 2198 40 41 59 125 392 40 33 2199 40 2017 41 41 123 469 2200 40 41 59 125 2189 40 2017 41 59 125 450 418 2201 40 2202 46 2203 40 2127 41 41 59 125 439 2204 2205 40 41 123 450 2205 40 424 41 59 125 439 2204 2205 40 2206 2207 41 123 2208 2209 61 2209 40 41 59 2209 46 2210 40 41 59 2209 46 2211 40 41 59 450 418 2212 40 2207 41 59 125 439 492 2213 40 41 123 2214 40 41 46 2215 40 41 59 125 618 439 2216 2217 40 41 123 2218 2219 61 40 40 2218 41 2220 40 41 46 2221 40 41 41 59 2173 60 2216 62 2222 61 2219 46 2223 40 41 59 450 2222 46 2224 40 2222 46 2225 40 41 45 1501 41 59 125 439 2142 91 93 2226 40 2142 613 2127 41 123 385 40 2142 2227 58 2127 41 123 2228 2229 61 2230 40 2227 41 59 2173 60 2216 62 2231 61 2229 46 2232 40 41 59 385 40 2216 398 58 2231 41 123 392 40 398 46 2233 40 41 631 424 41 123 398 46 2234 40 41 59 125 125 125 450 2127 59 125 439 2235 2236 40 2142 2237 41 123 450 418 2238 40 2237 41 59 125 439 2239 2240 40 41 123 450 418 2241 40 41 59 125 439 492 2242 40 41 123 2243 46 2242 40 41 59 125 125 
2688,Java,"public class MovementDiagonal extends Movement {

    private static final double SQRT_2 = Math.sqrt(2);

    public MovementDiagonal(IBaritone baritone, BetterBlockPos start, EnumFacing dir1, EnumFacing dir2, int dy) {
        this(baritone, start, start.offset(dir1), start.offset(dir2), dir2, dy);
        // super(start, start.offset(dir1).offset(dir2), new BlockPos[]{start.offset(dir1), start.offset(dir1).up(), start.offset(dir2), start.offset(dir2).up(), start.offset(dir1).offset(dir2), start.offset(dir1).offset(dir2).up()}, new BlockPos[]{start.offset(dir1).offset(dir2).down()});
    }

    private MovementDiagonal(IBaritone baritone, BetterBlockPos start, BetterBlockPos dir1, BetterBlockPos dir2, EnumFacing drr2, int dy) {
        this(baritone, start, dir1.offset(drr2).up(dy), dir1, dir2);
    }

    private MovementDiagonal(IBaritone baritone, BetterBlockPos start, BetterBlockPos end, BetterBlockPos dir1, BetterBlockPos dir2) {
        super(baritone, start, end, new BetterBlockPos[]{dir1, dir1.up(), dir2, dir2.up(), end, end.up()});
    }

    @Override
    protected boolean safeToCancel(MovementState state) {
        //too simple. backfill does not work after cornering with this
        //return MovementHelper.canWalkOn(ctx, ctx.playerFeet().down());
        EntityPlayerSP player = ctx.player();
        double offset = 0.25;
        double x = player.posX;
        double y = player.posY - 1;
        double z = player.posZ;
        //standard
        if (ctx.playerFeet().equals(src)) {
            return true;
        }
        //both corners are walkable
        if (MovementHelper.canWalkOn(ctx, new BlockPos(src.x, src.y - 1, dest.z))
                && MovementHelper.canWalkOn(ctx, new BlockPos(dest.x, src.y - 1, src.z))) {
            return true;
        }
        //we are in a likely unwalkable corner, check for a supporting block
        if (ctx.playerFeet().equals(new BetterBlockPos(src.x, src.y, dest.z))
                || ctx.playerFeet().equals(new BetterBlockPos(dest.x, src.y, src.z))) {
            return (MovementHelper.canWalkOn(ctx, new BetterBlockPos(x + offset, y, z + offset))
                    || MovementHelper.canWalkOn(ctx, new BetterBlockPos(x + offset, y, z - offset))
                    || MovementHelper.canWalkOn(ctx, new BetterBlockPos(x - offset, y, z + offset))
                    || MovementHelper.canWalkOn(ctx, new BetterBlockPos(x - offset, y, z - offset)));
        }
        return true;
    }

    @Override
    public double calculateCost(CalculationContext context) {
        MutableMoveResult result = new MutableMoveResult();
        cost(context, src.x, src.y, src.z, dest.x, dest.z, result);
        if (result.y != dest.y) {
            return COST_INF; // doesn't apply to us, this position is incorrect
        }
        return result.cost;
    }

    @Override
    protected Set<BetterBlockPos> calculateValidPositions() {
        BetterBlockPos diagA = new BetterBlockPos(src.x, src.y, dest.z);
        BetterBlockPos diagB = new BetterBlockPos(dest.x, src.y, src.z);
        if (dest.y < src.y) {
            return ImmutableSet.of(src, dest.up(), diagA, diagB, dest, diagA.down(), diagB.down());
        }
        if (dest.y > src.y) {
            return ImmutableSet.of(src, src.up(), diagA, diagB, dest, diagA.up(), diagB.up());
        }
        return ImmutableSet.of(src, dest, diagA, diagB);
    }

    public static void cost(CalculationContext context, int x, int y, int z, int destX, int destZ, MutableMoveResult res) {
        if (!MovementHelper.canWalkThrough(context.bsi, destX, y + 1, destZ)) {
            return;
        }
        IBlockState destInto = context.get(destX, y, destZ);
        boolean ascend = false;
        IBlockState destWalkOn;
        boolean descend = false;
        if (!MovementHelper.canWalkThrough(context.bsi, destX, y, destZ, destInto)) {
            ascend = true;
            if (!context.allowDiagonalAscend || !MovementHelper.canWalkThrough(context.bsi, x, y + 2, z) || !MovementHelper.canWalkOn(context.bsi, destX, y, destZ, destInto) || !MovementHelper.canWalkThrough(context.bsi, destX, y + 2, destZ)) {
                return;
            }
            destWalkOn = destInto;
        } else {
            destWalkOn = context.get(destX, y - 1, destZ);
            if (!MovementHelper.canWalkOn(context.bsi, destX, y - 1, destZ, destWalkOn)) {
                descend = true;
                if (!context.allowDiagonalDescend || !MovementHelper.canWalkOn(context.bsi, destX, y - 2, destZ) || !MovementHelper.canWalkThrough(context.bsi, destX, y - 1, destZ, destWalkOn)) {
                    return;
                }
            }
        }
        double multiplier = WALK_ONE_BLOCK_COST;
        // For either possible soul sand, that affects half of our walking
        if (destWalkOn.getBlock() == Blocks.SOUL_SAND) {
            multiplier += (WALK_ONE_OVER_SOUL_SAND_COST - WALK_ONE_BLOCK_COST) / 2;
        } else if (destWalkOn.getBlock() == Blocks.WATER) {
            multiplier += context.walkOnWaterOnePenalty * SQRT_2;
        }
        Block fromDown = context.get(x, y - 1, z).getBlock();
        if (fromDown == Blocks.LADDER || fromDown == Blocks.VINE) {
            return;
        }
        if (fromDown == Blocks.SOUL_SAND) {
            multiplier += (WALK_ONE_OVER_SOUL_SAND_COST - WALK_ONE_BLOCK_COST) / 2;
        }
        Block cuttingOver1 = context.get(x, y - 1, destZ).getBlock();
        if (cuttingOver1 == Blocks.MAGMA || MovementHelper.isLava(cuttingOver1)) {
            return;
        }
        Block cuttingOver2 = context.get(destX, y - 1, z).getBlock();
        if (cuttingOver2 == Blocks.MAGMA || MovementHelper.isLava(cuttingOver2)) {
            return;
        }
        Block startIn = context.getBlock(x, y, z);
        boolean water = false;
        if (MovementHelper.isWater(startIn) || MovementHelper.isWater(destInto.getBlock())) {
            if (ascend) {
                return;
            }
            // Ignore previous multiplier
            // Whatever we were walking on (possibly soul sand) doesn't matter as we're actually floating on water
            // Not even touching the blocks below
            multiplier = context.waterWalkSpeed;
            water = true;
        }
        IBlockState pb0 = context.get(x, y, destZ);
        IBlockState pb2 = context.get(destX, y, z);
        if (ascend) {
            boolean ATop = MovementHelper.canWalkThrough(context.bsi, x, y + 2, destZ);
            boolean AMid = MovementHelper.canWalkThrough(context.bsi, x, y + 1, destZ);
            boolean ALow = MovementHelper.canWalkThrough(context.bsi, x, y, destZ, pb0);
            boolean BTop = MovementHelper.canWalkThrough(context.bsi, destX, y + 2, z);
            boolean BMid = MovementHelper.canWalkThrough(context.bsi, destX, y + 1, z);
            boolean BLow = MovementHelper.canWalkThrough(context.bsi, destX, y, z, pb2);
            if ((!(ATop && AMid && ALow) && !(BTop && BMid && BLow)) // no option
                    || MovementHelper.avoidWalkingInto(pb0.getBlock()) // bad
                    || MovementHelper.avoidWalkingInto(pb2.getBlock()) // bad
                    || (ATop && AMid && MovementHelper.canWalkOn(context.bsi, x, y, destZ, pb0)) // we could just ascend
                    || (BTop && BMid && MovementHelper.canWalkOn(context.bsi, destX, y, z, pb2)) // we could just ascend
                    || (!ATop && AMid && ALow) // head bonk A
                    || (!BTop && BMid && BLow)) { // head bonk B
                return;
            }
            res.cost = multiplier * SQRT_2 + JUMP_ONE_BLOCK_COST;
            res.x = destX;
            res.z = destZ;
            res.y = y + 1;
            return;
        }
        double optionA = MovementHelper.getMiningDurationTicks(context, x, y, destZ, pb0, false);
        double optionB = MovementHelper.getMiningDurationTicks(context, destX, y, z, pb2, false);
        if (optionA != 0 && optionB != 0) {
            // check these one at a time -- if pb0 and pb2 were nonzero, we already know that (optionA != 0 && optionB != 0)
            // so no need to check pb1 as well, might as well return early here
            return;
        }
        IBlockState pb1 = context.get(x, y + 1, destZ);
        optionA += MovementHelper.getMiningDurationTicks(context, x, y + 1, destZ, pb1, true);
        if (optionA != 0 && optionB != 0) {
            // same deal, if pb1 makes optionA nonzero and option B already was nonzero, pb3 can't affect the result
            return;
        }
        IBlockState pb3 = context.get(destX, y + 1, z);
        if (optionA == 0 && ((MovementHelper.avoidWalkingInto(pb2.getBlock()) && pb2.getBlock() != Blocks.WATER) || MovementHelper.avoidWalkingInto(pb3.getBlock()))) {
            // at this point we're done calculating optionA, so we can check if it's actually possible to edge around in that direction
            return;
        }
        optionB += MovementHelper.getMiningDurationTicks(context, destX, y + 1, z, pb3, true);
        if (optionA != 0 && optionB != 0) {
            // and finally, if the cost is nonzero for both ways to approach this diagonal, it's not possible
            return;
        }
        if (optionB == 0 && ((MovementHelper.avoidWalkingInto(pb0.getBlock()) && pb0.getBlock() != Blocks.WATER) || MovementHelper.avoidWalkingInto(pb1.getBlock()))) {
            // and now that option B is fully calculated, see if we can edge around that way
            return;
        }
        if (optionA != 0 || optionB != 0) {
            multiplier *= SQRT_2 - 0.001; // TODO tune
            if (startIn == Blocks.LADDER || startIn == Blocks.VINE) {
                // edging around doesn't work if doing so would climb a ladder or vine instead of moving sideways
                return;
            }
        } else {
            // only can sprint if not edging around
            if (context.canSprint && !water) {
                // If we aren't edging around anything, and we aren't in water
                // We can sprint =D
                // Don't check for soul sand, since we can sprint on that too
                multiplier *= SPRINT_MULTIPLIER;
            }
        }
        res.cost = multiplier * SQRT_2;
        if (descend) {
            res.cost += Math.max(FALL_N_BLOCKS_COST[1], CENTER_AFTER_FALL_COST);
            res.y = y - 1;
        } else {
            res.y = y;
        }
        res.x = destX;
        res.z = destZ;
    }

    @Override
    public MovementState updateState(MovementState state) {
        super.updateState(state);
        if (state.getStatus() != MovementStatus.RUNNING) {
            return state;
        }

        if (ctx.playerFeet().equals(dest)) {
            return state.setStatus(MovementStatus.SUCCESS);
        } else if (!playerInValidPosition() && !(MovementHelper.isLiquid(ctx, src) && getValidPositions().contains(ctx.playerFeet().up()))) {
            return state.setStatus(MovementStatus.UNREACHABLE);
        }
        if (dest.y > src.y && ctx.player().posY < src.y + 0.1 && ctx.player().collidedHorizontally) {
            state.setInput(Input.JUMP, true);
        }
        if (sprint()) {
            state.setInput(Input.SPRINT, true);
        }
        MovementHelper.moveTowards(ctx, state, dest);
        return state;
    }

    private boolean sprint() {
        if (MovementHelper.isLiquid(ctx, ctx.playerFeet()) && !Baritone.settings().sprintInWater.value) {
            return false;
        }
        for (int i = 0; i < 4; i++) {
            if (!MovementHelper.canWalkThrough(ctx, positionsToBreak[i])) {
                return false;
            }
        }
        return true;
    }

    @Override
    protected boolean prepared(MovementState state) {
        return true;
    }

    @Override
    public List<BlockPos> toBreak(BlockStateInterface bsi) {
        if (toBreakCached != null) {
            return toBreakCached;
        }
        List<BlockPos> result = new ArrayList<>();
        for (int i = 4; i < 6; i++) {
            if (!MovementHelper.canWalkThrough(bsi, positionsToBreak[i].x, positionsToBreak[i].y, positionsToBreak[i].z)) {
                result.add(positionsToBreak[i]);
            }
        }
        toBreakCached = result;
        return result;
    }

    @Override
    public List<BlockPos> toWalkInto(BlockStateInterface bsi) {
        if (toWalkIntoCached == null) {
            toWalkIntoCached = new ArrayList<>();
        }
        List<BlockPos> result = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            if (!MovementHelper.canWalkThrough(bsi, positionsToBreak[i].x, positionsToBreak[i].y, positionsToBreak[i].z)) {
                result.add(positionsToBreak[i]);
            }
        }
        toWalkIntoCached = result;
        return toWalkIntoCached;
    }
}",1,439 334 2000 378 2001 123 437 457 381 356 2002 61 2003 46 2004 40 1502 41 59 439 2000 40 2005 2006 44 2007 2008 44 2009 2010 44 2009 2011 44 404 2012 41 123 467 40 2006 44 2008 44 2008 46 2013 40 2010 41 44 2008 46 2013 40 2011 41 44 2011 44 2012 41 59 621 125 437 2000 40 2005 2006 44 2007 2008 44 2007 2010 44 2007 2011 44 2009 2014 44 404 2012 41 123 467 40 2006 44 2008 44 2010 46 2015 40 2014 41 46 2016 40 2012 41 44 2010 44 2011 41 59 125 437 2000 40 2005 2006 44 2007 2008 44 2007 2017 44 2007 2010 44 2007 2011 41 123 463 40 2006 44 2008 44 2017 44 418 2007 91 93 123 2010 44 2010 46 2018 40 41 44 2011 44 2011 46 2018 40 41 44 2017 44 2017 46 2018 40 41 125 41 59 125 64 2019 438 324 2020 40 2021 2022 41 123 621 621 2023 2024 61 2025 46 2024 40 41 59 356 2026 61 1499 59 356 2027 61 2024 46 2028 59 356 2029 61 2024 46 2030 45 1501 59 356 2031 61 2024 46 2032 59 621 392 40 2025 46 2033 40 41 46 2034 40 2035 41 41 123 450 473 59 125 621 392 40 2036 46 2037 40 2025 44 418 2038 40 2035 46 2027 44 2035 46 2029 45 1501 44 2039 46 2031 41 41 605 2036 46 2037 40 2025 44 418 2038 40 2039 46 2027 44 2035 46 2029 45 1501 44 2035 46 2031 41 41 41 123 450 473 59 125 621 392 40 2025 46 2033 40 41 46 2034 40 418 2007 40 2035 46 2027 44 2035 46 2029 44 2039 46 2031 41 41 606 2025 46 2033 40 41 46 2034 40 418 2007 40 2039 46 2027 44 2035 46 2029 44 2035 46 2031 41 41 41 123 450 40 2036 46 2037 40 2025 44 418 2007 40 2027 43 2026 44 2029 44 2031 43 2026 41 41 606 2036 46 2037 40 2025 44 418 2007 40 2027 43 2026 44 2029 44 2031 45 2026 41 41 606 2036 46 2037 40 2025 44 418 2007 40 2027 45 2026 44 2029 44 2031 43 2026 41 41 606 2036 46 2037 40 2025 44 418 2007 40 2027 45 2026 44 2029 44 2031 45 2026 41 41 41 59 125 450 473 59 125 64 2019 439 356 2040 40 2041 2042 41 123 2043 2044 61 418 2043 40 41 59 2045 40 2042 44 2046 46 2047 44 2046 46 2048 44 2046 46 2049 44 2050 46 2047 44 2050 46 2049 44 2044 41 59 392 40 2044 46 2048 631 2050 46 2048 41 123 450 2051 59 621 125 450 2044 46 2045 59 125 64 2019 438 2052 60 2007 62 2053 40 41 123 2007 2054 61 418 2007 40 2055 46 2056 44 2055 46 2057 44 2058 46 2059 41 59 2007 2060 61 418 2007 40 2058 46 2056 44 2055 46 2057 44 2055 46 2059 41 59 392 40 2058 46 2057 60 2055 46 2057 41 123 450 2061 46 2062 40 2055 44 2058 46 2063 40 41 44 2054 44 2060 44 2058 44 2054 46 2064 40 41 44 2060 46 2064 40 41 41 59 125 392 40 2058 46 2057 62 2055 46 2057 41 123 450 2065 46 2066 40 2055 44 2055 46 2067 40 41 44 2054 44 2060 44 2058 44 2054 46 2067 40 41 44 2060 46 2067 40 41 41 59 125 450 2068 46 2069 40 2055 44 2058 44 2054 44 2060 41 59 125 439 457 492 2070 40 2041 2042 44 404 2071 44 404 2072 44 404 2073 44 404 2074 44 404 2075 44 2076 2077 41 123 392 40 33 2078 46 2079 40 2042 46 2080 44 2074 44 2072 43 1501 44 2075 41 41 123 450 59 125 2081 2082 61 2042 46 2083 40 2074 44 2072 44 2075 41 59 324 2084 61 380 59 2081 2085 59 324 2086 61 380 59 392 40 33 2078 46 2079 40 2042 46 2080 44 2074 44 2072 44 2075 44 2082 41 41 123 2084 61 473 59 392 40 33 2042 46 2087 606 33 2078 46 2079 40 2042 46 2080 44 2071 44 2072 43 1502 44 2073 41 606 33 2078 46 2088 40 2042 46 2080 44 2074 44 2072 44 2075 44 2082 41 606 33 2078 46 2079 40 2042 46 2080 44 2074 44 2072 43 1502 44 2075 41 41 123 450 59 125 2085 61 2082 59 125 360 123 2085 61 2042 46 2083 40 2074 44 2072 45 1501 44 2075 41 59 392 40 33 2078 46 2089 40 2042 46 2080 44 2074 44 2072 45 1501 44 2075 44 2085 41 41 123 2086 61 473 59 392 40 33 2042 46 2090 606 33 2078 46 2089 40 2042 46 2080 44 2074 44 2072 45 1502 44 2075 41 606 33 2078 46 2079 40 2042 46 2080 44 2074 44 2072 45 1501 44 2075 44 2085 41 41 123 450 59 125 125 125 356 2091 61 2092 59 621 392 40 2085 46 2093 40 41 614 2094 46 2095 41 123 2091 636 40 2096 45 2092 41 47 1502 59 125 360 392 40 2085 46 2093 40 41 614 2094 46 2097 41 123 2091 636 2042 46 2098 42 2002 59 125 2099 2100 61 2042 46 2083 40 2071 44 2072 45 1501 44 2073 41 46 2093 40 41 59 392 40 2100 614 2094 46 2101 606 2100 614 2094 46 2102 41 123 450 59 125 392 40 2100 614 2094 46 2095 41 123 2091 636 40 2103 45 2092 41 47 1502 59 125 2099 2104 61 2042 46 2083 40 2071 44 2072 45 1501 44 2075 41 46 2093 40 41 59 392 40 2104 614 2094 46 2105 606 2078 46 2106 40 2104 41 41 123 450 59 125 2099 2107 61 2042 46 2083 40 2074 44 2072 45 1501 44 2073 41 46 2093 40 41 59 392 40 2107 614 2094 46 2105 606 2078 46 2106 40 2107 41 41 123 450 59 125 2099 2108 61 2042 46 2093 40 2071 44 2072 44 2073 41 59 324 2109 61 380 59 392 40 2078 46 2110 40 2108 41 606 2078 46 2110 40 2082 46 2093 40 41 41 41 123 392 40 2084 41 123 450 59 125 621 621 621 2091 61 2042 46 2111 59 2109 61 473 59 125 2081 2112 61 2042 46 2083 40 2071 44 2072 44 2075 41 59 2081 2113 61 2042 46 2083 40 2074 44 2072 44 2073 41 59 392 40 2084 41 123 324 2114 61 2078 46 2079 40 2042 46 2080 44 2071 44 2072 43 1502 44 2075 41 59 324 2115 61 2078 46 2079 40 2042 46 2080 44 2071 44 2072 43 1501 44 2075 41 59 324 2116 61 2078 46 2079 40 2042 46 2080 44 2071 44 2072 44 2075 44 2112 41 59 324 2117 61 2078 46 2079 40 2042 46 2080 44 2074 44 2072 43 1502 44 2073 41 59 324 2118 61 2078 46 2079 40 2042 46 2080 44 2074 44 2072 43 1501 44 2073 41 59 324 2119 61 2078 46 2079 40 2042 46 2080 44 2074 44 2072 44 2073 44 2113 41 59 392 40 40 33 40 2114 605 2115 605 2116 41 605 33 40 2117 605 2118 605 2119 41 41 621 606 2078 46 2120 40 2112 46 2093 40 41 41 621 606 2078 46 2120 40 2113 46 2093 40 41 41 621 606 40 2114 605 2115 605 2078 46 2121 40 2042 46 2080 44 2071 44 2072 44 2075 44 2112 41 41 621 606 40 2117 605 2118 605 2078 46 2121 40 2042 46 2080 44 2074 44 2072 44 2073 44 2113 41 41 621 606 40 33 2114 605 2115 605 2116 41 621 606 40 33 2117 605 2118 605 2119 41 41 123 621 450 59 125 2077 46 2070 61 2091 42 2002 43 2122 59 2077 46 2071 61 2074 59 2077 46 2073 61 2075 59 2077 46 2072 61 2072 43 1501 59 450 59 125 356 2123 61 2078 46 2124 40 2042 44 2071 44 2072 44 2075 44 2112 44 380 41 59 356 2125 61 2078 46 2124 40 2042 44 2074 44 2072 44 2073 44 2113 44 380 41 59 392 40 2123 631 1500 605 2125 631 1500 41 123 621 621 450 59 125 2081 2126 61 2042 46 2083 40 2071 44 2072 43 1501 44 2075 41 59 2123 636 2078 46 2124 40 2042 44 2071 44 2072 43 1501 44 2075 44 2126 44 473 41 59 392 40 2123 631 1500 605 2125 631 1500 41 123 621 450 59 125 2081 2127 61 2042 46 2083 40 2074 44 2072 43 1501 44 2073 41 59 392 40 2123 614 1500 605 40 40 2078 46 2128 40 2113 46 2093 40 41 41 605 2113 46 2093 40 41 631 2094 46 2097 41 606 2078 46 2128 40 2127 46 2093 40 41 41 41 41 123 621 450 59 125 2125 636 2078 46 2124 40 2042 44 2074 44 2072 43 1501 44 2073 44 2127 44 473 41 59 392 40 2123 631 1500 605 2125 631 1500 41 123 621 450 59 125 392 40 2125 614 1500 605 40 40 2078 46 2128 40 2112 46 2093 40 41 41 605 2112 46 2093 40 41 631 2094 46 2097 41 606 2078 46 2128 40 2126 46 2093 40 41 41 41 41 123 621 450 59 125 392 40 2123 631 1500 606 2125 631 1500 41 123 2091 649 2002 45 1497 59 621 392 40 2108 614 2094 46 2101 606 2108 614 2094 46 2102 41 123 621 450 59 125 125 360 123 621 392 40 2042 46 2129 605 33 2109 41 123 621 621 621 2091 649 2130 59 125 125 2077 46 2070 61 2091 42 2002 59 392 40 2086 41 123 2077 46 2070 636 2003 46 2131 40 2132 91 1501 93 44 2133 41 59 2077 46 2072 61 2072 45 1501 59 125 360 123 2077 46 2072 61 2072 59 125 2077 46 2071 61 2074 59 2077 46 2073 61 2075 59 125 64 2019 439 2021 2134 40 2021 2022 41 123 463 46 2134 40 2022 41 59 392 40 2022 46 2135 40 41 631 2136 46 2137 41 123 450 2022 59 125 392 40 2138 46 2139 40 41 46 2140 40 2141 41 41 123 450 2022 46 2142 40 2136 46 2143 41 59 125 360 392 40 33 2144 40 41 605 33 40 2145 46 2146 40 2138 44 2147 41 605 2148 40 41 46 2149 40 2138 46 2139 40 41 46 2150 40 41 41 41 41 123 450 2022 46 2151 40 2136 46 2152 41 59 125 392 40 2141 46 2072 62 2147 46 2072 605 2138 46 2153 40 41 46 2154 60 2147 46 2072 43 1499 605 2138 46 2153 40 41 46 2155 41 123 2022 46 2156 40 2157 46 2158 44 473 41 59 125 392 40 2159 40 41 41 123 2022 46 2160 40 2161 46 2162 44 473 41 59 125 2145 46 2163 40 2138 44 2022 44 2141 41 59 450 2022 59 125 437 324 2164 40 41 123 392 40 2165 46 2166 40 2167 44 2167 46 2168 40 41 41 605 33 2169 46 2170 40 41 46 2171 46 2172 41 123 450 380 59 125 385 40 404 2173 61 1500 59 2173 60 1502 59 2173 637 41 123 392 40 33 2165 46 2174 40 2167 44 2175 91 2173 93 41 41 123 450 380 59 125 125 450 473 59 125 64 2019 438 324 2176 40 2021 2022 41 123 450 473 59 125 64 2019 439 2177 60 2178 62 2179 40 2180 2181 41 123 392 40 2182 631 424 41 123 450 2182 59 125 2177 60 2178 62 2183 61 418 2184 60 62 40 41 59 385 40 404 2185 61 1502 59 2185 60 1502 59 2185 637 41 123 392 40 33 2186 46 2187 40 2181 44 2188 91 2185 93 46 2071 44 2188 91 2185 93 46 2072 44 2188 91 2185 93 46 2073 41 41 123 2183 46 2189 40 2188 91 2185 93 41 59 125 125 2182 61 2183 59 450 2183 59 125 64 2019 439 2177 60 2178 62 2190 40 2180 2181 41 123 392 40 2191 614 424 41 123 2191 61 418 2192 60 62 40 41 59 125 2177 60 2178 62 2193 61 418 2194 60 62 40 41 59 385 40 404 2195 61 1500 59 2195 60 1502 59 2195 637 41 123 392 40 33 2196 46 2197 40 2181 44 2198 91 2195 93 46 2071 44 2198 91 2195 93 46 2072 44 2198 91 2195 93 46 2073 41 41 123 2193 46 2199 40 2198 91 2195 93 41 59 125 125 2191 61 2193 59 450 2191 59 125 125 
2964,Java,"@Slf4j
public abstract class DisputeManager<T extends DisputeList<Dispute>> extends SupportManager {
    protected final TradeWalletService tradeWalletService;
    protected final BtcWalletService btcWalletService;
    protected final TradeManager tradeManager;
    protected final ClosedTradableManager closedTradableManager;
    protected final OpenOfferManager openOfferManager;
    protected final PubKeyRing pubKeyRing;
    protected final DisputeListService<T> disputeListService;
    private final Config config;
    private final PriceFeedService priceFeedService;
    protected final DaoFacade daoFacade;

    @Getter
    protected final ObservableList<TradeDataValidation.ValidationException> validationExceptions =
            FXCollections.observableArrayList();
    @Getter
    private final KeyPair signatureKeyPair;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    public DisputeManager(P2PService p2PService,
                          TradeWalletService tradeWalletService,
                          BtcWalletService btcWalletService,
                          WalletsSetup walletsSetup,
                          TradeManager tradeManager,
                          ClosedTradableManager closedTradableManager,
                          OpenOfferManager openOfferManager,
                          DaoFacade daoFacade,
                          KeyRing keyRing,
                          DisputeListService<T> disputeListService,
                          Config config,
                          PriceFeedService priceFeedService) {
        super(p2PService, walletsSetup);

        this.tradeWalletService = tradeWalletService;
        this.btcWalletService = btcWalletService;
        this.tradeManager = tradeManager;
        this.closedTradableManager = closedTradableManager;
        this.openOfferManager = openOfferManager;
        this.daoFacade = daoFacade;
        this.pubKeyRing = keyRing.getPubKeyRing();
        signatureKeyPair = keyRing.getSignatureKeyPair();
        this.disputeListService = disputeListService;
        this.config = config;
        this.priceFeedService = priceFeedService;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Implement template methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void requestPersistence() {
        disputeListService.requestPersistence();
    }

    @Override
    public NodeAddress getPeerNodeAddress(ChatMessage message) {
        Optional<Dispute> disputeOptional = findDispute(message);
        if (!disputeOptional.isPresent()) {
            log.warn(""Could not find dispute for tradeId = {} traderId = {}"",
                    message.getTradeId(), message.getTraderId());
            return null;
        }
        return getNodeAddressPubKeyRingTuple(disputeOptional.get()).first;
    }

    @Override
    public PubKeyRing getPeerPubKeyRing(ChatMessage message) {
        Optional<Dispute> disputeOptional = findDispute(message);
        if (!disputeOptional.isPresent()) {
            log.warn(""Could not find dispute for tradeId = {} traderId = {}"",
                    message.getTradeId(), message.getTraderId());
            return null;
        }

        return getNodeAddressPubKeyRingTuple(disputeOptional.get()).second;
    }

    @Override
    public List<ChatMessage> getAllChatMessages(String tradeId) {
        return getDisputeList().stream()
                .filter(dispute -> dispute.getTradeId().equals(tradeId))
                .flatMap(dispute -> dispute.getChatMessages().stream())
                .collect(Collectors.toList());
    }

    @Override
    public boolean channelOpen(ChatMessage message) {
        return findDispute(message).isPresent();
    }

    @Override
    public void addAndPersistChatMessage(ChatMessage message) {
        findDispute(message).ifPresent(dispute -> {
            if (dispute.getChatMessages().stream().noneMatch(m -> m.getUid().equals(message.getUid()))) {
                dispute.addAndPersistChatMessage(message);
                requestPersistence();
            } else {
                log.warn(""We got a chatMessage that we have already stored. UId = {} TradeId = {}"",
                        message.getUid(), message.getTradeId());
            }
        });
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Abstract methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    // We get that message at both peers. The dispute object is in context of the trader
    public abstract void onDisputeResultMessage(DisputeResultMessage disputeResultMessage);

    @Nullable
    public abstract NodeAddress getAgentNodeAddress(Dispute dispute);

    protected abstract Trade.DisputeState getDisputeStateStartedByPeer();

    public abstract void cleanupDisputes();

    protected abstract String getDisputeInfo(Dispute dispute);

    protected abstract String getDisputeIntroForPeer(String disputeInfo);

    protected abstract String getDisputeIntroForDisputeCreator(String disputeInfo);


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Delegates for disputeListService
    ///////////////////////////////////////////////////////////////////////////////////////////

    public IntegerProperty getNumOpenDisputes() {
        return disputeListService.getNumOpenDisputes();
    }

    public ObservableList<Dispute> getDisputesAsObservableList() {
        return disputeListService.getObservableList();
    }

    public String getNrOfDisputes(boolean isBuyer, Contract contract) {
        return disputeListService.getNrOfDisputes(isBuyer, contract);
    }

    protected T getDisputeList() {
        return disputeListService.getDisputeList();
    }

    public Set<String> getDisputedTradeIds() {
        return disputeListService.getDisputedTradeIds();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void onAllServicesInitialized() {
        super.onAllServicesInitialized();
        disputeListService.onAllServicesInitialized();

        p2PService.addP2PServiceListener(new BootstrapListener() {
            @Override
            public void onUpdatedDataReceived() {
                tryApplyMessages();
            }
        });

        walletsSetup.downloadPercentageProperty().addListener((observable, oldValue, newValue) -> {
            if (walletsSetup.isDownloadComplete())
                tryApplyMessages();
        });

        walletsSetup.numPeersProperty().addListener((observable, oldValue, newValue) -> {
            if (walletsSetup.hasSufficientPeersForBroadcast())
                tryApplyMessages();
        });

        tryApplyMessages();
        cleanupDisputes();

        List<Dispute> disputes = getDisputeList().getList();
        disputes.forEach(dispute -> {
            try {
                TradeDataValidation.validateDonationAddress(dispute, dispute.getDonationAddressOfDelayedPayoutTx(), daoFacade);
                TradeDataValidation.validateNodeAddress(dispute, dispute.getContract().getBuyerNodeAddress(), config);
                TradeDataValidation.validateNodeAddress(dispute, dispute.getContract().getSellerNodeAddress(), config);
            } catch (TradeDataValidation.AddressException | TradeDataValidation.NodeAddressException e) {
                log.error(e.toString());
                validationExceptions.add(e);
            }
        });

        TradeDataValidation.testIfAnyDisputeTriedReplay(disputes,
                disputeReplayException -> {
                    log.error(disputeReplayException.toString());
                    validationExceptions.add(disputeReplayException);
                });
    }

    public boolean isTrader(Dispute dispute) {
        return pubKeyRing.equals(dispute.getTraderPubKeyRing());
    }


    public Optional<Dispute> findOwnDispute(String tradeId) {
        T disputeList = getDisputeList();
        if (disputeList == null) {
            log.warn(""disputes is null"");
            return Optional.empty();
        }
        return disputeList.stream().filter(e -> e.getTradeId().equals(tradeId)).findAny();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Message handler
    ///////////////////////////////////////////////////////////////////////////////////////////

    // dispute agent receives that from trader who opens dispute
    protected void onOpenNewDisputeMessage(OpenNewDisputeMessage openNewDisputeMessage) {
        T disputeList = getDisputeList();
        if (disputeList == null) {
            log.warn(""disputes is null"");
            return;
        }

        String errorMessage = null;
        Dispute dispute = openNewDisputeMessage.getDispute();
        // Disputes from clients < 1.2.0 always have support type ARBITRATION in dispute as the field didn't exist before
        dispute.setSupportType(openNewDisputeMessage.getSupportType());
        // disputes from clients < 1.6.0 have state not set as the field didn't exist before
        dispute.setState(Dispute.State.NEW);    // this can be removed a few months after 1.6.0 release

        Contract contract = dispute.getContract();
        addPriceInfoMessage(dispute, 0);

        PubKeyRing peersPubKeyRing = dispute.isDisputeOpenerIsBuyer() ? contract.getSellerPubKeyRing() : contract.getBuyerPubKeyRing();
        if (isAgent(dispute)) {
            if (!disputeList.contains(dispute)) {
                Optional<Dispute> storedDisputeOptional = findDispute(dispute);
                if (!storedDisputeOptional.isPresent()) {
                    disputeList.add(dispute);
                    sendPeerOpenedDisputeMessage(dispute, contract, peersPubKeyRing);
                } else {
                    // valid case if both have opened a dispute and agent was not online.
                    log.debug(""We got a dispute already open for that trade and trading peer. TradeId = {}"",
                            dispute.getTradeId());
                }
            } else {
                errorMessage = ""We got a dispute msg what we have already stored. TradeId = "" + dispute.getTradeId();
                log.warn(errorMessage);
            }
        } else {
            errorMessage = ""Trader received openNewDisputeMessage. That must never happen."";
            log.error(errorMessage);
        }

        // We use the ChatMessage not the openNewDisputeMessage for the ACK
        ObservableList<ChatMessage> messages = dispute.getChatMessages();
        if (!messages.isEmpty()) {
            ChatMessage chatMessage = messages.get(0);
            PubKeyRing sendersPubKeyRing = dispute.isDisputeOpenerIsBuyer() ? contract.getBuyerPubKeyRing() : contract.getSellerPubKeyRing();
            sendAckMessage(chatMessage, sendersPubKeyRing, errorMessage == null, errorMessage);
        }

        addMediationResultMessage(dispute);

        try {
            TradeDataValidation.validateDonationAddress(dispute.getDonationAddressOfDelayedPayoutTx(), daoFacade);
            TradeDataValidation.testIfDisputeTriesReplay(dispute, disputeList.getList());
            TradeDataValidation.validateNodeAddress(dispute, dispute.getContract().getBuyerNodeAddress(), config);
            TradeDataValidation.validateNodeAddress(dispute, dispute.getContract().getSellerNodeAddress(), config);
        } catch (TradeDataValidation.AddressException |
                TradeDataValidation.DisputeReplayException |
                TradeDataValidation.NodeAddressException e) {
            log.error(e.toString());
            validationExceptions.add(e);
        }
        requestPersistence();
    }

    // Not-dispute-requester receives that msg from dispute agent
    protected void onPeerOpenedDisputeMessage(PeerOpenedDisputeMessage peerOpenedDisputeMessage) {
        T disputeList = getDisputeList();
        if (disputeList == null) {
            log.warn(""disputes is null"");
            return;
        }

        String errorMessage = null;
        Dispute dispute = peerOpenedDisputeMessage.getDispute();

        Optional<Trade> optionalTrade = tradeManager.getTradeById(dispute.getTradeId());
        if (!optionalTrade.isPresent()) {
            return;
        }

        Trade trade = optionalTrade.get();
        try {
            TradeDataValidation.validateDelayedPayoutTx(trade,
                    trade.getDelayedPayoutTx(),
                    dispute,
                    daoFacade,
                    btcWalletService);
        } catch (TradeDataValidation.ValidationException e) {
            // The peer sent us an invalid donation address. We do not return here as we don't want to break
            // mediation/arbitration and log only the issue. The dispute agent will run validation as well and will get
            // a popup displayed to react.
            log.warn(""Donation address is invalid. {}"", e.toString());
        }

        if (!isAgent(dispute)) {
            if (!disputeList.contains(dispute)) {
                Optional<Dispute> storedDisputeOptional = findDispute(dispute);
                if (!storedDisputeOptional.isPresent()) {
                    disputeList.add(dispute);
                    trade.setDisputeState(getDisputeStateStartedByPeer());
                    tradeManager.requestPersistence();
                    errorMessage = null;
                } else {
                    // valid case if both have opened a dispute and agent was not online.
                    log.debug(""We got a dispute already open for that trade and trading peer. TradeId = {}"",
                            dispute.getTradeId());
                }
            } else {
                errorMessage = ""We got a dispute msg what we have already stored. TradeId = "" + dispute.getTradeId();
                log.warn(errorMessage);
            }
        } else {
            errorMessage = ""Arbitrator received peerOpenedDisputeMessage. That must never happen."";
            log.error(errorMessage);
        }

        // We use the ChatMessage not the peerOpenedDisputeMessage for the ACK
        ObservableList<ChatMessage> messages = peerOpenedDisputeMessage.getDispute().getChatMessages();
        if (!messages.isEmpty()) {
            ChatMessage msg = messages.get(0);
            sendAckMessage(msg, dispute.getAgentPubKeyRing(), errorMessage == null, errorMessage);
        }

        sendAckMessage(peerOpenedDisputeMessage, dispute.getAgentPubKeyRing(), errorMessage == null, errorMessage);
        requestPersistence();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Send message
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void sendOpenNewDisputeMessage(Dispute dispute,
                                          boolean reOpen,
                                          ResultHandler resultHandler,
                                          FaultHandler faultHandler) {
        T disputeList = getDisputeList();
        if (disputeList == null) {
            log.warn(""disputes is null"");
            return;
        }

        if (disputeList.contains(dispute)) {
            String msg = ""We got a dispute msg what we have already stored. TradeId = "" + dispute.getTradeId();
            log.warn(msg);
            faultHandler.handleFault(msg, new DisputeAlreadyOpenException());
            return;
        }

        Optional<Dispute> storedDisputeOptional = findDispute(dispute);
        if (!storedDisputeOptional.isPresent() || reOpen) {
            String disputeInfo = getDisputeInfo(dispute);
            String disputeMessage = getDisputeIntroForDisputeCreator(disputeInfo);
            String sysMsg = dispute.isSupportTicket() ?
                    Res.get(""support.youOpenedTicket"", disputeInfo, Version.VERSION)
                    : disputeMessage;

            String message = Res.get(""support.systemMsg"", sysMsg);
            ChatMessage chatMessage = new ChatMessage(
                    getSupportType(),
                    dispute.getTradeId(),
                    pubKeyRing.hashCode(),
                    false,
                    message,
                    p2PService.getAddress());
            chatMessage.setSystemMessage(true);
            dispute.addAndPersistChatMessage(chatMessage);
            if (!reOpen) {
                disputeList.add(dispute);
            }

            NodeAddress agentNodeAddress = getAgentNodeAddress(dispute);
            if (agentNodeAddress == null) {
                return;
            }

            OpenNewDisputeMessage openNewDisputeMessage = new OpenNewDisputeMessage(dispute,
                    p2PService.getAddress(),
                    UUID.randomUUID().toString(),
                    getSupportType());

            log.info(""Send {} to peer {}. tradeId={}, openNewDisputeMessage.uid={}, chatMessage.uid={}"",
                    openNewDisputeMessage.getClass().getSimpleName(),
                    agentNodeAddress,
                    openNewDisputeMessage.getTradeId(),
                    openNewDisputeMessage.getUid(),
                    chatMessage.getUid());

            mailboxMessageService.sendEncryptedMailboxMessage(agentNodeAddress,
                    dispute.getAgentPubKeyRing(),
                    openNewDisputeMessage,
                    new SendMailboxMessageListener() {
                        @Override
                        public void onArrived() {
                            log.info(""{} arrived at peer {}. tradeId={}, openNewDisputeMessage.uid={}, "" +
                                            ""chatMessage.uid={}"",
                                    openNewDisputeMessage.getClass().getSimpleName(), agentNodeAddress,
                                    openNewDisputeMessage.getTradeId(), openNewDisputeMessage.getUid(),
                                    chatMessage.getUid());

                            // We use the chatMessage wrapped inside the openNewDisputeMessage for
                            // the state, as that is displayed to the user and we only persist that msg
                            chatMessage.setArrived(true);
                            requestPersistence();
                            resultHandler.handleResult();
                        }

                        @Override
                        public void onStoredInMailbox() {
                            log.info(""{} stored in mailbox for peer {}. tradeId={}, openNewDisputeMessage.uid={}, "" +
                                            ""chatMessage.uid={}"",
                                    openNewDisputeMessage.getClass().getSimpleName(), agentNodeAddress,
                                    openNewDisputeMessage.getTradeId(), openNewDisputeMessage.getUid(),
                                    chatMessage.getUid());

                            // We use the chatMessage wrapped inside the openNewDisputeMessage for
                            // the state, as that is displayed to the user and we only persist that msg
                            chatMessage.setStoredInMailbox(true);
                            requestPersistence();
                            resultHandler.handleResult();
                        }

                        @Override
                        public void onFault(String errorMessage) {
                            log.error(""{} failed: Peer {}. tradeId={}, openNewDisputeMessage.uid={}, "" +
                                            ""chatMessage.uid={}, errorMessage={}"",
                                    openNewDisputeMessage.getClass().getSimpleName(), agentNodeAddress,
                                    openNewDisputeMessage.getTradeId(), openNewDisputeMessage.getUid(),
                                    chatMessage.getUid(), errorMessage);

                            // We use the chatMessage wrapped inside the openNewDisputeMessage for
                            // the state, as that is displayed to the user and we only persist that msg
                            chatMessage.setSendMessageError(errorMessage);
                            requestPersistence();
                            faultHandler.handleFault(""Sending dispute message failed: "" +
                                    errorMessage, new DisputeMessageDeliveryFailedException());
                        }
                    }
            );
        } else {
            String msg = ""We got a dispute already open for that trade and trading peer.\n"" +
                    ""TradeId = "" + dispute.getTradeId();
            log.warn(msg);
            faultHandler.handleFault(msg, new DisputeAlreadyOpenException());
        }
        requestPersistence();
    }

    // Dispute agent sends that to trading peer when he received openDispute request
    private void sendPeerOpenedDisputeMessage(Dispute disputeFromOpener,
                                              Contract contractFromOpener,
                                              PubKeyRing pubKeyRing) {
        // We delay a bit for sending the message to the peer to allow that a openDispute message from the peer is
        // being used as the valid msg. If dispute agent was offline and both peer requested we want to see the correct
        // message and not skip the system message of the peer as it would be the case if we have created the system msg
        // from the code below.
        UserThread.runAfter(() -> doSendPeerOpenedDisputeMessage(disputeFromOpener,
                contractFromOpener,
                pubKeyRing),
                100, TimeUnit.MILLISECONDS);
    }

    private void doSendPeerOpenedDisputeMessage(Dispute disputeFromOpener,
                                                Contract contractFromOpener,
                                                PubKeyRing pubKeyRing) {
        T disputeList = getDisputeList();
        if (disputeList == null) {
            log.warn(""disputes is null"");
            return;
        }

        Dispute dispute = new Dispute(new Date().getTime(),
                disputeFromOpener.getTradeId(),
                pubKeyRing.hashCode(),
                !disputeFromOpener.isDisputeOpenerIsBuyer(),
                !disputeFromOpener.isDisputeOpenerIsMaker(),
                pubKeyRing,
                disputeFromOpener.getTradeDate().getTime(),
                disputeFromOpener.getTradePeriodEnd().getTime(),
                contractFromOpener,
                disputeFromOpener.getContractHash(),
                disputeFromOpener.getDepositTxSerialized(),
                disputeFromOpener.getPayoutTxSerialized(),
                disputeFromOpener.getDepositTxId(),
                disputeFromOpener.getPayoutTxId(),
                disputeFromOpener.getContractAsJson(),
                disputeFromOpener.getMakerContractSignature(),
                disputeFromOpener.getTakerContractSignature(),
                disputeFromOpener.getAgentPubKeyRing(),
                disputeFromOpener.isSupportTicket(),
                disputeFromOpener.getSupportType());
        dispute.setExtraDataMap(disputeFromOpener.getExtraDataMap());
        dispute.setDelayedPayoutTxId(disputeFromOpener.getDelayedPayoutTxId());
        dispute.setDonationAddressOfDelayedPayoutTx(disputeFromOpener.getDonationAddressOfDelayedPayoutTx());

        Optional<Dispute> storedDisputeOptional = findDispute(dispute);

        // Valid case if both have opened a dispute and agent was not online.
        if (storedDisputeOptional.isPresent()) {
            log.info(""We got a dispute already open for that trade and trading peer. TradeId = {}"", dispute.getTradeId());
            return;
        }

        String disputeInfo = getDisputeInfo(dispute);
        String disputeMessage = getDisputeIntroForPeer(disputeInfo);
        String sysMsg = dispute.isSupportTicket() ?
                Res.get(""support.peerOpenedTicket"", disputeInfo, Version.VERSION)
                : disputeMessage;
        ChatMessage chatMessage = new ChatMessage(
                getSupportType(),
                dispute.getTradeId(),
                pubKeyRing.hashCode(),
                false,
                Res.get(""support.systemMsg"", sysMsg),
                p2PService.getAddress());
        chatMessage.setSystemMessage(true);
        dispute.addAndPersistChatMessage(chatMessage);

        addPriceInfoMessage(dispute, 0);

        disputeList.add(dispute);

        // We mirrored dispute already!
        Contract contract = dispute.getContract();
        PubKeyRing peersPubKeyRing = dispute.isDisputeOpenerIsBuyer() ? contract.getBuyerPubKeyRing() : contract.getSellerPubKeyRing();
        NodeAddress peersNodeAddress = dispute.isDisputeOpenerIsBuyer() ? contract.getBuyerNodeAddress() : contract.getSellerNodeAddress();
        PeerOpenedDisputeMessage peerOpenedDisputeMessage = new PeerOpenedDisputeMessage(dispute,
                p2PService.getAddress(),
                UUID.randomUUID().toString(),
                getSupportType());

        log.info(""Send {} to peer {}. tradeId={}, peerOpenedDisputeMessage.uid={}, chatMessage.uid={}"",
                peerOpenedDisputeMessage.getClass().getSimpleName(), peersNodeAddress,
                peerOpenedDisputeMessage.getTradeId(), peerOpenedDisputeMessage.getUid(),
                chatMessage.getUid());

        mailboxMessageService.sendEncryptedMailboxMessage(peersNodeAddress,
                peersPubKeyRing,
                peerOpenedDisputeMessage,
                new SendMailboxMessageListener() {
                    @Override
                    public void onArrived() {
                        log.info(""{} arrived at peer {}. tradeId={}, peerOpenedDisputeMessage.uid={}, "" +
                                        ""chatMessage.uid={}"",
                                peerOpenedDisputeMessage.getClass().getSimpleName(), peersNodeAddress,
                                peerOpenedDisputeMessage.getTradeId(), peerOpenedDisputeMessage.getUid(),
                                chatMessage.getUid());

                        // We use the chatMessage wrapped inside the peerOpenedDisputeMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setArrived(true);
                        requestPersistence();
                    }

                    @Override
                    public void onStoredInMailbox() {
                        log.info(""{} stored in mailbox for peer {}. tradeId={}, peerOpenedDisputeMessage.uid={}, "" +
                                        ""chatMessage.uid={}"",
                                peerOpenedDisputeMessage.getClass().getSimpleName(), peersNodeAddress,
                                peerOpenedDisputeMessage.getTradeId(), peerOpenedDisputeMessage.getUid(),
                                chatMessage.getUid());

                        // We use the chatMessage wrapped inside the peerOpenedDisputeMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setStoredInMailbox(true);
                        requestPersistence();
                    }

                    @Override
                    public void onFault(String errorMessage) {
                        log.error(""{} failed: Peer {}. tradeId={}, peerOpenedDisputeMessage.uid={}, "" +
                                        ""chatMessage.uid={}, errorMessage={}"",
                                peerOpenedDisputeMessage.getClass().getSimpleName(), peersNodeAddress,
                                peerOpenedDisputeMessage.getTradeId(), peerOpenedDisputeMessage.getUid(),
                                chatMessage.getUid(), errorMessage);

                        // We use the chatMessage wrapped inside the peerOpenedDisputeMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setSendMessageError(errorMessage);
                        requestPersistence();
                    }
                }
        );
        requestPersistence();
    }

    // dispute agent send result to trader
    public void sendDisputeResultMessage(DisputeResult disputeResult, Dispute dispute, String summaryText) {
        T disputeList = getDisputeList();
        if (disputeList == null) {
            log.warn(""disputes is null"");
            return;
        }

        ChatMessage chatMessage = new ChatMessage(
                getSupportType(),
                dispute.getTradeId(),
                dispute.getTraderPubKeyRing().hashCode(),
                false,
                summaryText,
                p2PService.getAddress());

        disputeResult.setChatMessage(chatMessage);
        dispute.addAndPersistChatMessage(chatMessage);

        NodeAddress peersNodeAddress;
        Contract contract = dispute.getContract();
        if (contract.getBuyerPubKeyRing().equals(dispute.getTraderPubKeyRing()))
            peersNodeAddress = contract.getBuyerNodeAddress();
        else
            peersNodeAddress = contract.getSellerNodeAddress();
        DisputeResultMessage disputeResultMessage = new DisputeResultMessage(disputeResult,
                p2PService.getAddress(),
                UUID.randomUUID().toString(),
                getSupportType());
        log.info(""Send {} to peer {}. tradeId={}, disputeResultMessage.uid={}, chatMessage.uid={}"",
                disputeResultMessage.getClass().getSimpleName(), peersNodeAddress, disputeResultMessage.getTradeId(),
                disputeResultMessage.getUid(), chatMessage.getUid());
        mailboxMessageService.sendEncryptedMailboxMessage(peersNodeAddress,
                dispute.getTraderPubKeyRing(),
                disputeResultMessage,
                new SendMailboxMessageListener() {
                    @Override
                    public void onArrived() {
                        log.info(""{} arrived at peer {}. tradeId={}, disputeResultMessage.uid={}, "" +
                                        ""chatMessage.uid={}"",
                                disputeResultMessage.getClass().getSimpleName(), peersNodeAddress,
                                disputeResultMessage.getTradeId(), disputeResultMessage.getUid(),
                                chatMessage.getUid());

                        // We use the chatMessage wrapped inside the disputeResultMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setArrived(true);
                        requestPersistence();
                    }

                    @Override
                    public void onStoredInMailbox() {
                        log.info(""{} stored in mailbox for peer {}. tradeId={}, disputeResultMessage.uid={}, "" +
                                        ""chatMessage.uid={}"",
                                disputeResultMessage.getClass().getSimpleName(), peersNodeAddress,
                                disputeResultMessage.getTradeId(), disputeResultMessage.getUid(),
                                chatMessage.getUid());

                        // We use the chatMessage wrapped inside the disputeResultMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setStoredInMailbox(true);
                        requestPersistence();
                    }

                    @Override
                    public void onFault(String errorMessage) {
                        log.error(""{} failed: Peer {}. tradeId={}, disputeResultMessage.uid={}, "" +
                                        ""chatMessage.uid={}, errorMessage={}"",
                                disputeResultMessage.getClass().getSimpleName(), peersNodeAddress,
                                disputeResultMessage.getTradeId(), disputeResultMessage.getUid(),
                                chatMessage.getUid(), errorMessage);

                        // We use the chatMessage wrapped inside the disputeResultMessage for
                        // the state, as that is displayed to the user and we only persist that msg
                        chatMessage.setSendMessageError(errorMessage);
                        requestPersistence();
                    }
                }
        );
        requestPersistence();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////////////////////////////////////////

    private Tuple2<NodeAddress, PubKeyRing> getNodeAddressPubKeyRingTuple(Dispute dispute) {
        PubKeyRing receiverPubKeyRing = null;
        NodeAddress peerNodeAddress = null;
        if (isTrader(dispute)) {
            receiverPubKeyRing = dispute.getAgentPubKeyRing();
            peerNodeAddress = getAgentNodeAddress(dispute);
        } else if (isAgent(dispute)) {
            receiverPubKeyRing = dispute.getTraderPubKeyRing();
            Contract contract = dispute.getContract();
            if (contract.getBuyerPubKeyRing().equals(receiverPubKeyRing))
                peerNodeAddress = contract.getBuyerNodeAddress();
            else
                peerNodeAddress = contract.getSellerNodeAddress();
        } else {
            log.error(""That must not happen. Trader cannot communicate to other trader."");
        }
        return new Tuple2<>(peerNodeAddress, receiverPubKeyRing);
    }

    private boolean isAgent(Dispute dispute) {
        return pubKeyRing.equals(dispute.getAgentPubKeyRing());
    }

    private Optional<Dispute> findDispute(Dispute dispute) {
        return findDispute(dispute.getTradeId(), dispute.getTraderId());
    }

    protected Optional<Dispute> findDispute(DisputeResult disputeResult) {
        ChatMessage chatMessage = disputeResult.getChatMessage();
        checkNotNull(chatMessage, ""chatMessage must not be null"");
        return findDispute(disputeResult.getTradeId(), disputeResult.getTraderId());
    }

    private Optional<Dispute> findDispute(ChatMessage message) {
        return findDispute(message.getTradeId(), message.getTraderId());
    }

    private Optional<Dispute> findDispute(String tradeId, int traderId) {
        T disputeList = getDisputeList();
        if (disputeList == null) {
            log.warn(""disputes is null"");
            return Optional.empty();
        }
        return disputeList.stream()
                .filter(e -> e.getTradeId().equals(tradeId) && e.getTraderId() == traderId)
                .findAny();
    }

    public Optional<Dispute> findDispute(String tradeId) {
        T disputeList = getDisputeList();
        if (disputeList == null) {
            log.warn(""disputes is null"");
            return Optional.empty();
        }
        return disputeList.stream()
                .filter(e -> e.getTradeId().equals(tradeId))
                .findAny();
    }

    public Optional<Trade> findTrade(Dispute dispute) {
        Optional<Trade> retVal = tradeManager.getTradeById(dispute.getTradeId());
        if (!retVal.isPresent()) {
            retVal = closedTradableManager.getClosedTrades().stream().filter(e -> e.getId().equals(dispute.getTradeId())).findFirst();
        }
        return retVal;
    }

    private void addMediationResultMessage(Dispute dispute) {
        // In case of refundAgent we add a message with the mediatorsDisputeSummary. Only visible for refundAgent.
        if (dispute.getMediatorsDisputeResult() != null) {
            String mediatorsDisputeResult = Res.get(""support.mediatorsDisputeSummary"", dispute.getMediatorsDisputeResult());
            ChatMessage mediatorsDisputeResultMessage = new ChatMessage(
                    getSupportType(),
                    dispute.getTradeId(),
                    pubKeyRing.hashCode(),
                    false,
                    mediatorsDisputeResult,
                    p2PService.getAddress());
            mediatorsDisputeResultMessage.setSystemMessage(true);
            dispute.addAndPersistChatMessage(mediatorsDisputeResultMessage);
            requestPersistence();
        }
    }

    public void addMediationReOpenedMessage(Dispute dispute, boolean senderIsTrader) {
        ChatMessage chatMessage = new ChatMessage(
                getSupportType(),
                dispute.getTradeId(),
                dispute.getTraderId(),
                senderIsTrader,
                Res.get(""support.info.disputeReOpened""),
                p2PService.getAddress());
        chatMessage.setSystemMessage(false);
        dispute.addAndPersistChatMessage(chatMessage);
        this.sendChatMessage(chatMessage);
        requestPersistence();
    }

    // If price was going down between take offer time and open dispute time the buyer has an incentive to
    // not send the payment but to try to make a new trade with the better price. We risks to lose part of the
    // security deposit (in mediation we will always get back 0.003 BTC to keep some incentive to accept mediated
    // proposal). But if gain is larger than this loss he has economically an incentive to default in the trade.
    // We do all those calculations to give a hint to mediators to detect option trades.
    protected void addPriceInfoMessage(Dispute dispute, int counter) {
        if (!priceFeedService.hasPrices()) {
            if (counter < 3) {
                log.info(""Price provider has still no data. This is expected at startup. We try again in 10 sec."");
                UserThread.runAfter(() -> addPriceInfoMessage(dispute, counter + 1), 10);
            } else {
                log.warn(""Price provider still has no data after 3 repeated requests and 30 seconds delay. We give up."");
            }
            return;
        }

        Contract contract = dispute.getContract();
        OfferPayload offerPayload = contract.getOfferPayload();
        Price priceAtDisputeOpening = getPrice(offerPayload.getCurrencyCode());
        if (priceAtDisputeOpening == null) {
            log.info(""Price provider did not provide a price for {}. "" +
                            ""This is expected if this currency is not supported by the price providers."",
                    offerPayload.getCurrencyCode());
            return;
        }

        // The amount we would get if we do a new trade with current price
        Coin potentialAmountAtDisputeOpening = priceAtDisputeOpening.getAmountByVolume(contract.getTradeVolume());
        Coin buyerSecurityDeposit = Coin.valueOf(offerPayload.getBuyerSecurityDeposit());
        Coin minRefundAtMediatedDispute = Restrictions.getMinRefundAtMediatedDispute();
        // minRefundAtMediatedDispute is always larger as buyerSecurityDeposit at mediated payout, we ignore refund agent case here as there it can be 0.
        Coin maxLossSecDeposit = buyerSecurityDeposit.subtract(minRefundAtMediatedDispute);
        Coin tradeAmount = contract.getTradeAmount();
        Coin potentialGain = potentialAmountAtDisputeOpening.subtract(tradeAmount).subtract(maxLossSecDeposit);
        String optionTradeDetails;
        // We don't translate those strings (yet) as it is only displayed to mediators/arbitrators.
        String headline;
        if (potentialGain.isPositive()) {
            headline = ""This might be a potential option trade!"";
            optionTradeDetails = ""\nBTC amount calculated with price at dispute opening: "" + potentialAmountAtDisputeOpening.toFriendlyString() +
                    ""\nMax loss of security deposit is: "" + maxLossSecDeposit.toFriendlyString() +
                    ""\nPossible gain from an option trade is: "" + potentialGain.toFriendlyString();
        } else {
            headline = ""It does not appear to be an option trade."";
            optionTradeDetails = ""\nBTC amount calculated with price at dispute opening: "" + potentialAmountAtDisputeOpening.toFriendlyString() +
                    ""\nMax loss of security deposit is: "" + maxLossSecDeposit.toFriendlyString() +
                    ""\nPossible loss from an option trade is: "" + potentialGain.multiply(-1).toFriendlyString();
        }

        String percentagePriceDetails = offerPayload.isUseMarketBasedPrice() ?
                "" (market based price was used: "" + offerPayload.getMarketPriceMargin() * 100 + ""%)"" :
                "" (fix price was used)"";

        String priceInfoText = ""System message: "" + headline +
                ""\n\nTrade price: "" + contract.getTradePrice().toFriendlyString() + percentagePriceDetails +
                ""\nTrade amount: "" + tradeAmount.toFriendlyString() +
                ""\nPrice at dispute opening: "" + priceAtDisputeOpening.toFriendlyString() +
                optionTradeDetails;

        // We use the existing msg to copy over the users data
        ChatMessage priceInfoMessage = new ChatMessage(
                getSupportType(),
                dispute.getTradeId(),
                pubKeyRing.hashCode(),
                false,
                priceInfoText,
                p2PService.getAddress());
        priceInfoMessage.setSystemMessage(true);
        dispute.addAndPersistChatMessage(priceInfoMessage);
        requestPersistence();
    }

    @Nullable
    private Price getPrice(String currencyCode) {
        MarketPrice marketPrice = priceFeedService.getMarketPrice(currencyCode);
        if (marketPrice != null && marketPrice.isRecentExternalPriceAvailable()) {
            double marketPriceAsDouble = marketPrice.getPrice();
            try {
                int precision = CurrencyUtil.isCryptoCurrency(currencyCode) ?
                        Altcoin.SMALLEST_UNIT_EXPONENT :
                        Fiat.SMALLEST_UNIT_EXPONENT;
                double scaled = MathUtils.scaleUpByPowerOf10(marketPriceAsDouble, precision);
                long roundedToLong = MathUtils.roundDoubleToLong(scaled);
                return Price.valueOf(currencyCode, roundedToLong);
            } catch (Exception e) {
                log.error(""Exception at getPrice / parseToFiat: "" + e.toString());
                return null;
            }
        } else {
            return null;
        }
    }
}",1,64 2000 439 305 334 2001 60 2002 378 2003 60 2004 641 378 2005 123 438 381 2006 2007 59 438 381 2008 2009 59 438 381 2010 2011 59 438 381 2012 2013 59 438 381 2014 2015 59 438 381 2016 2017 59 438 381 2018 60 2002 62 2019 59 437 381 2020 2021 59 437 381 2022 2023 59 438 381 2024 2025 59 64 2026 438 381 2027 60 2028 46 2029 62 2030 61 2031 46 2032 40 41 59 64 2026 437 381 2033 2034 59 621 621 621 439 2001 40 2035 2036 44 2006 2007 44 2008 2009 44 2037 2038 44 2010 2011 44 2012 2013 44 2014 2015 44 2024 2025 44 2039 2040 44 2018 60 2002 62 2019 44 2020 2021 44 2022 2023 41 123 463 40 2036 44 2038 41 59 467 46 2007 61 2007 59 467 46 2009 61 2009 59 467 46 2011 61 2011 59 467 46 2013 61 2013 59 467 46 2015 61 2015 59 467 46 2025 61 2025 59 467 46 2017 61 2040 46 2041 40 41 59 2034 61 2040 46 2042 40 41 59 467 46 2019 61 2019 59 467 46 2021 61 2021 59 467 46 2023 61 2023 59 125 621 621 621 64 2043 439 492 2044 40 41 123 2019 46 2044 40 41 59 125 64 2043 439 2045 2046 40 2047 2048 41 123 2049 60 2004 62 2050 61 2051 40 2048 41 59 392 40 33 2050 46 2052 40 41 41 123 2053 46 2054 40 648 44 2048 46 2055 40 41 44 2048 46 2056 40 41 41 59 450 424 59 125 450 2057 40 2050 46 2058 40 41 41 46 2059 59 125 64 2043 439 2016 2060 40 2047 2048 41 123 2061 60 2004 62 2062 61 2063 40 2048 41 59 392 40 33 2062 46 2064 40 41 41 123 2065 46 2066 40 648 44 2048 46 2067 40 41 44 2048 46 2068 40 41 41 59 450 424 59 125 450 2069 40 2062 46 2070 40 41 41 46 2071 59 125 64 2043 439 2072 60 2047 62 2073 40 2074 2075 41 123 450 2076 40 41 46 2077 40 41 46 2078 40 2079 45 62 2079 46 2080 40 41 46 2081 40 2075 41 41 46 2082 40 2079 45 62 2079 46 2083 40 41 46 2077 40 41 41 46 2084 40 2085 46 2086 40 41 41 59 125 64 2043 439 324 2087 40 2047 2048 41 123 450 2088 40 2048 41 46 2089 40 41 59 125 64 2043 439 492 2090 40 2047 2048 41 123 2091 40 2048 41 46 2092 40 2093 45 62 123 392 40 2093 46 2094 40 41 46 2095 40 41 46 2096 40 2097 45 62 2097 46 2098 40 41 46 2099 40 2048 46 2098 40 41 41 41 41 123 2093 46 2090 40 2048 41 59 2044 40 41 59 125 360 123 2100 46 2101 40 648 44 2048 46 2098 40 41 44 2048 46 2102 40 41 41 59 125 125 41 59 125 621 621 621 621 439 305 492 2103 40 2104 2105 41 59 64 2106 439 305 2045 2107 40 2004 2108 41 59 438 305 2109 46 2110 2111 40 41 59 439 305 492 2112 40 41 59 438 305 2074 2113 40 2004 2108 41 59 438 305 2074 2114 40 2074 2115 41 59 438 305 2074 2116 40 2074 2115 41 59 621 621 621 439 2117 2118 40 41 123 450 2019 46 2118 40 41 59 125 439 2027 60 2004 62 2119 40 41 123 450 2019 46 2120 40 41 59 125 439 2074 2121 40 324 2122 44 2123 2124 41 123 450 2019 46 2121 40 2122 44 2124 41 59 125 438 2002 2125 40 41 123 450 2019 46 2125 40 41 59 125 439 2126 60 2074 62 2127 40 41 123 450 2019 46 2127 40 41 59 125 621 621 621 439 492 2128 40 41 123 463 46 2128 40 41 59 2019 46 2128 40 41 59 2036 46 2129 40 418 2130 40 41 123 64 2043 439 492 2131 40 41 123 2132 40 41 59 125 125 41 59 2038 46 2133 40 41 46 2134 40 40 2135 44 2136 44 2137 41 45 62 123 392 40 2038 46 2138 40 41 41 2139 40 41 59 125 41 59 2038 46 2140 40 41 46 2134 40 40 2135 44 2136 44 2137 41 45 62 123 392 40 2038 46 2141 40 41 41 2142 40 41 59 125 41 59 2143 40 41 59 2112 40 41 59 2072 60 2004 62 2144 61 2125 40 41 46 2145 40 41 59 2144 46 2146 40 2108 45 62 123 474 123 2028 46 2147 40 2108 44 2108 46 2148 40 41 44 2025 41 59 2028 46 2149 40 2108 44 2108 46 2150 40 41 46 2151 40 41 44 2021 41 59 2028 46 2149 40 2108 44 2108 46 2150 40 41 46 2152 40 41 44 2021 41 59 125 329 40 2028 46 2153 124 2028 46 2154 2155 41 123 2156 46 371 40 2155 46 2157 40 41 41 59 2030 46 2158 40 2155 41 59 125 125 41 59 2028 46 2159 40 2144 44 2160 45 62 123 2161 46 371 40 2160 46 2162 40 41 41 59 2030 46 2163 40 2160 41 59 125 41 59 125 439 324 2164 40 2004 2108 41 123 450 2017 46 2165 40 2108 46 2166 40 41 41 59 125 439 2167 60 2004 62 2168 40 2074 2075 41 123 2002 2169 61 2125 40 41 59 392 40 2169 614 424 41 123 2170 46 2171 40 648 41 59 450 2167 46 362 40 41 59 125 450 2169 46 2172 40 41 46 2173 40 2174 45 62 2174 46 2175 40 41 46 2176 40 2075 41 41 46 2177 40 41 59 125 621 621 621 621 438 492 2178 40 2179 2180 41 123 2002 2181 61 2125 40 41 59 392 40 2181 614 424 41 123 2182 46 2183 40 648 41 59 450 59 125 2074 2184 61 424 59 2004 2108 61 2180 46 2185 40 41 59 621 2108 46 2186 40 2180 46 2187 40 41 41 59 621 2108 46 2188 40 2004 46 2189 46 2190 41 59 621 2123 2124 61 2108 46 2191 40 41 59 2192 40 2108 44 1500 41 59 2016 2193 61 2108 46 2194 40 41 63 2124 46 2195 40 41 58 2124 46 2196 40 41 59 392 40 2197 40 2108 41 41 123 392 40 33 2181 46 2198 40 2108 41 41 123 2167 60 2004 62 2199 61 2200 40 2108 41 59 392 40 33 2199 46 2201 40 41 41 123 2181 46 2202 40 2108 41 59 2203 40 2108 44 2124 44 2193 41 59 125 360 123 621 2204 46 2205 40 648 44 2108 46 2206 40 41 41 59 125 125 360 123 2184 61 648 43 2108 46 2207 40 41 59 2208 46 2209 40 2184 41 59 125 125 360 123 2184 61 648 59 2210 46 371 40 2184 41 59 125 621 2027 60 2047 62 2211 61 2108 46 2212 40 41 59 392 40 33 2211 46 2213 40 41 41 123 2047 2214 61 2211 46 2215 40 1500 41 59 2016 2216 61 2108 46 2194 40 41 63 2124 46 2196 40 41 58 2124 46 2195 40 41 59 2217 40 2214 44 2216 44 2184 614 424 44 2184 41 59 125 2218 40 2108 41 59 474 123 2028 46 2219 40 2108 46 2220 40 41 44 2025 41 59 2028 46 2221 40 2108 44 2181 46 2222 40 41 41 59 2028 46 2223 40 2108 44 2108 46 2191 40 41 46 2224 40 41 44 2021 41 59 2028 46 2223 40 2108 44 2108 46 2191 40 41 46 2225 40 41 44 2021 41 59 125 329 40 2028 46 2226 124 2028 46 2227 124 2028 46 2228 2229 41 123 2230 46 371 40 2229 46 2231 40 41 41 59 2030 46 2232 40 2229 41 59 125 2044 40 41 59 125 621 438 492 2233 40 2234 2235 41 123 2002 2236 61 2125 40 41 59 392 40 2236 614 424 41 123 2237 46 2238 40 648 41 59 450 59 125 2074 2239 61 424 59 2004 2108 61 2235 46 2240 40 41 59 2167 60 2109 62 2241 61 2011 46 2242 40 2108 46 2243 40 41 41 59 392 40 33 2241 46 2244 40 41 41 123 450 59 125 2109 2245 61 2241 46 2246 40 41 59 474 123 2028 46 2247 40 2245 44 2245 46 2248 40 41 44 2108 44 2025 44 2009 41 59 125 329 40 2028 46 2029 2249 41 123 621 621 621 2250 46 2251 40 648 44 2249 46 2252 40 41 41 59 125 392 40 33 2253 40 2108 41 41 123 392 40 33 2236 46 2254 40 2108 41 41 123 2167 60 2004 62 2255 61 2256 40 2108 41 59 392 40 33 2255 46 2244 40 41 41 123 2236 46 2257 40 2108 41 59 2245 46 2258 40 2111 40 41 41 59 2011 46 2044 40 41 59 2239 61 424 59 125 360 123 621 2259 46 2260 40 648 44 2108 46 2243 40 41 41 59 125 125 360 123 2239 61 648 43 2108 46 2243 40 41 59 2261 46 2262 40 2239 41 59 125 125 360 123 2239 61 648 59 2263 46 371 40 2239 41 59 125 621 2027 60 2047 62 2264 61 2235 46 2240 40 41 46 2265 40 41 59 392 40 33 2264 46 2266 40 41 41 123 2047 2267 61 2264 46 2246 40 1500 41 59 2268 40 2267 44 2108 46 2269 40 41 44 2239 614 424 44 2239 41 59 125 2270 40 2235 44 2108 46 2271 40 41 44 2239 614 424 44 2239 41 59 2044 40 41 59 125 621 621 621 439 492 2272 40 2004 2108 44 324 2273 44 2274 2275 44 2276 2277 41 123 2002 2278 61 2125 40 41 59 392 40 2278 614 424 41 123 2279 46 2280 40 648 41 59 450 59 125 392 40 2278 46 2281 40 2108 41 41 123 2074 2282 61 648 43 2108 46 2283 40 41 59 2284 46 2285 40 2282 41 59 2277 46 2286 40 2282 44 418 2287 40 41 41 59 450 59 125 2167 60 2004 62 2288 61 2289 40 2108 41 59 392 40 33 2288 46 2290 40 41 606 2273 41 123 2074 2115 61 2113 40 2108 41 59 2074 2291 61 2116 40 2115 41 59 2074 2292 61 2108 46 2293 40 41 63 2294 46 2295 40 648 44 2115 44 2296 46 2297 41 58 2291 59 2074 2048 61 2294 46 2295 40 648 44 2292 41 59 2047 2298 61 418 2047 40 2299 40 41 44 2108 46 2300 40 41 44 2017 46 2301 40 41 44 380 44 2048 44 2036 46 2302 40 41 41 59 2298 46 2303 40 473 41 59 2108 46 2090 40 2298 41 59 392 40 33 2273 41 123 2278 46 2304 40 2108 41 59 125 2045 2305 61 2107 40 2108 41 59 392 40 2305 614 424 41 123 450 59 125 2179 2180 61 418 2179 40 2108 44 2036 46 2302 40 41 44 2306 46 2307 40 41 46 2308 40 41 44 2299 40 41 41 59 2309 46 2310 40 648 44 2180 46 2311 40 41 46 2312 40 41 44 2305 44 2180 46 2300 40 41 44 2180 46 2313 40 41 44 2298 46 2313 40 41 41 59 2314 46 2315 40 2305 44 2108 46 2316 40 41 44 2180 44 418 2317 40 41 123 64 2043 439 492 2318 40 41 123 2309 46 2310 40 648 43 648 44 2180 46 2311 40 41 46 2312 40 41 44 2305 44 2180 46 2300 40 41 44 2180 46 2313 40 41 44 2298 46 2313 40 41 41 59 621 621 2298 46 2319 40 473 41 59 2044 40 41 59 2275 46 2320 40 41 59 125 64 2043 439 492 2321 40 41 123 2309 46 2310 40 648 43 648 44 2180 46 2311 40 41 46 2312 40 41 44 2305 44 2180 46 2300 40 41 44 2180 46 2313 40 41 44 2298 46 2313 40 41 41 59 621 621 2298 46 2322 40 473 41 59 2044 40 41 59 2275 46 2323 40 41 59 125 64 2043 439 492 2324 40 2074 2325 41 123 2309 46 371 40 648 43 648 44 2180 46 2311 40 41 46 2312 40 41 44 2305 44 2180 46 2300 40 41 44 2180 46 2313 40 41 44 2298 46 2313 40 41 44 2325 41 59 621 621 2298 46 2326 40 2325 41 59 2044 40 41 59 2277 46 2327 40 648 43 2325 44 418 2328 40 41 41 59 125 125 41 59 125 360 123 2074 2329 61 648 43 648 43 2108 46 2330 40 41 59 2331 46 2332 40 2329 41 59 2277 46 2333 40 2329 44 418 2334 40 41 41 59 125 2044 40 41 59 125 621 437 492 2335 40 2004 2336 44 2123 2337 44 2016 2017 41 123 621 621 621 621 2338 46 2339 40 40 41 45 62 2340 40 2336 44 2337 44 2017 41 44 1503 44 2341 46 2342 41 59 125 437 492 2343 40 2004 2336 44 2123 2337 44 2016 2017 41 123 2002 2344 61 2125 40 41 59 392 40 2344 614 424 41 123 2345 46 2346 40 648 41 59 450 59 125 2004 2108 61 418 2004 40 418 2347 40 41 46 2348 40 41 44 2336 46 2349 40 41 44 2017 46 2350 40 41 44 33 2336 46 2351 40 41 44 33 2336 46 2352 40 41 44 2017 44 2336 46 2353 40 41 46 2348 40 41 44 2336 46 2354 40 41 46 2348 40 41 44 2337 44 2336 46 2355 40 41 44 2336 46 2356 40 41 44 2336 46 2357 40 41 44 2336 46 2358 40 41 44 2336 46 2359 40 41 44 2336 46 2360 40 41 44 2336 46 2361 40 41 44 2336 46 2362 40 41 44 2336 46 2363 40 41 44 2336 46 2364 40 41 44 2336 46 2365 40 41 41 59 2108 46 2366 40 2336 46 2367 40 41 41 59 2108 46 2368 40 2336 46 2369 40 41 41 59 2108 46 2370 40 2336 46 2371 40 41 41 59 2167 60 2004 62 2372 61 2373 40 2108 41 59 621 392 40 2372 46 2374 40 41 41 123 2375 46 2376 40 648 44 2108 46 2349 40 41 41 59 450 59 125 2074 2115 61 2113 40 2108 41 59 2074 2377 61 2114 40 2115 41 59 2074 2378 61 2108 46 2364 40 41 63 2379 46 2380 40 648 44 2115 44 2381 46 2382 41 58 2377 59 2047 2383 61 418 2047 40 2365 40 41 44 2108 46 2349 40 41 44 2017 46 2350 40 41 44 380 44 2379 46 2380 40 648 44 2378 41 44 2036 46 2384 40 41 41 59 2383 46 2385 40 473 41 59 2108 46 2090 40 2383 41 59 2386 40 2108 44 1500 41 59 2344 46 2387 40 2108 41 59 621 2123 2124 61 2108 46 2388 40 41 59 2016 2389 61 2108 46 2351 40 41 63 2124 46 2390 40 41 58 2124 46 2391 40 41 59 2045 2392 61 2108 46 2351 40 41 63 2124 46 2393 40 41 58 2124 46 2394 40 41 59 2234 2235 61 418 2234 40 2108 44 2036 46 2384 40 41 44 2395 46 2396 40 41 46 2397 40 41 44 2365 40 41 41 59 2398 46 2399 40 648 44 2235 46 2400 40 41 46 2401 40 41 44 2392 44 2235 46 2349 40 41 44 2235 46 2402 40 41 44 2383 46 2402 40 41 41 59 2403 46 2404 40 2392 44 2389 44 2235 44 418 2405 40 41 123 64 2043 439 492 2406 40 41 123 2398 46 2399 40 648 43 648 44 2235 46 2400 40 41 46 2401 40 41 44 2392 44 2235 46 2349 40 41 44 2235 46 2402 40 41 44 2383 46 2402 40 41 41 59 621 621 2383 46 2407 40 473 41 59 2044 40 41 59 125 64 2043 439 492 2408 40 41 123 2398 46 2399 40 648 43 648 44 2235 46 2400 40 41 46 2401 40 41 44 2392 44 2235 46 2349 40 41 44 2235 46 2402 40 41 44 2383 46 2402 40 41 41 59 621 621 2383 46 2409 40 473 41 59 2044 40 41 59 125 64 2043 439 492 2410 40 2074 2411 41 123 2398 46 371 40 648 43 648 44 2235 46 2400 40 41 46 2401 40 41 44 2392 44 2235 46 2349 40 41 44 2235 46 2402 40 41 44 2383 46 2402 40 41 44 2411 41 59 621 621 2383 46 2412 40 2411 41 59 2044 40 41 59 125 125 41 59 2044 40 41 59 125 621 439 492 2413 40 2414 2415 44 2004 2108 44 2074 2416 41 123 2002 2417 61 2125 40 41 59 392 40 2417 614 424 41 123 2418 46 2419 40 648 41 59 450 59 125 2047 2420 61 418 2047 40 2421 40 41 44 2108 46 2422 40 41 44 2108 46 2423 40 41 46 2424 40 41 44 380 44 2416 44 2036 46 2425 40 41 41 59 2415 46 2426 40 2420 41 59 2108 46 2090 40 2420 41 59 2045 2427 59 2123 2124 61 2108 46 2428 40 41 59 392 40 2124 46 2429 40 41 46 2430 40 2108 46 2423 40 41 41 41 2427 61 2124 46 2431 40 41 59 360 2427 61 2124 46 2432 40 41 59 2104 2105 61 418 2104 40 2415 44 2036 46 2425 40 41 44 2433 46 2434 40 41 46 2435 40 41 44 2421 40 41 41 59 2436 46 2437 40 648 44 2105 46 2438 40 41 46 2439 40 41 44 2427 44 2105 46 2422 40 41 44 2105 46 2440 40 41 44 2420 46 2440 40 41 41 59 2441 46 2442 40 2427 44 2108 46 2423 40 41 44 2105 44 418 2443 40 41 123 64 2043 439 492 2444 40 41 123 2436 46 2437 40 648 43 648 44 2105 46 2438 40 41 46 2439 40 41 44 2427 44 2105 46 2422 40 41 44 2105 46 2440 40 41 44 2420 46 2440 40 41 41 59 621 621 2420 46 2445 40 473 41 59 2044 40 41 59 125 64 2043 439 492 2446 40 41 123 2436 46 2437 40 648 43 648 44 2105 46 2438 40 41 46 2439 40 41 44 2427 44 2105 46 2422 40 41 44 2105 46 2440 40 41 44 2420 46 2440 40 41 41 59 621 621 2420 46 2447 40 473 41 59 2044 40 41 59 125 64 2043 439 492 2448 40 2074 2449 41 123 2436 46 371 40 648 43 648 44 2105 46 2438 40 41 46 2439 40 41 44 2427 44 2105 46 2422 40 41 44 2105 46 2440 40 41 44 2420 46 2440 40 41 44 2449 41 59 621 621 2420 46 2450 40 2449 41 59 2044 40 41 59 125 125 41 59 2044 40 41 59 125 621 621 621 437 2451 60 2045 44 2016 62 2452 40 2004 2108 41 123 2016 2453 61 424 59 2045 2454 61 424 59 392 40 2164 40 2108 41 41 123 2453 61 2108 46 2455 40 41 59 2454 61 2107 40 2108 41 59 125 360 392 40 2456 40 2108 41 41 123 2453 61 2108 46 2457 40 41 59 2123 2124 61 2108 46 2458 40 41 59 392 40 2124 46 2459 40 41 46 2460 40 2453 41 41 2454 61 2124 46 2461 40 41 59 360 2454 61 2124 46 2462 40 41 59 125 360 123 2463 46 371 40 648 41 59 125 450 418 2451 60 62 40 2454 44 2453 41 59 125 437 324 2464 40 2004 2108 41 123 450 2017 46 2465 40 2108 46 2466 40 41 41 59 125 437 2167 60 2004 62 2467 40 2004 2108 41 123 450 2467 40 2108 46 2468 40 41 44 2108 46 2469 40 41 41 59 125 438 2167 60 2004 62 2467 40 2414 2415 41 123 2047 2470 61 2415 46 2471 40 41 59 2472 40 2470 44 648 41 59 450 2467 40 2415 46 2473 40 41 44 2415 46 2474 40 41 41 59 125 437 2167 60 2004 62 2467 40 2047 2048 41 123 450 2467 40 2048 46 2475 40 41 44 2048 46 2476 40 41 41 59 125 437 2167 60 2004 62 2467 40 2074 2075 44 404 2477 41 123 2002 2478 61 2125 40 41 59 392 40 2478 614 424 41 123 2479 46 2480 40 648 41 59 450 2167 46 362 40 41 59 125 450 2478 46 2481 40 41 46 2482 40 2483 45 62 2483 46 2484 40 41 46 2485 40 2075 41 605 2483 46 2486 40 41 614 2477 41 46 2487 40 41 59 125 439 2167 60 2004 62 2467 40 2074 2075 41 123 2002 2488 61 2125 40 41 59 392 40 2488 614 424 41 123 2489 46 2490 40 648 41 59 450 2167 46 362 40 41 59 125 450 2488 46 2491 40 41 46 2492 40 2493 45 62 2493 46 2494 40 41 46 2495 40 2075 41 41 46 2496 40 41 59 125 439 2167 60 2109 62 2497 40 2004 2108 41 123 2167 60 2109 62 2498 61 2011 46 2499 40 2108 46 2500 40 41 41 59 392 40 33 2498 46 2501 40 41 41 123 2498 61 2013 46 2502 40 41 46 2503 40 41 46 2504 40 2505 45 62 2505 46 2506 40 41 46 2507 40 2108 46 2500 40 41 41 41 46 2508 40 41 59 125 450 2498 59 125 437 492 2509 40 2004 2108 41 123 621 392 40 2108 46 2510 40 41 631 424 41 123 2074 2511 61 2512 46 2513 40 648 44 2108 46 2510 40 41 41 59 2047 2514 61 418 2047 40 2515 40 41 44 2108 46 2516 40 41 44 2017 46 2517 40 41 44 380 44 2511 44 2036 46 2518 40 41 41 59 2514 46 2519 40 473 41 59 2108 46 2090 40 2514 41 59 2044 40 41 59 125 125 439 492 2520 40 2004 2108 44 324 2521 41 123 2047 2522 61 418 2047 40 2523 40 41 44 2108 46 2524 40 41 44 2108 46 2525 40 41 44 2521 44 2526 46 2527 40 648 41 44 2036 46 2528 40 41 41 59 2522 46 2529 40 380 41 59 2108 46 2090 40 2522 41 59 467 46 2530 40 2522 41 59 2044 40 41 59 125 621 621 621 621 621 438 492 2531 40 2004 2108 44 404 2532 41 123 392 40 33 2023 46 2533 40 41 41 123 392 40 2532 60 1502 41 123 2534 46 2535 40 648 41 59 2536 46 2537 40 40 41 45 62 2531 40 2108 44 2532 43 1501 41 44 1502 41 59 125 360 123 2538 46 2539 40 648 41 59 125 450 59 125 2123 2124 61 2108 46 2540 40 41 59 2541 2542 61 2124 46 2543 40 41 59 2544 2545 61 2546 40 2542 46 2547 40 41 41 59 392 40 2545 614 424 41 123 2548 46 2549 40 648 43 648 44 2542 46 2547 40 41 41 59 450 59 125 621 2550 2551 61 2545 46 2552 40 2124 46 2553 40 41 41 59 2550 2554 61 2550 46 2555 40 2542 46 2556 40 41 41 59 2550 2557 61 2558 46 2559 40 41 59 621 2550 2560 61 2554 46 2561 40 2557 41 59 2550 2562 61 2124 46 2563 40 41 59 2550 2564 61 2551 46 2561 40 2562 41 46 2561 40 2560 41 59 2074 2565 59 621 2074 2566 59 392 40 2564 46 2567 40 41 41 123 2566 61 648 59 2565 61 648 43 2551 46 2568 40 41 43 648 43 2560 46 2568 40 41 43 648 43 2564 46 2568 40 41 59 125 360 123 2566 61 648 59 2565 61 648 43 2551 46 2569 40 41 43 648 43 2560 46 2569 40 41 43 648 43 2564 46 2570 40 45 1501 41 46 2569 40 41 59 125 2074 2571 61 2542 46 2572 40 41 63 648 43 2542 46 2573 40 41 42 1503 43 648 58 648 59 2074 2574 61 648 43 2566 43 648 43 2124 46 2575 40 41 46 2576 40 41 43 2571 43 648 43 2562 46 2576 40 41 43 648 43 2545 46 2576 40 41 43 2565 59 621 2047 2577 61 418 2047 40 2578 40 41 44 2108 46 2579 40 41 44 2017 46 2580 40 41 44 380 44 2574 44 2036 46 2581 40 41 41 59 2577 46 2582 40 473 41 59 2108 46 2090 40 2577 41 59 2044 40 41 59 125 64 2106 437 2583 2584 40 2074 2585 41 123 2586 2587 61 2023 46 2588 40 2585 41 59 392 40 2587 631 424 605 2587 46 2589 40 41 41 123 356 2590 61 2587 46 2584 40 41 59 474 123 404 2591 61 2592 46 2593 40 2585 41 63 2594 46 2595 58 2596 46 2595 59 356 2597 61 2598 46 2599 40 2590 44 2591 41 59 413 2600 61 2598 46 2601 40 2597 41 59 450 2583 46 2602 40 2585 44 2600 41 59 125 329 40 2603 2604 41 123 2605 46 371 40 648 43 2604 46 2606 40 41 41 59 450 424 59 125 125 360 123 450 424 59 125 125 125 
2976,Java,"@Slf4j
public class DaoFacade implements DaoSetupService {
    private final ProposalListPresentation proposalListPresentation;
    private final ProposalService proposalService;
    private final BallotListService ballotListService;
    private final BallotListPresentation ballotListPresentation;
    private final MyProposalListService myProposalListService;
    private final DaoStateService daoStateService;
    private final DaoStateMonitoringService daoStateMonitoringService;
    private final PeriodService periodService;
    private final CycleService cycleService;
    private final MyBlindVoteListService myBlindVoteListService;
    private final MyVoteListService myVoteListService;
    private final CompensationProposalFactory compensationProposalFactory;
    private final ReimbursementProposalFactory reimbursementProposalFactory;
    private final ChangeParamProposalFactory changeParamProposalFactory;
    private final ConfiscateBondProposalFactory confiscateBondProposalFactory;
    private final RoleProposalFactory roleProposalFactory;
    private final GenericProposalFactory genericProposalFactory;
    private final RemoveAssetProposalFactory removeAssetProposalFactory;
    private final BondedRolesRepository bondedRolesRepository;
    private final BondedReputationRepository bondedReputationRepository;
    private final MyBondedReputationRepository myBondedReputationRepository;
    private final LockupTxService lockupTxService;
    private final UnlockTxService unlockTxService;
    private final DaoStateStorageService daoStateStorageService;

    private final ObjectProperty<DaoPhase.Phase> phaseProperty = new SimpleObjectProperty<>(DaoPhase.Phase.UNDEFINED);

    @Inject
    public DaoFacade(MyProposalListService myProposalListService,
                     ProposalListPresentation proposalListPresentation,
                     ProposalService proposalService,
                     BallotListService ballotListService,
                     BallotListPresentation ballotListPresentation,
                     DaoStateService daoStateService,
                     DaoStateMonitoringService daoStateMonitoringService,
                     PeriodService periodService,
                     CycleService cycleService,
                     MyBlindVoteListService myBlindVoteListService,
                     MyVoteListService myVoteListService,
                     CompensationProposalFactory compensationProposalFactory,
                     ReimbursementProposalFactory reimbursementProposalFactory,
                     ChangeParamProposalFactory changeParamProposalFactory,
                     ConfiscateBondProposalFactory confiscateBondProposalFactory,
                     RoleProposalFactory roleProposalFactory,
                     GenericProposalFactory genericProposalFactory,
                     RemoveAssetProposalFactory removeAssetProposalFactory,
                     BondedRolesRepository bondedRolesRepository,
                     BondedReputationRepository bondedReputationRepository,
                     MyBondedReputationRepository myBondedReputationRepository,
                     LockupTxService lockupTxService,
                     UnlockTxService unlockTxService,
                     DaoStateStorageService daoStateStorageService) {
        this.proposalListPresentation = proposalListPresentation;
        this.proposalService = proposalService;
        this.ballotListService = ballotListService;
        this.ballotListPresentation = ballotListPresentation;
        this.myProposalListService = myProposalListService;
        this.daoStateService = daoStateService;
        this.daoStateMonitoringService = daoStateMonitoringService;
        this.periodService = periodService;
        this.cycleService = cycleService;
        this.myBlindVoteListService = myBlindVoteListService;
        this.myVoteListService = myVoteListService;
        this.compensationProposalFactory = compensationProposalFactory;
        this.reimbursementProposalFactory = reimbursementProposalFactory;
        this.changeParamProposalFactory = changeParamProposalFactory;
        this.confiscateBondProposalFactory = confiscateBondProposalFactory;
        this.roleProposalFactory = roleProposalFactory;
        this.genericProposalFactory = genericProposalFactory;
        this.removeAssetProposalFactory = removeAssetProposalFactory;
        this.bondedRolesRepository = bondedRolesRepository;
        this.bondedReputationRepository = bondedReputationRepository;
        this.myBondedReputationRepository = myBondedReputationRepository;
        this.lockupTxService = lockupTxService;
        this.unlockTxService = unlockTxService;
        this.daoStateStorageService = daoStateStorageService;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // DaoSetupService
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void addListeners() {
        daoStateService.addDaoStateListener(new DaoStateListener() {
            @Override
            public void onNewBlockHeight(int blockHeight) {
                if (blockHeight > 0 && periodService.getCurrentCycle() != null)
                    periodService.getCurrentCycle().getPhaseForHeight(blockHeight).ifPresent(phaseProperty::set);
            }
        });
    }

    @Override
    public void start() {
    }


    public void addBsqStateListener(DaoStateListener listener) {
        daoStateService.addDaoStateListener(listener);
    }

    public void removeBsqStateListener(DaoStateListener listener) {
        daoStateService.removeDaoStateListener(listener);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    //
    // Phase: Proposal
    //
    ///////////////////////////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Use case: Present lists
    ///////////////////////////////////////////////////////////////////////////////////////////

    public ObservableList<Proposal> getActiveOrMyUnconfirmedProposals() {
        return proposalListPresentation.getActiveOrMyUnconfirmedProposals();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Use case: Create proposal
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Creation of Proposal and proposalTransaction
    public ProposalWithTransaction getCompensationProposalWithTransaction(String name,
                                                                          String link,
                                                                          Coin requestedBsq)
            throws ProposalValidationException, InsufficientMoneyException, TxException {
        return compensationProposalFactory.createProposalWithTransaction(name,
                link,
                requestedBsq);
    }

    public ProposalWithTransaction getReimbursementProposalWithTransaction(String name,
                                                                           String link,
                                                                           Coin requestedBsq)
            throws ProposalValidationException, InsufficientMoneyException, TxException {
        return reimbursementProposalFactory.createProposalWithTransaction(name,
                link,
                requestedBsq);
    }

    public ProposalWithTransaction getParamProposalWithTransaction(String name,
                                                                   String link,
                                                                   Param param,
                                                                   String paramValue)
            throws ProposalValidationException, InsufficientMoneyException, TxException {
        return changeParamProposalFactory.createProposalWithTransaction(name,
                link,
                param,
                paramValue);
    }

    public ProposalWithTransaction getConfiscateBondProposalWithTransaction(String name,
                                                                            String link,
                                                                            String lockupTxId)
            throws ProposalValidationException, InsufficientMoneyException, TxException {
        return confiscateBondProposalFactory.createProposalWithTransaction(name,
                link,
                lockupTxId);
    }

    public ProposalWithTransaction getBondedRoleProposalWithTransaction(Role role)
            throws ProposalValidationException, InsufficientMoneyException, TxException {
        return roleProposalFactory.createProposalWithTransaction(role);
    }

    public ProposalWithTransaction getGenericProposalWithTransaction(String name,
                                                                     String link)
            throws ProposalValidationException, InsufficientMoneyException, TxException {
        return genericProposalFactory.createProposalWithTransaction(name, link);
    }

    public ProposalWithTransaction getRemoveAssetProposalWithTransaction(String name,
                                                                         String link,
                                                                         Asset asset)
            throws ProposalValidationException, InsufficientMoneyException, TxException {
        return removeAssetProposalFactory.createProposalWithTransaction(name, link, asset);
    }

    public ObservableList<BondedRole> getBondedRoles() {
        return bondedRolesRepository.getBonds();
    }

    public List<BondedRole> getAcceptedBondedRoles() {
        return bondedRolesRepository.getAcceptedBonds();
    }

    // Show fee
    public Coin getProposalFee(int chainHeight) {
        return ProposalConsensus.getFee(daoStateService, chainHeight);
    }

    // Publish proposal tx, proposal payload and persist it to myProposalList
    public void publishMyProposal(Proposal proposal, Transaction transaction, ResultHandler resultHandler,
                                  ErrorMessageHandler errorMessageHandler) {
        myProposalListService.publishTxAndPayload(proposal, transaction, resultHandler, errorMessageHandler);
    }

    // Check if it is my proposal
    public boolean isMyProposal(Proposal proposal) {
        return myProposalListService.isMine(proposal);
    }

    // Remove my proposal
    public boolean removeMyProposal(Proposal proposal) {
        return myProposalListService.remove(proposal);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    //
    // Phase: Blind Vote
    //
    ///////////////////////////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Use case: Present lists
    ///////////////////////////////////////////////////////////////////////////////////////////

    public ObservableList<Ballot> getAllBallots() {
        return ballotListPresentation.getAllBallots();
    }

    public List<Ballot> getAllValidBallots() {
        return ballotListPresentation.getAllValidBallots();
    }

    public FilteredList<Ballot> getBallotsOfCycle() {
        return ballotListPresentation.getBallotsOfCycle();
    }

    public Tuple2<Long, Long> getMeritAndStakeForProposal(String proposalTxId) {
        return myVoteListService.getMeritAndStakeForProposal(proposalTxId, myBlindVoteListService);
    }

    public long getAvailableMerit() {
        return myBlindVoteListService.getCurrentlyAvailableMerit();
    }

    public List<MyVote> getMyVoteListForCycle() {
        return myVoteListService.getMyVoteListForCycle();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Use case: Vote
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Vote on ballot
    public void setVote(Ballot ballot, @Nullable Vote vote) {
        ballotListService.setVote(ballot, vote);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Use case: Create blindVote
    ///////////////////////////////////////////////////////////////////////////////////////////

    // When creating blind vote we present fee
    public Coin getBlindVoteFeeForCycle() {
        return BlindVoteConsensus.getFee(daoStateService, daoStateService.getChainHeight());
    }

    public Tuple2<Coin, Integer> getBlindVoteMiningFeeAndTxVsize(Coin stake)
            throws WalletException, InsufficientMoneyException, TransactionVerificationException {
        return myBlindVoteListService.getMiningFeeAndTxVsize(stake);
    }

    // Publish blindVote tx and broadcast blindVote to p2p network and store to blindVoteList.
    public void publishBlindVote(Coin stake, ResultHandler resultHandler, ExceptionHandler exceptionHandler) {
        myBlindVoteListService.publishBlindVote(stake, resultHandler, exceptionHandler);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    //
    // Generic
    //
    ///////////////////////////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Use case: Presentation of phases
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Because last block in request and voting phases must not be used for making a tx as it will get confirmed in the
    // next block which would be already the next phase we hide that last block to the user and add it to the break.
    public int getFirstBlockOfPhaseForDisplay(int height, DaoPhase.Phase phase) {
        int firstBlock = periodService.getFirstBlockOfPhase(height, phase);
        switch (phase) {
            case UNDEFINED:
                break;
            case PROPOSAL:
                break;
            case BREAK1:
                firstBlock--;
                break;
            case BLIND_VOTE:
                break;
            case BREAK2:
                firstBlock--;
                break;
            case VOTE_REVEAL:
                break;
            case BREAK3:
                firstBlock--;
                break;
            case RESULT:
                break;
        }
        return firstBlock;
    }

    public Map<Integer, Date> getBlockStartDateByCycleIndex() {
        return periodService.getCycles().stream().collect(Collectors.toMap(
                cycleService::getCycleIndex,
                cycle -> new Date(daoStateService.getBlockTimeAtBlockHeight(cycle.getHeightOfFirstBlock()))
        ));
    }

    // Because last block in request and voting phases must not be used for making a tx as it will get confirmed in the
    // next block which would be already the next phase we hide that last block to the user and add it to the break.
    public int getLastBlockOfPhaseForDisplay(int height, DaoPhase.Phase phase) {
        int lastBlock = periodService.getLastBlockOfPhase(height, phase);
        switch (phase) {
            case UNDEFINED:
                break;
            case PROPOSAL:
                lastBlock--;
                break;
            case BREAK1:
                break;
            case BLIND_VOTE:
                lastBlock--;
                break;
            case BREAK2:
                break;
            case VOTE_REVEAL:
                lastBlock--;
                break;
            case BREAK3:
                break;
            case RESULT:
                break;
        }
        return lastBlock;
    }

    // Because last block in request and voting phases must not be used for making a tx as it will get confirmed in the
    // next block which would be already the next phase we hide that last block to the user and add it to the break.
    public int getDurationForPhaseForDisplay(DaoPhase.Phase phase) {
        int duration = periodService.getDurationForPhase(phase, daoStateService.getChainHeight());
        switch (phase) {
            case UNDEFINED:
                break;
            case PROPOSAL:
                duration--;
                break;
            case BREAK1:
                duration++;
                break;
            case BLIND_VOTE:
                duration--;
                break;
            case BREAK2:
                duration++;
                break;
            case VOTE_REVEAL:
                duration--;
                break;
            case BREAK3:
                duration++;
                break;
            case RESULT:
                break;
        }
        return duration;
    }

    public int getCurrentCycleDuration() {
        Cycle currentCycle = periodService.getCurrentCycle();
        return currentCycle != null ? currentCycle.getDuration() : 0;
    }

    // listeners for phase change
    public ReadOnlyObjectProperty<DaoPhase.Phase> phaseProperty() {
        return phaseProperty;
    }

    public int getChainHeight() {
        return daoStateService.getChainHeight();
    }

    public Optional<Block> getBlockAtChainHeight() {
        return getBlockAtHeight(getChainHeight());
    }

    public Optional<Block> getBlockAtHeight(int chainHeight) {
        return daoStateService.getBlockAtHeight(chainHeight);
    }

    public boolean isInConflictWithSeedNode() {
        return daoStateMonitoringService.isInConflictWithSeedNode();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Use case: Bonding
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void publishLockupTx(Coin lockupAmount, int lockTime, LockupReason lockupReason, byte[] hash,
                                Consumer<String> resultHandler, ExceptionHandler exceptionHandler) {
        lockupTxService.publishLockupTx(lockupAmount, lockTime, lockupReason, hash, resultHandler, exceptionHandler);
    }

    public Tuple2<Coin, Integer> getLockupTxMiningFeeAndTxVsize(Coin lockupAmount,
                                                                int lockTime,
                                                                LockupReason lockupReason,
                                                                byte[] hash)
            throws InsufficientMoneyException, IOException, TransactionVerificationException, WalletException {
        return lockupTxService.getMiningFeeAndTxVsize(lockupAmount, lockTime, lockupReason, hash);
    }

    public void publishUnlockTx(String lockupTxId, Consumer<String> resultHandler,
                                ExceptionHandler exceptionHandler) {
        unlockTxService.publishUnlockTx(lockupTxId, resultHandler, exceptionHandler);
    }

    public Tuple2<Coin, Integer> getUnlockTxMiningFeeAndTxVsize(String lockupTxId)
            throws InsufficientMoneyException, TransactionVerificationException, WalletException {
        return unlockTxService.getMiningFeeAndTxVsize(lockupTxId);
    }

    public long getTotalLockupAmount() {
        return daoStateService.getTotalLockupAmount();
    }

    public long getTotalAmountOfUnLockingTxOutputs() {
        return daoStateService.getTotalAmountOfUnLockingTxOutputs();
    }

    public long getTotalAmountOfUnLockedTxOutputs() {
        return daoStateService.getTotalAmountOfUnLockedTxOutputs();
    }

    public long getTotalAmountOfConfiscatedTxOutputs() {
        return daoStateService.getTotalAmountOfConfiscatedTxOutputs();
    }

    public long getTotalAmountOfInvalidatedBsq() {
        return daoStateService.getTotalAmountOfInvalidatedBsq();
    }

    // Contains burned fee and invalidated bsq due invalid txs
    public long getTotalAmountOfBurntBsq() {
        return daoStateService.getTotalAmountOfBurntBsq();
    }

    public List<Tx> getInvalidTxs() {
        return daoStateService.getInvalidTxs();
    }

    public List<Tx> getIrregularTxs() {
        return daoStateService.getIrregularTxs();
    }

    public long getTotalAmountOfUnspentTxOutputs() {
        // Does not consider confiscated outputs (they stay as utxo)
        return daoStateService.getUnspentTxOutputMap().values().stream().mapToLong(BaseTxOutput::getValue).sum();
    }

    public Optional<Integer> getLockTime(String txId) {
        return daoStateService.getLockTime(txId);
    }


    public List<Bond> getAllBonds() {
        List<Bond> bonds = new ArrayList<>(bondedReputationRepository.getBonds());
        bonds.addAll(bondedRolesRepository.getBonds());
        return bonds;
    }

    public List<Bond> getAllActiveBonds() {
        List<Bond> bonds = new ArrayList<>(bondedReputationRepository.getActiveBonds());
        bonds.addAll(bondedRolesRepository.getActiveBonds());
        return bonds;
    }

    public ObservableList<MyBondedReputation> getMyBondedReputations() {
        return myBondedReputationRepository.getMyBondedReputations();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Use case: Present transaction related state
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Optional<Tx> getTx(String txId) {
        return daoStateService.getTx(txId);
    }

    public int getGenesisBlockHeight() {
        return daoStateService.getGenesisBlockHeight();
    }

    public String getGenesisTxId() {
        return daoStateService.getGenesisTxId();
    }

    public Coin getGenesisTotalSupply() {
        return daoStateService.getGenesisTotalSupply();
    }

    public int getNumIssuanceTransactions(IssuanceType issuanceType) {
        return daoStateService.getIssuanceSetForType(issuanceType).size();
    }

    public Set<Tx> getBurntFeeTxs() {
        return daoStateService.getBurntFeeTxs();
    }

    public Set<TxOutput> getUnspentTxOutputs() {
        return daoStateService.getUnspentTxOutputs();
    }

    public boolean isTxOutputSpendable(TxOutputKey txOutputKey) {
        return daoStateService.isTxOutputSpendable(txOutputKey);
    }

    public long getUnspentTxOutputValue(TxOutputKey key) {
        return daoStateService.getUnspentTxOutputValue(key);
    }

    public int getNumTxs() {
        return daoStateService.getNumTxs();
    }

    public Optional<TxOutput> getLockupTxOutput(String txId) {
        return daoStateService.getLockupTxOutput(txId);
    }

    public long getTotalIssuedAmount(IssuanceType issuanceType) {
        return daoStateService.getTotalIssuedAmount(issuanceType);
    }

    public long getBlockTime(int issuanceBlockHeight) {
        return daoStateService.getBlockTime(issuanceBlockHeight);
    }

    public int getIssuanceBlockHeight(String txId) {
        return daoStateService.getIssuanceBlockHeight(txId);
    }

    public boolean isIssuanceTx(String txId, IssuanceType issuanceType) {
        return daoStateService.isIssuanceTx(txId, issuanceType);
    }

    public boolean hasTxBurntFee(String hashAsString) {
        return daoStateService.hasTxBurntFee(hashAsString);
    }

    public Optional<TxType> getOptionalTxType(String txId) {
        return daoStateService.getOptionalTxType(txId);
    }

    public TxType getTxType(String txId) {
        return daoStateService.getTx(txId).map(Tx::getTxType).orElse(TxType.UNDEFINED_TX_TYPE);
    }

    public boolean isInPhaseButNotLastBlock(DaoPhase.Phase phase) {
        return periodService.isInPhaseButNotLastBlock(phase);
    }

    public boolean isTxInCorrectCycle(int txHeight, int chainHeight) {
        return periodService.isTxInCorrectCycle(txHeight, chainHeight);
    }

    public boolean isTxInCorrectCycle(String txId, int chainHeight) {
        return periodService.isTxInCorrectCycle(txId, chainHeight);
    }

    public Coin getMinCompensationRequestAmount() {
        return CompensationConsensus.getMinCompensationRequestAmount(daoStateService, periodService.getChainHeight());
    }

    public Coin getMaxCompensationRequestAmount() {
        return CompensationConsensus.getMaxCompensationRequestAmount(daoStateService, periodService.getChainHeight());
    }

    public Coin getMinReimbursementRequestAmount() {
        return ReimbursementConsensus.getMinReimbursementRequestAmount(daoStateService, periodService.getChainHeight());
    }

    public Coin getMaxReimbursementRequestAmount() {
        return ReimbursementConsensus.getMaxReimbursementRequestAmount(daoStateService, periodService.getChainHeight());
    }

    public String getParamValue(Param param) {
        return getParamValue(param, periodService.getChainHeight());
    }

    public String getParamValue(Param param, int blockHeight) {
        return daoStateService.getParamValue(param, blockHeight);
    }

    public void resyncDaoStateFromGenesis(Runnable resultHandler) {
        daoStateStorageService.resyncDaoStateFromGenesis(resultHandler);
    }

    public void resyncDaoStateFromResources(File storageDir) throws IOException {
        daoStateStorageService.resyncDaoStateFromResources(storageDir);
    }

    public boolean isMyRole(Role role) {
        return bondedRolesRepository.isMyRole(role);
    }

    public Optional<Bond> getBondByLockupTxId(String lockupTxId) {
        return getAllBonds().stream().filter(e -> lockupTxId.equals(e.getLockupTxId())).findAny();
    }

    public double getRequiredThreshold(Proposal proposal) {
        return proposalService.getRequiredThreshold(proposal);
    }

    public Coin getRequiredQuorum(Proposal proposal) {
        return proposalService.getRequiredQuorum(proposal);
    }

    public long getRequiredBond(Optional<RoleProposal> roleProposal) {
        Optional<BondedRoleType> bondedRoleType = roleProposal.map(e -> e.getRole().getBondedRoleType());
        checkArgument(bondedRoleType.isPresent(), ""bondedRoleType must be present"");
        int height = roleProposal.flatMap(p -> daoStateService.getTx(p.getTxId()))
                .map(BaseTx::getBlockHeight)
                .orElse(daoStateService.getChainHeight());
        long requiredBondUnit = roleProposal.map(RoleProposal::getRequiredBondUnit)
                .orElse(bondedRoleType.get().getRequiredBondUnit());
        long baseFactor = daoStateService.getParamValueAsCoin(Param.BONDED_ROLE_FACTOR, height).value;
        return requiredBondUnit * baseFactor;
    }

    public long getRequiredBond(RoleProposal roleProposal) {
        return getRequiredBond(Optional.of(roleProposal));
    }

    public long getRequiredBond(BondedRoleType bondedRoleType) {
        int height = daoStateService.getChainHeight();
        long requiredBondUnit = bondedRoleType.getRequiredBondUnit();
        long baseFactor = daoStateService.getParamValueAsCoin(Param.BONDED_ROLE_FACTOR, height).value;
        return requiredBondUnit * baseFactor;
    }

    public Set<String> getAllPastParamValues(Param param) {
        Set<String> set = new HashSet<>();
        periodService.getCycles().forEach(cycle -> {
            set.add(getParamValue(param, cycle.getHeightOfFirstBlock()));
        });
        return set;
    }

    public Set<String> getAllDonationAddresses() {
        // We support any of the past addresses as well as in case the peer has not enabled the DAO or is out of sync we
        // do not want to break validation.
        Set<String> allPastParamValues = getAllPastParamValues(Param.RECIPIENT_BTC_ADDRESS);

        // If Dao is deactivated we need to add the default address as getAllPastParamValues will not return us any.
        if (allPastParamValues.isEmpty()) {
            allPastParamValues.add(Param.RECIPIENT_BTC_ADDRESS.getDefaultValue());
        }

        if (Config.baseCurrencyNetwork().isMainnet()) {
            // If Dao is deactivated we need to add the past addresses used as well.
            // This list need to be updated once a new address gets defined.
            allPastParamValues.add(DelayedPayoutAddressProvider.BM2019_ADDRESS);
            allPastParamValues.add(DelayedPayoutAddressProvider.BM2_ADDRESS);
            allPastParamValues.add(DelayedPayoutAddressProvider.BM3_ADDRESS);
        }

        return allPastParamValues;
    }

    public boolean isParseBlockChainComplete() {
        return daoStateService.isParseBlockChainComplete();
    }
}",1,64 2000 439 334 2001 395 2002 123 437 381 2003 2004 59 437 381 2005 2006 59 437 381 2007 2008 59 437 381 2009 2010 59 437 381 2011 2012 59 437 381 2013 2014 59 437 381 2015 2016 59 437 381 2017 2018 59 437 381 2019 2020 59 437 381 2021 2022 59 437 381 2023 2024 59 437 381 2025 2026 59 437 381 2027 2028 59 437 381 2029 2030 59 437 381 2031 2032 59 437 381 2033 2034 59 437 381 2035 2036 59 437 381 2037 2038 59 437 381 2039 2040 59 437 381 2041 2042 59 437 381 2043 2044 59 437 381 2045 2046 59 437 381 2047 2048 59 437 381 2049 2050 59 437 381 2051 60 2052 46 2053 62 2054 61 418 2055 60 62 40 2052 46 2053 46 2056 41 59 64 2057 439 2001 40 2011 2012 44 2003 2004 44 2005 2006 44 2007 2008 44 2009 2010 44 2013 2014 44 2015 2016 44 2017 2018 44 2019 2020 44 2021 2022 44 2023 2024 44 2025 2026 44 2027 2028 44 2029 2030 44 2031 2032 44 2033 2034 44 2035 2036 44 2037 2038 44 2039 2040 44 2041 2042 44 2043 2044 44 2045 2046 44 2047 2048 44 2049 2050 41 123 467 46 2004 61 2004 59 467 46 2006 61 2006 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 467 46 2012 61 2012 59 467 46 2014 61 2014 59 467 46 2016 61 2016 59 467 46 2018 61 2018 59 467 46 2020 61 2020 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2026 61 2026 59 467 46 2028 61 2028 59 467 46 2030 61 2030 59 467 46 2032 61 2032 59 467 46 2034 61 2034 59 467 46 2036 61 2036 59 467 46 2038 61 2038 59 467 46 2040 61 2040 59 467 46 2042 61 2042 59 467 46 2044 61 2044 59 467 46 2046 61 2046 59 467 46 2048 61 2048 59 467 46 2050 61 2050 59 125 621 621 621 64 2058 439 492 2059 40 41 123 2014 46 2060 40 418 2061 40 41 123 64 2058 439 492 2062 40 404 2063 41 123 392 40 2063 62 1500 605 2018 46 2064 40 41 631 424 41 2018 46 2064 40 41 46 2065 40 2063 41 46 2066 40 2054 58 58 2067 41 59 125 125 41 59 125 64 2058 439 492 2068 40 41 123 125 439 492 2069 40 2070 2071 41 123 2014 46 2072 40 2071 41 59 125 439 492 2073 40 2070 2071 41 123 2014 46 2074 40 2071 41 59 125 621 621 621 621 621 621 621 621 439 2075 60 2076 62 2077 40 41 123 450 2004 46 2077 40 41 59 125 621 621 621 621 439 2078 2079 40 2080 2081 44 2080 2082 44 2083 2084 41 470 2085 44 2086 44 2087 123 450 2026 46 2088 40 2081 44 2082 44 2084 41 59 125 439 2078 2089 40 2080 2081 44 2080 2082 44 2083 2084 41 470 2085 44 2086 44 2087 123 450 2028 46 2090 40 2081 44 2082 44 2084 41 59 125 439 2078 2091 40 2080 2081 44 2080 2082 44 2092 2093 44 2080 2094 41 470 2085 44 2086 44 2087 123 450 2030 46 2095 40 2081 44 2082 44 2093 44 2094 41 59 125 439 2078 2096 40 2080 2081 44 2080 2082 44 2080 2097 41 470 2085 44 2086 44 2087 123 450 2032 46 2098 40 2081 44 2082 44 2097 41 59 125 439 2078 2099 40 2100 2101 41 470 2085 44 2086 44 2087 123 450 2034 46 2102 40 2101 41 59 125 439 2078 2103 40 2080 2081 44 2080 2082 41 470 2085 44 2086 44 2087 123 450 2036 46 2104 40 2081 44 2082 41 59 125 439 2078 2105 40 2080 2081 44 2080 2082 44 2106 2107 41 470 2085 44 2086 44 2087 123 450 2038 46 2108 40 2081 44 2082 44 2107 41 59 125 439 2075 60 2109 62 2110 40 41 123 450 2040 46 2111 40 41 59 125 439 2112 60 2109 62 2113 40 41 123 450 2040 46 2114 40 41 59 125 621 439 2083 2115 40 404 2116 41 123 450 2117 46 2118 40 2014 44 2116 41 59 125 621 439 492 2119 40 2076 2120 44 2121 2122 44 2123 2124 44 2125 2126 41 123 2012 46 2127 40 2120 44 2122 44 2124 44 2126 41 59 125 621 439 324 2128 40 2076 2120 41 123 450 2012 46 2129 40 2120 41 59 125 621 439 324 2130 40 2076 2120 41 123 450 2012 46 2131 40 2120 41 59 125 621 621 621 621 621 621 621 621 439 2075 60 2132 62 2133 40 41 123 450 2010 46 2133 40 41 59 125 439 2112 60 2132 62 2134 40 41 123 450 2010 46 2134 40 41 59 125 439 2135 60 2132 62 2136 40 41 123 450 2010 46 2136 40 41 59 125 439 2137 60 2138 44 2138 62 2139 40 2080 2140 41 123 450 2024 46 2139 40 2140 44 2022 41 59 125 439 413 2141 40 41 123 450 2022 46 2142 40 41 59 125 439 2112 60 2143 62 2144 40 41 123 450 2024 46 2144 40 41 59 125 621 621 621 621 439 492 2145 40 2132 2146 44 64 2147 2148 2149 41 123 2008 46 2145 40 2146 44 2149 41 59 125 621 621 621 621 439 2083 2150 40 41 123 450 2151 46 2152 40 2014 44 2014 46 2153 40 41 41 59 125 439 2137 60 2083 44 2154 62 2155 40 2083 2156 41 470 2157 44 2086 44 2158 123 450 2022 46 2159 40 2156 41 59 125 621 439 492 2160 40 2083 2156 44 2123 2124 44 2161 2162 41 123 2022 46 2160 40 2156 44 2124 44 2162 41 59 125 621 621 621 621 621 621 621 621 621 621 439 404 2163 40 404 2164 44 2052 46 2053 2165 41 123 404 2166 61 2018 46 2167 40 2164 44 2165 41 59 464 40 2165 41 123 328 2056 58 325 59 328 2168 58 325 59 328 2169 58 2166 629 59 325 59 328 2170 58 325 59 328 2171 58 2166 629 59 325 59 328 2172 58 325 59 328 2173 58 2166 629 59 325 59 328 2174 58 325 59 125 450 2166 59 125 439 2175 60 2154 44 2176 62 2177 40 41 123 450 2018 46 2178 40 41 46 2179 40 41 46 2180 40 2181 46 2182 40 2020 58 58 2183 44 2184 45 62 418 2176 40 2014 46 2185 40 2184 46 2186 40 41 41 41 41 41 59 125 621 621 439 404 2187 40 404 2164 44 2052 46 2053 2165 41 123 404 2188 61 2018 46 2189 40 2164 44 2165 41 59 464 40 2165 41 123 328 2056 58 325 59 328 2190 58 2188 629 59 325 59 328 2191 58 325 59 328 2192 58 2188 629 59 325 59 328 2193 58 325 59 328 2194 58 2188 629 59 325 59 328 2195 58 325 59 328 2196 58 325 59 125 450 2188 59 125 621 621 439 404 2197 40 2052 46 2053 2165 41 123 404 2198 61 2018 46 2199 40 2165 44 2014 46 2200 40 41 41 59 464 40 2165 41 123 328 2056 58 325 59 328 2201 58 2198 629 59 325 59 328 2202 58 2198 637 59 325 59 328 2203 58 2198 629 59 325 59 328 2204 58 2198 637 59 325 59 328 2205 58 2198 629 59 325 59 328 2206 58 2198 637 59 325 59 328 2207 58 325 59 125 450 2198 59 125 439 404 2208 40 41 123 2209 2210 61 2018 46 2211 40 41 59 450 2210 631 424 63 2210 46 2212 40 41 58 1500 59 125 621 439 2213 60 2052 46 2053 62 2054 40 41 123 450 2054 59 125 439 404 2214 40 41 123 450 2014 46 2214 40 41 59 125 439 2215 60 2216 62 2217 40 41 123 450 2218 40 2214 40 41 41 59 125 439 2215 60 2216 62 2219 40 404 2116 41 123 450 2014 46 2219 40 2116 41 59 125 439 324 2220 40 41 123 450 2016 46 2220 40 41 59 125 621 621 621 439 492 2221 40 2083 2222 44 404 2223 44 2224 2225 44 326 91 93 2226 44 2227 60 2080 62 2124 44 2161 2162 41 123 2046 46 2221 40 2222 44 2223 44 2225 44 2226 44 2124 44 2162 41 59 125 439 2137 60 2083 44 2154 62 2228 40 2083 2222 44 404 2223 44 2224 2225 44 326 91 93 2226 41 470 2086 44 2229 44 2158 44 2157 123 450 2046 46 2230 40 2222 44 2223 44 2225 44 2226 41 59 125 439 492 2231 40 2080 2097 44 2227 60 2080 62 2124 44 2161 2162 41 123 2048 46 2231 40 2097 44 2124 44 2162 41 59 125 439 2137 60 2083 44 2154 62 2232 40 2080 2097 41 470 2086 44 2158 44 2157 123 450 2048 46 2233 40 2097 41 59 125 439 413 2234 40 41 123 450 2014 46 2234 40 41 59 125 439 413 2235 40 41 123 450 2014 46 2235 40 41 59 125 439 413 2236 40 41 123 450 2014 46 2236 40 41 59 125 439 413 2237 40 41 123 450 2014 46 2237 40 41 59 125 439 413 2238 40 41 123 450 2014 46 2238 40 41 59 125 621 439 413 2239 40 41 123 450 2014 46 2239 40 41 59 125 439 2112 60 2240 62 2241 40 41 123 450 2014 46 2241 40 41 59 125 439 2112 60 2240 62 2242 40 41 123 450 2014 46 2242 40 41 59 125 439 413 2243 40 41 123 621 450 2014 46 2244 40 41 46 2245 40 41 46 2246 40 41 46 2247 40 2248 58 58 2249 41 46 2250 40 41 59 125 439 2215 60 2154 62 2251 40 2080 2252 41 123 450 2014 46 2251 40 2252 41 59 125 439 2112 60 2253 62 2254 40 41 123 2112 60 2253 62 2255 61 418 2256 60 62 40 2042 46 2257 40 41 41 59 2255 46 2258 40 2040 46 2257 40 41 41 59 450 2255 59 125 439 2112 60 2253 62 2259 40 41 123 2112 60 2253 62 2260 61 418 2261 60 62 40 2042 46 2262 40 41 41 59 2260 46 2263 40 2040 46 2262 40 41 41 59 450 2260 59 125 439 2075 60 2264 62 2265 40 41 123 450 2044 46 2265 40 41 59 125 621 621 621 439 2215 60 2240 62 2266 40 2080 2252 41 123 450 2014 46 2266 40 2252 41 59 125 439 404 2267 40 41 123 450 2014 46 2267 40 41 59 125 439 2080 2268 40 41 123 450 2014 46 2268 40 41 59 125 439 2083 2269 40 41 123 450 2014 46 2269 40 41 59 125 439 404 2270 40 2271 2272 41 123 450 2014 46 2273 40 2272 41 46 2274 40 41 59 125 439 2275 60 2240 62 2276 40 41 123 450 2014 46 2276 40 41 59 125 439 2275 60 2277 62 2278 40 41 123 450 2014 46 2278 40 41 59 125 439 324 2279 40 2280 2281 41 123 450 2014 46 2279 40 2281 41 59 125 439 413 2282 40 2280 2283 41 123 450 2014 46 2282 40 2283 41 59 125 439 404 2284 40 41 123 450 2014 46 2284 40 41 59 125 439 2215 60 2277 62 2285 40 2080 2252 41 123 450 2014 46 2285 40 2252 41 59 125 439 413 2286 40 2271 2272 41 123 450 2014 46 2286 40 2272 41 59 125 439 413 2287 40 404 2288 41 123 450 2014 46 2287 40 2288 41 59 125 439 404 2289 40 2080 2252 41 123 450 2014 46 2289 40 2252 41 59 125 439 324 2290 40 2080 2252 44 2271 2272 41 123 450 2014 46 2290 40 2252 44 2272 41 59 125 439 324 2291 40 2080 2292 41 123 450 2014 46 2291 40 2292 41 59 125 439 2215 60 2293 62 2294 40 2080 2252 41 123 450 2014 46 2294 40 2252 41 59 125 439 2293 2295 40 2080 2252 41 123 450 2014 46 2266 40 2252 41 46 2296 40 2240 58 58 2295 41 46 2297 40 2293 46 2298 41 59 125 439 324 2299 40 2052 46 2053 2165 41 123 450 2018 46 2299 40 2165 41 59 125 439 324 2300 40 404 2301 44 404 2116 41 123 450 2018 46 2300 40 2301 44 2116 41 59 125 439 324 2300 40 2080 2252 44 404 2116 41 123 450 2018 46 2300 40 2252 44 2116 41 59 125 439 2083 2302 40 41 123 450 2303 46 2302 40 2014 44 2018 46 2214 40 41 41 59 125 439 2083 2304 40 41 123 450 2305 46 2304 40 2014 44 2018 46 2214 40 41 41 59 125 439 2083 2306 40 41 123 450 2307 46 2306 40 2014 44 2018 46 2214 40 41 41 59 125 439 2083 2308 40 41 123 450 2309 46 2308 40 2014 44 2018 46 2214 40 41 41 59 125 439 2080 2310 40 2092 2093 41 123 450 2310 40 2093 44 2018 46 2214 40 41 41 59 125 439 2080 2310 40 2092 2093 44 404 2311 41 123 450 2014 46 2310 40 2093 44 2311 41 59 125 439 492 2312 40 2313 2124 41 123 2050 46 2312 40 2124 41 59 125 439 492 2314 40 2315 2316 41 470 2229 123 2050 46 2314 40 2316 41 59 125 439 324 2317 40 2100 2101 41 123 450 2040 46 2317 40 2101 41 59 125 439 2215 60 2253 62 2318 40 2080 2097 41 123 450 2254 40 41 46 2319 40 41 46 2320 40 2321 45 62 2097 46 2322 40 2321 46 2323 40 41 41 41 46 2324 40 41 59 125 439 356 2325 40 2076 2120 41 123 450 2006 46 2325 40 2120 41 59 125 439 2083 2326 40 2076 2120 41 123 450 2006 46 2326 40 2120 41 59 125 439 413 2327 40 2215 60 2328 62 2329 41 123 2215 60 2330 62 2331 61 2329 46 2332 40 2333 45 62 2333 46 2334 40 41 46 2335 40 41 41 59 2336 40 2331 46 2337 40 41 44 648 41 59 404 2164 61 2329 46 2338 40 2339 45 62 2014 46 2266 40 2339 46 2340 40 41 41 41 46 2332 40 2341 58 58 2342 41 46 2343 40 2014 46 2214 40 41 41 59 413 2344 61 2329 46 2332 40 2328 58 58 2345 41 46 2343 40 2331 46 2346 40 41 46 2345 40 41 41 59 413 2347 61 2014 46 2348 40 2092 46 2349 44 2164 41 46 2350 59 450 2344 42 2347 59 125 439 413 2327 40 2328 2329 41 123 450 2327 40 2215 46 2351 40 2329 41 41 59 125 439 413 2327 40 2352 2353 41 123 404 2164 61 2014 46 2214 40 41 59 413 2354 61 2353 46 2355 40 41 59 413 2356 61 2014 46 2357 40 2092 46 2358 44 2164 41 46 2359 59 450 2354 42 2356 59 125 439 2275 60 2080 62 2360 40 2092 2093 41 123 2275 60 2080 62 2361 61 418 2362 60 62 40 41 59 2018 46 2363 40 41 46 2364 40 2365 45 62 123 2361 46 2366 40 2310 40 2093 44 2365 46 2367 40 41 41 41 59 125 41 59 450 2361 59 125 439 2275 60 2080 62 2368 40 41 123 621 621 2275 60 2080 62 2369 61 2360 40 2092 46 2370 41 59 621 392 40 2369 46 2371 40 41 41 123 2369 46 2372 40 2092 46 2370 46 2373 40 41 41 59 125 392 40 2374 46 2375 40 41 46 2376 40 41 41 123 621 621 2369 46 2377 40 2378 46 2379 41 59 2369 46 2377 40 2378 46 2380 41 59 2369 46 2377 40 2378 46 2381 41 59 125 450 2369 59 125 439 324 2382 40 41 123 450 2014 46 2382 40 41 59 125 125 
2687,Java,"public class MovementFall extends Movement {

    private static final ItemStack STACK_BUCKET_WATER = new ItemStack(Items.WATER_BUCKET);
    private static final ItemStack STACK_BUCKET_EMPTY = new ItemStack(Items.BUCKET);

    public MovementFall(IBaritone baritone, BetterBlockPos src, BetterBlockPos dest) {
        super(baritone, src, dest, MovementFall.buildPositionsToBreak(src, dest));
    }

    @Override
    public double calculateCost(CalculationContext context) {
        MutableMoveResult result = new MutableMoveResult();
        MovementDescend.cost(context, src.x, src.y, src.z, dest.x, dest.z, result);
        if (result.y != dest.y) {
            return COST_INF; // doesn't apply to us, this position is a descend not a fall
        }
        return result.cost;
    }

    @Override
    protected Set<BetterBlockPos> calculateValidPositions() {
        Set<BetterBlockPos> set = new HashSet<>();
        set.add(src);
        for (int y = src.y - dest.y; y >= 0; y--) {
            set.add(dest.up(y));
        }
        return set;
    }

    private boolean willPlaceBucket() {
        CalculationContext context = new CalculationContext(baritone);
        MutableMoveResult result = new MutableMoveResult();
        return MovementDescend.dynamicFallCost(context, src.x, src.y, src.z, dest.x, dest.z, 0, context.get(dest.x, src.y - 2, dest.z), result);
    }

    @Override
    public MovementState updateState(MovementState state) {
        super.updateState(state);
        if (state.getStatus() != MovementStatus.RUNNING) {
            return state;
        }

        BlockPos playerFeet = ctx.playerFeet();
        Rotation toDest = RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest), ctx.playerRotations());
        Rotation targetRotation = null;
        Block destBlock = ctx.world().getBlockState(dest).getBlock();
        boolean isWater = destBlock == Blocks.WATER || destBlock == Blocks.FLOWING_WATER;
        if (!isWater && willPlaceBucket() && !playerFeet.equals(dest)) {
            if (!InventoryPlayer.isHotbar(ctx.player().inventory.getSlotFor(STACK_BUCKET_WATER)) || ctx.world().provider.isNether()) {
                return state.setStatus(MovementStatus.UNREACHABLE);
            }

            if (ctx.player().posY - dest.getY() < ctx.playerController().getBlockReachDistance() && !ctx.player().onGround) {
                ctx.player().inventory.currentItem = ctx.player().inventory.getSlotFor(STACK_BUCKET_WATER);

                targetRotation = new Rotation(toDest.getYaw(), 90.0F);

                if (ctx.isLookingAt(dest) || ctx.isLookingAt(dest.down())) {
                    state.setInput(Input.CLICK_RIGHT, true);
                }
            }
        }
        if (targetRotation != null) {
            state.setTarget(new MovementTarget(targetRotation, true));
        } else {
            state.setTarget(new MovementTarget(toDest, false));
        }
        if (playerFeet.equals(dest) && (ctx.player().posY - playerFeet.getY() < 0.094 || isWater)) { // 0.094 because lilypads
            if (isWater) { // only match water, not flowing water (which we cannot pick up with a bucket)
                if (InventoryPlayer.isHotbar(ctx.player().inventory.getSlotFor(STACK_BUCKET_EMPTY))) {
                    ctx.player().inventory.currentItem = ctx.player().inventory.getSlotFor(STACK_BUCKET_EMPTY);
                    if (ctx.player().motionY >= 0) {
                        return state.setInput(Input.CLICK_RIGHT, true);
                    } else {
                        return state;
                    }
                } else {
                    if (ctx.player().motionY >= 0) {
                        return state.setStatus(MovementStatus.SUCCESS);
                    } // don't else return state; we need to stay centered because this water might be flowing under the surface
                }
            } else {
                return state.setStatus(MovementStatus.SUCCESS);
            }
        }
        Vec3d destCenter = VecUtils.getBlockPosCenter(dest); // we are moving to the 0.5 center not the edge (like if we were falling on a ladder)
        if (Math.abs(ctx.player().posX + ctx.player().motionX - destCenter.x) > 0.1 || Math.abs(ctx.player().posZ + ctx.player().motionZ - destCenter.z) > 0.1) {
            if (!ctx.player().onGround && Math.abs(ctx.player().motionY) > 0.4) {
                state.setInput(Input.SNEAK, true);
            }
            state.setInput(Input.MOVE_FORWARD, true);
        }
        Vec3i avoid = Optional.ofNullable(avoid()).map(EnumFacing::getDirectionVec).orElse(null);
        if (avoid == null) {
            avoid = src.subtract(dest);
        } else {
            double dist = Math.abs(avoid.getX() * (destCenter.x - avoid.getX() / 2.0 - ctx.player().posX)) + Math.abs(avoid.getZ() * (destCenter.z - avoid.getZ() / 2.0 - ctx.player().posZ));
            if (dist < 0.6) {
                state.setInput(Input.MOVE_FORWARD, true);
            } else if (!ctx.player().onGround) {
                state.setInput(Input.SNEAK, false);
            }
        }
        if (targetRotation == null) {
            Vec3d destCenterOffset = new Vec3d(destCenter.x + 0.125 * avoid.getX(), destCenter.y, destCenter.z + 0.125 * avoid.getZ());
            state.setTarget(new MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), destCenterOffset, ctx.playerRotations()), false));
        }
        return state;
    }

    private EnumFacing avoid() {
        for (int i = 0; i < 15; i++) {
            IBlockState state = ctx.world().getBlockState(ctx.playerFeet().down(i));
            if (state.getBlock() == Blocks.LADDER) {
                return state.getValue(BlockLadder.FACING);
            }
        }
        return null;
    }

    @Override
    public boolean safeToCancel(MovementState state) {
        // if we haven't started walking off the edge yet, or if we're in the process of breaking blocks before doing the fall
        // then it's safe to cancel this
        return ctx.playerFeet().equals(src) || state.getStatus() != MovementStatus.RUNNING;
    }

    private static BetterBlockPos[] buildPositionsToBreak(BetterBlockPos src, BetterBlockPos dest) {
        BetterBlockPos[] toBreak;
        int diffX = src.getX() - dest.getX();
        int diffZ = src.getZ() - dest.getZ();
        int diffY = src.getY() - dest.getY();
        toBreak = new BetterBlockPos[diffY + 2];
        for (int i = 0; i < toBreak.length; i++) {
            toBreak[i] = new BetterBlockPos(src.getX() - diffX, src.getY() + 1 - i, src.getZ() - diffZ);
        }
        return toBreak;
    }

    @Override
    protected boolean prepared(MovementState state) {
        if (state.getStatus() == MovementStatus.WAITING) {
            return true;
        }
        // only break if one of the first three needs to be broken
        // specifically ignore the last one which might be water
        for (int i = 0; i < 4 && i < positionsToBreak.length; i++) {
            if (!MovementHelper.canWalkThrough(ctx, positionsToBreak[i])) {
                return super.prepared(state);
            }
        }
        return true;
    }
}",1,439 334 2000 378 2001 123 437 457 381 2002 2003 61 418 2002 40 2004 46 2005 41 59 437 457 381 2002 2006 61 418 2002 40 2004 46 2007 41 59 439 2000 40 2008 2009 44 2010 2011 44 2010 2012 41 123 463 40 2009 44 2011 44 2012 44 2000 46 2013 40 2011 44 2012 41 41 59 125 64 2014 439 356 2015 40 2016 2017 41 123 2018 2019 61 418 2018 40 41 59 2020 46 2021 40 2017 44 2011 46 2022 44 2011 46 2023 44 2011 46 2024 44 2012 46 2022 44 2012 46 2024 44 2019 41 59 392 40 2019 46 2023 631 2012 46 2023 41 123 450 2025 59 621 125 450 2019 46 2021 59 125 64 2014 438 2026 60 2010 62 2027 40 41 123 2026 60 2010 62 2028 61 418 2029 60 62 40 41 59 2028 46 2030 40 2011 41 59 385 40 404 2031 61 2011 46 2031 45 2012 46 2031 59 2031 615 1500 59 2031 629 41 123 2028 46 2030 40 2012 46 2032 40 2031 41 41 59 125 450 2028 59 125 437 324 2033 40 41 123 2016 2017 61 418 2016 40 2009 41 59 2034 2035 61 418 2034 40 41 59 450 2036 46 2037 40 2017 44 2011 46 2038 44 2011 46 2039 44 2011 46 2040 44 2012 46 2038 44 2012 46 2040 44 1500 44 2017 46 2041 40 2012 46 2038 44 2011 46 2039 45 1502 44 2012 46 2040 41 44 2035 41 59 125 64 2014 439 2042 2043 40 2042 2044 41 123 463 46 2043 40 2044 41 59 392 40 2044 46 2045 40 41 631 2046 46 2047 41 123 450 2044 59 125 2048 2049 61 2050 46 2049 40 41 59 2051 2052 61 2053 46 2054 40 2050 46 2055 40 41 44 2056 46 2057 40 2012 41 44 2050 46 2058 40 41 41 59 2051 2059 61 424 59 2060 2061 61 2050 46 2062 40 41 46 2063 40 2012 41 46 2064 40 41 59 324 2065 61 2061 614 2066 46 2067 606 2061 614 2066 46 2068 59 392 40 33 2065 605 2033 40 41 605 33 2049 46 2069 40 2012 41 41 123 392 40 33 2070 46 2071 40 2050 46 2072 40 41 46 2073 46 2074 40 2003 41 41 606 2050 46 2062 40 41 46 2075 46 2076 40 41 41 123 450 2044 46 2077 40 2046 46 2078 41 59 125 392 40 2050 46 2072 40 41 46 2079 45 2012 46 2080 40 41 60 2050 46 2081 40 41 46 2082 40 41 605 33 2050 46 2072 40 41 46 2083 41 123 2050 46 2072 40 41 46 2073 46 2084 61 2050 46 2072 40 41 46 2073 46 2074 40 2003 41 59 2059 61 418 2051 40 2052 46 2085 40 41 44 1503 41 59 392 40 2050 46 2086 40 2012 41 606 2050 46 2086 40 2012 46 2087 40 41 41 41 123 2044 46 2088 40 2089 46 2090 44 473 41 59 125 125 125 392 40 2059 631 424 41 123 2044 46 2091 40 418 2092 40 2059 44 473 41 41 59 125 360 123 2044 46 2093 40 418 2094 40 2052 44 380 41 41 59 125 392 40 2049 46 2069 40 2012 41 605 40 2050 46 2095 40 41 46 2096 45 2049 46 2097 40 41 60 1498 606 2065 41 41 123 621 392 40 2065 41 123 621 392 40 2098 46 2099 40 2050 46 2095 40 41 46 2100 46 2101 40 2006 41 41 41 123 2050 46 2095 40 41 46 2100 46 2102 61 2050 46 2095 40 41 46 2100 46 2101 40 2006 41 59 392 40 2050 46 2095 40 41 46 2103 615 1500 41 123 450 2044 46 2104 40 2105 46 2106 44 473 41 59 125 360 123 450 2044 59 125 125 360 123 392 40 2050 46 2095 40 41 46 2107 615 1500 41 123 450 2044 46 2108 40 2046 46 2109 41 59 125 621 125 125 360 123 450 2044 46 2110 40 2046 46 2111 41 59 125 125 2112 2113 61 2056 46 2057 40 2012 41 59 621 392 40 2114 46 2115 40 2050 46 2095 40 41 46 2116 43 2050 46 2095 40 41 46 2117 45 2113 46 2118 41 62 1499 606 2114 46 2115 40 2050 46 2095 40 41 46 2119 43 2050 46 2095 40 41 46 2120 45 2113 46 2121 41 62 1499 41 123 392 40 33 2050 46 2095 40 41 46 2122 605 2114 46 2115 40 2050 46 2095 40 41 46 2123 41 62 1499 41 123 2044 46 2124 40 2125 46 2126 44 473 41 59 125 2044 46 2127 40 2128 46 2129 44 473 41 59 125 2130 2131 61 2132 46 2133 40 2131 40 41 41 46 2134 40 2135 58 58 2136 41 46 2137 40 424 41 59 392 40 2131 614 424 41 123 2131 61 2011 46 2138 40 2012 41 59 125 360 123 356 2139 61 2114 46 2115 40 2131 46 2140 40 41 42 40 2113 46 2118 45 2131 46 2140 40 41 47 1502 45 2050 46 2095 40 41 46 2116 41 41 43 2114 46 2115 40 2131 46 2141 40 41 42 40 2113 46 2121 45 2131 46 2141 40 41 47 1502 45 2050 46 2095 40 41 46 2119 41 41 59 392 40 2139 60 1499 41 123 2044 46 2142 40 2143 46 2144 44 473 41 59 125 360 392 40 33 2050 46 2095 40 41 46 2145 41 123 2044 46 2146 40 2147 46 2148 44 380 41 59 125 125 392 40 2059 614 424 41 123 2112 2149 61 418 2112 40 2113 46 2118 43 1499 42 2131 46 2150 40 41 44 2113 46 2151 44 2113 46 2121 43 1499 42 2131 46 2152 40 41 41 59 2044 46 2153 40 418 2154 40 2053 46 2054 40 2050 46 2055 40 41 44 2149 44 2050 46 2058 40 41 41 44 380 41 41 59 125 450 2044 59 125 437 2155 2156 40 41 123 385 40 404 2157 61 1500 59 2157 60 1503 59 2157 637 41 123 2158 2044 61 2159 46 2160 40 41 46 2161 40 2159 46 2162 40 41 46 2163 40 2157 41 41 59 392 40 2044 46 2164 40 41 614 2165 46 2166 41 123 450 2044 46 2167 40 2168 46 2169 41 59 125 125 450 424 59 125 64 2014 439 324 2170 40 2042 2044 41 123 621 621 450 2171 46 2172 40 41 46 2173 40 2011 41 606 2044 46 2174 40 41 631 2175 46 2176 59 125 437 457 2010 91 93 2177 40 2010 2011 44 2010 2012 41 123 2010 91 93 2178 59 404 2179 61 2011 46 2180 40 41 45 2012 46 2180 40 41 59 404 2181 61 2011 46 2182 40 41 45 2012 46 2182 40 41 59 404 2183 61 2011 46 2184 40 41 45 2012 46 2184 40 41 59 2178 61 418 2010 91 2183 43 1502 93 59 385 40 404 2185 61 1500 59 2185 60 2178 46 2186 59 2185 637 41 123 2178 91 2185 93 61 418 2010 40 2011 46 2180 40 41 45 2179 44 2011 46 2184 40 41 43 1501 45 2185 44 2011 46 2182 40 41 45 2181 41 59 125 450 2178 59 125 64 2014 438 324 2187 40 2042 2044 41 123 392 40 2044 46 2188 40 41 614 2189 46 2190 41 123 450 473 59 125 621 621 385 40 404 2191 61 1500 59 2191 60 1502 605 2191 60 2192 46 2193 59 2191 637 41 123 392 40 33 2194 46 2195 40 2196 44 2192 91 2191 93 41 41 123 450 463 46 2187 40 2044 41 59 125 125 450 473 59 125 125 
29350,Java,"	public static abstract class EclipseSingularizer {
		protected static final long[] NULL_POSS = {0L};
		public abstract LombokImmutableList<String> getSupportedTypes();
		
		/** Checks if any of the to-be-generated nodes (fields, methods) already exist. If so, errors on these (singulars don't support manually writing some of it, and returns true). */
		public boolean checkForAlreadyExistingNodesAndGenerateError(EclipseNode builderType, SingularData data) {
			for (EclipseNode child : builderType.down()) {
				switch (child.getKind()) {
				case FIELD: {
					FieldDeclaration fd = (FieldDeclaration) child.get();
					char[] name = fd.name;
					if (name == null) continue;
					if (getGeneratedBy(fd) != null) continue;
					for (char[] fieldToBeGenerated : listFieldsToBeGenerated(data, builderType)) {
						if (!Arrays.equals(name, fieldToBeGenerated)) continue;
						child.addError(""Manually adding a field that @Singular @Builder would generate is not supported. If you want to manually manage the builder aspect for this field/parameter, don't use @Singular."");
						return true;
					}
					break;
				}
				case METHOD: {
					AbstractMethodDeclaration method = (AbstractMethodDeclaration) child.get();
					char[] name = method.selector;
					if (name == null) continue;
					if (getGeneratedBy(method) != null) continue;
					for (char[] methodToBeGenerated : listMethodsToBeGenerated(data, builderType)) {
						if (!Arrays.equals(name, methodToBeGenerated)) continue;
						child.addError(""Manually adding a method that @Singular @Builder would generate is not supported. If you want to manually manage the builder aspect for this field/parameter, don't use @Singular."");
						return true;
					}
					break;
				}}
			}
			
			return false;
		}
		
		public List<char[]> listFieldsToBeGenerated(SingularData data, EclipseNode builderType) {
			return Collections.singletonList(data.pluralName);
		}
		
		public List<char[]> listMethodsToBeGenerated(SingularData data, EclipseNode builderType) {
			char[] p = data.pluralName;
			char[] s = data.singularName;
			if (Arrays.equals(p, s)) return Collections.singletonList(p);
			return Arrays.asList(p, s);
		}
		
		public abstract List<EclipseNode> generateFields(SingularData data, EclipseNode builderType);
		
		/**
		 * Generates the singular, plural, and clear methods for the given {@link SingularData}.
		 * Uses the given {@code builderType} as return type if {@code chain == true}, {@code void} otherwise.
		 * If you need more control over the return type and value, use
		 * {@link #generateMethods(SingularData, boolean, EclipseNode, boolean, TypeReferenceMaker, StatementMaker)}.
		 */
		public void generateMethods(final BuilderJob job, SingularData data, boolean deprecate) {
			TypeReferenceMaker returnTypeMaker = new TypeReferenceMaker() {
				@Override public TypeReference make() {
					return job.oldChain ? cloneSelfType(job.builderType) : TypeReference.baseTypeReference(TypeIds.T_void, 0);
				}
			};
			
			StatementMaker returnStatementMaker = new StatementMaker() {
				@Override public ReturnStatement make() {
					return job.oldChain ? new ReturnStatement(new ThisReference(0, 0), 0, 0) : null;
				}
			};
			
			generateMethods(job.checkerFramework, data, deprecate, job.builderType, job.oldFluent, returnTypeMaker, returnStatementMaker, job.accessInners);
		}
		
		/**
		 * Generates the singular, plural, and clear methods for the given {@link SingularData}.
		 * Uses the given {@code returnTypeMaker} and {@code returnStatementMaker} for the generated methods.
		 */
		public abstract void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, EclipseNode builderType, boolean fluent, TypeReferenceMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access);
		
		public abstract void appendBuildCode(SingularData data, EclipseNode builderType, List<Statement> statements, char[] targetVariableName, String builderVariable);
		
		public boolean shadowedDuringBuild() {
			return true;
		}
		
		public boolean requiresCleaning() {
			try {
				return !getClass().getMethod(""appendCleaningCode"", SingularData.class, EclipseNode.class, List.class).getDeclaringClass().equals(EclipseSingularizer.class);
			} catch (NoSuchMethodException e) {
				return false;
			}
		}
		
		public void appendCleaningCode(SingularData data, EclipseNode builderType, List<Statement> statements) {
		}
		
		// -- Utility methods --
		
		protected Annotation[] generateSelfReturnAnnotations(boolean deprecate, CheckerFrameworkVersion cfv, ASTNode source) {
			Annotation deprecated = deprecate ? generateDeprecatedAnnotation(source) : null;
			Annotation returnsReceiver = cfv.generateReturnsReceiver() ? generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER) : null;
			if (deprecated == null && returnsReceiver == null) return null;
			if (deprecated == null) return new Annotation[] {returnsReceiver};
			if (returnsReceiver == null) return new Annotation[] {deprecated};
			return new Annotation[] {deprecated, returnsReceiver};
		}
		
		/**
		 * Adds the requested number of type arguments to the provided type, copying each argument in {@code typeArgs}. If typeArgs is too long, the extra elements are ignored.
		 * If {@code typeArgs} is null or too short, {@code java.lang.Object} will be substituted for each missing type argument.
		 * 
		 * @param count The number of type arguments requested.
		 * @param addExtends If {@code true}, all bounds are either '? extends X' or just '?'. If false, the reverse is applied, and '? extends Foo' is converted to Foo, '?' to Object, etc.
		 * @param node Some node in the same AST. Just used to obtain makers and contexts and such.
		 * @param type The type to add generics to.
		 * @param typeArgs the list of type args to clone.
		 * @param source The source annotation that is the root cause of this code generation.
		 */
		protected TypeReference addTypeArgs(int count, boolean addExtends, EclipseNode node, TypeReference type, List<TypeReference> typeArgs) {
			TypeReference[] clonedAndFixedArgs = createTypeArgs(count, addExtends, node, typeArgs);
			if (type instanceof SingleTypeReference) {
				type = new ParameterizedSingleTypeReference(((SingleTypeReference) type).token, clonedAndFixedArgs, 0, 0L);
			} else if (type instanceof QualifiedTypeReference) {
				QualifiedTypeReference qtr = (QualifiedTypeReference) type;
				TypeReference[][] trs = new TypeReference[qtr.tokens.length][];
				trs[qtr.tokens.length - 1] = clonedAndFixedArgs;
				type = new ParameterizedQualifiedTypeReference(((QualifiedTypeReference) type).tokens, trs, 0, NULL_POSS);
			} else {
				node.addError(""Don't know how to clone-and-parameterize type: "" + type);
			}
			
			return type;
		}
		
		protected TypeReference[] createTypeArgs(int count, boolean addExtends, EclipseNode node, List<TypeReference> typeArgs) {
			if (count < 0) throw new IllegalArgumentException(""count is negative"");
			if (count == 0) return null;
			List<TypeReference> arguments = new ArrayList<TypeReference>();
			
			if (typeArgs != null) for (TypeReference orig : typeArgs) {
				Wildcard wildcard = orig instanceof Wildcard ? (Wildcard) orig : null;
				if (!addExtends) {
					if (wildcard != null && (wildcard.kind == Wildcard.UNBOUND || wildcard.kind == Wildcard.SUPER)) {
						arguments.add(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, NULL_POSS));
					} else if (wildcard != null && wildcard.kind == Wildcard.EXTENDS) {
						try {
							arguments.add(copyType(wildcard.bound));
						} catch (Exception e) {
							arguments.add(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, NULL_POSS));
						}
					} else {
						arguments.add(copyType(orig));
					}
				} else {
					if (wildcard != null && (wildcard.kind == Wildcard.UNBOUND || wildcard.kind == Wildcard.SUPER)) {
						Wildcard w = new Wildcard(Wildcard.UNBOUND);
						arguments.add(w);
					} else if (wildcard != null && wildcard.kind == Wildcard.EXTENDS) {
						arguments.add(copyType(orig));
					} else {
						Wildcard w = new Wildcard(Wildcard.EXTENDS);
						w.bound = copyType(orig);
						arguments.add(w);
					}
				}
				if (--count == 0) break;
			}
			
			while (count-- > 0) {
				if (addExtends) {
					arguments.add(new Wildcard(Wildcard.UNBOUND));
				} else {
					arguments.add(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, NULL_POSS));
				}
			}
			
			if (arguments.isEmpty()) return null;
			return arguments.toArray(new TypeReference[0]);
		}
		
		private static final char[] SIZE_TEXT = new char[] {'s', 'i', 'z', 'e'};
		
		/** Generates 'this.<em>name</em>.size()' as an expression; if nullGuard is true, it's this.name == null ? 0 : this.name.size(). */
		protected Expression getSize(EclipseNode builderType, char[] name, boolean nullGuard, String builderVariable) {
			MessageSend invoke = new MessageSend();
			Reference thisRef = getBuilderReference(builderVariable);
			FieldReference thisDotName = new FieldReference(name, 0L);
			thisDotName.receiver = thisRef;
			invoke.receiver = thisDotName;
			invoke.selector = SIZE_TEXT;
			if (!nullGuard) return invoke;
			
			Reference cdnThisRef = getBuilderReference(builderVariable);
			FieldReference cdnThisDotName = new FieldReference(name, 0L);
			cdnThisDotName.receiver = cdnThisRef;
			NullLiteral nullLiteral = new NullLiteral(0, 0);
			EqualExpression isNull = new EqualExpression(cdnThisDotName, nullLiteral, OperatorIds.EQUAL_EQUAL);
			IntLiteral zeroLiteral = makeIntLiteral(new char[] {'0'}, null);
			ConditionalExpression conditional = new ConditionalExpression(isNull, zeroLiteral, invoke);
			return conditional;
		}
		
		protected TypeReference cloneParamType(int index, List<TypeReference> typeArgs, EclipseNode builderType) {
			if (typeArgs != null && typeArgs.size() > index) {
				TypeReference originalType = typeArgs.get(index);
				if (originalType instanceof Wildcard) {
					Wildcard wOriginalType = (Wildcard) originalType;
					if (wOriginalType.kind == Wildcard.EXTENDS) {
						try {
							return copyType(wOriginalType.bound);
						} catch (Exception e) {
							// fallthrough
						}
					}
				} else {
					return copyType(originalType);
				}
			}
			
			return new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, NULL_POSS);
		}
		
		/** @return a {@code SingleNameReference} to the builder in the variable <code>builderVariable</code>. If {@ code builderVariable == ""this""}, a {@code ThisReference} is returned. */
		protected static Reference getBuilderReference(String builderVariable) {
			if (""this"".equals(builderVariable)) {
				return new ThisReference(0, 0);
			} else {
				return new SingleNameReference(builderVariable.toCharArray(), 0);
			}
		}
		
		protected void nullBehaviorize(EclipseNode typeNode, SingularData data, List<Statement> statements, Argument arg) {
			boolean ignoreNullCollections = data.isIgnoreNullCollections();
			
			if (ignoreNullCollections) {
				Expression isNotNull = new EqualExpression(new SingleNameReference(data.getPluralName(), 0L), new NullLiteral(0, 0), OperatorIds.NOT_EQUAL);
				Block b = new Block(0);
				b.statements = statements.toArray(new Statement[statements.size()]);
				statements.clear();
				statements.add(new IfStatement(isNotNull, b, 0, 0));
				EclipseHandlerUtil.createRelevantNullableAnnotation(typeNode, arg);
				return;
			}
			
			EclipseHandlerUtil.createRelevantNonNullAnnotation(typeNode, arg);
			Statement nullCheck = EclipseHandlerUtil.generateNullCheck(null, data.getPluralName(), typeNode, ""%s cannot be null"");
			statements.add(0, nullCheck);
		}
		
		protected abstract int getTypeArgumentsCount();
		
		protected abstract char[][] getEmptyMakerReceiver(String targetFqn);
		protected abstract char[] getEmptyMakerSelector(String targetFqn);
		
		public MessageSend getEmptyExpression(String targetFqn, SingularData data, EclipseNode typeNode, ASTNode source) {
			MessageSend send = new MessageSend();
			send.receiver = generateQualifiedNameRef(source, getEmptyMakerReceiver(targetFqn));
			send.selector = getEmptyMakerSelector(targetFqn);
			send.typeArguments = createTypeArgs(getTypeArgumentsCount(), false, typeNode, data.getTypeArgs());
			return send;
		}
	}",1,439 457 305 334 2000 123 438 457 381 413 91 93 2001 61 123 1500 125 59 439 305 2002 60 2003 62 2004 40 41 59 618 439 324 2005 40 2006 2007 44 2008 2009 41 123 385 40 2006 2010 58 2007 46 2011 40 41 41 123 464 40 2010 46 2012 40 41 41 123 328 2013 58 123 2014 2015 61 40 2014 41 2010 46 2016 40 41 59 330 91 93 2017 61 2015 46 2017 59 392 40 2017 614 424 41 344 59 392 40 2018 40 2015 41 631 424 41 344 59 385 40 330 91 93 2019 58 2020 40 2009 44 2007 41 41 123 392 40 33 2021 46 2022 40 2017 44 2019 41 41 344 59 2010 46 2023 40 648 41 59 450 473 59 125 325 59 125 328 2024 58 123 2025 2026 61 40 2025 41 2010 46 2027 40 41 59 330 91 93 2028 61 2026 46 2029 59 392 40 2028 614 424 41 344 59 392 40 2030 40 2026 41 631 424 41 344 59 385 40 330 91 93 2031 58 2032 40 2009 44 2007 41 41 123 392 40 33 2033 46 2034 40 2028 44 2031 41 41 344 59 2010 46 2035 40 648 41 59 450 473 59 125 325 59 125 125 125 450 380 59 125 439 2036 60 330 91 93 62 2037 40 2008 2009 44 2006 2007 41 123 450 2038 46 2039 40 2009 46 2040 41 59 125 439 2036 60 330 91 93 62 2041 40 2008 2009 44 2006 2007 41 123 330 91 93 2042 61 2009 46 2043 59 330 91 93 2044 61 2009 46 2045 59 392 40 2046 46 2047 40 2042 44 2044 41 41 450 2048 46 2049 40 2042 41 59 450 2046 46 2050 40 2042 44 2044 41 59 125 439 305 2036 60 2006 62 2051 40 2008 2009 44 2006 2007 41 59 618 439 492 2052 40 381 2053 2054 44 2008 2009 44 324 2055 41 123 2056 2057 61 418 2056 40 41 123 64 2058 439 2059 2060 40 41 123 450 2054 46 2061 63 2062 40 2054 46 2007 41 58 2059 46 2063 40 2064 46 2065 44 1500 41 59 125 125 59 2066 2067 61 418 2066 40 41 123 64 2068 439 2069 2070 40 41 123 450 2054 46 2071 63 418 2069 40 418 2072 40 1500 44 1500 41 44 1500 44 1500 41 58 424 59 125 125 59 2052 40 2054 46 2073 44 2009 44 2055 44 2054 46 2007 44 2054 46 2074 44 2057 44 2067 44 2054 46 2075 41 59 125 618 439 305 492 2052 40 2076 2077 44 2008 2009 44 324 2055 44 2006 2007 44 324 2078 44 2079 2080 44 2081 2082 44 2083 2084 41 59 439 305 492 2085 40 2008 2009 44 2006 2007 44 2036 60 2086 62 2087 44 330 91 93 2088 44 2003 2089 41 59 439 324 2090 40 41 123 450 473 59 125 439 324 2091 40 41 123 474 123 450 33 2092 40 41 46 2093 40 648 44 2008 46 334 44 2006 46 334 44 2036 46 334 41 46 2094 40 41 46 2095 40 2000 46 334 41 59 125 329 40 2096 2097 41 123 450 380 59 125 125 439 492 2098 40 2008 2009 44 2006 2007 44 2036 60 2086 62 2087 41 123 125 621 438 2099 91 93 2100 40 324 2055 44 2076 2077 44 2101 2102 41 123 2099 2103 61 2055 63 2104 40 2102 41 58 424 59 2099 2105 61 2077 46 2106 40 41 63 2107 40 2102 44 2076 46 2108 41 58 424 59 392 40 2103 614 424 605 2105 614 424 41 450 424 59 392 40 2103 614 424 41 450 418 2099 91 93 123 2105 125 59 392 40 2105 614 424 41 450 418 2099 91 93 123 2103 125 59 450 418 2099 91 93 123 2103 44 2105 125 59 125 618 438 2109 2110 40 404 2111 44 324 2112 44 2006 2113 44 2109 2114 44 2036 60 2109 62 2115 41 123 2109 91 93 2116 61 2117 40 2111 44 2112 44 2113 44 2115 41 59 392 40 2114 402 2118 41 123 2114 61 418 2119 40 40 40 2118 41 2114 41 46 2120 44 2116 44 1500 44 1500 41 59 125 360 392 40 2114 402 2121 41 123 2121 2122 61 40 2121 41 2114 59 2109 91 93 91 93 2123 61 418 2109 91 2122 46 2124 46 2125 93 91 93 59 2123 91 2122 46 2124 46 2125 45 1501 93 61 2116 59 2114 61 418 2126 40 40 40 2121 41 2114 41 46 2124 44 2123 44 1500 44 2001 41 59 125 360 123 2113 46 2127 40 648 43 2114 41 59 125 450 2114 59 125 438 2109 91 93 2128 40 404 2111 44 324 2112 44 2006 2113 44 2036 60 2109 62 2115 41 123 392 40 2111 60 1500 41 469 418 2129 40 648 41 59 392 40 2111 614 1500 41 450 424 59 2036 60 2109 62 2130 61 418 2131 60 2109 62 40 41 59 392 40 2115 631 424 41 385 40 2109 2132 58 2115 41 123 2133 2134 61 2132 402 2133 63 40 2133 41 2132 58 424 59 392 40 33 2112 41 123 392 40 2134 631 424 605 40 2134 46 2135 614 2133 46 2136 606 2134 46 2135 614 2133 46 2137 41 41 123 2130 46 2138 40 418 2139 40 2140 46 2141 44 2001 41 41 59 125 360 392 40 2134 631 424 605 2134 46 2135 614 2133 46 2142 41 123 474 123 2130 46 2143 40 2144 40 2134 46 2145 41 41 59 125 329 40 2146 2147 41 123 2130 46 2148 40 418 2149 40 2150 46 2151 44 2001 41 41 59 125 125 360 123 2130 46 2152 40 2153 40 2132 41 41 59 125 125 360 123 392 40 2134 631 424 605 40 2134 46 2154 614 2133 46 2155 606 2134 46 2154 614 2133 46 2156 41 41 123 2133 2157 61 418 2133 40 2133 46 2155 41 59 2130 46 2158 40 2157 41 59 125 360 392 40 2134 631 424 605 2134 46 2154 614 2133 46 2159 41 123 2130 46 2160 40 2161 40 2132 41 41 59 125 360 123 2133 2162 61 418 2133 40 2133 46 2159 41 59 2162 46 2163 61 2164 40 2132 41 59 2130 46 2165 40 2162 41 59 125 125 392 40 629 2111 614 1500 41 325 59 125 496 40 2111 629 62 1500 41 123 392 40 2112 41 123 2130 46 2166 40 418 2167 40 2167 46 2168 41 41 59 125 360 123 2130 46 2169 40 418 2170 40 2171 46 2172 44 2001 41 41 59 125 125 392 40 2130 46 2173 40 41 41 450 424 59 450 2130 46 2174 40 418 2109 91 1500 93 41 59 125 437 457 381 330 91 93 2175 61 418 330 91 93 123 607 44 607 44 607 44 607 125 59 618 438 2176 2177 40 2006 2007 44 330 91 93 2178 44 324 2179 44 2003 2089 41 123 2180 2181 61 418 2180 40 41 59 2182 2183 61 2184 40 2089 41 59 2185 2186 61 418 2185 40 2178 44 1500 41 59 2186 46 2187 61 2183 59 2181 46 2187 61 2186 59 2181 46 2188 61 2175 59 392 40 33 2179 41 450 2181 59 2182 2189 61 2184 40 2089 41 59 2185 2190 61 418 2185 40 2178 44 1500 41 59 2190 46 2187 61 2189 59 2191 2192 61 418 2191 40 1500 44 1500 41 59 2193 2194 61 418 2193 40 2190 44 2192 44 2195 46 2196 41 59 2197 2198 61 2199 40 418 330 91 93 123 607 125 44 424 41 59 2200 2201 61 418 2200 40 2194 44 2198 44 2181 41 59 450 2201 59 125 438 2109 2202 40 404 2203 44 2036 60 2109 62 2115 44 2006 2007 41 123 392 40 2115 631 424 605 2115 46 2204 40 41 62 2203 41 123 2109 2205 61 2115 46 2206 40 2203 41 59 392 40 2205 402 2207 41 123 2207 2208 61 40 2207 41 2205 59 392 40 2208 46 2209 614 2207 46 2210 41 123 474 123 450 2211 40 2208 46 2212 41 59 125 329 40 2213 2214 41 123 621 125 125 125 360 123 450 2215 40 2205 41 59 125 125 450 418 2216 40 2217 46 2218 44 2001 41 59 125 618 438 457 2219 2220 40 2003 2089 41 123 392 40 648 46 2221 40 2089 41 41 123 450 418 2222 40 1500 44 1500 41 59 125 360 123 450 418 2223 40 2089 46 2224 40 41 44 1500 41 59 125 125 438 492 2225 40 2006 2226 44 2008 2009 44 2036 60 2086 62 2087 44 2227 2228 41 123 324 2229 61 2009 46 2230 40 41 59 392 40 2229 41 123 2176 2231 61 418 2232 40 418 2233 40 2009 46 2234 40 41 44 1500 41 44 418 2235 40 1500 44 1500 41 44 2236 46 2237 41 59 2238 2239 61 418 2238 40 1500 41 59 2239 46 2087 61 2087 46 2240 40 418 2086 91 2087 46 2241 40 41 93 41 59 2087 46 2242 40 41 59 2087 46 2243 40 418 2244 40 2231 44 2239 44 1500 44 1500 41 41 59 2245 46 2246 40 2226 44 2228 41 59 450 59 125 2247 46 2248 40 2226 44 2228 41 59 2086 2249 61 2247 46 2250 40 424 44 2009 46 2251 40 41 44 2226 44 648 41 59 2087 46 2252 40 1500 44 2249 41 59 125 438 305 404 2253 40 41 59 438 305 330 91 93 91 93 2254 40 2003 2255 41 59 438 305 330 91 93 2256 40 2003 2255 41 59 439 2257 2258 40 2003 2255 44 2008 2009 44 2006 2226 44 2101 2102 41 123 2257 2259 61 418 2257 40 41 59 2259 46 2260 61 2261 40 2102 44 2254 40 2255 41 41 59 2259 46 2262 61 2256 40 2255 41 59 2259 46 2263 61 2128 40 2253 40 41 44 380 44 2226 44 2009 46 2264 40 41 41 59 450 2259 59 125 125 
2644,Java,"public abstract class AbstractNodeCostSearch implements IPathFinder, Helper {

    protected final int startX;
    protected final int startY;
    protected final int startZ;

    protected final Goal goal;

    private final CalculationContext context;

    /**
     * @see <a href=""https://github.com/cabaletta/baritone/issues/107"">Issue #107</a>
     */
    private final Long2ObjectOpenHashMap<PathNode> map;

    protected PathNode startNode;

    protected PathNode mostRecentConsidered;

    protected final PathNode[] bestSoFar = new PathNode[COEFFICIENTS.length];

    private volatile boolean isFinished;

    protected boolean cancelRequested;

    /**
     * This is really complicated and hard to explain. I wrote a comment in the old version of MineBot but it was so
     * long it was easier as a Google Doc (because I could insert charts).
     *
     * @see <a href=""https://docs.google.com/document/d/1WVHHXKXFdCR1Oz__KtK8sFqyvSwJN_H4lftkHFgmzlc/edit"">here</a>
     */
    protected static final double[] COEFFICIENTS = {1.5, 2, 2.5, 3, 4, 5, 10};

    /**
     * If a path goes less than 5 blocks and doesn't make it to its goal, it's not worth considering.
     */
    protected static final double MIN_DIST_PATH = 5;

    /**
     * there are floating point errors caused by random combinations of traverse and diagonal over a flat area
     * that means that sometimes there's a cost improvement of like 10 ^ -16
     * it's not worth the time to update the costs, decrease-key the heap, potentially repropagate, etc
     * <p>
     * who cares about a hundredth of a tick? that's half a millisecond for crying out loud!
     */
    protected static final double MIN_IMPROVEMENT = 0.01;

    AbstractNodeCostSearch(int startX, int startY, int startZ, Goal goal, CalculationContext context) {
        this.startX = startX;
        this.startY = startY;
        this.startZ = startZ;
        this.goal = goal;
        this.context = context;
        this.map = new Long2ObjectOpenHashMap<>(Baritone.settings().pathingMapDefaultSize.value, Baritone.settings().pathingMapLoadFactor.value);
    }

    public void cancel() {
        cancelRequested = true;
    }

    @Override
    public synchronized PathCalculationResult calculate(long primaryTimeout, long failureTimeout) {
        if (isFinished) {
            throw new IllegalStateException(""Path finder cannot be reused!"");
        }
        cancelRequested = false;
        try {
            IPath path = calculate0(primaryTimeout, failureTimeout).map(IPath::postProcess).orElse(null);
            if (cancelRequested) {
                return new PathCalculationResult(PathCalculationResult.Type.CANCELLATION);
            }
            if (path == null) {
                return new PathCalculationResult(PathCalculationResult.Type.FAILURE);
            }
            int previousLength = path.length();
            path = path.cutoffAtLoadedChunks(context.bsi);
            if (path.length() < previousLength) {
                Helper.HELPER.logDebug(""Cutting off path at edge of loaded chunks"");
                Helper.HELPER.logDebug(""Length decreased by "" + (previousLength - path.length()));
            } else {
                Helper.HELPER.logDebug(""Path ends within loaded chunks"");
            }
            previousLength = path.length();
            path = path.staticCutoff(goal);
            if (path.length() < previousLength) {
                Helper.HELPER.logDebug(""Static cutoff "" + previousLength + "" to "" + path.length());
            }
            if (goal.isInGoal(path.getDest())) {
                return new PathCalculationResult(PathCalculationResult.Type.SUCCESS_TO_GOAL, path);
            } else {
                return new PathCalculationResult(PathCalculationResult.Type.SUCCESS_SEGMENT, path);
            }
        } catch (Exception e) {
            Helper.HELPER.logDirect(""Pathing exception: "" + e);
            e.printStackTrace();
            return new PathCalculationResult(PathCalculationResult.Type.EXCEPTION);
        } finally {
            // this is run regardless of what exception may or may not be raised by calculate0
            isFinished = true;
        }
    }

    protected abstract Optional<IPath> calculate0(long primaryTimeout, long failureTimeout);

    /**
     * Determines the distance squared from the specified node to the start
     * node. Intended for use in distance comparison, rather than anything that
     * considers the real distance value, hence the ""sq"".
     *
     * @param n A node
     * @return The distance, squared
     */
    protected double getDistFromStartSq(PathNode n) {
        int xDiff = n.x - startX;
        int yDiff = n.y - startY;
        int zDiff = n.z - startZ;
        return xDiff * xDiff + yDiff * yDiff + zDiff * zDiff;
    }

    /**
     * Attempts to search the block position hashCode long to {@link PathNode} map
     * for the node mapped to the specified pos. If no node is found,
     * a new node is created.
     *
     * @param x        The x position of the node
     * @param y        The y position of the node
     * @param z        The z position of the node
     * @param hashCode The hash code of the node, provided by {@link BetterBlockPos#longHash(int, int, int)}
     * @return The associated node
     * @see <a href=""https://github.com/cabaletta/baritone/issues/107"">Issue #107</a>
     */

    protected PathNode getNodeAtPosition(int x, int y, int z, long hashCode) {
        PathNode node = map.get(hashCode);
        if (node == null) {
            node = new PathNode(x, y, z, goal);
            map.put(hashCode, node);
        }
        return node;
    }

    @Override
    public Optional<IPath> pathToMostRecentNodeConsidered() {
        return Optional.ofNullable(mostRecentConsidered).map(node -> new Path(startNode, node, 0, goal, context));
    }

    @Override
    public Optional<IPath> bestPathSoFar() {
        return bestSoFar(false, 0);
    }

    protected Optional<IPath> bestSoFar(boolean logInfo, int numNodes) {
        if (startNode == null) {
            return Optional.empty();
        }
        double bestDist = 0;
        for (int i = 0; i < COEFFICIENTS.length; i++) {
            if (bestSoFar[i] == null) {
                continue;
            }
            double dist = getDistFromStartSq(bestSoFar[i]);
            if (dist > bestDist) {
                bestDist = dist;
            }
            if (dist > MIN_DIST_PATH * MIN_DIST_PATH) { // square the comparison since distFromStartSq is squared
                if (logInfo) {
                    if (COEFFICIENTS[i] >= 3) {
                        System.out.println(""Warning: cost coefficient is greater than three! Probably means that"");
                        System.out.println(""the path I found is pretty terrible (like sneak-bridging for dozens of blocks)"");
                        System.out.println(""But I'm going to do it anyway, because yolo"");
                    }
                    System.out.println(""Path goes for "" + Math.sqrt(dist) + "" blocks"");
                    logDebug(""A* cost coefficient "" + COEFFICIENTS[i]);
                }
                return Optional.of(new Path(startNode, bestSoFar[i], numNodes, goal, context));
            }
        }
        // instead of returning bestSoFar[0], be less misleading
        // if it actually won't find any path, don't make them think it will by rendering a dark blue that will never actually happen
        if (logInfo) {
            logDebug(""Even with a cost coefficient of "" + COEFFICIENTS[COEFFICIENTS.length - 1] + "", I couldn't get more than "" + Math.sqrt(bestDist) + "" blocks"");
            logDebug(""No path found =("");
            logNotification(""No path found =("", true);
        }
        return Optional.empty();
    }

    @Override
    public final boolean isFinished() {
        return isFinished;
    }

    @Override
    public final Goal getGoal() {
        return goal;
    }

    public BetterBlockPos getStart() {
        return new BetterBlockPos(startX, startY, startZ);
    }

    protected int mapSize() {
        return map.size();
    }
}",1,439 305 334 2000 395 2001 44 2002 123 438 381 404 2003 59 438 381 404 2004 59 438 381 404 2005 59 438 381 2006 2007 59 437 381 2008 2009 59 618 437 381 2010 60 2011 62 2012 59 438 2011 2013 59 438 2011 2014 59 438 381 2011 91 93 2015 61 418 2011 91 2016 46 2017 93 59 437 493 324 2018 59 438 324 2019 59 618 438 457 381 356 91 93 2016 61 123 1502 44 1502 44 1502 44 1502 44 1502 44 1502 44 1502 125 59 618 438 457 381 356 2020 61 1502 59 618 438 457 381 356 2021 61 1498 59 2000 40 404 2003 44 404 2004 44 404 2005 44 2006 2007 44 2008 2009 41 123 467 46 2003 61 2003 59 467 46 2004 61 2004 59 467 46 2005 61 2005 59 467 46 2007 61 2007 59 467 46 2009 61 2009 59 467 46 2012 61 418 2010 60 62 40 2022 46 2023 40 41 46 2024 46 2025 44 2022 46 2023 40 41 46 2026 46 2025 41 59 125 439 492 2027 40 41 123 2019 61 473 59 125 64 2028 439 465 2029 2030 40 413 2031 44 413 2032 41 123 392 40 2018 41 123 469 418 2033 40 648 41 59 125 2019 61 380 59 474 123 2034 2035 61 2036 40 2031 44 2032 41 46 2012 40 2034 58 58 2037 41 46 2038 40 424 41 59 392 40 2019 41 123 450 418 2029 40 2029 46 2039 46 2040 41 59 125 392 40 2035 614 424 41 123 450 418 2029 40 2029 46 2041 46 2042 41 59 125 404 2043 61 2035 46 2017 40 41 59 2035 61 2035 46 2044 40 2009 46 2045 41 59 392 40 2035 46 2017 40 41 60 2043 41 123 2002 46 2046 46 2047 40 648 41 59 2002 46 2046 46 2047 40 648 43 40 2043 45 2035 46 2017 40 41 41 41 59 125 360 123 2002 46 2048 46 2049 40 648 41 59 125 2043 61 2035 46 2017 40 41 59 2035 61 2035 46 2050 40 2007 41 59 392 40 2035 46 2017 40 41 60 2043 41 123 2002 46 2051 46 2052 40 648 43 2043 43 648 43 2035 46 2017 40 41 41 59 125 392 40 2007 46 2053 40 2035 46 2054 40 41 41 41 123 450 418 2029 40 2029 46 2055 46 2056 44 2035 41 59 125 360 123 450 418 2029 40 2029 46 2057 46 2058 44 2035 41 59 125 125 329 40 2059 2060 41 123 2002 46 2061 46 2062 40 648 43 2060 41 59 2060 46 2063 40 41 59 450 418 2029 40 2029 46 2064 46 2065 41 59 125 382 123 621 2018 61 473 59 125 125 438 305 2066 60 2067 62 2068 40 413 2031 44 413 2032 41 59 618 438 356 2069 40 2011 2070 41 123 404 2071 61 2070 46 2072 45 2003 59 404 2073 61 2070 46 2074 45 2004 59 404 2075 61 2070 46 2076 45 2005 59 450 2071 42 2071 43 2073 42 2073 43 2075 42 2075 59 125 618 438 2011 2077 40 404 2078 44 404 2079 44 404 2080 44 413 2081 41 123 2011 2082 61 2012 46 2083 40 2081 41 59 392 40 2082 614 424 41 123 2082 61 418 2011 40 2078 44 2079 44 2080 44 2007 41 59 2012 46 2084 40 2081 44 2082 41 59 125 450 2082 59 125 64 2028 439 2066 60 2067 62 2085 40 41 123 450 2066 46 2086 40 2014 41 46 2012 40 2087 45 62 418 2088 40 2013 44 2087 44 1500 44 2007 44 2009 41 41 59 125 64 2028 439 2066 60 2067 62 2089 40 41 123 450 2015 40 380 44 1500 41 59 125 438 2066 60 2067 62 2015 40 324 2090 44 404 2091 41 123 392 40 2013 614 424 41 123 450 2066 46 362 40 41 59 125 356 2092 61 1500 59 385 40 404 2093 61 1500 59 2093 60 2016 46 2017 59 2093 637 41 123 392 40 2015 91 2093 93 614 424 41 123 344 59 125 356 2094 61 2069 40 2015 91 2093 93 41 59 392 40 2094 62 2092 41 123 2092 61 2094 59 125 392 40 2094 62 2020 42 2020 41 123 621 392 40 2090 41 123 392 40 2016 91 2093 93 615 1502 41 123 2095 46 430 46 2096 40 648 41 59 2095 46 430 46 2096 40 648 41 59 2095 46 430 46 2096 40 648 41 59 125 2097 46 430 46 2098 40 648 43 2099 46 2100 40 2094 41 43 648 41 59 2101 40 648 43 2016 91 2093 93 41 59 125 450 2066 46 2102 40 418 2103 40 2013 44 2015 91 2093 93 44 2091 44 2007 44 2009 41 41 59 125 125 621 621 392 40 2090 41 123 2104 40 648 43 2016 91 2016 46 2017 45 1501 93 43 648 43 2105 46 2106 40 2092 41 43 648 41 59 2104 40 648 41 59 2107 40 648 44 473 41 59 125 450 2066 46 362 40 41 59 125 64 2028 439 381 324 2018 40 41 123 450 2018 59 125 64 2028 439 381 2006 2108 40 41 123 450 2007 59 125 439 2109 2110 40 41 123 450 418 2109 40 2003 44 2004 44 2005 41 59 125 438 404 2111 40 41 123 450 2012 46 2112 40 41 59 125 125 
2747,Java,"public class BtcWalletService extends WalletService {
    private static final Logger log = LoggerFactory.getLogger(BtcWalletService.class);

    private final AddressEntryList addressEntryList;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public BtcWalletService(WalletsSetup walletsSetup,
                            AddressEntryList addressEntryList,
                            Preferences preferences,
                            FeeService feeService) {
        super(walletsSetup,
                preferences,
                feeService);

        this.addressEntryList = addressEntryList;

        walletsSetup.addSetupCompletedHandler(() -> {
            wallet = walletsSetup.getBtcWallet();
            addListenersToWallet();

            walletsSetup.getChain().addNewBestBlockListener(block -> chainHeightProperty.set(block.getHeight()));
            chainHeightProperty.set(walletsSetup.getChain().getBestChainHeight());
        });
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Overridden Methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    void decryptWallet(@NotNull KeyParameter key) {
        super.decryptWallet(key);

        addressEntryList.getAddressEntriesAsListImmutable().forEach(e -> {
            DeterministicKey keyPair = e.getKeyPair();
            if (keyPair.isEncrypted())
                e.setDeterministicKey(keyPair.decrypt(key));
        });
        addressEntryList.requestPersistence();
    }

    @Override
    void encryptWallet(KeyCrypterScrypt keyCrypterScrypt, KeyParameter key) {
        super.encryptWallet(keyCrypterScrypt, key);
        addressEntryList.getAddressEntriesAsListImmutable().forEach(e -> {
            DeterministicKey keyPair = e.getKeyPair();
            if (keyPair.isEncrypted())
                e.setDeterministicKey(keyPair.encrypt(keyCrypterScrypt, key));
        });
        addressEntryList.requestPersistence();
    }

    @Override
    String getWalletAsString(boolean includePrivKeys) {
        StringBuilder sb = new StringBuilder();
        getAddressEntryListAsImmutableList().forEach(e -> sb.append(e.toString()).append(""\n""));
        //boolean reallyIncludePrivKeys = includePrivKeys && !wallet.isEncrypted();
        return ""Address entry list:\n"" +
                sb.toString() +
                ""\n\n"" +
                wallet.toString(true, includePrivKeys, this.aesKey, true, true, walletsSetup.getChain()) + ""\n\n"" +
                ""All pubKeys as hex:\n"" +
                wallet.printAllPubKeysAsHex();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Public Methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Burn BSQ txs (some proposal txs, asset listing fee tx, proof of burn tx)
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction completePreparedBurnBsqTx(Transaction preparedBurnFeeTx, byte[] opReturnData)
            throws WalletException, InsufficientMoneyException, TransactionVerificationException {
        return completePreparedProposalTx(preparedBurnFeeTx, opReturnData, null, null);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Proposal txs
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction completePreparedReimbursementRequestTx(Coin issuanceAmount,
                                                              Address issuanceAddress,
                                                              Transaction feeTx,
                                                              byte[] opReturnData)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {
        return completePreparedProposalTx(feeTx, opReturnData, issuanceAmount, issuanceAddress);
    }

    public Transaction completePreparedCompensationRequestTx(Coin issuanceAmount,
                                                             Address issuanceAddress,
                                                             Transaction feeTx,
                                                             byte[] opReturnData)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {
        return completePreparedProposalTx(feeTx, opReturnData, issuanceAmount, issuanceAddress);
    }

    private Transaction completePreparedProposalTx(Transaction feeTx, byte[] opReturnData,
                                                   @Nullable Coin issuanceAmount, @Nullable Address issuanceAddress)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {

        // (BsqFee)tx has following structure:
        // inputs [1-n] BSQ inputs (fee)
        // outputs [0-1] BSQ request fee change output (>= 546 Satoshi)

        // preparedCompensationRequestTx has following structure:
        // inputs [1-n] BSQ inputs for request fee
        // inputs [1-n] BTC inputs for BSQ issuance and miner fee
        // outputs [1] Mandatory BSQ request fee change output (>= 546 Satoshi)
        // outputs [1] Potentially BSQ issuance output (>= 546 Satoshi) - in case of a issuance tx, otherwise that output does not exist
        // outputs [0-1] BTC change output from issuance and miner fee inputs (>= 546 Satoshi)
        // outputs [1] OP_RETURN with opReturnData and amount 0
        // mining fee: BTC mining fee + burned BSQ fee

        Transaction preparedTx = new Transaction(params);
        // Copy inputs from BSQ fee tx
        feeTx.getInputs().forEach(preparedTx::addInput);
        int indexOfBtcFirstInput = feeTx.getInputs().size();

        // Need to be first because issuance is not guaranteed to be valid and would otherwise burn change output!
        // BSQ change outputs from BSQ fee inputs.
        feeTx.getOutputs().forEach(preparedTx::addOutput);

        // For generic proposals there is no issuance output, for compensation and reimburse requests there is
        if (issuanceAmount != null && issuanceAddress != null) {
            // BSQ issuance output
            preparedTx.addOutput(issuanceAmount, issuanceAddress);
        }

        // safety check counter to avoid endless loops
        int counter = 0;
        // estimated size of input sig
        int sigSizePerInput = 106;
        // typical size for a tx with 3 inputs
        int txVsizeWithUnsignedInputs = 300;
        Coin txFeePerVbyte = feeService.getTxFeePerVbyte();

        Address changeAddress = getFreshAddressEntry().getAddress();
        checkNotNull(changeAddress, ""changeAddress must not be null"");

        BtcCoinSelector coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        List<TransactionInput> preparedBsqTxInputs = preparedTx.getInputs();
        List<TransactionOutput> preparedBsqTxOutputs = preparedTx.getOutputs();
        Tuple2<Integer, Integer> numInputs = getNumInputs(preparedTx);
        int numLegacyInputs = numInputs.first;
        int numSegwitInputs = numInputs.second;
        Transaction resultTx = null;
        boolean isFeeOutsideTolerance;
        do {
            counter++;
            if (counter >= 10) {
                checkNotNull(resultTx, ""resultTx must not be null"");
                log.error(""Could not calculate the fee. Tx="" + resultTx);
                break;
            }

            Transaction tx = new Transaction(params);
            preparedBsqTxInputs.forEach(tx::addInput);
            preparedBsqTxOutputs.forEach(tx::addOutput);

            SendRequest sendRequest = SendRequest.forTx(tx);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            // signInputs needs to be false as it would try to sign all inputs (BSQ inputs are not in this wallet)
            sendRequest.signInputs = false;

            sendRequest.fee = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4);

            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;

            sendRequest.coinSelector = coinSelector;
            sendRequest.changeAddress = changeAddress;
            wallet.completeTx(sendRequest);

            resultTx = sendRequest.tx;

            // add OP_RETURN output
            resultTx.addOutput(new TransactionOutput(params, resultTx, Coin.ZERO, ScriptBuilder.createOpReturnScript(opReturnData).getProgram()));

            numInputs = getNumInputs(resultTx);
            numLegacyInputs = numInputs.first;
            numSegwitInputs = numInputs.second;
            txVsizeWithUnsignedInputs = resultTx.getVsize();
            long estimatedFeeAsLong = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4).value;

            // calculated fee must be inside of a tolerance range with tx fee
            isFeeOutsideTolerance = Math.abs(resultTx.getFee().value - estimatedFeeAsLong) > 1000;
        }
        while (isFeeOutsideTolerance);

        // Sign all BTC inputs
        signAllBtcInputs(indexOfBtcFirstInput, resultTx);

        checkWalletConsistency(wallet);
        verifyTransaction(resultTx);

        // printTx(""BTC wallet: Signed tx"", resultTx);
        return resultTx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Blind vote tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    // We add BTC inputs to pay miner fees and sign the BTC tx inputs

    // (BsqFee)tx has following structure:
    // inputs [1-n] BSQ inputs (fee + stake)
    // outputs [1] BSQ stake
    // outputs [0-1] BSQ change output (>= 546 Satoshi)

    // preparedVoteTx has following structure:
    // inputs [1-n] BSQ inputs (fee + stake)
    // inputs [1-n] BTC inputs for miner fee
    // outputs [1] BSQ stake
    // outputs [0-1] BSQ change output (>= 546 Satoshi)
    // outputs [0-1] BTC change output from miner fee inputs (>= 546 Satoshi)
    // outputs [1] OP_RETURN with opReturnData and amount 0
    // mining fee: BTC mining fee + burned BSQ fee
    public Transaction completePreparedBlindVoteTx(Transaction preparedTx, byte[] opReturnData)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {
        // First input index for btc inputs (they get added after bsq inputs)
        return completePreparedBsqTxWithBtcFee(preparedTx, opReturnData);
    }

    private Transaction completePreparedBsqTxWithBtcFee(Transaction preparedTx,
                                                        byte[] opReturnData) throws InsufficientMoneyException, TransactionVerificationException, WalletException {
        // Remember index for first BTC input
        int indexOfBtcFirstInput = preparedTx.getInputs().size();

        Transaction tx = addInputsForMinerFee(preparedTx, opReturnData);
        signAllBtcInputs(indexOfBtcFirstInput, tx);

        checkWalletConsistency(wallet);
        verifyTransaction(tx);

        // printTx(""BTC wallet: Signed tx"", tx);
        return tx;
    }

    private Transaction addInputsForMinerFee(Transaction preparedTx,
                                             byte[] opReturnData) throws InsufficientMoneyException {
        // safety check counter to avoid endless loops
        int counter = 0;
        // estimated size of input sig
        int sigSizePerInput = 106;
        // typical size for a tx with 3 inputs
        int txVsizeWithUnsignedInputs = 300;
        Coin txFeePerVbyte = feeService.getTxFeePerVbyte();

        Address changeAddress = getFreshAddressEntry().getAddress();
        checkNotNull(changeAddress, ""changeAddress must not be null"");

        BtcCoinSelector coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        List<TransactionInput> preparedBsqTxInputs = preparedTx.getInputs();
        List<TransactionOutput> preparedBsqTxOutputs = preparedTx.getOutputs();
        Tuple2<Integer, Integer> numInputs = getNumInputs(preparedTx);
        int numLegacyInputs = numInputs.first;
        int numSegwitInputs = numInputs.second;
        Transaction resultTx = null;
        boolean isFeeOutsideTolerance;
        do {
            counter++;
            if (counter >= 10) {
                checkNotNull(resultTx, ""resultTx must not be null"");
                log.error(""Could not calculate the fee. Tx="" + resultTx);
                break;
            }

            Transaction tx = new Transaction(params);
            preparedBsqTxInputs.forEach(tx::addInput);
            preparedBsqTxOutputs.forEach(tx::addOutput);

            SendRequest sendRequest = SendRequest.forTx(tx);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            // signInputs needs to be false as it would try to sign all inputs (BSQ inputs are not in this wallet)
            sendRequest.signInputs = false;

            sendRequest.fee = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4);
            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;

            sendRequest.coinSelector = coinSelector;
            sendRequest.changeAddress = changeAddress;
            wallet.completeTx(sendRequest);

            resultTx = sendRequest.tx;

            // add OP_RETURN output
            resultTx.addOutput(new TransactionOutput(params, resultTx, Coin.ZERO, ScriptBuilder.createOpReturnScript(opReturnData).getProgram()));

            numInputs = getNumInputs(resultTx);
            numLegacyInputs = numInputs.first;
            numSegwitInputs = numInputs.second;
            txVsizeWithUnsignedInputs = resultTx.getVsize();
            final long estimatedFeeAsLong = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4).value;
            // calculated fee must be inside of a tolerance range with tx fee
            isFeeOutsideTolerance = Math.abs(resultTx.getFee().value - estimatedFeeAsLong) > 1000;
        }
        while (isFeeOutsideTolerance);
        return resultTx;
    }

    private void signAllBtcInputs(int indexOfBtcFirstInput, Transaction tx) throws TransactionVerificationException {
        for (int i = indexOfBtcFirstInput; i < tx.getInputs().size(); i++) {
            TransactionInput input = tx.getInputs().get(i);
            checkArgument(input.getConnectedOutput() != null && input.getConnectedOutput().isMine(wallet),
                    ""input.getConnectedOutput() is not in our wallet. That must not happen."");
            signTransactionInput(wallet, aesKey, tx, input, i);
            checkScriptSig(tx, input, i);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Vote reveal tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    // We add BTC fees to the prepared reveal tx
    // (BsqFee)tx has following structure:
    // inputs [1] BSQ input (stake)
    // output [1] BSQ unlocked stake

    // preparedVoteTx has following structure:
    // inputs [1] BSQ inputs (stake)
    // inputs [1-n] BTC inputs for miner fee
    // outputs [1] BSQ unlocked stake
    // outputs [0-1] BTC change output from miner fee inputs (>= 546 Satoshi)
    // outputs [1] OP_RETURN with opReturnData and amount 0
    // mining fee: BTC mining fee + burned BSQ fee
    public Transaction completePreparedVoteRevealTx(Transaction preparedTx, byte[] opReturnData)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {
        return completePreparedBsqTxWithBtcFee(preparedTx, opReturnData);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Add fee input to prepared BSQ send tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction completePreparedSendBsqTx(Transaction preparedBsqTx) throws
            TransactionVerificationException, WalletException, InsufficientMoneyException {
        // preparedBsqTx has following structure:
        // inputs [1-n] BSQ inputs
        // outputs [1] BSQ receiver's output
        // outputs [0-1] BSQ change output

        // We add BTC mining fee. Result tx looks like:
        // inputs [1-n] BSQ inputs
        // inputs [1-n] BTC inputs
        // outputs [1] BSQ receiver's output
        // outputs [0-1] BSQ change output
        // outputs [0-1] BTC change output
        // mining fee: BTC mining fee
        Coin txFeePerVbyte = getTxFeeForWithdrawalPerVbyte();
        return completePreparedBsqTx(preparedBsqTx, null, txFeePerVbyte);
    }

    public Transaction completePreparedSendBsqTx(Transaction preparedBsqTx, Coin txFeePerVbyte) throws
            TransactionVerificationException, WalletException, InsufficientMoneyException {
        return completePreparedBsqTx(preparedBsqTx, null, txFeePerVbyte);
    }

    public Transaction completePreparedBsqTx(Transaction preparedBsqTx,
                                             @Nullable byte[] opReturnData) throws
            TransactionVerificationException, WalletException, InsufficientMoneyException {
        Coin txFeePerVbyte = getTxFeeForWithdrawalPerVbyte();
        return completePreparedBsqTx(preparedBsqTx, opReturnData, txFeePerVbyte);
    }

    public Transaction completePreparedBsqTx(Transaction preparedBsqTx,
                                             @Nullable byte[] opReturnData,
                                             Coin txFeePerVbyte) throws
            TransactionVerificationException, WalletException, InsufficientMoneyException {

        // preparedBsqTx has following structure:
        // inputs [1-n] BSQ inputs
        // outputs [1] BSQ receiver's output
        // outputs [0-1] BSQ change output
        // mining fee: optional burned BSQ fee (only if opReturnData != null)

        // We add BTC mining fee. Result tx looks like:
        // inputs [1-n] BSQ inputs
        // inputs [1-n] BTC inputs
        // outputs [0-1] BSQ receiver's output
        // outputs [0-1] BSQ change output
        // outputs [0-1] BTC change output
        // outputs [0-1] OP_RETURN with opReturnData (only if opReturnData != null)
        // mining fee: BTC mining fee + optional burned BSQ fee (only if opReturnData != null)

        // In case of txs for burned BSQ fees we have no receiver output and it might be that there is no change outputs
        // We need to guarantee that min. 1 valid output is added (OP_RETURN does not count). So we use a higher input
        // for BTC to force an additional change output.

        // safety check counter to avoid endless loops
        int counter = 0;
        // estimated size of input sig
        int sigSizePerInput = 106;
        // typical size for a tx with 2 inputs
        int txVsizeWithUnsignedInputs = 203;
        // In case there are no change outputs we force a change by adding min dust to the BTC input
        Coin forcedChangeValue = Coin.ZERO;

        Address changeAddress = getFreshAddressEntry().getAddress();
        checkNotNull(changeAddress, ""changeAddress must not be null"");

        BtcCoinSelector coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        List<TransactionInput> preparedBsqTxInputs = preparedBsqTx.getInputs();
        List<TransactionOutput> preparedBsqTxOutputs = preparedBsqTx.getOutputs();
        // We don't know at this point what type the btc input would be (segwit/legacy).
        // We use legacy to be on the safe side.
        int numLegacyInputs = preparedBsqTxInputs.size() + 1; // We add 1 for the BTC fee input
        int numSegwitInputs = 0;
        Transaction resultTx = null;
        boolean isFeeOutsideTolerance;
        boolean opReturnIsOnlyOutput;
        do {
            counter++;
            if (counter >= 10) {
                checkNotNull(resultTx, ""resultTx must not be null"");
                log.error(""Could not calculate the fee. Tx="" + resultTx);
                break;
            }

            Transaction tx = new Transaction(params);
            preparedBsqTxInputs.forEach(tx::addInput);

            if (forcedChangeValue.isZero()) {
                preparedBsqTxOutputs.forEach(tx::addOutput);
            } else {
                //TODO test that case
                checkArgument(preparedBsqTxOutputs.size() == 0, ""preparedBsqTxOutputs.size must be null in that code branch"");
                tx.addOutput(forcedChangeValue, changeAddress);
            }

            SendRequest sendRequest = SendRequest.forTx(tx);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            // signInputs needs to be false as it would try to sign all inputs (BSQ inputs are not in this wallet)
            sendRequest.signInputs = false;

            sendRequest.fee = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4);
            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;

            sendRequest.coinSelector = coinSelector;
            sendRequest.changeAddress = changeAddress;
            wallet.completeTx(sendRequest);

            resultTx = sendRequest.tx;

            // We might have the rare case that both inputs matched the required fees, so both did not require
            // a change output.
            // In such cases we need to add artificially a change output (OP_RETURN is not allowed as only output)
            opReturnIsOnlyOutput = resultTx.getOutputs().size() == 0;
            forcedChangeValue = opReturnIsOnlyOutput ? Restrictions.getMinNonDustOutput() : Coin.ZERO;

            // add OP_RETURN output
            if (opReturnData != null)
                resultTx.addOutput(new TransactionOutput(params, resultTx, Coin.ZERO, ScriptBuilder.createOpReturnScript(opReturnData).getProgram()));

            Tuple2<Integer, Integer> numInputs = getNumInputs(resultTx);
            numLegacyInputs = numInputs.first;
            numSegwitInputs = numInputs.second;
            txVsizeWithUnsignedInputs = resultTx.getVsize();
            final long estimatedFeeAsLong = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4).value;
            // calculated fee must be inside of a tolerance range with tx fee
            isFeeOutsideTolerance = Math.abs(resultTx.getFee().value - estimatedFeeAsLong) > 1000;
        }
        while (opReturnIsOnlyOutput ||
                isFeeOutsideTolerance ||
                resultTx.getFee().value < txFeePerVbyte.multiply(resultTx.getVsize()).value);

        // Sign all BTC inputs
        signAllBtcInputs(preparedBsqTxInputs.size(), resultTx);

        checkWalletConsistency(wallet);
        verifyTransaction(resultTx);

        printTx(""BTC wallet: Signed tx"", resultTx);
        return resultTx;
    }

    private Tuple2<Integer, Integer> getNumInputs(Transaction tx) {
        int numLegacyInputs = 0;
        int numSegwitInputs = 0;
        for (TransactionInput input : tx.getInputs()) {
            TransactionOutput connectedOutput = input.getConnectedOutput();
            if (connectedOutput == null || ScriptPattern.isP2PKH(connectedOutput.getScriptPubKey()) ||
                    ScriptPattern.isP2PK(connectedOutput.getScriptPubKey())) {
                // If connectedOutput is null, we don't know here the input type. To avoid underpaying fees,
                // we treat it as a legacy input which will result in a higher fee estimation.
                numLegacyInputs++;
            } else if (ScriptPattern.isP2WPKH(connectedOutput.getScriptPubKey())) {
                numSegwitInputs++;
            } else {
                throw new IllegalArgumentException(""Inputs should spend a P2PKH, P2PK or P2WPKH output"");
            }
        }
        return new Tuple2<>(numLegacyInputs, numSegwitInputs);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Commit tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void commitTx(Transaction tx) {
        wallet.commitTx(tx);
        // printTx(""BTC commit Tx"", tx);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // AddressEntry
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Optional<AddressEntry> getAddressEntry(String offerId,
                                                  @SuppressWarnings(""SameParameterValue"") AddressEntry.Context context) {
        return getAddressEntryListAsImmutableList().stream()
                .filter(e -> offerId.equals(e.getOfferId()))
                .filter(e -> context == e.getContext())
                .findAny();
    }

    public AddressEntry getOrCreateAddressEntry(String offerId, AddressEntry.Context context) {
        Optional<AddressEntry> addressEntry = getAddressEntryListAsImmutableList().stream()
                .filter(e -> offerId.equals(e.getOfferId()))
                .filter(e -> context == e.getContext())
                .findAny();
        if (addressEntry.isPresent()) {
            return addressEntry.get();
        } else {
            // We try to use available and not yet used entries
            Optional<AddressEntry> emptyAvailableAddressEntry = getAddressEntryListAsImmutableList().stream()
                    .filter(e -> AddressEntry.Context.AVAILABLE == e.getContext())
                    .filter(e -> isAddressUnused(e.getAddress()))
                    .filter(e -> Script.ScriptType.P2WPKH.equals(e.getAddress().getOutputScriptType()))
                    .findAny();
            if (emptyAvailableAddressEntry.isPresent() &&
                    context != AddressEntry.Context.MULTI_SIG) {    // always use fresh address for MULTI_SIG GH#5880
                return addressEntryList.swapAvailableToAddressEntryWithOfferId(emptyAvailableAddressEntry.get(), context, offerId);
            } else {
                DeterministicKey key = (DeterministicKey) wallet.findKeyFromAddress(wallet.freshReceiveAddress(Script.ScriptType.P2WPKH));
                AddressEntry entry = new AddressEntry(key, context, offerId, true);
                log.info(""getOrCreateAddressEntry: new AddressEntry={}"", entry);
                addressEntryList.addAddressEntry(entry);
                return entry;
            }
        }
    }

    public AddressEntry getArbitratorAddressEntry() {
        AddressEntry.Context context = AddressEntry.Context.ARBITRATOR;
        Optional<AddressEntry> addressEntry = getAddressEntryListAsImmutableList().stream()
                .filter(e -> context == e.getContext())
                .findAny();
        return getOrCreateAddressEntry(context, addressEntry, false);
    }

    public AddressEntry getFreshAddressEntry() {
        return getFreshAddressEntry(true);
    }

    public AddressEntry getFreshAddressEntry(boolean segwit) {
        AddressEntry.Context context = AddressEntry.Context.AVAILABLE;
        Optional<AddressEntry> addressEntry = getAddressEntryListAsImmutableList().stream()
                .filter(e -> context == e.getContext())
                .filter(e -> isAddressUnused(e.getAddress()))
                .filter(e -> {
                    boolean isSegwitOutputScriptType = Script.ScriptType.P2WPKH.equals(e.getAddress().getOutputScriptType());
                    // We need to ensure that we take only addressEntries which matches our segWit flag
                    return isSegwitOutputScriptType == segwit;
                })
                .findAny();
        return getOrCreateAddressEntry(context, addressEntry, segwit);
    }

    public void recoverAddressEntry(String offerId, String address, AddressEntry.Context context) {
        findAddressEntry(address, AddressEntry.Context.AVAILABLE).ifPresent(addressEntry ->
                addressEntryList.swapAvailableToAddressEntryWithOfferId(addressEntry, context, offerId));
    }

    private AddressEntry getOrCreateAddressEntry(AddressEntry.Context context,
                                                 Optional<AddressEntry> addressEntry,
                                                 boolean segwit) {
        if (addressEntry.isPresent()) {
            return addressEntry.get();
        } else {
            DeterministicKey key;
            if (segwit) {
                key = (DeterministicKey) wallet.findKeyFromAddress(wallet.freshReceiveAddress(Script.ScriptType.P2WPKH));
            } else {
                key = (DeterministicKey) wallet.findKeyFromAddress(wallet.freshReceiveAddress(Script.ScriptType.P2PKH));
            }
            AddressEntry entry = new AddressEntry(key, context, segwit);
            log.info(""getOrCreateAddressEntry: add new AddressEntry {}"", entry);
            addressEntryList.addAddressEntry(entry);
            return entry;
        }
    }

    private Optional<AddressEntry> findAddressEntry(String address, AddressEntry.Context context) {
        return getAddressEntryListAsImmutableList().stream()
                .filter(e -> address.equals(e.getAddressString()))
                .filter(e -> context == e.getContext())
                .findAny();
    }

    public List<AddressEntry> getAvailableAddressEntries() {
        return getAddressEntryListAsImmutableList().stream()
                .filter(addressEntry -> AddressEntry.Context.AVAILABLE == addressEntry.getContext())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getAddressEntriesForOpenOffer() {
        return getAddressEntryListAsImmutableList().stream()
                .filter(addressEntry -> AddressEntry.Context.OFFER_FUNDING == addressEntry.getContext() ||
                        AddressEntry.Context.RESERVED_FOR_TRADE == addressEntry.getContext())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getAddressEntriesForTrade() {
        return getAddressEntryListAsImmutableList().stream()
                .filter(addressEntry -> AddressEntry.Context.MULTI_SIG == addressEntry.getContext() ||
                        AddressEntry.Context.TRADE_PAYOUT == addressEntry.getContext())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getAddressEntries(AddressEntry.Context context) {
        return getAddressEntryListAsImmutableList().stream()
                .filter(addressEntry -> context == addressEntry.getContext())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getFundedAvailableAddressEntries() {
        return getAvailableAddressEntries().stream()
                .filter(addressEntry -> getBalanceForAddress(addressEntry.getAddress()).isPositive())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getAddressEntryListAsImmutableList() {
        return addressEntryList.getAddressEntriesAsListImmutable();
    }

    public void swapTradeEntryToAvailableEntry(String offerId, AddressEntry.Context context) {
        if (context == AddressEntry.Context.MULTI_SIG) {
            log.error(""swapTradeEntryToAvailableEntry called with MULTI_SIG context. "" +
                    ""This in not permitted as we must not reuse those address entries and there "" +
                    ""are no redeemable funds on that addresses. Only the keys are used for creating "" +
                    ""the Multisig address. offerId={}, context={}"", offerId, context);
            return;
        }

        getAddressEntryListAsImmutableList().stream()
                .filter(e -> offerId.equals(e.getOfferId()))
                .filter(e -> context == e.getContext())
                .forEach(e -> {
                    log.info(""swap addressEntry with address {} and offerId {} from context {} to available"",
                            e.getAddressString(), e.getOfferId(), context);
                    addressEntryList.swapToAvailable(e);
                });
    }

    // When funds from MultiSig address is spent we reset the coinLockedInMultiSig value to 0.
    public void resetCoinLockedInMultiSigAddressEntry(String offerId) {
        setCoinLockedInMultiSigAddressEntry(offerId, 0);
    }

    public void setCoinLockedInMultiSigAddressEntry(String offerId, long value) {
        getAddressEntryListAsImmutableList().stream()
                .filter(e -> AddressEntry.Context.MULTI_SIG == e.getContext())
                .filter(e -> offerId.equals(e.getOfferId()))
                .forEach(addressEntry -> setCoinLockedInMultiSigAddressEntry(addressEntry, value));
    }

    public void setCoinLockedInMultiSigAddressEntry(AddressEntry addressEntry, long value) {
        log.info(""Set coinLockedInMultiSig for addressEntry {} to value {}"", addressEntry, value);
        addressEntryList.setCoinLockedInMultiSigAddressEntry(addressEntry, value);
    }

    public void resetAddressEntriesForOpenOffer(String offerId) {
        log.info(""resetAddressEntriesForOpenOffer offerId={}"", offerId);
        swapTradeEntryToAvailableEntry(offerId, AddressEntry.Context.OFFER_FUNDING);
        swapTradeEntryToAvailableEntry(offerId, AddressEntry.Context.RESERVED_FOR_TRADE);
    }

    public void resetAddressEntriesForPendingTrade(String offerId) {
        // We must not swap MULTI_SIG entries as those addresses are not detected in the isAddressUnused
        // check at getOrCreateAddressEntry and could lead to a reuse of those keys and result in the same 2of2 MS
        // address if same peers trade again.

        // We swap TRADE_PAYOUT to be sure all is cleaned up. There might be cases where a user cannot send the funds
        // to an external wallet directly in the last step of the trade, but the funds are in the Bisq wallet anyway and
        // the dealing with the external wallet is pure UI thing. The user can move the funds to the wallet and then
        // send out the funds to the external wallet. As this cleanup is a rare situation and most users do not use
        // the feature to send out the funds we prefer that strategy (if we keep the address entry it might cause
        // complications in some edge cases after a SPV resync).
        swapTradeEntryToAvailableEntry(offerId, AddressEntry.Context.TRADE_PAYOUT);
    }

    public void swapAnyTradeEntryContextToAvailableEntry(String offerId) {
        resetAddressEntriesForOpenOffer(offerId);
        resetAddressEntriesForPendingTrade(offerId);
    }

    public void saveAddressEntryList() {
        addressEntryList.requestPersistence();
    }

    public DeterministicKey getMultiSigKeyPair(String tradeId, byte[] pubKey) {
        Optional<AddressEntry> multiSigAddressEntryOptional = getAddressEntry(tradeId, AddressEntry.Context.MULTI_SIG);
        DeterministicKey multiSigKeyPair;
        if (multiSigAddressEntryOptional.isPresent()) {
            AddressEntry multiSigAddressEntry = multiSigAddressEntryOptional.get();
            multiSigKeyPair = multiSigAddressEntry.getKeyPair();
            if (!Arrays.equals(pubKey, multiSigAddressEntry.getPubKey())) {
                log.error(""Pub Key from AddressEntry does not match key pair from trade data. Trade ID={}\n"" +
                        ""We try to find the keypair in the wallet with the pubKey we found in the trade data."", tradeId);
                multiSigKeyPair = findKeyFromPubKey(pubKey);
            }
        } else {
            log.error(""multiSigAddressEntry not found for trade ID={}.\n"" +
                    ""We try to find the keypair in the wallet with the pubKey we found in the trade data."", tradeId);
            multiSigKeyPair = findKeyFromPubKey(pubKey);
        }

        return multiSigKeyPair;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Balance
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Coin getSavingWalletBalance() {
        return Coin.valueOf(getFundedAvailableAddressEntries().stream()
                .mapToLong(addressEntry -> getBalanceForAddress(addressEntry.getAddress()).value)
                .sum());
    }

    public Stream<AddressEntry> getAddressEntriesForAvailableBalanceStream() {
        Stream<AddressEntry> availableAndPayout = Stream.concat(getAddressEntries(AddressEntry.Context.TRADE_PAYOUT)
                .stream(), getFundedAvailableAddressEntries().stream());
        Stream<AddressEntry> available = Stream.concat(availableAndPayout,
                getAddressEntries(AddressEntry.Context.ARBITRATOR).stream());
        available = Stream.concat(available, getAddressEntries(AddressEntry.Context.OFFER_FUNDING).stream());
        return available.filter(addressEntry -> getBalanceForAddress(addressEntry.getAddress()).isPositive());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Double spend unconfirmed transaction (unlock in case we got into a tx with a too low mining fee)
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void doubleSpendTransaction(String txId, Runnable resultHandler, ErrorMessageHandler errorMessageHandler)
            throws InsufficientFundsException {
        AddressEntry addressEntry = getFreshAddressEntry();
        checkNotNull(addressEntry.getAddress(), ""addressEntry.getAddress() must not be null"");
        Optional<Transaction> transactionOptional = wallet.getTransactions(true).stream()
                .filter(t -> t.getTxId().toString().equals(txId))
                .findAny();
        if (transactionOptional.isPresent()) {
            Transaction txToDoubleSpend = transactionOptional.get();
            Address toAddress = addressEntry.getAddress();
            final TransactionConfidence.ConfidenceType confidenceType = txToDoubleSpend.getConfidence().getConfidenceType();
            if (confidenceType == TransactionConfidence.ConfidenceType.PENDING) {
                log.debug(""txToDoubleSpend no. of inputs "" + txToDoubleSpend.getInputs().size());

                Transaction newTransaction = new Transaction(params);
                txToDoubleSpend.getInputs().forEach(input -> {
                            final TransactionOutput connectedOutput = input.getConnectedOutput();
                            if (connectedOutput != null &&
                                    connectedOutput.isMine(wallet) &&
                                    connectedOutput.getParentTransaction() != null &&
                                    connectedOutput.getParentTransaction().getConfidence() != null &&
                                    input.getValue() != null) {
                                //if (connectedOutput.getParentTransaction().getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING) {
                                newTransaction.addInput(new TransactionInput(params,
                                        newTransaction,
                                        new byte[]{},
                                        new TransactionOutPoint(params, input.getOutpoint().getIndex(),
                                                new Transaction(params, connectedOutput.getParentTransaction().bitcoinSerialize())),
                                        Coin.valueOf(input.getValue().value)));
                               /* } else {
                                    log.warn(""Confidence of parent tx is not of type BUILDING: ConfidenceType="" +
                                            connectedOutput.getParentTransaction().getConfidence().getConfidenceType());
                                }*/
                            }
                        }
                );

                log.info(""newTransaction no. of inputs "" + newTransaction.getInputs().size());
                log.info(""newTransaction vsize in vkB "" + newTransaction.getVsize() / 1024);

                if (!newTransaction.getInputs().isEmpty()) {
                    Coin amount = Coin.valueOf(newTransaction.getInputs().stream()
                            .mapToLong(input -> input.getValue() != null ? input.getValue().value : 0)
                            .sum());
                    newTransaction.addOutput(amount, toAddress);

                    try {
                        Coin fee;
                        int counter = 0;
                        int txVsize = 0;
                        Transaction tx;
                        SendRequest sendRequest;
                        Coin txFeeForWithdrawalPerVbyte = getTxFeeForWithdrawalPerVbyte();
                        do {
                            counter++;
                            fee = txFeeForWithdrawalPerVbyte.multiply(txVsize);
                            newTransaction.clearOutputs();
                            newTransaction.addOutput(amount.subtract(fee), toAddress);

                            sendRequest = SendRequest.forTx(newTransaction);
                            sendRequest.fee = fee;
                            sendRequest.feePerKb = Coin.ZERO;
                            sendRequest.ensureMinRequiredFee = false;
                            sendRequest.aesKey = aesKey;
                            sendRequest.coinSelector = new BtcCoinSelector(toAddress, preferences.getIgnoreDustThreshold());
                            sendRequest.changeAddress = toAddress;
                            wallet.completeTx(sendRequest);
                            tx = sendRequest.tx;
                            txVsize = tx.getVsize();
                            printTx(""FeeEstimationTransaction"", tx);
                            sendRequest.tx.getOutputs().forEach(o -> log.debug(""Output value "" + o.getValue().toFriendlyString()));
                        }
                        while (feeEstimationNotSatisfied(counter, tx));

                        if (counter == 10)
                            log.error(""Could not calculate the fee. Tx="" + tx);


                        Wallet.SendResult sendResult = null;
                        try {
                            sendRequest = SendRequest.forTx(newTransaction);
                            sendRequest.fee = fee;
                            sendRequest.feePerKb = Coin.ZERO;
                            sendRequest.ensureMinRequiredFee = false;
                            sendRequest.aesKey = aesKey;
                            sendRequest.coinSelector = new BtcCoinSelector(toAddress, preferences.getIgnoreDustThreshold());
                            sendRequest.changeAddress = toAddress;
                            sendResult = wallet.sendCoins(sendRequest);
                        } catch (InsufficientMoneyException e) {
                            // in some cases getFee did not calculate correctly and we still get an InsufficientMoneyException
                            log.warn(""We still have a missing fee "" + (e.missing != null ? e.missing.toFriendlyString() : """"));

                            amount = amount.subtract(e.missing);
                            newTransaction.clearOutputs();
                            newTransaction.addOutput(amount, toAddress);

                            sendRequest = SendRequest.forTx(newTransaction);
                            sendRequest.fee = fee;
                            sendRequest.feePerKb = Coin.ZERO;
                            sendRequest.ensureMinRequiredFee = false;
                            sendRequest.aesKey = aesKey;
                            sendRequest.coinSelector = new BtcCoinSelector(toAddress,
                                    preferences.getIgnoreDustThreshold(), false);
                            sendRequest.changeAddress = toAddress;

                            try {
                                sendResult = wallet.sendCoins(sendRequest);
                                printTx(""FeeEstimationTransaction"", newTransaction);

                                // For better redundancy in case the broadcast via BitcoinJ fails we also
                                // publish the tx via mempool nodes.
                                MemPoolSpaceTxBroadcaster.broadcastTx(sendResult.tx);
                            } catch (InsufficientMoneyException e2) {
                                errorMessageHandler.handleErrorMessage(""We did not get the correct fee calculated. "" + (e2.missing != null ? e2.missing.toFriendlyString() : """"));
                            }
                        }
                        if (sendResult != null) {
                            log.info(""Broadcasting double spending transaction. "" + sendResult.tx);
                            Futures.addCallback(sendResult.broadcastComplete, new FutureCallback<>() {
                                @Override
                                public void onSuccess(Transaction result) {
                                    log.info(""Double spending transaction published. "" + result);
                                    resultHandler.run();
                                }

                                @Override
                                public void onFailure(@NotNull Throwable t) {
                                    log.error(""Broadcasting double spending transaction failed. "" + t.getMessage());
                                    errorMessageHandler.handleErrorMessage(t.getMessage());
                                }
                            }, MoreExecutors.directExecutor());
                        }

                    } catch (InsufficientMoneyException e) {
                        throw new InsufficientFundsException(""The fees for that transaction exceed the available funds "" +
                                ""or the resulting output value is below the min. dust value:\n"" +
                                ""Missing "" + (e.missing != null ? e.missing.toFriendlyString() : ""null""));
                    }
                } else {
                    String errorMessage = ""We could not find inputs we control in the transaction we want to double spend."";
                    log.warn(errorMessage);
                    errorMessageHandler.handleErrorMessage(errorMessage);
                }
            } else if (confidenceType == TransactionConfidence.ConfidenceType.BUILDING) {
                errorMessageHandler.handleErrorMessage(""That transaction is already in the blockchain so we cannot double spend it."");
            } else if (confidenceType == TransactionConfidence.ConfidenceType.DEAD) {
                errorMessageHandler.handleErrorMessage(""One of the inputs of that transaction has been already double spent."");
            }
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Withdrawal Fee calculation
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction getFeeEstimationTransaction(String fromAddress,
                                                   String toAddress,
                                                   Coin amount,
                                                   AddressEntry.Context context)
            throws AddressFormatException, AddressEntryException, InsufficientFundsException {

        Optional<AddressEntry> addressEntry = findAddressEntry(fromAddress, context);
        if (!addressEntry.isPresent())
            throw new AddressEntryException(""WithdrawFromAddress is not found in our wallet."");

        checkNotNull(addressEntry.get().getAddress(), ""addressEntry.get().getAddress() must nto be null"");

        try {
            Coin fee;
            int counter = 0;
            int txVsize = 0;
            Transaction tx;
            Coin txFeeForWithdrawalPerVbyte = getTxFeeForWithdrawalPerVbyte();
            do {
                counter++;
                fee = txFeeForWithdrawalPerVbyte.multiply(txVsize);
                SendRequest sendRequest = getSendRequest(fromAddress, toAddress, amount, fee, aesKey, context);
                wallet.completeTx(sendRequest);
                tx = sendRequest.tx;
                txVsize = tx.getVsize();
                printTx(""FeeEstimationTransaction"", tx);
            }
            while (feeEstimationNotSatisfied(counter, tx));
            if (counter == 10)
                log.error(""Could not calculate the fee. Tx="" + tx);

            return tx;
        } catch (InsufficientMoneyException e) {
            throw new InsufficientFundsException(""The fees for that transaction exceed the available funds "" +
                    ""or the resulting output value is below the min. dust value:\n"" +
                    ""Missing "" + (e.missing != null ? e.missing.toFriendlyString() : ""null""));
        }
    }

    public Transaction getFeeEstimationTransactionForMultipleAddresses(Set<String> fromAddresses,
                                                                       Coin amount)
            throws AddressFormatException, AddressEntryException, InsufficientFundsException {
        Coin txFeeForWithdrawalPerVbyte = getTxFeeForWithdrawalPerVbyte();
        return getFeeEstimationTransactionForMultipleAddresses(fromAddresses, amount, txFeeForWithdrawalPerVbyte);
    }

    public Transaction getFeeEstimationTransactionForMultipleAddresses(Set<String> fromAddresses,
                                                                       Coin amount,
                                                                       Coin txFeeForWithdrawalPerVbyte)
            throws AddressFormatException, AddressEntryException, InsufficientFundsException {
        Set<AddressEntry> addressEntries = fromAddresses.stream()
                .map(address -> {
                    Optional<AddressEntry> addressEntryOptional = findAddressEntry(address, AddressEntry.Context.AVAILABLE);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.OFFER_FUNDING);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.TRADE_PAYOUT);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.ARBITRATOR);
                    return addressEntryOptional;
                })
                .flatMap(Optional::stream)
                .collect(Collectors.toSet());
        if (addressEntries.isEmpty())
            throw new AddressEntryException(""No Addresses for withdraw  found in our wallet"");

        try {
            Coin fee;
            int counter = 0;
            int txVsize = 0;
            Transaction tx;
            do {
                counter++;
                fee = txFeeForWithdrawalPerVbyte.multiply(txVsize);
                // We use a dummy address for the output
                // We don't know here whether the output is segwit or not but we don't care too much because the size of
                // a segwit ouput is just 3 byte smaller than the size of a legacy ouput.
                final String dummyReceiver = SegwitAddress.fromKey(params, new ECKey()).toString();
                SendRequest sendRequest = getSendRequestForMultipleAddresses(fromAddresses, dummyReceiver, amount, fee, null, aesKey);
                wallet.completeTx(sendRequest);
                tx = sendRequest.tx;
                txVsize = tx.getVsize();
                printTx(""FeeEstimationTransactionForMultipleAddresses"", tx);
            }
            while (feeEstimationNotSatisfied(counter, tx));
            if (counter == 10)
                log.error(""Could not calculate the fee. Tx="" + tx);

            return tx;
        } catch (InsufficientMoneyException e) {
            throw new InsufficientFundsException(""The fees for that transaction exceed the available funds "" +
                    ""or the resulting output value is below the min. dust value:\n"" +
                    ""Missing "" + (e.missing != null ? e.missing.toFriendlyString() : ""null""));
        }
    }

    private boolean feeEstimationNotSatisfied(int counter, Transaction tx) {
        return feeEstimationNotSatisfied(counter, tx, getTxFeeForWithdrawalPerVbyte());
    }

    private boolean feeEstimationNotSatisfied(int counter, Transaction tx, Coin txFeeForWithdrawalPerVbyte) {
        long targetFee = txFeeForWithdrawalPerVbyte.multiply(tx.getVsize()).value;
        return counter < 10 &&
                (tx.getFee().value < targetFee ||
                        tx.getFee().value - targetFee > 1000);
    }

    public int getEstimatedFeeTxVsize(List<Coin> outputValues, Coin txFee)
            throws InsufficientMoneyException, AddressFormatException {
        Transaction transaction = new Transaction(params);
        // In reality txs have a mix of segwit/legacy ouputs, but we don't care too much because the size of
        // a segwit ouput is just 3 byte smaller than the size of a legacy ouput.
        Address dummyAddress = SegwitAddress.fromKey(params, new ECKey());
        outputValues.forEach(outputValue -> transaction.addOutput(outputValue, dummyAddress));

        SendRequest sendRequest = SendRequest.forTx(transaction);
        sendRequest.shuffleOutputs = false;
        sendRequest.aesKey = aesKey;
        sendRequest.coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        sendRequest.fee = txFee;
        sendRequest.feePerKb = Coin.ZERO;
        sendRequest.ensureMinRequiredFee = false;
        sendRequest.changeAddress = dummyAddress;
        wallet.completeTx(sendRequest);
        return transaction.getVsize();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Withdrawal Send
    ///////////////////////////////////////////////////////////////////////////////////////////

    public String sendFunds(String fromAddress,
                            String toAddress,
                            Coin receiverAmount,
                            Coin fee,
                            @Nullable KeyParameter aesKey,
                            @SuppressWarnings(""SameParameterValue"") AddressEntry.Context context,
                            @Nullable String memo,
                            FutureCallback<Transaction> callback) throws AddressFormatException,
            AddressEntryException, InsufficientMoneyException {
        SendRequest sendRequest = getSendRequest(fromAddress, toAddress, receiverAmount, fee, aesKey, context);
        Wallet.SendResult sendResult = wallet.sendCoins(sendRequest);
        Futures.addCallback(sendResult.broadcastComplete, callback, MoreExecutors.directExecutor());
        if (memo != null) {
            sendResult.tx.setMemo(memo);
        }

        // For better redundancy in case the broadcast via BitcoinJ fails we also
        // publish the tx via mempool nodes.
        MemPoolSpaceTxBroadcaster.broadcastTx(sendResult.tx);

        return sendResult.tx.getTxId().toString();
    }

    public Transaction sendFundsForMultipleAddresses(Set<String> fromAddresses,
                                                     String toAddress,
                                                     Coin receiverAmount,
                                                     Coin fee,
                                                     @Nullable String changeAddress,
                                                     @Nullable KeyParameter aesKey,
                                                     @Nullable String memo,
                                                     FutureCallback<Transaction> callback) throws AddressFormatException,
            AddressEntryException, InsufficientMoneyException {

        SendRequest request = getSendRequestForMultipleAddresses(fromAddresses, toAddress, receiverAmount, fee, changeAddress, aesKey);
        Wallet.SendResult sendResult = wallet.sendCoins(request);
        Futures.addCallback(sendResult.broadcastComplete, callback, MoreExecutors.directExecutor());
        if (memo != null) {
            sendResult.tx.setMemo(memo);
        }
        printTx(""sendFunds"", sendResult.tx);

        // For better redundancy in case the broadcast via BitcoinJ fails we also
        // publish the tx via mempool nodes.
        MemPoolSpaceTxBroadcaster.broadcastTx(sendResult.tx);

        return sendResult.tx;
    }

    private SendRequest getSendRequest(String fromAddress,
                                       String toAddress,
                                       Coin amount,
                                       Coin fee,
                                       @Nullable KeyParameter aesKey,
                                       AddressEntry.Context context) throws AddressFormatException,
            AddressEntryException {
        Transaction tx = new Transaction(params);
        final Coin receiverAmount = amount.subtract(fee);
        Preconditions.checkArgument(Restrictions.isAboveDust(receiverAmount),
                ""The amount is too low (dust limit)."");
        tx.addOutput(receiverAmount, Address.fromString(params, toAddress));

        SendRequest sendRequest = SendRequest.forTx(tx);
        sendRequest.fee = fee;
        sendRequest.feePerKb = Coin.ZERO;
        sendRequest.ensureMinRequiredFee = false;
        sendRequest.aesKey = aesKey;
        sendRequest.shuffleOutputs = false;
        Optional<AddressEntry> addressEntry = findAddressEntry(fromAddress, context);
        if (!addressEntry.isPresent())
            throw new AddressEntryException(""WithdrawFromAddress is not found in our wallet."");

        checkNotNull(addressEntry.get(), ""addressEntry.get() must not be null"");
        checkNotNull(addressEntry.get().getAddress(), ""addressEntry.get().getAddress() must not be null"");
        sendRequest.coinSelector = new BtcCoinSelector(addressEntry.get().getAddress(), preferences.getIgnoreDustThreshold());
        sendRequest.changeAddress = addressEntry.get().getAddress();
        return sendRequest;
    }

    private SendRequest getSendRequestForMultipleAddresses(Set<String> fromAddresses,
                                                           String toAddress,
                                                           Coin amount,
                                                           Coin fee,
                                                           @Nullable String changeAddress,
                                                           @Nullable KeyParameter aesKey) throws
            AddressFormatException, AddressEntryException {
        Transaction tx = new Transaction(params);
        final Coin netValue = amount.subtract(fee);
        checkArgument(Restrictions.isAboveDust(netValue),
                ""The amount is too low (dust limit)."");

        tx.addOutput(netValue, Address.fromString(params, toAddress));

        SendRequest sendRequest = SendRequest.forTx(tx);
        sendRequest.fee = fee;
        sendRequest.feePerKb = Coin.ZERO;
        sendRequest.ensureMinRequiredFee = false;
        sendRequest.aesKey = aesKey;
        sendRequest.shuffleOutputs = false;
        Set<AddressEntry> addressEntries = fromAddresses.stream()
                .map(address -> {
                    Optional<AddressEntry> addressEntryOptional = findAddressEntry(address, AddressEntry.Context.AVAILABLE);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.OFFER_FUNDING);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.TRADE_PAYOUT);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.ARBITRATOR);
                    return addressEntryOptional;
                })
                .flatMap(Optional::stream)
                .collect(Collectors.toSet());
        if (addressEntries.isEmpty())
            throw new AddressEntryException(""No Addresses for withdraw found in our wallet"");

        sendRequest.coinSelector = new BtcCoinSelector(walletsSetup.getAddressesFromAddressEntries(addressEntries),
                preferences.getIgnoreDustThreshold());
        Optional<AddressEntry> addressEntryOptional = Optional.empty();

        if (changeAddress != null)
            addressEntryOptional = findAddressEntry(changeAddress, AddressEntry.Context.AVAILABLE);

        AddressEntry changeAddressAddressEntry = addressEntryOptional.orElseGet(this::getFreshAddressEntry);
        checkNotNull(changeAddressAddressEntry, ""change address must not be null"");
        sendRequest.changeAddress = changeAddressAddressEntry.getAddress();
        return sendRequest;
    }

    // We ignore utxos which are considered dust attacks for spying on users' wallets.
    // The ignoreDustThreshold value is set in the preferences. If not set we use default non dust
    // value of 546 sat.
    @Override
    protected boolean isDustAttackUtxo(TransactionOutput output) {
        return output.getValue().value < preferences.getIgnoreDustThreshold();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Refund payoutTx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction createRefundPayoutTx(Coin buyerAmount,
                                            Coin sellerAmount,
                                            Coin fee,
                                            String buyerAddressString,
                                            String sellerAddressString)
            throws AddressFormatException, InsufficientMoneyException, WalletException, TransactionVerificationException {
        Transaction tx = new Transaction(params);
        Preconditions.checkArgument(buyerAmount.add(sellerAmount).isPositive(),
                ""The sellerAmount + buyerAmount must be positive."");
        // buyerAmount can be 0
        if (buyerAmount.isPositive()) {
            Preconditions.checkArgument(Restrictions.isAboveDust(buyerAmount),
                    ""The buyerAmount is too low (dust limit)."");

            tx.addOutput(buyerAmount, Address.fromString(params, buyerAddressString));
        }
        // sellerAmount can be 0
        if (sellerAmount.isPositive()) {
            Preconditions.checkArgument(Restrictions.isAboveDust(sellerAmount),
                    ""The sellerAmount is too low (dust limit)."");

            tx.addOutput(sellerAmount, Address.fromString(params, sellerAddressString));
        }

        SendRequest sendRequest = SendRequest.forTx(tx);
        sendRequest.fee = fee;
        sendRequest.feePerKb = Coin.ZERO;
        sendRequest.ensureMinRequiredFee = false;
        sendRequest.aesKey = aesKey;
        sendRequest.shuffleOutputs = false;
        sendRequest.coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        sendRequest.changeAddress = getFreshAddressEntry().getAddress();

        checkNotNull(wallet);
        wallet.completeTx(sendRequest);

        Transaction resultTx = sendRequest.tx;
        checkWalletConsistency(wallet);
        verifyTransaction(resultTx);

        WalletService.printTx(""createRefundPayoutTx"", resultTx);

        return resultTx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Find inputs and change
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Tuple2<List<RawTransactionInput>, Coin> getInputsAndChange(Coin required) throws InsufficientMoneyException {
        BtcCoinSelector coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        CoinSelection coinSelection = coinSelector.select(required, Objects.requireNonNull(wallet).calculateAllSpendCandidates());

        Coin change;
        try {
            change = coinSelector.getChange(required, coinSelection);
        } catch (InsufficientMoneyException e) {
            log.error(""Missing funds in getSellersBtcInputsForBsqSwapTx. missing={}"", e.missing);
            throw new InsufficientMoneyException(e.missing);
        }

        Transaction dummyTx = new Transaction(params);
        coinSelection.gathered.forEach(dummyTx::addInput);
        List<RawTransactionInput> inputs = dummyTx.getInputs().stream()
                .map(RawTransactionInput::new)
                .collect(Collectors.toList());
        return new Tuple2<>(inputs, change);
    }
}",1,439 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 381 2006 2007 59 621 621 621 64 2008 439 2000 40 2009 2010 44 2006 2007 44 2011 2012 44 2013 2014 41 123 463 40 2010 44 2012 44 2014 41 59 467 46 2007 61 2007 59 2010 46 2015 40 40 41 45 62 123 2016 61 2010 46 2017 40 41 59 2018 40 41 59 2010 46 2019 40 41 46 2020 40 2021 45 62 2022 46 2023 40 2021 46 2024 40 41 41 41 59 2022 46 2023 40 2010 46 2019 40 41 46 2025 40 41 41 59 125 41 59 125 621 621 621 64 2026 492 2027 40 64 2028 2029 2030 41 123 463 46 2027 40 2030 41 59 2007 46 2031 40 41 46 2032 40 2033 45 62 123 2034 2035 61 2033 46 2036 40 41 59 392 40 2035 46 2037 40 41 41 2033 46 2038 40 2035 46 2039 40 2030 41 41 59 125 41 59 2007 46 2040 40 41 59 125 64 2026 492 2041 40 2042 2043 44 2029 2030 41 123 463 46 2041 40 2043 44 2030 41 59 2007 46 2044 40 41 46 2045 40 2046 45 62 123 2047 2048 61 2046 46 2049 40 41 59 392 40 2048 46 2050 40 41 41 2046 46 2051 40 2048 46 2052 40 2043 44 2030 41 41 59 125 41 59 2007 46 2053 40 41 59 125 64 2026 2054 2055 40 324 2056 41 123 2057 2058 61 418 2057 40 41 59 2059 40 41 46 2060 40 2061 45 62 2058 46 2062 40 2061 46 2063 40 41 41 46 2062 40 648 41 41 59 621 450 648 43 2058 46 2063 40 41 43 648 43 2064 46 2063 40 473 44 2056 44 467 46 2065 44 473 44 473 44 2010 46 2066 40 41 41 43 648 43 648 43 2064 46 2067 40 41 59 125 621 621 621 621 621 621 439 2068 2069 40 2068 2070 44 326 91 93 2071 41 470 2072 44 2073 44 2074 123 450 2075 40 2070 44 2071 44 424 44 424 41 59 125 621 621 621 439 2068 2076 40 2077 2078 44 2079 2080 44 2068 2081 44 326 91 93 2071 41 470 2074 44 2072 44 2073 123 450 2082 40 2081 44 2071 44 2078 44 2080 41 59 125 439 2068 2083 40 2077 2078 44 2079 2080 44 2068 2081 44 326 91 93 2071 41 470 2074 44 2072 44 2073 123 450 2084 40 2081 44 2071 44 2078 44 2080 41 59 125 437 2068 2085 40 2068 2081 44 326 91 93 2071 44 64 2086 2077 2078 44 64 2086 2079 2080 41 470 2074 44 2072 44 2073 123 621 621 621 621 621 621 621 621 621 621 621 2068 2087 61 418 2068 40 433 41 59 621 2081 46 2088 40 41 46 2089 40 2087 58 58 2090 41 59 404 2091 61 2081 46 2088 40 41 46 2092 40 41 59 621 621 2081 46 2093 40 41 46 2089 40 2087 58 58 2094 41 59 621 392 40 2078 631 424 605 2080 631 424 41 123 621 2087 46 2094 40 2078 44 2080 41 59 125 621 404 2095 61 1500 59 621 404 2096 61 1504 59 621 404 2097 61 1504 59 2077 2098 61 2014 46 2099 40 41 59 2079 2100 61 2101 40 41 46 2102 40 41 59 2103 40 2100 44 648 41 59 2104 2105 61 418 2104 40 2010 46 2106 40 2107 46 2108 46 2109 41 44 2012 46 2110 40 41 41 59 2111 60 2112 62 2113 61 2087 46 2088 40 41 59 2111 60 2114 62 2115 61 2087 46 2093 40 41 59 2116 60 2117 44 2117 62 2118 61 2119 40 2087 41 59 404 2120 61 2118 46 2121 59 404 2122 61 2118 46 2123 59 2068 2124 61 424 59 324 2125 59 355 123 2095 637 59 392 40 2095 615 1502 41 123 2103 40 2124 44 648 41 59 2003 46 371 40 648 43 2124 41 59 325 59 125 2068 2126 61 418 2068 40 433 41 59 2113 46 2089 40 2126 58 58 2090 41 59 2115 46 2089 40 2126 58 58 2094 41 59 2127 2128 61 2127 46 2129 40 2126 41 59 2128 46 2130 61 380 59 2128 46 2131 61 2131 59 621 2128 46 2132 61 380 59 2128 46 2133 61 2098 46 2134 40 2097 43 2096 42 2120 43 2096 42 2122 47 1502 41 59 2128 46 2135 61 2077 46 2136 59 2128 46 2137 61 380 59 2128 46 2105 61 2105 59 2128 46 2100 61 2100 59 2138 46 2139 40 2128 41 59 2124 61 2128 46 2126 59 621 2124 46 2094 40 418 2114 40 433 44 2124 44 2077 46 2136 44 2140 46 2141 40 2071 41 46 2142 40 41 41 41 59 2118 61 2119 40 2124 41 59 2120 61 2118 46 2121 59 2122 61 2118 46 2123 59 2097 61 2124 46 2143 40 41 59 413 2144 61 2098 46 2134 40 2097 43 2096 42 2120 43 2096 42 2122 47 1502 41 46 2145 59 621 2125 61 2146 46 2147 40 2124 46 2148 40 41 46 2145 45 2144 41 62 1504 59 125 496 40 2125 41 59 621 2149 40 2091 44 2124 41 59 2150 40 2151 41 59 2152 40 2124 41 59 621 450 2124 59 125 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 439 2068 2153 40 2068 2154 44 326 91 93 2071 41 470 2074 44 2072 44 2073 123 621 450 2155 40 2154 44 2071 41 59 125 437 2068 2156 40 2068 2154 44 326 91 93 2071 41 470 2073 44 2074 44 2072 123 621 404 2157 61 2154 46 2158 40 41 46 2159 40 41 59 2068 2160 61 2161 40 2154 44 2071 41 59 2162 40 2157 44 2160 41 59 2163 40 2164 41 59 2165 40 2160 41 59 621 450 2160 59 125 437 2068 2166 40 2068 2154 44 326 91 93 2071 41 470 2073 123 621 404 2167 61 1500 59 621 404 2168 61 1504 59 621 404 2169 61 1504 59 2077 2170 61 2014 46 2171 40 41 59 2079 2172 61 2173 40 41 46 2174 40 41 59 2175 40 2172 44 648 41 59 2176 2177 61 418 2176 40 2010 46 2178 40 2179 46 2180 46 2181 41 44 2012 46 2182 40 41 41 59 2183 60 2184 62 2185 61 2154 46 2186 40 41 59 2183 60 2187 62 2188 61 2154 46 2189 40 41 59 2190 60 2191 44 2191 62 2192 61 2193 40 2154 41 59 404 2194 61 2192 46 2195 59 404 2196 61 2192 46 2197 59 2068 2198 61 424 59 324 2199 59 355 123 2167 637 59 392 40 2167 615 1502 41 123 2175 40 2198 44 648 41 59 2003 46 371 40 648 43 2198 41 59 325 59 125 2068 2200 61 418 2068 40 433 41 59 2185 46 2201 40 2200 58 58 2202 41 59 2188 46 2201 40 2200 58 58 2203 41 59 2204 2205 61 2204 46 2206 40 2200 41 59 2205 46 2207 61 380 59 2205 46 2208 61 2208 59 621 2205 46 2209 61 380 59 2205 46 2210 61 2170 46 2211 40 2169 43 2168 42 2194 43 2168 42 2196 47 1502 41 59 2205 46 2212 61 2077 46 2213 59 2205 46 2214 61 380 59 2205 46 2177 61 2177 59 2205 46 2172 61 2172 59 2215 46 2216 40 2205 41 59 2198 61 2205 46 2200 59 621 2198 46 2203 40 418 2187 40 433 44 2198 44 2077 46 2213 44 2217 46 2218 40 2071 41 46 2219 40 41 41 41 59 2192 61 2193 40 2198 41 59 2194 61 2192 46 2195 59 2196 61 2192 46 2197 59 2169 61 2198 46 2220 40 41 59 381 413 2221 61 2170 46 2211 40 2169 43 2168 42 2194 43 2168 42 2196 47 1502 41 46 2222 59 621 2199 61 2223 46 2224 40 2198 46 2225 40 41 46 2222 45 2221 41 62 1504 59 125 496 40 2199 41 59 450 2198 59 125 437 492 2226 40 404 2227 44 2068 2228 41 470 2074 123 385 40 404 2229 61 2227 59 2229 60 2228 46 2230 40 41 46 2231 40 41 59 2229 637 41 123 2232 2233 61 2228 46 2230 40 41 46 2234 40 2229 41 59 2235 40 2233 46 2236 40 41 631 424 605 2233 46 2236 40 41 46 2237 40 2238 41 44 648 41 59 2239 40 2238 44 2240 44 2228 44 2233 44 2229 41 59 2241 40 2228 44 2233 44 2229 41 59 125 125 621 621 621 621 621 621 621 621 621 621 621 621 621 621 439 2068 2242 40 2068 2154 44 326 91 93 2071 41 470 2074 44 2072 44 2073 123 450 2156 40 2154 44 2071 41 59 125 621 621 621 439 2068 2243 40 2068 2244 41 470 2074 44 2072 44 2073 123 621 621 621 621 621 621 621 621 621 621 621 2077 2245 61 2246 40 41 59 450 2247 40 2244 44 424 44 2245 41 59 125 439 2068 2243 40 2068 2244 44 2077 2248 41 470 2074 44 2072 44 2073 123 450 2249 40 2244 44 424 44 2248 41 59 125 439 2068 2250 40 2068 2244 44 64 2086 326 91 93 2071 41 470 2074 44 2072 44 2073 123 2077 2248 61 2251 40 41 59 450 2250 40 2244 44 2071 44 2248 41 59 125 439 2068 2250 40 2068 2244 44 64 2086 326 91 93 2071 44 2077 2248 41 470 2074 44 2072 44 2073 123 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 404 2252 61 1500 59 621 404 2253 61 1504 59 621 404 2254 61 1504 59 621 2077 2255 61 2077 46 2256 59 2079 2257 61 2258 40 41 46 2259 40 41 59 2260 40 2257 44 648 41 59 2261 2262 61 418 2261 40 2010 46 2263 40 2264 46 2265 46 2266 41 44 2012 46 2267 40 41 41 59 2268 60 2269 62 2270 61 2244 46 2271 40 41 59 2268 60 2272 62 2273 61 2244 46 2274 40 41 59 621 621 404 2275 61 2270 46 2276 40 41 43 1501 59 621 404 2277 61 1500 59 2068 2278 61 424 59 324 2279 59 324 2280 59 355 123 2252 637 59 392 40 2252 615 1502 41 123 2260 40 2278 44 648 41 59 2003 46 371 40 648 43 2278 41 59 325 59 125 2068 2228 61 418 2068 40 433 41 59 2270 46 2281 40 2228 58 58 2282 41 59 392 40 2255 46 2283 40 41 41 123 2273 46 2281 40 2228 58 58 2284 41 59 125 360 123 621 2285 40 2273 46 2276 40 41 614 1500 44 648 41 59 2228 46 2286 40 2255 44 2257 41 59 125 2287 2288 61 2287 46 2289 40 2228 41 59 2288 46 2290 61 380 59 2288 46 2291 61 2291 59 621 2288 46 2292 61 380 59 2288 46 2293 61 2248 46 2294 40 2254 43 2253 42 2275 43 2253 42 2277 47 1502 41 59 2288 46 2295 61 2077 46 2256 59 2288 46 2296 61 380 59 2288 46 2262 61 2262 59 2288 46 2257 61 2257 59 2297 46 2298 40 2288 41 59 2278 61 2288 46 2228 59 621 621 621 2280 61 2278 46 2274 40 41 46 2276 40 41 614 1500 59 2255 61 2280 63 2299 46 2300 40 41 58 2077 46 2256 59 621 392 40 2071 631 424 41 2278 46 2301 40 418 2272 40 433 44 2278 44 2077 46 2256 44 2302 46 2303 40 2071 41 46 2304 40 41 41 41 59 2305 60 2306 44 2306 62 2307 61 2308 40 2278 41 59 2275 61 2307 46 2309 59 2277 61 2307 46 2310 59 2254 61 2278 46 2311 40 41 59 381 413 2312 61 2248 46 2294 40 2254 43 2253 42 2275 43 2253 42 2277 47 1502 41 46 2313 59 621 2279 61 2314 46 2315 40 2278 46 2316 40 41 46 2313 45 2312 41 62 1504 59 125 496 40 2280 606 2279 606 2278 46 2317 40 41 46 2318 60 2248 46 2319 40 2278 46 2320 40 41 41 46 2318 41 59 621 2226 40 2270 46 2276 40 41 44 2278 41 59 2321 40 2322 41 59 2323 40 2278 41 59 2324 40 648 44 2278 41 59 450 2278 59 125 437 2325 60 2326 44 2326 62 2327 40 2068 2228 41 123 404 2328 61 1500 59 404 2329 61 1500 59 385 40 2330 2331 58 2228 46 2332 40 41 41 123 2333 2334 61 2331 46 2335 40 41 59 392 40 2334 614 424 606 2336 46 2337 40 2334 46 2338 40 41 41 606 2336 46 2339 40 2334 46 2338 40 41 41 41 123 621 621 2328 637 59 125 360 392 40 2336 46 2340 40 2334 46 2338 40 41 41 41 123 2329 637 59 125 360 123 469 418 2341 40 648 41 59 125 125 450 418 2325 60 62 40 2328 44 2329 41 59 125 621 621 621 439 492 2342 40 2068 2228 41 123 2343 46 2342 40 2228 41 59 621 125 621 621 621 439 2344 60 2345 62 2346 40 2054 2347 44 64 2348 40 648 41 2345 46 2349 2350 41 123 450 2351 40 41 46 2352 40 41 46 2353 40 2354 45 62 2347 46 2355 40 2354 46 2356 40 41 41 41 46 2353 40 2354 45 62 2350 614 2354 46 2357 40 41 41 46 2358 40 41 59 125 439 2345 2359 40 2054 2347 44 2345 46 2349 2350 41 123 2344 60 2345 62 2360 61 2361 40 41 46 2362 40 41 46 2363 40 2364 45 62 2347 46 2365 40 2364 46 2366 40 41 41 41 46 2363 40 2364 45 62 2350 614 2364 46 2367 40 41 41 46 2368 40 41 59 392 40 2360 46 2369 40 41 41 123 450 2360 46 2370 40 41 59 125 360 123 621 2344 60 2345 62 2371 61 2361 40 41 46 2362 40 41 46 2363 40 2364 45 62 2345 46 2349 46 2372 614 2364 46 2367 40 41 41 46 2363 40 2364 45 62 2373 40 2364 46 2374 40 41 41 41 46 2363 40 2364 45 62 2375 46 2376 46 2377 46 2365 40 2364 46 2374 40 41 46 2378 40 41 41 41 46 2368 40 41 59 392 40 2371 46 2369 40 41 605 2350 631 2345 46 2349 46 2379 41 123 621 450 2007 46 2380 40 2371 46 2381 40 41 44 2350 44 2347 41 59 125 360 123 2382 2030 61 40 2382 41 2383 46 2384 40 2383 46 2385 40 2375 46 2376 46 2377 41 41 59 2345 2386 61 418 2345 40 2030 44 2350 44 2347 44 473 41 59 2003 46 2387 40 648 44 2386 41 59 2007 46 2388 40 2386 41 59 450 2386 59 125 125 125 439 2345 2389 40 41 123 2345 46 2349 2350 61 2345 46 2349 46 2390 59 2344 60 2345 62 2391 61 2392 40 41 46 2393 40 41 46 2394 40 2395 45 62 2350 614 2395 46 2396 40 41 41 46 2397 40 41 59 450 2359 40 2350 44 2391 44 380 41 59 125 439 2345 2398 40 41 123 450 2398 40 473 41 59 125 439 2345 2398 40 324 2399 41 123 2345 46 2349 2350 61 2345 46 2349 46 2400 59 2344 60 2345 62 2401 61 2402 40 41 46 2403 40 41 46 2404 40 2405 45 62 2350 614 2405 46 2406 40 41 41 46 2404 40 2405 45 62 2407 40 2405 46 2408 40 41 41 41 46 2404 40 2405 45 62 123 324 2409 61 2410 46 2411 46 2412 46 2413 40 2405 46 2408 40 41 46 2414 40 41 41 59 621 450 2409 614 2399 59 125 41 46 2415 40 41 59 450 2359 40 2350 44 2401 44 2399 41 59 125 439 492 2416 40 2054 2347 44 2054 2417 44 2345 46 2349 2350 41 123 2418 40 2417 44 2345 46 2349 46 2419 41 46 2420 40 2421 45 62 2007 46 2422 40 2421 44 2350 44 2347 41 41 59 125 437 2345 2359 40 2345 46 2349 2350 44 2344 60 2345 62 2423 44 324 2399 41 123 392 40 2423 46 2424 40 41 41 123 450 2423 46 2425 40 41 59 125 360 123 2426 2030 59 392 40 2399 41 123 2030 61 40 2426 41 2427 46 2428 40 2427 46 2429 40 2430 46 2431 46 2432 41 41 59 125 360 123 2030 61 40 2426 41 2433 46 2434 40 2433 46 2435 40 2436 46 2437 46 2438 41 41 59 125 2345 2439 61 418 2345 40 2030 44 2350 44 2399 41 59 2003 46 2440 40 648 44 2439 41 59 2007 46 2441 40 2439 41 59 450 2439 59 125 125 437 2344 60 2345 62 2442 40 2054 2417 44 2345 46 2349 2350 41 123 450 2443 40 41 46 2444 40 41 46 2445 40 2446 45 62 2417 46 2447 40 2446 46 2448 40 41 41 41 46 2445 40 2446 45 62 2350 614 2446 46 2449 40 41 41 46 2450 40 41 59 125 439 2451 60 2345 62 2452 40 41 123 450 2453 40 41 46 2454 40 41 46 2455 40 2423 45 62 2345 46 2349 46 2456 614 2423 46 2457 40 41 41 46 2458 40 2459 46 2460 40 41 41 59 125 439 2451 60 2345 62 2461 40 41 123 450 2462 40 41 46 2463 40 41 46 2464 40 2423 45 62 2345 46 2349 46 2465 614 2423 46 2466 40 41 606 2345 46 2349 46 2467 614 2423 46 2466 40 41 41 46 2468 40 2469 46 2470 40 41 41 59 125 439 2451 60 2345 62 2471 40 41 123 450 2472 40 41 46 2473 40 41 46 2474 40 2423 45 62 2345 46 2349 46 2475 614 2423 46 2476 40 41 606 2345 46 2349 46 2477 614 2423 46 2476 40 41 41 46 2478 40 2479 46 2480 40 41 41 59 125 439 2451 60 2345 62 2481 40 2345 46 2349 2350 41 123 450 2482 40 41 46 2483 40 41 46 2484 40 2423 45 62 2350 614 2423 46 2485 40 41 41 46 2486 40 2487 46 2488 40 41 41 59 125 439 2451 60 2345 62 2489 40 41 123 450 2452 40 41 46 2490 40 41 46 2491 40 2423 45 62 2492 40 2423 46 2493 40 41 41 46 2494 40 41 41 46 2495 40 2496 46 2497 40 41 41 59 125 439 2451 60 2345 62 2498 40 41 123 450 2007 46 2499 40 41 59 125 439 492 2500 40 2054 2347 44 2345 46 2349 2350 41 123 392 40 2350 614 2345 46 2349 46 2501 41 123 2003 46 371 40 648 43 648 43 648 43 648 44 2347 44 2350 41 59 450 59 125 2498 40 41 46 2502 40 41 46 2503 40 2504 45 62 2347 46 2505 40 2504 46 2506 40 41 41 41 46 2503 40 2504 45 62 2350 614 2504 46 2507 40 41 41 46 2508 40 2504 45 62 123 2003 46 2509 40 648 44 2504 46 2510 40 41 44 2504 46 2506 40 41 44 2350 41 59 2007 46 2511 40 2504 41 59 125 41 59 125 621 439 492 2512 40 2054 2347 41 123 2513 40 2347 44 1500 41 59 125 439 492 2514 40 2054 2347 44 413 2515 41 123 2498 40 41 46 2516 40 41 46 2517 40 2518 45 62 2345 46 2349 46 2519 614 2518 46 2520 40 41 41 46 2517 40 2518 45 62 2347 46 2521 40 2518 46 2522 40 41 41 41 46 2523 40 2423 45 62 2514 40 2423 44 2515 41 41 59 125 439 492 2514 40 2345 2423 44 413 2515 41 123 2003 46 2524 40 648 44 2423 44 2515 41 59 2007 46 2514 40 2423 44 2515 41 59 125 439 492 2525 40 2054 2347 41 123 2003 46 2526 40 648 44 2347 41 59 2500 40 2347 44 2345 46 2349 46 2527 41 59 2500 40 2347 44 2345 46 2349 46 2528 41 59 125 439 492 2529 40 2054 2347 41 123 621 621 621 621 621 621 621 621 621 2500 40 2347 44 2345 46 2349 46 2530 41 59 125 439 492 2531 40 2054 2347 41 123 2525 40 2347 41 59 2529 40 2347 41 59 125 439 492 2532 40 41 123 2007 46 2533 40 41 59 125 439 2534 2535 40 2054 2536 44 326 91 93 2537 41 123 2344 60 2345 62 2538 61 2346 40 2536 44 2345 46 2349 46 2539 41 59 2534 2540 59 392 40 2538 46 2541 40 41 41 123 2345 2542 61 2538 46 2543 40 41 59 2540 61 2542 46 2544 40 41 59 392 40 33 2545 46 2546 40 2537 44 2542 46 2547 40 41 41 41 123 2003 46 371 40 648 43 648 44 2536 41 59 2540 61 2548 40 2537 41 59 125 125 360 123 2003 46 371 40 648 43 648 44 2536 41 59 2540 61 2549 40 2537 41 59 125 450 2540 59 125 621 621 621 439 2077 2550 40 41 123 450 2077 46 2551 40 2489 40 41 46 2552 40 41 46 2553 40 2423 45 62 2554 40 2423 46 2555 40 41 41 46 2515 41 46 2556 40 41 41 59 125 439 2557 60 2345 62 2558 40 41 123 2557 60 2345 62 2559 61 2557 46 2560 40 2481 40 2345 46 2349 46 2561 41 46 2562 40 41 44 2489 40 41 46 2562 40 41 41 59 2557 60 2345 62 2563 61 2557 46 2560 40 2559 44 2481 40 2345 46 2349 46 2564 41 46 2562 40 41 41 59 2563 61 2557 46 2560 40 2563 44 2481 40 2345 46 2349 46 2565 41 46 2562 40 41 41 59 450 2563 46 2566 40 2423 45 62 2567 40 2423 46 2568 40 41 41 46 2569 40 41 41 59 125 621 621 621 439 492 2570 40 2054 2571 44 2572 2573 44 2574 2575 41 470 2576 123 2345 2423 61 2398 40 41 59 2577 40 2423 46 2578 40 41 44 648 41 59 2344 60 2068 62 2579 61 2580 46 2581 40 473 41 46 2582 40 41 46 2583 40 2584 45 62 2584 46 2585 40 41 46 2586 40 41 46 2587 40 2571 41 41 46 2588 40 41 59 392 40 2579 46 2589 40 41 41 123 2068 2590 61 2579 46 2591 40 41 59 2079 2592 61 2423 46 2578 40 41 59 381 2593 46 2594 2595 61 2590 46 2596 40 41 46 2597 40 41 59 392 40 2595 614 2593 46 2594 46 2598 41 123 2003 46 2599 40 648 43 2590 46 2600 40 41 46 2601 40 41 41 59 2068 2602 61 418 2068 40 433 41 59 2590 46 2600 40 41 46 2603 40 2604 45 62 123 381 2605 2606 61 2604 46 2607 40 41 59 392 40 2606 631 424 605 2606 46 2608 40 2580 41 605 2606 46 2609 40 41 631 424 605 2606 46 2609 40 41 46 2596 40 41 631 424 605 2604 46 2610 40 41 631 424 41 123 621 2602 46 2611 40 418 2612 40 433 44 2602 44 418 326 91 93 123 125 44 418 2613 40 433 44 2604 46 2614 40 41 46 2615 40 41 44 418 2068 40 433 44 2606 46 2609 40 41 46 2616 40 41 41 41 44 2077 46 2617 40 2604 46 2610 40 41 46 2515 41 41 41 59 604 125 125 41 59 2003 46 2618 40 648 43 2602 46 2600 40 41 46 2601 40 41 41 59 2003 46 2618 40 648 43 2602 46 2619 40 41 47 1505 41 59 392 40 33 2602 46 2600 40 41 46 2620 40 41 41 123 2077 2621 61 2077 46 2622 40 2602 46 2600 40 41 46 2582 40 41 46 2623 40 2604 45 62 2604 46 2624 40 41 631 424 63 2604 46 2624 40 41 46 2515 58 1500 41 46 2625 40 41 41 59 2602 46 2626 40 2621 44 2592 41 59 474 123 2077 2627 59 404 2628 61 1500 59 404 2629 61 1500 59 2068 2228 59 2630 2631 59 2077 2632 61 2633 40 41 59 355 123 2628 637 59 2627 61 2632 46 2634 40 2629 41 59 2602 46 2635 40 41 59 2602 46 2626 40 2621 46 2636 40 2627 41 44 2592 41 59 2631 61 2630 46 2637 40 2602 41 59 2631 46 2627 61 2627 59 2631 46 2638 61 2077 46 2639 59 2631 46 2640 61 380 59 2631 46 2641 61 2641 59 2631 46 2642 61 418 2643 40 2592 44 2012 46 2644 40 41 41 59 2631 46 2645 61 2592 59 2580 46 2646 40 2631 41 59 2228 61 2631 46 2228 59 2629 61 2228 46 2619 40 41 59 2647 40 648 44 2228 41 59 2631 46 2228 46 2648 40 41 46 2603 40 2649 45 62 2003 46 2599 40 648 43 2649 46 2624 40 41 46 2650 40 41 41 41 59 125 496 40 2651 40 2628 44 2228 41 41 59 392 40 2628 614 1502 41 2003 46 371 40 648 43 2228 41 59 2652 46 2653 2654 61 424 59 474 123 2631 61 2630 46 2655 40 2602 41 59 2631 46 2627 61 2627 59 2631 46 2656 61 2077 46 2657 59 2631 46 2658 61 380 59 2631 46 2659 61 2659 59 2631 46 2660 61 418 2661 40 2592 44 2012 46 2662 40 41 41 59 2631 46 2663 61 2592 59 2654 61 2580 46 2664 40 2631 41 59 125 329 40 2073 2665 41 123 621 2003 46 2666 40 648 43 40 2665 46 2667 631 424 63 2665 46 2667 46 2668 40 41 58 648 41 41 59 2621 61 2621 46 2669 40 2665 46 2667 41 59 2602 46 2670 40 41 59 2602 46 2626 40 2621 44 2592 41 59 2631 61 2630 46 2671 40 2602 41 59 2631 46 2627 61 2627 59 2631 46 2672 61 2077 46 2673 59 2631 46 2674 61 380 59 2631 46 2675 61 2675 59 2631 46 2676 61 418 2677 40 2592 44 2012 46 2678 40 41 44 380 41 59 2631 46 2679 61 2592 59 474 123 2654 61 2580 46 2680 40 2631 41 59 2681 40 648 44 2602 41 59 621 621 2682 46 2683 40 2654 46 2228 41 59 125 329 40 2073 2684 41 123 2575 46 2685 40 648 43 40 2684 46 2667 631 424 63 2684 46 2667 46 2668 40 41 58 648 41 41 59 125 125 392 40 2654 631 424 41 123 2003 46 2618 40 648 43 2654 46 2228 41 59 2686 46 2687 40 2654 46 2688 44 418 2689 60 62 40 41 123 64 2026 439 492 2690 40 2068 2691 41 123 2003 46 2618 40 648 43 2691 41 59 2573 46 2692 40 41 59 125 64 2026 439 492 2693 40 64 2028 2694 2584 41 123 2003 46 371 40 648 43 2584 46 2695 40 41 41 59 2575 46 2696 40 2584 46 2695 40 41 41 59 125 125 44 2697 46 2698 40 41 41 59 125 125 329 40 2073 2699 41 123 469 418 2576 40 648 43 648 43 648 43 40 2699 46 2700 631 424 63 2699 46 2700 46 2701 40 41 58 648 41 41 59 125 125 360 123 2054 2702 61 648 59 2003 46 2703 40 2702 41 59 2575 46 2704 40 2702 41 59 125 125 360 392 40 2595 614 2593 46 2594 46 2705 41 123 2575 46 2706 40 648 41 59 125 360 392 40 2595 614 2593 46 2594 46 2707 41 123 2575 46 2708 40 648 41 59 125 125 125 621 621 621 439 2068 2709 40 2054 2710 44 2054 2711 44 2077 2712 44 2345 46 2349 2350 41 470 2713 44 2714 44 2576 123 2344 60 2345 62 2423 61 2442 40 2710 44 2350 41 59 392 40 33 2423 46 2715 40 41 41 469 418 2714 40 648 41 59 2716 40 2423 46 2717 40 41 46 2718 40 41 44 648 41 59 474 123 2077 2719 59 404 2720 61 1500 59 404 2721 61 1500 59 2068 2228 59 2077 2722 61 2723 40 41 59 355 123 2720 637 59 2719 61 2722 46 2724 40 2721 41 59 2725 2726 61 2727 40 2710 44 2711 44 2712 44 2719 44 2728 44 2350 41 59 2729 46 2730 40 2726 41 59 2228 61 2726 46 2228 59 2721 61 2228 46 2731 40 41 59 2732 40 648 44 2228 41 59 125 496 40 2733 40 2720 44 2228 41 41 59 392 40 2720 614 1502 41 2003 46 371 40 648 43 2228 41 59 450 2228 59 125 329 40 2073 2734 41 123 469 418 2576 40 648 43 648 43 648 43 40 2734 46 2735 631 424 63 2734 46 2735 46 2736 40 41 58 648 41 41 59 125 125 439 2068 2737 40 2738 60 2054 62 2739 44 2077 2712 41 470 2713 44 2714 44 2576 123 2077 2740 61 2741 40 41 59 450 2737 40 2739 44 2712 44 2740 41 59 125 439 2068 2737 40 2738 60 2054 62 2739 44 2077 2712 44 2077 2742 41 470 2713 44 2714 44 2576 123 2738 60 2345 62 2743 61 2739 46 2744 40 41 46 2745 40 2417 45 62 123 2344 60 2345 62 2746 61 2442 40 2417 44 2345 46 2349 46 2747 41 59 392 40 33 2746 46 2748 40 41 41 2746 61 2442 40 2417 44 2345 46 2349 46 2749 41 59 392 40 33 2746 46 2748 40 41 41 2746 61 2442 40 2417 44 2345 46 2349 46 2750 41 59 392 40 33 2746 46 2748 40 41 41 2746 61 2442 40 2417 44 2345 46 2349 46 2751 41 59 450 2746 59 125 41 46 2752 40 2344 58 58 2744 41 46 2753 40 2754 46 2755 40 41 41 59 392 40 2743 46 2756 40 41 41 469 418 2714 40 648 41 59 474 123 2077 2757 59 404 2758 61 1500 59 404 2759 61 1500 59 2068 2228 59 355 123 2758 637 59 2757 61 2742 46 2760 40 2759 41 59 621 621 621 381 2054 2761 61 2762 46 2763 40 433 44 418 2764 40 41 41 46 2765 40 41 59 2766 2767 61 2768 40 2739 44 2761 44 2712 44 2757 44 424 44 2769 41 59 2770 46 2771 40 2767 41 59 2228 61 2767 46 2228 59 2759 61 2228 46 2772 40 41 59 2773 40 648 44 2228 41 59 125 496 40 2774 40 2758 44 2228 41 41 59 392 40 2758 614 1502 41 2003 46 371 40 648 43 2228 41 59 450 2228 59 125 329 40 2073 2775 41 123 469 418 2576 40 648 43 648 43 648 43 40 2775 46 2776 631 424 63 2775 46 2776 46 2777 40 41 58 648 41 41 59 125 125 437 324 2778 40 404 2779 44 2068 2228 41 123 450 2778 40 2779 44 2228 44 2780 40 41 41 59 125 437 324 2778 40 404 2779 44 2068 2228 44 2077 2742 41 123 413 2781 61 2742 46 2782 40 2228 46 2783 40 41 41 46 2515 59 450 2779 60 1502 605 40 2228 46 2784 40 41 46 2515 60 2781 606 2228 46 2784 40 41 46 2515 45 2781 62 1504 41 59 125 439 404 2785 40 2451 60 2077 62 2786 44 2077 2787 41 470 2073 44 2713 123 2068 2788 61 418 2068 40 433 41 59 621 621 2079 2789 61 2790 46 2791 40 433 44 418 2792 40 41 41 59 2786 46 2793 40 2794 45 62 2788 46 2795 40 2794 44 2789 41 41 59 2796 2797 61 2796 46 2798 40 2788 41 59 2797 46 2799 61 380 59 2797 46 2800 61 2800 59 2797 46 2801 61 418 2802 40 2010 46 2803 40 2345 46 2349 46 2804 41 44 2012 46 2805 40 41 41 59 2797 46 2806 61 2787 59 2797 46 2807 61 2077 46 2808 59 2797 46 2809 61 380 59 2797 46 2810 61 2789 59 2811 46 2812 40 2797 41 59 450 2788 46 2813 40 41 59 125 621 621 621 439 2054 2814 40 2054 2710 44 2054 2711 44 2077 2815 44 2077 2816 44 64 2086 2029 2817 44 64 2348 40 648 41 2345 46 2349 2350 44 64 2086 2054 2818 44 2819 60 2068 62 2820 41 470 2713 44 2714 44 2073 123 2821 2822 61 2823 40 2710 44 2711 44 2815 44 2816 44 2817 44 2350 41 59 2824 46 2825 2826 61 2827 46 2828 40 2822 41 59 2829 46 2830 40 2826 46 2831 44 2820 44 2832 46 2833 40 41 41 59 392 40 2818 631 424 41 123 2826 46 2228 46 2834 40 2818 41 59 125 621 621 2835 46 2836 40 2826 46 2228 41 59 450 2826 46 2228 46 2837 40 41 46 2838 40 41 59 125 439 2068 2839 40 2738 60 2054 62 2739 44 2054 2711 44 2077 2815 44 2077 2816 44 64 2086 2054 2840 44 64 2086 2029 2817 44 64 2086 2054 2818 44 2819 60 2068 62 2820 41 470 2713 44 2714 44 2073 123 2841 2842 61 2843 40 2739 44 2711 44 2815 44 2816 44 2840 44 2817 41 59 2844 46 2845 2846 61 2847 46 2848 40 2842 41 59 2849 46 2850 40 2846 46 2851 44 2820 44 2852 46 2853 40 41 41 59 392 40 2818 631 424 41 123 2846 46 2228 46 2854 40 2818 41 59 125 2855 40 648 44 2846 46 2228 41 59 621 621 2856 46 2857 40 2846 46 2228 41 59 450 2846 46 2228 59 125 437 2858 2859 40 2054 2710 44 2054 2711 44 2077 2712 44 2077 2816 44 64 2086 2029 2817 44 2345 46 2349 2350 41 470 2713 44 2714 123 2068 2228 61 418 2068 40 433 41 59 381 2077 2815 61 2712 46 2860 40 2816 41 59 2861 46 2862 40 2863 46 2864 40 2815 41 44 648 41 59 2228 46 2865 40 2815 44 2079 46 2866 40 433 44 2711 41 41 59 2858 2867 61 2858 46 2868 40 2228 41 59 2867 46 2816 61 2816 59 2867 46 2869 61 2077 46 2870 59 2867 46 2871 61 380 59 2867 46 2817 61 2817 59 2867 46 2872 61 380 59 2344 60 2345 62 2423 61 2442 40 2710 44 2350 41 59 392 40 33 2423 46 2873 40 41 41 469 418 2714 40 648 41 59 2874 40 2423 46 2875 40 41 44 648 41 59 2874 40 2423 46 2875 40 41 46 2876 40 41 44 648 41 59 2867 46 2877 61 418 2878 40 2423 46 2875 40 41 46 2876 40 41 44 2012 46 2879 40 41 41 59 2867 46 2840 61 2423 46 2875 40 41 46 2876 40 41 59 450 2867 59 125 437 2858 2880 40 2738 60 2054 62 2739 44 2054 2711 44 2077 2712 44 2077 2816 44 64 2086 2054 2840 44 64 2086 2029 2817 41 470 2713 44 2714 123 2068 2228 61 418 2068 40 433 41 59 381 2077 2881 61 2712 46 2882 40 2816 41 59 2883 40 2884 46 2885 40 2881 41 44 648 41 59 2228 46 2886 40 2881 44 2079 46 2887 40 433 44 2711 41 41 59 2858 2888 61 2858 46 2889 40 2228 41 59 2888 46 2816 61 2816 59 2888 46 2890 61 2077 46 2891 59 2888 46 2892 61 380 59 2888 46 2817 61 2817 59 2888 46 2893 61 380 59 2738 60 2345 62 2894 61 2739 46 2895 40 41 46 2896 40 2417 45 62 123 2344 60 2345 62 2897 61 2442 40 2417 44 2345 46 2349 46 2898 41 59 392 40 33 2897 46 2899 40 41 41 2897 61 2442 40 2417 44 2345 46 2349 46 2900 41 59 392 40 33 2897 46 2899 40 41 41 2897 61 2442 40 2417 44 2345 46 2349 46 2901 41 59 392 40 33 2897 46 2899 40 41 41 2897 61 2442 40 2417 44 2345 46 2349 46 2902 41 59 450 2897 59 125 41 46 2903 40 2344 58 58 2895 41 46 2904 40 2905 46 2906 40 41 41 59 392 40 2894 46 2907 40 41 41 469 418 2714 40 648 41 59 2888 46 2908 61 418 2909 40 2010 46 2910 40 2894 41 44 2012 46 2911 40 41 41 59 2344 60 2345 62 2912 61 2344 46 362 40 41 59 392 40 2840 631 424 41 2912 61 2442 40 2840 44 2345 46 2349 46 2913 41 59 2345 2914 61 2912 46 2915 40 467 58 58 2398 41 59 2916 40 2914 44 648 41 59 2888 46 2840 61 2914 46 2917 40 41 59 450 2888 59 125 621 621 621 64 2026 438 324 2918 40 2919 2920 41 123 450 2920 46 2921 40 41 46 2515 60 2012 46 2922 40 41 59 125 621 621 621 439 2068 2923 40 2077 2924 44 2077 2925 44 2077 2816 44 2054 2926 44 2054 2927 41 470 2713 44 2073 44 2072 44 2074 123 2068 2228 61 418 2068 40 433 41 59 2928 46 2929 40 2924 46 2930 40 2925 41 46 2931 40 41 44 648 41 59 621 392 40 2924 46 2931 40 41 41 123 2928 46 2929 40 2932 46 2933 40 2924 41 44 648 41 59 2228 46 2934 40 2924 44 2079 46 2935 40 433 44 2926 41 41 59 125 621 392 40 2925 46 2931 40 41 41 123 2928 46 2929 40 2936 46 2937 40 2925 41 44 648 41 59 2228 46 2938 40 2925 44 2079 46 2939 40 433 44 2927 41 41 59 125 2858 2940 61 2858 46 2941 40 2228 41 59 2940 46 2816 61 2816 59 2940 46 2942 61 2077 46 2943 59 2940 46 2944 61 380 59 2940 46 2817 61 2817 59 2940 46 2945 61 380 59 2940 46 2946 61 418 2947 40 2010 46 2948 40 2345 46 2349 46 2949 41 44 2012 46 2950 40 41 41 59 2940 46 2840 61 2398 40 41 46 2951 40 41 59 2952 40 2953 41 59 2953 46 2954 40 2940 41 59 2068 2955 61 2940 46 2228 59 2956 40 2953 41 59 2957 40 2955 41 59 2001 46 2958 40 648 44 2955 41 59 450 2955 59 125 621 621 621 439 2325 60 2451 60 2959 62 44 2077 62 2960 40 2077 2961 41 470 2073 123 2962 2963 61 418 2962 40 2010 46 2964 40 2345 46 2349 46 2965 41 44 2012 46 2966 40 41 41 59 2967 2968 61 2963 46 2969 40 2961 44 2970 46 2971 40 2972 41 46 2973 40 41 41 59 2077 2974 59 474 123 2974 61 2963 46 2975 40 2961 44 2968 41 59 125 329 40 2073 2976 41 123 2003 46 371 40 648 44 2976 46 2977 41 59 469 418 2073 40 2976 46 2977 41 59 125 2068 2978 61 418 2068 40 433 41 59 2968 46 2979 46 2980 40 2978 58 58 2981 41 59 2451 60 2959 62 2982 61 2978 46 2983 40 41 46 2984 40 41 46 2985 40 2959 58 58 418 41 46 2986 40 2987 46 2988 40 41 41 59 450 418 2325 60 62 40 2982 44 2974 41 59 125 125 
2594,Java,"@RunWith(Parameterized.class)
public class OpenSetsTest {

    private final int size;

    public OpenSetsTest(int size) {
        this.size = size;
    }

    @Parameterized.Parameters
    public static Collection<Object[]> data() {
        ArrayList<Object[]> testSizes = new ArrayList<>();
        for (int size = 1; size < 20; size++) {
            testSizes.add(new Object[]{size});
        }
        for (int size = 100; size <= 1000; size += 100) {
            testSizes.add(new Object[]{size});
        }
        testSizes.add(new Object[]{5000});
        testSizes.add(new Object[]{10000});
        return testSizes;
    }

    private static void removeAndTest(int amount, IOpenSet[] test, Collection<PathNode> mustContain) {
        double[][] results = new double[test.length][amount];
        for (int i = 0; i < test.length; i++) {
            long before = System.nanoTime() / 1000000L;
            for (int j = 0; j < amount; j++) {
                PathNode pn = test[i].removeLowest();
                if (mustContain != null && !mustContain.contains(pn)) {
                    throw new IllegalStateException(mustContain + "" "" + pn);
                }
                results[i][j] = pn.combinedCost;
            }
            System.out.println(test[i].getClass() + "" "" + (System.nanoTime() / 1000000L - before));
        }
        for (int j = 0; j < amount; j++) {
            for (int i = 1; i < test.length; i++) {
                assertEquals(results[i][j], results[0][j], 0);
            }
        }
        for (int i = 0; i < amount - 1; i++) {
            assertTrue(results[0][i] < results[0][i + 1]);
        }
    }

    @Test
    public void testSize() {
        System.out.println(""Testing size "" + size);
        // Include LinkedListOpenSet even though it's not performant because I absolutely trust that it behaves properly
        // I'm really testing the heap implementations against it as the ground truth
        IOpenSet[] test = new IOpenSet[]{new BinaryHeapOpenSet(), new LinkedListOpenSet()};
        for (IOpenSet set : test) {
            assertTrue(set.isEmpty());
        }

        // generate the pathnodes that we'll be testing the sets on
        PathNode[] toInsert = new PathNode[size];
        for (int i = 0; i < size; i++) {
            // can't use an existing goal
            // because they use Baritone.settings()
            // and we can't do that because Minecraft itself isn't initted
            PathNode pn = new PathNode(0, 0, 0, new Goal() {
                @Override
                public boolean isInGoal(int x, int y, int z) {
                    return false;
                }

                @Override
                public double heuristic(int x, int y, int z) {
                    return 0;
                }
            });
            pn.combinedCost = Math.random();
            toInsert[i] = pn;
        }

        // create a list of what the first removals should be
        ArrayList<PathNode> copy = new ArrayList<>(Arrays.asList(toInsert));
        copy.sort(Comparator.comparingDouble(pn -> pn.combinedCost));
        Set<PathNode> lowestQuarter = new HashSet<>(copy.subList(0, size / 4));

        // all opensets should be empty; nothing has been inserted yet
        for (IOpenSet set : test) {
            assertTrue(set.isEmpty());
        }

        System.out.println(""Insertion"");
        for (IOpenSet set : test) {
            long before = System.nanoTime() / 1000000L;
            for (int i = 0; i < size; i++)
                set.insert(toInsert[i]);
            System.out.println(set.getClass() + "" "" + (System.nanoTime() / 1000000L - before));
            //all three take either 0 or 1ms to insert up to 10,000 nodes
            //linkedlist takes 0ms most often (because there's no array resizing or allocation there, just pointer shuffling)
        }

        // all opensets should now be full
        for (IOpenSet set : test) {
            assertFalse(set.isEmpty());
        }

        System.out.println(""Removal round 1"");
        // remove a quarter of the nodes and verify that they are indeed the size/4 lowest ones
        removeAndTest(size / 4, test, lowestQuarter);

        // none of them should be empty (sanity check)
        for (IOpenSet set : test) {
            assertFalse(set.isEmpty());
        }
        int cnt = 0;
        for (int i = 0; cnt < size / 2 && i < size; i++) {
            if (lowestQuarter.contains(toInsert[i])) { // these were already removed and can't be updated to test
                continue;
            }
            toInsert[i].combinedCost *= Math.random();
            // multiplying it by a random number between 0 and 1 is guaranteed to decrease it
            for (IOpenSet set : test) {
                // it's difficult to benchmark these individually because if you modify all at once then update then
                // it breaks the internal consistency of the heaps.
                // you have to call update every time you modify a node.
                set.update(toInsert[i]);
            }
            cnt++;
        }

        //still shouldn't be empty
        for (IOpenSet set : test) {
            assertFalse(set.isEmpty());
        }

        System.out.println(""Removal round 2"");
        // remove the remaining 3/4
        removeAndTest(size - size / 4, test, null);

        // every set should now be empty
        for (IOpenSet set : test) {
            assertTrue(set.isEmpty());
        }
    }
}",1,64 2000 40 2001 46 334 41 439 334 2002 123 437 381 404 2003 59 439 2002 40 404 2003 41 123 467 46 2003 61 2003 59 125 64 2001 46 2004 439 457 2005 60 2006 91 93 62 2007 40 41 123 2008 60 2006 91 93 62 2009 61 418 2008 60 62 40 41 59 385 40 404 2003 61 1501 59 2003 60 1503 59 2003 637 41 123 2009 46 2010 40 418 2006 91 93 123 2003 125 41 59 125 385 40 404 2003 61 1503 59 2003 620 1504 59 2003 636 1503 41 123 2009 46 2011 40 418 2006 91 93 123 2003 125 41 59 125 2009 46 2012 40 418 2006 91 93 123 1505 125 41 59 2009 46 2012 40 418 2006 91 93 123 1505 125 41 59 450 2009 59 125 437 457 492 2013 40 404 2014 44 2015 91 93 2016 44 2005 60 2017 62 2018 41 123 356 91 93 91 93 2019 61 418 356 91 2016 46 2020 93 91 2014 93 59 385 40 404 2021 61 1500 59 2021 60 2016 46 2020 59 2021 637 41 123 413 2022 61 2023 46 2024 40 41 47 1507 59 385 40 404 2025 61 1500 59 2025 60 2014 59 2025 637 41 123 2017 2026 61 2016 91 2021 93 46 2027 40 41 59 392 40 2018 631 424 605 33 2018 46 2028 40 2026 41 41 123 469 418 2029 40 2018 43 648 43 2026 41 59 125 2019 91 2021 93 91 2025 93 61 2026 46 2030 59 125 2023 46 430 46 2031 40 2016 91 2021 93 46 2032 40 41 43 648 43 40 2023 46 2024 40 41 47 1507 45 2022 41 41 59 125 385 40 404 2033 61 1500 59 2033 60 2014 59 2033 637 41 123 385 40 404 2021 61 1501 59 2021 60 2016 46 2020 59 2021 637 41 123 2034 40 2019 91 2021 93 91 2033 93 44 2019 91 1500 93 91 2033 93 44 1500 41 59 125 125 385 40 404 2021 61 1500 59 2021 60 2014 45 1501 59 2021 637 41 123 2035 40 2019 91 1500 93 91 2021 93 60 2019 91 1500 93 91 2021 43 1501 93 41 59 125 125 64 2036 439 492 2037 40 41 123 2038 46 430 46 2039 40 648 43 2003 41 59 621 621 2015 91 93 2016 61 418 2015 91 93 123 418 2040 40 41 44 418 2041 40 41 125 59 385 40 2015 2042 58 2016 41 123 2043 40 2042 46 2044 40 41 41 59 125 621 2017 91 93 2045 61 418 2017 91 2003 93 59 385 40 404 2046 61 1500 59 2046 60 2003 59 2046 637 41 123 621 621 621 2017 2047 61 418 2017 40 1500 44 1500 44 1500 44 418 2048 40 41 123 64 2049 439 324 2050 40 404 2051 44 404 2052 44 404 2053 41 123 450 380 59 125 64 2049 439 356 2054 40 404 2051 44 404 2052 44 404 2053 41 123 450 1500 59 125 125 41 59 2047 46 2055 61 2056 46 2057 40 41 59 2045 91 2046 93 61 2047 59 125 621 2058 60 2017 62 2059 61 418 2058 60 62 40 2060 46 2061 40 2045 41 41 59 2059 46 2062 40 2063 46 2064 40 2065 45 62 2065 46 2066 41 41 59 2067 60 2017 62 2068 61 418 2069 60 62 40 2059 46 2070 40 1500 44 2003 47 1502 41 41 59 621 385 40 2015 2042 58 2016 41 123 2071 40 2042 46 2072 40 41 41 59 125 2038 46 430 46 2039 40 648 41 59 385 40 2015 2042 58 2016 41 123 413 2073 61 2038 46 2074 40 41 47 1507 59 385 40 404 2046 61 1500 59 2046 60 2003 59 2046 637 41 2042 46 2075 40 2045 91 2046 93 41 59 2038 46 430 46 2039 40 2042 46 2076 40 41 43 648 43 40 2038 46 2074 40 41 47 1507 45 2073 41 41 59 621 621 125 621 385 40 2015 2042 58 2016 41 123 2077 40 2042 46 2078 40 41 41 59 125 2038 46 430 46 2039 40 648 41 59 621 2013 40 2003 47 1502 44 2016 44 2068 41 59 621 385 40 2015 2042 58 2016 41 123 2079 40 2042 46 2080 40 41 41 59 125 404 2081 61 1500 59 385 40 404 2046 61 1500 59 2081 60 2003 47 1502 605 2046 60 2003 59 2046 637 41 123 392 40 2068 46 2082 40 2045 91 2046 93 41 41 123 621 344 59 125 2045 91 2046 93 46 2066 649 2083 46 2084 40 41 59 621 385 40 2015 2042 58 2016 41 123 621 621 621 2042 46 2085 40 2045 91 2046 93 41 59 125 2081 637 59 125 621 385 40 2015 2042 58 2016 41 123 2086 40 2042 46 2087 40 41 41 59 125 2038 46 430 46 2039 40 648 41 59 621 2013 40 2003 45 2003 47 1502 44 2016 44 424 41 59 621 385 40 2015 2042 58 2016 41 123 2088 40 2042 46 2089 40 41 41 59 125 125 125 
17755,Java,"public class ChunkSampleStream<T extends ChunkSource>
    implements SampleStream, SequenceableLoader, Loader.Callback<Chunk>, Loader.ReleaseCallback {

  /** A callback to be notified when a sample stream has finished being released. */
  public interface ReleaseCallback<T extends ChunkSource> {

    /**
     * Called when the {@link ChunkSampleStream} has finished being released.
     *
     * @param chunkSampleStream The released sample stream.
     */
    void onSampleStreamReleased(ChunkSampleStream<T> chunkSampleStream);
  }

  private static final String TAG = ""ChunkSampleStream"";

  public final @C.TrackType int primaryTrackType;

  private final int[] embeddedTrackTypes;
  private final Format[] embeddedTrackFormats;
  private final boolean[] embeddedTracksSelected;
  private final T chunkSource;
  private final SequenceableLoader.Callback<ChunkSampleStream<T>> callback;
  private final MediaSourceEventListener.EventDispatcher mediaSourceEventDispatcher;
  private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
  private final Loader loader;
  private final ChunkHolder nextChunkHolder;
  private final ArrayList<BaseMediaChunk> mediaChunks;
  private final List<BaseMediaChunk> readOnlyMediaChunks;
  private final SampleQueue primarySampleQueue;
  private final SampleQueue[] embeddedSampleQueues;
  private final BaseMediaChunkOutput chunkOutput;

  @Nullable private Chunk loadingChunk;
  private @MonotonicNonNull Format primaryDownstreamTrackFormat;
  @Nullable private ReleaseCallback<T> releaseCallback;
  private long pendingResetPositionUs;
  private long lastSeekPositionUs;
  private int nextNotifyPrimaryFormatMediaChunkIndex;
  @Nullable private BaseMediaChunk canceledMediaChunk;

  /* package */ boolean loadingFinished;

  /**
   * Constructs an instance.
   *
   * @param primaryTrackType The {@link C.TrackType type} of the primary track.
   * @param embeddedTrackTypes The types of any embedded tracks, or null.
   * @param embeddedTrackFormats The formats of the embedded tracks, or null.
   * @param chunkSource A {@link ChunkSource} from which chunks to load are obtained.
   * @param callback An {@link Callback} for the stream.
   * @param allocator An {@link Allocator} from which allocations can be obtained.
   * @param positionUs The position from which to start loading media.
   * @param drmSessionManager The {@link DrmSessionManager} to obtain {@link DrmSession DrmSessions}
   *     from.
   * @param drmEventDispatcher A dispatcher to notify of {@link DrmSessionEventListener} events.
   * @param loadErrorHandlingPolicy The {@link LoadErrorHandlingPolicy}.
   * @param mediaSourceEventDispatcher A dispatcher to notify of {@link MediaSourceEventListener}
   *     events.
   */
  public ChunkSampleStream(
      @C.TrackType int primaryTrackType,
      @Nullable int[] embeddedTrackTypes,
      @Nullable Format[] embeddedTrackFormats,
      T chunkSource,
      Callback<ChunkSampleStream<T>> callback,
      Allocator allocator,
      long positionUs,
      DrmSessionManager drmSessionManager,
      DrmSessionEventListener.EventDispatcher drmEventDispatcher,
      LoadErrorHandlingPolicy loadErrorHandlingPolicy,
      MediaSourceEventListener.EventDispatcher mediaSourceEventDispatcher) {
    this.primaryTrackType = primaryTrackType;
    this.embeddedTrackTypes = embeddedTrackTypes == null ? new int[0] : embeddedTrackTypes;
    this.embeddedTrackFormats = embeddedTrackFormats == null ? new Format[0] : embeddedTrackFormats;
    this.chunkSource = chunkSource;
    this.callback = callback;
    this.mediaSourceEventDispatcher = mediaSourceEventDispatcher;
    this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
    loader = new Loader(""ChunkSampleStream"");
    nextChunkHolder = new ChunkHolder();
    mediaChunks = new ArrayList<>();
    readOnlyMediaChunks = Collections.unmodifiableList(mediaChunks);

    int embeddedTrackCount = this.embeddedTrackTypes.length;
    embeddedSampleQueues = new SampleQueue[embeddedTrackCount];
    embeddedTracksSelected = new boolean[embeddedTrackCount];
    int[] trackTypes = new int[1 + embeddedTrackCount];
    SampleQueue[] sampleQueues = new SampleQueue[1 + embeddedTrackCount];

    primarySampleQueue =
        SampleQueue.createWithDrm(
            allocator,
            /* playbackLooper= */ checkNotNull(Looper.myLooper()),
            drmSessionManager,
            drmEventDispatcher);
    trackTypes[0] = primaryTrackType;
    sampleQueues[0] = primarySampleQueue;

    for (int i = 0; i < embeddedTrackCount; i++) {
      SampleQueue sampleQueue = SampleQueue.createWithoutDrm(allocator);
      embeddedSampleQueues[i] = sampleQueue;
      sampleQueues[i + 1] = sampleQueue;
      trackTypes[i + 1] = this.embeddedTrackTypes[i];
    }

    chunkOutput = new BaseMediaChunkOutput(trackTypes, sampleQueues);
    pendingResetPositionUs = positionUs;
    lastSeekPositionUs = positionUs;
  }

  /**
   * Discards buffered media up to the specified position.
   *
   * @param positionUs The position to discard up to, in microseconds.
   * @param toKeyframe If true then for each track discards samples up to the keyframe before or at
   *     the specified position, rather than any sample before or at that position.
   */
  public void discardBuffer(long positionUs, boolean toKeyframe) {
    if (isPendingReset()) {
      return;
    }
    int oldFirstSampleIndex = primarySampleQueue.getFirstIndex();
    primarySampleQueue.discardTo(positionUs, toKeyframe, true);
    int newFirstSampleIndex = primarySampleQueue.getFirstIndex();
    if (newFirstSampleIndex > oldFirstSampleIndex) {
      long discardToUs = primarySampleQueue.getFirstTimestampUs();
      for (int i = 0; i < embeddedSampleQueues.length; i++) {
        embeddedSampleQueues[i].discardTo(discardToUs, toKeyframe, embeddedTracksSelected[i]);
      }
    }
    discardDownstreamMediaChunks(newFirstSampleIndex);
  }

  /**
   * Selects the embedded track, returning a new {@link EmbeddedSampleStream} from which the track's
   * samples can be consumed. {@link EmbeddedSampleStream#release()} must be called on the returned
   * stream when the track is no longer required, and before calling this method again to obtain
   * another stream for the same track.
   *
   * @param positionUs The current playback position in microseconds.
   * @param trackType The type of the embedded track to enable.
   * @return The {@link EmbeddedSampleStream} for the embedded track.
   */
  public EmbeddedSampleStream selectEmbeddedTrack(long positionUs, int trackType) {
    for (int i = 0; i < embeddedSampleQueues.length; i++) {
      if (embeddedTrackTypes[i] == trackType) {
        Assertions.checkState(!embeddedTracksSelected[i]);
        embeddedTracksSelected[i] = true;
        embeddedSampleQueues[i].seekTo(positionUs, /* allowTimeBeyondBuffer= */ true);
        return new EmbeddedSampleStream(this, embeddedSampleQueues[i], i);
      }
    }
    // Should never happen.
    throw new IllegalStateException();
  }

  /** Returns the {@link ChunkSource} used by this stream. */
  public T getChunkSource() {
    return chunkSource;
  }

  /**
   * Returns an estimate of the position up to which data is buffered.
   *
   * @return An estimate of the absolute position in microseconds up to which data is buffered, or
   *     {@link C#TIME_END_OF_SOURCE} if the track is fully buffered.
   */
  @Override
  public long getBufferedPositionUs() {
    if (loadingFinished) {
      return C.TIME_END_OF_SOURCE;
    } else if (isPendingReset()) {
      return pendingResetPositionUs;
    } else {
      long bufferedPositionUs = lastSeekPositionUs;
      BaseMediaChunk lastMediaChunk = getLastMediaChunk();
      BaseMediaChunk lastCompletedMediaChunk =
          lastMediaChunk.isLoadCompleted()
              ? lastMediaChunk
              : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;
      if (lastCompletedMediaChunk != null) {
        bufferedPositionUs = max(bufferedPositionUs, lastCompletedMediaChunk.endTimeUs);
      }
      return max(bufferedPositionUs, primarySampleQueue.getLargestQueuedTimestampUs());
    }
  }

  /**
   * Adjusts a seek position given the specified {@link SeekParameters}. Chunk boundaries are used
   * as sync points.
   *
   * @param positionUs The seek position in microseconds.
   * @param seekParameters Parameters that control how the seek is performed.
   * @return The adjusted seek position, in microseconds.
   */
  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
    return chunkSource.getAdjustedSeekPositionUs(positionUs, seekParameters);
  }

  /**
   * Seeks to the specified position in microseconds.
   *
   * @param positionUs The seek position in microseconds.
   */
  public void seekToUs(long positionUs) {
    lastSeekPositionUs = positionUs;
    if (isPendingReset()) {
      // A reset is already pending. We only need to update its position.
      pendingResetPositionUs = positionUs;
      return;
    }

    // Detect whether the seek is to the start of a chunk that's at least partially buffered.
    @Nullable BaseMediaChunk seekToMediaChunk = null;
    for (int i = 0; i < mediaChunks.size(); i++) {
      BaseMediaChunk mediaChunk = mediaChunks.get(i);
      long mediaChunkStartTimeUs = mediaChunk.startTimeUs;
      if (mediaChunkStartTimeUs == positionUs && mediaChunk.clippedStartTimeUs == C.TIME_UNSET) {
        seekToMediaChunk = mediaChunk;
        break;
      } else if (mediaChunkStartTimeUs > positionUs) {
        // We're not going to find a chunk with a matching start time.
        break;
      }
    }

    // See if we can seek inside the primary sample queue.
    boolean seekInsideBuffer;
    if (seekToMediaChunk != null) {
      // When seeking to the start of a chunk we use the index of the first sample in the chunk
      // rather than the seek position. This ensures we seek to the keyframe at the start of the
      // chunk even if its timestamp is slightly earlier than the advertised chunk start time.
      seekInsideBuffer = primarySampleQueue.seekTo(seekToMediaChunk.getFirstSampleIndex(0));
    } else {
      seekInsideBuffer =
          primarySampleQueue.seekTo(
              positionUs, /* allowTimeBeyondBuffer= */ positionUs < getNextLoadPositionUs());
    }

    if (seekInsideBuffer) {
      // We can seek inside the buffer.
      nextNotifyPrimaryFormatMediaChunkIndex =
          primarySampleIndexToMediaChunkIndex(
              primarySampleQueue.getReadIndex(), /* minChunkIndex= */ 0);
      // Seek the embedded sample queues.
      for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
        embeddedSampleQueue.seekTo(positionUs, /* allowTimeBeyondBuffer= */ true);
      }
    } else {
      // We can't seek inside the buffer, and so need to reset.
      pendingResetPositionUs = positionUs;
      loadingFinished = false;
      mediaChunks.clear();
      nextNotifyPrimaryFormatMediaChunkIndex = 0;
      if (loader.isLoading()) {
        // Discard as much as we can synchronously.
        primarySampleQueue.discardToEnd();
        for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
          embeddedSampleQueue.discardToEnd();
        }
        loader.cancelLoading();
      } else {
        loader.clearFatalError();
        resetSampleQueues();
      }
    }
  }

  /**
   * Releases the stream.
   *
   * <p>This method should be called when the stream is no longer required. Either this method or
   * {@link #release(ReleaseCallback)} can be used to release this stream.
   */
  public void release() {
    release(null);
  }

  /**
   * Releases the stream.
   *
   * <p>This method should be called when the stream is no longer required. Either this method or
   * {@link #release()} can be used to release this stream.
   *
   * @param callback An optional callback to be called on the loading thread once the loader has
   *     been released.
   */
  public void release(@Nullable ReleaseCallback<T> callback) {
    this.releaseCallback = callback;
    // Discard as much as we can synchronously.
    primarySampleQueue.preRelease();
    for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
      embeddedSampleQueue.preRelease();
    }
    loader.release(this);
  }

  @Override
  public void onLoaderReleased() {
    primarySampleQueue.release();
    for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
      embeddedSampleQueue.release();
    }
    chunkSource.release();
    if (releaseCallback != null) {
      releaseCallback.onSampleStreamReleased(this);
    }
  }

  // SampleStream implementation.

  @Override
  public boolean isReady() {
    return !isPendingReset() && primarySampleQueue.isReady(loadingFinished);
  }

  @Override
  public void maybeThrowError() throws IOException {
    loader.maybeThrowError();
    primarySampleQueue.maybeThrowError();
    if (!loader.isLoading()) {
      chunkSource.maybeThrowError();
    }
  }

  @Override
  public int readData(
      FormatHolder formatHolder, DecoderInputBuffer buffer, @ReadFlags int readFlags) {
    if (isPendingReset()) {
      return C.RESULT_NOTHING_READ;
    }
    if (canceledMediaChunk != null
        && canceledMediaChunk.getFirstSampleIndex(/* trackIndex= */ 0)
            <= primarySampleQueue.getReadIndex()) {
      // Don't read into chunk that's going to be discarded.
      // TODO: Support splicing to allow this. See [internal b/161130873].
      return C.RESULT_NOTHING_READ;
    }
    maybeNotifyPrimaryTrackFormatChanged();

    return primarySampleQueue.read(formatHolder, buffer, readFlags, loadingFinished);
  }

  @Override
  public int skipData(long positionUs) {
    if (isPendingReset()) {
      return 0;
    }
    int skipCount = primarySampleQueue.getSkipCount(positionUs, loadingFinished);
    if (canceledMediaChunk != null) {
      // Don't skip into chunk that's going to be discarded.
      // TODO: Support splicing to allow this. See [internal b/161130873].
      int maxSkipCount =
          canceledMediaChunk.getFirstSampleIndex(/* trackIndex= */ 0)
              - primarySampleQueue.getReadIndex();
      skipCount = min(skipCount, maxSkipCount);
    }
    primarySampleQueue.skip(skipCount);
    maybeNotifyPrimaryTrackFormatChanged();
    return skipCount;
  }

  // Loader.Callback implementation.

  @Override
  public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
    loadingChunk = null;
    chunkSource.onChunkLoadCompleted(loadable);
    LoadEventInfo loadEventInfo =
        new LoadEventInfo(
            loadable.loadTaskId,
            loadable.dataSpec,
            loadable.getUri(),
            loadable.getResponseHeaders(),
            elapsedRealtimeMs,
            loadDurationMs,
            loadable.bytesLoaded());
    loadErrorHandlingPolicy.onLoadTaskConcluded(loadable.loadTaskId);
    mediaSourceEventDispatcher.loadCompleted(
        loadEventInfo,
        loadable.type,
        primaryTrackType,
        loadable.trackFormat,
        loadable.trackSelectionReason,
        loadable.trackSelectionData,
        loadable.startTimeUs,
        loadable.endTimeUs);
    callback.onContinueLoadingRequested(this);
  }

  @Override
  public void onLoadCanceled(
      Chunk loadable, long elapsedRealtimeMs, long loadDurationMs, boolean released) {
    loadingChunk = null;
    canceledMediaChunk = null;
    LoadEventInfo loadEventInfo =
        new LoadEventInfo(
            loadable.loadTaskId,
            loadable.dataSpec,
            loadable.getUri(),
            loadable.getResponseHeaders(),
            elapsedRealtimeMs,
            loadDurationMs,
            loadable.bytesLoaded());
    loadErrorHandlingPolicy.onLoadTaskConcluded(loadable.loadTaskId);
    mediaSourceEventDispatcher.loadCanceled(
        loadEventInfo,
        loadable.type,
        primaryTrackType,
        loadable.trackFormat,
        loadable.trackSelectionReason,
        loadable.trackSelectionData,
        loadable.startTimeUs,
        loadable.endTimeUs);
    if (!released) {
      if (isPendingReset()) {
        resetSampleQueues();
      } else if (isMediaChunk(loadable)) {
        // TODO: Support splicing to keep data from canceled chunk. See [internal b/161130873].
        discardUpstreamMediaChunksFromIndex(mediaChunks.size() - 1);
        if (mediaChunks.isEmpty()) {
          pendingResetPositionUs = lastSeekPositionUs;
        }
      }
      callback.onContinueLoadingRequested(this);
    }
  }

  @Override
  public LoadErrorAction onLoadError(
      Chunk loadable,
      long elapsedRealtimeMs,
      long loadDurationMs,
      IOException error,
      int errorCount) {
    long bytesLoaded = loadable.bytesLoaded();
    boolean isMediaChunk = isMediaChunk(loadable);
    int lastChunkIndex = mediaChunks.size() - 1;
    boolean cancelable =
        bytesLoaded == 0 || !isMediaChunk || !haveReadFromMediaChunk(lastChunkIndex);
    LoadEventInfo loadEventInfo =
        new LoadEventInfo(
            loadable.loadTaskId,
            loadable.dataSpec,
            loadable.getUri(),
            loadable.getResponseHeaders(),
            elapsedRealtimeMs,
            loadDurationMs,
            bytesLoaded);
    MediaLoadData mediaLoadData =
        new MediaLoadData(
            loadable.type,
            primaryTrackType,
            loadable.trackFormat,
            loadable.trackSelectionReason,
            loadable.trackSelectionData,
            Util.usToMs(loadable.startTimeUs),
            Util.usToMs(loadable.endTimeUs));
    LoadErrorInfo loadErrorInfo =
        new LoadErrorInfo(loadEventInfo, mediaLoadData, error, errorCount);

    @Nullable LoadErrorAction loadErrorAction = null;
    if (chunkSource.onChunkLoadError(
        loadable, cancelable, loadErrorInfo, loadErrorHandlingPolicy)) {
      if (cancelable) {
        loadErrorAction = Loader.DONT_RETRY;
        if (isMediaChunk) {
          BaseMediaChunk removed = discardUpstreamMediaChunksFromIndex(lastChunkIndex);
          Assertions.checkState(removed == loadable);
          if (mediaChunks.isEmpty()) {
            pendingResetPositionUs = lastSeekPositionUs;
          }
        }
      } else {
        Log.w(TAG, ""Ignoring attempt to cancel non-cancelable load."");
      }
    }

    if (loadErrorAction == null) {
      // The load was not cancelled. Either the load must be retried or the error propagated.
      long retryDelayMs = loadErrorHandlingPolicy.getRetryDelayMsFor(loadErrorInfo);
      loadErrorAction =
          retryDelayMs != C.TIME_UNSET
              ? Loader.createRetryAction(/* resetErrorCount= */ false, retryDelayMs)
              : Loader.DONT_RETRY_FATAL;
    }

    boolean canceled = !loadErrorAction.isRetry();
    mediaSourceEventDispatcher.loadError(
        loadEventInfo,
        loadable.type,
        primaryTrackType,
        loadable.trackFormat,
        loadable.trackSelectionReason,
        loadable.trackSelectionData,
        loadable.startTimeUs,
        loadable.endTimeUs,
        error,
        canceled);
    if (canceled) {
      loadingChunk = null;
      loadErrorHandlingPolicy.onLoadTaskConcluded(loadable.loadTaskId);
      callback.onContinueLoadingRequested(this);
    }
    return loadErrorAction;
  }

  // SequenceableLoader implementation

  @Override
  public boolean continueLoading(long positionUs) {
    if (loadingFinished || loader.isLoading() || loader.hasFatalError()) {
      return false;
    }

    boolean pendingReset = isPendingReset();
    List<BaseMediaChunk> chunkQueue;
    long loadPositionUs;
    if (pendingReset) {
      chunkQueue = Collections.emptyList();
      loadPositionUs = pendingResetPositionUs;
    } else {
      chunkQueue = readOnlyMediaChunks;
      loadPositionUs = getLastMediaChunk().endTimeUs;
    }
    chunkSource.getNextChunk(positionUs, loadPositionUs, chunkQueue, nextChunkHolder);
    boolean endOfStream = nextChunkHolder.endOfStream;
    @Nullable Chunk loadable = nextChunkHolder.chunk;
    nextChunkHolder.clear();

    if (endOfStream) {
      pendingResetPositionUs = C.TIME_UNSET;
      loadingFinished = true;
      return true;
    }

    if (loadable == null) {
      return false;
    }

    loadingChunk = loadable;
    if (isMediaChunk(loadable)) {
      BaseMediaChunk mediaChunk = (BaseMediaChunk) loadable;
      if (pendingReset) {
        // Only set the queue start times if we're not seeking to a chunk boundary. If we are
        // seeking to a chunk boundary then we want the queue to pass through all of the samples in
        // the chunk. Doing this ensures we'll always output the keyframe at the start of the chunk,
        // even if its timestamp is slightly earlier than the advertised chunk start time.
        if (mediaChunk.startTimeUs != pendingResetPositionUs) {
          primarySampleQueue.setStartTimeUs(pendingResetPositionUs);
          for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
            embeddedSampleQueue.setStartTimeUs(pendingResetPositionUs);
          }
        }
        pendingResetPositionUs = C.TIME_UNSET;
      }
      mediaChunk.init(chunkOutput);
      mediaChunks.add(mediaChunk);
    } else if (loadable instanceof InitializationChunk) {
      ((InitializationChunk) loadable).init(chunkOutput);
    }
    long elapsedRealtimeMs =
        loader.startLoading(
            loadable, this, loadErrorHandlingPolicy.getMinimumLoadableRetryCount(loadable.type));
    mediaSourceEventDispatcher.loadStarted(
        new LoadEventInfo(loadable.loadTaskId, loadable.dataSpec, elapsedRealtimeMs),
        loadable.type,
        primaryTrackType,
        loadable.trackFormat,
        loadable.trackSelectionReason,
        loadable.trackSelectionData,
        loadable.startTimeUs,
        loadable.endTimeUs);
    return true;
  }

  @Override
  public boolean isLoading() {
    return loader.isLoading();
  }

  @Override
  public long getNextLoadPositionUs() {
    if (isPendingReset()) {
      return pendingResetPositionUs;
    } else {
      return loadingFinished ? C.TIME_END_OF_SOURCE : getLastMediaChunk().endTimeUs;
    }
  }

  @Override
  public void reevaluateBuffer(long positionUs) {
    if (loader.hasFatalError() || isPendingReset()) {
      return;
    }

    if (loader.isLoading()) {
      Chunk loadingChunk = checkNotNull(this.loadingChunk);
      if (isMediaChunk(loadingChunk)
          && haveReadFromMediaChunk(/* mediaChunkIndex= */ mediaChunks.size() - 1)) {
        // Can't cancel anymore because the renderers have read from this chunk.
        return;
      }
      if (chunkSource.shouldCancelLoad(positionUs, loadingChunk, readOnlyMediaChunks)) {
        loader.cancelLoading();
        if (isMediaChunk(loadingChunk)) {
          canceledMediaChunk = (BaseMediaChunk) loadingChunk;
        }
      }
      return;
    }

    int preferredQueueSize = chunkSource.getPreferredQueueSize(positionUs, readOnlyMediaChunks);
    if (preferredQueueSize < mediaChunks.size()) {
      discardUpstream(preferredQueueSize);
    }
  }

  private void discardUpstream(int preferredQueueSize) {
    Assertions.checkState(!loader.isLoading());

    int currentQueueSize = mediaChunks.size();
    int newQueueSize = C.LENGTH_UNSET;
    for (int i = preferredQueueSize; i < currentQueueSize; i++) {
      if (!haveReadFromMediaChunk(i)) {
        // TODO: Sparse tracks (e.g. ESMG) may prevent discarding in almost all cases because it
        // means that most chunks have been read from already. See [internal b/161126666].
        newQueueSize = i;
        break;
      }
    }
    if (newQueueSize == C.LENGTH_UNSET) {
      return;
    }

    long endTimeUs = getLastMediaChunk().endTimeUs;
    BaseMediaChunk firstRemovedChunk = discardUpstreamMediaChunksFromIndex(newQueueSize);
    if (mediaChunks.isEmpty()) {
      pendingResetPositionUs = lastSeekPositionUs;
    }
    loadingFinished = false;
    mediaSourceEventDispatcher.upstreamDiscarded(
        primaryTrackType, firstRemovedChunk.startTimeUs, endTimeUs);
  }

  private boolean isMediaChunk(Chunk chunk) {
    return chunk instanceof BaseMediaChunk;
  }

  private void resetSampleQueues() {
    primarySampleQueue.reset();
    for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
      embeddedSampleQueue.reset();
    }
  }

  /** Returns whether samples have been read from media chunk at given index. */
  private boolean haveReadFromMediaChunk(int mediaChunkIndex) {
    BaseMediaChunk mediaChunk = mediaChunks.get(mediaChunkIndex);
    if (primarySampleQueue.getReadIndex() > mediaChunk.getFirstSampleIndex(0)) {
      return true;
    }
    for (int i = 0; i < embeddedSampleQueues.length; i++) {
      if (embeddedSampleQueues[i].getReadIndex() > mediaChunk.getFirstSampleIndex(i + 1)) {
        return true;
      }
    }
    return false;
  }

  /* package */ boolean isPendingReset() {
    return pendingResetPositionUs != C.TIME_UNSET;
  }

  private void discardDownstreamMediaChunks(int discardToSampleIndex) {
    int discardToMediaChunkIndex =
        primarySampleIndexToMediaChunkIndex(discardToSampleIndex, /* minChunkIndex= */ 0);
    // Don't discard any chunks that we haven't reported the primary format change for yet.
    discardToMediaChunkIndex =
        min(discardToMediaChunkIndex, nextNotifyPrimaryFormatMediaChunkIndex);
    if (discardToMediaChunkIndex > 0) {
      Util.removeRange(mediaChunks, /* fromIndex= */ 0, /* toIndex= */ discardToMediaChunkIndex);
      nextNotifyPrimaryFormatMediaChunkIndex -= discardToMediaChunkIndex;
    }
  }

  private void maybeNotifyPrimaryTrackFormatChanged() {
    int readSampleIndex = primarySampleQueue.getReadIndex();
    int notifyToMediaChunkIndex =
        primarySampleIndexToMediaChunkIndex(
            readSampleIndex, /* minChunkIndex= */ nextNotifyPrimaryFormatMediaChunkIndex - 1);
    while (nextNotifyPrimaryFormatMediaChunkIndex <= notifyToMediaChunkIndex) {
      maybeNotifyPrimaryTrackFormatChanged(nextNotifyPrimaryFormatMediaChunkIndex++);
    }
  }

  private void maybeNotifyPrimaryTrackFormatChanged(int mediaChunkReadIndex) {
    BaseMediaChunk currentChunk = mediaChunks.get(mediaChunkReadIndex);
    Format trackFormat = currentChunk.trackFormat;
    if (!trackFormat.equals(primaryDownstreamTrackFormat)) {
      mediaSourceEventDispatcher.downstreamFormatChanged(
          primaryTrackType,
          trackFormat,
          currentChunk.trackSelectionReason,
          currentChunk.trackSelectionData,
          currentChunk.startTimeUs);
    }
    primaryDownstreamTrackFormat = trackFormat;
  }

  /**
   * Returns the media chunk index corresponding to a given primary sample index.
   *
   * @param primarySampleIndex The primary sample index for which the corresponding media chunk
   *     index is required.
   * @param minChunkIndex A minimum chunk index from which to start searching, or -1 if no hint can
   *     be provided.
   * @return The index of the media chunk corresponding to the sample index, or -1 if the list of
   *     media chunks is empty, or {@code minChunkIndex} if the sample precedes the first chunk in
   *     the search (i.e. the chunk at {@code minChunkIndex}, or at index 0 if {@code minChunkIndex}
   *     is -1.
   */
  private int primarySampleIndexToMediaChunkIndex(int primarySampleIndex, int minChunkIndex) {
    for (int i = minChunkIndex + 1; i < mediaChunks.size(); i++) {
      if (mediaChunks.get(i).getFirstSampleIndex(0) > primarySampleIndex) {
        return i - 1;
      }
    }
    return mediaChunks.size() - 1;
  }

  private BaseMediaChunk getLastMediaChunk() {
    return mediaChunks.get(mediaChunks.size() - 1);
  }

  /**
   * Discard upstream media chunks from {@code chunkIndex} and corresponding samples from sample
   * queues.
   *
   * @param chunkIndex The index of the first chunk to discard.
   * @return The chunk at given index.
   */
  private BaseMediaChunk discardUpstreamMediaChunksFromIndex(int chunkIndex) {
    BaseMediaChunk firstRemovedChunk = mediaChunks.get(chunkIndex);
    Util.removeRange(mediaChunks, /* fromIndex= */ chunkIndex, /* toIndex= */ mediaChunks.size());
    nextNotifyPrimaryFormatMediaChunkIndex =
        max(nextNotifyPrimaryFormatMediaChunkIndex, mediaChunks.size());
    primarySampleQueue.discardUpstreamSamples(firstRemovedChunk.getFirstSampleIndex(0));
    for (int i = 0; i < embeddedSampleQueues.length; i++) {
      embeddedSampleQueues[i].discardUpstreamSamples(firstRemovedChunk.getFirstSampleIndex(i + 1));
    }
    return firstRemovedChunk;
  }

  /** A {@link SampleStream} embedded in a {@link ChunkSampleStream}. */
  public final class EmbeddedSampleStream implements SampleStream {

    public final ChunkSampleStream<T> parent;

    private final SampleQueue sampleQueue;
    private final int index;

    private boolean notifiedDownstreamFormat;

    public EmbeddedSampleStream(ChunkSampleStream<T> parent, SampleQueue sampleQueue, int index) {
      this.parent = parent;
      this.sampleQueue = sampleQueue;
      this.index = index;
    }

    @Override
    public boolean isReady() {
      return !isPendingReset() && sampleQueue.isReady(loadingFinished);
    }

    @Override
    public int skipData(long positionUs) {
      if (isPendingReset()) {
        return 0;
      }
      int skipCount = sampleQueue.getSkipCount(positionUs, loadingFinished);
      if (canceledMediaChunk != null) {
        // Don't skip into chunk that's going to be discarded.
        // TODO: Support splicing to allow this. See [internal b/161130873].
        int maxSkipCount =
            canceledMediaChunk.getFirstSampleIndex(/* trackIndex= */ 1 + index)
                - sampleQueue.getReadIndex();
        skipCount = min(skipCount, maxSkipCount);
      }
      sampleQueue.skip(skipCount);
      if (skipCount > 0) {
        maybeNotifyDownstreamFormat();
      }
      return skipCount;
    }

    @Override
    public void maybeThrowError() {
      // Do nothing. Errors will be thrown from the primary stream.
    }

    @Override
    public int readData(
        FormatHolder formatHolder, DecoderInputBuffer buffer, @ReadFlags int readFlags) {
      if (isPendingReset()) {
        return C.RESULT_NOTHING_READ;
      }
      if (canceledMediaChunk != null
          && canceledMediaChunk.getFirstSampleIndex(/* trackIndex= */ 1 + index)
              <= sampleQueue.getReadIndex()) {
        // Don't read into chunk that's going to be discarded.
        // TODO: Support splicing to allow this. See [internal b/161130873].
        return C.RESULT_NOTHING_READ;
      }
      maybeNotifyDownstreamFormat();
      return sampleQueue.read(formatHolder, buffer, readFlags, loadingFinished);
    }

    public void release() {
      Assertions.checkState(embeddedTracksSelected[index]);
      embeddedTracksSelected[index] = false;
    }

    private void maybeNotifyDownstreamFormat() {
      if (!notifiedDownstreamFormat) {
        mediaSourceEventDispatcher.downstreamFormatChanged(
            embeddedTrackTypes[index],
            embeddedTrackFormats[index],
            C.SELECTION_REASON_UNKNOWN,
            /* trackSelectionData= */ null,
            lastSeekPositionUs);
        notifiedDownstreamFormat = true;
      }
    }
  }
}",1,439 334 2000 60 2001 378 2002 62 395 2003 44 2004 44 2005 46 2006 60 2007 62 44 2005 46 2008 123 618 439 405 2008 60 2001 378 2002 62 123 618 492 2009 40 2000 60 2001 62 2010 41 59 125 437 457 381 2011 2012 61 648 59 439 381 64 2013 46 2014 404 2015 59 437 381 404 91 93 2016 59 437 381 2017 91 93 2018 59 437 381 324 91 93 2019 59 437 381 2001 2020 59 437 381 2004 46 2006 60 2000 60 2001 641 2021 59 437 381 2022 46 2023 2024 59 437 381 2025 2026 59 437 381 2005 2027 59 437 381 2028 2029 59 437 381 2030 60 2031 62 2032 59 437 381 2033 60 2031 62 2034 59 437 381 2035 2036 59 437 381 2035 91 93 2037 59 437 381 2038 2039 59 64 2040 437 2007 2041 59 437 64 2042 2017 2043 59 64 2040 437 2008 60 2001 62 2044 59 437 413 2045 59 437 413 2046 59 437 404 2047 59 64 2040 437 2031 2048 59 604 324 2049 59 618 439 2000 40 64 2013 46 2014 404 2015 44 64 2040 404 91 93 2016 44 64 2040 2017 91 93 2018 44 2001 2020 44 2006 60 2000 60 2001 641 2021 44 2050 2051 44 413 2052 44 2053 2054 44 2055 46 2023 2056 44 2025 2026 44 2022 46 2023 2024 41 123 467 46 2015 61 2015 59 467 46 2016 61 2016 614 424 63 418 404 91 1500 93 58 2016 59 467 46 2018 61 2018 614 424 63 418 2017 91 1500 93 58 2018 59 467 46 2020 61 2020 59 467 46 2021 61 2021 59 467 46 2024 61 2024 59 467 46 2026 61 2026 59 2027 61 418 2005 40 648 41 59 2029 61 418 2028 40 41 59 2032 61 418 2030 60 62 40 41 59 2034 61 2057 46 2058 40 2032 41 59 404 2059 61 467 46 2016 46 2060 59 2037 61 418 2035 91 2059 93 59 2019 61 418 324 91 2059 93 59 404 91 93 2061 61 418 404 91 1501 43 2059 93 59 2035 91 93 2062 61 418 2035 91 1501 43 2059 93 59 2036 61 2035 46 2063 40 2051 44 604 2064 40 2065 46 2066 40 41 41 44 2054 44 2056 41 59 2061 91 1500 93 61 2015 59 2062 91 1500 93 61 2036 59 385 40 404 2067 61 1500 59 2067 60 2059 59 2067 637 41 123 2035 2068 61 2035 46 2069 40 2051 41 59 2037 91 2067 93 61 2068 59 2062 91 2067 43 1501 93 61 2068 59 2061 91 2067 43 1501 93 61 467 46 2016 91 2067 93 59 125 2039 61 418 2038 40 2061 44 2062 41 59 2045 61 2052 59 2046 61 2052 59 125 618 439 492 2070 40 413 2052 44 324 2071 41 123 392 40 2072 40 41 41 123 450 59 125 404 2073 61 2036 46 2074 40 41 59 2036 46 2075 40 2052 44 2071 44 473 41 59 404 2076 61 2036 46 2074 40 41 59 392 40 2076 62 2073 41 123 413 2077 61 2036 46 2078 40 41 59 385 40 404 2079 61 1500 59 2079 60 2037 46 2080 59 2079 637 41 123 2037 91 2079 93 46 2075 40 2077 44 2071 44 2019 91 2079 93 41 59 125 125 2081 40 2076 41 59 125 618 439 2082 2083 40 413 2052 44 404 2084 41 123 385 40 404 2085 61 1500 59 2085 60 2037 46 2086 59 2085 637 41 123 392 40 2016 91 2085 93 614 2084 41 123 2087 46 2088 40 33 2019 91 2085 93 41 59 2019 91 2085 93 61 473 59 2037 91 2085 93 46 2089 40 2052 44 604 473 41 59 450 418 2082 40 467 44 2037 91 2085 93 44 2085 41 59 125 125 621 469 418 2090 40 41 59 125 618 439 2001 2091 40 41 123 450 2020 59 125 618 64 2092 439 413 2093 40 41 123 392 40 2049 41 123 450 2013 46 2094 59 125 360 392 40 2095 40 41 41 123 450 2045 59 125 360 123 413 2096 61 2046 59 2031 2097 61 2098 40 41 59 2031 2099 61 2097 46 2100 40 41 63 2097 58 2032 46 2101 40 41 62 1501 63 2032 46 2102 40 2032 46 2101 40 41 45 1502 41 58 424 59 392 40 2099 631 424 41 123 2096 61 2103 40 2096 44 2099 46 2104 41 59 125 450 2105 40 2096 44 2036 46 2106 40 41 41 59 125 125 618 439 413 2107 40 413 2052 44 2108 2109 41 123 450 2020 46 2107 40 2052 44 2109 41 59 125 618 439 492 2110 40 413 2052 41 123 2046 61 2052 59 392 40 2111 40 41 41 123 621 2045 61 2052 59 450 59 125 621 64 2040 2031 2112 61 424 59 385 40 404 2113 61 1500 59 2113 60 2032 46 2114 40 41 59 2113 637 41 123 2031 2115 61 2032 46 2116 40 2113 41 59 413 2117 61 2115 46 2118 59 392 40 2117 614 2052 605 2115 46 2119 614 2013 46 2120 41 123 2112 61 2115 59 325 59 125 360 392 40 2117 62 2052 41 123 621 325 59 125 125 621 324 2121 59 392 40 2112 631 424 41 123 621 621 621 2121 61 2036 46 2122 40 2112 46 2123 40 1500 41 41 59 125 360 123 2121 61 2036 46 2124 40 2052 44 604 2052 60 2125 40 41 41 59 125 392 40 2121 41 123 621 2047 61 2126 40 2036 46 2127 40 41 44 604 1500 41 59 621 385 40 2035 2128 58 2037 41 123 2128 46 2129 40 2052 44 604 473 41 59 125 125 360 123 621 2045 61 2052 59 2049 61 380 59 2032 46 2130 40 41 59 2047 61 1500 59 392 40 2027 46 2131 40 41 41 123 621 2036 46 2132 40 41 59 385 40 2035 2133 58 2037 41 123 2133 46 2132 40 41 59 125 2027 46 2134 40 41 59 125 360 123 2027 46 2135 40 41 59 2136 40 41 59 125 125 125 618 439 492 2137 40 41 123 2137 40 424 41 59 125 618 439 492 2137 40 64 2040 2008 60 2001 62 2021 41 123 467 46 2044 61 2021 59 621 2036 46 2138 40 41 59 385 40 2035 2139 58 2037 41 123 2139 46 2138 40 41 59 125 2027 46 2137 40 467 41 59 125 64 2092 439 492 2140 40 41 123 2036 46 2137 40 41 59 385 40 2035 2141 58 2037 41 123 2141 46 2137 40 41 59 125 2020 46 2137 40 41 59 392 40 2044 631 424 41 123 2044 46 2142 40 467 41 59 125 125 621 64 2092 439 324 2143 40 41 123 450 33 2144 40 41 605 2036 46 2143 40 2049 41 59 125 64 2092 439 492 2145 40 41 470 2146 123 2027 46 2145 40 41 59 2036 46 2145 40 41 59 392 40 33 2027 46 2147 40 41 41 123 2020 46 2145 40 41 59 125 125 64 2092 439 404 2148 40 2149 2150 44 2151 2152 44 64 2153 404 2154 41 123 392 40 2155 40 41 41 123 450 2013 46 2156 59 125 392 40 2048 631 424 605 2048 46 2157 40 604 1500 41 620 2036 46 2158 40 41 41 123 621 621 450 2013 46 2159 59 125 2160 40 41 59 450 2036 46 2161 40 2150 44 2152 44 2154 44 2049 41 59 125 64 2092 439 404 2162 40 413 2052 41 123 392 40 2163 40 41 41 123 450 1500 59 125 404 2164 61 2036 46 2165 40 2052 44 2049 41 59 392 40 2048 631 424 41 123 621 621 404 2166 61 2048 46 2167 40 604 1500 41 45 2036 46 2168 40 41 59 2164 61 2169 40 2164 44 2166 41 59 125 2036 46 2170 40 2164 41 59 2171 40 41 59 450 2164 59 125 621 64 2092 439 492 2172 40 2007 2173 44 413 2174 44 413 2175 41 123 2041 61 424 59 2020 46 2176 40 2173 41 59 2177 2178 61 418 2177 40 2173 46 2179 44 2173 46 2180 44 2173 46 2181 40 41 44 2173 46 2182 40 41 44 2174 44 2175 44 2173 46 2183 40 41 41 59 2026 46 2184 40 2173 46 2179 41 59 2024 46 2185 40 2178 44 2173 46 2186 44 2015 44 2173 46 2187 44 2173 46 2188 44 2173 46 2189 44 2173 46 2190 44 2173 46 2191 41 59 2021 46 2192 40 467 41 59 125 64 2092 439 492 2193 40 2007 2173 44 413 2174 44 413 2175 44 324 2194 41 123 2041 61 424 59 2048 61 424 59 2195 2196 61 418 2195 40 2173 46 2197 44 2173 46 2198 44 2173 46 2199 40 41 44 2173 46 2200 40 41 44 2174 44 2175 44 2173 46 2201 40 41 41 59 2026 46 2202 40 2173 46 2197 41 59 2024 46 2203 40 2196 44 2173 46 2204 44 2015 44 2173 46 2205 44 2173 46 2206 44 2173 46 2207 44 2173 46 2208 44 2173 46 2209 41 59 392 40 33 2194 41 123 392 40 2210 40 41 41 123 2211 40 41 59 125 360 392 40 2212 40 2173 41 41 123 621 2213 40 2032 46 2214 40 41 45 1501 41 59 392 40 2032 46 2215 40 41 41 123 2045 61 2046 59 125 125 2021 46 2216 40 467 41 59 125 125 64 2092 439 2217 2218 40 2007 2173 44 413 2174 44 413 2175 44 2146 371 44 404 2219 41 123 413 2220 61 2173 46 2220 40 41 59 324 2221 61 2221 40 2173 41 59 404 2222 61 2032 46 2223 40 41 45 1501 59 324 2224 61 2220 614 1500 606 33 2221 606 33 2225 40 2222 41 59 2226 2227 61 418 2226 40 2173 46 2228 44 2173 46 2229 44 2173 46 2230 40 41 44 2173 46 2231 40 41 44 2174 44 2175 44 2220 41 59 2232 2233 61 418 2232 40 2173 46 2234 44 2015 44 2173 46 2235 44 2173 46 2236 44 2173 46 2237 44 2238 46 2239 40 2173 46 2240 41 44 2238 46 2239 40 2173 46 2241 41 41 59 2242 2243 61 418 2242 40 2227 44 2233 44 371 44 2219 41 59 64 2040 2217 2244 61 424 59 392 40 2020 46 2245 40 2173 44 2224 44 2243 44 2026 41 41 123 392 40 2224 41 123 2244 61 2005 46 2246 59 392 40 2221 41 123 2031 2247 61 2248 40 2222 41 59 2249 46 2250 40 2247 614 2173 41 59 392 40 2032 46 2251 40 41 41 123 2045 61 2046 59 125 125 125 360 123 2252 46 2253 40 2012 44 648 41 59 125 125 392 40 2244 614 424 41 123 621 413 2254 61 2026 46 2255 40 2243 41 59 2244 61 2254 631 2013 46 2256 63 2005 46 2257 40 604 380 44 2254 41 58 2005 46 2258 59 125 324 2259 61 33 2244 46 2260 40 41 59 2024 46 2261 40 2227 44 2173 46 2234 44 2015 44 2173 46 2235 44 2173 46 2236 44 2173 46 2237 44 2173 46 2240 44 2173 46 2241 44 371 44 2259 41 59 392 40 2259 41 123 2041 61 424 59 2026 46 2262 40 2173 46 2228 41 59 2021 46 2263 40 467 41 59 125 450 2244 59 125 621 64 2092 439 324 2264 40 413 2052 41 123 392 40 2049 606 2027 46 2265 40 41 606 2027 46 2266 40 41 41 123 450 380 59 125 324 2267 61 2268 40 41 59 2033 60 2031 62 2269 59 413 2270 59 392 40 2267 41 123 2269 61 2271 46 2272 40 41 59 2270 61 2045 59 125 360 123 2269 61 2034 59 2270 61 2273 40 41 46 2274 59 125 2020 46 2275 40 2052 44 2270 44 2269 44 2029 41 59 324 2276 61 2029 46 2276 59 64 2040 2007 2173 61 2029 46 2277 59 2029 46 2278 40 41 59 392 40 2276 41 123 2045 61 2013 46 2279 59 2049 61 473 59 450 473 59 125 392 40 2173 614 424 41 123 450 380 59 125 2041 61 2173 59 392 40 2280 40 2173 41 41 123 2031 2281 61 40 2031 41 2173 59 392 40 2267 41 123 621 621 621 621 392 40 2281 46 2282 631 2045 41 123 2036 46 2283 40 2045 41 59 385 40 2035 2284 58 2037 41 123 2284 46 2283 40 2045 41 59 125 125 2045 61 2013 46 2285 59 125 2281 46 2286 40 2039 41 59 2032 46 2287 40 2281 41 59 125 360 392 40 2173 402 2288 41 123 40 40 2288 41 2173 41 46 2289 40 2039 41 59 125 413 2174 61 2027 46 2290 40 2173 44 467 44 2026 46 2291 40 2173 46 2292 41 41 59 2024 46 2293 40 418 2294 40 2173 46 2295 44 2173 46 2296 44 2174 41 44 2173 46 2292 44 2015 44 2173 46 2297 44 2173 46 2298 44 2173 46 2299 44 2173 46 2300 44 2173 46 2301 41 59 450 473 59 125 64 2092 439 324 2302 40 41 123 450 2027 46 2302 40 41 59 125 64 2092 439 413 2303 40 41 123 392 40 2304 40 41 41 123 450 2045 59 125 360 123 450 2049 63 2013 46 2305 58 2306 40 41 46 2307 59 125 125 64 2092 439 492 2308 40 413 2052 41 123 392 40 2027 46 2309 40 41 606 2310 40 41 41 123 450 59 125 392 40 2027 46 2302 40 41 41 123 2007 2041 61 2311 40 467 46 2041 41 59 392 40 2312 40 2041 41 605 2313 40 604 2032 46 2314 40 41 45 1501 41 41 123 621 450 59 125 392 40 2020 46 2315 40 2052 44 2041 44 2034 41 41 123 2027 46 2316 40 41 59 392 40 2312 40 2041 41 41 123 2048 61 40 2031 41 2041 59 125 125 450 59 125 404 2317 61 2020 46 2318 40 2052 44 2034 41 59 392 40 2317 60 2032 46 2319 40 41 41 123 2320 40 2317 41 59 125 125 437 492 2321 40 404 2322 41 123 2323 46 2324 40 33 2027 46 2302 40 41 41 59 404 2325 61 2032 46 2326 40 41 59 404 2327 61 2013 46 2328 59 385 40 404 2329 61 2322 59 2329 60 2325 59 2329 637 41 123 392 40 33 2330 40 2329 41 41 123 621 621 2327 61 2329 59 325 59 125 125 392 40 2327 614 2013 46 2328 41 123 450 59 125 413 2331 61 2332 40 41 46 2331 59 2031 2333 61 2334 40 2327 41 59 392 40 2032 46 2335 40 41 41 123 2045 61 2046 59 125 2049 61 380 59 2024 46 2336 40 2015 44 2333 46 2337 44 2331 41 59 125 437 324 2338 40 2007 2339 41 123 450 2339 402 2031 59 125 437 492 2340 40 41 123 2036 46 2341 40 41 59 385 40 2035 2342 58 2037 41 123 2342 46 2341 40 41 59 125 125 618 437 324 2343 40 404 2344 41 123 2031 2345 61 2032 46 2346 40 2344 41 59 392 40 2036 46 2347 40 41 62 2345 46 2348 40 1500 41 41 123 450 473 59 125 385 40 404 2349 61 1500 59 2349 60 2037 46 2350 59 2349 637 41 123 392 40 2037 91 2349 93 46 2347 40 41 62 2345 46 2348 40 2349 43 1501 41 41 123 450 473 59 125 125 450 380 59 125 604 324 2351 40 41 123 450 2045 631 2013 46 2352 59 125 437 492 2353 40 404 2354 41 123 404 2355 61 2356 40 2354 44 604 1500 41 59 621 2355 61 2357 40 2355 44 2047 41 59 392 40 2355 62 1500 41 123 2358 46 2359 40 2032 44 604 1500 44 604 2355 41 59 2047 628 2355 59 125 125 437 492 2360 40 41 123 404 2361 61 2036 46 2362 40 41 59 404 2363 61 2364 40 2361 44 604 2047 45 1501 41 59 496 40 2047 620 2363 41 123 2360 40 2047 637 41 59 125 125 437 492 2360 40 404 2365 41 123 2031 2366 61 2032 46 2367 40 2365 41 59 2017 2368 61 2366 46 2368 59 392 40 33 2368 46 2369 40 2043 41 41 123 2024 46 2370 40 2015 44 2368 44 2366 46 2371 44 2366 46 2372 44 2366 46 2373 41 59 125 2043 61 2368 59 125 618 437 404 2374 40 404 2375 44 404 2376 41 123 385 40 404 2377 61 2376 43 1501 59 2377 60 2032 46 2378 40 41 59 2377 637 41 123 392 40 2032 46 2379 40 2377 41 46 2380 40 1500 41 62 2375 41 123 450 2377 45 1501 59 125 125 450 2032 46 2378 40 41 45 1501 59 125 437 2031 2381 40 41 123 450 2032 46 2382 40 2032 46 2383 40 41 45 1501 41 59 125 618 437 2031 2384 40 404 2385 41 123 2031 2386 61 2032 46 2387 40 2385 41 59 2388 46 2389 40 2032 44 604 2385 44 604 2032 46 2390 40 41 41 59 2047 61 2391 40 2047 44 2032 46 2390 40 41 41 59 2036 46 2392 40 2386 46 2393 40 1500 41 41 59 385 40 404 2394 61 1500 59 2394 60 2037 46 2395 59 2394 637 41 123 2037 91 2394 93 46 2392 40 2386 46 2393 40 2394 43 1501 41 41 59 125 450 2386 59 125 618 439 381 334 2082 395 2003 123 439 381 2000 60 2001 62 2396 59 437 381 2035 2397 59 437 381 404 2398 59 437 324 2399 59 439 2082 40 2000 60 2001 62 2396 44 2035 2397 44 404 2398 41 123 467 46 2396 61 2396 59 467 46 2397 61 2397 59 467 46 2398 61 2398 59 125 64 2092 439 324 2143 40 41 123 450 33 2351 40 41 605 2397 46 2143 40 2049 41 59 125 64 2092 439 404 2162 40 413 2052 41 123 392 40 2351 40 41 41 123 450 1500 59 125 404 2400 61 2397 46 2401 40 2052 44 2049 41 59 392 40 2048 631 424 41 123 621 621 404 2402 61 2048 46 2403 40 604 1501 43 2398 41 45 2397 46 2404 40 41 59 2400 61 2405 40 2400 44 2402 41 59 125 2397 46 2406 40 2400 41 59 392 40 2400 62 1500 41 123 2407 40 41 59 125 450 2400 59 125 64 2092 439 492 2145 40 41 123 621 125 64 2092 439 404 2148 40 2149 2150 44 2151 2152 44 64 2153 404 2154 41 123 392 40 2351 40 41 41 123 450 2013 46 2408 59 125 392 40 2048 631 424 605 2048 46 2409 40 604 1501 43 2398 41 620 2397 46 2410 40 41 41 123 621 621 450 2013 46 2411 59 125 2412 40 41 59 450 2397 46 2413 40 2150 44 2152 44 2154 44 2049 41 59 125 439 492 2137 40 41 123 2414 46 2415 40 2019 91 2398 93 41 59 2019 91 2398 93 61 380 59 125 437 492 2416 40 41 123 392 40 33 2399 41 123 2024 46 2417 40 2016 91 2398 93 44 2018 91 2398 93 44 2013 46 2418 44 604 424 44 2046 41 59 2399 61 473 59 125 125 125 125 
2965,Java,"@Slf4j
@EqualsAndHashCode
@Getter
public final class Dispute implements NetworkPayload, PersistablePayload {

    public enum State {
        NEEDS_UPGRADE,
        NEW,
        OPEN,
        REOPENED,
        CLOSED;

        public static Dispute.State fromProto(protobuf.Dispute.State state) {
            return ProtoUtil.enumFromProto(Dispute.State.class, state.name());
        }

        public static protobuf.Dispute.State toProtoMessage(Dispute.State state) {
            return protobuf.Dispute.State.valueOf(state.name());
        }
    }

    private final String tradeId;
    private final String id;
    private final int traderId;
    private final boolean disputeOpenerIsBuyer;
    private final boolean disputeOpenerIsMaker;
    // PubKeyRing of trader who opened the dispute
    private final PubKeyRing traderPubKeyRing;
    private final long tradeDate;
    private final long tradePeriodEnd;
    private final Contract contract;
    @Nullable
    private final byte[] contractHash;
    @Nullable
    private final byte[] depositTxSerialized;
    @Nullable
    private final byte[] payoutTxSerialized;
    @Nullable
    private final String depositTxId;
    @Nullable
    private final String payoutTxId;
    private final String contractAsJson;
    @Nullable
    private final String makerContractSignature;
    @Nullable
    private final String takerContractSignature;
    private final PubKeyRing agentPubKeyRing; // dispute agent
    private final boolean isSupportTicket;
    private final ObservableList<ChatMessage> chatMessages = FXCollections.observableArrayList();
    // disputeResultProperty.get is Nullable!
    private final ObjectProperty<DisputeResult> disputeResultProperty = new SimpleObjectProperty<>();
    private final long openingDate;
    @Nullable
    @Setter
    private String disputePayoutTxId;
    @Setter
    // Added v1.2.0
    private SupportType supportType;
    // Only used at refundAgent so that he knows how the mediator resolved the case
    @Setter
    @Nullable
    private String mediatorsDisputeResult;
    @Setter
    @Nullable
    private String delayedPayoutTxId;

    // Added at v1.4.0
    @Setter
    @Nullable
    private String donationAddressOfDelayedPayoutTx;
    // Added at v1.6.0
    private Dispute.State disputeState = State.NEW;

    // Should be only used in emergency case if we need to add data but do not want to break backward compatibility
    // at the P2P network storage checks. The hash of the object will be used to verify if the data is valid. Any new
    // field in a class would break that hash and therefore break the storage mechanism.
    @Nullable
    @Setter
    private Map<String, String> extraDataMap;

    // We do not persist uid, it is only used by dispute agents to guarantee an uid.
    @Setter
    @Nullable
    private transient String uid;
    @Setter
    private transient long payoutTxConfirms = -1;
    @Setter
    private transient boolean payoutDone = false;

    private transient final BooleanProperty isClosedProperty = new SimpleBooleanProperty();
    private transient final IntegerProperty badgeCountProperty = new SimpleIntegerProperty();


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Dispute(long openingDate,
                   String tradeId,
                   int traderId,
                   boolean disputeOpenerIsBuyer,
                   boolean disputeOpenerIsMaker,
                   PubKeyRing traderPubKeyRing,
                   long tradeDate,
                   long tradePeriodEnd,
                   Contract contract,
                   @Nullable byte[] contractHash,
                   @Nullable byte[] depositTxSerialized,
                   @Nullable byte[] payoutTxSerialized,
                   @Nullable String depositTxId,
                   @Nullable String payoutTxId,
                   String contractAsJson,
                   @Nullable String makerContractSignature,
                   @Nullable String takerContractSignature,
                   PubKeyRing agentPubKeyRing,
                   boolean isSupportTicket,
                   SupportType supportType) {
        this.openingDate = openingDate;
        this.tradeId = tradeId;
        this.traderId = traderId;
        this.disputeOpenerIsBuyer = disputeOpenerIsBuyer;
        this.disputeOpenerIsMaker = disputeOpenerIsMaker;
        this.traderPubKeyRing = traderPubKeyRing;
        this.tradeDate = tradeDate;
        this.tradePeriodEnd = tradePeriodEnd;
        this.contract = contract;
        this.contractHash = contractHash;
        this.depositTxSerialized = depositTxSerialized;
        this.payoutTxSerialized = payoutTxSerialized;
        this.depositTxId = depositTxId;
        this.payoutTxId = payoutTxId;
        this.contractAsJson = contractAsJson;
        this.makerContractSignature = makerContractSignature;
        this.takerContractSignature = takerContractSignature;
        this.agentPubKeyRing = agentPubKeyRing;
        this.isSupportTicket = isSupportTicket;
        this.supportType = supportType;

        id = tradeId + ""_"" + traderId;
        uid = UUID.randomUUID().toString();
        refreshAlertLevel(true);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // PROTO BUFFER
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public protobuf.Dispute toProtoMessage() {
        // Needed to avoid ConcurrentModificationException
        List<ChatMessage> clonedChatMessages = new ArrayList<>(chatMessages);
        protobuf.Dispute.Builder builder = protobuf.Dispute.newBuilder()
                .setTradeId(tradeId)
                .setTraderId(traderId)
                .setDisputeOpenerIsBuyer(disputeOpenerIsBuyer)
                .setDisputeOpenerIsMaker(disputeOpenerIsMaker)
                .setTraderPubKeyRing(traderPubKeyRing.toProtoMessage())
                .setTradeDate(tradeDate)
                .setTradePeriodEnd(tradePeriodEnd)
                .setContract(contract.toProtoMessage())
                .setContractAsJson(contractAsJson)
                .setAgentPubKeyRing(agentPubKeyRing.toProtoMessage())
                .setIsSupportTicket(isSupportTicket)
                .addAllChatMessage(clonedChatMessages.stream()
                        .map(msg -> msg.toProtoNetworkEnvelope().getChatMessage())
                        .collect(Collectors.toList()))
                .setIsClosed(this.isClosed())
                .setOpeningDate(openingDate)
                .setState(Dispute.State.toProtoMessage(disputeState))
                .setId(id);

        Optional.ofNullable(contractHash).ifPresent(e -> builder.setContractHash(ByteString.copyFrom(e)));
        Optional.ofNullable(depositTxSerialized).ifPresent(e -> builder.setDepositTxSerialized(ByteString.copyFrom(e)));
        Optional.ofNullable(payoutTxSerialized).ifPresent(e -> builder.setPayoutTxSerialized(ByteString.copyFrom(e)));
        Optional.ofNullable(depositTxId).ifPresent(builder::setDepositTxId);
        Optional.ofNullable(payoutTxId).ifPresent(builder::setPayoutTxId);
        Optional.ofNullable(disputePayoutTxId).ifPresent(builder::setDisputePayoutTxId);
        Optional.ofNullable(makerContractSignature).ifPresent(builder::setMakerContractSignature);
        Optional.ofNullable(takerContractSignature).ifPresent(builder::setTakerContractSignature);
        Optional.ofNullable(disputeResultProperty.get()).ifPresent(result -> builder.setDisputeResult(disputeResultProperty.get().toProtoMessage()));
        Optional.ofNullable(supportType).ifPresent(result -> builder.setSupportType(SupportType.toProtoMessage(supportType)));
        Optional.ofNullable(mediatorsDisputeResult).ifPresent(result -> builder.setMediatorsDisputeResult(mediatorsDisputeResult));
        Optional.ofNullable(delayedPayoutTxId).ifPresent(result -> builder.setDelayedPayoutTxId(delayedPayoutTxId));
        Optional.ofNullable(donationAddressOfDelayedPayoutTx).ifPresent(result -> builder.setDonationAddressOfDelayedPayoutTx(donationAddressOfDelayedPayoutTx));
        Optional.ofNullable(getExtraDataMap()).ifPresent(builder::putAllExtraData);
        return builder.build();
    }

    public static Dispute fromProto(protobuf.Dispute proto, CoreProtoResolver coreProtoResolver) {
        Dispute dispute = new Dispute(proto.getOpeningDate(),
                proto.getTradeId(),
                proto.getTraderId(),
                proto.getDisputeOpenerIsBuyer(),
                proto.getDisputeOpenerIsMaker(),
                PubKeyRing.fromProto(proto.getTraderPubKeyRing()),
                proto.getTradeDate(),
                proto.getTradePeriodEnd(),
                Contract.fromProto(proto.getContract(), coreProtoResolver),
                ProtoUtil.byteArrayOrNullFromProto(proto.getContractHash()),
                ProtoUtil.byteArrayOrNullFromProto(proto.getDepositTxSerialized()),
                ProtoUtil.byteArrayOrNullFromProto(proto.getPayoutTxSerialized()),
                ProtoUtil.stringOrNullFromProto(proto.getDepositTxId()),
                ProtoUtil.stringOrNullFromProto(proto.getPayoutTxId()),
                proto.getContractAsJson(),
                ProtoUtil.stringOrNullFromProto(proto.getMakerContractSignature()),
                ProtoUtil.stringOrNullFromProto(proto.getTakerContractSignature()),
                PubKeyRing.fromProto(proto.getAgentPubKeyRing()),
                proto.getIsSupportTicket(),
                SupportType.fromProto(proto.getSupportType()));

        dispute.setExtraDataMap(CollectionUtils.isEmpty(proto.getExtraDataMap()) ?
                null : ExtraDataMapValidator.getValidatedExtraDataMap(proto.getExtraDataMap()));

        dispute.chatMessages.addAll(proto.getChatMessageList().stream()
                .map(ChatMessage::fromPayloadProto)
                .collect(Collectors.toList()));

        if (proto.hasDisputeResult())
            dispute.disputeResultProperty.set(DisputeResult.fromProto(proto.getDisputeResult()));
        dispute.disputePayoutTxId = ProtoUtil.stringOrNullFromProto(proto.getDisputePayoutTxId());

        String mediatorsDisputeResult = proto.getMediatorsDisputeResult();
        if (!mediatorsDisputeResult.isEmpty()) {
            dispute.setMediatorsDisputeResult(mediatorsDisputeResult);
        }

        String delayedPayoutTxId = proto.getDelayedPayoutTxId();
        if (!delayedPayoutTxId.isEmpty()) {
            dispute.setDelayedPayoutTxId(delayedPayoutTxId);
        }

        String donationAddressOfDelayedPayoutTx = proto.getDonationAddressOfDelayedPayoutTx();
        if (!donationAddressOfDelayedPayoutTx.isEmpty()) {
            dispute.setDonationAddressOfDelayedPayoutTx(donationAddressOfDelayedPayoutTx);
        }

        if (Dispute.State.fromProto(proto.getState()) == State.NEEDS_UPGRADE) {
            // old disputes did not have a state field, so choose an appropriate state:
            dispute.setState(proto.getIsClosed() ? State.CLOSED : State.OPEN);
            if (dispute.getDisputeState() == State.CLOSED) {
                // mark chat messages as read for pre-existing CLOSED disputes
                // otherwise at upgrade, all old disputes would have 1 unread chat message
                // because currently when a dispute is closed, the last chat message is not marked read
                dispute.getChatMessages().forEach(m -> m.setWasDisplayed(true));
            }
        } else {
            dispute.setState(Dispute.State.fromProto(proto.getState()));
        }

        dispute.refreshAlertLevel(true);
        return dispute;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void addAndPersistChatMessage(ChatMessage chatMessage) {
        if (!chatMessages.contains(chatMessage)) {
            chatMessages.add(chatMessage);
        } else {
            log.error(""disputeDirectMessage already exists"");
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Setters
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void setIsClosed() {
        setState(State.CLOSED);
    }

    public void reOpen() {
        setState(State.REOPENED);
    }

    public void setState(Dispute.State disputeState) {
        this.disputeState = disputeState;
        this.isClosedProperty.set(disputeState == State.CLOSED);
    }

    public void setDisputeResult(DisputeResult disputeResult) {
        disputeResultProperty.set(disputeResult);
    }

    public void setExtraData(String key, String value) {
        if (key == null || value == null) {
            return;
        }
        if (extraDataMap == null) {
            extraDataMap = new HashMap<>();
        }
        extraDataMap.put(key, value);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    ///////////////////////////////////////////////////////////////////////////////////////////

    public String getShortTradeId() {
        return Utilities.getShortId(tradeId);
    }

    public ReadOnlyBooleanProperty isClosedProperty() {
        return isClosedProperty;
    }
    public ReadOnlyIntegerProperty getBadgeCountProperty() {
        return badgeCountProperty;
    }
    public ReadOnlyObjectProperty<DisputeResult> disputeResultProperty() {
        return disputeResultProperty;
    }

    public Date getTradeDate() {
        return new Date(tradeDate);
    }

    public Date getTradePeriodEnd() {
        return new Date(tradePeriodEnd);
    }

    public Date getOpeningDate() {
        return new Date(openingDate);
    }

    public boolean isNew() {
        return this.disputeState == State.NEW;
    }

    public boolean isClosed() {
        return this.disputeState == State.CLOSED;
    }

    public void refreshAlertLevel(boolean senderFlag) {
        // if the dispute is ""new"" that is 1 alert that has to be propagated upstream
        // or if there are unread messages that is 1 alert that has to be propagated upstream
        if (isNew() || unreadMessageCount(senderFlag) > 0) {
            badgeCountProperty.setValue(1);
        } else {
            badgeCountProperty.setValue(0);
        }
    }

    public long unreadMessageCount(boolean senderFlag) {
        return chatMessages.stream()
                .filter(m -> m.isSenderIsTrader() == senderFlag || m.isSystemMessage())
                .filter(m -> !m.isWasDisplayed())
                .count();
    }

    public void setDisputeSeen(boolean senderFlag) {
        if (this.disputeState == State.NEW)
            setState(State.OPEN);
        refreshAlertLevel(senderFlag);
    }

    public void setChatMessagesSeen(boolean senderFlag) {
        getChatMessages().forEach(m -> m.setWasDisplayed(true));
        refreshAlertLevel(senderFlag);
    }

    public String getRoleString() {
        if (disputeOpenerIsMaker) {
            if (disputeOpenerIsBuyer)
                return Res.get(""support.buyerOfferer"");
            else
                return Res.get(""support.sellerOfferer"");
        } else {
            if (disputeOpenerIsBuyer)
                return Res.get(""support.buyerTaker"");
            else
                return Res.get(""support.sellerTaker"");
        }
    }

    @Override
    public String toString() {
        return ""Dispute{"" +
                ""\n     tradeId='"" + tradeId + '\'' +
                "",\n     id='"" + id + '\'' +
                "",\n     uid='"" + uid + '\'' +
                "",\n     state="" + disputeState +
                "",\n     traderId="" + traderId +
                "",\n     disputeOpenerIsBuyer="" + disputeOpenerIsBuyer +
                "",\n     disputeOpenerIsMaker="" + disputeOpenerIsMaker +
                "",\n     traderPubKeyRing="" + traderPubKeyRing +
                "",\n     tradeDate="" + tradeDate +
                "",\n     tradePeriodEnd="" + tradePeriodEnd +
                "",\n     contract="" + contract +
                "",\n     contractHash="" + Utilities.bytesAsHexString(contractHash) +
                "",\n     depositTxSerialized="" + Utilities.bytesAsHexString(depositTxSerialized) +
                "",\n     payoutTxSerialized="" + Utilities.bytesAsHexString(payoutTxSerialized) +
                "",\n     depositTxId='"" + depositTxId + '\'' +
                "",\n     payoutTxId='"" + payoutTxId + '\'' +
                "",\n     contractAsJson='"" + contractAsJson + '\'' +
                "",\n     makerContractSignature='"" + makerContractSignature + '\'' +
                "",\n     takerContractSignature='"" + takerContractSignature + '\'' +
                "",\n     agentPubKeyRing="" + agentPubKeyRing +
                "",\n     isSupportTicket="" + isSupportTicket +
                "",\n     chatMessages="" + chatMessages +
                "",\n     isClosedProperty="" + isClosedProperty +
                "",\n     disputeResultProperty="" + disputeResultProperty +
                "",\n     disputePayoutTxId='"" + disputePayoutTxId + '\'' +
                "",\n     openingDate="" + openingDate +
                "",\n     supportType="" + supportType +
                "",\n     mediatorsDisputeResult='"" + mediatorsDisputeResult + '\'' +
                "",\n     delayedPayoutTxId='"" + delayedPayoutTxId + '\'' +
                "",\n     donationAddressOfDelayedPayoutTx='"" + donationAddressOfDelayedPayoutTx + '\'' +
                ""\n}"";
    }
}",1,64 2000 64 2001 64 2002 439 381 334 2003 395 2004 44 2005 123 439 370 2006 123 2007 44 2008 44 2009 44 2010 44 2011 59 439 457 2003 46 2006 2012 40 2013 46 2003 46 2006 2014 41 123 450 2015 46 2016 40 2003 46 2006 46 334 44 2014 46 2017 40 41 41 59 125 439 457 2013 46 2003 46 2006 2018 40 2003 46 2006 2014 41 123 450 2013 46 2003 46 2006 46 2019 40 2014 46 2020 40 41 41 59 125 125 437 381 2021 2022 59 437 381 2021 2023 59 437 381 404 2024 59 437 381 324 2025 59 437 381 324 2026 59 621 437 381 2027 2028 59 437 381 413 2029 59 437 381 413 2030 59 437 381 2031 2032 59 64 2033 437 381 326 91 93 2034 59 64 2033 437 381 326 91 93 2035 59 64 2033 437 381 326 91 93 2036 59 64 2033 437 381 2021 2037 59 64 2033 437 381 2021 2038 59 437 381 2021 2039 59 64 2033 437 381 2021 2040 59 64 2033 437 381 2021 2041 59 437 381 2027 2042 59 621 437 381 324 2043 59 437 381 2044 60 2045 62 2046 61 2047 46 2048 40 41 59 621 437 381 2049 60 2050 62 2051 61 418 2052 60 62 40 41 59 437 381 413 2053 59 64 2033 64 2054 437 2021 2055 59 64 2054 621 437 2056 2057 59 621 64 2054 64 2033 437 2021 2058 59 64 2054 64 2033 437 2021 2059 59 621 64 2054 64 2033 437 2021 2060 59 621 437 2003 46 2006 2061 61 2006 46 2062 59 621 621 621 64 2033 64 2054 437 2063 60 2021 44 2021 62 2064 59 621 64 2054 64 2033 437 472 2021 2065 59 64 2054 437 472 413 2066 61 45 1501 59 64 2054 437 472 324 2067 61 380 59 437 472 381 2068 2069 61 418 2070 40 41 59 437 472 381 2071 2072 61 418 2073 40 41 59 621 621 621 439 2003 40 413 2053 44 2021 2022 44 404 2024 44 324 2025 44 324 2026 44 2027 2028 44 413 2029 44 413 2030 44 2031 2032 44 64 2033 326 91 93 2034 44 64 2033 326 91 93 2035 44 64 2033 326 91 93 2036 44 64 2033 2021 2037 44 64 2033 2021 2038 44 2021 2039 44 64 2033 2021 2040 44 64 2033 2021 2041 44 2027 2042 44 324 2043 44 2056 2057 41 123 467 46 2053 61 2053 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2025 61 2025 59 467 46 2026 61 2026 59 467 46 2028 61 2028 59 467 46 2029 61 2029 59 467 46 2030 61 2030 59 467 46 2032 61 2032 59 467 46 2034 61 2034 59 467 46 2035 61 2035 59 467 46 2036 61 2036 59 467 46 2037 61 2037 59 467 46 2038 61 2038 59 467 46 2039 61 2039 59 467 46 2040 61 2040 59 467 46 2041 61 2041 59 467 46 2042 61 2042 59 467 46 2043 61 2043 59 467 46 2057 61 2057 59 2023 61 2022 43 648 43 2024 59 2065 61 2074 46 2075 40 41 46 2076 40 41 59 2077 40 473 41 59 125 621 621 621 64 2078 439 2079 46 2003 2080 40 41 123 621 2081 60 2045 62 2082 61 418 2083 60 62 40 2046 41 59 2079 46 2003 46 2084 2085 61 2079 46 2003 46 2086 40 41 46 2087 40 2022 41 46 2088 40 2024 41 46 2089 40 2025 41 46 2090 40 2026 41 46 2091 40 2028 46 2080 40 41 41 46 2092 40 2029 41 46 2093 40 2030 41 46 2094 40 2032 46 2080 40 41 41 46 2095 40 2039 41 46 2096 40 2042 46 2080 40 41 41 46 2097 40 2043 41 46 2098 40 2082 46 2099 40 41 46 2100 40 2101 45 62 2101 46 2102 40 41 46 2103 40 41 41 46 2104 40 2105 46 2106 40 41 41 41 46 2107 40 467 46 2108 40 41 41 46 2109 40 2053 41 46 2110 40 2003 46 2006 46 2080 40 2061 41 41 46 2111 40 2023 41 59 2112 46 2113 40 2034 41 46 2114 40 2115 45 62 2085 46 2116 40 2117 46 2118 40 2115 41 41 41 59 2112 46 2113 40 2035 41 46 2114 40 2115 45 62 2085 46 2119 40 2117 46 2118 40 2115 41 41 41 59 2112 46 2113 40 2036 41 46 2114 40 2115 45 62 2085 46 2120 40 2117 46 2118 40 2115 41 41 41 59 2112 46 2113 40 2037 41 46 2114 40 2085 58 58 2121 41 59 2112 46 2113 40 2038 41 46 2114 40 2085 58 58 2122 41 59 2112 46 2113 40 2055 41 46 2114 40 2085 58 58 2123 41 59 2112 46 2113 40 2040 41 46 2114 40 2085 58 58 2124 41 59 2112 46 2113 40 2041 41 46 2114 40 2085 58 58 2125 41 59 2112 46 2113 40 2051 46 2126 40 41 41 46 2114 40 2127 45 62 2085 46 2128 40 2051 46 2126 40 41 46 2080 40 41 41 41 59 2112 46 2113 40 2057 41 46 2114 40 2127 45 62 2085 46 2129 40 2056 46 2080 40 2057 41 41 41 59 2112 46 2113 40 2058 41 46 2114 40 2127 45 62 2085 46 2130 40 2058 41 41 59 2112 46 2113 40 2059 41 46 2114 40 2127 45 62 2085 46 2131 40 2059 41 41 59 2112 46 2113 40 2060 41 46 2114 40 2127 45 62 2085 46 2132 40 2060 41 41 59 2112 46 2113 40 2133 40 41 41 46 2114 40 2085 58 58 2134 41 59 450 2085 46 2135 40 41 59 125 439 457 2003 2136 40 2079 46 2003 2137 44 2138 2139 41 123 2003 2140 61 418 2003 40 2137 46 2141 40 41 44 2137 46 2142 40 41 44 2137 46 2143 40 41 44 2137 46 2144 40 41 44 2137 46 2145 40 41 44 2027 46 2136 40 2137 46 2146 40 41 41 44 2137 46 2147 40 41 44 2137 46 2148 40 41 44 2031 46 2136 40 2137 46 2149 40 41 44 2139 41 44 2150 46 2151 40 2137 46 2152 40 41 41 44 2150 46 2151 40 2137 46 2153 40 41 41 44 2150 46 2151 40 2137 46 2154 40 41 41 44 2150 46 2155 40 2137 46 2156 40 41 41 44 2150 46 2155 40 2137 46 2157 40 41 41 44 2137 46 2158 40 41 44 2150 46 2155 40 2137 46 2159 40 41 41 44 2150 46 2155 40 2137 46 2160 40 41 41 44 2027 46 2136 40 2137 46 2161 40 41 41 44 2137 46 2162 40 41 44 2056 46 2136 40 2137 46 2163 40 41 41 41 59 2140 46 2164 40 2165 46 2166 40 2137 46 2167 40 41 41 63 424 58 2168 46 2169 40 2137 46 2167 40 41 41 41 59 2140 46 2046 46 2170 40 2137 46 2171 40 41 46 2172 40 41 46 2173 40 2045 58 58 2174 41 46 2175 40 2176 46 2177 40 41 41 41 59 392 40 2137 46 2178 40 41 41 2140 46 2051 46 2179 40 2050 46 2136 40 2137 46 2180 40 41 41 41 59 2140 46 2055 61 2150 46 2155 40 2137 46 2181 40 41 41 59 2021 2058 61 2137 46 2182 40 41 59 392 40 33 2058 46 2166 40 41 41 123 2140 46 2183 40 2058 41 59 125 2021 2059 61 2137 46 2184 40 41 59 392 40 33 2059 46 2166 40 41 41 123 2140 46 2185 40 2059 41 59 125 2021 2060 61 2137 46 2186 40 41 59 392 40 33 2060 46 2166 40 41 41 123 2140 46 2187 40 2060 41 59 125 392 40 2003 46 2006 46 2136 40 2137 46 2188 40 41 41 614 2006 46 2189 41 123 621 2140 46 2190 40 2137 46 2191 40 41 63 2006 46 2192 58 2006 46 2193 41 59 392 40 2140 46 2194 40 41 614 2006 46 2192 41 123 621 621 621 2140 46 2195 40 41 46 2196 40 2197 45 62 2197 46 2198 40 473 41 41 59 125 125 360 123 2140 46 2199 40 2003 46 2006 46 2136 40 2137 46 2188 40 41 41 41 59 125 2140 46 2200 40 473 41 59 450 2140 59 125 621 621 621 439 492 2201 40 2045 2202 41 123 392 40 33 2046 46 2203 40 2202 41 41 123 2046 46 2204 40 2202 41 59 125 360 123 2205 46 371 40 648 41 59 125 125 621 621 621 439 492 2206 40 41 123 2207 40 2006 46 2208 41 59 125 439 492 2209 40 41 123 2210 40 2006 46 2211 41 59 125 439 492 2212 40 2003 46 2006 2061 41 123 467 46 2061 61 2061 59 467 46 2069 46 2213 40 2061 614 2006 46 2214 41 59 125 439 492 2215 40 2050 2216 41 123 2051 46 2217 40 2216 41 59 125 439 492 2218 40 2021 2219 44 2021 2220 41 123 392 40 2219 614 424 606 2220 614 424 41 123 450 59 125 392 40 2064 614 424 41 123 2064 61 418 2221 60 62 40 41 59 125 2064 46 2222 40 2219 44 2220 41 59 125 621 621 621 439 2021 2223 40 41 123 450 2224 46 2225 40 2022 41 59 125 439 2226 2069 40 41 123 450 2069 59 125 439 2227 2228 40 41 123 450 2072 59 125 439 2229 60 2050 62 2051 40 41 123 450 2051 59 125 439 2230 2231 40 41 123 450 418 2230 40 2029 41 59 125 439 2230 2232 40 41 123 450 418 2230 40 2030 41 59 125 439 2230 2233 40 41 123 450 418 2230 40 2053 41 59 125 439 324 2234 40 41 123 450 467 46 2061 614 2006 46 2062 59 125 439 324 2235 40 41 123 450 467 46 2061 614 2006 46 2236 59 125 439 492 2237 40 324 2238 41 123 621 621 392 40 2234 40 41 606 2239 40 2238 41 62 1500 41 123 2072 46 2240 40 1501 41 59 125 360 123 2072 46 2241 40 1500 41 59 125 125 439 413 2242 40 324 2238 41 123 450 2046 46 2243 40 41 46 2244 40 2245 45 62 2245 46 2246 40 41 614 2238 606 2245 46 2247 40 41 41 46 2244 40 2245 45 62 33 2245 46 2248 40 41 41 46 2249 40 41 59 125 439 492 2250 40 324 2238 41 123 392 40 467 46 2061 614 2006 46 2062 41 2212 40 2006 46 2251 41 59 2237 40 2238 41 59 125 439 492 2252 40 324 2238 41 123 2253 40 41 46 2254 40 2255 45 62 2255 46 2256 40 473 41 41 59 2237 40 2238 41 59 125 439 2021 2257 40 41 123 392 40 2026 41 123 392 40 2025 41 450 2258 46 2259 40 648 41 59 360 450 2258 46 2259 40 648 41 59 125 360 123 392 40 2025 41 450 2260 46 2261 40 648 41 59 360 450 2260 46 2261 40 648 41 59 125 125 64 2078 439 2021 2262 40 41 123 450 648 43 648 43 2022 43 607 43 648 43 2023 43 607 43 648 43 2065 43 607 43 648 43 2061 43 648 43 2024 43 648 43 2025 43 648 43 2026 43 648 43 2028 43 648 43 2029 43 648 43 2030 43 648 43 2032 43 648 43 2263 46 2264 40 2034 41 43 648 43 2263 46 2264 40 2035 41 43 648 43 2263 46 2264 40 2036 41 43 648 43 2037 43 607 43 648 43 2038 43 607 43 648 43 2039 43 607 43 648 43 2040 43 607 43 648 43 2041 43 607 43 648 43 2042 43 648 43 2043 43 648 43 2046 43 648 43 2069 43 648 43 2051 43 648 43 2055 43 607 43 648 43 2053 43 648 43 2057 43 648 43 2058 43 607 43 648 43 2059 43 607 43 648 43 2060 43 607 43 648 59 125 125 
3351,Java,"@Slf4j
public abstract class BisqExecutable implements GracefulShutDownHandler, BisqSetup.BisqSetupListener, UncaughtExceptionHandler {

    public static final int EXIT_SUCCESS = 0;
    public static final int EXIT_FAILURE = 1;

    private final String fullName;
    private final String scriptName;
    private final String appName;
    private final String version;

    protected Injector injector;
    protected AppModule module;
    protected Config config;
    private boolean isShutdownInProgress;
    private boolean hasDowngraded;

    public BisqExecutable(String fullName, String scriptName, String appName, String version) {
        this.fullName = fullName;
        this.scriptName = scriptName;
        this.appName = appName;
        this.version = version;
    }

    public void execute(String[] args) {
        try {
            config = new Config(appName, Utilities.getUserDataDir(), args);
            if (config.helpRequested) {
                config.printHelp(System.out, new BisqHelpFormatter(fullName, scriptName, version));
                System.exit(EXIT_SUCCESS);
            }
        } catch (ConfigException ex) {
            System.err.println(""error: "" + ex.getMessage());
            System.exit(EXIT_FAILURE);
        } catch (Throwable ex) {
            System.err.println(""fault: An unexpected error occurred. "" +
                    ""Please file a report at https://bisq.network/issues"");
            ex.printStackTrace(System.err);
            System.exit(EXIT_FAILURE);
        }

        doExecute();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // First synchronous execution tasks
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected void doExecute() {
        CommonSetup.setup(config, this);
        CoreSetup.setup(config);

        addCapabilities();

        // If application is JavaFX application we need to wait until it is initialized
        launchApplication();
    }

    protected abstract void configUserThread();

    protected void addCapabilities() {
    }

    // The onApplicationLaunched call must map to UserThread, so that all following methods are running in the
    // thread the application is running and we don't run into thread interference.
    protected abstract void launchApplication();


    ///////////////////////////////////////////////////////////////////////////////////////////
    // If application is a JavaFX application we need wait for onApplicationLaunched
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Headless versions can call inside launchApplication the onApplicationLaunched() manually
    // Desktop gets called from JavaFx thread
    protected void onApplicationLaunched() {
        configUserThread();

        // Now we can use the user thread start periodic tasks
        CommonSetup.startPeriodicTasks();

        // As the handler method might be overwritten by subclasses and they use the application as handler
        // we need to setup the handler after the application is created.
        CommonSetup.setupUncaughtExceptionHandler(this);
        setupGuice();
        setupAvoidStandbyMode();

        hasDowngraded = BisqSetup.hasDowngraded();
        if (hasDowngraded) {
            // If user tried to downgrade we do not read the persisted data to avoid data corruption
            // We call startApplication to enable UI to show popup. We prevent in BisqSetup to go further
            // in the process and require a shut down.
            startApplication();
        } else {
            readAllPersisted(this::startApplication);
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // We continue with a series of synchronous execution tasks
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected void setupGuice() {
        module = getModule();
        injector = getInjector();
        applyInjector();
    }

    protected abstract AppModule getModule();

    protected Injector getInjector() {
        return Guice.createInjector(module);
    }

    protected void applyInjector() {
        // Subclasses might configure classes with the injector here
    }

    protected void readAllPersisted(Runnable completeHandler) {
        readAllPersisted(null, completeHandler);
    }

    protected void readAllPersisted(@Nullable List<PersistedDataHost> additionalHosts, Runnable completeHandler) {
        List<PersistedDataHost> hosts = CorePersistedDataHost.getPersistedDataHosts(injector);
        if (additionalHosts != null) {
            hosts.addAll(additionalHosts);
        }

        AtomicInteger remaining = new AtomicInteger(hosts.size());
        hosts.forEach(host -> {
            host.readPersisted(() -> {
                if (remaining.decrementAndGet() == 0) {
                    UserThread.execute(completeHandler);
                }
            });
        });
    }

    protected void setupAvoidStandbyMode() {
    }

    protected abstract void startApplication();

    // Once the application is ready we get that callback and we start the setup
    protected void onApplicationStarted() {
        runBisqSetup();
    }

    protected void runBisqSetup() {
        BisqSetup bisqSetup = injector.getInstance(BisqSetup.class);
        bisqSetup.addBisqSetupListener(this);
        bisqSetup.start();
    }

    public abstract void onSetupComplete();


    ///////////////////////////////////////////////////////////////////////////////////////////
    // GracefulShutDownHandler implementation
    ///////////////////////////////////////////////////////////////////////////////////////////

    // This might need to be overwritten in case the application is not using all modules
    @Override
    public void gracefulShutDown(ResultHandler resultHandler) {
        log.info(""Start graceful shutDown"");
        if (isShutdownInProgress) {
            return;
        }

        isShutdownInProgress = true;

        if (injector == null) {
            log.info(""Shut down called before injector was created"");
            resultHandler.handleResult();
            System.exit(EXIT_SUCCESS);
        }

        // We do not use the UserThread to avoid that the timeout would not get triggered in case the UserThread
        // would get blocked by a shutdown routine.
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                log.warn(""Graceful shutdown not completed in 10 sec. We trigger our timeout handler."");
                flushAndExit(resultHandler, EXIT_SUCCESS);
            }
        }, 10000);

        try {
            injector.getInstance(ClockWatcher.class).shutDown();
            injector.getInstance(OpenBsqSwapOfferService.class).shutDown();
            injector.getInstance(PriceFeedService.class).shutDown();
            injector.getInstance(ArbitratorManager.class).shutDown();
            injector.getInstance(TradeStatisticsManager.class).shutDown();
            injector.getInstance(XmrTxProofService.class).shutDown();
            injector.getInstance(RpcService.class).shutDown();
            injector.getInstance(DaoSetup.class).shutDown();
            injector.getInstance(AvoidStandbyModeService.class).shutDown();
            log.info(""OpenOfferManager shutdown started"");
            injector.getInstance(OpenOfferManager.class).shutDown(() -> {
                log.info(""OpenOfferManager shutdown completed"");

                injector.getInstance(BtcWalletService.class).shutDown();
                injector.getInstance(BsqWalletService.class).shutDown();

                // We need to shut down BitcoinJ before the P2PService as it uses Tor.
                WalletsSetup walletsSetup = injector.getInstance(WalletsSetup.class);
                walletsSetup.shutDownComplete.addListener((ov, o, n) -> {
                    log.info(""WalletsSetup shutdown completed"");
                    injector.getInstance(P2PService.class).shutDown(() -> {
                        log.info(""P2PService shutdown completed"");
                        module.close(injector);
                        flushAndExit(resultHandler, EXIT_SUCCESS);
                    });
                });
                walletsSetup.shutDown();
            });
        } catch (Throwable t) {
            log.error(""App shutdown failed with an exception"", t);
            flushAndExit(resultHandler, EXIT_FAILURE);
        }
    }

    private void flushAndExit(ResultHandler resultHandler, int status) {
        if (!hasDowngraded) {
            // If user tried to downgrade we do not write the persistable data to avoid data corruption
            log.info(""PersistenceManager flushAllDataToDiskAtShutdown started"");
            PersistenceManager.flushAllDataToDiskAtShutdown(() -> {
                log.info(""Graceful shutdown completed. Exiting now."");
                resultHandler.handleResult();
                UserThread.runAfter(() -> System.exit(status), 100, TimeUnit.MILLISECONDS);
            });
        } else {
            UserThread.runAfter(() -> System.exit(status), 100, TimeUnit.MILLISECONDS);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // UncaughtExceptionHandler implementation
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void handleUncaughtException(Throwable throwable, boolean doShutDown) {
        log.error(throwable.toString());

        if (doShutDown)
            gracefulShutDown(() -> log.info(""gracefulShutDown complete""));
    }
}",1,64 2000 439 305 334 2001 395 2002 44 2003 46 2004 44 2005 123 439 457 381 404 2006 61 1500 59 439 457 381 404 2007 61 1501 59 437 381 2008 2009 59 437 381 2008 2010 59 437 381 2008 2011 59 437 381 2008 2012 59 438 2013 2014 59 438 2015 414 59 438 2016 2017 59 437 324 2018 59 437 324 2019 59 439 2001 40 2008 2009 44 2008 2010 44 2008 2011 44 2008 2012 41 123 467 46 2009 61 2009 59 467 46 2010 61 2010 59 467 46 2011 61 2011 59 467 46 2012 61 2012 59 125 439 492 2020 40 2008 91 93 2021 41 123 474 123 2017 61 418 2016 40 2011 44 2022 46 2023 40 41 44 2021 41 59 392 40 2017 46 2024 41 123 2017 46 2025 40 2026 46 430 44 418 2027 40 2009 44 2010 44 2012 41 41 59 2026 46 375 40 2006 41 59 125 125 329 40 2028 2029 41 123 2030 46 2031 46 2032 40 648 43 2029 46 2033 40 41 41 59 2030 46 375 40 2007 41 59 125 329 40 2034 2029 41 123 2035 46 2036 46 2037 40 648 43 648 41 59 2029 46 2038 40 2035 46 2036 41 59 2035 46 375 40 2007 41 59 125 2039 40 41 59 125 621 621 621 438 492 2040 40 41 123 2041 46 2042 40 2017 44 467 41 59 2043 46 2042 40 2017 41 59 2044 40 41 59 621 2045 40 41 59 125 438 305 492 2046 40 41 59 438 492 2047 40 41 123 125 621 621 438 305 492 2048 40 41 59 621 621 621 621 621 438 492 2049 40 41 123 2046 40 41 59 621 2050 46 2051 40 41 59 621 621 2050 46 2052 40 467 41 59 2053 40 41 59 2054 40 41 59 2019 61 2003 46 2019 40 41 59 392 40 2019 41 123 621 621 621 2055 40 41 59 125 360 123 2056 40 467 58 58 2057 41 59 125 125 621 621 621 438 492 2058 40 41 123 414 61 2059 40 41 59 2014 61 2060 40 41 59 2061 40 41 59 125 438 305 2015 2062 40 41 59 438 2013 2063 40 41 123 450 2064 46 2065 40 414 41 59 125 438 492 2066 40 41 123 621 125 438 492 2067 40 2068 2069 41 123 2067 40 424 44 2069 41 59 125 438 492 2067 40 64 2070 2071 60 2072 62 2073 44 2068 2069 41 123 2071 60 2072 62 2074 61 2075 46 2076 40 2014 41 59 392 40 2073 631 424 41 123 2074 46 2077 40 2073 41 59 125 2078 2079 61 418 2078 40 2074 46 2080 40 41 41 59 2074 46 2081 40 2082 45 62 123 2082 46 2083 40 40 41 45 62 123 392 40 2079 46 2084 40 41 614 1500 41 123 2085 46 2020 40 2069 41 59 125 125 41 59 125 41 59 125 438 492 2086 40 41 123 125 438 305 492 2087 40 41 59 621 438 492 2088 40 41 123 2089 40 41 59 125 438 492 2090 40 41 123 2003 2091 61 2014 46 2092 40 2003 46 334 41 59 2091 46 2093 40 467 41 59 2091 46 2094 40 41 59 125 439 305 492 2095 40 41 59 621 621 621 621 64 2096 439 492 2097 40 2098 2099 41 123 2100 46 2101 40 648 41 59 392 40 2018 41 123 450 59 125 2018 61 473 59 392 40 2014 614 424 41 123 2100 46 2101 40 648 41 59 2099 46 2102 40 41 59 2103 46 375 40 2006 41 59 125 621 621 418 2104 40 41 46 2105 40 418 2106 40 41 123 64 2096 439 492 2107 40 41 123 2100 46 2108 40 648 41 59 2109 40 2099 44 2006 41 59 125 125 44 1505 41 59 474 123 2014 46 2110 40 2111 46 334 41 46 2112 40 41 59 2014 46 2110 40 2113 46 334 41 46 2112 40 41 59 2014 46 2110 40 2114 46 334 41 46 2112 40 41 59 2014 46 2110 40 2115 46 334 41 46 2112 40 41 59 2014 46 2110 40 2116 46 334 41 46 2112 40 41 59 2014 46 2110 40 2117 46 334 41 46 2112 40 41 59 2014 46 2110 40 2118 46 334 41 46 2112 40 41 59 2014 46 2110 40 2119 46 334 41 46 2112 40 41 59 2014 46 2110 40 2120 46 334 41 46 2112 40 41 59 2100 46 2101 40 648 41 59 2014 46 2110 40 2121 46 334 41 46 2112 40 40 41 45 62 123 2100 46 2101 40 648 41 59 2014 46 2110 40 2122 46 334 41 46 2112 40 41 59 2014 46 2110 40 2123 46 334 41 46 2112 40 41 59 621 2124 2125 61 2014 46 2110 40 2124 46 334 41 59 2125 46 2126 46 2127 40 40 2128 44 2129 44 2130 41 45 62 123 2100 46 2101 40 648 41 59 2014 46 2110 40 2131 46 334 41 46 2112 40 40 41 45 62 123 2100 46 2101 40 648 41 59 414 46 2132 40 2014 41 59 2133 40 2099 44 2006 41 59 125 41 59 125 41 59 2125 46 2112 40 41 59 125 41 59 125 329 40 2134 2135 41 123 2100 46 371 40 648 44 2135 41 59 2136 40 2099 44 2007 41 59 125 125 437 492 2137 40 2098 2099 44 404 2138 41 123 392 40 33 2019 41 123 621 2139 46 2140 40 648 41 59 2141 46 2142 40 40 41 45 62 123 2139 46 2140 40 648 41 59 2099 46 2143 40 41 59 2144 46 2145 40 40 41 45 62 2146 46 375 40 2138 41 44 1503 44 2147 46 2148 41 59 125 41 59 125 360 123 2149 46 2150 40 40 41 45 62 2151 46 375 40 2138 41 44 1503 44 2152 46 2153 41 59 125 125 621 621 621 64 2096 439 492 2154 40 2155 2156 44 324 2157 41 123 2158 46 371 40 2156 46 2159 40 41 41 59 392 40 2157 41 2097 40 40 41 45 62 2158 46 2160 40 648 41 41 59 125 125 
3452,Java,"public class ConfigTests {

    @Rule
    public ExpectedException exceptionRule = ExpectedException.none();

    // Note: ""DataDirProperties"" in the test method names below represent the group of
    // configuration options that influence the location of a Bisq node's data directory.
    // These options include appName, userDataDir, appDataDir and configFile

    @Test
    public void whenNoArgCtorIsCalled_thenDefaultAppNameIsSetToTempValue() {
        Config config = new Config();
        String defaultAppName = config.defaultAppName;
        String regex = ""Bisq\\d{2,}Temp"";
        assertTrue(format(""Temp app name '%s' failed to match '%s'"", defaultAppName, regex),
                defaultAppName.matches(regex));
    }

    @Test
    public void whenAppNameOptionIsSet_thenAppNamePropertyDiffersFromDefaultAppNameProperty() {
        Config config = configWithOpts(opt(APP_NAME, ""My-Bisq""));
        assertThat(config.appName, equalTo(""My-Bisq""));
        assertThat(config.appName, not(equalTo(config.defaultAppName)));
    }

    @Test
    public void whenNoOptionsAreSet_thenDataDirPropertiesEqualDefaultValues() {
        Config config = new Config();
        assertThat(config.appName, equalTo(config.defaultAppName));
        assertThat(config.userDataDir, equalTo(config.defaultUserDataDir));
        assertThat(config.appDataDir, equalTo(config.defaultAppDataDir));
        assertThat(config.configFile, equalTo(config.defaultConfigFile));
    }

    @Test
    public void whenAppNameOptionIsSet_thenDataDirPropertiesReflectItsValue() {
        Config config = configWithOpts(opt(APP_NAME, ""My-Bisq""));
        assertThat(config.appName, equalTo(""My-Bisq""));
        assertThat(config.userDataDir, equalTo(config.defaultUserDataDir));
        assertThat(config.appDataDir, equalTo(new File(config.userDataDir, ""My-Bisq"")));
        assertThat(config.configFile, equalTo(new File(config.appDataDir, DEFAULT_CONFIG_FILE_NAME)));
    }

    @Test
    public void whenAppDataDirOptionIsSet_thenDataDirPropertiesReflectItsValue() throws IOException {
        File appDataDir = Files.createTempDirectory(""myapp"").toFile();
        Config config = configWithOpts(opt(APP_DATA_DIR, appDataDir));
        assertThat(config.appName, equalTo(config.defaultAppName));
        assertThat(config.userDataDir, equalTo(config.defaultUserDataDir));
        assertThat(config.appDataDir, equalTo(appDataDir));
        assertThat(config.configFile, equalTo(new File(config.appDataDir, DEFAULT_CONFIG_FILE_NAME)));
    }

    @Test
    public void whenUserDataDirOptionIsSet_thenDataDirPropertiesReflectItsValue() throws IOException {
        File userDataDir = Files.createTempDirectory(""myuserdata"").toFile();
        Config config = configWithOpts(opt(USER_DATA_DIR, userDataDir));
        assertThat(config.appName, equalTo(config.defaultAppName));
        assertThat(config.userDataDir, equalTo(userDataDir));
        assertThat(config.appDataDir, equalTo(new File(userDataDir, config.defaultAppName)));
        assertThat(config.configFile, equalTo(new File(config.appDataDir, DEFAULT_CONFIG_FILE_NAME)));
    }

    @Test
    public void whenAppNameAndAppDataDirOptionsAreSet_thenDataDirPropertiesReflectTheirValues() throws IOException {
        File appDataDir = Files.createTempDirectory(""myapp"").toFile();
        Config config = configWithOpts(opt(APP_NAME, ""My-Bisq""), opt(APP_DATA_DIR, appDataDir));
        assertThat(config.appName, equalTo(""My-Bisq""));
        assertThat(config.userDataDir, equalTo(config.defaultUserDataDir));
        assertThat(config.appDataDir, equalTo(appDataDir));
        assertThat(config.configFile, equalTo(new File(config.appDataDir, DEFAULT_CONFIG_FILE_NAME)));
    }

    @Test
    public void whenOptionIsSetAtCommandLineAndInConfigFile_thenCommandLineValueTakesPrecedence() throws IOException {
        File configFile = File.createTempFile(""bisq"", ""properties"");
        try (PrintWriter writer = new PrintWriter(configFile)) {
            writer.println(new ConfigFileOption(APP_NAME, ""Bisq-configFileValue""));
        }
        Config config = configWithOpts(opt(APP_NAME, ""Bisq-commandLineValue""));
        assertThat(config.appName, equalTo(""Bisq-commandLineValue""));
    }

    @Test
    public void whenUnrecognizedOptionIsSet_thenConfigExceptionIsThrown() {
        exceptionRule.expect(ConfigException.class);
        exceptionRule.expectMessage(""problem parsing option 'bogus': bogus is not a recognized option"");
        configWithOpts(opt(""bogus""));
    }

    @Test
    public void whenUnrecognizedOptionIsSetInConfigFile_thenNoExceptionIsThrown() throws IOException {
        File configFile = File.createTempFile(""bisq"", ""properties"");
        try (PrintWriter writer = new PrintWriter(configFile)) {
            writer.println(new ConfigFileOption(""bogusOption"", ""bogusValue""));
            writer.println(new ConfigFileOption(APP_NAME, ""BisqTest""));
        }
        Config config = configWithOpts(opt(CONFIG_FILE, configFile.getAbsolutePath()));
        assertThat(config.appName, equalTo(""BisqTest""));
    }

    @Test
    public void whenOptionFileArgumentDoesNotExist_thenConfigExceptionIsThrown() {
        String filepath = ""/does/not/exist"";
        if (System.getProperty(""os.name"").startsWith(""Windows"")) {
            filepath = ""C:\\does\\not\\exist"";
        }
        exceptionRule.expect(ConfigException.class);
        exceptionRule.expectMessage(format(""problem parsing option 'torrcFile': File [%s] does not exist"", filepath));
        configWithOpts(opt(TORRC_FILE, filepath));
    }

    @Test
    public void whenConfigFileOptionIsSetToNonExistentFile_thenConfigExceptionIsThrown() {
        String filepath = ""/no/such/bisq.properties"";
        if (System.getProperty(""os.name"").startsWith(""Windows"")) {
            filepath = ""C:\\no\\such\\bisq.properties"";
        }
        exceptionRule.expect(ConfigException.class);
        exceptionRule.expectMessage(format(""The specified config file '%s' does not exist"", filepath));
        configWithOpts(opt(CONFIG_FILE, filepath));
    }

    @Test
    public void whenConfigFileOptionIsSetInConfigFile_thenConfigExceptionIsThrown() throws IOException {
        File configFile = File.createTempFile(""bisq"", ""properties"");
        try (PrintWriter writer = new PrintWriter(configFile)) {
            writer.println(new ConfigFileOption(CONFIG_FILE, ""/tmp/other.bisq.properties""));
        }
        exceptionRule.expect(ConfigException.class);
        exceptionRule.expectMessage(format(""The '%s' option is disallowed in config files"", CONFIG_FILE));
        configWithOpts(opt(CONFIG_FILE, configFile.getAbsolutePath()));
    }

    @Test
    public void whenConfigFileOptionIsSetToExistingFile_thenConfigFilePropertyReflectsItsValue() throws IOException {
        File configFile = File.createTempFile(""bisq"", ""properties"");
        Config config = configWithOpts(opt(CONFIG_FILE, configFile.getAbsolutePath()));
        assertThat(config.configFile, equalTo(configFile));
    }

    @Test
    public void whenConfigFileOptionIsSetToRelativePath_thenThePathIsPrefixedByAppDataDir() throws IOException {
        File configFile = Files.createTempFile(""my-bisq"", "".properties"").toFile();
        File appDataDir = configFile.getParentFile();
        String relativeConfigFilePath = configFile.getName();
        Config config = configWithOpts(opt(APP_DATA_DIR, appDataDir), opt(CONFIG_FILE, relativeConfigFilePath));
        assertThat(config.configFile, equalTo(configFile));
    }

    @Test
    public void whenAppNameIsSetInConfigFile_thenDataDirPropertiesReflectItsValue() throws IOException {
        File configFile = File.createTempFile(""bisq"", ""properties"");
        try (PrintWriter writer = new PrintWriter(configFile)) {
            writer.println(new ConfigFileOption(APP_NAME, ""My-Bisq""));
        }
        Config config = configWithOpts(opt(CONFIG_FILE, configFile.getAbsolutePath()));
        assertThat(config.appName, equalTo(""My-Bisq""));
        assertThat(config.userDataDir, equalTo(config.defaultUserDataDir));
        assertThat(config.appDataDir, equalTo(new File(config.userDataDir, config.appName)));
        assertThat(config.configFile, equalTo(configFile));
    }

    @Test
    public void whenBannedBtcNodesOptionIsSet_thenBannedBtcNodesPropertyReturnsItsValue() {
        Config config = configWithOpts(opt(BANNED_BTC_NODES, ""foo.onion:8333,bar.onion:8333""));
        assertThat(config.bannedBtcNodes, contains(""foo.onion:8333"", ""bar.onion:8333""));
    }

    @Test
    public void whenHelpOptionIsSet_thenIsHelpRequestedIsTrue() {
        assertFalse(new Config().helpRequested);
        assertTrue(configWithOpts(opt(HELP)).helpRequested);
    }

    @Test
    public void whenConfigIsConstructed_thenNoConsoleOutputSideEffectsShouldOccur() {
        PrintStream outOrig = System.out;
        PrintStream errOrig = System.err;
        ByteArrayOutputStream outBytes = new ByteArrayOutputStream();
        ByteArrayOutputStream errBytes = new ByteArrayOutputStream();
        try (PrintStream outTest = new PrintStream(outBytes);
             PrintStream errTest = new PrintStream(errBytes)) {
            System.setOut(outTest);
            System.setErr(errTest);
            new Config();
            assertThat(outBytes.toString(), isEmptyString());
            assertThat(errBytes.toString(), isEmptyString());
        } finally {
            System.setOut(outOrig);
            System.setErr(errOrig);
        }
    }

    @Test
    public void whenConfigIsConstructed_thenAppDataDirAndSubdirsAreCreated() {
        Config config = new Config();
        assertTrue(config.appDataDir.exists());
        assertTrue(config.keyStorageDir.exists());
        assertTrue(config.storageDir.exists());
        assertTrue(config.torDir.exists());
        assertTrue(config.walletDir.exists());
    }

    @Test
    public void whenAppDataDirCannotBeCreated_thenUncheckedIoExceptionIsThrown() throws IOException {
        // set a userDataDir that is actually a file so appDataDir cannot be created
        File aFile = Files.createTempFile(""A"", ""File"").toFile();
        exceptionRule.expect(UncheckedIOException.class);
        exceptionRule.expectMessage(containsString(""Application data directory""));
        exceptionRule.expectMessage(containsString(""could not be created""));
        configWithOpts(opt(USER_DATA_DIR, aFile));
    }

    @Test
    public void whenAppDataDirIsSymbolicLink_thenAppDataDirCreationIsNoOp() throws IOException {
        Path parentDir = Files.createTempDirectory(""parent"");
        Path targetDir = parentDir.resolve(""target"");
        Path symlink = parentDir.resolve(""symlink"");
        Files.createDirectory(targetDir);
        try {
            Files.createSymbolicLink(symlink, targetDir);
        } catch (Throwable ex) {
            // An error occurred trying to create a symbolic link, likely because the
            // operating system (e.g. Windows) does not support it, so we abort the test.
            return;
        }
        configWithOpts(opt(APP_DATA_DIR, symlink));
    }


    // == TEST SUPPORT FACILITIES ========================================================

    static Config configWithOpts(Opt... opts) {
        String[] args = new String[opts.length];
        for (int i = 0; i < opts.length; i++)
            args[i] = opts[i].toString();
        return new Config(args);
    }

    static Opt opt(String name) {
        return new Opt(name);
    }

    static Opt opt(String name, Object arg) {
        return new Opt(name, arg.toString());
    }

    static class Opt {
        private final String name;
        private final String arg;

        public Opt(String name) {
            this(name, null);
        }

        public Opt(String name, String arg) {
            this.name = name;
            this.arg = arg;
        }

        @Override
        public String toString() {
            return format(""--%s%s"", name, arg != null ? (""="" + arg) : """");
        }
    }
}",1,439 334 2000 123 64 2001 439 2002 2003 61 2002 46 2004 40 41 59 621 621 621 64 2005 439 492 2006 40 41 123 2007 2008 61 418 2007 40 41 59 2009 2010 61 2008 46 2010 59 2009 2011 61 648 59 2012 40 2013 40 648 44 2010 44 2011 41 44 2010 46 2014 40 2011 41 41 59 125 64 2005 439 492 2015 40 41 123 2016 2017 61 2018 40 2019 40 2020 44 648 41 41 59 2021 40 2017 46 2022 44 2023 40 648 41 41 59 2021 40 2017 46 2022 44 422 40 2023 40 2017 46 2024 41 41 41 59 125 64 2005 439 492 2025 40 41 123 2026 2027 61 418 2026 40 41 59 2028 40 2027 46 2029 44 2030 40 2027 46 2031 41 41 59 2028 40 2027 46 2032 44 2030 40 2027 46 2033 41 41 59 2028 40 2027 46 2034 44 2030 40 2027 46 2035 41 41 59 2028 40 2027 46 2036 44 2030 40 2027 46 2037 41 41 59 125 64 2005 439 492 2038 40 41 123 2039 2040 61 2041 40 2042 40 2043 44 648 41 41 59 2044 40 2040 46 2045 44 2046 40 648 41 41 59 2044 40 2040 46 2047 44 2046 40 2040 46 2048 41 41 59 2044 40 2040 46 2049 44 2046 40 418 2050 40 2040 46 2047 44 648 41 41 41 59 2044 40 2040 46 2051 44 2046 40 418 2050 40 2040 46 2049 44 2052 41 41 41 59 125 64 2005 439 492 2053 40 41 470 2054 123 2055 2056 61 2057 46 2058 40 648 41 46 2059 40 41 59 2060 2061 61 2062 40 2063 40 2064 44 2056 41 41 59 2065 40 2061 46 2066 44 2067 40 2061 46 2068 41 41 59 2065 40 2061 46 2069 44 2067 40 2061 46 2070 41 41 59 2065 40 2061 46 2056 44 2067 40 2056 41 41 59 2065 40 2061 46 2071 44 2067 40 418 2055 40 2061 46 2056 44 2072 41 41 41 59 125 64 2005 439 492 2073 40 41 470 2054 123 2074 2075 61 2076 46 2077 40 648 41 46 2078 40 41 59 2079 2080 61 2081 40 2082 40 2083 44 2075 41 41 59 2084 40 2080 46 2085 44 2086 40 2080 46 2087 41 41 59 2084 40 2080 46 2075 44 2086 40 2075 41 41 59 2084 40 2080 46 2088 44 2086 40 418 2074 40 2075 44 2080 46 2087 41 41 41 59 2084 40 2080 46 2089 44 2086 40 418 2074 40 2080 46 2088 44 2090 41 41 41 59 125 64 2005 439 492 2091 40 41 470 2054 123 2092 2093 61 2094 46 2095 40 648 41 46 2096 40 41 59 2097 2098 61 2099 40 2100 40 2101 44 648 41 44 2100 40 2102 44 2093 41 41 59 2103 40 2098 46 2104 44 2105 40 648 41 41 59 2103 40 2098 46 2106 44 2105 40 2098 46 2107 41 41 59 2103 40 2098 46 2093 44 2105 40 2093 41 41 59 2103 40 2098 46 2108 44 2105 40 418 2092 40 2098 46 2093 44 2109 41 41 41 59 125 64 2005 439 492 2110 40 41 470 2054 123 2111 2112 61 2111 46 2113 40 648 44 648 41 59 474 40 2114 2115 61 418 2114 40 2112 41 41 123 2115 46 2116 40 418 2117 40 2118 44 648 41 41 59 125 2119 2120 61 2121 40 2122 40 2123 44 648 41 41 59 2124 40 2120 46 2125 44 2126 40 648 41 41 59 125 64 2005 439 492 2127 40 41 123 2003 46 2128 40 2129 46 334 41 59 2003 46 2130 40 648 41 59 2131 40 2132 40 648 41 41 59 125 64 2005 439 492 2133 40 41 470 2054 123 2134 2135 61 2134 46 2136 40 648 44 648 41 59 474 40 2137 2138 61 418 2137 40 2135 41 41 123 2138 46 2139 40 418 2140 40 648 44 648 41 41 59 2138 46 2139 40 418 2140 40 2141 44 648 41 41 59 125 2142 2143 61 2144 40 2145 40 2146 44 2135 46 2147 40 41 41 41 59 2148 40 2143 46 2149 44 2150 40 648 41 41 59 125 64 2005 439 492 2151 40 41 123 2152 2153 61 648 59 392 40 2154 46 2155 40 648 41 46 2156 40 648 41 41 123 2153 61 648 59 125 2003 46 2157 40 2158 46 334 41 59 2003 46 2159 40 2160 40 648 44 2153 41 41 59 2161 40 2162 40 2163 44 2153 41 41 59 125 64 2005 439 492 2164 40 41 123 2165 2166 61 648 59 392 40 2167 46 2168 40 648 41 46 2169 40 648 41 41 123 2166 61 648 59 125 2003 46 2170 40 2171 46 334 41 59 2003 46 2172 40 2173 40 648 44 2166 41 41 59 2174 40 2175 40 2176 44 2166 41 41 59 125 64 2005 439 492 2177 40 41 470 2054 123 2178 2179 61 2178 46 2180 40 648 44 648 41 59 474 40 2181 2182 61 418 2181 40 2179 41 41 123 2182 46 2183 40 418 2184 40 2185 44 648 41 41 59 125 2003 46 2186 40 2187 46 334 41 59 2003 46 2188 40 2189 40 648 44 2190 41 41 59 2191 40 2192 40 2190 44 2179 46 2193 40 41 41 41 59 125 64 2005 439 492 2194 40 41 470 2054 123 2195 2196 61 2195 46 2197 40 648 44 648 41 59 2198 2199 61 2200 40 2201 40 2202 44 2196 46 2203 40 41 41 41 59 2204 40 2199 46 2196 44 2205 40 2196 41 41 59 125 64 2005 439 492 2206 40 41 470 2054 123 2207 2208 61 2209 46 2210 40 648 44 648 41 46 2211 40 41 59 2207 2212 61 2208 46 2213 40 41 59 2214 2215 61 2208 46 2216 40 41 59 2217 2218 61 2219 40 2220 40 2221 44 2212 41 44 2220 40 2222 44 2215 41 41 59 2223 40 2218 46 2208 44 2224 40 2208 41 41 59 125 64 2005 439 492 2225 40 41 470 2054 123 2226 2227 61 2226 46 2228 40 648 44 648 41 59 474 40 2229 2230 61 418 2229 40 2227 41 41 123 2230 46 2231 40 418 2232 40 2233 44 648 41 41 59 125 2234 2235 61 2236 40 2237 40 2238 44 2227 46 2239 40 41 41 41 59 2240 40 2235 46 2241 44 2242 40 648 41 41 59 2240 40 2235 46 2243 44 2242 40 2235 46 2244 41 41 59 2240 40 2235 46 2245 44 2242 40 418 2226 40 2235 46 2243 44 2235 46 2241 41 41 41 59 2240 40 2235 46 2227 44 2242 40 2227 41 41 59 125 64 2005 439 492 2246 40 41 123 2247 2248 61 2249 40 2250 40 2251 44 648 41 41 59 2252 40 2248 46 2253 44 2254 40 648 44 648 41 41 59 125 64 2005 439 492 2255 40 41 123 2256 40 418 2257 40 41 46 2258 41 59 2259 40 2260 40 2261 40 2262 41 41 46 2258 41 59 125 64 2005 439 492 2263 40 41 123 2264 2265 61 2266 46 430 59 2264 2267 61 2266 46 2268 59 2269 2270 61 418 2269 40 41 59 2269 2271 61 418 2269 40 41 59 474 40 2264 2272 61 418 2264 40 2270 41 59 2264 2273 61 418 2264 40 2271 41 41 123 2266 46 2274 40 2272 41 59 2266 46 2275 40 2273 41 59 418 2276 40 41 59 2277 40 2270 46 2278 40 41 44 2279 40 41 41 59 2277 40 2271 46 2278 40 41 44 2279 40 41 41 59 125 382 123 2266 46 2280 40 2265 41 59 2266 46 2281 40 2267 41 59 125 125 64 2005 439 492 2282 40 41 123 2283 2284 61 418 2283 40 41 59 2285 40 2284 46 2286 46 2287 40 41 41 59 2285 40 2284 46 2288 46 2287 40 41 41 59 2285 40 2284 46 2289 46 2287 40 41 41 59 2285 40 2284 46 2290 46 2287 40 41 41 59 2285 40 2284 46 2291 46 2287 40 41 41 59 125 64 2005 439 492 2292 40 41 470 2054 123 621 2293 2294 61 2295 46 2296 40 648 44 648 41 46 2297 40 41 59 2003 46 2298 40 2299 46 334 41 59 2003 46 2300 40 2301 40 648 41 41 59 2003 46 2300 40 2301 40 648 41 41 59 2302 40 2303 40 2304 44 2294 41 41 59 125 64 2005 439 492 2305 40 41 470 2054 123 2306 2307 61 2308 46 2309 40 648 41 59 2306 2310 61 2307 46 2311 40 648 41 59 2306 2312 61 2307 46 2311 40 648 41 59 2308 46 2313 40 2310 41 59 474 123 2308 46 2314 40 2312 44 2310 41 59 125 329 40 2315 2316 41 123 621 621 450 59 125 2317 40 2318 40 2319 44 2312 41 41 59 125 621 457 2320 2321 40 2322 613 2323 41 123 2324 91 93 2325 61 418 2324 91 2323 46 2326 93 59 385 40 404 2327 61 1500 59 2327 60 2323 46 2326 59 2327 637 41 2325 91 2327 93 61 2323 91 2327 93 46 2328 40 41 59 450 418 2320 40 2325 41 59 125 457 2322 2329 40 2330 2331 41 123 450 418 2322 40 2331 41 59 125 457 2322 2329 40 2330 2331 44 2332 2333 41 123 450 418 2322 40 2331 44 2333 46 2334 40 41 41 59 125 457 334 2322 123 437 381 2330 2331 59 437 381 2330 2333 59 439 2322 40 2330 2331 41 123 467 40 2331 44 424 41 59 125 439 2322 40 2330 2331 44 2330 2333 41 123 467 46 2331 61 2331 59 467 46 2333 61 2333 59 125 64 2335 439 2330 2336 40 41 123 450 2337 40 648 44 2331 44 2333 631 424 63 40 648 43 2333 41 58 648 41 59 125 125 125 
2516,Java,"public final class PathingBehavior extends Behavior implements IPathingBehavior, Helper {

    private PathExecutor current;
    private PathExecutor next;

    private Goal goal;
    private CalculationContext context;

    /*eta*/
    private int ticksElapsedSoFar;
    private BetterBlockPos startPosition;

    private boolean safeToCancel;
    private boolean pauseRequestedLastTick;
    private boolean unpausedLastTick;
    private boolean pausedThisTick;
    private boolean cancelRequested;
    private boolean calcFailedLastTick;

    private volatile AbstractNodeCostSearch inProgress;
    private final Object pathCalcLock = new Object();

    private final Object pathPlanLock = new Object();

    private boolean lastAutoJump;

    private BetterBlockPos expectedSegmentStart;

    private final LinkedBlockingQueue<PathEvent> toDispatch = new LinkedBlockingQueue<>();

    public PathingBehavior(Baritone baritone) {
        super(baritone);
    }

    private void queuePathEvent(PathEvent event) {
        toDispatch.add(event);
    }

    private void dispatchEvents() {
        ArrayList<PathEvent> curr = new ArrayList<>();
        toDispatch.drainTo(curr);
        calcFailedLastTick = curr.contains(PathEvent.CALC_FAILED);
        for (PathEvent event : curr) {
            baritone.getGameEventHandler().onPathEvent(event);
        }
    }

    @Override
    public void onTick(TickEvent event) {
        dispatchEvents();
        if (event.getType() == TickEvent.Type.OUT) {
            secretInternalSegmentCancel();
            baritone.getPathingControlManager().cancelEverything();
            return;
        }
        expectedSegmentStart = pathStart();
        baritone.getPathingControlManager().preTick();
        tickPath();
        ticksElapsedSoFar++;
        dispatchEvents();
    }

    @Override
    public void onPlayerSprintState(SprintStateEvent event) {
        if (isPathing()) {
            event.setState(current.isSprinting());
        }
    }

    private void tickPath() {
        pausedThisTick = false;
        if (pauseRequestedLastTick && safeToCancel) {
            pauseRequestedLastTick = false;
            if (unpausedLastTick) {
                baritone.getInputOverrideHandler().clearAllKeys();
                baritone.getInputOverrideHandler().getBlockBreakHelper().stopBreakingBlock();
            }
            unpausedLastTick = false;
            pausedThisTick = true;
            return;
        }
        unpausedLastTick = true;
        if (cancelRequested) {
            cancelRequested = false;
            baritone.getInputOverrideHandler().clearAllKeys();
        }
        synchronized (pathPlanLock) {
            synchronized (pathCalcLock) {
                if (inProgress != null) {
                    // we are calculating
                    // are we calculating the right thing though? 🤔
                    BetterBlockPos calcFrom = inProgress.getStart();
                    Optional<IPath> currentBest = inProgress.bestPathSoFar();
                    if ((current == null || !current.getPath().getDest().equals(calcFrom)) // if current ends in inProgress's start, then we're ok
                            && !calcFrom.equals(ctx.playerFeet()) && !calcFrom.equals(expectedSegmentStart) // if current starts in our playerFeet or pathStart, then we're ok
                            && (!currentBest.isPresent() || (!currentBest.get().positions().contains(ctx.playerFeet()) && !currentBest.get().positions().contains(expectedSegmentStart))) // if
                    ) {
                        // when it was *just* started, currentBest will be empty so we need to also check calcFrom since that's always present
                        inProgress.cancel(); // cancellation doesn't dispatch any events
                    }
                }
            }
            if (current == null) {
                return;
            }
            safeToCancel = current.onTick();
            if (current.failed() || current.finished()) {
                current = null;
                if (goal == null || goal.isInGoal(ctx.playerFeet())) {
                    logDebug(""All done. At "" + goal);
                    queuePathEvent(PathEvent.AT_GOAL);
                    next = null;
                    if (Baritone.settings().disconnectOnArrival.value) {
                        ctx.world().sendQuittingDisconnectingPacket();
                    }
                    return;
                }
                if (next != null && !next.getPath().positions().contains(ctx.playerFeet()) && !next.getPath().positions().contains(expectedSegmentStart)) { // can contain either one
                    // if the current path failed, we may not actually be on the next one, so make sure
                    logDebug(""Discarding next path as it does not contain current position"");
                    // for example if we had a nicely planned ahead path that starts where current ends
                    // that's all fine and good
                    // but if we fail in the middle of current
                    // we're nowhere close to our planned ahead path
                    // so need to discard it sadly.
                    queuePathEvent(PathEvent.DISCARD_NEXT);
                    next = null;
                }
                if (next != null) {
                    logDebug(""Continuing on to planned next path"");
                    queuePathEvent(PathEvent.CONTINUING_ONTO_PLANNED_NEXT);
                    current = next;
                    next = null;
                    current.onTick(); // don't waste a tick doing nothing, get started right away
                    return;
                }
                // at this point, current just ended, but we aren't in the goal and have no plan for the future
                synchronized (pathCalcLock) {
                    if (inProgress != null) {
                        queuePathEvent(PathEvent.PATH_FINISHED_NEXT_STILL_CALCULATING);
                        return;
                    }
                    // we aren't calculating
                    queuePathEvent(PathEvent.CALC_STARTED);
                    findPathInNewThread(expectedSegmentStart, true, context);
                }
                return;
            }
            // at this point, we know current is in progress
            if (safeToCancel && next != null && next.snipsnapifpossible()) {
                // a movement just ended; jump directly onto the next path
                logDebug(""Splicing into planned next path early..."");
                queuePathEvent(PathEvent.SPLICING_ONTO_NEXT_EARLY);
                current = next;
                next = null;
                current.onTick();
                return;
            }
            if (Baritone.settings().splicePath.value) {
                current = current.trySplice(next);
            }
            if (next != null && current.getPath().getDest().equals(next.getPath().getDest())) {
                next = null;
            }
            synchronized (pathCalcLock) {
                if (inProgress != null) {
                    // if we aren't calculating right now
                    return;
                }
                if (next != null) {
                    // and we have no plan for what to do next
                    return;
                }
                if (goal == null || goal.isInGoal(current.getPath().getDest())) {
                    // and this path doesn't get us all the way there
                    return;
                }
                if (ticksRemainingInSegment(false).get() < Baritone.settings().planningTickLookahead.value) {
                    // and this path has 7.5 seconds or less left
                    // don't include the current movement so a very long last movement (e.g. descend) doesn't trip it up
                    // if we actually included current, it wouldn't start planning ahead until the last movement was done, if the last movement took more than 7.5 seconds on its own
                    logDebug(""Path almost over. Planning ahead..."");
                    queuePathEvent(PathEvent.NEXT_SEGMENT_CALC_STARTED);
                    findPathInNewThread(current.getPath().getDest(), false, context);
                }
            }
        }
    }

    @Override
    public void onPlayerUpdate(PlayerUpdateEvent event) {
        if (current != null) {
            switch (event.getState()) {
                case PRE:
                    lastAutoJump = mc.gameSettings.autoJump;
                    mc.gameSettings.autoJump = false;
                    break;
                case POST:
                    mc.gameSettings.autoJump = lastAutoJump;
                    break;
                default:
                    break;
            }
        }
    }

    public void secretInternalSetGoal(Goal goal) {
        this.goal = goal;
    }

    public boolean secretInternalSetGoalAndPath(PathingCommand command) {
        secretInternalSetGoal(command.goal);
        if (command instanceof PathingCommandContext) {
            context = ((PathingCommandContext) command).desiredCalcContext;
        } else {
            context = new CalculationContext(baritone, true);
        }
        if (goal == null) {
            return false;
        }
        if (goal.isInGoal(ctx.playerFeet()) || goal.isInGoal(expectedSegmentStart)) {
            return false;
        }
        synchronized (pathPlanLock) {
            if (current != null) {
                return false;
            }
            synchronized (pathCalcLock) {
                if (inProgress != null) {
                    return false;
                }
                queuePathEvent(PathEvent.CALC_STARTED);
                findPathInNewThread(expectedSegmentStart, true, context);
                return true;
            }
        }
    }

    @Override
    public Goal getGoal() {
        return goal;
    }

    @Override
    public boolean isPathing() {
        return hasPath() && !pausedThisTick;
    }

    @Override
    public PathExecutor getCurrent() {
        return current;
    }

    @Override
    public PathExecutor getNext() {
        return next;
    }

    @Override
    public Optional<AbstractNodeCostSearch> getInProgress() {
        return Optional.ofNullable(inProgress);
    }

    public boolean isSafeToCancel() {
        return current == null || safeToCancel;
    }

    public void requestPause() {
        pauseRequestedLastTick = true;
    }

    public boolean cancelSegmentIfSafe() {
        if (isSafeToCancel()) {
            secretInternalSegmentCancel();
            return true;
        }
        return false;
    }

    @Override
    public boolean cancelEverything() {
        boolean doIt = isSafeToCancel();
        if (doIt) {
            secretInternalSegmentCancel();
        }
        baritone.getPathingControlManager().cancelEverything(); // regardless of if we can stop the current segment, we can still stop the processes
        return doIt;
    }

    public boolean calcFailedLastTick() { // NOT exposed on public api
        return calcFailedLastTick;
    }

    public void softCancelIfSafe() {
        synchronized (pathPlanLock) {
            getInProgress().ifPresent(AbstractNodeCostSearch::cancel); // only cancel ours
            if (!isSafeToCancel()) {
                return;
            }
            current = null;
            next = null;
        }
        cancelRequested = true;
        // do everything BUT clear keys
    }

    // just cancel the current path
    private void secretInternalSegmentCancel() {
        queuePathEvent(PathEvent.CANCELED);
        synchronized (pathPlanLock) {
            getInProgress().ifPresent(AbstractNodeCostSearch::cancel);
            if (current != null) {
                current = null;
                next = null;
                baritone.getInputOverrideHandler().clearAllKeys();
                baritone.getInputOverrideHandler().getBlockBreakHelper().stopBreakingBlock();
            }
        }
    }

    @Override
    public void forceCancel() { // exposed on public api because :sob:
        cancelEverything();
        secretInternalSegmentCancel();
        synchronized (pathCalcLock) {
            inProgress = null;
        }
    }

    public CalculationContext secretInternalGetCalculationContext() {
        return context;
    }

    public Optional<Double> estimatedTicksToGoal() {
        BetterBlockPos currentPos = ctx.playerFeet();
        if (goal == null || currentPos == null || startPosition == null) {
            return Optional.empty();
        }
        if (goal.isInGoal(ctx.playerFeet())) {
            resetEstimatedTicksToGoal();
            return Optional.of(0.0);
        }
        if (ticksElapsedSoFar == 0) {
            return Optional.empty();
        }
        double current = goal.heuristic(currentPos.x, currentPos.y, currentPos.z);
        double start = goal.heuristic(startPosition.x, startPosition.y, startPosition.z);
        if (current == start) {// can't check above because current and start can be equal even if currentPos and startPosition are not
            return Optional.empty();
        }
        double eta = Math.abs(current - goal.heuristic()) * ticksElapsedSoFar / Math.abs(start - current);
        return Optional.of(eta);
    }

    private void resetEstimatedTicksToGoal() {
        resetEstimatedTicksToGoal(expectedSegmentStart);
    }

    private void resetEstimatedTicksToGoal(BlockPos start) {
        resetEstimatedTicksToGoal(new BetterBlockPos(start));
    }

    private void resetEstimatedTicksToGoal(BetterBlockPos start) {
        ticksElapsedSoFar = 0;
        startPosition = start;
    }

    /**
     * See issue #209
     *
     * @return The starting {@link BlockPos} for a new path
     */
    public BetterBlockPos pathStart() { // TODO move to a helper or util class
        BetterBlockPos feet = ctx.playerFeet();
        if (!MovementHelper.canWalkOn(ctx, feet.down())) {
            if (ctx.player().onGround) {
                double playerX = ctx.player().posX;
                double playerZ = ctx.player().posZ;
                ArrayList<BetterBlockPos> closest = new ArrayList<>();
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dz = -1; dz <= 1; dz++) {
                        closest.add(new BetterBlockPos(feet.x + dx, feet.y, feet.z + dz));
                    }
                }
                closest.sort(Comparator.comparingDouble(pos -> ((pos.x + 0.5D) - playerX) * ((pos.x + 0.5D) - playerX) + ((pos.z + 0.5D) - playerZ) * ((pos.z + 0.5D) - playerZ)));
                for (int i = 0; i < 4; i++) {
                    BetterBlockPos possibleSupport = closest.get(i);
                    double xDist = Math.abs((possibleSupport.x + 0.5D) - playerX);
                    double zDist = Math.abs((possibleSupport.z + 0.5D) - playerZ);
                    if (xDist > 0.8 && zDist > 0.8) {
                        // can't possibly be sneaking off of this one, we're too far away
                        continue;
                    }
                    if (MovementHelper.canWalkOn(ctx, possibleSupport.down()) && MovementHelper.canWalkThrough(ctx, possibleSupport) && MovementHelper.canWalkThrough(ctx, possibleSupport.up())) {
                        // this is plausible
                        //logDebug(""Faking path start assuming player is standing off the edge of a block"");
                        return possibleSupport;
                    }
                }

            } else {
                // !onGround
                // we're in the middle of a jump
                if (MovementHelper.canWalkOn(ctx, feet.down().down())) {
                    //logDebug(""Faking path start assuming player is midair and falling"");
                    return feet.down();
                }
            }
        }
        return feet;
    }

    /**
     * In a new thread, pathfind to target blockpos
     *
     * @param start
     * @param talkAboutIt
     */
    private void findPathInNewThread(final BlockPos start, final boolean talkAboutIt, CalculationContext context) {
        // this must be called with synchronization on pathCalcLock!
        // actually, we can check this, muahaha
        if (!Thread.holdsLock(pathCalcLock)) {
            throw new IllegalStateException(""Must be called with synchronization on pathCalcLock"");
            // why do it this way? it's already indented so much that putting the whole thing in a synchronized(pathCalcLock) was just too much lol
        }
        if (inProgress != null) {
            throw new IllegalStateException(""Already doing it""); // should have been checked by caller
        }
        if (!context.safeForThreadedUse) {
            throw new IllegalStateException(""Improper context thread safety level"");
        }
        Goal goal = this.goal;
        if (goal == null) {
            logDebug(""no goal""); // TODO should this be an exception too? definitely should be checked by caller
            return;
        }
        long primaryTimeout;
        long failureTimeout;
        if (current == null) {
            primaryTimeout = Baritone.settings().primaryTimeoutMS.value;
            failureTimeout = Baritone.settings().failureTimeoutMS.value;
        } else {
            primaryTimeout = Baritone.settings().planAheadPrimaryTimeoutMS.value;
            failureTimeout = Baritone.settings().planAheadFailureTimeoutMS.value;
        }
        AbstractNodeCostSearch pathfinder = createPathfinder(start, goal, current == null ? null : current.getPath(), context);
        if (!Objects.equals(pathfinder.getGoal(), goal)) { // will return the exact same object if simplification didn't happen
            logDebug(""Simplifying "" + goal.getClass() + "" to GoalXZ due to distance"");
        }
        inProgress = pathfinder;
        Baritone.getExecutor().execute(() -> {
            if (talkAboutIt) {
                logDebug(""Starting to search for path from "" + start + "" to "" + goal);
            }

            PathCalculationResult calcResult = pathfinder.calculate(primaryTimeout, failureTimeout);
            synchronized (pathPlanLock) {
                Optional<PathExecutor> executor = calcResult.getPath().map(p -> new PathExecutor(PathingBehavior.this, p));
                if (current == null) {
                    if (executor.isPresent()) {
                        if (executor.get().getPath().positions().contains(expectedSegmentStart)) {
                            queuePathEvent(PathEvent.CALC_FINISHED_NOW_EXECUTING);
                            current = executor.get();
                            resetEstimatedTicksToGoal(start);
                        } else {
                            logDebug(""Warning: discarding orphan path segment with incorrect start"");
                        }
                    } else {
                        if (calcResult.getType() != PathCalculationResult.Type.CANCELLATION && calcResult.getType() != PathCalculationResult.Type.EXCEPTION) {
                            // don't dispatch CALC_FAILED on cancellation
                            queuePathEvent(PathEvent.CALC_FAILED);
                        }
                    }
                } else {
                    if (next == null) {
                        if (executor.isPresent()) {
                            if (executor.get().getPath().getSrc().equals(current.getPath().getDest())) {
                                queuePathEvent(PathEvent.NEXT_SEGMENT_CALC_FINISHED);
                                next = executor.get();
                            } else {
                                logDebug(""Warning: discarding orphan next segment with incorrect start"");
                            }
                        } else {
                            queuePathEvent(PathEvent.NEXT_CALC_FAILED);
                        }
                    } else {
                        //throw new IllegalStateException(""I have no idea what to do with this path"");
                        // no point in throwing an exception here, and it gets it stuck with inProgress being not null
                        logDirect(""Warning: PathingBehaivor illegal state! Discarding invalid path!"");
                    }
                }
                if (talkAboutIt && current != null && current.getPath() != null) {
                    if (goal.isInGoal(current.getPath().getDest())) {
                        logDebug(""Finished finding a path from "" + start + "" to "" + goal + "". "" + current.getPath().getNumNodesConsidered() + "" nodes considered"");
                    } else {
                        logDebug(""Found path segment from "" + start + "" towards "" + goal + "". "" + current.getPath().getNumNodesConsidered() + "" nodes considered"");
                    }
                }
                synchronized (pathCalcLock) {
                    inProgress = null;
                }
            }
        });
    }

    private static AbstractNodeCostSearch createPathfinder(BlockPos start, Goal goal, IPath previous, CalculationContext context) {
        Goal transformed = goal;
        if (Baritone.settings().simplifyUnloadedYCoord.value && goal instanceof IGoalRenderPos) {
            BlockPos pos = ((IGoalRenderPos) goal).getGoalPos();
            if (!context.bsi.worldContainsLoadedChunk(pos.getX(), pos.getZ())) {
                transformed = new GoalXZ(pos.getX(), pos.getZ());
            }
        }
        Favoring favoring = new Favoring(context.getBaritone().getPlayerContext(), previous, context);
        return new AStarPathFinder(start.getX(), start.getY(), start.getZ(), transformed, favoring, context);
    }

    @Override
    public void onRenderPass(RenderEvent event) {
        PathRenderer.render(event, this);
    }
}",1,439 381 334 2000 378 2001 395 2002 44 2003 123 437 2004 2005 59 437 2004 2006 59 437 2007 2008 59 437 2009 2010 59 604 437 404 2011 59 437 2012 2013 59 437 324 2014 59 437 324 2015 59 437 324 2016 59 437 324 2017 59 437 324 2018 59 437 324 2019 59 437 493 2020 2021 59 437 381 2022 2023 61 418 2022 40 41 59 437 381 2022 2024 61 418 2022 40 41 59 437 324 2025 59 437 2012 2026 59 437 381 2027 60 2028 62 2029 61 418 2027 60 62 40 41 59 439 2000 40 2030 2031 41 123 463 40 2031 41 59 125 437 492 2032 40 2028 373 41 123 2029 46 2033 40 373 41 59 125 437 492 2034 40 41 123 2035 60 2028 62 2036 61 418 2035 60 62 40 41 59 2029 46 2037 40 2036 41 59 2019 61 2036 46 2038 40 2028 46 2039 41 59 385 40 2028 373 58 2036 41 123 2031 46 2040 40 41 46 2041 40 373 41 59 125 125 64 2042 439 492 2043 40 2044 373 41 123 2034 40 41 59 392 40 373 46 2045 40 41 614 2044 46 2046 46 2047 41 123 2048 40 41 59 2031 46 2049 40 41 46 2050 40 41 59 450 59 125 2026 61 2051 40 41 59 2031 46 2052 40 41 46 2053 40 41 59 2054 40 41 59 2011 637 59 2034 40 41 59 125 64 2042 439 492 2055 40 2056 373 41 123 392 40 2057 40 41 41 123 373 46 2058 40 2005 46 2059 40 41 41 59 125 125 437 492 2060 40 41 123 2017 61 380 59 392 40 2015 605 2014 41 123 2015 61 380 59 392 40 2016 41 123 2031 46 2061 40 41 46 2062 40 41 59 2031 46 2061 40 41 46 2063 40 41 46 2064 40 41 59 125 2016 61 380 59 2017 61 473 59 450 59 125 2016 61 473 59 392 40 2018 41 123 2018 61 380 59 2031 46 2065 40 41 46 2066 40 41 59 125 465 40 2024 41 123 465 40 2023 41 123 392 40 2021 631 424 41 123 621 621 2012 2067 61 2021 46 2068 40 41 59 2069 60 2070 62 2071 61 2021 46 2072 40 41 59 392 40 40 2005 614 424 606 33 2005 46 2073 40 41 46 2074 40 41 46 2075 40 2067 41 41 621 605 33 2067 46 2075 40 2076 46 2077 40 41 41 605 33 2067 46 2075 40 2026 41 621 605 40 33 2071 46 2078 40 41 606 40 33 2071 46 2079 40 41 46 2080 40 41 46 2081 40 2076 46 2077 40 41 41 605 33 2071 46 2079 40 41 46 2080 40 41 46 2081 40 2026 41 41 41 621 41 123 621 2021 46 2082 40 41 59 621 125 125 125 392 40 2005 614 424 41 123 450 59 125 2014 61 2005 46 2043 40 41 59 392 40 2005 46 2083 40 41 606 2005 46 2084 40 41 41 123 2005 61 424 59 392 40 2008 614 424 606 2008 46 2085 40 2086 46 2087 40 41 41 41 123 2088 40 648 43 2008 41 59 2032 40 2028 46 2089 41 59 2006 61 424 59 392 40 2030 46 2090 40 41 46 2091 46 2092 41 123 2086 46 2093 40 41 46 2094 40 41 59 125 450 59 125 392 40 2006 631 424 605 33 2006 46 2095 40 41 46 2096 40 41 46 2097 40 2086 46 2087 40 41 41 605 33 2006 46 2095 40 41 46 2096 40 41 46 2097 40 2026 41 41 123 621 621 2098 40 648 41 59 621 621 621 621 621 2032 40 2028 46 2099 41 59 2006 61 424 59 125 392 40 2006 631 424 41 123 2100 40 648 41 59 2032 40 2028 46 2101 41 59 2005 61 2006 59 2006 61 424 59 2005 46 2043 40 41 59 621 450 59 125 621 465 40 2023 41 123 392 40 2021 631 424 41 123 2032 40 2028 46 2102 41 59 450 59 125 621 2032 40 2028 46 2103 41 59 2104 40 2026 44 473 44 2010 41 59 125 450 59 125 621 392 40 2014 605 2006 631 424 605 2006 46 2105 40 41 41 123 621 2106 40 648 41 59 2032 40 2028 46 2107 41 59 2005 61 2006 59 2006 61 424 59 2005 46 2043 40 41 59 450 59 125 392 40 2030 46 2108 40 41 46 2109 46 2110 41 123 2005 61 2005 46 2111 40 2006 41 59 125 392 40 2006 631 424 605 2005 46 2112 40 41 46 2113 40 41 46 2114 40 2006 46 2112 40 41 46 2113 40 41 41 41 123 2006 61 424 59 125 465 40 2023 41 123 392 40 2021 631 424 41 123 621 450 59 125 392 40 2006 631 424 41 123 621 450 59 125 392 40 2008 614 424 606 2008 46 2115 40 2005 46 2112 40 41 46 2113 40 41 41 41 123 621 450 59 125 392 40 2116 40 380 41 46 2117 40 41 60 2030 46 2108 40 41 46 2118 46 2110 41 123 621 621 621 2119 40 648 41 59 2032 40 2028 46 2120 41 59 2121 40 2005 46 2112 40 41 46 2113 40 41 44 380 44 2010 41 59 125 125 125 125 64 2042 439 492 2122 40 2123 373 41 123 392 40 2005 631 424 41 123 464 40 373 46 2124 40 41 41 123 328 2125 58 2025 61 2126 46 2127 46 2128 59 2126 46 2127 46 2128 61 380 59 325 59 328 2129 58 2126 46 2127 46 2128 61 2025 59 325 59 349 58 325 59 125 125 125 439 492 2130 40 2007 2008 41 123 467 46 2008 61 2008 59 125 439 324 2131 40 2132 2133 41 123 2130 40 2133 46 2008 41 59 392 40 2133 402 2134 41 123 2010 61 40 40 2134 41 2133 41 46 2135 59 125 360 123 2010 61 418 2009 40 2031 44 473 41 59 125 392 40 2008 614 424 41 123 450 380 59 125 392 40 2008 46 2136 40 2137 46 2138 40 41 41 606 2008 46 2136 40 2026 41 41 123 450 380 59 125 465 40 2024 41 123 392 40 2005 631 424 41 123 450 380 59 125 465 40 2023 41 123 392 40 2021 631 424 41 123 450 380 59 125 2032 40 2028 46 2139 41 59 2140 40 2026 44 473 44 2010 41 59 450 473 59 125 125 125 64 2042 439 2007 2141 40 41 123 450 2008 59 125 64 2042 439 324 2142 40 41 123 450 2143 40 41 605 33 2017 59 125 64 2042 439 2004 2144 40 41 123 450 2005 59 125 64 2042 439 2004 2145 40 41 123 450 2006 59 125 64 2042 439 2146 60 2020 62 2147 40 41 123 450 2146 46 2148 40 2021 41 59 125 439 324 2149 40 41 123 450 2005 614 424 606 2014 59 125 439 492 2150 40 41 123 2015 61 473 59 125 439 324 2151 40 41 123 392 40 2149 40 41 41 123 2152 40 41 59 450 473 59 125 450 380 59 125 64 2042 439 324 2153 40 41 123 324 2154 61 2149 40 41 59 392 40 2154 41 123 2155 40 41 59 125 2031 46 2156 40 41 46 2153 40 41 59 621 450 2154 59 125 439 324 2019 40 41 123 621 450 2019 59 125 439 492 2157 40 41 123 465 40 2024 41 123 2147 40 41 46 2158 40 2020 58 58 2159 41 59 621 392 40 33 2149 40 41 41 123 450 59 125 2005 61 424 59 2006 61 424 59 125 2018 61 473 59 621 125 621 437 492 2160 40 41 123 2032 40 2028 46 2161 41 59 465 40 2024 41 123 2147 40 41 46 2162 40 2020 58 58 2163 41 59 392 40 2005 631 424 41 123 2005 61 424 59 2006 61 424 59 2031 46 2164 40 41 46 2165 40 41 59 2031 46 2164 40 41 46 2166 40 41 46 2167 40 41 59 125 125 125 64 2042 439 492 2168 40 41 123 621 2153 40 41 59 2160 40 41 59 465 40 2023 41 123 2021 61 424 59 125 125 439 2009 2169 40 41 123 450 2010 59 125 439 2146 60 2170 62 2171 40 41 123 2012 2172 61 2173 46 2174 40 41 59 392 40 2008 614 424 606 2172 614 424 606 2013 614 424 41 123 450 2146 46 362 40 41 59 125 392 40 2008 46 2175 40 2173 46 2174 40 41 41 41 123 2176 40 41 59 450 2146 46 2177 40 1500 41 59 125 392 40 2011 614 1500 41 123 450 2146 46 362 40 41 59 125 356 2005 61 2008 46 2178 40 2172 46 2179 44 2172 46 2180 44 2172 46 2181 41 59 356 2182 61 2008 46 2178 40 2013 46 2179 44 2013 46 2180 44 2013 46 2181 41 59 392 40 2005 614 2182 41 123 621 450 2146 46 362 40 41 59 125 356 2183 61 2184 46 2185 40 2005 45 2008 46 2178 40 41 41 42 2011 47 2184 46 2185 40 2182 45 2005 41 59 450 2146 46 2186 40 2183 41 59 125 437 492 2187 40 41 123 2187 40 2026 41 59 125 437 492 2187 40 2188 2189 41 123 2187 40 418 2012 40 2189 41 41 59 125 437 492 2187 40 2012 2189 41 123 2011 61 1500 59 2013 61 2189 59 125 618 439 2012 2190 40 41 123 621 2012 2191 61 2192 46 2193 40 41 59 392 40 33 2194 46 2195 40 2192 44 2191 46 2196 40 41 41 41 123 392 40 2192 46 2197 40 41 46 2198 41 123 356 2199 61 2192 46 2197 40 41 46 2200 59 356 2201 61 2192 46 2197 40 41 46 2202 59 2203 60 2012 62 2204 61 418 2203 60 62 40 41 59 385 40 404 2205 61 45 1501 59 2205 620 1501 59 2205 637 41 123 385 40 404 2206 61 45 1501 59 2206 620 1501 59 2206 637 41 123 2204 46 2207 40 418 2012 40 2191 46 2208 43 2205 44 2191 46 2209 44 2191 46 2210 43 2206 41 41 59 125 125 2204 46 2211 40 2212 46 2213 40 2214 45 62 40 40 2214 46 2215 43 1499 41 45 2199 41 42 40 40 2214 46 2215 43 1499 41 45 2199 41 43 40 40 2214 46 2216 43 1499 41 45 2201 41 42 40 40 2214 46 2216 43 1499 41 45 2201 41 41 41 59 385 40 404 2217 61 1500 59 2217 60 1502 59 2217 637 41 123 2012 2218 61 2204 46 2219 40 2217 41 59 356 2220 61 2221 46 2222 40 40 2218 46 2215 43 1499 41 45 2199 41 59 356 2223 61 2221 46 2222 40 40 2218 46 2216 43 1499 41 45 2201 41 59 392 40 2220 62 1499 605 2223 62 1499 41 123 621 344 59 125 392 40 2194 46 2195 40 2192 44 2218 46 2196 40 41 41 605 2194 46 2224 40 2192 44 2218 41 605 2194 46 2224 40 2192 44 2218 46 2225 40 41 41 41 123 621 621 450 2218 59 125 125 125 360 123 621 621 392 40 2194 46 2195 40 2192 44 2191 46 2196 40 41 46 2196 40 41 41 41 123 621 450 2191 46 2196 40 41 59 125 125 125 450 2191 59 125 618 437 492 2226 40 381 2188 2189 44 381 324 2227 44 2009 2010 41 123 621 621 392 40 33 2228 46 2229 40 2023 41 41 123 469 418 2230 40 648 41 59 621 125 392 40 2021 631 424 41 123 469 418 2231 40 648 41 59 621 125 392 40 33 2010 46 2232 41 123 469 418 2233 40 648 41 59 125 2007 2008 61 467 46 2008 59 392 40 2008 614 424 41 123 2234 40 648 41 59 621 450 59 125 413 2235 59 413 2236 59 392 40 2005 614 424 41 123 2235 61 2030 46 2237 40 41 46 2238 46 2239 59 2236 61 2030 46 2237 40 41 46 2240 46 2239 59 125 360 123 2235 61 2030 46 2241 40 41 46 2242 46 2243 59 2236 61 2030 46 2241 40 41 46 2244 46 2243 59 125 2020 2245 61 2246 40 2189 44 2008 44 2005 614 424 63 424 58 2005 46 2247 40 41 44 2010 41 59 392 40 33 2248 46 2249 40 2245 46 2141 40 41 44 2008 41 41 123 621 2250 40 648 43 2008 46 2251 40 41 43 648 41 59 125 2021 61 2245 59 2030 46 2252 40 41 46 2253 40 40 41 45 62 123 392 40 2227 41 123 2254 40 648 43 2189 43 648 43 2008 41 59 125 2255 2256 61 2245 46 2257 40 2235 44 2236 41 59 465 40 2024 41 123 2146 60 2004 62 2258 61 2256 46 2247 40 41 46 2259 40 2260 45 62 418 2004 40 2000 46 467 44 2260 41 41 59 392 40 2005 614 424 41 123 392 40 2258 46 2261 40 41 41 123 392 40 2258 46 2262 40 41 46 2247 40 41 46 2263 40 41 46 2264 40 2026 41 41 123 2032 40 2028 46 2265 41 59 2005 61 2258 46 2262 40 41 59 2187 40 2189 41 59 125 360 123 2266 40 648 41 59 125 125 360 123 392 40 2256 46 2267 40 41 631 2255 46 2268 46 2269 605 2256 46 2267 40 41 631 2255 46 2268 46 2270 41 123 621 2032 40 2028 46 2271 41 59 125 125 125 360 123 392 40 2006 614 424 41 123 392 40 2258 46 2272 40 41 41 123 392 40 2258 46 2273 40 41 46 2247 40 41 46 2274 40 41 46 2249 40 2005 46 2247 40 41 46 2275 40 41 41 41 123 2032 40 2028 46 2276 41 59 2006 61 2258 46 2273 40 41 59 125 360 123 2277 40 648 41 59 125 125 360 123 2032 40 2028 46 2278 41 59 125 125 360 123 621 621 2279 40 648 41 59 125 125 392 40 2227 605 2005 631 424 605 2005 46 2247 40 41 631 424 41 123 392 40 2008 46 2280 40 2005 46 2247 40 41 46 2281 40 41 41 41 123 2282 40 648 43 2189 43 648 43 2008 43 648 43 2005 46 2247 40 41 46 2283 40 41 43 648 41 59 125 360 123 2284 40 648 43 2189 43 648 43 2008 43 648 43 2005 46 2247 40 41 46 2285 40 41 43 648 41 59 125 125 465 40 2023 41 123 2021 61 424 59 125 125 125 41 59 125 437 457 2020 2286 40 2188 2189 44 2007 2008 44 2287 2288 44 2009 2010 41 123 2007 2289 61 2008 59 392 40 2030 46 2290 40 41 46 2291 46 2292 605 2008 402 2293 41 123 2188 2294 61 40 40 2293 41 2008 41 46 2295 40 41 59 392 40 33 2010 46 2296 46 2297 40 2294 46 2298 40 41 44 2294 46 2299 40 41 41 41 123 2289 61 418 2300 40 2294 46 2298 40 41 44 2294 46 2299 40 41 41 59 125 125 2301 2302 61 418 2301 40 2010 46 2303 40 41 46 2304 40 41 44 2288 44 2010 41 59 450 418 2305 40 2189 46 2306 40 41 44 2189 46 2307 40 41 44 2189 46 2308 40 41 44 2289 44 2302 44 2010 41 59 125 64 2042 439 492 2309 40 2310 373 41 123 2311 46 2312 40 373 44 467 41 59 125 125 
5166,Java,"@FxmlView
public class AccountView extends ActivatableView<TabPane, Void> {

    @FXML
    Tab fiatAccountsTab, altcoinAccountsTab, notificationTab,
            passwordTab, seedWordsTab, walletInfoTab, backupTab;

    private Navigation.Listener navigationListener;
    private ChangeListener<Tab> tabChangeListener;

    private final ViewLoader viewLoader;
    private final Navigation navigation;
    private Tab selectedTab;
    private Tab arbitratorRegistrationTab;
    private Tab mediatorRegistrationTab;
    private Tab refundAgentRegistrationTab;
    private Tab signingTab;
    private ArbitratorRegistrationView arbitratorRegistrationView;
    private MediatorRegistrationView mediatorRegistrationView;
    private RefundAgentRegistrationView refundAgentRegistrationView;
    private Scene scene;
    private EventHandler<KeyEvent> keyEventEventHandler;
    private ListChangeListener<Tab> tabListChangeListener;

    @Inject
    private AccountView(CachingViewLoader viewLoader, Navigation navigation) {
        this.viewLoader = viewLoader;
        this.navigation = navigation;
    }

    @Override
    public void initialize() {

        root.setTabClosingPolicy(TabPane.TabClosingPolicy.ALL_TABS);

        fiatAccountsTab.setText(Res.get(""account.menu.paymentAccount"").toUpperCase());
        altcoinAccountsTab.setText(Res.get(""account.menu.altCoinsAccountView"").toUpperCase());
        notificationTab.setText(Res.get(""account.menu.notifications"").toUpperCase());
        passwordTab.setText(Res.get(""account.menu.password"").toUpperCase());
        seedWordsTab.setText(Res.get(""account.menu.seedWords"").toUpperCase());
        walletInfoTab.setText(Res.get(""account.menu.walletInfo"").toUpperCase());
        backupTab.setText(Res.get(""account.menu.backup"").toUpperCase());

        navigationListener = (viewPath, data) -> {
            if (viewPath.size() == 3 && viewPath.indexOf(AccountView.class) == 1) {
                if (arbitratorRegistrationTab == null && viewPath.get(2).equals(ArbitratorRegistrationView.class)) {
                    navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
                } else if (mediatorRegistrationTab == null && viewPath.get(2).equals(MediatorRegistrationView.class)) {
                    navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
                } else if (refundAgentRegistrationTab == null && viewPath.get(2).equals(RefundAgentRegistrationView.class)) {
                    navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
                } else if (signingTab == null && viewPath.get(2).equals(SigningView.class)) {
                    navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
                } else {
                    loadView(viewPath.tip());
                }
            } else {
                resetSelectedTab();
            }
        };

        keyEventEventHandler = event -> {
            if (Utilities.isAltOrCtrlPressed(KeyCode.D, event) && mediatorRegistrationTab == null) {
                closeOtherExtraTabs(mediatorRegistrationTab);
                mediatorRegistrationTab = new Tab(Res.get(""account.tab.mediatorRegistration"").toUpperCase());
                mediatorRegistrationTab.setClosable(true);
                root.getTabs().add(mediatorRegistrationTab);
                navigation.navigateTo(MainView.class, AccountView.class, MediatorRegistrationView.class);
            } else if (Utilities.isAltOrCtrlPressed(KeyCode.N, event) && refundAgentRegistrationTab == null) {
                closeOtherExtraTabs(refundAgentRegistrationTab);
                refundAgentRegistrationTab = new Tab(Res.get(""account.tab.refundAgentRegistration"").toUpperCase());
                refundAgentRegistrationTab.setClosable(true);
                root.getTabs().add(refundAgentRegistrationTab);
                navigation.navigateTo(MainView.class, AccountView.class, RefundAgentRegistrationView.class);
            } else if (Utilities.isAltOrCtrlPressed(KeyCode.I, event) && signingTab == null) {
                closeOtherExtraTabs(signingTab);
                signingTab = new Tab(Res.get(""account.tab.signing"").toUpperCase());
                signingTab.setClosable(true);
                root.getTabs().add(signingTab);
                navigation.navigateTo(MainView.class, AccountView.class, SigningView.class);
            }
        };

        tabChangeListener = (ov, oldValue, newValue) -> {
            if (arbitratorRegistrationTab != null && selectedTab != arbitratorRegistrationTab) {
                navigation.navigateTo(MainView.class, AccountView.class, ArbitratorRegistrationView.class);
            } else if (mediatorRegistrationTab != null && selectedTab != mediatorRegistrationTab) {
                navigation.navigateTo(MainView.class, AccountView.class, MediatorRegistrationView.class);
            } else if (refundAgentRegistrationTab != null && selectedTab != refundAgentRegistrationTab) {
                navigation.navigateTo(MainView.class, AccountView.class, RefundAgentRegistrationView.class);
            } else if (signingTab != null && !selectedTab.equals(signingTab)) {
                navigation.navigateTo(MainView.class, AccountView.class, SigningView.class);
            } else if (newValue == fiatAccountsTab && selectedTab != fiatAccountsTab) {
                navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
            } else if (newValue == altcoinAccountsTab && selectedTab != altcoinAccountsTab) {
                navigation.navigateTo(MainView.class, AccountView.class, AltCoinAccountsView.class);
            } else if (newValue == notificationTab && selectedTab != notificationTab) {
                navigation.navigateTo(MainView.class, AccountView.class, MobileNotificationsView.class);
            } else if (newValue == passwordTab && selectedTab != passwordTab) {
                navigation.navigateTo(MainView.class, AccountView.class, PasswordView.class);
            } else if (newValue == seedWordsTab && selectedTab != seedWordsTab) {
                navigation.navigateTo(MainView.class, AccountView.class, SeedWordsView.class);
            } else if (newValue == walletInfoTab && selectedTab != walletInfoTab) {
                navigation.navigateTo(MainView.class, AccountView.class, WalletInfoView.class);
            } else if (newValue == backupTab && selectedTab != backupTab) {
                navigation.navigateTo(MainView.class, AccountView.class, BackupView.class);
            }
        };

        tabListChangeListener = change -> {
            change.next();
            List<? extends Tab> removedTabs = change.getRemoved();
            if (removedTabs.size() == 1 && removedTabs.get(0).equals(arbitratorRegistrationTab))
                onArbitratorRegistrationTabRemoved();

            if (removedTabs.size() == 1 && removedTabs.get(0).equals(mediatorRegistrationTab))
                onMediatorRegistrationTabRemoved();

            if (removedTabs.size() == 1 && removedTabs.get(0).equals(refundAgentRegistrationTab))
                onRefundAgentRegistrationTabRemoved();

            if (removedTabs.size() == 1 && removedTabs.get(0).equals(signingTab))
                onSigningTabRemoved();
        };
    }

    private void closeOtherExtraTabs(Tab newTab) {
        if (arbitratorRegistrationTab != null && !arbitratorRegistrationTab.equals(newTab)) {
            root.getTabs().remove(arbitratorRegistrationTab);
        }
        if (mediatorRegistrationTab != null && !mediatorRegistrationTab.equals(newTab)) {
            root.getTabs().remove(mediatorRegistrationTab);
        }
        if (refundAgentRegistrationTab != null && !refundAgentRegistrationTab.equals(newTab)) {
            root.getTabs().remove(refundAgentRegistrationTab);
        }
        if (signingTab != null && !signingTab.equals(newTab)) {
            root.getTabs().remove(signingTab);
        }
    }

    private void onArbitratorRegistrationTabRemoved() {
        arbitratorRegistrationTab = null;
        navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
    }

    private void onMediatorRegistrationTabRemoved() {
        mediatorRegistrationTab = null;
        navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
    }

    private void onRefundAgentRegistrationTabRemoved() {
        refundAgentRegistrationTab = null;
        navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
    }

    private void onSigningTabRemoved() {
        signingTab = null;
        navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
    }

    @Override
    protected void activate() {
        // Hide account new badge if user saw this section
        DontShowAgainLookup.dontShowAgain(AccountPresentation.ACCOUNT_NEWS, true);

        navigation.addListener(navigationListener);

        root.getSelectionModel().selectedItemProperty().addListener(tabChangeListener);
        root.getTabs().addListener(tabListChangeListener);

        scene = root.getScene();
        if (scene != null)
            scene.addEventHandler(KeyEvent.KEY_RELEASED, keyEventEventHandler);

        if (navigation.getCurrentPath().size() == 2 && navigation.getCurrentPath().get(1) == AccountView.class) {
            if (arbitratorRegistrationTab != null)
                navigation.navigateTo(MainView.class, AccountView.class, ArbitratorRegistrationView.class);
            else if (mediatorRegistrationTab != null)
                navigation.navigateTo(MainView.class, AccountView.class, MediatorRegistrationView.class);
            else if (refundAgentRegistrationTab != null)
                navigation.navigateTo(MainView.class, AccountView.class, RefundAgentRegistrationView.class);
            else if (signingTab != null)
                navigation.navigateTo(MainView.class, AccountView.class, SigningView.class);
            else if (root.getSelectionModel().getSelectedItem() == fiatAccountsTab)
                navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
            else if (root.getSelectionModel().getSelectedItem() == altcoinAccountsTab)
                navigation.navigateTo(MainView.class, AccountView.class, AltCoinAccountsView.class);
            else if (root.getSelectionModel().getSelectedItem() == notificationTab)
                navigation.navigateTo(MainView.class, AccountView.class, MobileNotificationsView.class);
            else if (root.getSelectionModel().getSelectedItem() == passwordTab)
                navigation.navigateTo(MainView.class, AccountView.class, PasswordView.class);
            else if (root.getSelectionModel().getSelectedItem() == seedWordsTab)
                navigation.navigateTo(MainView.class, AccountView.class, SeedWordsView.class);
            else if (root.getSelectionModel().getSelectedItem() == walletInfoTab)
                navigation.navigateTo(MainView.class, AccountView.class, WalletInfoView.class);
            else if (root.getSelectionModel().getSelectedItem() == backupTab)
                navigation.navigateTo(MainView.class, AccountView.class, BackupView.class);
            else
                navigation.navigateTo(MainView.class, AccountView.class, FiatAccountsView.class);
        }

        String key = ""accountPrivacyInfo"";
        if (!DevEnv.isDevMode())
            new Popup()
                    .headLine(Res.get(""account.info.headline""))
                    .backgroundInfo(Res.get(""account.info.msg""))
                    .dontShowAgainId(key)
                    .show();
    }

    @Override
    protected void deactivate() {
        navigation.removeListener(navigationListener);
        root.getSelectionModel().selectedItemProperty().removeListener(tabChangeListener);
        root.getTabs().removeListener(tabListChangeListener);

        if (scene != null)
            scene.removeEventHandler(KeyEvent.KEY_RELEASED, keyEventEventHandler);
    }

    private void loadView(Class<? extends View> viewClass) {
        View view = viewLoader.load(viewClass);

        resetSelectedTab();

        if (view instanceof ArbitratorRegistrationView) {
            if (arbitratorRegistrationTab != null) {
                selectedTab = arbitratorRegistrationTab;
                arbitratorRegistrationView = (ArbitratorRegistrationView) view;
                arbitratorRegistrationView.onTabSelection(true);
            }
        } else if (view instanceof MediatorRegistrationView) {
            if (mediatorRegistrationTab != null) {
                selectedTab = mediatorRegistrationTab;
                mediatorRegistrationView = (MediatorRegistrationView) view;
                mediatorRegistrationView.onTabSelection(true);
            }
        } else if (view instanceof RefundAgentRegistrationView) {
            if (refundAgentRegistrationTab != null) {
                selectedTab = refundAgentRegistrationTab;
                refundAgentRegistrationView = (RefundAgentRegistrationView) view;
                refundAgentRegistrationView.onTabSelection(true);
            }
        } else if (view instanceof SigningView) {
            if (signingTab != null) {
                selectedTab = signingTab;
            }
        } else if (view instanceof FiatAccountsView) {
            selectedTab = fiatAccountsTab;
        } else if (view instanceof AltCoinAccountsView) {
            selectedTab = altcoinAccountsTab;
        } else if (view instanceof MobileNotificationsView) {
            selectedTab = notificationTab;
        } else if (view instanceof PasswordView) {
            selectedTab = passwordTab;
        } else if (view instanceof SeedWordsView) {
            selectedTab = seedWordsTab;
        } else if (view instanceof WalletInfoView) {
            selectedTab = walletInfoTab;
        } else if (view instanceof BackupView) {
            selectedTab = backupTab;
        } else {
            throw new IllegalArgumentException(""View not supported: "" + view);
        }

        if (selectedTab.getContent() != null && selectedTab.getContent() instanceof ScrollPane) {
            ((ScrollPane) selectedTab.getContent()).setContent(view.getRoot());
        } else {
            selectedTab.setContent(view.getRoot());
        }
        root.getSelectionModel().select(selectedTab);
    }

    private void resetSelectedTab() {
        if (selectedTab != null && selectedTab.getContent() != null) {
            if (selectedTab.getContent() instanceof ScrollPane) {
                ((ScrollPane) selectedTab.getContent()).setContent(null);
            } else {
                selectedTab.setContent(null);
            }
        }
    }
}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 123 64 2005 2006 2007 44 2008 44 2009 44 2010 44 2011 44 2012 44 2013 59 437 2014 46 2015 2016 59 437 2017 60 2006 62 2018 59 437 381 2019 2020 59 437 381 2014 2021 59 437 2006 2022 59 437 2006 2023 59 437 2006 2024 59 437 2006 2025 59 437 2006 2026 59 437 2027 2028 59 437 2029 2030 59 437 2031 2032 59 437 2033 2034 59 437 2035 60 2036 62 2037 59 437 2038 60 2006 62 2039 59 64 2040 437 2001 40 2041 2020 44 2014 2021 41 123 467 46 2020 61 2020 59 467 46 2021 61 2021 59 125 64 2042 439 492 2043 40 41 123 2044 46 2045 40 2003 46 2046 46 2047 41 59 2007 46 2048 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2008 46 2048 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2009 46 2048 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2010 46 2048 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2011 46 2048 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2012 46 2048 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2013 46 2048 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2016 61 40 2052 44 2053 41 45 62 123 392 40 2052 46 2054 40 41 614 1502 605 2052 46 2055 40 2001 46 334 41 614 1501 41 123 392 40 2023 614 424 605 2052 46 2050 40 1502 41 46 2056 40 2027 46 334 41 41 123 2021 46 2057 40 2058 46 334 44 2001 46 334 44 2059 46 334 41 59 125 360 392 40 2024 614 424 605 2052 46 2050 40 1502 41 46 2056 40 2029 46 334 41 41 123 2021 46 2060 40 2061 46 334 44 2001 46 334 44 2062 46 334 41 59 125 360 392 40 2025 614 424 605 2052 46 2050 40 1502 41 46 2056 40 2031 46 334 41 41 123 2021 46 2063 40 2064 46 334 44 2001 46 334 44 2065 46 334 41 59 125 360 392 40 2026 614 424 605 2052 46 2050 40 1502 41 46 2056 40 2066 46 334 41 41 123 2021 46 2067 40 2068 46 334 44 2001 46 334 44 2069 46 334 41 59 125 360 123 2070 40 2052 46 2071 40 41 41 59 125 125 360 123 2072 40 41 59 125 125 59 2037 61 373 45 62 123 392 40 2073 46 2074 40 2075 46 2076 44 373 41 605 2024 614 424 41 123 2077 40 2024 41 59 2024 61 418 2006 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2024 46 2078 40 473 41 59 2044 46 2079 40 41 46 2080 40 2024 41 59 2021 46 2081 40 2082 46 334 44 2001 46 334 44 2029 46 334 41 59 125 360 392 40 2073 46 2074 40 2075 46 2083 44 373 41 605 2025 614 424 41 123 2084 40 2025 41 59 2025 61 418 2006 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2025 46 2085 40 473 41 59 2044 46 2086 40 41 46 2087 40 2025 41 59 2021 46 2088 40 2089 46 334 44 2001 46 334 44 2031 46 334 41 59 125 360 392 40 2073 46 2074 40 2075 46 2090 44 373 41 605 2026 614 424 41 123 2091 40 2026 41 59 2026 61 418 2006 40 2049 46 2050 40 648 41 46 2051 40 41 41 59 2026 46 2092 40 473 41 59 2044 46 2093 40 41 46 2094 40 2026 41 59 2021 46 2095 40 2096 46 334 44 2001 46 334 44 2097 46 334 41 59 125 125 59 2018 61 40 2098 44 2099 44 2100 41 45 62 123 392 40 2023 631 424 605 2022 631 2023 41 123 2021 46 2101 40 2102 46 334 44 2001 46 334 44 2027 46 334 41 59 125 360 392 40 2024 631 424 605 2022 631 2024 41 123 2021 46 2103 40 2104 46 334 44 2001 46 334 44 2029 46 334 41 59 125 360 392 40 2025 631 424 605 2022 631 2025 41 123 2021 46 2105 40 2106 46 334 44 2001 46 334 44 2031 46 334 41 59 125 360 392 40 2026 631 424 605 33 2022 46 2107 40 2026 41 41 123 2021 46 2108 40 2109 46 334 44 2001 46 334 44 2110 46 334 41 59 125 360 392 40 2100 614 2007 605 2022 631 2007 41 123 2021 46 2111 40 2112 46 334 44 2001 46 334 44 2113 46 334 41 59 125 360 392 40 2100 614 2008 605 2022 631 2008 41 123 2021 46 2114 40 2115 46 334 44 2001 46 334 44 2116 46 334 41 59 125 360 392 40 2100 614 2009 605 2022 631 2009 41 123 2021 46 2117 40 2118 46 334 44 2001 46 334 44 2119 46 334 41 59 125 360 392 40 2100 614 2010 605 2022 631 2010 41 123 2021 46 2120 40 2121 46 334 44 2001 46 334 44 2122 46 334 41 59 125 360 392 40 2100 614 2011 605 2022 631 2011 41 123 2021 46 2123 40 2124 46 334 44 2001 46 334 44 2125 46 334 41 59 125 360 392 40 2100 614 2012 605 2022 631 2012 41 123 2021 46 2126 40 2127 46 334 44 2001 46 334 44 2128 46 334 41 59 125 360 392 40 2100 614 2013 605 2022 631 2013 41 123 2021 46 2129 40 2130 46 334 44 2001 46 334 44 2131 46 334 41 59 125 125 59 2039 61 2132 45 62 123 2132 46 2133 40 41 59 2134 60 63 378 2006 62 2135 61 2132 46 2136 40 41 59 392 40 2135 46 2137 40 41 614 1501 605 2135 46 2050 40 1500 41 46 2138 40 2023 41 41 2139 40 41 59 392 40 2135 46 2137 40 41 614 1501 605 2135 46 2050 40 1500 41 46 2138 40 2024 41 41 2140 40 41 59 392 40 2135 46 2137 40 41 614 1501 605 2135 46 2050 40 1500 41 46 2138 40 2025 41 41 2141 40 41 59 392 40 2135 46 2137 40 41 614 1501 605 2135 46 2050 40 1500 41 46 2138 40 2026 41 41 2142 40 41 59 125 59 125 437 492 2143 40 2006 2144 41 123 392 40 2023 631 424 605 33 2023 46 2145 40 2144 41 41 123 2146 46 2147 40 41 46 2148 40 2023 41 59 125 392 40 2024 631 424 605 33 2024 46 2145 40 2144 41 41 123 2149 46 2150 40 41 46 2151 40 2024 41 59 125 392 40 2025 631 424 605 33 2025 46 2145 40 2144 41 41 123 2152 46 2153 40 41 46 2154 40 2025 41 59 125 392 40 2026 631 424 605 33 2026 46 2145 40 2144 41 41 123 2155 46 2156 40 41 46 2157 40 2026 41 59 125 125 437 492 2158 40 41 123 2023 61 424 59 2021 46 2159 40 2160 46 334 44 2001 46 334 44 2161 46 334 41 59 125 437 492 2162 40 41 123 2024 61 424 59 2021 46 2163 40 2164 46 334 44 2001 46 334 44 2165 46 334 41 59 125 437 492 2166 40 41 123 2025 61 424 59 2021 46 2167 40 2168 46 334 44 2001 46 334 44 2169 46 334 41 59 125 437 492 2170 40 41 123 2026 61 424 59 2021 46 2171 40 2172 46 334 44 2001 46 334 44 2173 46 334 41 59 125 64 2042 438 492 2174 40 41 123 621 2175 46 2176 40 2177 46 2178 44 473 41 59 2021 46 2179 40 2016 41 59 2180 46 2181 40 41 46 2182 40 41 46 2179 40 2018 41 59 2180 46 2183 40 41 46 2179 40 2039 41 59 2034 61 2180 46 2184 40 41 59 392 40 2034 631 424 41 2034 46 2185 40 2036 46 2186 44 2037 41 59 392 40 2021 46 2187 40 41 46 2188 40 41 614 1502 605 2021 46 2187 40 41 46 2189 40 1501 41 614 2001 46 334 41 123 392 40 2023 631 424 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2027 46 334 41 59 360 392 40 2024 631 424 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2029 46 334 41 59 360 392 40 2025 631 424 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2031 46 334 41 59 360 392 40 2026 631 424 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2192 46 334 41 59 360 392 40 2180 46 2181 40 41 46 2193 40 41 614 2007 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2194 46 334 41 59 360 392 40 2180 46 2181 40 41 46 2193 40 41 614 2008 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2195 46 334 41 59 360 392 40 2180 46 2181 40 41 46 2193 40 41 614 2009 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2196 46 334 41 59 360 392 40 2180 46 2181 40 41 46 2193 40 41 614 2010 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2197 46 334 41 59 360 392 40 2180 46 2181 40 41 46 2193 40 41 614 2011 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2198 46 334 41 59 360 392 40 2180 46 2181 40 41 46 2193 40 41 614 2012 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2199 46 334 41 59 360 392 40 2180 46 2181 40 41 46 2193 40 41 614 2013 41 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2200 46 334 41 59 360 2021 46 2190 40 2191 46 334 44 2001 46 334 44 2194 46 334 41 59 125 2201 2202 61 648 59 392 40 33 2203 46 2204 40 41 41 418 2205 40 41 46 2206 40 2207 46 2189 40 648 41 41 46 2208 40 2207 46 2189 40 648 41 41 46 2209 40 2202 41 46 2210 40 41 59 125 64 2042 438 492 2211 40 41 123 2021 46 2212 40 2016 41 59 2213 46 2214 40 41 46 2215 40 41 46 2212 40 2018 41 59 2213 46 2216 40 41 46 2212 40 2039 41 59 392 40 2034 631 424 41 2034 46 2217 40 2036 46 2218 44 2037 41 59 125 437 492 2219 40 2220 60 63 378 2221 62 2222 41 123 2221 2223 61 2020 46 2224 40 2222 41 59 2225 40 41 59 392 40 2223 402 2027 41 123 392 40 2023 631 424 41 123 2022 61 2023 59 2028 61 40 2027 41 2223 59 2028 46 2226 40 473 41 59 125 125 360 392 40 2223 402 2029 41 123 392 40 2024 631 424 41 123 2022 61 2024 59 2030 61 40 2029 41 2223 59 2030 46 2227 40 473 41 59 125 125 360 392 40 2223 402 2031 41 123 392 40 2025 631 424 41 123 2022 61 2025 59 2032 61 40 2031 41 2223 59 2032 46 2228 40 473 41 59 125 125 360 392 40 2223 402 2229 41 123 392 40 2026 631 424 41 123 2022 61 2026 59 125 125 360 392 40 2223 402 2230 41 123 2022 61 2007 59 125 360 392 40 2223 402 2231 41 123 2022 61 2008 59 125 360 392 40 2223 402 2232 41 123 2022 61 2009 59 125 360 392 40 2223 402 2233 41 123 2022 61 2010 59 125 360 392 40 2223 402 2234 41 123 2022 61 2011 59 125 360 392 40 2223 402 2235 41 123 2022 61 2012 59 125 360 392 40 2223 402 2236 41 123 2022 61 2013 59 125 360 123 469 418 2237 40 648 43 2223 41 59 125 392 40 2022 46 2238 40 41 631 424 605 2022 46 2238 40 41 402 2239 41 123 40 40 2239 41 2022 46 2238 40 41 41 46 2240 40 2223 46 2241 40 41 41 59 125 360 123 2022 46 2242 40 2223 46 2243 40 41 41 59 125 2244 46 2245 40 41 46 2246 40 2022 41 59 125 437 492 2247 40 41 123 392 40 2022 631 424 605 2022 46 2248 40 41 631 424 41 123 392 40 2022 46 2248 40 41 402 2249 41 123 40 40 2249 41 2022 46 2248 40 41 41 46 2250 40 424 41 59 125 360 123 2022 46 2251 40 424 41 59 125 125 125 125 
2476,Java,"public class BlockStateInterface {

    private final Long2ObjectMap<Chunk> loadedChunks;
    private final WorldData worldData;
    protected final IBlockAccess world;
    public final BlockPos.MutableBlockPos isPassableBlockPos;
    public final IBlockAccess access;

    private Chunk prev = null;
    private CachedRegion prevCached = null;

    private final boolean useTheRealWorld;

    private static final IBlockState AIR = Blocks.AIR.getDefaultState();

    public BlockStateInterface(IPlayerContext ctx) {
        this(ctx, false);
    }

    public BlockStateInterface(IPlayerContext ctx, boolean copyLoadedChunks) {
        this(ctx.world(), (WorldData) ctx.worldData(), copyLoadedChunks);
    }

    public BlockStateInterface(World world, WorldData worldData, boolean copyLoadedChunks) {
        this.world = world;
        this.worldData = worldData;
        Long2ObjectMap<Chunk> worldLoaded = ((IChunkProviderClient) world.getChunkProvider()).loadedChunks();
        if (copyLoadedChunks) {
            this.loadedChunks = new Long2ObjectOpenHashMap<>(worldLoaded); // make a copy that we can safely access from another thread
        } else {
            this.loadedChunks = worldLoaded; // this will only be used on the main thread
        }
        this.useTheRealWorld = !Baritone.settings().pathThroughCachedOnly.value;
        if (!Minecraft.getMinecraft().isCallingFromMinecraftThread()) {
            throw new IllegalStateException();
        }
        this.isPassableBlockPos = new BlockPos.MutableBlockPos();
        this.access = new BlockStateInterfaceAccessWrapper(this);
    }

    public boolean worldContainsLoadedChunk(int blockX, int blockZ) {
        return loadedChunks.containsKey(ChunkPos.asLong(blockX >> 4, blockZ >> 4));
    }

    public static Block getBlock(IPlayerContext ctx, BlockPos pos) { // won't be called from the pathing thread because the pathing thread doesn't make a single blockpos pog
        return get(ctx, pos).getBlock();
    }

    public static IBlockState get(IPlayerContext ctx, BlockPos pos) {
        return new BlockStateInterface(ctx).get0(pos.getX(), pos.getY(), pos.getZ()); // immense iq
        // can't just do world().get because that doesn't work for out of bounds
        // and toBreak and stuff fails when the movement is instantiated out of load range but it's not able to BlockStateInterface.get what it's going to walk on
    }

    public IBlockState get0(BlockPos pos) {
        return get0(pos.getX(), pos.getY(), pos.getZ());
    }

    public IBlockState get0(int x, int y, int z) { // Mickey resigned

        // Invalid vertical position
        if (y < 0 || y >= 256) {
            return AIR;
        }

        if (useTheRealWorld) {
            Chunk cached = prev;
            // there's great cache locality in block state lookups
            // generally it's within each movement
            // if it's the same chunk as last time
            // we can just skip the mc.world.getChunk lookup
            // which is a Long2ObjectOpenHashMap.get
            // see issue #113
            if (cached != null && cached.x == x >> 4 && cached.z == z >> 4) {
                return cached.getBlockState(x, y, z);
            }
            Chunk chunk = loadedChunks.get(ChunkPos.asLong(x >> 4, z >> 4));

            if (chunk != null && chunk.isLoaded()) {
                prev = chunk;
                return chunk.getBlockState(x, y, z);
            }
        }
        // same idea here, skip the Long2ObjectOpenHashMap.get if at all possible
        // except here, it's 512x512 tiles instead of 16x16, so even better repetition
        CachedRegion cached = prevCached;
        if (cached == null || cached.getX() != x >> 9 || cached.getZ() != z >> 9) {
            if (worldData == null) {
                return AIR;
            }
            CachedRegion region = worldData.cache.getRegion(x >> 9, z >> 9);
            if (region == null) {
                return AIR;
            }
            prevCached = region;
            cached = region;
        }
        IBlockState type = cached.getBlock(x & 511, y, z & 511);
        if (type == null) {
            return AIR;
        }
        return type;
    }

    public boolean isLoaded(int x, int z) {
        Chunk prevChunk = prev;
        if (prevChunk != null && prevChunk.x == x >> 4 && prevChunk.z == z >> 4) {
            return true;
        }
        prevChunk = loadedChunks.get(ChunkPos.asLong(x >> 4, z >> 4));
        if (prevChunk != null && prevChunk.isLoaded()) {
            prev = prevChunk;
            return true;
        }
        CachedRegion prevRegion = prevCached;
        if (prevRegion != null && prevRegion.getX() == x >> 9 && prevRegion.getZ() == z >> 9) {
            return prevRegion.isCached(x & 511, z & 511);
        }
        if (worldData == null) {
            return false;
        }
        prevRegion = worldData.cache.getRegion(x >> 9, z >> 9);
        if (prevRegion == null) {
            return false;
        }
        prevCached = prevRegion;
        return prevRegion.isCached(x & 511, z & 511);
    }
}",1,439 334 2000 123 437 381 2001 60 2002 62 2003 59 437 381 2004 2005 59 438 381 2006 2007 59 439 381 2008 46 2009 2010 59 439 381 2006 2011 59 437 2002 2012 61 424 59 437 2013 2014 61 424 59 437 381 324 2015 59 437 457 381 2016 2017 61 2018 46 2017 46 2019 40 41 59 439 2000 40 2020 2021 41 123 467 40 2021 44 380 41 59 125 439 2000 40 2020 2021 44 324 2022 41 123 467 40 2021 46 2007 40 41 44 40 2004 41 2021 46 2005 40 41 44 2022 41 59 125 439 2000 40 2023 2007 44 2004 2005 44 324 2022 41 123 467 46 2007 61 2007 59 467 46 2005 61 2005 59 2001 60 2002 62 2024 61 40 40 2025 41 2007 46 2026 40 41 41 46 2003 40 41 59 392 40 2022 41 123 467 46 2003 61 418 2027 60 62 40 2024 41 59 621 125 360 123 467 46 2003 61 2024 59 621 125 467 46 2015 61 33 2028 46 2029 40 41 46 2030 46 2031 59 392 40 33 2032 46 2033 40 41 46 2034 40 41 41 123 469 418 2035 40 41 59 125 467 46 2010 61 418 2008 46 2009 40 41 59 467 46 2011 61 418 2036 40 467 41 59 125 439 324 2037 40 404 2038 44 404 2039 41 123 450 2003 46 2040 40 2041 46 2042 40 2038 641 1502 44 2039 641 1502 41 41 59 125 439 457 2043 2044 40 2020 2021 44 2008 2045 41 123 621 450 2046 40 2021 44 2045 41 46 2044 40 41 59 125 439 457 2016 2047 40 2020 2021 44 2008 2045 41 123 450 418 2000 40 2021 41 46 2048 40 2045 46 2049 40 41 44 2045 46 2050 40 41 44 2045 46 2051 40 41 41 59 621 621 621 125 439 2016 2052 40 2008 2045 41 123 450 2052 40 2045 46 2053 40 41 44 2045 46 2054 40 41 44 2045 46 2055 40 41 41 59 125 439 2016 2052 40 404 2056 44 404 2057 44 404 2058 41 123 621 621 392 40 2057 60 1500 606 2057 615 1504 41 123 450 2017 59 125 392 40 2015 41 123 2002 2059 61 2012 59 621 621 621 621 621 621 392 40 2059 631 424 605 2059 46 2056 614 2056 641 1502 605 2059 46 2058 614 2058 641 1502 41 123 450 2059 46 2060 40 2056 44 2057 44 2058 41 59 125 2002 2061 61 2003 46 2047 40 2062 46 2063 40 2056 641 1502 44 2058 641 1502 41 41 59 392 40 2061 631 424 605 2061 46 2064 40 41 41 123 2012 61 2061 59 450 2061 46 2065 40 2056 44 2057 44 2058 41 59 125 125 621 621 2013 2066 61 2014 59 392 40 2066 614 424 606 2066 46 2067 40 41 631 2056 641 1502 606 2066 46 2068 40 41 631 2058 641 1502 41 123 392 40 2005 614 424 41 123 450 2017 59 125 2013 443 61 2005 46 2069 46 2070 40 2056 641 1502 44 2058 641 1502 41 59 392 40 443 614 424 41 123 450 2017 59 125 2014 61 443 59 2066 61 443 59 125 2016 2071 61 2066 46 2044 40 2056 38 1504 44 2057 44 2058 38 1504 41 59 392 40 2071 614 424 41 123 450 2017 59 125 450 2071 59 125 439 324 2072 40 404 2056 44 404 2058 41 123 2002 2073 61 2012 59 392 40 2073 631 424 605 2073 46 2056 614 2056 641 1502 605 2073 46 2058 614 2058 641 1502 41 123 450 473 59 125 2073 61 2003 46 2047 40 2074 46 2075 40 2056 641 1502 44 2058 641 1502 41 41 59 392 40 2073 631 424 605 2073 46 2072 40 41 41 123 2012 61 2073 59 450 473 59 125 2013 2076 61 2014 59 392 40 2076 631 424 605 2076 46 2077 40 41 614 2056 641 1502 605 2076 46 2078 40 41 614 2058 641 1502 41 123 450 2076 46 2079 40 2056 38 1504 44 2058 38 1504 41 59 125 392 40 2005 614 424 41 123 450 380 59 125 2076 61 2005 46 2080 46 2081 40 2056 641 1502 44 2058 641 1502 41 59 392 40 2076 614 424 41 123 450 380 59 125 2014 61 2076 59 450 2076 46 2082 40 2056 38 1504 44 2058 38 1504 41 59 125 125 
29567,Java,"public class Eclipse {
	private static final Annotation[] EMPTY_ANNOTATIONS_ARRAY = new Annotation[0];
	/**
	 * Eclipse's Parser class is instrumented to not attempt to fill in the body of any method or initializer
	 * or field initialization if this flag is set. Set it on the flag field of
	 * any method, field, or initializer you create!
	 */
	public static final int ECLIPSE_DO_NOT_TOUCH_FLAG = ASTNode.Bit24;
	
	/* This section includes flags that are in ecj files too new vs. the deps we compile against.
	 * Specifically: org.eclipse.jdt.internal.compiler.ast.ASTNode and org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers
	 */
	public static final int AccRecord = ASTNode.Bit25; // ECM.AccRecord
	public static final int IsCanonicalConstructor = ASTNode.Bit10; // ASTNode.IsCanonicalConstructor
	public static final int IsImplicit = ASTNode.Bit11; // ASTNode.IsImplicit
	
	private static final Pattern SPLIT_AT_DOT = Pattern.compile(""\\."");
	
	private Eclipse() {
		//Prevent instantiation
	}
	
	/**
	 * For 'speed' reasons, Eclipse works a lot with char arrays. I have my doubts this was a fruitful exercise,
	 * but we need to deal with it. This turns [[java][lang][String]] into ""java.lang.String"".
	 */
	public static String toQualifiedName(char[][] typeName) {
		int len = typeName.length - 1; // number of dots
		if (len == 0) return new String(typeName[0]);
		
		for (char[] c : typeName) len += c.length;
		char[] ret = new char[len];
		char[] part = typeName[0];
		System.arraycopy(part, 0, ret, 0, part.length);
		int pos = part.length;
		for (int i = 1; i < typeName.length; i++) {
			ret[pos++] = '.';
			part = typeName[i];
			System.arraycopy(part, 0, ret, pos, part.length);
			pos += part.length;
		}
		return new String(ret);
	}
	
	public static char[][] fromQualifiedName(String typeName) {
		String[] split = SPLIT_AT_DOT.split(typeName);
		char[][] result = new char[split.length][];
		for (int i = 0; i < split.length; i++) {
			result[i] = split[i].toCharArray();
		}
		return result;
	}
	
	public static long pos(ASTNode node) {
		return ((long) node.sourceStart << 32) | (node.sourceEnd & 0xFFFFFFFFL);
	}
	
	public static long[] poss(ASTNode node, int repeat) {
		long p = ((long) node.sourceStart << 32) | (node.sourceEnd & 0xFFFFFFFFL);
		long[] out = new long[repeat];
		Arrays.fill(out, p);
		return out;
	}
	
	/**
	 * Checks if an eclipse-style array-of-array-of-characters to represent a fully qualified name ('foo.bar.baz'), matches a plain
	 * string containing the same fully qualified name with dots in the string.
	 */
	public static boolean nameEquals(char[][] typeName, String string) {
		int pos = 0, len = string.length();
		for (int i = 0; i < typeName.length; i++) {
			char[] t = typeName[i];
			if (i > 0) {
				if (pos == len) return false;
				if (string.charAt(pos++) != '.') return false;
			}
			for (int j = 0; j < t.length; j++) {
				if (pos == len) return false;
				if (string.charAt(pos++) != t[j]) return false;
			}
		}
		
		return true;
	}
	
	public static boolean hasClinit(TypeDeclaration parent) {
		if (parent.methods == null) return false;
		
		for (AbstractMethodDeclaration method : parent.methods) {
			if (method instanceof Clinit) return true;
		}
		return false;
	}
	
	/**
	 * Searches the given field node for annotations and returns each one that matches the provided regular expression pattern.
	 * 
	 * Only the simple name is checked - the package and any containing class are ignored.
	 */
	public static Annotation[] findAnnotations(AbstractVariableDeclaration field, Pattern namePattern) {
		List<Annotation> result = new ArrayList<Annotation>();
		if (field.annotations == null) return EMPTY_ANNOTATIONS_ARRAY;
		for (Annotation annotation : field.annotations) {
			TypeReference typeRef = annotation.type;
			if (typeRef != null && typeRef.getTypeName() != null) {
				char[][] typeName = typeRef.getTypeName();
				String suspect = new String(typeName[typeName.length - 1]);
				if (namePattern.matcher(suspect).matches()) {
					result.add(annotation);
				}
			}
		}	
		return result.toArray(EMPTY_ANNOTATIONS_ARRAY);
	}
	
	/**
	 * Checks if the given type reference represents a primitive type.
	 */
	public static boolean isPrimitive(TypeReference ref) {
		if (ref.dimensions() > 0) return false;
		return JavaIdentifiers.isPrimitive(toQualifiedName(ref.getTypeName()));
	}
	
	/**
	 * Returns the actual value of the given Literal or Literal-like node.
	 */
	public static Object calculateValue(Expression e) {
		if (e instanceof Literal) {
			((Literal) e).computeConstant();
			switch (e.constant.typeID()) {
			case TypeIds.T_int: return e.constant.intValue();
			case TypeIds.T_byte: return e.constant.byteValue();
			case TypeIds.T_short: return e.constant.shortValue();
			case TypeIds.T_char: return e.constant.charValue();
			case TypeIds.T_float: return e.constant.floatValue();
			case TypeIds.T_double: return e.constant.doubleValue();
			case TypeIds.T_boolean: return e.constant.booleanValue();
			case TypeIds.T_long: return e.constant.longValue();
			case TypeIds.T_JavaLangString: return e.constant.stringValue();
			default: return null;
			}
		} else if (e instanceof ClassLiteralAccess) {
			return new ClassLiteral(Eclipse.toQualifiedName(((ClassLiteralAccess) e).type.getTypeName()));
		} else if (e instanceof SingleNameReference) {
			return new FieldSelect(new String(((SingleNameReference)e).token));
		} else if (e instanceof QualifiedNameReference) {
			String qName = Eclipse.toQualifiedName(((QualifiedNameReference) e).tokens);
			int idx = qName.lastIndexOf('.');
			return new FieldSelect(idx == -1 ? qName : qName.substring(idx+1));
		} else if (e instanceof UnaryExpression) {
			if (""-"".equals(((UnaryExpression) e).operatorToString())) {
				Object inner = calculateValue(((UnaryExpression) e).expression);
				if (inner instanceof Integer) return - ((Integer) inner).intValue();
				if (inner instanceof Byte) return - ((Byte) inner).byteValue();
				if (inner instanceof Short) return - ((Short) inner).shortValue();
				if (inner instanceof Long) return - ((Long) inner).longValue();
				if (inner instanceof Float) return - ((Float) inner).floatValue();
				if (inner instanceof Double) return - ((Double) inner).doubleValue();
				return null;
			}
		}
		
		return null;
	}
	
	private static long latestEcjCompilerVersionConstantCached = 0;
	
	public static long getLatestEcjCompilerVersionConstant() {
		if (latestEcjCompilerVersionConstantCached != 0) return latestEcjCompilerVersionConstantCached;
		
		int highestVersionSoFar = 0;
		for (Field f : ClassFileConstants.class.getDeclaredFields()) {
			try {
				if (f.getName().startsWith(""JDK"")) {
					String versionString = f.getName().substring(""JDK"".length());
					if (versionString.startsWith(""1_"")) versionString = versionString.substring(""1_"".length());
					
					int thisVersion = Integer.parseInt(versionString);
					if (thisVersion > highestVersionSoFar) {
						highestVersionSoFar = thisVersion;
						latestEcjCompilerVersionConstantCached = (Long) f.get(null);
					}
				}
			} catch (Exception ignore) {}
		}
		
		if (highestVersionSoFar > 6 && !ecjSupportsJava7Features()) {
			latestEcjCompilerVersionConstantCached = ClassFileConstants.JDK1_6;
		}
		return latestEcjCompilerVersionConstantCached;
	}
	
	private static int ecjCompilerVersionCached = -1;
	public static int getEcjCompilerVersion() {
		if (ecjCompilerVersionCached >= 0) return ecjCompilerVersionCached;
		
		for (Field f : CompilerOptions.class.getDeclaredFields()) {
			try {
				String fName = f.getName();
				String versionNumber = null;
				if (fName.startsWith(""VERSION_1_"")) {
					versionNumber = fName.substring(""VERSION_1_"".length());
				} else if (fName.startsWith(""VERSION_"")) {
					versionNumber = fName.substring(""VERSION_"".length());
				} else continue;
				ecjCompilerVersionCached = Math.max(ecjCompilerVersionCached, Integer.parseInt(versionNumber));
			} catch (Exception ignore) {}
		}
		
		if (ecjCompilerVersionCached < 5) ecjCompilerVersionCached = 5;
		if (!ecjSupportsJava7Features()) ecjCompilerVersionCached = Math.min(6, ecjCompilerVersionCached);
		return ecjCompilerVersionCached;
	}
	
	/**
	 * Certain ECJ versions that only go up to -source 6 report that they support -source 7 and even fail to error when -source 7 is applied.
	 * We detect this and correctly say that no more than -source 6 is supported. (when this is the case, this method returns false).
	 */
	private static boolean ecjSupportsJava7Features() {
		try {
			TryStatement.class.getDeclaredField(""resources"");
			return true;
		} catch (NoSuchFieldException e) {
			return false;
		}
	}
	
	private static boolean caseStatementInit = false;
	private static Field caseStatementConstantExpressions = null;
	public static CaseStatement createCaseStatement(Expression expr) {
		CaseStatement stat = new CaseStatement(expr, 0, 0);
		if (expr == null) return stat;
		if (!caseStatementInit) {
			try {
				caseStatementConstantExpressions = Permit.getField(CaseStatement.class, ""constantExpressions"");
				caseStatementConstantExpressions.setAccessible(true);
			} catch (NoSuchFieldException ignore) {}
			caseStatementInit = true;
		}
		if (caseStatementConstantExpressions != null) try {
			caseStatementConstantExpressions.set(stat, new Expression[] {expr});
		} catch (IllegalArgumentException ignore) {
		} catch (IllegalAccessException ignore) {}
		return stat;
	}
}",1,439 334 2000 123 437 457 381 2001 91 93 2002 61 418 2001 91 1500 93 59 618 439 457 381 404 2003 61 2004 46 2005 59 604 439 457 381 404 2006 61 2004 46 2007 59 621 439 457 381 404 2008 61 2004 46 2009 59 621 439 457 381 404 2010 61 2004 46 2011 59 621 437 457 381 2012 2013 61 2012 46 2014 40 648 41 59 437 2000 40 41 123 621 125 618 439 457 2015 2016 40 330 91 93 91 93 2017 41 123 404 2018 61 2017 46 2019 45 1501 59 621 392 40 2018 614 1500 41 450 418 2015 40 2017 91 1500 93 41 59 385 40 330 91 93 2020 58 2017 41 2018 636 2020 46 2019 59 330 91 93 2021 61 418 330 91 2018 93 59 330 91 93 2022 61 2017 91 1500 93 59 2023 46 2024 40 2022 44 1500 44 2021 44 1500 44 2022 46 2019 41 59 404 2025 61 2022 46 2019 59 385 40 404 2026 61 1501 59 2026 60 2017 46 2019 59 2026 637 41 123 2021 91 2025 637 93 61 607 59 2022 61 2017 91 2026 93 59 2023 46 2024 40 2022 44 1500 44 2021 44 2025 44 2022 46 2019 41 59 2025 636 2022 46 2019 59 125 450 418 2015 40 2021 41 59 125 439 457 330 91 93 91 93 2027 40 2015 2017 41 123 2015 91 93 2028 61 2013 46 2028 40 2017 41 59 330 91 93 91 93 2029 61 418 330 91 2028 46 2030 93 91 93 59 385 40 404 2031 61 1500 59 2031 60 2028 46 2030 59 2031 637 41 123 2029 91 2031 93 61 2028 91 2031 93 46 2032 40 41 59 125 450 2029 59 125 439 457 413 2033 40 2004 2034 41 123 450 40 40 413 41 2034 46 2035 622 1503 41 124 40 2034 46 2036 38 1511 41 59 125 439 457 413 91 93 2037 40 2004 2034 44 404 2038 41 123 413 2039 61 40 40 413 41 2034 46 2040 622 1503 41 124 40 2034 46 2041 38 1511 41 59 413 91 93 430 61 418 413 91 2038 93 59 2042 46 2043 40 430 44 2039 41 59 450 430 59 125 618 439 457 324 2044 40 330 91 93 91 93 2017 44 2015 461 41 123 404 2033 61 1500 44 2045 61 461 46 2046 40 41 59 385 40 404 2047 61 1500 59 2047 60 2017 46 2046 59 2047 637 41 123 330 91 93 2048 61 2017 91 2047 93 59 392 40 2047 62 1500 41 123 392 40 2033 614 2045 41 450 380 59 392 40 461 46 2049 40 2033 637 41 631 607 41 450 380 59 125 385 40 404 2050 61 1500 59 2050 60 2048 46 2046 59 2050 637 41 123 392 40 2033 614 2045 41 450 380 59 392 40 461 46 2051 40 2033 637 41 631 2048 91 2050 93 41 450 380 59 125 125 450 473 59 125 439 457 324 2052 40 2053 2054 41 123 392 40 2054 46 2055 614 424 41 450 380 59 385 40 2056 2057 58 2054 46 2055 41 123 392 40 2057 402 2058 41 450 473 59 125 450 380 59 125 618 439 457 2001 91 93 2059 40 2060 2061 44 2012 2062 41 123 2063 60 2001 62 2064 61 418 2065 60 2001 62 40 41 59 392 40 2061 46 2066 614 424 41 450 2002 59 385 40 2001 2067 58 2061 46 2066 41 123 2068 2069 61 2067 46 2070 59 392 40 2069 631 424 605 2069 46 2071 40 41 631 424 41 123 330 91 93 91 93 2017 61 2069 46 2071 40 41 59 2015 2072 61 418 2015 40 2017 91 2017 46 2073 45 1501 93 41 59 392 40 2062 46 2074 40 2072 41 46 2075 40 41 41 123 2064 46 2076 40 2067 41 59 125 125 125 450 2064 46 2077 40 2002 41 59 125 618 439 457 324 2078 40 2079 442 41 123 392 40 442 46 2080 40 41 62 1500 41 450 380 59 450 2081 46 2078 40 2016 40 442 46 2082 40 41 41 41 59 125 618 439 457 2083 2084 40 2085 2086 41 123 392 40 2086 402 2087 41 123 40 40 2087 41 2086 41 46 2088 40 41 59 464 40 2086 46 2089 46 2090 40 41 41 123 328 2091 46 2092 58 450 2086 46 2089 46 2093 40 41 59 328 2091 46 2094 58 450 2086 46 2089 46 2095 40 41 59 328 2091 46 2096 58 450 2086 46 2089 46 2097 40 41 59 328 2091 46 2098 58 450 2086 46 2089 46 2099 40 41 59 328 2091 46 2100 58 450 2086 46 2089 46 2101 40 41 59 328 2091 46 2102 58 450 2086 46 2089 46 2103 40 41 59 328 2091 46 2104 58 450 2086 46 2089 46 2105 40 41 59 328 2091 46 2106 58 450 2086 46 2089 46 2107 40 41 59 328 2091 46 2108 58 450 2086 46 2089 46 2109 40 41 59 349 58 450 424 59 125 125 360 392 40 2086 402 2110 41 123 450 418 2111 40 2000 46 2016 40 40 40 2110 41 2086 41 46 2112 46 2113 40 41 41 41 59 125 360 392 40 2086 402 2114 41 123 450 418 2115 40 418 2015 40 40 40 2114 41 2086 41 46 2116 41 41 59 125 360 392 40 2086 402 2117 41 123 2015 2118 61 2000 46 2016 40 40 40 2117 41 2086 41 46 2119 41 59 404 2120 61 2118 46 2121 40 607 41 59 450 418 2122 40 2120 614 45 1501 63 2118 58 2118 46 2123 40 2120 43 1501 41 41 59 125 360 392 40 2086 402 2124 41 123 392 40 648 46 2125 40 40 40 2124 41 2086 41 46 2126 40 41 41 41 123 2083 2127 61 2084 40 40 40 2124 41 2086 41 46 2128 41 59 392 40 2127 402 2129 41 450 45 40 40 2129 41 2127 41 46 2130 40 41 59 392 40 2127 402 2131 41 450 45 40 40 2131 41 2127 41 46 2132 40 41 59 392 40 2127 402 2133 41 450 45 40 40 2133 41 2127 41 46 2134 40 41 59 392 40 2127 402 2135 41 450 45 40 40 2135 41 2127 41 46 2136 40 41 59 392 40 2127 402 2137 41 450 45 40 40 2137 41 2127 41 46 2138 40 41 59 392 40 2127 402 2139 41 450 45 40 40 2139 41 2127 41 46 2140 40 41 59 450 424 59 125 125 450 424 59 125 437 457 413 2141 61 1500 59 439 457 413 2142 40 41 123 392 40 2141 631 1500 41 450 2141 59 404 2143 61 1500 59 385 40 2144 2145 58 2146 46 334 46 2147 40 41 41 123 474 123 392 40 2145 46 2148 40 41 46 2149 40 648 41 41 123 2015 2150 61 2145 46 2148 40 41 46 2151 40 648 46 2152 40 41 41 59 392 40 2150 46 2149 40 648 41 41 2150 61 2150 46 2151 40 648 46 2152 40 41 41 59 404 2153 61 2154 46 2155 40 2150 41 59 392 40 2153 62 2143 41 123 2143 61 2153 59 2141 61 40 2156 41 2145 46 2157 40 424 41 59 125 125 125 329 40 2158 2159 41 123 125 125 392 40 2143 62 1502 605 33 2160 40 41 41 123 2141 61 2146 46 2161 59 125 450 2141 59 125 437 457 404 2162 61 45 1501 59 439 457 404 2163 40 41 123 392 40 2162 615 1500 41 450 2162 59 385 40 2164 2165 58 2166 46 334 46 2167 40 41 41 123 474 123 2015 2168 61 2165 46 2169 40 41 59 2015 2170 61 424 59 392 40 2168 46 2171 40 648 41 41 123 2170 61 2168 46 2172 40 648 46 2173 40 41 41 59 125 360 392 40 2168 46 2171 40 648 41 41 123 2170 61 2168 46 2174 40 648 46 2175 40 41 41 59 125 360 344 59 2162 61 2176 46 2177 40 2162 44 2178 46 2179 40 2170 41 41 59 125 329 40 2180 2181 41 123 125 125 392 40 2162 60 1502 41 2162 61 1502 59 392 40 33 2182 40 41 41 2162 61 2183 46 2184 40 1502 44 2162 41 59 450 2162 59 125 618 437 457 324 2185 40 41 123 474 123 2186 46 334 46 2187 40 648 41 59 450 473 59 125 329 40 2188 2086 41 123 450 380 59 125 125 437 457 324 2189 61 380 59 437 457 2190 2191 61 424 59 439 457 2192 2193 40 2085 2194 41 123 2192 2195 61 418 2192 40 2194 44 1500 44 1500 41 59 392 40 2194 614 424 41 450 2195 59 392 40 33 2189 41 123 474 123 2191 61 2196 46 2197 40 2192 46 334 44 648 41 59 2191 46 2198 40 473 41 59 125 329 40 2199 2200 41 123 125 2189 61 473 59 125 392 40 2191 631 424 41 474 123 2191 46 2201 40 2195 44 418 2085 91 93 123 2194 125 41 59 125 329 40 2202 2203 41 123 125 329 40 2204 2203 41 123 125 450 2195 59 125 125 
3882,Java,"@FxmlView
public class FiatAccountsView extends PaymentAccountsView<GridPane, FiatAccountsViewModel> {

    private final IBANValidator ibanValidator;
    private final BICValidator bicValidator;
    private final CapitualValidator capitualValidator;
    private final LengthValidator inputValidator;
    private final UpholdValidator upholdValidator;
    private final MoneyBeamValidator moneyBeamValidator;
    private final PopmoneyValidator popmoneyValidator;
    private final RevolutValidator revolutValidator;
    private final AliPayValidator aliPayValidator;
    private final PerfectMoneyValidator perfectMoneyValidator;
    private final SwishValidator swishValidator;
    private final ClearXchangeValidator clearXchangeValidator;
    private final ChaseQuickPayValidator chaseQuickPayValidator;
    private final InteracETransferValidator interacETransferValidator;
    private final JapanBankTransferValidator japanBankTransferValidator;
    private final AustraliaPayidValidator australiapayidValidator;
    private final USPostalMoneyOrderValidator usPostalMoneyOrderValidator;
    private final WeChatPayValidator weChatPayValidator;
    private final HalCashValidator halCashValidator;
    private final F2FValidator f2FValidator;
    private final PromptPayValidator promptPayValidator;
    private final AdvancedCashValidator advancedCashValidator;
    private final TransferwiseValidator transferwiseValidator;
    private final CoinFormatter formatter;
    private ComboBox<PaymentMethod> paymentMethodComboBox;
    private PaymentMethodForm paymentMethodForm;
    private TitledGroupBg accountTitledGroupBg;
    private Button saveNewAccountButton;
    private int gridRow = 0;

    @Inject
    public FiatAccountsView(FiatAccountsViewModel model,
                            IBANValidator ibanValidator,
                            BICValidator bicValidator,
                            CapitualValidator capitualValidator,
                            LengthValidator inputValidator,
                            UpholdValidator upholdValidator,
                            MoneyBeamValidator moneyBeamValidator,
                            PopmoneyValidator popmoneyValidator,
                            RevolutValidator revolutValidator,
                            AliPayValidator aliPayValidator,
                            PerfectMoneyValidator perfectMoneyValidator,
                            SwishValidator swishValidator,
                            ClearXchangeValidator clearXchangeValidator,
                            ChaseQuickPayValidator chaseQuickPayValidator,
                            InteracETransferValidator interacETransferValidator,
                            JapanBankTransferValidator japanBankTransferValidator,
                            AustraliaPayidValidator australiaPayIDValidator,
                            USPostalMoneyOrderValidator usPostalMoneyOrderValidator,
                            WeChatPayValidator weChatPayValidator,
                            HalCashValidator halCashValidator,
                            F2FValidator f2FValidator,
                            PromptPayValidator promptPayValidator,
                            AdvancedCashValidator advancedCashValidator,
                            TransferwiseValidator transferwiseValidator,
                            AccountAgeWitnessService accountAgeWitnessService,
                            @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter formatter) {
        super(model, accountAgeWitnessService);

        this.ibanValidator = ibanValidator;
        this.bicValidator = bicValidator;
        this.capitualValidator = capitualValidator;
        this.inputValidator = inputValidator;
        this.inputValidator.setMaxLength(100); // restrict general field entry length
        this.inputValidator.setMinLength(2);
        this.upholdValidator = upholdValidator;
        this.moneyBeamValidator = moneyBeamValidator;
        this.popmoneyValidator = popmoneyValidator;
        this.revolutValidator = revolutValidator;
        this.aliPayValidator = aliPayValidator;
        this.perfectMoneyValidator = perfectMoneyValidator;
        this.swishValidator = swishValidator;
        this.clearXchangeValidator = clearXchangeValidator;
        this.chaseQuickPayValidator = chaseQuickPayValidator;
        this.interacETransferValidator = interacETransferValidator;
        this.japanBankTransferValidator = japanBankTransferValidator;
        this.australiapayidValidator = australiaPayIDValidator;
        this.usPostalMoneyOrderValidator = usPostalMoneyOrderValidator;
        this.weChatPayValidator = weChatPayValidator;
        this.halCashValidator = halCashValidator;
        this.f2FValidator = f2FValidator;
        this.promptPayValidator = promptPayValidator;
        this.advancedCashValidator = advancedCashValidator;
        this.transferwiseValidator = transferwiseValidator;
        this.formatter = formatter;
    }

    @Override
    protected ObservableList<PaymentAccount> getPaymentAccounts() {
        return model.getPaymentAccounts();
    }

    @Override
    protected void importAccounts() {
        model.dataModel.importAccounts((Stage) root.getScene().getWindow());
    }

    @Override
    protected void exportAccounts() {
        model.dataModel.exportAccounts((Stage) root.getScene().getWindow());
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // UI actions
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onSaveNewAccount(PaymentAccount paymentAccount) {
        Coin maxTradeLimitAsCoin = paymentAccount.getPaymentMethod().getMaxTradeLimitAsCoin(""USD"");
        Coin maxTradeLimitSecondMonth = maxTradeLimitAsCoin.divide(2L);
        Coin maxTradeLimitFirstMonth = maxTradeLimitAsCoin.divide(4L);
        if (paymentAccount instanceof F2FAccount) {
            new Popup().information(Res.get(""payment.f2f.info""))
                    .width(700)
                    .closeButtonText(Res.get(""payment.f2f.info.openURL""))
                    .onClose(() -> GUIUtil.openWebPage(""https://bisq.wiki/Face-to-face_(payment_method)""))
                    .actionButtonText(Res.get(""shared.iUnderstand""))
                    .onAction(() -> doSaveNewAccount(paymentAccount))
                    .show();
        } else if (paymentAccount instanceof CashByMailAccount) {
            // CashByMail has no chargeback risk so we don't show the text from payment.limits.info.
            new Popup().information(Res.get(""payment.cashByMail.info""))
                    .width(850)
                    .closeButtonText(Res.get(""shared.cancel""))
                    .actionButtonText(Res.get(""shared.iUnderstand""))
                    .onAction(() -> doSaveNewAccount(paymentAccount))
                    .show();
        } else if (paymentAccount instanceof HalCashAccount) {
            // HalCash has no chargeback risk so we don't show the text from payment.limits.info.
            new Popup().information(Res.get(""payment.halCash.info""))
                    .width(700)
                    .closeButtonText(Res.get(""shared.cancel""))
                    .actionButtonText(Res.get(""shared.iUnderstand""))
                    .onAction(() -> doSaveNewAccount(paymentAccount))
                    .show();
        } else {

            String limitsInfoKey = ""payment.limits.info"";
            String initialLimit = formatter.formatCoinWithCode(maxTradeLimitFirstMonth);

            if (PaymentMethod.hasChargebackRisk(paymentAccount.getPaymentMethod(), paymentAccount.getTradeCurrencies())) {
                limitsInfoKey = ""payment.limits.info.withSigning"";
                initialLimit = formatter.formatCoinWithCode(OfferRestrictions.TOLERATED_SMALL_TRADE_AMOUNT);
            }

            new Popup().information(Res.get(limitsInfoKey,
                    initialLimit,
                    formatter.formatCoinWithCode(maxTradeLimitSecondMonth),
                    formatter.formatCoinWithCode(maxTradeLimitAsCoin)))
                    .width(700)
                    .closeButtonText(Res.get(""shared.cancel""))
                    .actionButtonText(Res.get(""shared.iUnderstand""))
                    .onAction(() -> {
                        final String currencyName = Config.baseCurrencyNetwork().getCurrencyName();
                        if (paymentAccount instanceof ClearXchangeAccount) {
                            new Popup().information(Res.get(""payment.clearXchange.info"", currencyName, currencyName))
                                    .width(900)
                                    .closeButtonText(Res.get(""shared.cancel""))
                                    .actionButtonText(Res.get(""shared.iConfirm""))
                                    .onAction(() -> doSaveNewAccount(paymentAccount))
                                    .show();
                        } else if (paymentAccount instanceof WesternUnionAccount) {
                            new Popup().information(Res.get(""payment.westernUnion.info""))
                                    .width(700)
                                    .closeButtonText(Res.get(""shared.cancel""))
                                    .actionButtonText(Res.get(""shared.iUnderstand""))
                                    .onAction(() -> doSaveNewAccount(paymentAccount))
                                    .show();
                        } else if (paymentAccount instanceof MoneyGramAccount) {
                            new Popup().information(Res.get(""payment.moneyGram.info""))
                                    .width(700)
                                    .closeButtonText(Res.get(""shared.cancel""))
                                    .actionButtonText(Res.get(""shared.iUnderstand""))
                                    .onAction(() -> doSaveNewAccount(paymentAccount))
                                    .show();
                        } else if (paymentAccount instanceof CashDepositAccount) {
                            new Popup().information(Res.get(""payment.cashDeposit.info""))
                                    .width(700)
                                    .closeButtonText(Res.get(""shared.cancel""))
                                    .actionButtonText(Res.get(""shared.iConfirm""))
                                    .onAction(() -> doSaveNewAccount(paymentAccount))
                                    .show();
                        } else if (paymentAccount instanceof RevolutAccount) {
                            new Popup().information(Res.get(""payment.revolut.info""))
                                    .width(700)
                                    .closeButtonText(Res.get(""shared.cancel""))
                                    .actionButtonText(Res.get(""shared.iConfirm""))
                                    .onAction(() -> doSaveNewAccount(paymentAccount))
                                    .show();
                        } else if (paymentAccount instanceof USPostalMoneyOrderAccount) {
                            new Popup().information(Res.get(""payment.usPostalMoneyOrder.info""))
                                    .width(700)
                                    .closeButtonText(Res.get(""shared.cancel""))
                                    .actionButtonText(Res.get(""shared.iUnderstand""))
                                    .onAction(() -> doSaveNewAccount(paymentAccount))
                                    .show();
                        } else if (paymentAccount instanceof AustraliaPayid) {
                            new Popup().information(Res.get(""payment.payid.info"", currencyName, currencyName))
                                    .width(900)
                                    .closeButtonText(Res.get(""shared.cancel""))
                                    .actionButtonText(Res.get(""shared.iConfirm""))
                                    .onAction(() -> doSaveNewAccount(paymentAccount))
                                    .show();
                        } else if (paymentAccount instanceof AmazonGiftCardAccount) {
                            new Popup().information(Res.get(""payment.amazonGiftCard.info"", currencyName, currencyName))
                                    .width(900)
                                    .closeButtonText(Res.get(""shared.cancel""))
                                    .actionButtonText(Res.get(""shared.iUnderstand""))
                                    .onAction(() -> doSaveNewAccount(paymentAccount))
                                    .show();
                        } else {
                            doSaveNewAccount(paymentAccount);
                        }
                    })
                    .show();
        }
    }

    private void doSaveNewAccount(PaymentAccount paymentAccount) {
        if (getPaymentAccounts().stream().noneMatch(e -> e.getAccountName() != null &&
                e.getAccountName().equals(paymentAccount.getAccountName()))) {
            model.onSaveNewAccount(paymentAccount);
            removeNewAccountForm();
        } else {
            new Popup().warning(Res.get(""shared.accountNameAlreadyUsed"")).show();
        }
    }

    private void onCancelNewAccount() {
        removeNewAccountForm();
    }

    protected boolean deleteAccountFromModel(PaymentAccount paymentAccount) {
        return model.onDeleteAccount(paymentAccount);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Base form
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    protected void buildForm() {
        addTitledGroupBg(root, gridRow, 2, Res.get(""shared.manageAccounts""));

        Tuple3<Label, ListView<PaymentAccount>, VBox> tuple = addTopLabelListView(root, gridRow, Res.get(""account.fiat.yourFiatAccounts""), Layout.FIRST_ROW_DISTANCE);
        paymentAccountsListView = tuple.second;
        int prefNumRows = Math.min(4, Math.max(2, model.dataModel.getNumPaymentAccounts()));
        paymentAccountsListView.setMinHeight(prefNumRows * Layout.LIST_ROW_HEIGHT + 28);
        setPaymentAccountsCellFactory();

        Tuple3<Button, Button, Button> tuple3 = add3ButtonsAfterGroup(root, ++gridRow, Res.get(""shared.addNewAccount""),
                Res.get(""shared.ExportAccounts""), Res.get(""shared.importAccounts""));
        addAccountButton = tuple3.first;
        exportButton = tuple3.second;
        importButton = tuple3.third;
    }

    // Add new account form
    @Override
    protected void addNewAccount() {
        paymentAccountsListView.getSelectionModel().clearSelection();
        removeAccountRows();
        addAccountButton.setDisable(true);
        accountTitledGroupBg = addTitledGroupBg(root, ++gridRow, 2, Res.get(""shared.createNewAccount""), Layout.GROUP_DISTANCE);
        paymentMethodComboBox = FormBuilder.addComboBox(root, gridRow, Res.get(""shared.selectPaymentMethod""), Layout.FIRST_ROW_AND_GROUP_DISTANCE);
        paymentMethodComboBox.setVisibleRowCount(11);
        paymentMethodComboBox.setPrefWidth(250);
        List<PaymentMethod> list = PaymentMethod.getPaymentMethods().stream()
                .filter(PaymentMethod::isFiat)
                .sorted()
                .collect(Collectors.toList());
        paymentMethodComboBox.setItems(FXCollections.observableArrayList(list));
        paymentMethodComboBox.setConverter(new StringConverter<>() {
            @Override
            public String toString(PaymentMethod paymentMethod) {
                return paymentMethod != null ? Res.get(paymentMethod.getId()) : """";
            }

            @Override
            public PaymentMethod fromString(String s) {
                return null;
            }
        });
        paymentMethodComboBox.setOnAction(e -> {
            if (paymentMethodForm != null) {
                FormBuilder.removeRowsFromGridPane(root, 3, paymentMethodForm.getGridRow() + 1);
                GridPane.setRowSpan(accountTitledGroupBg, paymentMethodForm.getRowSpan() + 1);
            }
            gridRow = 2;
            paymentMethodForm = getPaymentMethodForm(paymentMethodComboBox.getSelectionModel().getSelectedItem());
            if (paymentMethodForm != null) {
                if (paymentMethodForm.getPaymentAccount().getMessageForAccountCreation() != null) {
                    new Popup().information(Res.get(paymentMethodForm.getPaymentAccount().getMessageForAccountCreation()))
                            .width(900)
                            .closeButtonText(Res.get(""shared.iUnderstand""))
                            .show();
                }
                paymentMethodForm.addFormForAddAccount();
                gridRow = paymentMethodForm.getGridRow();
                Tuple2<Button, Button> tuple2 = add2ButtonsAfterGroup(root, ++gridRow, Res.get(""shared.saveNewAccount""), Res.get(""shared.cancel""));
                saveNewAccountButton = tuple2.first;
                saveNewAccountButton.setOnAction(event -> onSaveNewAccount(paymentMethodForm.getPaymentAccount()));
                saveNewAccountButton.disableProperty().bind(paymentMethodForm.allInputsValidProperty().not());
                Button cancelButton = tuple2.second;
                cancelButton.setOnAction(event -> onCancelNewAccount());
                GridPane.setRowSpan(accountTitledGroupBg, paymentMethodForm.getRowSpan() + 1);
            }
        });
    }

    // Select account form
    @Override
    protected void onSelectAccount(PaymentAccount paymentAccount) {
        removeAccountRows();
        addAccountButton.setDisable(false);
        accountTitledGroupBg = addTitledGroupBg(root, ++gridRow, 2, Res.get(""shared.selectedAccount""), Layout.GROUP_DISTANCE);
        paymentMethodForm = getPaymentMethodForm(paymentAccount);
        if (paymentMethodForm != null) {
            paymentMethodForm.addFormForDisplayAccount();
            gridRow = paymentMethodForm.getGridRow();
            Tuple2<Button, Button> tuple = add2ButtonsAfterGroup(root, ++gridRow, Res.get(""shared.deleteAccount""), Res.get(""shared.cancel""));
            Button deleteAccountButton = tuple.first;
            deleteAccountButton.setOnAction(event -> onDeleteAccount(paymentMethodForm.getPaymentAccount()));
            Button cancelButton = tuple.second;
            cancelButton.setOnAction(event -> removeSelectAccountForm());
            GridPane.setRowSpan(accountTitledGroupBg, paymentMethodForm.getRowSpan());
            model.onSelectAccount(paymentAccount);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////////////////////////////////////////

    private PaymentMethodForm getPaymentMethodForm(PaymentAccount paymentAccount) {
        return getPaymentMethodForm(paymentAccount.getPaymentMethod(), paymentAccount);
    }

    private PaymentMethodForm getPaymentMethodForm(PaymentMethod paymentMethod) {
        final PaymentAccount paymentAccount = PaymentAccountFactory.getPaymentAccount(paymentMethod);
        paymentAccount.init();
        return getPaymentMethodForm(paymentMethod, paymentAccount);
    }

    private PaymentMethodForm getPaymentMethodForm(PaymentMethod paymentMethod, PaymentAccount paymentAccount) {
        switch (paymentMethod.getId()) {
            case PaymentMethod.UPHOLD_ID:
                return new UpholdForm(paymentAccount, accountAgeWitnessService, upholdValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.MONEY_BEAM_ID:
                return new MoneyBeamForm(paymentAccount, accountAgeWitnessService, moneyBeamValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.POPMONEY_ID:
                return new PopmoneyForm(paymentAccount, accountAgeWitnessService, popmoneyValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.REVOLUT_ID:
                return new RevolutForm(paymentAccount, accountAgeWitnessService, revolutValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.PERFECT_MONEY_ID:
                return new PerfectMoneyForm(paymentAccount, accountAgeWitnessService, perfectMoneyValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.SEPA_ID:
                return new SepaForm(paymentAccount, accountAgeWitnessService, ibanValidator, bicValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.SEPA_INSTANT_ID:
                return new SepaInstantForm(paymentAccount, accountAgeWitnessService, ibanValidator, bicValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.FASTER_PAYMENTS_ID:
                return new FasterPaymentsForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.NATIONAL_BANK_ID:
                return new NationalBankForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.SAME_BANK_ID:
                return new SameBankForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.SPECIFIC_BANKS_ID:
                return new SpecificBankForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.JAPAN_BANK_ID:
                return new JapanBankTransferForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.AUSTRALIA_PAYID_ID:
                return new AustraliaPayidForm(paymentAccount, accountAgeWitnessService, australiapayidValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.ALI_PAY_ID:
                return new AliPayForm(paymentAccount, accountAgeWitnessService, aliPayValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.WECHAT_PAY_ID:
                return new WeChatPayForm(paymentAccount, accountAgeWitnessService, weChatPayValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.SWISH_ID:
                return new SwishForm(paymentAccount, accountAgeWitnessService, swishValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.CLEAR_X_CHANGE_ID:
                return new ClearXchangeForm(paymentAccount, accountAgeWitnessService, clearXchangeValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.CHASE_QUICK_PAY_ID:
                return new ChaseQuickPayForm(paymentAccount, accountAgeWitnessService, chaseQuickPayValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.INTERAC_E_TRANSFER_ID:
                return new InteracETransferForm(paymentAccount, accountAgeWitnessService, interacETransferValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.US_POSTAL_MONEY_ORDER_ID:
                return new USPostalMoneyOrderForm(paymentAccount, accountAgeWitnessService, usPostalMoneyOrderValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.MONEY_GRAM_ID:
                return new MoneyGramForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.WESTERN_UNION_ID:
                return new WesternUnionForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.CASH_DEPOSIT_ID:
                return new CashDepositForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.CASH_BY_MAIL_ID:
                return new CashByMailForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.HAL_CASH_ID:
                return new HalCashForm(paymentAccount, accountAgeWitnessService, halCashValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.F2F_ID:
                return new F2FForm(paymentAccount, accountAgeWitnessService, f2FValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.PROMPT_PAY_ID:
                return new PromptPayForm(paymentAccount, accountAgeWitnessService, promptPayValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.ADVANCED_CASH_ID:
                return new AdvancedCashForm(paymentAccount, accountAgeWitnessService, advancedCashValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.TRANSFERWISE_ID:
                return new TransferwiseForm(paymentAccount, accountAgeWitnessService, transferwiseValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.TRANSFERWISE_USD_ID:
                return new TransferwiseUsdForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.PAYSERA_ID:
                return new PayseraForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.PAXUM_ID:
                return new PaxumForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.NEFT_ID:
                return new NeftForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.RTGS_ID:
                return new RtgsForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.IMPS_ID:
                return new ImpsForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.UPI_ID:
                return new UpiForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.PAYTM_ID:
                return new PaytmForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.NEQUI_ID:
                return new NequiForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.BIZUM_ID:
                return new BizumForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.PIX_ID:
                return new PixForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.AMAZON_GIFT_CARD_ID:
                return new AmazonGiftCardForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.CAPITUAL_ID:
                return new CapitualForm(paymentAccount, accountAgeWitnessService, capitualValidator, inputValidator, root, gridRow, formatter);
            case PaymentMethod.CELPAY_ID:
                return new CelPayForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.MONESE_ID:
                return new MoneseForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.SATISPAY_ID:
                return new SatispayForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.TIKKIE_ID:
                return new TikkieForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.VERSE_ID:
                return new VerseForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.STRIKE_ID:
                return new StrikeForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.SWIFT_ID:
                return new SwiftForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.ACH_TRANSFER_ID:
                return new AchTransferForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            case PaymentMethod.DOMESTIC_WIRE_TRANSFER_ID:
                return new DomesticWireTransferForm(paymentAccount, accountAgeWitnessService, inputValidator, root, gridRow, formatter);
            default:
                log.error(""Not supported PaymentMethod: "" + paymentMethod);
                return null;
        }
    }

    private void removeNewAccountForm() {
        saveNewAccountButton.disableProperty().unbind();
        removeAccountRows();
        addAccountButton.setDisable(false);
    }

    @Override
    protected void removeSelectAccountForm() {
        FormBuilder.removeRowsFromGridPane(root, 2, gridRow);
        gridRow = 1;
        addAccountButton.setDisable(false);
        paymentAccountsListView.getSelectionModel().clearSelection();
    }


    private void removeAccountRows() {
        FormBuilder.removeRowsFromGridPane(root, 2, gridRow);
        gridRow = 1;
    }

    @Override
    protected void copyAccount() {
        var selectedAccount = paymentAccountsListView.getSelectionModel().getSelectedItem();
        if (selectedAccount == null) {
            return;
        }
        Utilities.copyToClipboard(accountAgeWitnessService.getSignInfoFromAccount(selectedAccount));
    }

}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 123 437 381 2005 2006 59 437 381 2007 2008 59 437 381 2009 2010 59 437 381 2011 2012 59 437 381 2013 2014 59 437 381 2015 2016 59 437 381 2017 2018 59 437 381 2019 2020 59 437 381 2021 2022 59 437 381 2023 2024 59 437 381 2025 2026 59 437 381 2027 2028 59 437 381 2029 2030 59 437 381 2031 2032 59 437 381 2033 2034 59 437 381 2035 2036 59 437 381 2037 2038 59 437 381 2039 2040 59 437 381 2041 2042 59 437 381 2043 2044 59 437 381 2045 2046 59 437 381 2047 2048 59 437 381 2049 2050 59 437 381 2051 2052 59 437 2053 60 2054 62 2055 59 437 2056 2057 59 437 2058 2059 59 437 2060 2061 59 437 404 2062 61 1500 59 64 2063 439 2001 40 2004 2064 44 2005 2006 44 2007 2008 44 2009 2010 44 2011 2012 44 2013 2014 44 2015 2016 44 2017 2018 44 2019 2020 44 2021 2022 44 2023 2024 44 2025 2026 44 2027 2028 44 2029 2030 44 2031 2032 44 2033 2034 44 2035 2065 44 2037 2038 44 2039 2040 44 2041 2042 44 2043 2044 44 2045 2046 44 2047 2048 44 2049 2050 44 2066 2067 44 64 2068 40 2069 46 2070 41 2051 2052 41 123 463 40 2064 44 2067 41 59 467 46 2006 61 2006 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 467 46 2012 61 2012 59 467 46 2012 46 2071 40 1503 41 59 621 467 46 2012 46 2072 40 1502 41 59 467 46 2014 61 2014 59 467 46 2016 61 2016 59 467 46 2018 61 2018 59 467 46 2020 61 2020 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2026 61 2026 59 467 46 2028 61 2028 59 467 46 2030 61 2030 59 467 46 2032 61 2032 59 467 46 2034 61 2034 59 467 46 2036 61 2065 59 467 46 2038 61 2038 59 467 46 2040 61 2040 59 467 46 2042 61 2042 59 467 46 2044 61 2044 59 467 46 2046 61 2046 59 467 46 2048 61 2048 59 467 46 2050 61 2050 59 467 46 2052 61 2052 59 125 64 2073 438 2074 60 2075 62 2076 40 41 123 450 2064 46 2076 40 41 59 125 64 2073 438 492 2077 40 41 123 2064 46 2078 46 2077 40 40 2079 41 2080 46 2081 40 41 46 2082 40 41 41 59 125 64 2073 438 492 2083 40 41 123 2064 46 2084 46 2083 40 40 2085 41 2086 46 2087 40 41 46 2088 40 41 41 59 125 621 621 621 437 492 2089 40 2075 2090 41 123 2091 2092 61 2090 46 2093 40 41 46 2094 40 648 41 59 2091 2095 61 2092 46 2096 40 1502 41 59 2091 2097 61 2092 46 2096 40 1502 41 59 392 40 2090 402 2098 41 123 418 2099 40 41 46 2100 40 2101 46 2102 40 648 41 41 46 2103 40 1504 41 46 2104 40 2101 46 2102 40 648 41 41 46 2105 40 40 41 45 62 2106 46 2107 40 648 41 41 46 2108 40 2101 46 2102 40 648 41 41 46 2109 40 40 41 45 62 2110 40 2090 41 41 46 2111 40 41 59 125 360 392 40 2090 402 2112 41 123 621 418 2113 40 41 46 2114 40 2115 46 2116 40 648 41 41 46 2117 40 1504 41 46 2118 40 2115 46 2116 40 648 41 41 46 2119 40 2115 46 2116 40 648 41 41 46 2120 40 40 41 45 62 2121 40 2090 41 41 46 2122 40 41 59 125 360 392 40 2090 402 2123 41 123 621 418 2124 40 41 46 2125 40 2126 46 2127 40 648 41 41 46 2128 40 1504 41 46 2129 40 2126 46 2127 40 648 41 41 46 2130 40 2126 46 2127 40 648 41 41 46 2131 40 40 41 45 62 2132 40 2090 41 41 46 2133 40 41 59 125 360 123 2134 2135 61 648 59 2134 2136 61 2052 46 2137 40 2097 41 59 392 40 2054 46 2138 40 2090 46 2093 40 41 44 2090 46 2139 40 41 41 41 123 2135 61 648 59 2136 61 2052 46 2137 40 2140 46 2141 41 59 125 418 2142 40 41 46 2143 40 2144 46 2145 40 2135 44 2136 44 2052 46 2137 40 2095 41 44 2052 46 2137 40 2092 41 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 123 381 2134 2150 61 2151 46 2152 40 41 46 2153 40 41 59 392 40 2090 402 2154 41 123 418 2142 40 41 46 2143 40 2144 46 2145 40 648 44 2150 44 2150 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 2155 40 2090 41 41 46 2156 40 41 59 125 360 392 40 2090 402 2157 41 123 418 2142 40 41 46 2143 40 2144 46 2145 40 648 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 2158 40 2090 41 41 46 2159 40 41 59 125 360 392 40 2090 402 2160 41 123 418 2142 40 41 46 2143 40 2144 46 2145 40 648 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 2161 40 2090 41 41 46 2162 40 41 59 125 360 392 40 2090 402 2163 41 123 418 2142 40 41 46 2143 40 2144 46 2145 40 648 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 2164 40 2090 41 41 46 2165 40 41 59 125 360 392 40 2090 402 2166 41 123 418 2142 40 41 46 2143 40 2144 46 2145 40 648 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 2167 40 2090 41 41 46 2168 40 41 59 125 360 392 40 2090 402 2169 41 123 418 2142 40 41 46 2143 40 2144 46 2145 40 648 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 2170 40 2090 41 41 46 2171 40 41 59 125 360 392 40 2090 402 2172 41 123 418 2142 40 41 46 2143 40 2144 46 2145 40 648 44 2150 44 2150 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 2173 40 2090 41 41 46 2174 40 41 59 125 360 392 40 2090 402 2175 41 123 418 2142 40 41 46 2143 40 2144 46 2145 40 648 44 2150 44 2150 41 41 46 2146 40 1504 41 46 2147 40 2144 46 2145 40 648 41 41 46 2148 40 2144 46 2145 40 648 41 41 46 2149 40 40 41 45 62 2176 40 2090 41 41 46 2177 40 41 59 125 360 123 2178 40 2090 41 59 125 125 41 46 2179 40 41 59 125 125 437 492 2180 40 2075 2090 41 123 392 40 2076 40 41 46 2181 40 41 46 2182 40 2183 45 62 2183 46 2184 40 41 631 424 605 2183 46 2184 40 41 46 2185 40 2090 46 2184 40 41 41 41 41 123 2064 46 2089 40 2090 41 59 2186 40 41 59 125 360 123 418 2187 40 41 46 494 40 2188 46 2189 40 648 41 41 46 2190 40 41 59 125 125 437 492 2191 40 41 123 2192 40 41 59 125 438 324 2193 40 2075 2090 41 123 450 2064 46 2194 40 2090 41 59 125 621 621 621 64 2073 438 492 2195 40 41 123 2196 40 2197 44 2062 44 1502 44 2198 46 2199 40 648 41 41 59 2200 60 2201 44 2202 60 2075 62 44 2203 62 2204 61 2205 40 2197 44 2062 44 2198 46 2199 40 648 41 44 2206 46 2207 41 59 2208 61 2204 46 2209 59 404 2210 61 2211 46 2212 40 1502 44 2211 46 2213 40 1502 44 2064 46 2214 46 2215 40 41 41 41 59 2208 46 2216 40 2210 42 2206 46 2217 43 1503 41 59 2218 40 41 59 2200 60 2060 44 2060 44 2060 62 2219 61 2220 40 2197 44 637 2062 44 2198 46 2199 40 648 41 44 2198 46 2199 40 648 41 44 2198 46 2199 40 648 41 41 59 2221 61 2219 46 2222 59 2223 61 2219 46 2209 59 2224 61 2219 46 2225 59 125 621 64 2073 438 492 2226 40 41 123 2227 46 2228 40 41 46 2229 40 41 59 2230 40 41 59 2231 46 2232 40 473 41 59 2059 61 2233 40 2234 44 637 2062 44 1502 44 2235 46 2236 40 648 41 44 2237 46 2238 41 59 2055 61 2239 46 2240 40 2234 44 2062 44 2235 46 2236 40 648 41 44 2237 46 2241 41 59 2055 46 2242 40 1503 41 59 2055 46 2243 40 1504 41 59 2244 60 2054 62 411 61 2054 46 2245 40 41 46 2246 40 41 46 2247 40 2054 58 58 2248 41 46 2249 40 41 46 2250 40 2251 46 2252 40 41 41 59 2055 46 2253 40 2254 46 2255 40 411 41 41 59 2055 46 2256 40 418 2257 60 62 40 41 123 64 2073 439 2258 2259 40 2054 2260 41 123 450 2260 631 424 63 2235 46 2236 40 2260 46 2261 40 41 41 58 648 59 125 64 2073 439 2054 2262 40 2258 2263 41 123 450 424 59 125 125 41 59 2055 46 2264 40 2265 45 62 123 392 40 2057 631 424 41 123 2239 46 2266 40 2234 44 1502 44 2057 46 2267 40 41 43 1501 41 59 2003 46 2268 40 2059 44 2057 46 2269 40 41 43 1501 41 59 125 2062 61 1502 59 2057 61 2270 40 2055 46 2228 40 41 46 2271 40 41 41 59 392 40 2057 631 424 41 123 392 40 2057 46 2272 40 41 46 2273 40 41 631 424 41 123 418 2274 40 41 46 2275 40 2235 46 2236 40 2057 46 2272 40 41 46 2273 40 41 41 41 46 2276 40 1504 41 46 2277 40 2235 46 2236 40 648 41 41 46 2278 40 41 59 125 2057 46 2279 40 41 59 2062 61 2057 46 2280 40 41 59 2281 60 2060 44 2060 62 2282 61 2283 40 2234 44 637 2062 44 2235 46 2236 40 648 41 44 2235 46 2236 40 648 41 41 59 2061 61 2282 46 2284 59 2061 46 2264 40 373 45 62 2089 40 2057 46 2272 40 41 41 41 59 2061 46 2285 40 41 46 2286 40 2057 46 2287 40 41 46 422 40 41 41 59 2060 2288 61 2282 46 2289 59 2288 46 2264 40 373 45 62 2191 40 41 41 59 2003 46 2290 40 2059 44 2057 46 2291 40 41 43 1501 41 59 125 125 41 59 125 621 64 2073 438 492 2292 40 2075 2090 41 123 2293 40 41 59 2294 46 2295 40 380 41 59 2059 61 2296 40 2297 44 637 2062 44 1502 44 2298 46 2299 40 648 41 44 2300 46 2301 41 59 2057 61 2302 40 2090 41 59 392 40 2057 631 424 41 123 2057 46 2303 40 41 59 2062 61 2057 46 2304 40 41 59 2305 60 2060 44 2060 62 2306 61 2307 40 2297 44 637 2062 44 2298 46 2299 40 648 41 44 2298 46 2299 40 648 41 41 59 2060 2308 61 2306 46 2309 59 2308 46 2310 40 373 45 62 2311 40 2057 46 2312 40 41 41 41 59 2060 2313 61 2306 46 2314 59 2313 46 2310 40 373 45 62 2315 40 41 41 59 2003 46 2316 40 2059 44 2057 46 2317 40 41 41 59 2064 46 2292 40 2090 41 59 125 125 621 621 621 437 2056 2318 40 2075 2090 41 123 450 2318 40 2090 46 2319 40 41 44 2090 41 59 125 437 2056 2318 40 2054 2320 41 123 381 2075 2090 61 2321 46 2322 40 2320 41 59 2090 46 2323 40 41 59 450 2318 40 2320 44 2090 41 59 125 437 2056 2318 40 2054 2320 44 2075 2090 41 123 464 40 2320 46 2324 40 41 41 123 328 2054 46 2325 58 450 418 2326 40 2090 44 2067 44 2014 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2328 58 450 418 2329 40 2090 44 2067 44 2016 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2330 58 450 418 2331 40 2090 44 2067 44 2018 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2332 58 450 418 2333 40 2090 44 2067 44 2020 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2334 58 450 418 2335 40 2090 44 2067 44 2024 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2336 58 450 418 2337 40 2090 44 2067 44 2006 44 2008 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2338 58 450 418 2339 40 2090 44 2067 44 2006 44 2008 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2340 58 450 418 2341 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2342 58 450 418 2343 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2344 58 450 418 2345 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2346 58 450 418 2347 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2348 58 450 418 2349 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2350 58 450 418 2351 40 2090 44 2067 44 2036 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2352 58 450 418 2353 40 2090 44 2067 44 2022 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2354 58 450 418 2355 40 2090 44 2067 44 2040 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2356 58 450 418 2357 40 2090 44 2067 44 2026 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2358 58 450 418 2359 40 2090 44 2067 44 2028 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2360 58 450 418 2361 40 2090 44 2067 44 2030 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2362 58 450 418 2363 40 2090 44 2067 44 2032 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2364 58 450 418 2365 40 2090 44 2067 44 2038 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2366 58 450 418 2367 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2368 58 450 418 2369 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2370 58 450 418 2371 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2372 58 450 418 2373 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2374 58 450 418 2375 40 2090 44 2067 44 2042 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2376 58 450 418 2377 40 2090 44 2067 44 2044 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2378 58 450 418 2379 40 2090 44 2067 44 2046 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2380 58 450 418 2381 40 2090 44 2067 44 2048 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2382 58 450 418 2383 40 2090 44 2067 44 2050 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2384 58 450 418 2385 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2386 58 450 418 2387 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2388 58 450 418 2389 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2390 58 450 418 2391 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2392 58 450 418 2393 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2394 58 450 418 2395 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2396 58 450 418 2397 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2398 58 450 418 2399 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2400 58 450 418 2401 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2402 58 450 418 2403 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2404 58 450 418 2405 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2406 58 450 418 2407 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2408 58 450 418 2409 40 2090 44 2067 44 2010 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2410 58 450 418 2411 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2412 58 450 418 2413 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2414 58 450 418 2415 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2416 58 450 418 2417 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2418 58 450 418 2419 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2420 58 450 418 2421 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2422 58 450 418 2423 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2424 58 450 418 2425 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 328 2054 46 2426 58 450 418 2427 40 2090 44 2067 44 2012 44 2327 44 2062 44 2052 41 59 349 58 2428 46 371 40 648 43 2320 41 59 450 424 59 125 125 437 492 2429 40 41 123 2061 46 2430 40 41 46 2431 40 41 59 2432 40 41 59 2433 46 2434 40 380 41 59 125 64 2073 438 492 2435 40 41 123 2436 46 2437 40 2438 44 1502 44 2062 41 59 2062 61 1501 59 2439 46 2440 40 380 41 59 2441 46 2442 40 41 46 2443 40 41 59 125 437 492 2444 40 41 123 2445 46 2446 40 2447 44 1502 44 2062 41 59 2062 61 1501 59 125 64 2073 438 492 2448 40 41 123 490 2449 61 2450 46 2451 40 41 46 2452 40 41 59 392 40 2449 614 424 41 123 450 59 125 2453 46 2454 40 2067 46 2455 40 2449 41 41 59 125 125 
2588,Java,"public final class MineProcess extends BaritoneProcessHelper implements IMineProcess {

    private static final int ORE_LOCATIONS_COUNT = 64;

    private BlockOptionalMetaLookup filter;
    private List<BlockPos> knownOreLocations;
    private List<BlockPos> blacklist; // inaccessible
    private Map<BlockPos, Long> anticipatedDrops;
    private BlockPos branchPoint;
    private GoalRunAway branchPointRunaway;
    private int desiredQuantity;
    private int tickCount;

    public MineProcess(Baritone baritone) {
        super(baritone);
    }

    @Override
    public boolean isActive() {
        return filter != null;
    }

    @Override
    public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
        if (desiredQuantity > 0) {
            int curr = ctx.player().inventory.mainInventory.stream()
                    .filter(stack -> filter.has(stack))
                    .mapToInt(ItemStack::getCount).sum();
            System.out.println(""Currently have "" + curr + "" valid items"");
            if (curr >= desiredQuantity) {
                logDirect(""Have "" + curr + "" valid items"");
                cancel();
                return null;
            }
        }
        if (calcFailed) {
            if (!knownOreLocations.isEmpty() && Baritone.settings().blacklistClosestOnFailure.value) {
                logDirect(""Unable to find any path to "" + filter + "", blacklisting presumably unreachable closest instance..."");
                if (Baritone.settings().notificationOnMineFail.value) {
                    logNotification(""Unable to find any path to "" + filter + "", blacklisting presumably unreachable closest instance..."", true);
                }
                knownOreLocations.stream().min(Comparator.comparingDouble(ctx.player()::getDistanceSq)).ifPresent(blacklist::add);
                knownOreLocations.removeIf(blacklist::contains);
            } else {
                logDirect(""Unable to find any path to "" + filter + "", canceling mine"");
                if (Baritone.settings().notificationOnMineFail.value) {
                    logNotification(""Unable to find any path to "" + filter + "", canceling mine"", true);
                }
                cancel();
                return null;
            }
        }
        if (!Baritone.settings().allowBreak.value) {
            logDirect(""Unable to mine when allowBreak is false!"");
            cancel();
            return null;
        }
        updateLoucaSystem();
        int mineGoalUpdateInterval = Baritone.settings().mineGoalUpdateInterval.value;
        List<BlockPos> curr = new ArrayList<>(knownOreLocations);
        if (mineGoalUpdateInterval != 0 && tickCount++ % mineGoalUpdateInterval == 0) { // big brain
            CalculationContext context = new CalculationContext(baritone, true);
            Baritone.getExecutor().execute(() -> rescan(curr, context));
        }
        if (Baritone.settings().legitMine.value) {
            addNearby();
        }
        Optional<BlockPos> shaft = curr.stream()
                .filter(pos -> pos.getX() == ctx.playerFeet().getX() && pos.getZ() == ctx.playerFeet().getZ())
                .filter(pos -> pos.getY() >= ctx.playerFeet().getY())
                .filter(pos -> !(BlockStateInterface.get(ctx, pos).getBlock() instanceof BlockAir)) // after breaking a block, it takes mineGoalUpdateInterval ticks for it to actually update this list =(
                .min(Comparator.comparingDouble(ctx.player()::getDistanceSq));
        baritone.getInputOverrideHandler().clearAllKeys();
        if (shaft.isPresent() && ctx.player().onGround) {
            BlockPos pos = shaft.get();
            IBlockState state = baritone.bsi.get0(pos);
            if (!MovementHelper.avoidBreaking(baritone.bsi, pos.getX(), pos.getY(), pos.getZ(), state)) {
                Optional<Rotation> rot = RotationUtils.reachable(ctx, pos);
                if (rot.isPresent() && isSafeToCancel) {
                    baritone.getLookBehavior().updateTarget(rot.get(), true);
                    MovementHelper.switchToBestToolFor(ctx, ctx.world().getBlockState(pos));
                    if (ctx.isLookingAt(pos) || ctx.playerRotations().isReallyCloseTo(rot.get())) {
                        baritone.getInputOverrideHandler().setInputForceState(Input.CLICK_LEFT, true);
                    }
                    return new PathingCommand(null, PathingCommandType.REQUEST_PAUSE);
                }
            }
        }
        PathingCommand command = updateGoal();
        if (command == null) {
            // none in range
            // maybe say something in chat? (ahem impact)
            cancel();
            return null;
        }
        return command;
    }

    private void updateLoucaSystem() {
        Map<BlockPos, Long> copy = new HashMap<>(anticipatedDrops);
        ctx.getSelectedBlock().ifPresent(pos -> {
            if (knownOreLocations.contains(pos)) {
                copy.put(pos, System.currentTimeMillis() + Baritone.settings().mineDropLoiterDurationMSThanksLouca.value);
            }
        });
        // elaborate dance to avoid concurrentmodificationexcepption since rescan thread reads this
        // don't want to slow everything down with a gross lock do we now
        for (BlockPos pos : anticipatedDrops.keySet()) {
            if (copy.get(pos) < System.currentTimeMillis()) {
                copy.remove(pos);
            }
        }
        anticipatedDrops = copy;
    }

    @Override
    public void onLostControl() {
        mine(0, (BlockOptionalMetaLookup) null);
    }

    @Override
    public String displayName0() {
        return ""Mine "" + filter;
    }

    private PathingCommand updateGoal() {
        boolean legit = Baritone.settings().legitMine.value;
        List<BlockPos> locs = knownOreLocations;
        if (!locs.isEmpty()) {
            CalculationContext context = new CalculationContext(baritone);
            List<BlockPos> locs2 = prune(context, new ArrayList<>(locs), filter, ORE_LOCATIONS_COUNT, blacklist, droppedItemsScan());
            // can't reassign locs, gotta make a new var locs2, because we use it in a lambda right here, and variables you use in a lambda must be effectively final
            Goal goal = new GoalComposite(locs2.stream().map(loc -> coalesce(loc, locs2, context)).toArray(Goal[]::new));
            knownOreLocations = locs2;
            return new PathingCommand(goal, legit ? PathingCommandType.FORCE_REVALIDATE_GOAL_AND_PATH : PathingCommandType.REVALIDATE_GOAL_AND_PATH);
        }
        // we don't know any ore locations at the moment
        if (!legit && !Baritone.settings().exploreForBlocks.value) {
            return null;
        }
        // only when we should explore for blocks or are in legit mode we do this
        int y = Baritone.settings().legitMineYLevel.value;
        if (branchPoint == null) {
            /*if (!baritone.getPathingBehavior().isPathing() && playerFeet().y == y) {
                // cool, path is over and we are at desired y
                branchPoint = playerFeet();
                branchPointRunaway = null;
            } else {
                return new GoalYLevel(y);
            }*/
            branchPoint = ctx.playerFeet();
        }
        // TODO shaft mode, mine 1x1 shafts to either side
        // TODO also, see if the GoalRunAway with maintain Y at 11 works even from the surface
        if (branchPointRunaway == null) {
            branchPointRunaway = new GoalRunAway(1, y, branchPoint) {
                @Override
                public boolean isInGoal(int x, int y, int z) {
                    return false;
                }
                @Override
                public double heuristic() {
                    return Double.NEGATIVE_INFINITY;
                }
            };
        }
        return new PathingCommand(branchPointRunaway, PathingCommandType.REVALIDATE_GOAL_AND_PATH);
    }

    private void rescan(List<BlockPos> already, CalculationContext context) {
        if (filter == null) {
            return;
        }
        if (Baritone.settings().legitMine.value) {
            return;
        }
        List<BlockPos> dropped = droppedItemsScan();
        List<BlockPos> locs = searchWorld(context, filter, ORE_LOCATIONS_COUNT, already, blacklist, dropped);
        locs.addAll(dropped);
        if (locs.isEmpty() && !Baritone.settings().exploreForBlocks.value) {
            logDirect(""No locations for "" + filter + "" known, cancelling"");
            if (Baritone.settings().notificationOnMineFail.value) {
                logNotification(""No locations for "" + filter + "" known, cancelling"", true);
            }
            cancel();
            return;
        }
        knownOreLocations = locs;
    }

    private boolean internalMiningGoal(BlockPos pos, CalculationContext context, List<BlockPos> locs) {
        // Here, BlockStateInterface is used because the position may be in a cached chunk (the targeted block is one that is kept track of)
        if (locs.contains(pos)) {
            return true;
        }
        IBlockState state = context.bsi.get0(pos);
        if (Baritone.settings().internalMiningAirException.value && state.getBlock() instanceof BlockAir) {
            return true;
        }
        return filter.has(state) && plausibleToBreak(context, pos);
    }

    private Goal coalesce(BlockPos loc, List<BlockPos> locs, CalculationContext context) {
        boolean assumeVerticalShaftMine = !(baritone.bsi.get0(loc.up()).getBlock() instanceof BlockFalling);
        if (!Baritone.settings().forceInternalMining.value) {
            if (assumeVerticalShaftMine) {
                // we can get directly below the block
                return new GoalThreeBlocks(loc);
            } else {
                // we need to get feet or head into the block
                return new GoalTwoBlocks(loc);
            }
        }
        boolean upwardGoal = internalMiningGoal(loc.up(), context, locs);
        boolean downwardGoal = internalMiningGoal(loc.down(), context, locs);
        boolean doubleDownwardGoal = internalMiningGoal(loc.down(2), context, locs);
        if (upwardGoal == downwardGoal) { // symmetric
            if (doubleDownwardGoal && assumeVerticalShaftMine) {
                // we have a checkerboard like pattern
                // this one, and the one two below it
                // therefore it's fine to path to immediately below this one, since your feet will be in the doubleDownwardGoal
                // but only if assumeVerticalShaftMine
                return new GoalThreeBlocks(loc);
            } else {
                // this block has nothing interesting two below, but is symmetric vertically so we can get either feet or head into it
                return new GoalTwoBlocks(loc);
            }
        }
        if (upwardGoal) {
            // downwardGoal known to be false
            // ignore the gap then potential doubleDownward, because we want to path feet into this one and head into upwardGoal
            return new GoalBlock(loc);
        }
        // upwardGoal known to be false, downwardGoal known to be true
        if (doubleDownwardGoal && assumeVerticalShaftMine) {
            // this block and two below it are goals
            // path into the center of the one below, because that includes directly below this one
            return new GoalTwoBlocks(loc.down());
        }
        // upwardGoal false, downwardGoal true, doubleDownwardGoal false
        // just this block and the one immediately below, no others
        return new GoalBlock(loc.down());
    }

    private static class GoalThreeBlocks extends GoalTwoBlocks {

        public GoalThreeBlocks(BlockPos pos) {
            super(pos);
        }

        @Override
        public boolean isInGoal(int x, int y, int z) {
            return x == this.x && (y == this.y || y == this.y - 1 || y == this.y - 2) && z == this.z;
        }

        @Override
        public double heuristic(int x, int y, int z) {
            int xDiff = x - this.x;
            int yDiff = y - this.y;
            int zDiff = z - this.z;
            return GoalBlock.calculate(xDiff, yDiff < -1 ? yDiff + 2 : yDiff == -1 ? 0 : yDiff, zDiff);
        }
    }

    public List<BlockPos> droppedItemsScan() {
        if (!Baritone.settings().mineScanDroppedItems.value) {
            return Collections.emptyList();
        }
        List<BlockPos> ret = new ArrayList<>();
        for (Entity entity : ctx.world().loadedEntityList) {
            if (entity instanceof EntityItem) {
                EntityItem ei = (EntityItem) entity;
                if (filter.has(ei.getItem())) {
                    ret.add(new BlockPos(entity));
                }
            }
        }
        ret.addAll(anticipatedDrops.keySet());
        return ret;
    }

    public static List<BlockPos> searchWorld(CalculationContext ctx, BlockOptionalMetaLookup filter, int max, List<BlockPos> alreadyKnown, List<BlockPos> blacklist, List<BlockPos> dropped) {
        List<BlockPos> locs = new ArrayList<>();
        List<Block> untracked = new ArrayList<>();
        for (BlockOptionalMeta bom : filter.blocks()) {
            Block block = bom.getBlock();
            if (CachedChunk.BLOCKS_TO_KEEP_TRACK_OF.contains(block)) {
                BetterBlockPos pf = ctx.baritone.getPlayerContext().playerFeet();

                // maxRegionDistanceSq 2 means adjacent directly or adjacent diagonally; nothing further than that
                locs.addAll(ctx.worldData.getCachedWorld().getLocationsOf(
                        BlockUtils.blockToString(block),
                        Baritone.settings().maxCachedWorldScanCount.value,
                        pf.x,
                        pf.z,
                        2
                ));
            } else {
                untracked.add(block);
            }
        }

        locs = prune(ctx, locs, filter, max, blacklist, dropped);

        if (!untracked.isEmpty() || (Baritone.settings().extendCacheOnThreshold.value && locs.size() < max)) {
            locs.addAll(WorldScanner.INSTANCE.scanChunkRadius(
                    ctx.getBaritone().getPlayerContext(),
                    filter,
                    max,
                    10,
                    32
            )); // maxSearchRadius is NOT sq
        }

        locs.addAll(alreadyKnown);

        return prune(ctx, locs, filter, max, blacklist, dropped);
    }

    private void addNearby() {
        List<BlockPos> dropped = droppedItemsScan();
        knownOreLocations.addAll(dropped);
        BlockPos playerFeet = ctx.playerFeet();
        BlockStateInterface bsi = new BlockStateInterface(ctx);
        int searchDist = 10;
        double fakedBlockReachDistance = 20; // at least 10 * sqrt(3) with some extra space to account for positioning within the block
        for (int x = playerFeet.getX() - searchDist; x <= playerFeet.getX() + searchDist; x++) {
            for (int y = playerFeet.getY() - searchDist; y <= playerFeet.getY() + searchDist; y++) {
                for (int z = playerFeet.getZ() - searchDist; z <= playerFeet.getZ() + searchDist; z++) {
                    // crucial to only add blocks we can see because otherwise this
                    // is an x-ray and it'll get caught
                    if (filter.has(bsi.get0(x, y, z))) {
                        BlockPos pos = new BlockPos(x, y, z);
                        if ((Baritone.settings().legitMineIncludeDiagonals.value && knownOreLocations.stream().anyMatch(ore -> ore.distanceSq(pos) <= 2 /* sq means this is pytha dist <= sqrt(2) */)) || RotationUtils.reachable(ctx.player(), pos, fakedBlockReachDistance).isPresent()) {
                            knownOreLocations.add(pos);
                        }
                    }
                }
            }
        }
        knownOreLocations = prune(new CalculationContext(baritone), knownOreLocations, filter, ORE_LOCATIONS_COUNT, blacklist, dropped);
    }

    private static List<BlockPos> prune(CalculationContext ctx, List<BlockPos> locs2, BlockOptionalMetaLookup filter, int max, List<BlockPos> blacklist, List<BlockPos> dropped) {
        dropped.removeIf(drop -> {
            for (BlockPos pos : locs2) {
                if (pos.distanceSq(drop) <= 9 && filter.has(ctx.get(pos.getX(), pos.getY(), pos.getZ())) && MineProcess.plausibleToBreak(ctx, pos)) { // TODO maybe drop also has to be supported? no lava below?
                    return true;
                }
            }
            return false;
        });
        List<BlockPos> locs = locs2
                .stream()
                .distinct()

                // remove any that are within loaded chunks that aren't actually what we want
                .filter(pos -> !ctx.bsi.worldContainsLoadedChunk(pos.getX(), pos.getZ()) || filter.has(ctx.get(pos.getX(), pos.getY(), pos.getZ())) || dropped.contains(pos))

                // remove any that are implausible to mine (encased in bedrock, or touching lava)
                .filter(pos -> MineProcess.plausibleToBreak(ctx, pos))

                .filter(pos -> {
                    if (Baritone.settings().allowOnlyExposedOres.value) {
                        return isNextToAir(ctx, pos);
                    } else {
                        return true;
                    }
                })

                .filter(pos -> pos.getY() >= Baritone.settings().minYLevelWhileMining.value)

                .filter(pos -> !blacklist.contains(pos))

                .sorted(Comparator.comparingDouble(ctx.getBaritone().getPlayerContext().player()::getDistanceSq))
                .collect(Collectors.toList());

        if (locs.size() > max) {
            return locs.subList(0, max);
        }
        return locs;
    }

    public static boolean isNextToAir(CalculationContext ctx, BlockPos pos) {
        int radius = Baritone.settings().allowOnlyExposedOresDistance.value;
        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                for (int dz = -radius; dz <= radius; dz++) {
                    if (Math.abs(dx) + Math.abs(dy) + Math.abs(dz) <= radius
                            && MovementHelper.isTransparent(ctx.getBlock(pos.getX() + dx, pos.getY() + dy, pos.getZ() + dz))) {
                        return true;
                    }
                }
            }
        }
        return false;
    }


    public static boolean plausibleToBreak(CalculationContext ctx, BlockPos pos) {
        if (MovementHelper.getMiningDurationTicks(ctx, pos.getX(), pos.getY(), pos.getZ(), ctx.bsi.get0(pos), true) >= COST_INF) {
            return false;
        }

        // bedrock above and below makes it implausible, otherwise we're good
        return !(ctx.bsi.get0(pos.up()).getBlock() == Blocks.BEDROCK && ctx.bsi.get0(pos.down()).getBlock() == Blocks.BEDROCK);
    }

    @Override
    public void mineByName(int quantity, String... blocks) {
        mine(quantity, new BlockOptionalMetaLookup(blocks));
    }

    @Override
    public void mine(int quantity, BlockOptionalMetaLookup filter) {
        this.filter = filter;
        if (filter != null && !Baritone.settings().allowBreak.value) {
            logDirect(""Unable to mine when allowBreak is false!"");
            this.mine(quantity, (BlockOptionalMetaLookup) null);
            return;
        }
        this.desiredQuantity = quantity;
        this.knownOreLocations = new ArrayList<>();
        this.blacklist = new ArrayList<>();
        this.branchPoint = null;
        this.branchPointRunaway = null;
        this.anticipatedDrops = new HashMap<>();
        if (filter != null) {
            rescan(new ArrayList<>(), new CalculationContext(baritone));
        }
    }
}",1,439 381 334 2000 378 2001 395 2002 123 437 457 381 404 2003 61 1503 59 437 2004 2005 59 437 2006 60 2007 62 2008 59 437 2006 60 2007 62 2009 59 621 437 2010 60 2007 44 2011 62 2012 59 437 2007 2013 59 437 2014 2015 59 437 404 2016 59 437 404 2017 59 439 2000 40 2018 2019 41 123 463 40 2019 41 59 125 64 2020 439 324 2021 40 41 123 450 2005 631 424 59 125 64 2020 439 2022 2023 40 324 2024 44 324 2025 41 123 392 40 2016 62 1500 41 123 404 2026 61 2027 46 2028 40 41 46 2029 46 2030 46 2031 40 41 46 2005 40 2032 45 62 2005 46 2033 40 2032 41 41 46 2034 40 2035 58 58 2036 41 46 2037 40 41 59 2038 46 430 46 2039 40 648 43 2026 43 648 41 59 392 40 2026 615 2016 41 123 2040 40 648 43 2026 43 648 41 59 2041 40 41 59 450 424 59 125 125 392 40 2024 41 123 392 40 33 2008 46 2042 40 41 605 2018 46 2043 40 41 46 2044 46 2045 41 123 2046 40 648 43 2005 43 648 41 59 392 40 2018 46 2043 40 41 46 2047 46 2045 41 123 2048 40 648 43 2005 43 648 44 473 41 59 125 2008 46 2049 40 41 46 2050 40 2051 46 2052 40 2053 46 2054 40 41 58 58 2055 41 41 46 2056 40 2009 58 58 2057 41 59 2008 46 2058 40 2009 58 58 2059 41 59 125 360 123 2060 40 648 43 2005 43 648 41 59 392 40 2018 46 2043 40 41 46 2061 46 2045 41 123 2062 40 648 43 2005 43 648 44 473 41 59 125 2063 40 41 59 450 424 59 125 125 392 40 33 2018 46 2064 40 41 46 2065 46 2066 41 123 2067 40 648 41 59 2068 40 41 59 450 424 59 125 2069 40 41 59 404 2070 61 2018 46 2064 40 41 46 2070 46 2066 59 2006 60 2007 62 2071 61 418 2072 60 62 40 2008 41 59 392 40 2070 631 1500 605 2017 637 37 2070 614 1500 41 123 621 2073 2074 61 418 2073 40 2019 44 473 41 59 2018 46 2075 40 41 46 2076 40 40 41 45 62 2077 40 2071 44 2074 41 41 59 125 392 40 2018 46 2064 40 41 46 2078 46 2066 41 123 2079 40 41 59 125 2080 60 2007 62 2081 61 2071 46 2082 40 41 46 2005 40 2083 45 62 2083 46 2084 40 41 614 2085 46 2086 40 41 46 2084 40 41 605 2083 46 2087 40 41 614 2085 46 2086 40 41 46 2087 40 41 41 46 2005 40 2083 45 62 2083 46 2088 40 41 615 2085 46 2086 40 41 46 2088 40 41 41 46 2005 40 2083 45 62 33 40 2089 46 2090 40 2085 44 2083 41 46 2091 40 41 402 2092 41 41 621 46 2093 40 2094 46 2095 40 2085 46 2096 40 41 58 58 2097 41 41 59 2019 46 2098 40 41 46 2099 40 41 59 392 40 2081 46 2100 40 41 605 2085 46 2096 40 41 46 2101 41 123 2007 2083 61 2081 46 2090 40 41 59 2102 2103 61 2019 46 2104 46 2105 40 2083 41 59 392 40 33 2106 46 2107 40 2019 46 2104 44 2083 46 2084 40 41 44 2083 46 2088 40 41 44 2083 46 2087 40 41 44 2103 41 41 123 2080 60 2108 62 2109 61 2110 46 2111 40 2085 44 2083 41 59 392 40 2109 46 2100 40 41 605 2025 41 123 2019 46 2112 40 41 46 2113 40 2109 46 2090 40 41 44 473 41 59 2106 46 2114 40 2085 44 2085 46 2115 40 41 46 2116 40 2083 41 41 59 392 40 2085 46 2117 40 2083 41 606 2085 46 2118 40 41 46 2119 40 2109 46 2090 40 41 41 41 123 2019 46 2098 40 41 46 2120 40 2121 46 2122 44 473 41 59 125 450 418 2022 40 424 44 2123 46 2124 41 59 125 125 125 2022 2125 61 2126 40 41 59 392 40 2125 614 424 41 123 621 621 2127 40 41 59 450 424 59 125 450 2125 59 125 437 492 2128 40 41 123 2010 60 2007 44 2011 62 2129 61 418 2130 60 62 40 2012 41 59 2131 46 2132 40 41 46 2133 40 2134 45 62 123 392 40 2008 46 2135 40 2134 41 41 123 2129 46 2136 40 2134 44 2137 46 2138 40 41 43 2018 46 2139 40 41 46 2140 46 2141 41 59 125 125 41 59 621 621 385 40 2007 2134 58 2012 46 2142 40 41 41 123 392 40 2129 46 2143 40 2134 41 60 2144 46 2145 40 41 41 123 2129 46 2146 40 2134 41 59 125 125 2012 61 2129 59 125 64 2020 439 492 2147 40 41 123 2148 40 1500 44 40 2004 41 424 41 59 125 64 2020 439 2149 2150 40 41 123 450 648 43 2005 59 125 437 2022 2151 40 41 123 324 2152 61 2018 46 2153 40 41 46 2154 46 2155 59 2006 60 2007 62 2156 61 2008 59 392 40 33 2156 46 2157 40 41 41 123 2158 2159 61 418 2158 40 2019 41 59 2006 60 2007 62 2160 61 2161 40 2159 44 418 2162 60 62 40 2156 41 44 2005 44 2003 44 2009 44 2163 40 41 41 59 621 2164 2165 61 418 2166 40 2160 46 2167 40 41 46 2168 40 2169 45 62 2170 40 2169 44 2160 44 2159 41 41 46 2171 40 2164 91 93 58 58 418 41 41 59 2008 61 2160 59 450 418 2022 40 2165 44 2152 63 2172 46 2173 58 2172 46 2174 41 59 125 621 392 40 33 2152 605 33 2018 46 2153 40 41 46 2175 46 2155 41 123 450 424 59 125 621 404 2176 61 2018 46 2153 40 41 46 2177 46 2155 59 392 40 2013 614 424 41 123 604 2013 61 2178 46 2179 40 41 59 125 621 621 392 40 2015 614 424 41 123 2015 61 418 2014 40 1501 44 2176 44 2013 41 123 64 2020 439 324 2180 40 404 2181 44 404 2176 44 404 2182 41 123 450 380 59 125 64 2020 439 356 2183 40 41 123 450 2184 46 2185 59 125 125 59 125 450 418 2022 40 2015 44 2186 46 2187 41 59 125 437 492 2188 40 2006 60 2007 62 2189 44 2190 2191 41 123 392 40 2005 614 424 41 123 450 59 125 392 40 2018 46 2192 40 41 46 2193 46 2194 41 123 450 59 125 2006 60 2007 62 2195 61 2196 40 41 59 2006 60 2007 62 2197 61 2198 40 2191 44 2005 44 2003 44 2189 44 2009 44 2195 41 59 2197 46 2199 40 2195 41 59 392 40 2197 46 2200 40 41 605 33 2018 46 2192 40 41 46 2201 46 2194 41 123 2202 40 648 43 2005 43 648 41 59 392 40 2018 46 2192 40 41 46 2203 46 2194 41 123 2204 40 648 43 2005 43 648 44 473 41 59 125 2205 40 41 59 450 59 125 2008 61 2197 59 125 437 324 2206 40 2007 2207 44 2190 2191 44 2006 60 2007 62 2208 41 123 621 392 40 2208 46 2209 40 2207 41 41 123 450 473 59 125 2210 2211 61 2191 46 2212 46 2213 40 2207 41 59 392 40 2018 46 2214 40 41 46 2215 46 2216 605 2211 46 2217 40 41 402 2218 41 123 450 473 59 125 450 2005 46 2219 40 2211 41 605 2220 40 2191 44 2207 41 59 125 437 2221 2222 40 2007 2223 44 2006 60 2007 62 2208 44 2190 2191 41 123 324 2224 61 33 40 2019 46 2225 46 2226 40 2223 46 2227 40 41 41 46 2228 40 41 402 2229 41 59 392 40 33 2018 46 2230 40 41 46 2231 46 2232 41 123 392 40 2224 41 123 621 450 418 2233 40 2223 41 59 125 360 123 621 450 418 2234 40 2223 41 59 125 125 324 2235 61 2206 40 2223 46 2227 40 41 44 2191 44 2208 41 59 324 2236 61 2206 40 2223 46 2237 40 41 44 2191 44 2208 41 59 324 2238 61 2206 40 2223 46 2237 40 1502 41 44 2191 44 2208 41 59 392 40 2235 614 2236 41 123 621 392 40 2238 605 2224 41 123 621 621 621 621 450 418 2239 40 2223 41 59 125 360 123 621 450 418 2240 40 2223 41 59 125 125 392 40 2235 41 123 621 621 450 418 2241 40 2223 41 59 125 621 392 40 2238 605 2224 41 123 621 621 450 418 2242 40 2223 46 2237 40 41 41 59 125 621 621 450 418 2243 40 2223 46 2237 40 41 41 59 125 437 457 334 2244 378 2245 123 439 2244 40 2007 2207 41 123 463 40 2207 41 59 125 64 2020 439 324 2246 40 404 2247 44 404 2248 44 404 2249 41 123 450 2247 614 467 46 2247 605 40 2248 614 467 46 2248 606 2248 614 467 46 2248 45 1501 606 2248 614 467 46 2248 45 1502 41 605 2249 614 467 46 2249 59 125 64 2020 439 356 2250 40 404 2247 44 404 2248 44 404 2249 41 123 404 2251 61 2247 45 467 46 2247 59 404 2252 61 2248 45 467 46 2248 59 404 2253 61 2249 45 467 46 2249 59 450 2254 46 2255 40 2251 44 2252 60 45 1501 63 2252 43 1502 58 2252 614 45 1501 63 1500 58 2252 44 2253 41 59 125 125 439 2006 60 2007 62 2256 40 41 123 392 40 33 2018 46 2257 40 41 46 2258 46 2259 41 123 450 2260 46 2261 40 41 59 125 2006 60 2007 62 2262 61 418 2263 60 62 40 41 59 385 40 2264 2265 58 2266 46 2267 40 41 46 2268 41 123 392 40 2265 402 2269 41 123 2269 2270 61 40 2269 41 2265 59 392 40 2005 46 2271 40 2270 46 2272 40 41 41 41 123 2262 46 2273 40 418 2007 40 2265 41 41 59 125 125 125 2262 46 2274 40 2012 46 2275 40 41 41 59 450 2262 59 125 439 457 2006 60 2007 62 2276 40 2190 2277 44 2004 2005 44 404 2278 44 2006 60 2007 62 2279 44 2006 60 2007 62 2009 44 2006 60 2007 62 2280 41 123 2006 60 2007 62 2208 61 418 2281 60 62 40 41 59 2006 60 2282 62 2283 61 418 2281 60 62 40 41 59 385 40 2284 2285 58 2005 46 2286 40 41 41 123 2282 2287 61 2285 46 2288 40 41 59 392 40 2289 46 2290 46 2291 40 2287 41 41 123 2292 2293 61 2277 46 2019 46 2294 40 41 46 2295 40 41 59 621 2208 46 2296 40 2277 46 2297 46 2298 40 41 46 2299 40 2300 46 2301 40 2287 41 44 2018 46 2302 40 41 46 2303 46 2304 44 2293 46 2305 44 2293 46 2306 44 1502 41 41 59 125 360 123 2283 46 2307 40 2287 41 59 125 125 2208 61 2308 40 2277 44 2208 44 2005 44 2278 44 2009 44 2280 41 59 392 40 33 2283 46 2309 40 41 606 40 2018 46 2310 40 41 46 2311 46 2312 605 2208 46 2313 40 41 60 2278 41 41 123 2208 46 2314 40 2315 46 2316 46 2317 40 2277 46 2318 40 41 46 2319 40 41 44 2005 44 2278 44 1502 44 1503 41 41 59 621 125 2208 46 2320 40 2279 41 59 450 2308 40 2277 44 2208 44 2005 44 2278 44 2009 44 2280 41 59 125 437 492 2321 40 41 123 2006 60 2007 62 2280 61 2256 40 41 59 2008 46 2322 40 2280 41 59 2007 2323 61 2277 46 2323 40 41 59 2324 2325 61 418 2324 40 2277 41 59 404 2326 61 1502 59 356 2327 61 1503 59 621 385 40 404 2328 61 2323 46 2329 40 41 45 2326 59 2328 620 2323 46 2329 40 41 43 2326 59 2328 637 41 123 385 40 404 2330 61 2323 46 2331 40 41 45 2326 59 2330 620 2323 46 2331 40 41 43 2326 59 2330 637 41 123 385 40 404 2332 61 2323 46 2333 40 41 45 2326 59 2332 620 2323 46 2333 40 41 43 2326 59 2332 637 41 123 621 621 392 40 2005 46 2334 40 2325 46 2335 40 2328 44 2330 44 2332 41 41 41 123 2007 2207 61 418 2007 40 2328 44 2330 44 2332 41 59 392 40 40 2018 46 2336 40 41 46 2337 46 2338 605 2008 46 2339 40 41 46 2340 40 2341 45 62 2341 46 2342 40 2207 41 620 1502 604 41 41 606 2343 46 2344 40 2277 46 2345 40 41 44 2207 44 2327 41 46 2346 40 41 41 123 2008 46 2347 40 2207 41 59 125 125 125 125 125 2008 61 2348 40 418 2190 40 2019 41 44 2008 44 2005 44 2003 44 2009 44 2280 41 59 125 437 457 2006 60 2007 62 2349 40 2190 2277 44 2006 60 2007 62 2350 44 2004 2005 44 404 2278 44 2006 60 2007 62 2009 44 2006 60 2007 62 2280 41 123 2280 46 2351 40 2352 45 62 123 385 40 2007 2207 58 2350 41 123 392 40 2207 46 2353 40 2352 41 620 1502 605 2005 46 2354 40 2277 46 2355 40 2207 46 2356 40 41 44 2207 46 2357 40 41 44 2207 46 2358 40 41 41 41 605 2000 46 2359 40 2277 44 2207 41 41 123 621 450 473 59 125 125 450 380 59 125 41 59 2006 60 2007 62 2208 61 2350 46 2360 40 41 46 2361 40 41 621 46 2005 40 2207 45 62 33 2277 46 2362 46 2363 40 2207 46 2364 40 41 44 2207 46 2365 40 41 41 606 2005 46 2366 40 2277 46 2367 40 2207 46 2364 40 41 44 2207 46 2368 40 41 44 2207 46 2365 40 41 41 41 606 2280 46 2369 40 2207 41 41 621 46 2005 40 2207 45 62 2000 46 2370 40 2277 44 2207 41 41 46 2005 40 2207 45 62 123 392 40 2018 46 2371 40 41 46 2372 46 2373 41 123 450 2374 40 2277 44 2207 41 59 125 360 123 450 473 59 125 125 41 46 2005 40 2207 45 62 2207 46 2368 40 41 615 2018 46 2375 40 41 46 2376 46 2377 41 46 2005 40 2207 45 62 33 2009 46 2369 40 2207 41 41 46 2378 40 2379 46 2380 40 2277 46 2381 40 41 46 2382 40 41 46 2383 40 41 58 58 2384 41 41 46 2385 40 2386 46 2387 40 41 41 59 392 40 2208 46 2388 40 41 62 2278 41 123 450 2208 46 2389 40 1500 44 2278 41 59 125 450 2208 59 125 439 457 324 2390 40 2190 2277 44 2007 2207 41 123 404 2391 61 2018 46 2392 40 41 46 2393 46 2394 59 385 40 404 2395 61 45 2391 59 2395 620 2391 59 2395 637 41 123 385 40 404 2396 61 45 2391 59 2396 620 2391 59 2396 637 41 123 385 40 404 2397 61 45 2391 59 2397 620 2391 59 2397 637 41 123 392 40 2398 46 2399 40 2395 41 43 2398 46 2399 40 2396 41 43 2398 46 2399 40 2397 41 620 2391 605 2400 46 2401 40 2277 46 2402 40 2207 46 2403 40 41 43 2395 44 2207 46 2404 40 41 43 2396 44 2207 46 2405 40 41 43 2397 41 41 41 123 450 473 59 125 125 125 125 450 380 59 125 439 457 324 2406 40 2190 2277 44 2007 2207 41 123 392 40 2407 46 2408 40 2277 44 2207 46 2409 40 41 44 2207 46 2410 40 41 44 2207 46 2411 40 41 44 2277 46 2412 46 2413 40 2207 41 44 473 41 615 2414 41 123 450 380 59 125 621 450 33 40 2277 46 2412 46 2413 40 2207 46 2415 40 41 41 46 2416 40 41 614 2417 46 2418 605 2277 46 2412 46 2413 40 2207 46 2419 40 41 41 46 2416 40 41 614 2417 46 2418 41 59 125 64 2020 439 492 2420 40 404 2421 44 2149 613 2422 41 123 2423 40 2421 44 418 2004 40 2422 41 41 59 125 64 2020 439 492 2424 40 404 2421 44 2004 2005 41 123 467 46 2005 61 2005 59 392 40 2005 631 424 605 33 2018 46 2425 40 41 46 2426 46 2427 41 123 2428 40 648 41 59 467 46 2424 40 2421 44 40 2004 41 424 41 59 450 59 125 467 46 2016 61 2421 59 467 46 2008 61 418 2429 60 62 40 41 59 467 46 2009 61 418 2429 60 62 40 41 59 467 46 2013 61 424 59 467 46 2015 61 424 59 467 46 2012 61 418 2430 60 62 40 41 59 392 40 2005 631 424 41 123 2188 40 418 2429 60 62 40 41 44 418 2190 40 2019 41 41 59 125 125 125 
2993,Java,"public class TradeWalletService {
    private static final Logger log = LoggerFactory.getLogger(TradeWalletService.class);
    private static final Coin MIN_DELAYED_PAYOUT_TX_FEE = Coin.valueOf(1000);

    private final WalletsSetup walletsSetup;
    private final Preferences preferences;
    private final NetworkParameters params;

    @Nullable
    private Wallet wallet;
    @Nullable
    private WalletConfig walletConfig;
    @Nullable
    private KeyParameter aesKey;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, initialization
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public TradeWalletService(WalletsSetup walletsSetup, Preferences preferences) {
        this.walletsSetup = walletsSetup;
        this.preferences = preferences;
        this.params = Config.baseCurrencyNetworkParameters();
        walletsSetup.addSetupCompletedHandler(() -> {
            walletConfig = walletsSetup.getWalletConfig();
            wallet = walletsSetup.getBtcWallet();
        });
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // AesKey
    ///////////////////////////////////////////////////////////////////////////////////////////

    void setAesKey(@Nullable KeyParameter newAesKey) {
        this.aesKey = newAesKey;
    }

    @Nullable
    public KeyParameter getAesKey() {
        return aesKey;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Trade fee
    ///////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Create a BTC trading fee transaction for the maker or taker of an offer. The first output of the tx is for the
     * fee receiver. The second output is the reserve of the trade. There is an optional third output for change.
     *
     * @param fundingAddress          the provided source of funds in case the savings wallet is not used
     * @param reservedForTradeAddress the address of the trade reserve
     * @param changeAddress           the change address to use in case of overpayment or use of the savings wallet
     * @param reservedFundsForOffer   the amount to reserve for the trade
     * @param useSavingsWallet        {@code true} to use the savings wallet, {@code false} to use the funding address
     * @param tradingFee              the amount of the trading fee
     * @param txFee                   the mining fee for this transaction
     * @param feeReceiverAddress      the address of the receiver of the trading fee
     * @param doBroadcast             {@code true} to broadcast the transaction, {@code false} otherwise
     * @param callback                an optional callback to use when broadcasting the transaction
     * @return the optionally broadcast transaction
     * @throws InsufficientMoneyException if the request could not be completed due to not enough balance
     * @throws AddressFormatException if the fee receiver base58 address doesn't parse or its checksum is invalid
     */
    public Transaction createBtcTradingFeeTx(Address fundingAddress,
                                             Address reservedForTradeAddress,
                                             Address changeAddress,
                                             Coin reservedFundsForOffer,
                                             boolean useSavingsWallet,
                                             Coin tradingFee,
                                             Coin txFee,
                                             String feeReceiverAddress,
                                             boolean doBroadcast,
                                             @Nullable TxBroadcaster.Callback callback) throws InsufficientMoneyException, AddressFormatException {
        Transaction tradingFeeTx = new Transaction(params);
        SendRequest sendRequest = null;
        try {
            tradingFeeTx.addOutput(tradingFee, Address.fromString(params, feeReceiverAddress));
            // the reserved amount we need for the trade we send to our trade reservedForTradeAddress
            tradingFeeTx.addOutput(reservedFundsForOffer, reservedForTradeAddress);

            // we allow spending of unconfirmed tx (double spend risk is low and usability would suffer if we need to
            // wait for 1 confirmation)
            // In case of double spend we will detect later in the trade process and use a ban score to penalize bad behaviour (not impl. yet)
            sendRequest = SendRequest.forTx(tradingFeeTx);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            if (useSavingsWallet) {
                sendRequest.coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                        preferences.getIgnoreDustThreshold());
            } else {
                sendRequest.coinSelector = new BtcCoinSelector(fundingAddress, preferences.getIgnoreDustThreshold());
            }
            // We use a fixed fee

            sendRequest.fee = txFee;
            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;

            // Change is optional in case of overpay or use of funds from savings wallet
            sendRequest.changeAddress = changeAddress;

            checkNotNull(wallet, ""Wallet must not be null"");
            wallet.completeTx(sendRequest);
            if (removeDust(tradingFeeTx)) {
                wallet.signTransaction(sendRequest);
            }
            WalletService.printTx(""tradingFeeTx"", tradingFeeTx);

            if (doBroadcast && callback != null) {
                broadcastTx(tradingFeeTx, callback);
            }

            return tradingFeeTx;
        } catch (Throwable t) {
            if (wallet != null && sendRequest != null && sendRequest.coinSelector != null) {
                log.error(""Balance = {}; CoinSelector = {}"", wallet.getBalance(sendRequest.coinSelector), sendRequest.coinSelector);
            }
            log.error(""createBtcTradingFeeTx failed: tradingFeeTx={}, txOutputs={}"", tradingFeeTx.toString(),
                    tradingFeeTx.getOutputs());
            throw t;
        }
    }

    public Transaction completeBsqTradingFeeTx(Transaction preparedBsqTx,
                                               Address fundingAddress,
                                               Address reservedForTradeAddress,
                                               Address changeAddress,
                                               Coin reservedFundsForOffer,
                                               boolean useSavingsWallet,
                                               Coin txFee)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException, AddressFormatException {
        try {
            // preparedBsqTx has following structure:
            // inputs [1-n] BSQ inputs
            // outputs [0-1] BSQ change output
            // mining fee: burned BSQ fee

            // We add BTC mining fee. Result tx looks like:
            // inputs [1-n] BSQ inputs
            // inputs [1-n] BTC inputs
            // outputs [0-1] BSQ change output
            // outputs [1] BTC reservedForTrade output
            // outputs [0-1] BTC change output
            // mining fee: BTC mining fee + burned BSQ fee

            // In case all BSQ were burnt as fees we have no receiver output and it might be that there are no change outputs
            // We need to guarantee that min. 1 valid output is added (OP_RETURN does not count). So we use a higher input
            // for BTC to force an additional change output.

            final int preparedBsqTxInputsSize = preparedBsqTx.getInputs().size();
            final boolean hasBsqOutputs = !preparedBsqTx.getOutputs().isEmpty();

            // If there are no BSQ change outputs an output larger than the burnt BSQ amount has to be added as the first
            // output to make sure the reserved funds are in output 1, deposit tx input creation depends on the reserve
            // being output 1. The amount has to be larger than the BSQ input to make sure the inputs get burnt.
            // The BTC changeAddress is used, so it might get used for both output 0 and output 2.
            if (!hasBsqOutputs) {
                var bsqInputValue = preparedBsqTx.getInputs().stream()
                        .map(TransactionInput::getValue)
                        .reduce(Coin.valueOf(0), Coin::add);

                preparedBsqTx.addOutput(bsqInputValue.add(Coin.valueOf(1)), changeAddress);
            }
            // the reserved amount we need for the trade we send to our trade reservedForTradeAddress
            preparedBsqTx.addOutput(reservedFundsForOffer, reservedForTradeAddress);

            // we allow spending of unconfirmed tx (double spend risk is low and usability would suffer if we need to
            // wait for 1 confirmation)
            // In case of double spend we will detect later in the trade process and use a ban score to penalize bad behaviour (not impl. yet)

            SendRequest sendRequest = SendRequest.forTx(preparedBsqTx);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            if (useSavingsWallet) {
                sendRequest.coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                        preferences.getIgnoreDustThreshold());
            } else {
                sendRequest.coinSelector = new BtcCoinSelector(fundingAddress, preferences.getIgnoreDustThreshold());
            }
            // We use a fixed fee
            sendRequest.fee = txFee;
            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;

            sendRequest.signInputs = false;

            // Change is optional in case of overpay or use of funds from savings wallet
            sendRequest.changeAddress = changeAddress;

            checkNotNull(wallet, ""Wallet must not be null"");
            wallet.completeTx(sendRequest);
            Transaction resultTx = sendRequest.tx;
            removeDust(resultTx);

            // Sign all BTC inputs
            for (int i = preparedBsqTxInputsSize; i < resultTx.getInputs().size(); i++) {
                TransactionInput txIn = resultTx.getInputs().get(i);
                checkArgument(txIn.getConnectedOutput() != null &&
                                txIn.getConnectedOutput().isMine(wallet),
                        ""txIn.getConnectedOutput() is not in our wallet. That must not happen."");
                WalletService.signTransactionInput(wallet, aesKey, resultTx, txIn, i);
                WalletService.checkScriptSig(resultTx, txIn, i);
            }

            WalletService.checkWalletConsistency(wallet);
            WalletService.verifyTransaction(resultTx);

            WalletService.printTx(Res.getBaseCurrencyCode() + "" wallet: Signed tx"", resultTx);
            return resultTx;
        } catch (Throwable t) {
            log.error(""completeBsqTradingFeeTx: preparedBsqTx={}"", preparedBsqTx.toString());
            throw t;
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Deposit tx
    ///////////////////////////////////////////////////////////////////////////////////////////


    // We construct the deposit transaction in the way that the buyer is always the first entry (inputs, outputs, MS keys) and then the seller.
    // In the creation of the deposit tx the taker/maker roles are the determining roles instead of buyer/seller.
    // In the payout tx it is the buyer/seller role. We keep the buyer/seller ordering over all transactions to not get confusion with ordering,
    // which is important to follow correctly specially for the order of the MS keys.


    /**
     * The taker creates a dummy transaction to get the input(s) and optional change output for the amount and the
     * taker's address for that trade. That will be used to send to the maker for creating the deposit transaction.
     *
     * @param takeOfferFeeTx the take offer fee tx
     * @param inputAmount    amount of takers input
     * @param txFee          mining fee
     * @return a data container holding the inputs, the output value and address
     * @throws TransactionVerificationException if there was an unexpected problem with the created dummy tx
     */
    public InputsAndChangeOutput takerCreatesDepositTxInputs(Transaction takeOfferFeeTx,
                                                             Coin inputAmount,
                                                             Coin txFee)
            throws TransactionVerificationException {
        // We add the mining fee 2 times to the deposit tx:
        // 1. Will be spent when publishing the deposit tx (paid by buyer)
        // 2. Will be added to the MS amount, so when publishing the payout tx the fee is already there and the outputs are not changed by fee reduction
        // The fee for the payout will be paid by the seller.

        /*
         The tx we create has that structure:

         IN[0]  input from taker fee tx > inputAmount (including tx fee) (unsigned)
         OUT[0] dummyOutputAmount (inputAmount - tx fee)

         We are only interested in the inputs.
         We get the exact input value from the taker fee tx so we don't create a change output.
         */

        // inputAmount includes the tx fee. So we subtract the fee to get the dummyOutputAmount.
        Coin dummyOutputAmount = inputAmount.subtract(txFee);

        Transaction dummyTX = new Transaction(params);
        // The output is just used to get the right inputs and change outputs, so we use an anonymous ECKey, as it will never be used for anything.
        // We don't care about fee calculation differences between the real tx and that dummy tx as we use a static tx fee.
        TransactionOutput dummyOutput = new TransactionOutput(params, dummyTX, dummyOutputAmount, SegwitAddress.fromKey(params, new ECKey()));
        dummyTX.addOutput(dummyOutput);

        // Find the needed inputs to pay the output, optionally add 1 change output.
        // Normally only 1 input and no change output is used, but we support multiple inputs and 1 change output.
        // Our spending transaction output is from the create offer fee payment.

        // We created the take offer fee tx in the structure that the second output is for the funds for the deposit tx.
        TransactionOutput reservedForTradeOutput = takeOfferFeeTx.getOutputs().get(1);
        checkArgument(reservedForTradeOutput.getValue().equals(inputAmount),
                ""Reserve amount does not equal input amount"");
        dummyTX.addInput(reservedForTradeOutput);

        WalletService.verifyTransaction(dummyTX);

        //WalletService.printTx(""dummyTX"", dummyTX);

        List<RawTransactionInput> rawTransactionInputList = dummyTX.getInputs().stream().map(e -> {
            checkNotNull(e.getConnectedOutput(), ""e.getConnectedOutput() must not be null"");
            checkNotNull(e.getConnectedOutput().getParentTransaction(),
                    ""e.getConnectedOutput().getParentTransaction() must not be null"");
            checkNotNull(e.getValue(), ""e.getValue() must not be null"");
            return getRawInputFromTransactionInput(e);
        }).collect(Collectors.toList());


        // TODO changeOutputValue and changeOutputAddress is not used as taker spends exact amount from fee tx.
        // Change is handled already at the fee tx creation so the handling of a change output for the deposit tx
        // can be removed here. We still keep it atm as we prefer to not introduce a larger
        // refactoring. When new trade protocol gets implemented this can be cleaned.
        // The maker though can have a change output if the taker takes less as the max. offer amount!
        return new InputsAndChangeOutput(new ArrayList<>(rawTransactionInputList), 0, null);
    }

    public PreparedDepositTxAndMakerInputs sellerAsMakerCreatesDepositTx(Coin makerInputAmount,
                                                                         Coin msOutputAmount,
                                                                         List<RawTransactionInput> takerRawTransactionInputs,
                                                                         long takerChangeOutputValue,
                                                                         @Nullable String takerChangeAddressString,
                                                                         Address makerAddress,
                                                                         Address makerChangeAddress,
                                                                         byte[] buyerPubKey,
                                                                         byte[] sellerPubKey)
            throws SigningException, TransactionVerificationException, WalletException, AddressFormatException {
        return makerCreatesDepositTx(false,
                makerInputAmount,
                msOutputAmount,
                takerRawTransactionInputs,
                takerChangeOutputValue,
                takerChangeAddressString,
                makerAddress,
                makerChangeAddress,
                buyerPubKey,
                sellerPubKey);
    }

    public PreparedDepositTxAndMakerInputs buyerAsMakerCreatesAndSignsDepositTx(Coin makerInputAmount,
                                                                                Coin msOutputAmount,
                                                                                List<RawTransactionInput> takerRawTransactionInputs,
                                                                                long takerChangeOutputValue,
                                                                                @Nullable String takerChangeAddressString,
                                                                                Address makerAddress,
                                                                                Address makerChangeAddress,
                                                                                byte[] buyerPubKey,
                                                                                byte[] sellerPubKey)
            throws SigningException, TransactionVerificationException, WalletException, AddressFormatException {
        return makerCreatesDepositTx(true,
                makerInputAmount,
                msOutputAmount,
                takerRawTransactionInputs,
                takerChangeOutputValue,
                takerChangeAddressString,
                makerAddress,
                makerChangeAddress,
                buyerPubKey,
                sellerPubKey);
    }

    /**
     * The maker creates the deposit transaction using the takers input(s) and optional output and signs his input(s).
     *
     * @param makerIsBuyer              the flag indicating if we are in the maker as buyer role or the opposite
     * @param makerInputAmount          the input amount of the maker
     * @param msOutputAmount            the output amount to our MS output
     * @param takerRawTransactionInputs raw data for the connected outputs for all inputs of the taker (normally 1 input)
     * @param takerChangeOutputValue    optional taker change output value
     * @param takerChangeAddressString  optional taker change address
     * @param makerAddress              the maker's address
     * @param makerChangeAddress        the maker's change address
     * @param buyerPubKey               the public key of the buyer
     * @param sellerPubKey              the public key of the seller
     * @return a data container holding the serialized transaction and the maker raw inputs
     * @throws SigningException if there was an unexpected problem signing (one of) the input(s) from the maker's wallet
     * @throws AddressFormatException if the taker base58 change address doesn't parse or its checksum is invalid
     * @throws TransactionVerificationException if there was an unexpected problem with the deposit tx or its signature(s)
     * @throws WalletException if the maker's wallet is null or there was an error choosing deposit tx input(s) from it
     */
    private PreparedDepositTxAndMakerInputs makerCreatesDepositTx(boolean makerIsBuyer,
                                                                  Coin makerInputAmount,
                                                                  Coin msOutputAmount,
                                                                  List<RawTransactionInput> takerRawTransactionInputs,
                                                                  long takerChangeOutputValue,
                                                                  @Nullable String takerChangeAddressString,
                                                                  Address makerAddress,
                                                                  Address makerChangeAddress,
                                                                  byte[] buyerPubKey,
                                                                  byte[] sellerPubKey)
            throws SigningException, TransactionVerificationException, WalletException, AddressFormatException {
        checkArgument(!takerRawTransactionInputs.isEmpty());

        // First we construct a dummy TX to get the inputs and outputs we want to use for the real deposit tx.
        // Similar to the way we did in the createTakerDepositTxInputs method.
        Transaction dummyTx = new Transaction(params);
        TransactionOutput dummyOutput = new TransactionOutput(params, dummyTx, makerInputAmount, SegwitAddress.fromKey(params, new ECKey()));
        dummyTx.addOutput(dummyOutput);
        addAvailableInputsAndChangeOutputs(dummyTx, makerAddress, makerChangeAddress);
        // Normally we have only 1 input but we support multiple inputs if the user has paid in with several transactions.
        List<TransactionInput> makerInputs = dummyTx.getInputs();
        TransactionOutput makerOutput = null;

        // We don't support more than 1 optional change output
        checkArgument(dummyTx.getOutputs().size() < 3, ""dummyTx.getOutputs().size() >= 3"");

        // Only save change outputs, the dummy output is ignored (that's why we start with index 1)
        if (dummyTx.getOutputs().size() > 1) {
            makerOutput = dummyTx.getOutput(1);
        }

        // Now we construct the real deposit tx
        Transaction preparedDepositTx = new Transaction(params);

        ArrayList<RawTransactionInput> makerRawTransactionInputs = new ArrayList<>();
        if (makerIsBuyer) {
            // Add buyer inputs
            for (TransactionInput input : makerInputs) {
                preparedDepositTx.addInput(input);
                makerRawTransactionInputs.add(getRawInputFromTransactionInput(input));
            }

            // Add seller inputs
            // the seller's input is not signed so we attach empty script bytes
            for (RawTransactionInput rawTransactionInput : takerRawTransactionInputs)
                preparedDepositTx.addInput(getTransactionInput(preparedDepositTx, new byte[]{}, rawTransactionInput));
        } else {
            // taker is buyer role

            // Add buyer inputs
            // the seller's input is not signed so we attach empty script bytes
            for (RawTransactionInput rawTransactionInput : takerRawTransactionInputs)
                preparedDepositTx.addInput(getTransactionInput(preparedDepositTx, new byte[]{}, rawTransactionInput));

            // Add seller inputs
            for (TransactionInput input : makerInputs) {
                preparedDepositTx.addInput(input);
                makerRawTransactionInputs.add(getRawInputFromTransactionInput(input));
            }
        }


        // Add MultiSig output
        Script hashedMultiSigOutputScript = get2of2MultiSigOutputScript(buyerPubKey, sellerPubKey, false);

        // Tx fee for deposit tx will be paid by buyer.
        TransactionOutput hashedMultiSigOutput = new TransactionOutput(params, preparedDepositTx, msOutputAmount,
                hashedMultiSigOutputScript.getProgram());
        preparedDepositTx.addOutput(hashedMultiSigOutput);

        TransactionOutput takerTransactionOutput = null;
        if (takerChangeOutputValue > 0 && takerChangeAddressString != null) {
            takerTransactionOutput = new TransactionOutput(params, preparedDepositTx, Coin.valueOf(takerChangeOutputValue),
                    Address.fromString(params, takerChangeAddressString));
        }

        if (makerIsBuyer) {
            // Add optional buyer outputs
            if (makerOutput != null) {
                preparedDepositTx.addOutput(makerOutput);
            }

            // Add optional seller outputs
            if (takerTransactionOutput != null) {
                preparedDepositTx.addOutput(takerTransactionOutput);
            }
        } else {
            // taker is buyer role

            // Add optional seller outputs
            if (takerTransactionOutput != null) {
                preparedDepositTx.addOutput(takerTransactionOutput);
            }

            // Add optional buyer outputs
            if (makerOutput != null) {
                preparedDepositTx.addOutput(makerOutput);
            }
        }

        int start = makerIsBuyer ? 0 : takerRawTransactionInputs.size();
        int end = makerIsBuyer ? makerInputs.size() : preparedDepositTx.getInputs().size();
        for (int i = start; i < end; i++) {
            TransactionInput input = preparedDepositTx.getInput(i);
            signInput(preparedDepositTx, input, i);
            WalletService.checkScriptSig(preparedDepositTx, input, i);
        }

        WalletService.printTx(""makerCreatesDepositTx"", preparedDepositTx);
        WalletService.verifyTransaction(preparedDepositTx);

        return new PreparedDepositTxAndMakerInputs(makerRawTransactionInputs, preparedDepositTx.bitcoinSerialize());
    }

    /**
     * The taker signs the deposit transaction he received from the maker and publishes it.
     *
     * @param takerIsSeller             the flag indicating if we are in the taker as seller role or the opposite
     * @param makersDepositTxSerialized the prepared deposit transaction signed by the maker
     * @param msOutputAmount            the MultiSig output amount, as determined by the taker
     * @param buyerInputs               the connected outputs for all inputs of the buyer
     * @param sellerInputs              the connected outputs for all inputs of the seller
     * @param buyerPubKey               the public key of the buyer
     * @param sellerPubKey              the public key of the seller
     * @throws SigningException if (one of) the taker input(s) was of an unrecognized type for signing
     * @throws TransactionVerificationException if a non-P2WH maker-as-buyer input wasn't signed, the maker's MultiSig
     * script, contract hash or output amount doesn't match the taker's, or there was an unexpected problem with the
     * final deposit tx or its signatures
     * @throws WalletException if the taker's wallet is null or structurally inconsistent
     */
    public Transaction takerSignsDepositTx(boolean takerIsSeller,
                                           byte[] makersDepositTxSerialized,
                                           Coin msOutputAmount,
                                           List<RawTransactionInput> buyerInputs,
                                           List<RawTransactionInput> sellerInputs,
                                           byte[] buyerPubKey,
                                           byte[] sellerPubKey)
            throws SigningException, TransactionVerificationException, WalletException {
        Transaction makersDepositTx = new Transaction(params, makersDepositTxSerialized);

        checkArgument(!buyerInputs.isEmpty());
        checkArgument(!sellerInputs.isEmpty());

        // Check if maker's MultiSig script is identical to the taker's
        Script hashedMultiSigOutputScript = get2of2MultiSigOutputScript(buyerPubKey, sellerPubKey, false);
        if (!makersDepositTx.getOutput(0).getScriptPubKey().equals(hashedMultiSigOutputScript)) {
            throw new TransactionVerificationException(""Maker's hashedMultiSigOutputScript does not match taker's hashedMultiSigOutputScript"");
        }

        // Check if maker's MultiSig output value is identical to the taker's
        if (!makersDepositTx.getOutput(0).getValue().equals(msOutputAmount)) {
            throw new TransactionVerificationException(""Maker's MultiSig output amount does not match taker's MultiSig output amount"");
        }

        // The outpoints are not available from the serialized makersDepositTx, so we cannot use that tx directly, but we use it to construct a new
        // depositTx
        Transaction depositTx = new Transaction(params);

        if (takerIsSeller) {
            // Add buyer inputs and apply signature
            // We grab the signature from the makersDepositTx and apply it to the new tx input
            for (int i = 0; i < buyerInputs.size(); i++) {
                TransactionInput makersInput = makersDepositTx.getInputs().get(i);
                byte[] makersScriptSigProgram = makersInput.getScriptSig().getProgram();
                TransactionInput input = getTransactionInput(depositTx, makersScriptSigProgram, buyerInputs.get(i));
                Script scriptPubKey = checkNotNull(input.getConnectedOutput()).getScriptPubKey();
                if (makersScriptSigProgram.length == 0 && !ScriptPattern.isP2WH(scriptPubKey)) {
                    throw new TransactionVerificationException(""Non-segwit inputs from maker not signed."");
                }
                if (!TransactionWitness.EMPTY.equals(makersInput.getWitness())) {
                    input.setWitness(makersInput.getWitness());
                }
                depositTx.addInput(input);
            }

            // Add seller inputs
            for (RawTransactionInput rawTransactionInput : sellerInputs) {
                depositTx.addInput(getTransactionInput(depositTx, new byte[]{}, rawTransactionInput));
            }
        } else {
            // taker is buyer
            // Add buyer inputs and apply signature
            for (RawTransactionInput rawTransactionInput : buyerInputs) {
                depositTx.addInput(getTransactionInput(depositTx, new byte[]{}, rawTransactionInput));
            }

            // Add seller inputs
            // We grab the signature from the makersDepositTx and apply it to the new tx input
            for (int i = buyerInputs.size(), k = 0; i < makersDepositTx.getInputs().size(); i++, k++) {
                TransactionInput transactionInput = makersDepositTx.getInputs().get(i);
                // We get the deposit tx unsigned if maker is seller
                depositTx.addInput(getTransactionInput(depositTx, new byte[]{}, sellerInputs.get(k)));
            }
        }

        // Add all outputs from makersDepositTx to depositTx
        makersDepositTx.getOutputs().forEach(depositTx::addOutput);
        WalletService.printTx(""makersDepositTx"", makersDepositTx);

        // Sign inputs
        int start = takerIsSeller ? buyerInputs.size() : 0;
        int end = takerIsSeller ? depositTx.getInputs().size() : buyerInputs.size();
        for (int i = start; i < end; i++) {
            TransactionInput input = depositTx.getInput(i);
            signInput(depositTx, input, i);
            WalletService.checkScriptSig(depositTx, input, i);
        }

        WalletService.printTx(""takerSignsDepositTx"", depositTx);

        WalletService.verifyTransaction(depositTx);
        WalletService.checkWalletConsistency(wallet);

        return depositTx;
    }


    public void sellerAsMakerFinalizesDepositTx(Transaction myDepositTx,
                                                Transaction takersDepositTx,
                                                int numTakersInputs)
            throws TransactionVerificationException, AddressFormatException {

        // We add takers signature from his inputs and add it to out tx which was already signed earlier.
        for (int i = 0; i < numTakersInputs; i++) {
            TransactionInput takersInput = takersDepositTx.getInput(i);
            Script takersScriptSig = takersInput.getScriptSig();
            TransactionInput txInput = myDepositTx.getInput(i);
            txInput.setScriptSig(takersScriptSig);
            TransactionWitness witness = takersInput.getWitness();
            if (!TransactionWitness.EMPTY.equals(witness)) {
                txInput.setWitness(witness);
            }
        }

        WalletService.printTx(""sellerAsMakerFinalizesDepositTx"", myDepositTx);
        WalletService.verifyTransaction(myDepositTx);
    }


    public void sellerAddsBuyerWitnessesToDepositTx(Transaction myDepositTx,
                                                    Transaction buyersDepositTxWithWitnesses) {
        int numberInputs = myDepositTx.getInputs().size();
        for (int i = 0; i < numberInputs; i++) {
            var txInput = myDepositTx.getInput(i);
            var witnessFromBuyer = buyersDepositTxWithWitnesses.getInput(i).getWitness();

            if (TransactionWitness.EMPTY.equals(txInput.getWitness()) &&
                    !TransactionWitness.EMPTY.equals(witnessFromBuyer)) {
                txInput.setWitness(witnessFromBuyer);
            }
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Delayed payout tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction createDelayedUnsignedPayoutTx(Transaction depositTx,
                                                     String donationAddressString,
                                                     Coin minerFee,
                                                     long lockTime)
            throws AddressFormatException, TransactionVerificationException {
        TransactionOutput hashedMultiSigOutput = depositTx.getOutput(0);
        Transaction delayedPayoutTx = new Transaction(params);
        delayedPayoutTx.addInput(hashedMultiSigOutput);
        applyLockTime(lockTime, delayedPayoutTx);
        Coin outputAmount = hashedMultiSigOutput.getValue().subtract(minerFee);
        delayedPayoutTx.addOutput(outputAmount, Address.fromString(params, donationAddressString));
        WalletService.printTx(""Unsigned delayedPayoutTx ToDonationAddress"", delayedPayoutTx);
        WalletService.verifyTransaction(delayedPayoutTx);
        return delayedPayoutTx;
    }

    public byte[] signDelayedPayoutTx(Transaction delayedPayoutTx,
                                      Transaction preparedDepositTx,
                                      DeterministicKey myMultiSigKeyPair,
                                      byte[] buyerPubKey,
                                      byte[] sellerPubKey)
            throws AddressFormatException, TransactionVerificationException {

        Script redeemScript = get2of2MultiSigRedeemScript(buyerPubKey, sellerPubKey);
        Sha256Hash sigHash;
        Coin delayedPayoutTxInputValue = preparedDepositTx.getOutput(0).getValue();
        sigHash = delayedPayoutTx.hashForWitnessSignature(0, redeemScript,
                delayedPayoutTxInputValue, Transaction.SigHash.ALL, false);
        checkNotNull(myMultiSigKeyPair, ""myMultiSigKeyPair must not be null"");
        if (myMultiSigKeyPair.isEncrypted()) {
            checkNotNull(aesKey);
        }

        ECKey.ECDSASignature mySignature = myMultiSigKeyPair.sign(sigHash, aesKey).toCanonicalised();
        WalletService.printTx(""delayedPayoutTx for sig creation"", delayedPayoutTx);
        WalletService.verifyTransaction(delayedPayoutTx);
        return mySignature.encodeToDER();
    }

    public Transaction finalizeUnconnectedDelayedPayoutTx(Transaction delayedPayoutTx,
                                                          byte[] buyerPubKey,
                                                          byte[] sellerPubKey,
                                                          byte[] buyerSignature,
                                                          byte[] sellerSignature,
                                                          Coin inputValue)
            throws AddressFormatException, TransactionVerificationException, SignatureDecodeException {

        Script redeemScript = get2of2MultiSigRedeemScript(buyerPubKey, sellerPubKey);
        ECKey.ECDSASignature buyerECDSASignature = ECKey.ECDSASignature.decodeFromDER(buyerSignature);
        ECKey.ECDSASignature sellerECDSASignature = ECKey.ECDSASignature.decodeFromDER(sellerSignature);
        TransactionSignature buyerTxSig = new TransactionSignature(buyerECDSASignature, Transaction.SigHash.ALL, false);
        TransactionSignature sellerTxSig = new TransactionSignature(sellerECDSASignature, Transaction.SigHash.ALL, false);
        TransactionInput input = delayedPayoutTx.getInput(0);
        input.setScriptSig(ScriptBuilder.createEmpty());
        TransactionWitness witness = TransactionWitness.redeemP2WSH(redeemScript, sellerTxSig, buyerTxSig);
        input.setWitness(witness);
        WalletService.printTx(""finalizeDelayedPayoutTx"", delayedPayoutTx);
        WalletService.verifyTransaction(delayedPayoutTx);

        if (checkNotNull(inputValue).isLessThan(delayedPayoutTx.getOutputSum().add(MIN_DELAYED_PAYOUT_TX_FEE))) {
            throw new TransactionVerificationException(""Delayed payout tx is paying less than the minimum allowed tx fee"");
        }
        Script scriptPubKey = get2of2MultiSigOutputScript(buyerPubKey, sellerPubKey, false);
        input.getScriptSig().correctlySpends(delayedPayoutTx, 0, witness, inputValue, scriptPubKey, Script.ALL_VERIFY_FLAGS);
        return delayedPayoutTx;
    }

    public Transaction finalizeDelayedPayoutTx(Transaction delayedPayoutTx,
                                               byte[] buyerPubKey,
                                               byte[] sellerPubKey,
                                               byte[] buyerSignature,
                                               byte[] sellerSignature)
            throws AddressFormatException, TransactionVerificationException, WalletException, SignatureDecodeException {

        TransactionInput input = delayedPayoutTx.getInput(0);
        finalizeUnconnectedDelayedPayoutTx(delayedPayoutTx, buyerPubKey, sellerPubKey, buyerSignature, sellerSignature, input.getValue());

        WalletService.checkWalletConsistency(wallet);
        checkNotNull(input.getConnectedOutput(), ""input.getConnectedOutput() must not be null"");
        input.verify(input.getConnectedOutput());
        return delayedPayoutTx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Standard payout tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Seller signs payout transaction, buyer has not signed yet.
     *
     * @param depositTx                 deposit transaction
     * @param buyerPayoutAmount         payout amount for buyer
     * @param sellerPayoutAmount        payout amount for seller
     * @param buyerPayoutAddressString  address for buyer
     * @param sellerPayoutAddressString address for seller
     * @param multiSigKeyPair           DeterministicKey for MultiSig from seller
     * @param buyerPubKey               the public key of the buyer
     * @param sellerPubKey              the public key of the seller
     * @return DER encoded canonical signature
     * @throws AddressFormatException if the buyer or seller base58 address doesn't parse or its checksum is invalid
     * @throws TransactionVerificationException if there was an unexpected problem with the payout tx or its signature
     */
    public byte[] buyerSignsPayoutTx(Transaction depositTx,
                                     Coin buyerPayoutAmount,
                                     Coin sellerPayoutAmount,
                                     String buyerPayoutAddressString,
                                     String sellerPayoutAddressString,
                                     DeterministicKey multiSigKeyPair,
                                     byte[] buyerPubKey,
                                     byte[] sellerPubKey)
            throws AddressFormatException, TransactionVerificationException {
        Transaction preparedPayoutTx = createPayoutTx(depositTx, buyerPayoutAmount, sellerPayoutAmount,
                buyerPayoutAddressString, sellerPayoutAddressString);
        // MS redeemScript
        Script redeemScript = get2of2MultiSigRedeemScript(buyerPubKey, sellerPubKey);
        // MS output from prev. tx is index 0
        Sha256Hash sigHash;
        TransactionOutput hashedMultiSigOutput = depositTx.getOutput(0);
        if (ScriptPattern.isP2SH(hashedMultiSigOutput.getScriptPubKey())) {
            sigHash = preparedPayoutTx.hashForSignature(0, redeemScript, Transaction.SigHash.ALL, false);
        } else {
            Coin inputValue = hashedMultiSigOutput.getValue();
            sigHash = preparedPayoutTx.hashForWitnessSignature(0, redeemScript,
                    inputValue, Transaction.SigHash.ALL, false);
        }
        checkNotNull(multiSigKeyPair, ""multiSigKeyPair must not be null"");
        if (multiSigKeyPair.isEncrypted()) {
            checkNotNull(aesKey);
        }
        ECKey.ECDSASignature buyerSignature = multiSigKeyPair.sign(sigHash, aesKey).toCanonicalised();
        WalletService.printTx(""prepared payoutTx"", preparedPayoutTx);
        WalletService.verifyTransaction(preparedPayoutTx);
        return buyerSignature.encodeToDER();
    }


    /**
     * Seller creates and signs payout transaction and adds signature of buyer to complete the transaction.
     *
     * @param depositTx                 deposit transaction
     * @param buyerSignature            DER encoded canonical signature of buyer
     * @param buyerPayoutAmount         payout amount for buyer
     * @param sellerPayoutAmount        payout amount for seller
     * @param buyerPayoutAddressString  address for buyer
     * @param sellerPayoutAddressString address for seller
     * @param multiSigKeyPair           seller's key pair for MultiSig
     * @param buyerPubKey               the public key of the buyer
     * @param sellerPubKey              the public key of the seller
     * @return the payout transaction
     * @throws AddressFormatException if the buyer or seller base58 address doesn't parse or its checksum is invalid
     * @throws TransactionVerificationException if there was an unexpected problem with the payout tx or its signatures
     * @throws WalletException if the seller's wallet is null or structurally inconsistent
     */
    public Transaction sellerSignsAndFinalizesPayoutTx(Transaction depositTx,
                                                       byte[] buyerSignature,
                                                       Coin buyerPayoutAmount,
                                                       Coin sellerPayoutAmount,
                                                       String buyerPayoutAddressString,
                                                       String sellerPayoutAddressString,
                                                       DeterministicKey multiSigKeyPair,
                                                       byte[] buyerPubKey,
                                                       byte[] sellerPubKey)
            throws AddressFormatException, TransactionVerificationException, WalletException, SignatureDecodeException {
        Transaction payoutTx = createPayoutTx(depositTx, buyerPayoutAmount, sellerPayoutAmount, buyerPayoutAddressString, sellerPayoutAddressString);
        // MS redeemScript
        Script redeemScript = get2of2MultiSigRedeemScript(buyerPubKey, sellerPubKey);
        // MS output from prev. tx is index 0
        TransactionOutput hashedMultiSigOutput = depositTx.getOutput(0);
        boolean hashedMultiSigOutputIsLegacy = ScriptPattern.isP2SH(hashedMultiSigOutput.getScriptPubKey());
        Sha256Hash sigHash;
        if (hashedMultiSigOutputIsLegacy) {
            sigHash = payoutTx.hashForSignature(0, redeemScript, Transaction.SigHash.ALL, false);
        } else {
            Coin inputValue = hashedMultiSigOutput.getValue();
            sigHash = payoutTx.hashForWitnessSignature(0, redeemScript,
                    inputValue, Transaction.SigHash.ALL, false);
        }
        checkNotNull(multiSigKeyPair, ""multiSigKeyPair must not be null"");
        if (multiSigKeyPair.isEncrypted()) {
            checkNotNull(aesKey);
        }
        ECKey.ECDSASignature sellerSignature = multiSigKeyPair.sign(sigHash, aesKey).toCanonicalised();
        TransactionSignature buyerTxSig = new TransactionSignature(ECKey.ECDSASignature.decodeFromDER(buyerSignature),
                Transaction.SigHash.ALL, false);
        TransactionSignature sellerTxSig = new TransactionSignature(sellerSignature, Transaction.SigHash.ALL, false);
        // Take care of order of signatures. Need to be reversed here. See comment below at getMultiSigRedeemScript (seller, buyer)
        TransactionInput input = payoutTx.getInput(0);
        if (hashedMultiSigOutputIsLegacy) {
            Script inputScript = ScriptBuilder.createP2SHMultiSigInputScript(ImmutableList.of(sellerTxSig, buyerTxSig),
                    redeemScript);
            input.setScriptSig(inputScript);
        } else {
            input.setScriptSig(ScriptBuilder.createEmpty());
            input.setWitness(TransactionWitness.redeemP2WSH(redeemScript, sellerTxSig, buyerTxSig));
        }
        WalletService.printTx(""payoutTx"", payoutTx);
        WalletService.verifyTransaction(payoutTx);
        WalletService.checkWalletConsistency(wallet);
        WalletService.checkScriptSig(payoutTx, input, 0);
        checkNotNull(input.getConnectedOutput(), ""input.getConnectedOutput() must not be null"");
        input.verify(input.getConnectedOutput());
        return payoutTx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Mediated payoutTx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public byte[] signMediatedPayoutTx(Transaction depositTx,
                                       Coin buyerPayoutAmount,
                                       Coin sellerPayoutAmount,
                                       String buyerPayoutAddressString,
                                       String sellerPayoutAddressString,
                                       DeterministicKey myMultiSigKeyPair,
                                       byte[] buyerPubKey,
                                       byte[] sellerPubKey)
            throws AddressFormatException, TransactionVerificationException {
        Transaction preparedPayoutTx = createPayoutTx(depositTx, buyerPayoutAmount, sellerPayoutAmount, buyerPayoutAddressString, sellerPayoutAddressString);
        // MS redeemScript
        Script redeemScript = get2of2MultiSigRedeemScript(buyerPubKey, sellerPubKey);
        // MS output from prev. tx is index 0
        TransactionOutput hashedMultiSigOutput = depositTx.getOutput(0);
        boolean hashedMultiSigOutputIsLegacy = ScriptPattern.isP2SH(hashedMultiSigOutput.getScriptPubKey());
        Sha256Hash sigHash;
        if (hashedMultiSigOutputIsLegacy) {
            sigHash = preparedPayoutTx.hashForSignature(0, redeemScript, Transaction.SigHash.ALL, false);
        } else {
            Coin inputValue = hashedMultiSigOutput.getValue();
            sigHash = preparedPayoutTx.hashForWitnessSignature(0, redeemScript,
                    inputValue, Transaction.SigHash.ALL, false);
        }
        checkNotNull(myMultiSigKeyPair, ""myMultiSigKeyPair must not be null"");
        if (myMultiSigKeyPair.isEncrypted()) {
            checkNotNull(aesKey);
        }
        ECKey.ECDSASignature mySignature = myMultiSigKeyPair.sign(sigHash, aesKey).toCanonicalised();
        WalletService.printTx(""prepared mediated payoutTx for sig creation"", preparedPayoutTx);
        WalletService.verifyTransaction(preparedPayoutTx);
        return mySignature.encodeToDER();
    }

    public Transaction finalizeMediatedPayoutTx(Transaction depositTx,
                                                byte[] buyerSignature,
                                                byte[] sellerSignature,
                                                Coin buyerPayoutAmount,
                                                Coin sellerPayoutAmount,
                                                String buyerPayoutAddressString,
                                                String sellerPayoutAddressString,
                                                DeterministicKey multiSigKeyPair,
                                                byte[] buyerPubKey,
                                                byte[] sellerPubKey)
            throws AddressFormatException, TransactionVerificationException, WalletException, SignatureDecodeException {
        Transaction payoutTx = createPayoutTx(depositTx, buyerPayoutAmount, sellerPayoutAmount, buyerPayoutAddressString, sellerPayoutAddressString);
        // MS redeemScript
        Script redeemScript = get2of2MultiSigRedeemScript(buyerPubKey, sellerPubKey);
        // MS output from prev. tx is index 0
        checkNotNull(multiSigKeyPair, ""multiSigKeyPair must not be null"");
        TransactionSignature buyerTxSig = new TransactionSignature(ECKey.ECDSASignature.decodeFromDER(buyerSignature),
                Transaction.SigHash.ALL, false);
        TransactionSignature sellerTxSig = new TransactionSignature(ECKey.ECDSASignature.decodeFromDER(sellerSignature),
                Transaction.SigHash.ALL, false);
        // Take care of order of signatures. Need to be reversed here. See comment below at getMultiSigRedeemScript (seller, buyer)
        TransactionOutput hashedMultiSigOutput = depositTx.getOutput(0);
        boolean hashedMultiSigOutputIsLegacy = ScriptPattern.isP2SH(hashedMultiSigOutput.getScriptPubKey());
        TransactionInput input = payoutTx.getInput(0);
        if (hashedMultiSigOutputIsLegacy) {
            Script inputScript = ScriptBuilder.createP2SHMultiSigInputScript(ImmutableList.of(sellerTxSig, buyerTxSig),
                    redeemScript);
            input.setScriptSig(inputScript);
        } else {
            input.setScriptSig(ScriptBuilder.createEmpty());
            input.setWitness(TransactionWitness.redeemP2WSH(redeemScript, sellerTxSig, buyerTxSig));
        }
        WalletService.printTx(""mediated payoutTx"", payoutTx);
        WalletService.verifyTransaction(payoutTx);
        WalletService.checkWalletConsistency(wallet);
        WalletService.checkScriptSig(payoutTx, input, 0);
        checkNotNull(input.getConnectedOutput(), ""input.getConnectedOutput() must not be null"");
        input.verify(input.getConnectedOutput());
        return payoutTx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Arbitrated payoutTx
    ///////////////////////////////////////////////////////////////////////////////////////////

    // TODO: Once we have removed legacy arbitrator from dispute domain we can remove that method as well.
    // Atm it is still used by ArbitrationManager.

    /**
     * A trader who got the signed tx from the arbitrator finalizes the payout tx.
     *
     * @param depositTxSerialized    serialized deposit tx
     * @param arbitratorSignature    DER encoded canonical signature of arbitrator
     * @param buyerPayoutAmount      payout amount of the buyer
     * @param sellerPayoutAmount     payout amount of the seller
     * @param buyerAddressString     the address of the buyer
     * @param sellerAddressString    the address of the seller
     * @param tradersMultiSigKeyPair the key pair for the MultiSig of the trader who calls that method
     * @param buyerPubKey            the public key of the buyer
     * @param sellerPubKey           the public key of the seller
     * @param arbitratorPubKey       the public key of the arbitrator
     * @return the completed payout tx
     * @throws AddressFormatException if the buyer or seller base58 address doesn't parse or its checksum is invalid
     * @throws TransactionVerificationException if there was an unexpected problem with the payout tx or its signature
     * @throws WalletException if the trade wallet is null or structurally inconsistent
     */
    public Transaction traderSignAndFinalizeDisputedPayoutTx(byte[] depositTxSerialized,
                                                             byte[] arbitratorSignature,
                                                             Coin buyerPayoutAmount,
                                                             Coin sellerPayoutAmount,
                                                             String buyerAddressString,
                                                             String sellerAddressString,
                                                             DeterministicKey tradersMultiSigKeyPair,
                                                             byte[] buyerPubKey,
                                                             byte[] sellerPubKey,
                                                             byte[] arbitratorPubKey)
            throws AddressFormatException, TransactionVerificationException, WalletException, SignatureDecodeException {
        Transaction depositTx = new Transaction(params, depositTxSerialized);
        TransactionOutput hashedMultiSigOutput = depositTx.getOutput(0);
        Transaction payoutTx = new Transaction(params);
        payoutTx.addInput(hashedMultiSigOutput);
        if (buyerPayoutAmount.isPositive()) {
            payoutTx.addOutput(buyerPayoutAmount, Address.fromString(params, buyerAddressString));
        }
        if (sellerPayoutAmount.isPositive()) {
            payoutTx.addOutput(sellerPayoutAmount, Address.fromString(params, sellerAddressString));
        }

        // take care of sorting!
        Script redeemScript = get2of3MultiSigRedeemScript(buyerPubKey, sellerPubKey, arbitratorPubKey);
        Sha256Hash sigHash;
        boolean hashedMultiSigOutputIsLegacy = !ScriptPattern.isP2SH(hashedMultiSigOutput.getScriptPubKey());
        if (hashedMultiSigOutputIsLegacy) {
            sigHash = payoutTx.hashForSignature(0, redeemScript, Transaction.SigHash.ALL, false);
        } else {
            Coin inputValue = hashedMultiSigOutput.getValue();
            sigHash = payoutTx.hashForWitnessSignature(0, redeemScript,
                    inputValue, Transaction.SigHash.ALL, false);
        }
        checkNotNull(tradersMultiSigKeyPair, ""tradersMultiSigKeyPair must not be null"");
        if (tradersMultiSigKeyPair.isEncrypted()) {
            checkNotNull(aesKey);
        }
        ECKey.ECDSASignature tradersSignature = tradersMultiSigKeyPair.sign(sigHash, aesKey).toCanonicalised();
        TransactionSignature tradersTxSig = new TransactionSignature(tradersSignature, Transaction.SigHash.ALL, false);
        TransactionSignature arbitratorTxSig = new TransactionSignature(ECKey.ECDSASignature.decodeFromDER(arbitratorSignature),
                Transaction.SigHash.ALL, false);
        TransactionInput input = payoutTx.getInput(0);
        // Take care of order of signatures. See comment below at getMultiSigRedeemScript (sort order needed here: arbitrator, seller, buyer)
        if (hashedMultiSigOutputIsLegacy) {
            Script inputScript = ScriptBuilder.createP2SHMultiSigInputScript(
                    ImmutableList.of(arbitratorTxSig, tradersTxSig),
                    redeemScript);
            input.setScriptSig(inputScript);
        } else {
            input.setScriptSig(ScriptBuilder.createEmpty());
            input.setWitness(TransactionWitness.redeemP2WSH(redeemScript, arbitratorTxSig, tradersTxSig));
        }
        WalletService.printTx(""disputed payoutTx"", payoutTx);
        WalletService.verifyTransaction(payoutTx);
        WalletService.checkWalletConsistency(wallet);
        WalletService.checkScriptSig(payoutTx, input, 0);
        checkNotNull(input.getConnectedOutput(), ""input.getConnectedOutput() must not be null"");
        input.verify(input.getConnectedOutput());
        return payoutTx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Emergency payoutTx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Tuple2<String, String> emergencyBuildPayoutTxFrom2of2MultiSig(String depositTxHex,
                                                                         Coin buyerPayoutAmount,
                                                                         Coin sellerPayoutAmount,
                                                                         Coin txFee,
                                                                         String buyerAddressString,
                                                                         String sellerAddressString,
                                                                         String buyerPubKeyAsHex,
                                                                         String sellerPubKeyAsHex,
                                                                         boolean hashedMultiSigOutputIsLegacy) {
        byte[] buyerPubKey = ECKey.fromPublicOnly(Utils.HEX.decode(buyerPubKeyAsHex)).getPubKey();
        byte[] sellerPubKey = ECKey.fromPublicOnly(Utils.HEX.decode(sellerPubKeyAsHex)).getPubKey();
        Script redeemScript = get2of2MultiSigRedeemScript(buyerPubKey, sellerPubKey);
        Coin msOutputValue = buyerPayoutAmount.add(sellerPayoutAmount).add(txFee);
        Transaction payoutTx = new Transaction(params);
        Sha256Hash spendTxHash = Sha256Hash.wrap(depositTxHex);
        payoutTx.addInput(new TransactionInput(params, payoutTx, new byte[]{}, new TransactionOutPoint(params, 0, spendTxHash), msOutputValue));

        if (buyerPayoutAmount.isPositive()) {
            payoutTx.addOutput(buyerPayoutAmount, Address.fromString(params, buyerAddressString));
        }
        if (sellerPayoutAmount.isPositive()) {
            payoutTx.addOutput(sellerPayoutAmount, Address.fromString(params, sellerAddressString));
        }

        String redeemScriptHex = Utils.HEX.encode(redeemScript.getProgram());
        String unsignedTxHex = Utils.HEX.encode(payoutTx.bitcoinSerialize(!hashedMultiSigOutputIsLegacy));
        return new Tuple2<>(redeemScriptHex, unsignedTxHex);
    }

    public String emergencyGenerateSignature(String rawTxHex,
                                             String redeemScriptHex,
                                             Coin inputValue,
                                             String myPrivKeyAsHex)
            throws IllegalArgumentException {
        boolean hashedMultiSigOutputIsLegacy = true;
        if (rawTxHex.startsWith(""010000000001""))
            hashedMultiSigOutputIsLegacy = false;
        byte[] payload = Utils.HEX.decode(rawTxHex);
        Transaction payoutTx = new Transaction(params, payload, null, params.getDefaultSerializer(), payload.length);
        Script redeemScript = new Script(Utils.HEX.decode(redeemScriptHex));
        Sha256Hash sigHash;
        if (hashedMultiSigOutputIsLegacy) {
            sigHash = payoutTx.hashForSignature(0, redeemScript, Transaction.SigHash.ALL, false);
        } else {
            sigHash = payoutTx.hashForWitnessSignature(0, redeemScript,
                    inputValue, Transaction.SigHash.ALL, false);
        }

        ECKey myPrivateKey = ECKey.fromPrivate(Utils.HEX.decode(myPrivKeyAsHex));
        checkNotNull(myPrivateKey, ""key must not be null"");
        ECKey.ECDSASignature myECDSASignature = myPrivateKey.sign(sigHash, aesKey).toCanonicalised();
        TransactionSignature myTxSig = new TransactionSignature(myECDSASignature, Transaction.SigHash.ALL, false);
        return Utils.HEX.encode(myTxSig.encodeToBitcoin());
    }

    public Tuple2<String, String> emergencyApplySignatureToPayoutTxFrom2of2MultiSig(String unsignedTxHex,
                                                                                    String redeemScriptHex,
                                                                                    String buyerSignatureAsHex,
                                                                                    String sellerSignatureAsHex,
                                                                                    boolean hashedMultiSigOutputIsLegacy)
            throws AddressFormatException, SignatureDecodeException {
        Transaction payoutTx = new Transaction(params, Utils.HEX.decode(unsignedTxHex));
        TransactionSignature buyerTxSig = TransactionSignature.decodeFromBitcoin(Utils.HEX.decode(buyerSignatureAsHex), true, true);
        TransactionSignature sellerTxSig = TransactionSignature.decodeFromBitcoin(Utils.HEX.decode(sellerSignatureAsHex), true, true);
        Script redeemScript = new Script(Utils.HEX.decode(redeemScriptHex));

        TransactionInput input = payoutTx.getInput(0);
        if (hashedMultiSigOutputIsLegacy) {
            Script inputScript = ScriptBuilder.createP2SHMultiSigInputScript(ImmutableList.of(sellerTxSig, buyerTxSig),
                    redeemScript);
            input.setScriptSig(inputScript);
        } else {
            input.setScriptSig(ScriptBuilder.createEmpty());
            input.setWitness(TransactionWitness.redeemP2WSH(redeemScript, sellerTxSig, buyerTxSig));
        }
        String txId = payoutTx.getTxId().toString();
        String signedTxHex = Utils.HEX.encode(payoutTx.bitcoinSerialize(!hashedMultiSigOutputIsLegacy));
        return new Tuple2<>(txId, signedTxHex);
    }

    public void emergencyPublishPayoutTxFrom2of2MultiSig(String signedTxHex, TxBroadcaster.Callback callback)
            throws AddressFormatException, TransactionVerificationException, WalletException {
        Transaction payoutTx = new Transaction(params, Utils.HEX.decode(signedTxHex));
        WalletService.printTx(""payoutTx"", payoutTx);
        WalletService.verifyTransaction(payoutTx);
        WalletService.checkWalletConsistency(wallet);
        broadcastTx(payoutTx, callback, 20);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // BsqSwap tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction sellerBuildBsqSwapTx(List<RawTransactionInput> buyersBsqInputs,
                                            List<RawTransactionInput> sellersBtcInputs,
                                            Coin sellersBsqPayoutAmount,
                                            String sellersBsqPayoutAddress,
                                            @Nullable Coin buyersBsqChangeAmount,
                                            @Nullable String buyersBsqChangeAddress,
                                            Coin buyersBtcPayoutAmount,
                                            String buyersBtcPayoutAddress,
                                            @Nullable Coin sellersBtcChangeAmount,
                                            @Nullable String sellersBtcChangeAddress) throws AddressFormatException {

        Transaction transaction = new Transaction(params);
        List<TransactionInput> sellersBtcTransactionInput = sellersBtcInputs.stream()
                .map(rawInput -> getTransactionInput(transaction, new byte[]{}, rawInput))
                .collect(Collectors.toList());
        return buildBsqSwapTx(buyersBsqInputs,
                sellersBtcTransactionInput,
                sellersBsqPayoutAmount,
                sellersBsqPayoutAddress,
                buyersBsqChangeAmount,
                buyersBsqChangeAddress,
                buyersBtcPayoutAmount,
                buyersBtcPayoutAddress,
                sellersBtcChangeAmount,
                sellersBtcChangeAddress,
                transaction);
    }

    public Transaction buyerBuildBsqSwapTx(List<RawTransactionInput> buyersBsqInputs,
                                           List<TransactionInput> sellersBtcInputs,
                                           Coin sellersBsqPayoutAmount,
                                           String sellersBsqPayoutAddress,
                                           @Nullable Coin buyersBsqChangeAmount,
                                           @Nullable String buyersBsqChangeAddress,
                                           Coin buyersBtcPayoutAmount,
                                           String buyersBtcPayoutAddress,
                                           @Nullable Coin sellersBtcChangeAmount,
                                           @Nullable String sellersBtcChangeAddress) throws AddressFormatException {
        Transaction transaction = new Transaction(params);
        return buildBsqSwapTx(buyersBsqInputs,
                sellersBtcInputs,
                sellersBsqPayoutAmount,
                sellersBsqPayoutAddress,
                buyersBsqChangeAmount,
                buyersBsqChangeAddress,
                buyersBtcPayoutAmount,
                buyersBtcPayoutAddress,
                sellersBtcChangeAmount,
                sellersBtcChangeAddress,
                transaction);
    }

    private Transaction buildBsqSwapTx(List<RawTransactionInput> buyersBsqInputs,
                                       List<TransactionInput> sellersBtcInputs,
                                       Coin sellersBsqPayoutAmount,
                                       String sellersBsqPayoutAddress,
                                       @Nullable Coin buyersBsqChangeAmount,
                                       @Nullable String buyersBsqChangeAddress,
                                       Coin buyersBtcPayoutAmount,
                                       String buyersBtcPayoutAddress,
                                       @Nullable Coin sellersBtcChangeAmount,
                                       @Nullable String sellersBtcChangeAddress,
                                       Transaction transaction) throws AddressFormatException {

        buyersBsqInputs.forEach(rawInput -> transaction.addInput(getTransactionInput(transaction, new byte[]{}, rawInput)));
        sellersBtcInputs.forEach(transaction::addInput);

        transaction.addOutput(sellersBsqPayoutAmount, Address.fromString(params, sellersBsqPayoutAddress));

        if (buyersBsqChangeAmount != null && buyersBsqChangeAmount.isPositive())
            transaction.addOutput(buyersBsqChangeAmount, Address.fromString(params, Objects.requireNonNull(buyersBsqChangeAddress)));

        transaction.addOutput(buyersBtcPayoutAmount, Address.fromString(params, buyersBtcPayoutAddress));

        if (sellersBtcChangeAmount != null && sellersBtcChangeAmount.isPositive())
            transaction.addOutput(sellersBtcChangeAmount, Address.fromString(params, Objects.requireNonNull(sellersBtcChangeAddress)));

        return transaction;
    }

    public void signBsqSwapTransaction(Transaction transaction, List<TransactionInput> myInputs)
            throws SigningException {
        for (TransactionInput input : myInputs) {
            signInput(transaction, input, input.getIndex());
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Broadcast tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void broadcastTx(Transaction tx, TxBroadcaster.Callback callback) {
        checkNotNull(walletConfig);
        TxBroadcaster.broadcastTx(wallet, walletConfig.peerGroup(), tx, callback);
    }

    public void broadcastTx(Transaction tx, TxBroadcaster.Callback callback, int timeoutInSec) {
        checkNotNull(walletConfig);
        TxBroadcaster.broadcastTx(wallet, walletConfig.peerGroup(), tx, callback, timeoutInSec);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Misc
    ///////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Returns the local existing wallet transaction with the given ID, or {@code null} if missing.
     *
     * @param txId the transaction ID of the transaction we want to lookup
     */
    public Transaction getWalletTx(Sha256Hash txId) {
        checkNotNull(wallet);
        return wallet.getTransaction(txId);
    }

    public void commitTx(Transaction tx) {
        checkNotNull(wallet);
        wallet.commitTx(tx);
    }

    public Transaction getClonedTransaction(Transaction tx) {
        return new Transaction(params, tx.bitcoinSerialize());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    // This method might be replace by RawTransactionInput constructor taking the TransactionInput as param.
    // As we used segwit=false for the bitcoinSerialize method here we still keep it to not risk to break anything,
    // though it very likely should be fine to replace it with the RawTransactionInput constructor call.
    @Deprecated
    private RawTransactionInput getRawInputFromTransactionInput(TransactionInput input) {
        checkNotNull(input, ""input must not be null"");
        checkNotNull(input.getConnectedOutput(), ""input.getConnectedOutput() must not be null"");
        checkNotNull(input.getConnectedOutput().getParentTransaction(),
                ""input.getConnectedOutput().getParentTransaction() must not be null"");
        checkNotNull(input.getValue(), ""input.getValue() must not be null"");

        // bitcoinSerialize(false) is used just in case the serialized tx is parsed by a bisq node still using
        // bitcoinj 0.14. This is not supposed to happen ever since Version.TRADE_PROTOCOL_VERSION was set to 3,
        // but it costs nothing to be on the safe side.
        // The serialized tx is just used to obtain its hash, so the witness data is not relevant.
        return new RawTransactionInput(input.getOutpoint().getIndex(),
                input.getConnectedOutput().getParentTransaction().bitcoinSerialize(false),
                input.getValue().value);
    }

    private TransactionInput getTransactionInput(Transaction parentTransaction,
                                                 byte[] scriptProgram,
                                                 RawTransactionInput rawTransactionInput) {
        return new TransactionInput(params,
                parentTransaction,
                scriptProgram,
                getConnectedOutPoint(rawTransactionInput),
                Coin.valueOf(rawTransactionInput.value));
    }

    private TransactionOutPoint getConnectedOutPoint(RawTransactionInput rawTransactionInput) {
        return new TransactionOutPoint(params, rawTransactionInput.index,
                new Transaction(params, rawTransactionInput.parentTransaction));
    }

    public boolean isP2WH(RawTransactionInput rawTransactionInput) {
        return ScriptPattern.isP2WH(
                checkNotNull(getConnectedOutPoint(rawTransactionInput).getConnectedOutput()).getScriptPubKey());
    }

    // TODO: Once we have removed legacy arbitrator from dispute domain we can remove that method as well.
    // Atm it is still used by traderSignAndFinalizeDisputedPayoutTx which is used by ArbitrationManager.

    // Don't use ScriptBuilder.createRedeemScript and ScriptBuilder.createP2SHOutputScript as they use a sorting
    // (Collections.sort(pubKeys, ECKey.PUBKEY_COMPARATOR);) which can lead to a non-matching list of signatures with pubKeys and the executeMultiSig does
    // not iterate all possible combinations of sig/pubKeys leading to a verification fault. That nasty bug happens just randomly as the list after sorting
    // might differ from the provided one or not.
    // Changing the while loop in executeMultiSig to fix that does not help as the reference implementation seems to behave the same (not iterating all
    // possibilities) .
    // Furthermore the executed list is reversed to the provided.
    // Best practice is to provide the list sorted by the least probable successful candidates first (arbitrator is first -> will be last in execution loop, so
    // avoiding unneeded expensive ECKey.verify calls)
    private Script get2of3MultiSigRedeemScript(byte[] buyerPubKey, byte[] sellerPubKey, byte[] arbitratorPubKey) {
        ECKey buyerKey = ECKey.fromPublicOnly(buyerPubKey);
        ECKey sellerKey = ECKey.fromPublicOnly(sellerPubKey);
        ECKey arbitratorKey = ECKey.fromPublicOnly(arbitratorPubKey);
        // Take care of sorting! Need to reverse to the order we use normally (buyer, seller, arbitrator)
        List<ECKey> keys = ImmutableList.of(arbitratorKey, sellerKey, buyerKey);
        return ScriptBuilder.createMultiSigOutputScript(2, keys);
    }

    private Script get2of2MultiSigRedeemScript(byte[] buyerPubKey, byte[] sellerPubKey) {
        ECKey buyerKey = ECKey.fromPublicOnly(buyerPubKey);
        ECKey sellerKey = ECKey.fromPublicOnly(sellerPubKey);
        // Take care of sorting! Need to reverse to the order we use normally (buyer, seller)
        List<ECKey> keys = ImmutableList.of(sellerKey, buyerKey);
        return ScriptBuilder.createMultiSigOutputScript(2, keys);
    }

    private Script get2of2MultiSigOutputScript(byte[] buyerPubKey, byte[] sellerPubKey, boolean legacy) {
        Script redeemScript = get2of2MultiSigRedeemScript(buyerPubKey, sellerPubKey);
        if (legacy) {
            return ScriptBuilder.createP2SHOutputScript(redeemScript);
        } else {
            return ScriptBuilder.createP2WSHOutputScript(redeemScript);
        }
    }

    private Transaction createPayoutTx(Transaction depositTx,
                                       Coin buyerPayoutAmount,
                                       Coin sellerPayoutAmount,
                                       String buyerAddressString,
                                       String sellerAddressString) throws AddressFormatException {
        TransactionOutput hashedMultiSigOutput = depositTx.getOutput(0);
        Transaction transaction = new Transaction(params);
        transaction.addInput(hashedMultiSigOutput);
        if (buyerPayoutAmount.isPositive()) {
            transaction.addOutput(buyerPayoutAmount, Address.fromString(params, buyerAddressString));
        }
        if (sellerPayoutAmount.isPositive()) {
            transaction.addOutput(sellerPayoutAmount, Address.fromString(params, sellerAddressString));
        }
        checkArgument(transaction.getOutputs().size() >= 1, ""We need at least one output."");
        return transaction;
    }

    private void signInput(Transaction transaction, TransactionInput input, int inputIndex) throws SigningException {
        checkNotNull(input.getConnectedOutput(), ""input.getConnectedOutput() must not be null"");
        Script scriptPubKey = input.getConnectedOutput().getScriptPubKey();
        ECKey sigKey = input.getOutpoint().getConnectedKey(wallet);
        checkNotNull(sigKey, ""signInput: sigKey must not be null. input.getOutpoint()="" +
                input.getOutpoint().toString());
        if (sigKey.isEncrypted()) {
            checkNotNull(aesKey);
        }

        if (ScriptPattern.isP2PK(scriptPubKey) || ScriptPattern.isP2PKH(scriptPubKey)) {
            Sha256Hash hash = transaction.hashForSignature(inputIndex, scriptPubKey, Transaction.SigHash.ALL, false);
            ECKey.ECDSASignature signature = sigKey.sign(hash, aesKey);
            TransactionSignature txSig = new TransactionSignature(signature, Transaction.SigHash.ALL, false);
            if (ScriptPattern.isP2PK(scriptPubKey)) {
                input.setScriptSig(ScriptBuilder.createInputScript(txSig));
            } else if (ScriptPattern.isP2PKH(scriptPubKey)) {
                input.setScriptSig(ScriptBuilder.createInputScript(txSig, sigKey));
            }
        } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {
            // scriptCode is expected to have the format of a legacy P2PKH output script
            Script scriptCode = ScriptBuilder.createP2PKHOutputScript(sigKey);
            Coin value = input.getValue();
            TransactionSignature txSig = transaction.calculateWitnessSignature(inputIndex, sigKey, aesKey, scriptCode, value,
                    Transaction.SigHash.ALL, false);
            input.setScriptSig(ScriptBuilder.createEmpty());
            input.setWitness(TransactionWitness.redeemP2WPKH(txSig, sigKey));
        } else {
            throw new SigningException(""Don't know how to sign for this kind of scriptPubKey: "" + scriptPubKey);
        }
    }

    private void addAvailableInputsAndChangeOutputs(Transaction transaction,
                                                    Address address,
                                                    Address changeAddress) throws WalletException {
        SendRequest sendRequest = null;
        try {
            // Let the framework do the work to find the right inputs
            sendRequest = SendRequest.forTx(transaction);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            // We use a fixed fee
            sendRequest.fee = Coin.ZERO;
            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;
            // we allow spending of unconfirmed tx (double spend risk is low and usability would suffer if we need to wait for 1 confirmation)
            sendRequest.coinSelector = new BtcCoinSelector(address, preferences.getIgnoreDustThreshold());
            // We use always the same address in a trade for all transactions
            sendRequest.changeAddress = changeAddress;
            // With the usage of completeTx() we get all the work done with fee calculation, validation and coin selection.
            // We don't commit that tx to the wallet as it will be changed later and it's not signed yet.
            // So it will not change the wallet balance.
            checkNotNull(wallet, ""wallet must not be null"");
            wallet.completeTx(sendRequest);
        } catch (Throwable t) {
            if (sendRequest != null && sendRequest.tx != null) {
                log.warn(""addAvailableInputsAndChangeOutputs: sendRequest.tx={}, sendRequest.tx.getOutputs()={}"",
                        sendRequest.tx, sendRequest.tx.getOutputs());
            }

            throw new WalletException(t);
        }
    }

    private void applyLockTime(long lockTime, Transaction tx) {
        checkArgument(!tx.getInputs().isEmpty(), ""The tx must have inputs. tx={}"", tx);
        tx.getInputs().forEach(input -> input.setSequenceNumber(TransactionInput.NO_SEQUENCE - 1));
        tx.setLockTime(lockTime);
    }

    // BISQ issue #4039: prevent dust outputs from being created.
    // check all the outputs in a proposed transaction, if any are below the dust threshold
    // remove them, noting the details in the log. returns 'true' to indicate if any dust was
    // removed.
    private boolean removeDust(Transaction transaction) {
        List<TransactionOutput> originalTransactionOutputs = transaction.getOutputs();
        List<TransactionOutput> keepTransactionOutputs = new ArrayList<>();
        for (TransactionOutput transactionOutput : originalTransactionOutputs) {
            if (transactionOutput.getValue().isLessThan(Restrictions.getMinNonDustOutput())) {
                log.info(""your transaction would have contained a dust output of {}"", transactionOutput.toString());
            } else {
                keepTransactionOutputs.add(transactionOutput);
            }
        }
        // if dust was detected, keepTransactionOutputs will have fewer elements than originalTransactionOutputs
        // set the transaction outputs to what we saved in keepTransactionOutputs, thus discarding dust.
        if (keepTransactionOutputs.size() != originalTransactionOutputs.size()) {
            log.info(""dust output was detected and removed, the new output is as follows:"");
            transaction.clearOutputs();
            for (TransactionOutput transactionOutput : keepTransactionOutputs) {
                transaction.addOutput(transactionOutput);
                log.info(""{}"", transactionOutput.toString());
            }
            return true;    // dust was removed
        }
        return false;       // no action necessary
    }
}",1,439 334 2000 123 437 457 381 2001 2002 61 2003 46 2004 40 2000 46 334 41 59 437 457 381 2005 2006 61 2005 46 2007 40 1504 41 59 437 381 2008 2009 59 437 381 2010 2011 59 437 381 2012 433 59 64 2013 437 2014 2015 59 64 2013 437 2016 2017 59 64 2013 437 2018 2019 59 621 621 621 64 2020 439 2000 40 2008 2009 44 2010 2011 41 123 467 46 2009 61 2009 59 467 46 2011 61 2011 59 467 46 433 61 2021 46 2022 40 41 59 2009 46 2023 40 40 41 45 62 123 2017 61 2009 46 2024 40 41 59 2015 61 2009 46 2025 40 41 59 125 41 59 125 621 621 621 492 2026 40 64 2013 2018 2027 41 123 467 46 2019 61 2027 59 125 64 2013 439 2018 2028 40 41 123 450 2019 59 125 621 621 621 618 439 2029 2030 40 2031 2032 44 2031 2033 44 2031 2034 44 2005 2035 44 324 2036 44 2005 2037 44 2005 2038 44 2039 2040 44 324 2041 44 64 2013 2042 46 2043 2044 41 470 2045 44 2046 123 2029 2047 61 418 2029 40 433 41 59 2048 2049 61 424 59 474 123 2047 46 2050 40 2037 44 2031 46 2051 40 433 44 2040 41 41 59 621 2047 46 2050 40 2035 44 2033 41 59 621 621 621 2049 61 2048 46 2052 40 2047 41 59 2049 46 2053 61 380 59 2049 46 2019 61 2019 59 392 40 2036 41 123 2049 46 2054 61 418 2055 40 2009 46 2056 40 2057 46 2058 46 2059 41 44 2011 46 2060 40 41 41 59 125 360 123 2049 46 2061 61 418 2062 40 2032 44 2011 46 2063 40 41 41 59 125 621 2049 46 2064 61 2038 59 2049 46 2065 61 2005 46 2066 59 2049 46 2067 61 380 59 621 2049 46 2034 61 2034 59 2068 40 2015 44 648 41 59 2015 46 2069 40 2049 41 59 392 40 2070 40 2047 41 41 123 2015 46 2071 40 2049 41 59 125 2072 46 2073 40 648 44 2047 41 59 392 40 2041 605 2044 631 424 41 123 2074 40 2047 44 2044 41 59 125 450 2047 59 125 329 40 2075 2076 41 123 392 40 2015 631 424 605 2049 631 424 605 2049 46 2077 631 424 41 123 2002 46 371 40 648 44 2015 46 2078 40 2049 46 2077 41 44 2049 46 2077 41 59 125 2002 46 371 40 648 44 2047 46 2079 40 41 44 2047 46 2080 40 41 41 59 469 2076 59 125 125 439 2029 2081 40 2029 2082 44 2031 2032 44 2031 2033 44 2031 2034 44 2005 2035 44 324 2036 44 2005 2038 41 470 2083 44 2084 44 2045 44 2046 123 474 123 621 621 621 621 621 621 621 621 621 621 621 621 621 621 381 404 2085 61 2082 46 2086 40 41 46 2087 40 41 59 381 324 2088 61 33 2082 46 2089 40 41 46 2090 40 41 59 621 621 621 621 392 40 33 2088 41 123 490 2091 61 2082 46 2086 40 41 46 2092 40 41 46 2093 40 2094 58 58 2095 41 46 2096 40 2005 46 2007 40 1500 41 44 2005 58 58 2097 41 59 2082 46 2098 40 2091 46 2097 40 2005 46 2007 40 1501 41 41 44 2034 41 59 125 621 2082 46 2099 40 2035 44 2033 41 59 621 621 621 2100 2101 61 2100 46 2102 40 2082 41 59 2101 46 2103 61 380 59 2101 46 2019 61 2019 59 392 40 2036 41 123 2101 46 2104 61 418 2105 40 2009 46 2106 40 2107 46 2108 46 2109 41 44 2011 46 2110 40 41 41 59 125 360 123 2101 46 2111 61 418 2112 40 2032 44 2011 46 2113 40 41 41 59 125 621 2101 46 2114 61 2038 59 2101 46 2115 61 2005 46 2116 59 2101 46 2117 61 380 59 2101 46 2118 61 380 59 621 2101 46 2034 61 2034 59 2119 40 2015 44 648 41 59 2015 46 2120 40 2101 41 59 2029 2121 61 2101 46 2122 59 2123 40 2121 41 59 621 385 40 404 2124 61 2085 59 2124 60 2121 46 2086 40 41 46 2087 40 41 59 2124 637 41 123 2125 2126 61 2121 46 2086 40 41 46 2127 40 2124 41 59 2128 40 2126 46 2129 40 41 631 424 605 2126 46 2129 40 41 46 2130 40 2015 41 44 648 41 59 2131 46 2132 40 2015 44 2019 44 2121 44 2126 44 2124 41 59 2131 46 2133 40 2121 44 2126 44 2124 41 59 125 2134 46 2135 40 2015 41 59 2134 46 2136 40 2121 41 59 2134 46 2137 40 2138 46 2139 40 41 43 648 44 2121 41 59 450 2121 59 125 329 40 2140 2141 41 123 2002 46 371 40 648 44 2082 46 2142 40 41 41 59 469 2141 59 125 125 621 621 621 621 621 621 621 618 439 2143 2144 40 2029 2145 44 2005 2146 44 2005 2038 41 470 2083 123 621 621 621 621 604 621 2005 2147 61 2146 46 2148 40 2038 41 59 2029 2149 61 418 2029 40 433 41 59 621 621 2150 2151 61 418 2150 40 433 44 2149 44 2147 44 2152 46 2153 40 433 44 418 2154 40 41 41 41 59 2149 46 2155 40 2151 41 59 621 621 621 621 2150 2156 61 2145 46 2157 40 41 46 2158 40 1501 41 59 2159 40 2156 46 2160 40 41 46 2161 40 2146 41 44 648 41 59 2149 46 2162 40 2156 41 59 2163 46 2164 40 2149 41 59 621 2165 60 2166 62 2167 61 2149 46 2168 40 41 46 2169 40 41 46 2170 40 2171 45 62 123 2172 40 2171 46 2173 40 41 44 648 41 59 2172 40 2171 46 2173 40 41 46 2174 40 41 44 648 41 59 2172 40 2171 46 2160 40 41 44 648 41 59 450 2175 40 2171 41 59 125 41 46 2176 40 2177 46 2178 40 41 41 59 621 621 621 621 621 450 418 2143 40 418 2179 60 62 40 2167 41 44 1500 44 424 41 59 125 439 2180 2181 40 2005 2182 44 2005 2183 44 2184 60 2185 62 2186 44 413 2187 44 64 2013 2039 2188 44 2031 2189 44 2031 2190 44 326 91 93 2191 44 326 91 93 2192 41 470 2193 44 2083 44 2084 44 2046 123 450 2194 40 380 44 2182 44 2183 44 2186 44 2187 44 2188 44 2189 44 2190 44 2191 44 2192 41 59 125 439 2180 2195 40 2005 2182 44 2005 2183 44 2184 60 2185 62 2186 44 413 2187 44 64 2013 2039 2188 44 2031 2189 44 2031 2190 44 326 91 93 2191 44 326 91 93 2192 41 470 2193 44 2083 44 2084 44 2046 123 450 2196 40 473 44 2182 44 2183 44 2186 44 2187 44 2188 44 2189 44 2190 44 2191 44 2192 41 59 125 618 437 2180 2197 40 324 2198 44 2005 2182 44 2005 2183 44 2184 60 2185 62 2186 44 413 2187 44 64 2013 2039 2188 44 2031 2189 44 2031 2190 44 326 91 93 2191 44 326 91 93 2192 41 470 2193 44 2083 44 2084 44 2046 123 2199 40 33 2186 46 2200 40 41 41 59 621 621 2029 2201 61 418 2029 40 433 41 59 2202 2203 61 418 2202 40 433 44 2201 44 2182 44 2204 46 2205 40 433 44 418 2206 40 41 41 41 59 2201 46 2207 40 2203 41 59 2208 40 2201 44 2189 44 2190 41 59 621 2184 60 2209 62 2210 61 2201 46 2211 40 41 59 2202 2212 61 424 59 621 2199 40 2201 46 2213 40 41 46 2214 40 41 60 1502 44 648 41 59 621 392 40 2201 46 2213 40 41 46 2214 40 41 62 1501 41 123 2212 61 2201 46 2215 40 1501 41 59 125 621 2029 2216 61 418 2029 40 433 41 59 2217 60 2185 62 2218 61 418 2217 60 62 40 41 59 392 40 2198 41 123 621 385 40 2209 2219 58 2210 41 123 2216 46 2220 40 2219 41 59 2218 46 2221 40 2222 40 2219 41 41 59 125 621 621 385 40 2185 2223 58 2186 41 2216 46 2224 40 2225 40 2216 44 418 326 91 93 123 125 44 2223 41 41 59 125 360 123 621 621 621 385 40 2185 2226 58 2186 41 2216 46 2227 40 2228 40 2216 44 418 326 91 93 123 125 44 2226 41 41 59 621 385 40 2209 2229 58 2210 41 123 2216 46 2227 40 2229 41 59 2218 46 2230 40 2231 40 2229 41 41 59 125 125 621 2232 2233 61 2234 40 2191 44 2192 44 380 41 59 621 2202 2235 61 418 2202 40 433 44 2216 44 2183 44 2233 46 2236 40 41 41 59 2216 46 2207 40 2235 41 59 2202 2237 61 424 59 392 40 2187 62 1500 605 2188 631 424 41 123 2237 61 418 2202 40 433 44 2216 44 2005 46 2007 40 2187 41 44 2031 46 2238 40 433 44 2188 41 41 59 125 392 40 2198 41 123 621 392 40 2212 631 424 41 123 2216 46 2207 40 2212 41 59 125 621 392 40 2237 631 424 41 123 2216 46 2207 40 2237 41 59 125 125 360 123 621 621 392 40 2237 631 424 41 123 2216 46 2207 40 2237 41 59 125 621 392 40 2212 631 424 41 123 2216 46 2207 40 2212 41 59 125 125 404 2239 61 2198 63 1500 58 2186 46 2214 40 41 59 404 2240 61 2198 63 2210 46 2214 40 41 58 2216 46 2211 40 41 46 2214 40 41 59 385 40 404 2241 61 2239 59 2241 60 2240 59 2241 637 41 123 2209 2242 61 2216 46 2243 40 2241 41 59 2244 40 2216 44 2242 44 2241 41 59 2245 46 2246 40 2216 44 2242 44 2241 41 59 125 2247 46 2248 40 648 44 2216 41 59 2247 46 2249 40 2216 41 59 450 418 2180 40 2218 44 2216 46 2250 40 41 41 59 125 618 439 2029 2251 40 324 2252 44 326 91 93 2253 44 2005 2183 44 2184 60 2185 62 2254 44 2184 60 2185 62 2255 44 326 91 93 2191 44 326 91 93 2192 41 470 2193 44 2083 44 2084 123 2029 2256 61 418 2029 40 433 44 2253 41 59 2257 40 33 2254 46 2258 40 41 41 59 2257 40 33 2255 46 2258 40 41 41 59 621 2259 2260 61 2261 40 2191 44 2192 44 380 41 59 392 40 33 2256 46 2262 40 1500 41 46 2263 40 41 46 2264 40 2260 41 41 123 469 418 2083 40 648 41 59 125 621 392 40 33 2256 46 2262 40 1500 41 46 2265 40 41 46 2264 40 2183 41 41 123 469 418 2083 40 648 41 59 125 621 621 2029 2266 61 418 2029 40 433 41 59 392 40 2252 41 123 621 621 385 40 404 2267 61 1500 59 2267 60 2254 46 2268 40 41 59 2267 637 41 123 2269 2270 61 2256 46 2271 40 41 46 2272 40 2267 41 59 326 91 93 2273 61 2270 46 2274 40 41 46 2275 40 41 59 2269 2276 61 2277 40 2266 44 2273 44 2254 46 2272 40 2267 41 41 59 2259 2278 61 2279 40 2276 46 2280 40 41 41 46 2263 40 41 59 392 40 2273 46 2281 614 1500 605 33 2282 46 2283 40 2278 41 41 123 469 418 2083 40 648 41 59 125 392 40 33 2284 46 2285 46 2264 40 2270 46 2286 40 41 41 41 123 2276 46 2287 40 2270 46 2286 40 41 41 59 125 2266 46 2288 40 2276 41 59 125 621 385 40 2185 2289 58 2255 41 123 2266 46 2290 40 2291 40 2266 44 418 326 91 93 123 125 44 2289 41 41 59 125 125 360 123 621 621 385 40 2185 2292 58 2254 41 123 2266 46 2293 40 2294 40 2266 44 418 326 91 93 123 125 44 2292 41 41 59 125 621 621 385 40 404 2295 61 2254 46 2296 40 41 44 2297 61 1500 59 2295 60 2256 46 2298 40 41 46 2296 40 41 59 2295 637 44 2297 637 41 123 2299 2300 61 2256 46 2298 40 41 46 2301 40 2295 41 59 621 2266 46 2302 40 2303 40 2266 44 418 326 91 93 123 125 44 2255 46 2301 40 2297 41 41 41 59 125 125 621 2256 46 2304 40 41 46 2305 40 2266 58 58 2306 41 59 2307 46 2308 40 648 44 2256 41 59 621 404 2309 61 2252 63 2254 46 2310 40 41 58 1500 59 404 2311 61 2252 63 2266 46 2312 40 41 46 2310 40 41 58 2254 46 2310 40 41 59 385 40 404 2313 61 2309 59 2313 60 2311 59 2313 637 41 123 2314 2315 61 2266 46 2316 40 2313 41 59 2317 40 2266 44 2315 44 2313 41 59 2307 46 2318 40 2266 44 2315 44 2313 41 59 125 2307 46 2308 40 648 44 2266 41 59 2307 46 2319 40 2266 41 59 2307 46 2320 40 2015 41 59 450 2266 59 125 439 492 2321 40 2029 2322 44 2029 2323 44 404 2324 41 470 2083 44 2046 123 621 385 40 404 2325 61 1500 59 2325 60 2324 59 2325 637 41 123 2326 2327 61 2323 46 2328 40 2325 41 59 2329 2330 61 2327 46 2331 40 41 59 2326 2332 61 2322 46 2328 40 2325 41 59 2332 46 2333 40 2330 41 59 2334 2335 61 2327 46 2336 40 41 59 392 40 33 2334 46 2337 46 2338 40 2335 41 41 123 2332 46 2339 40 2335 41 59 125 125 2340 46 2341 40 648 44 2322 41 59 2340 46 2342 40 2322 41 59 125 439 492 2343 40 2029 2322 44 2029 2344 41 123 404 2345 61 2322 46 2346 40 41 46 2347 40 41 59 385 40 404 2348 61 1500 59 2348 60 2345 59 2348 637 41 123 490 2349 61 2322 46 2350 40 2348 41 59 490 2351 61 2344 46 2350 40 2348 41 46 2352 40 41 59 392 40 2353 46 2354 46 2355 40 2349 46 2352 40 41 41 605 33 2353 46 2354 46 2355 40 2351 41 41 123 2349 46 2356 40 2351 41 59 125 125 125 621 621 621 439 2029 2357 40 2029 2358 44 2039 2359 44 2005 2360 44 413 2361 41 470 2046 44 2083 123 2362 2363 61 2358 46 2364 40 1500 41 59 2029 2365 61 418 2029 40 433 41 59 2365 46 2366 40 2363 41 59 2367 40 2361 44 2365 41 59 2005 2368 61 2363 46 2369 40 41 46 2370 40 2360 41 59 2365 46 2371 40 2368 44 2031 46 2372 40 433 44 2359 41 41 59 2373 46 2374 40 648 44 2365 41 59 2373 46 2375 40 2365 41 59 450 2365 59 125 439 326 91 93 2376 40 2029 2377 44 2029 2378 44 2379 2380 44 326 91 93 2191 44 326 91 93 2192 41 470 2046 44 2083 123 2381 2382 61 2383 40 2191 44 2192 41 59 2384 2385 59 2005 2386 61 2378 46 2387 40 1500 41 46 2388 40 41 59 2385 61 2377 46 2389 40 1500 44 2382 44 2386 44 2029 46 2390 46 2391 44 380 41 59 2392 40 2380 44 648 41 59 392 40 2380 46 2393 40 41 41 123 2392 40 2019 41 59 125 2394 46 2395 2396 61 2380 46 2397 40 2385 44 2019 41 46 2398 40 41 59 2399 46 2400 40 648 44 2377 41 59 2399 46 2401 40 2377 41 59 450 2396 46 2402 40 41 59 125 439 2029 2403 40 2029 2377 44 326 91 93 2191 44 326 91 93 2192 44 326 91 93 2404 44 326 91 93 2405 44 2005 2406 41 470 2046 44 2083 44 2407 123 2408 2409 61 2410 40 2191 44 2192 41 59 2411 46 2412 2413 61 2411 46 2412 46 2414 40 2404 41 59 2411 46 2412 2415 61 2411 46 2412 46 2414 40 2405 41 59 2416 2417 61 418 2416 40 2413 44 2029 46 2418 46 2419 44 380 41 59 2416 2420 61 418 2416 40 2415 44 2029 46 2418 46 2419 44 380 41 59 2421 2422 61 2377 46 2423 40 1500 41 59 2422 46 2424 40 2425 46 2426 40 41 41 59 2427 2428 61 2427 46 2429 40 2409 44 2420 44 2417 41 59 2422 46 2430 40 2428 41 59 2431 46 2432 40 648 44 2377 41 59 2431 46 2433 40 2377 41 59 392 40 2434 40 2406 41 46 2435 40 2377 46 2436 40 41 46 2437 40 2006 41 41 41 123 469 418 2083 40 648 41 59 125 2408 2438 61 2439 40 2191 44 2192 44 380 41 59 2422 46 2440 40 41 46 2441 40 2377 44 1500 44 2428 44 2406 44 2438 44 2408 46 2442 41 59 450 2377 59 125 439 2029 2443 40 2029 2377 44 326 91 93 2191 44 326 91 93 2192 44 326 91 93 2404 44 326 91 93 2405 41 470 2046 44 2083 44 2084 44 2407 123 2444 2445 61 2377 46 2446 40 1500 41 59 2403 40 2377 44 2191 44 2192 44 2404 44 2405 44 2445 46 2447 40 41 41 59 2448 46 2449 40 2015 41 59 2450 40 2445 46 2451 40 41 44 648 41 59 2445 46 2452 40 2445 46 2451 40 41 41 59 450 2377 59 125 621 621 621 618 439 326 91 93 2453 40 2029 2358 44 2005 2454 44 2005 2455 44 2039 2456 44 2039 2457 44 2379 2458 44 326 91 93 2191 44 326 91 93 2192 41 470 2046 44 2083 123 2029 2459 61 2460 40 2358 44 2454 44 2455 44 2456 44 2457 41 59 621 2461 2462 61 2463 40 2191 44 2192 41 59 621 2464 2465 59 2466 2467 61 2358 46 2468 40 1500 41 59 392 40 2469 46 2470 40 2467 46 2471 40 41 41 41 123 2465 61 2459 46 2472 40 1500 44 2462 44 2029 46 2473 46 2474 44 380 41 59 125 360 123 2005 2406 61 2467 46 2475 40 41 59 2465 61 2459 46 2476 40 1500 44 2462 44 2406 44 2029 46 2477 46 2478 44 380 41 59 125 2479 40 2458 44 648 41 59 392 40 2458 46 2480 40 41 41 123 2479 40 2019 41 59 125 2481 46 2482 2404 61 2458 46 2483 40 2465 44 2019 41 46 2484 40 41 59 2485 46 2486 40 648 44 2459 41 59 2485 46 2487 40 2459 41 59 450 2404 46 2488 40 41 59 125 618 439 2029 2489 40 2029 2358 44 326 91 93 2404 44 2005 2454 44 2005 2455 44 2039 2456 44 2039 2457 44 2379 2458 44 326 91 93 2191 44 326 91 93 2192 41 470 2046 44 2083 44 2084 44 2407 123 2029 2490 61 2491 40 2358 44 2454 44 2455 44 2456 44 2457 41 59 621 2492 2493 61 2494 40 2191 44 2192 41 59 621 2495 2496 61 2358 46 2497 40 1500 41 59 324 2498 61 2499 46 2500 40 2496 46 2501 40 41 41 59 2502 2503 59 392 40 2498 41 123 2503 61 2490 46 2504 40 1500 44 2493 44 2029 46 2505 46 2506 44 380 41 59 125 360 123 2005 2406 61 2496 46 2507 40 41 59 2503 61 2490 46 2508 40 1500 44 2493 44 2406 44 2029 46 2509 46 2510 44 380 41 59 125 2511 40 2458 44 648 41 59 392 40 2458 46 2512 40 41 41 123 2511 40 2019 41 59 125 2513 46 2514 2405 61 2458 46 2515 40 2503 44 2019 41 46 2516 40 41 59 2517 2518 61 418 2517 40 2513 46 2514 46 2519 40 2404 41 44 2029 46 2520 46 2521 44 380 41 59 2517 2522 61 418 2517 40 2405 44 2029 46 2520 46 2521 44 380 41 59 621 2523 2524 61 2490 46 2525 40 1500 41 59 392 40 2498 41 123 2492 2526 61 2527 46 2528 40 2529 46 2530 40 2522 44 2518 41 44 2493 41 59 2524 46 2531 40 2526 41 59 125 360 123 2524 46 2532 40 2533 46 2534 40 41 41 59 2524 46 2535 40 2536 46 2537 40 2493 44 2522 44 2518 41 41 59 125 2538 46 2539 40 648 44 2490 41 59 2538 46 2540 40 2490 41 59 2538 46 2541 40 2015 41 59 2538 46 2542 40 2490 44 2524 44 1500 41 59 2511 40 2524 46 2543 40 41 44 648 41 59 2524 46 2544 40 2524 46 2543 40 41 41 59 450 2490 59 125 621 621 621 439 326 91 93 2545 40 2029 2358 44 2005 2454 44 2005 2455 44 2039 2456 44 2039 2457 44 2379 2380 44 326 91 93 2191 44 326 91 93 2192 41 470 2046 44 2083 123 2029 2546 61 2547 40 2358 44 2454 44 2455 44 2456 44 2457 41 59 621 2548 2549 61 2550 40 2191 44 2192 41 59 621 2551 2552 61 2358 46 2553 40 1500 41 59 324 2554 61 2555 46 2556 40 2552 46 2557 40 41 41 59 2558 2559 59 392 40 2554 41 123 2559 61 2546 46 2560 40 1500 44 2549 44 2029 46 2561 46 2562 44 380 41 59 125 360 123 2005 2406 61 2552 46 2563 40 41 59 2559 61 2546 46 2564 40 1500 44 2549 44 2406 44 2029 46 2565 46 2566 44 380 41 59 125 2567 40 2380 44 648 41 59 392 40 2380 46 2568 40 41 41 123 2567 40 2019 41 59 125 2569 46 2570 2571 61 2380 46 2572 40 2559 44 2019 41 46 2573 40 41 59 2574 46 2575 40 648 44 2546 41 59 2574 46 2576 40 2546 41 59 450 2571 46 2577 40 41 59 125 439 2029 2578 40 2029 2358 44 326 91 93 2404 44 326 91 93 2405 44 2005 2454 44 2005 2455 44 2039 2456 44 2039 2457 44 2379 2458 44 326 91 93 2191 44 326 91 93 2192 41 470 2046 44 2083 44 2084 44 2407 123 2029 2579 61 2580 40 2358 44 2454 44 2455 44 2456 44 2457 41 59 621 2581 2582 61 2583 40 2191 44 2192 41 59 621 2584 40 2458 44 648 41 59 2585 2586 61 418 2585 40 2587 46 2588 46 2589 40 2404 41 44 2029 46 2590 46 2591 44 380 41 59 2585 2592 61 418 2585 40 2587 46 2588 46 2589 40 2405 41 44 2029 46 2590 46 2591 44 380 41 59 621 2593 2594 61 2358 46 2595 40 1500 41 59 324 2596 61 2597 46 2598 40 2594 46 2599 40 41 41 59 2600 2601 61 2579 46 2602 40 1500 41 59 392 40 2596 41 123 2581 2603 61 2604 46 2605 40 2606 46 2607 40 2592 44 2586 41 44 2582 41 59 2601 46 2608 40 2603 41 59 125 360 123 2601 46 2609 40 2610 46 2611 40 41 41 59 2601 46 2612 40 2613 46 2614 40 2582 44 2592 44 2586 41 41 59 125 2615 46 2616 40 648 44 2579 41 59 2615 46 2617 40 2579 41 59 2615 46 2618 40 2015 41 59 2615 46 2619 40 2579 44 2601 44 1500 41 59 2584 40 2601 46 2620 40 41 44 648 41 59 2601 46 2621 40 2601 46 2620 40 41 41 59 450 2579 59 125 621 621 621 621 621 618 439 2029 2622 40 326 91 93 2623 44 326 91 93 2624 44 2005 2454 44 2005 2455 44 2039 2625 44 2039 2626 44 2379 2627 44 326 91 93 2191 44 326 91 93 2192 44 326 91 93 2628 41 470 2046 44 2083 44 2084 44 2407 123 2029 2358 61 418 2029 40 433 44 2623 41 59 2629 2630 61 2358 46 2631 40 1500 41 59 2029 2632 61 418 2029 40 433 41 59 2632 46 2633 40 2630 41 59 392 40 2454 46 2634 40 41 41 123 2632 46 2635 40 2454 44 2031 46 2636 40 433 44 2625 41 41 59 125 392 40 2455 46 2634 40 41 41 123 2632 46 2637 40 2455 44 2031 46 2638 40 433 44 2626 41 41 59 125 621 2639 2640 61 2641 40 2191 44 2192 44 2628 41 59 2642 2643 59 324 2644 61 33 2645 46 2646 40 2630 46 2647 40 41 41 59 392 40 2644 41 123 2643 61 2632 46 2648 40 1500 44 2640 44 2029 46 2649 46 2650 44 380 41 59 125 360 123 2005 2406 61 2630 46 2651 40 41 59 2643 61 2632 46 2652 40 1500 44 2640 44 2406 44 2029 46 2653 46 2654 44 380 41 59 125 2655 40 2627 44 648 41 59 392 40 2627 46 2656 40 41 41 123 2655 40 2019 41 59 125 2657 46 2658 2659 61 2627 46 2660 40 2643 44 2019 41 46 2661 40 41 59 2662 2663 61 418 2662 40 2659 44 2029 46 2664 46 2665 44 380 41 59 2662 2666 61 418 2662 40 2657 46 2658 46 2667 40 2624 41 44 2029 46 2664 46 2665 44 380 41 59 2668 2669 61 2632 46 2670 40 1500 41 59 621 392 40 2644 41 123 2639 2671 61 2672 46 2673 40 2674 46 2675 40 2666 44 2663 41 44 2640 41 59 2669 46 2676 40 2671 41 59 125 360 123 2669 46 2677 40 2678 46 2679 40 41 41 59 2669 46 2680 40 2681 46 2682 40 2640 44 2666 44 2663 41 41 59 125 2683 46 2684 40 648 44 2632 41 59 2683 46 2685 40 2632 41 59 2683 46 2686 40 2015 41 59 2683 46 2687 40 2632 44 2669 44 1500 41 59 2655 40 2669 46 2688 40 41 44 648 41 59 2669 46 2689 40 2669 46 2688 40 41 41 59 450 2632 59 125 621 621 621 439 2690 60 2039 44 2039 62 2691 40 2039 2692 44 2005 2454 44 2005 2455 44 2005 2038 44 2039 2625 44 2039 2626 44 2039 2693 44 2039 2694 44 324 2695 41 123 326 91 93 2191 61 2696 46 2697 40 2698 46 2699 46 2700 40 2693 41 41 46 2701 40 41 59 326 91 93 2192 61 2696 46 2697 40 2698 46 2699 46 2700 40 2694 41 41 46 2701 40 41 59 2702 2703 61 2704 40 2191 44 2192 41 59 2005 2705 61 2454 46 2706 40 2455 41 46 2706 40 2038 41 59 2029 2707 61 418 2029 40 433 41 59 2708 2709 61 2708 46 2710 40 2692 41 59 2707 46 2711 40 418 2712 40 433 44 2707 44 418 326 91 93 123 125 44 418 2713 40 433 44 1500 44 2709 41 44 2705 41 41 59 392 40 2454 46 2714 40 41 41 123 2707 46 2715 40 2454 44 2031 46 2716 40 433 44 2625 41 41 59 125 392 40 2455 46 2714 40 41 41 123 2707 46 2717 40 2455 44 2031 46 2718 40 433 44 2626 41 41 59 125 2039 2719 61 2698 46 2699 46 2720 40 2703 46 2721 40 41 41 59 2039 2722 61 2698 46 2699 46 2720 40 2707 46 2723 40 33 2695 41 41 59 450 418 2690 60 62 40 2719 44 2722 41 59 125 439 2039 2724 40 2039 2725 44 2039 2726 44 2005 2406 44 2039 2727 41 470 2728 123 324 2695 61 473 59 392 40 2725 46 2729 40 648 41 41 2695 61 380 59 326 91 93 2730 61 2731 46 2732 46 2733 40 2725 41 59 2029 2734 61 418 2029 40 433 44 2730 44 424 44 433 46 2735 40 41 44 2730 46 2736 41 59 2737 2738 61 418 2737 40 2731 46 2732 46 2733 40 2726 41 41 59 2739 2740 59 392 40 2695 41 123 2740 61 2734 46 2741 40 1500 44 2738 44 2029 46 2742 46 2743 44 380 41 59 125 360 123 2740 61 2734 46 2744 40 1500 44 2738 44 2406 44 2029 46 2745 46 2746 44 380 41 59 125 2747 2748 61 2747 46 2749 40 2731 46 2732 46 2733 40 2727 41 41 59 2750 40 2748 44 648 41 59 2747 46 2751 2752 61 2748 46 2753 40 2740 44 2019 41 46 2754 40 41 59 2755 2756 61 418 2755 40 2752 44 2029 46 2757 46 2758 44 380 41 59 450 2731 46 2732 46 2759 40 2756 46 2760 40 41 41 59 125 439 2690 60 2039 44 2039 62 2761 40 2039 2762 44 2039 2726 44 2039 2763 44 2039 2764 44 324 2695 41 470 2046 44 2407 123 2029 2765 61 418 2029 40 433 44 2766 46 2767 46 2768 40 2762 41 41 59 2769 2770 61 2769 46 2771 40 2766 46 2767 46 2768 40 2763 41 44 473 44 473 41 59 2769 2772 61 2769 46 2771 40 2766 46 2767 46 2768 40 2764 41 44 473 44 473 41 59 2773 2774 61 418 2773 40 2766 46 2767 46 2768 40 2726 41 41 59 2775 2776 61 2765 46 2777 40 1500 41 59 392 40 2695 41 123 2773 2778 61 2779 46 2780 40 2781 46 2782 40 2772 44 2770 41 44 2774 41 59 2776 46 2783 40 2778 41 59 125 360 123 2776 46 2784 40 2785 46 2786 40 41 41 59 2776 46 2787 40 2788 46 2789 40 2774 44 2772 44 2770 41 41 59 125 2039 2790 61 2765 46 2791 40 41 46 2792 40 41 59 2039 2793 61 2766 46 2767 46 2794 40 2765 46 2795 40 33 2695 41 41 59 450 418 2690 60 62 40 2790 44 2793 41 59 125 439 492 2796 40 2039 2797 44 2042 46 2043 2044 41 470 2046 44 2083 44 2084 123 2029 2798 61 418 2029 40 433 44 2799 46 2800 46 2801 40 2797 41 41 59 2802 46 2803 40 648 44 2798 41 59 2802 46 2804 40 2798 41 59 2802 46 2805 40 2015 41 59 2806 40 2798 44 2044 44 1503 41 59 125 621 621 621 439 2029 2807 40 2184 60 2185 62 2808 44 2184 60 2185 62 2809 44 2005 2810 44 2039 2811 44 64 2013 2005 2812 44 64 2013 2039 2813 44 2005 2814 44 2039 2815 44 64 2013 2005 2816 44 64 2013 2039 2817 41 470 2046 123 2029 2818 61 418 2029 40 433 41 59 2184 60 2819 62 2820 61 2809 46 2821 40 41 46 2822 40 2823 45 62 2824 40 2818 44 418 326 91 93 123 125 44 2823 41 41 46 2825 40 2826 46 2827 40 41 41 59 450 2828 40 2808 44 2820 44 2810 44 2811 44 2812 44 2813 44 2814 44 2815 44 2816 44 2817 44 2818 41 59 125 439 2029 2829 40 2184 60 2185 62 2808 44 2184 60 2830 62 2809 44 2005 2810 44 2039 2811 44 64 2013 2005 2812 44 64 2013 2039 2813 44 2005 2814 44 2039 2815 44 64 2013 2005 2816 44 64 2013 2039 2817 41 470 2046 123 2029 2831 61 418 2029 40 433 41 59 450 2832 40 2808 44 2809 44 2810 44 2811 44 2812 44 2813 44 2814 44 2815 44 2816 44 2817 44 2831 41 59 125 437 2029 2833 40 2184 60 2185 62 2808 44 2184 60 2830 62 2809 44 2005 2810 44 2039 2811 44 64 2013 2005 2812 44 64 2013 2039 2813 44 2005 2814 44 2039 2815 44 64 2013 2005 2816 44 64 2013 2039 2817 44 2029 2834 41 470 2046 123 2808 46 2835 40 2836 45 62 2834 46 2837 40 2838 40 2834 44 418 326 91 93 123 125 44 2836 41 41 41 59 2809 46 2835 40 2834 58 58 2837 41 59 2834 46 2839 40 2810 44 2031 46 2840 40 433 44 2811 41 41 59 392 40 2812 631 424 605 2812 46 2841 40 41 41 2834 46 2839 40 2812 44 2031 46 2840 40 433 44 2842 46 2843 40 2813 41 41 41 59 2834 46 2839 40 2814 44 2031 46 2840 40 433 44 2815 41 41 59 392 40 2816 631 424 605 2816 46 2841 40 41 41 2834 46 2839 40 2816 44 2031 46 2840 40 433 44 2842 46 2843 40 2817 41 41 41 59 450 2834 59 125 439 492 2844 40 2029 2834 44 2184 60 2830 62 2845 41 470 2193 123 385 40 2830 2846 58 2845 41 123 2847 40 2834 44 2846 44 2846 46 2848 40 41 41 59 125 125 621 621 621 439 492 2849 40 2029 2850 44 2042 46 2043 2044 41 123 2851 40 2017 41 59 2042 46 2849 40 2015 44 2017 46 2852 40 41 44 2850 44 2044 41 59 125 439 492 2849 40 2029 2850 44 2042 46 2043 2044 44 404 2853 41 123 2854 40 2017 41 59 2042 46 2849 40 2015 44 2017 46 2855 40 41 44 2850 44 2044 44 2853 41 59 125 621 621 621 618 439 2029 2856 40 2857 2858 41 123 2859 40 2015 41 59 450 2015 46 2860 40 2858 41 59 125 439 492 2861 40 2029 2850 41 123 2862 40 2015 41 59 2015 46 2861 40 2850 41 59 125 439 2029 2863 40 2029 2850 41 123 450 418 2029 40 433 44 2850 46 2864 40 41 41 59 125 621 621 621 621 621 621 64 2865 437 2185 2866 40 2830 2867 41 123 2868 40 2867 44 648 41 59 2868 40 2867 46 2869 40 41 44 648 41 59 2868 40 2867 46 2869 40 41 46 2870 40 41 44 648 41 59 2868 40 2867 46 2871 40 41 44 648 41 59 621 621 621 621 450 418 2185 40 2867 46 2872 40 41 46 2873 40 41 44 2867 46 2869 40 41 46 2870 40 41 46 2874 40 380 41 44 2867 46 2871 40 41 46 2875 41 59 125 437 2830 2876 40 2029 2877 44 326 91 93 2878 44 2185 2879 41 123 450 418 2830 40 433 44 2877 44 2878 44 2880 40 2879 41 44 2005 46 2007 40 2879 46 2881 41 41 59 125 437 2882 2883 40 2185 2879 41 123 450 418 2882 40 433 44 2879 46 2884 44 418 2029 40 433 44 2879 46 2877 41 41 59 125 439 324 2885 40 2185 2879 41 123 450 2886 46 2885 40 2887 40 2883 40 2879 41 46 2888 40 41 41 46 2889 40 41 41 59 125 621 621 621 621 621 621 621 621 621 621 621 437 2890 2891 40 326 91 93 2191 44 326 91 93 2192 44 326 91 93 2628 41 123 2892 2893 61 2892 46 2894 40 2191 41 59 2892 2895 61 2892 46 2894 40 2192 41 59 2892 2896 61 2892 46 2894 40 2628 41 59 621 2184 60 2892 62 2897 61 2898 46 2899 40 2896 44 2895 44 2893 41 59 450 2900 46 2901 40 1502 44 2897 41 59 125 437 2890 2902 40 326 91 93 2191 44 326 91 93 2192 41 123 2903 2904 61 2903 46 2905 40 2191 41 59 2903 2906 61 2903 46 2905 40 2192 41 59 621 2184 60 2903 62 2907 61 2908 46 2909 40 2906 44 2904 41 59 450 2910 46 2911 40 1502 44 2907 41 59 125 437 2890 2912 40 326 91 93 2191 44 326 91 93 2192 44 324 2913 41 123 2890 2914 61 2902 40 2191 44 2192 41 59 392 40 2913 41 123 450 2915 46 2916 40 2914 41 59 125 360 123 450 2917 46 2918 40 2914 41 59 125 125 437 2029 2919 40 2029 2358 44 2005 2454 44 2005 2455 44 2039 2625 44 2039 2626 41 470 2046 123 2920 2921 61 2358 46 2922 40 1500 41 59 2029 2834 61 418 2029 40 433 41 59 2834 46 2923 40 2921 41 59 392 40 2454 46 2924 40 41 41 123 2834 46 2925 40 2454 44 2031 46 2926 40 433 44 2625 41 41 59 125 392 40 2455 46 2924 40 41 41 123 2834 46 2927 40 2455 44 2031 46 2928 40 433 44 2626 41 41 59 125 2929 40 2834 46 2930 40 41 46 2931 40 41 615 1501 44 648 41 59 450 2834 59 125 437 492 2932 40 2029 2834 44 2830 2867 44 404 2933 41 470 2193 123 2934 40 2867 46 2935 40 41 44 648 41 59 2890 2936 61 2867 46 2935 40 41 46 2937 40 41 59 2938 2939 61 2867 46 2940 40 41 46 2941 40 2015 41 59 2934 40 2939 44 648 43 2867 46 2940 40 41 46 2942 40 41 41 59 392 40 2939 46 2943 40 41 41 123 2934 40 2019 41 59 125 392 40 2944 46 2945 40 2936 41 606 2944 46 2946 40 2936 41 41 123 2857 2947 61 2834 46 2948 40 2933 44 2936 44 2029 46 2949 46 2950 44 380 41 59 2938 46 2951 2952 61 2939 46 2953 40 2947 44 2019 41 59 2954 2955 61 418 2954 40 2952 44 2029 46 2949 46 2950 44 380 41 59 392 40 2944 46 2945 40 2936 41 41 123 2867 46 2956 40 2957 46 2958 40 2955 41 41 59 125 360 392 40 2944 46 2946 40 2936 41 41 123 2867 46 2959 40 2960 46 2961 40 2955 44 2939 41 41 59 125 125 360 392 40 2944 46 2962 40 2936 41 41 123 621 2890 2963 61 2964 46 2965 40 2939 41 59 2005 2966 61 2867 46 2967 40 41 59 2968 2969 61 2834 46 2970 40 2933 44 2939 44 2019 44 2963 44 2966 44 2029 46 2971 46 2972 44 380 41 59 2867 46 2973 40 2964 46 2974 40 41 41 59 2867 46 2975 40 2976 46 2977 40 2969 44 2939 41 41 59 125 360 123 469 418 2193 40 648 43 2936 41 59 125 125 437 492 2978 40 2029 2834 44 2031 2979 44 2031 2034 41 470 2084 123 2980 2981 61 424 59 474 123 621 2981 61 2980 46 2982 40 2834 41 59 2981 46 2983 61 380 59 2981 46 2019 61 2019 59 621 2981 46 2984 61 2005 46 2985 59 2981 46 2986 61 2005 46 2985 59 2981 46 2987 61 380 59 621 2981 46 2988 61 418 2989 40 2979 44 2011 46 2990 40 41 41 59 621 2981 46 2034 61 2034 59 621 621 621 2991 40 2015 44 648 41 59 2015 46 2992 40 2981 41 59 125 329 40 2993 2994 41 123 392 40 2981 631 424 605 2981 46 2850 631 424 41 123 2002 46 2995 40 648 44 2981 46 2850 44 2981 46 2850 46 2996 40 41 41 59 125 469 418 2084 40 2994 41 59 125 125 437 492 2997 40 413 2361 44 2029 2850 41 123 2998 40 33 2850 46 2999 40 41 46 3000 40 41 44 648 44 2850 41 59 2850 46 2999 40 41 46 3001 40 2867 45 62 2867 46 3002 40 2830 46 3003 45 1501 41 41 59 2850 46 3004 40 2361 41 59 125 621 621 621 621 437 324 3005 40 2029 2834 41 123 2184 60 3006 62 3007 61 2834 46 3008 40 41 59 2184 60 3006 62 3009 61 418 3010 60 62 40 41 59 385 40 3006 3011 58 3007 41 123 392 40 3011 46 3012 40 41 46 3013 40 3014 46 3015 40 41 41 41 123 2002 46 3016 40 648 44 3011 46 3017 40 41 41 59 125 360 123 3009 46 3018 40 3011 41 59 125 125 621 621 392 40 3009 46 3019 40 41 631 3007 46 3019 40 41 41 123 2002 46 3020 40 648 41 59 2834 46 3021 40 41 59 385 40 3006 3011 58 3009 41 123 2834 46 3022 40 3011 41 59 2002 46 3020 40 648 44 3011 46 3023 40 41 41 59 125 450 473 59 621 125 450 380 59 621 125 125 
26125,Java,"public class ServerSettings {

    private static int serverId;

    private static byte ageLimit;
    private static boolean showBrackets;
    private static boolean isPvP;
    private static int type;
    private static int maximumOnlineUsers;
    private static Path dataPackDirectory;

    private static int scheduledPoolSize;
    private static int threadPoolSize;
    private static int[] acceptedProtocols;
    private static boolean scheduleRestart;
    private static boolean useDeadLockDetector;
    private static int deadLockDetectorInterval;
    private static boolean restartOnDeadLock;
    private static int maxPlayers;
    private static Predicate<String> playerNamePattern;
    private static Predicate<String> petNamePattern;
    private static Predicate<String> clanNamePattern;
    private static String[] scheduleRestartHours;
    private static boolean hardwareInfoEnabled;
    private static int maxPlayerPerHWID;
    private static int maxThreadPoolSize;
    private static int parallelismThreshold;

    private ServerSettings() {
        // helper class
    }

    public static void load(SettingsFile settingsFile) {
        serverId = settingsFile.getInt(""RequestServerID"", 1);
        type = ServerType.maskOf(settingsFile.getStringArray(""ServerListType""));

        maximumOnlineUsers = Math.max(1, settingsFile.getInt(""MaximumOnlineUsers"", 20));
        ageLimit = settingsFile.getByte(""ServerListAge"", (byte) 0);
        showBrackets = settingsFile.getBoolean(""ServerListBrackets"", false);
        isPvP = settingsFile.getBoolean(""PvPServer"", false);

        dataPackDirectory = Path.of(settingsFile.getString(""DatapackRoot"", "".""));

        var processors = Runtime.getRuntime().availableProcessors();

        scheduledPoolSize = determinePoolSize(settingsFile, ""ScheduledThreadPoolSize"", processors);
        threadPoolSize = determinePoolSize(settingsFile, ""ThreadPoolSize"", processors);
        maxThreadPoolSize = determinePoolSize(settingsFile, ""MaxThreadPoolSize"", threadPoolSize * 10);
        parallelismThreshold = settingsFile.getInt(""ParallelismThreshold"", 1000);
        acceptedProtocols =  settingsFile.getIntArray(""AllowedProtocolRevisions"", "";"");

        scheduleRestart = settingsFile.getBoolean(""ServerRestartScheduleEnabled"", false);
        scheduleRestartHours = settingsFile.getStringArray(""ServerRestartSchedule"");

        useDeadLockDetector = settingsFile.getBoolean(""DeadLockDetector"", true);
        deadLockDetectorInterval = settingsFile.getInt(""DeadLockCheckInterval"", 1800);
        restartOnDeadLock = settingsFile.getBoolean(""RestartOnDeadlock"", false);

        playerNamePattern = determineNamePattern(settingsFile, ""CnameTemplate"");
        petNamePattern = determineNamePattern(settingsFile, ""PetNameTemplate"");
        clanNamePattern = determineNamePattern(settingsFile, ""ClanNameTemplate"");

        maxPlayers = settingsFile.getInt(""CharMaxNumber"", 7);
        hardwareInfoEnabled = settingsFile.getBoolean(""EnableHardwareInfo"", false);
        maxPlayerPerHWID = settingsFile.getInt(""MaxPlayersPerHWID"", 0);
    }

    private static Predicate<String> determineNamePattern(SettingsFile settingsFile, String key) {
        try {
            return Pattern.compile(settingsFile.getString(key, "".*"")).asMatchPredicate();
        } catch (PatternSyntaxException e) {
            return Util.ANY_PATTERN;
        }
    }

    private static int determinePoolSize(SettingsFile settingsFile, String property, int processors) {
        var size = settingsFile.getInt(property, processors);

        if(size < 2) {
            return processors;
        }
        return size;
    }

    public static int serverId() {
        return serverId;
    }

    public static byte ageLimit() {
        return ageLimit;
    }

    public static boolean isShowingBrackets() {
        return showBrackets;
    }

    public static boolean isPvP() {
        return isPvP;
    }

    public static int type() {
        return type;
    }

    public static void setType(int value) {
        type = value;
    }

    public static int maximumOnlineUsers() {
        return maximumOnlineUsers;
    }

    public static Path dataPackDirectory() {
        return dataPackDirectory;
    }

    public static int scheduledPoolSize() {
        return scheduledPoolSize;
    }

    public static int threadPoolSize() {
        return threadPoolSize;
    }

    public static int maxThreadPoolSize() {
        return maxThreadPoolSize;
    }

    public static int parallelismThreshold() {
        return parallelismThreshold;
    }

    public static int[] acceptedProtocols() {
        return acceptedProtocols;
    }

    public static boolean scheduleRestart() {
        return scheduleRestart;
    }

    public static String[] scheduleRestartHours() {
        return scheduleRestartHours;
    }

    public static boolean useDeadLockDetector() {
        return useDeadLockDetector;
    }

    public static int deadLockDetectorInterval() {
        return deadLockDetectorInterval;
    }

    public static boolean restartOnDeadLock() {
        return restartOnDeadLock;
    }

    public static boolean acceptPlayerName(String name) {
        return playerNamePattern.test(name);
    }

    public static boolean acceptPetName(String name) {
        return petNamePattern.test(name);
    }

    public static boolean acceptClanName(String name) {
        return clanNamePattern.test(name);
    }

    public static int maxPlayersAllowed() {
        return maxPlayers;
    }

    public static boolean allowPlayersCount(int playerCount) {
        return maxPlayers <= 0 || maxPlayers >= playerCount;
    }

    public static void setAgeLimit(byte age) {
        ageLimit = age;
    }

    public static boolean isHardwareInfoEnabled() {
        return hardwareInfoEnabled;
    }

    public static int maxPlayerPerHWID() {
        return maxPlayerPerHWID;
    }
}",1,439 334 2000 123 437 457 404 2001 59 437 457 326 2002 59 437 457 324 2003 59 437 457 324 2004 59 437 457 404 2005 59 437 457 404 2006 59 437 457 2007 2008 59 437 457 404 2009 59 437 457 404 2010 59 437 457 404 91 93 2011 59 437 457 324 2012 59 437 457 324 2013 59 437 457 404 2014 59 437 457 324 2015 59 437 457 404 2016 59 437 457 2017 60 2018 62 2019 59 437 457 2017 60 2018 62 2020 59 437 457 2017 60 2018 62 2021 59 437 457 2018 91 93 2022 59 437 457 324 2023 59 437 457 404 2024 59 437 457 404 2025 59 437 457 404 2026 59 437 2000 40 41 123 621 125 439 457 492 2027 40 2028 2029 41 123 2001 61 2029 46 2030 40 648 44 1501 41 59 2005 61 2031 46 2032 40 2029 46 2033 40 648 41 41 59 2006 61 2034 46 2035 40 1501 44 2029 46 2030 40 648 44 1503 41 41 59 2002 61 2029 46 2036 40 648 44 40 326 41 1500 41 59 2003 61 2029 46 2037 40 648 44 380 41 59 2004 61 2029 46 2037 40 648 44 380 41 59 2008 61 2007 46 2038 40 2029 46 2039 40 648 44 648 41 41 59 490 2040 61 2041 46 2042 40 41 46 2043 40 41 59 2009 61 2044 40 2029 44 648 44 2040 41 59 2010 61 2044 40 2029 44 648 44 2040 41 59 2025 61 2044 40 2029 44 648 44 2010 42 1502 41 59 2026 61 2029 46 2030 40 648 44 1504 41 59 2011 61 2029 46 2045 40 648 44 648 41 59 2012 61 2029 46 2037 40 648 44 380 41 59 2022 61 2029 46 2033 40 648 41 59 2013 61 2029 46 2037 40 648 44 473 41 59 2014 61 2029 46 2030 40 648 44 1505 41 59 2015 61 2029 46 2037 40 648 44 380 41 59 2019 61 2046 40 2029 44 648 41 59 2020 61 2046 40 2029 44 648 41 59 2021 61 2046 40 2029 44 648 41 59 2016 61 2029 46 2030 40 648 44 1502 41 59 2023 61 2029 46 2037 40 648 44 380 41 59 2024 61 2029 46 2030 40 648 44 1500 41 59 125 437 457 2017 60 2018 62 2047 40 2028 2029 44 2018 2048 41 123 474 123 450 2049 46 2050 40 2029 46 2051 40 2048 44 648 41 41 46 2052 40 41 59 125 329 40 2053 2054 41 123 450 2055 46 2056 59 125 125 437 457 404 2057 40 2028 2029 44 2018 2058 44 404 2059 41 123 490 2060 61 2029 46 2061 40 2058 44 2059 41 59 392 40 2060 60 1502 41 123 450 2059 59 125 450 2060 59 125 439 457 404 2001 40 41 123 450 2001 59 125 439 457 326 2002 40 41 123 450 2002 59 125 439 457 324 2062 40 41 123 450 2003 59 125 439 457 324 2004 40 41 123 450 2004 59 125 439 457 404 2005 40 41 123 450 2005 59 125 439 457 492 2063 40 404 2064 41 123 2005 61 2064 59 125 439 457 404 2006 40 41 123 450 2006 59 125 439 457 2007 2008 40 41 123 450 2008 59 125 439 457 404 2009 40 41 123 450 2009 59 125 439 457 404 2010 40 41 123 450 2010 59 125 439 457 404 2025 40 41 123 450 2025 59 125 439 457 404 2026 40 41 123 450 2026 59 125 439 457 404 91 93 2011 40 41 123 450 2011 59 125 439 457 324 2012 40 41 123 450 2012 59 125 439 457 2018 91 93 2022 40 41 123 450 2022 59 125 439 457 324 2013 40 41 123 450 2013 59 125 439 457 404 2014 40 41 123 450 2014 59 125 439 457 324 2015 40 41 123 450 2015 59 125 439 457 324 2065 40 2018 2066 41 123 450 2019 46 2067 40 2066 41 59 125 439 457 324 2068 40 2018 2066 41 123 450 2020 46 2069 40 2066 41 59 125 439 457 324 2070 40 2018 2066 41 123 450 2021 46 2071 40 2066 41 59 125 439 457 404 2072 40 41 123 450 2016 59 125 439 457 324 2073 40 404 2074 41 123 450 2016 620 1500 606 2016 615 2074 59 125 439 457 492 2075 40 326 2076 41 123 2002 61 2076 59 125 439 457 324 2077 40 41 123 450 2023 59 125 439 457 404 2024 40 41 123 450 2024 59 125 125 
30735,Java,"public class RunTestsViaEcj extends AbstractRunTests {
	protected CompilerOptions ecjCompilerOptions() {
		CompilerOptions options = new CompilerOptions();
		Map<String, String> warnings = new HashMap<String, String>();
		
		String javaVersionString = System.getProperty(""compiler.compliance.level"");
		long ecjCompilerVersionConstant = Eclipse.getLatestEcjCompilerVersionConstant();
		long ecjCompilerVersion = Eclipse.getEcjCompilerVersion();
		if (javaVersionString != null) {
			long javaVersion = Long.parseLong(javaVersionString);
			ecjCompilerVersionConstant = (javaVersion + 44) << 16;
			ecjCompilerVersion = javaVersion;
		} else {
			// Preview features are only allowed if the maximum compiler version is equal to the source version
			warnings.put(""org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures"", ""enabled"");
		}
		options.complianceLevel = ecjCompilerVersionConstant;
		options.sourceLevel = ecjCompilerVersionConstant;
		options.targetJDK = ecjCompilerVersionConstant;
		options.docCommentSupport = false;
		options.parseLiteralExpressionsAsConstants = true;
		options.inlineJsrBytecode = true;
		options.reportUnusedDeclaredThrownExceptionExemptExceptionAndThrowable = false;
		options.reportUnusedDeclaredThrownExceptionIncludeDocCommentReference = false;
		options.reportUnusedDeclaredThrownExceptionWhenOverriding = false;
		options.reportUnusedParameterIncludeDocCommentReference = false;
		options.reportUnusedParameterWhenImplementingAbstract = false;
		options.reportUnusedParameterWhenOverridingConcrete = false;
		options.reportDeadCodeInTrivialIfStatement = false;
		options.generateClassFiles = false;
		warnings.put(CompilerOptions.OPTION_ReportUnusedLocal, ""ignore"");
		warnings.put(CompilerOptions.OPTION_ReportUnusedLabel, ""ignore"");
		warnings.put(CompilerOptions.OPTION_ReportUnusedImport, ""ignore"");
		warnings.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, ""ignore"");
		warnings.put(CompilerOptions.OPTION_ReportIndirectStaticAccess, ""warning"");
		warnings.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, ""warning"");
		warnings.put(""org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures"", ""ignore"");
		warnings.put(CompilerOptions.OPTION_Source, (ecjCompilerVersion < 9 ? ""1."" : """") + ecjCompilerVersion);
		options.set(warnings);
		return options;
	}
	
	protected IErrorHandlingPolicy ecjErrorHandlingPolicy() {
		return new IErrorHandlingPolicy() {
			public boolean stopOnFirstError() {
				return false;
			}
			
			public boolean proceedOnErrors() {
				return false;
			}
			
			@SuppressWarnings(""all"") // Added to the interface in later ecj version.
			public boolean ignoreAllErrors() {
				return false;
			}
		};
	}
	
	private ICompilationUnit getSourceUnit(File file, String source) {
		if (eclipseAvailable()) return new TestCompilationUnitEclipse(file.getName(), source);
		return new TestCompilationUnitEcj(file.getName(), source);
	}
	
	@Override
	public boolean transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding, Map<String, String> formatPreferences, int minVersion, boolean checkPositions) throws Throwable {
		final AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();
		final AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();
		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {
			@Override public void acceptResult(CompilationResult result) {
				compilationResult_.set(result);
			}
		};
		
		String source = readFile(file);
		char[] sourceArray = source.toCharArray();
		final ICompilationUnit sourceUnit;
		try {
			sourceUnit = getSourceUnit(file, source);
		} catch (Throwable t) {
			t.printStackTrace();
			return false;
		}
		
		Compiler ecjCompiler = new Compiler(createFileSystem(file, minVersion), ecjErrorHandlingPolicy(), ecjCompilerOptions(), bitbucketRequestor, new DefaultProblemFactory(Locale.ENGLISH)) {
			@Override protected synchronized void addCompilationUnit(ICompilationUnit inUnit, CompilationUnitDeclaration parsedUnit) {
				if (inUnit == sourceUnit) compilationUnit_.set(parsedUnit);
				super.addCompilationUnit(inUnit, parsedUnit);
			}
		};
		
		// initializeEclipseBundles();
		
		ecjCompiler.compile(new ICompilationUnit[] {sourceUnit});
		
		CompilationResult compilationResult = compilationResult_.get();
		CategorizedProblem[] problems = compilationResult.getAllProblems();
		
		if (problems != null) for (CategorizedProblem p : problems) {
			messages.add(new CompilerMessage(p.getSourceLineNumber(), p.getSourceStart(), p.isError(), p.getMessage()));
		}
		
		CompilationUnitDeclaration cud = compilationUnit_.get();
		
		if (cud == null) result.append(""---- No CompilationUnit provided by ecj ----"");
		else {
			String output = cud.toString();
			// starting somewhere around ecj16, the print code is a bit too cavalier with printing modifiers.
			output = output.replace(""non-sealed @val"", ""@val"");
			result.append(output);
		}
		
		if (eclipseAvailable()) {
			EclipseDomConversion.toDomAst(cud, sourceArray);
		}
		
		return true;
	}
	
	@SuppressWarnings(""unused"")
	private static class EclipseInitializer {
		static void initializeEclipseBundles() throws Exception {
			// This code does not work yet, it's research-in-progress.
			// The problem is that parts of the eclipse handler (in `PatchValEclipse` and friends) do not work unless
			// an actual eclipse exists; PatchVal causes code to run that will end up running `ResourcesPlugin.getWorkspace()`, which
			// goes down a rabbit hole of pinging off of various static fields (or `getX()` calls which return static fields), all
			// of which are `null` until the plugin they belong to is properly initialized.
			// This code is work in progress to 'hack' the initialization of each plugin one-by-one, but I doubt this is the right
			// way to do it, as I bet it's fragile (will break when eclipse updates rather easily), and who knows how many fields
			// and things need to be initialized.
			// A better plan would be to start an actual, real eclipse, by telling `EclipseStarter.startup` to launch some sort of
			// application (or at least a bunch of bundles/products/apps, including the JDT). This will then take long enough that
			// it'll need to be cached and re-used for each test or the Eclipse test run would take far too long.
			
			BundleContext context = EclipseStarter.startup(new String[0], null);
			RegistryFactory.setDefaultRegistryProvider(new IRegistryProvider() {
				private final ExtensionRegistry REG = new ExtensionRegistry(null, null, null);
				@Override public IExtensionRegistry getRegistry() {
					return REG;
				}
			});
			new Activator().start(context);
			new PlatformActivator().start(context);
			for (Bundle b : context.getBundles()) System.out.println(""BUNDLE: "" + b.getSymbolicName());
			new ResourcesPlugin().start(context);
			JavaModelManager.getJavaModelManager().startup();
		}
	}
	
	static boolean eclipseAvailable() {
		try {
			Class.forName(""org.eclipse.jdt.core.dom.CompilationUnit"");
		} catch (Throwable t) {
			return false;
		}
		
		return true;
	}
	
	private static final String bootRuntimePath = System.getProperty(""delombok.bootclasspath"");
	
	private static class EclipseDomConversion {
		static CompilationUnit toDomAst(CompilationUnitDeclaration cud, final char[] source) {
			Map<String, String> options = new HashMap<String, String>();
			options.put(JavaCore.COMPILER_SOURCE, ""11"");
			options.put(""org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures"", ""enabled"");
			
			org.eclipse.jdt.internal.core.CompilationUnit ccu = new org.eclipse.jdt.internal.core.CompilationUnit(null, null, null) {
				@Override public char[] getContents() {
					return source;
				}
			};
			return AST.convertCompilationUnit(4, cud, options, false, ccu, 0, null);
		}
	}
	
	private FileSystem createFileSystem(File file, int minVersion) {
		List<String> classpath = new ArrayList<String>();
		for (Iterator<String> i = classpath.iterator(); i.hasNext();) {
			if (FileSystem.getClasspath(i.next(), ""UTF-8"", null) == null) {
				i.remove();
			}
		}
		if (new File(""bin/main"").exists()) classpath.add(""bin/main"");
		classpath.add(""dist/lombok.jar"");
		classpath.add(""build/teststubs"");
		if (bootRuntimePath == null || bootRuntimePath.isEmpty()) throw new IllegalStateException(""System property delombok.bootclasspath is not set; set it to the rt of java6 or java8"");
		classpath.add(bootRuntimePath);
		for (File f : new File(""lib/test"").listFiles()) {
			String fn = f.getName();
			if (fn.length() < 4) continue;
			if (!fn.substring(fn.length() - 4).toLowerCase().equals("".jar"")) continue;
			classpath.add(""lib/test/"" + fn);
		}
		return new FileSystem(classpath.toArray(new String[0]), new String[] {file.getAbsolutePath()}, ""UTF-8"");
	}
	
	private static final class TestCompilationUnitEcj implements ICompilationUnit {
		private final char[] name, source, mainTypeName;
		
		TestCompilationUnitEcj(String name, String source) {
			this.source = source.toCharArray();
			this.name = name.toCharArray();
			
			char[] fileNameCharArray = getFileName();
			int start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;
			int end = CharOperation.lastIndexOf('.', fileNameCharArray);
			if (end == -1) {
				end = fileNameCharArray.length;
			}
			mainTypeName = CharOperation.subarray(fileNameCharArray, start, end);
		}
		
		@Override public char[] getFileName() {
			return name;
		}
		
		@Override public char[] getContents() {
			return source;
		}
		
		@Override public char[] getMainTypeName() {
			return mainTypeName;
		}
		
		@Override public char[][] getPackageName() {
			return null;
		}
	}
	
	private static final class TestCompilationUnitEclipse extends org.eclipse.jdt.internal.core.CompilationUnit {
		private final char[] source;
		private final char[] mainTypeName;
		
		private TestCompilationUnitEclipse(String name, String source) {
			super(null, name, null);
			this.source = source.toCharArray();
			
			char[] fileNameCharArray = getFileName();
			int start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;
			int end = CharOperation.lastIndexOf('.', fileNameCharArray);
			if (end == -1) {
				end = fileNameCharArray.length;
			}
			mainTypeName = CharOperation.subarray(fileNameCharArray, start, end);
		}
		
		@Override public char[] getContents() {
			return source;
		}
		
		@Override public char[] getMainTypeName() {
			return mainTypeName;
		}
		
		@Override public boolean ignoreOptionalProblems() {
			return false;
		}
		
		@Override public char[][] getPackageName() {
			return null;
		}
		
		@Override public char[] getModuleName() {
			return null;
		}
	}
}",1,439 334 2000 378 2001 123 438 2002 2003 40 41 123 2002 2004 61 418 2002 40 41 59 2005 60 2006 44 2006 62 2007 61 418 2008 60 2006 44 2006 62 40 41 59 2006 2009 61 2010 46 2011 40 648 41 59 413 2012 61 2013 46 2014 40 41 59 413 2015 61 2013 46 2016 40 41 59 392 40 2009 631 424 41 123 413 2017 61 2018 46 2019 40 2009 41 59 2012 61 40 2017 43 1503 41 622 1503 59 2015 61 2017 59 125 360 123 621 2007 46 2020 40 648 44 648 41 59 125 2004 46 2021 61 2012 59 2004 46 2022 61 2012 59 2004 46 2023 61 2012 59 2004 46 2024 61 380 59 2004 46 2025 61 473 59 2004 46 2026 61 473 59 2004 46 2027 61 380 59 2004 46 2028 61 380 59 2004 46 2029 61 380 59 2004 46 2030 61 380 59 2004 46 2031 61 380 59 2004 46 2032 61 380 59 2004 46 2033 61 380 59 2004 46 2034 61 380 59 2007 46 2035 40 2002 46 2036 44 648 41 59 2007 46 2035 40 2002 46 2037 44 648 41 59 2007 46 2035 40 2002 46 2038 44 648 41 59 2007 46 2035 40 2002 46 2039 44 648 41 59 2007 46 2035 40 2002 46 2040 44 648 41 59 2007 46 2035 40 2002 46 2041 44 648 41 59 2007 46 2035 40 648 44 648 41 59 2007 46 2035 40 2002 46 2042 44 40 2015 60 1502 63 648 58 648 41 43 2015 41 59 2004 46 2043 40 2007 41 59 450 2004 59 125 438 2044 2045 40 41 123 450 418 2044 40 41 123 439 324 2046 40 41 123 450 380 59 125 439 324 2047 40 41 123 450 380 59 125 64 2048 40 648 41 621 439 324 2049 40 41 123 450 380 59 125 125 59 125 437 2050 2051 40 2052 2053 44 2054 2055 41 123 392 40 2056 40 41 41 450 418 2057 40 2053 46 2058 40 41 44 2055 41 59 450 418 2059 40 2053 46 2058 40 41 44 2055 41 59 125 64 2060 439 324 2061 40 2062 60 2063 62 2064 44 2065 2066 44 2052 2053 44 2054 2067 44 2068 60 2054 44 2054 62 2069 44 404 2070 44 324 2071 41 470 2072 123 381 2073 60 2074 62 2075 61 418 2073 60 2074 62 40 41 59 381 2073 60 2076 62 2077 61 418 2073 60 2076 62 40 41 59 2078 2079 61 418 2078 40 41 123 64 2060 439 492 2080 40 2074 2066 41 123 2075 46 2081 40 2066 41 59 125 125 59 2054 2055 61 2082 40 2053 41 59 330 91 93 2083 61 2055 46 2084 40 41 59 381 2050 2085 59 474 123 2085 61 2051 40 2053 44 2055 41 59 125 329 40 2072 2086 41 123 2086 46 2087 40 41 59 450 380 59 125 2088 2089 61 418 2088 40 2090 40 2053 44 2070 41 44 2045 40 41 44 2003 40 41 44 2079 44 418 2091 40 2092 46 2093 41 41 123 64 2060 438 465 492 2094 40 2050 2095 44 2076 2096 41 123 392 40 2095 614 2085 41 2077 46 2097 40 2096 41 59 463 46 2094 40 2095 44 2096 41 59 125 125 59 621 2089 46 2098 40 418 2050 91 93 123 2085 125 41 59 2074 2099 61 2075 46 2100 40 41 59 2101 91 93 2102 61 2099 46 2103 40 41 59 392 40 2102 631 424 41 385 40 2101 2104 58 2102 41 123 2064 46 2105 40 418 2063 40 2104 46 2106 40 41 44 2104 46 2107 40 41 44 2104 46 2108 40 41 44 2104 46 2109 40 41 41 41 59 125 2076 2110 61 2077 46 2100 40 41 59 392 40 2110 614 424 41 2066 46 2111 40 648 41 59 360 123 2054 2112 61 2110 46 2113 40 41 59 621 2112 61 2112 46 2114 40 648 44 648 41 59 2066 46 2111 40 2112 41 59 125 392 40 2115 40 41 41 123 2116 46 2117 40 2110 44 2083 41 59 125 450 473 59 125 64 2118 40 648 41 437 457 334 2119 123 457 492 2120 40 41 470 2121 123 621 621 621 621 621 621 621 621 621 621 621 2122 2123 61 2124 46 2125 40 418 2054 91 1500 93 44 424 41 59 2126 46 2127 40 418 2128 40 41 123 437 381 2129 2130 61 418 2129 40 424 44 424 44 424 41 59 64 2060 439 2131 2132 40 41 123 450 2130 59 125 125 41 59 418 2133 40 41 46 2134 40 2123 41 59 418 2135 40 41 46 2134 40 2123 41 59 385 40 2136 2137 58 2123 46 2138 40 41 41 2139 46 430 46 2140 40 648 43 2137 46 2141 40 41 41 59 418 2142 40 41 46 2134 40 2123 41 59 2143 46 2144 40 41 46 2125 40 41 59 125 125 457 324 2145 40 41 123 474 123 2146 46 2147 40 648 41 59 125 329 40 2072 2148 41 123 450 380 59 125 450 473 59 125 437 457 381 2054 2149 61 2150 46 2151 40 648 41 59 437 457 334 2152 123 457 2153 2154 40 2155 2156 44 381 330 91 93 2055 41 123 2068 60 2054 44 2054 62 2157 61 418 2158 60 2054 44 2054 62 40 41 59 2157 46 2159 40 2160 46 2161 44 648 41 59 2157 46 2159 40 648 44 648 41 59 2162 46 2163 46 2164 46 406 46 2165 46 2153 2166 61 418 2162 46 2163 46 2164 46 406 46 2165 46 2153 40 424 44 424 44 424 41 123 64 2060 439 330 91 93 2167 40 41 123 450 2055 59 125 125 59 450 2168 46 2169 40 1502 44 2156 44 2157 44 380 44 2166 44 1500 44 424 41 59 125 125 437 2170 2171 40 2052 2053 44 404 2070 41 123 2172 60 2054 62 2173 61 418 2174 60 2054 62 40 41 59 385 40 2175 60 2054 62 2176 61 2173 46 2177 40 41 59 2176 46 2178 40 41 59 41 123 392 40 2170 46 2179 40 2176 46 2180 40 41 44 648 44 424 41 614 424 41 123 2176 46 2181 40 41 59 125 125 392 40 418 2052 40 648 41 46 2182 40 41 41 2173 46 2183 40 648 41 59 2173 46 2183 40 648 41 59 2173 46 2183 40 648 41 59 392 40 2149 614 424 606 2149 46 2184 40 41 41 469 418 2185 40 648 41 59 2173 46 2183 40 2149 41 59 385 40 2052 2186 58 418 2052 40 648 41 46 2187 40 41 41 123 2054 2188 61 2186 46 2189 40 41 59 392 40 2188 46 2190 40 41 60 1502 41 344 59 392 40 33 2188 46 2191 40 2188 46 2190 40 41 45 1502 41 46 2192 40 41 46 2193 40 648 41 41 344 59 2173 46 2183 40 648 43 2188 41 59 125 450 418 2170 40 2173 46 2194 40 418 2054 91 1500 93 41 44 418 2054 91 93 123 2053 46 2195 40 41 125 44 648 41 59 125 437 457 381 334 2196 395 2050 123 437 381 330 91 93 2197 44 2055 44 2198 59 2196 40 2054 2197 44 2054 2055 41 123 467 46 2055 61 2055 46 2199 40 41 59 467 46 2197 61 2197 46 2199 40 41 59 330 91 93 2200 61 2201 40 41 59 404 2202 61 2203 46 2204 40 2052 46 2205 44 2200 41 43 1501 59 404 2206 61 2203 46 2204 40 607 44 2200 41 59 392 40 2206 614 45 1501 41 123 2206 61 2200 46 2207 59 125 2198 61 2203 46 2208 40 2200 44 2202 44 2206 41 59 125 64 2060 439 330 91 93 2209 40 41 123 450 2197 59 125 64 2060 439 330 91 93 2210 40 41 123 450 2055 59 125 64 2060 439 330 91 93 2211 40 41 123 450 2198 59 125 64 2060 439 330 91 93 91 93 2212 40 41 123 450 424 59 125 125 437 457 381 334 2213 378 2214 46 2215 46 2216 46 406 46 2217 46 2218 123 437 381 330 91 93 2055 59 437 381 330 91 93 2219 59 437 2213 40 2054 2220 44 2054 2055 41 123 463 40 424 44 2220 44 424 41 59 467 46 2055 61 2055 46 2221 40 41 59 330 91 93 2222 61 2223 40 41 59 404 2224 61 2225 46 2226 40 2052 46 2227 44 2222 41 43 1501 59 404 2228 61 2225 46 2226 40 607 44 2222 41 59 392 40 2228 614 45 1501 41 123 2228 61 2222 46 2229 59 125 2219 61 2225 46 2230 40 2222 44 2224 44 2228 41 59 125 64 2060 439 330 91 93 2231 40 41 123 450 2055 59 125 64 2060 439 330 91 93 2232 40 41 123 450 2219 59 125 64 2060 439 324 2233 40 41 123 450 380 59 125 64 2060 439 330 91 93 91 93 2234 40 41 123 450 424 59 125 64 2060 439 330 91 93 2235 40 41 123 450 424 59 125 125 125 
3192,Java,"@FxmlView
public class AltCoinAccountsView extends PaymentAccountsView<GridPane, AltCoinAccountsViewModel> {

    private final InputValidator inputValidator;
    private final AltCoinAddressValidator altCoinAddressValidator;
    private final AssetService assetService;
    private final FilterManager filterManager;
    private final CoinFormatter formatter;
    private final Preferences preferences;

    private PaymentMethodForm paymentMethodForm;
    private TitledGroupBg accountTitledGroupBg;
    private Button saveNewAccountButton;
    private int gridRow = 0;

    @Inject
    public AltCoinAccountsView(AltCoinAccountsViewModel model,
                               InputValidator inputValidator,
                               AltCoinAddressValidator altCoinAddressValidator,
                               AccountAgeWitnessService accountAgeWitnessService,
                               AssetService assetService,
                               FilterManager filterManager,
                               @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter formatter,
                               Preferences preferences) {
        super(model, accountAgeWitnessService);

        this.inputValidator = inputValidator;
        this.altCoinAddressValidator = altCoinAddressValidator;
        this.assetService = assetService;
        this.filterManager = filterManager;
        this.formatter = formatter;
        this.preferences = preferences;
    }

    @Override
    protected ObservableList<PaymentAccount> getPaymentAccounts() {
        return model.getPaymentAccounts();
    }

    @Override
    protected void importAccounts() {
        model.dataModel.importAccounts((Stage) root.getScene().getWindow());
    }

    @Override
    protected void exportAccounts() {
        model.dataModel.exportAccounts((Stage) root.getScene().getWindow());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // UI actions
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onSaveNewAccount(PaymentAccount paymentAccount) {
        TradeCurrency selectedTradeCurrency = paymentAccount.getSelectedTradeCurrency();
        if (selectedTradeCurrency != null) {
            if (selectedTradeCurrency instanceof CryptoCurrency && ((CryptoCurrency) selectedTradeCurrency).isAsset()) {
                String name = selectedTradeCurrency.getName();
                new Popup().information(Res.get(""account.altcoin.popup.wallet.msg"",
                        selectedTradeCurrency.getCodeAndName(),
                        name,
                        name))
                        .closeButtonText(Res.get(""account.altcoin.popup.wallet.confirm""))
                        .show();
            }

            final Optional<Asset> asset = CurrencyUtil.findAsset(selectedTradeCurrency.getCode());
            if (asset.isPresent()) {
                final AltCoinAccountDisclaimer disclaimerAnnotation = asset.get().getClass().getAnnotation(AltCoinAccountDisclaimer.class);
                if (disclaimerAnnotation != null) {
                    new Popup()
                            .width(asset.get() instanceof Monero ? 1000 : 669)
                            .maxMessageLength(2500)
                            .information(Res.get(disclaimerAnnotation.value()))
                            .useIUnderstandButton()
                            .show();
                }
            }

            if (model.getPaymentAccounts().stream().noneMatch(e -> e.getAccountName() != null &&
                    e.getAccountName().equals(paymentAccount.getAccountName()))) {
                model.onSaveNewAccount(paymentAccount);
                removeNewAccountForm();
            } else {
                new Popup().warning(Res.get(""shared.accountNameAlreadyUsed"")).show();
            }

            preferences.dontShowAgain(INSTANT_TRADE_NEWS, true);
        }
    }

    private void onCancelNewAccount() {
        removeNewAccountForm();

        preferences.dontShowAgain(INSTANT_TRADE_NEWS, true);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Base form
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected void buildForm() {
        addTitledGroupBg(root, gridRow, 2, Res.get(""shared.manageAccounts""));

        Tuple3<Label, ListView<PaymentAccount>, VBox> tuple = addTopLabelListView(root, gridRow, Res.get(""account.altcoin.yourAltcoinAccounts""), Layout.FIRST_ROW_DISTANCE);
        paymentAccountsListView = tuple.second;
        int prefNumRows = Math.min(4, Math.max(2, model.dataModel.getNumPaymentAccounts()));
        paymentAccountsListView.setMinHeight(prefNumRows * Layout.LIST_ROW_HEIGHT + 28);
        setPaymentAccountsCellFactory();

        Tuple3<Button, Button, Button> tuple3 = add3ButtonsAfterGroup(root, ++gridRow, Res.get(""shared.addNewAccount""),
                Res.get(""shared.ExportAccounts""), Res.get(""shared.importAccounts""));
        addAccountButton = tuple3.first;
        exportButton = tuple3.second;
        importButton = tuple3.third;
    }

    // Add new account form
    protected void addNewAccount() {
        paymentAccountsListView.getSelectionModel().clearSelection();
        removeAccountRows();
        addAccountButton.setDisable(true);
        accountTitledGroupBg = addTitledGroupBg(root, ++gridRow, 1, Res.get(""shared.createNewAccount""), Layout.GROUP_DISTANCE);

        if (paymentMethodForm != null) {
            FormBuilder.removeRowsFromGridPane(root, 3, paymentMethodForm.getGridRow() + 1);
            GridPane.setRowSpan(accountTitledGroupBg, paymentMethodForm.getRowSpan() + 1);
        }
        gridRow = 2;
        paymentMethodForm = getPaymentMethodForm(PaymentMethod.BLOCK_CHAINS);
        paymentMethodForm.addFormForAddAccount();
        gridRow = paymentMethodForm.getGridRow();
        Tuple2<Button, Button> tuple2 = add2ButtonsAfterGroup(root, ++gridRow, Res.get(""shared.saveNewAccount""), Res.get(""shared.cancel""));
        saveNewAccountButton = tuple2.first;
        saveNewAccountButton.setOnAction(event -> onSaveNewAccount(paymentMethodForm.getPaymentAccount()));
        saveNewAccountButton.disableProperty().bind(paymentMethodForm.allInputsValidProperty().not());
        Button cancelButton = tuple2.second;
        cancelButton.setOnAction(event -> onCancelNewAccount());
        GridPane.setRowSpan(accountTitledGroupBg, paymentMethodForm.getRowSpan() + 1);
    }

    // Select account form
    protected void onSelectAccount(PaymentAccount paymentAccount) {
        removeAccountRows();
        addAccountButton.setDisable(false);
        accountTitledGroupBg = addTitledGroupBg(root, ++gridRow, 2, Res.get(""shared.selectedAccount""), Layout.GROUP_DISTANCE);
        paymentMethodForm = getPaymentMethodForm(paymentAccount);
        paymentMethodForm.addFormForDisplayAccount();
        gridRow = paymentMethodForm.getGridRow();
        Tuple2<Button, Button> tuple = add2ButtonsAfterGroup(root, ++gridRow, Res.get(""shared.deleteAccount""), Res.get(""shared.cancel""));
        Button deleteAccountButton = tuple.first;
        deleteAccountButton.setOnAction(event -> onDeleteAccount(paymentAccount));
        Button cancelButton = tuple.second;
        cancelButton.setOnAction(event -> removeSelectAccountForm());
        GridPane.setRowSpan(accountTitledGroupBg, paymentMethodForm.getRowSpan());
        model.onSelectAccount(paymentAccount);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////////////////////////////////////////

    private PaymentMethodForm getPaymentMethodForm(PaymentMethod paymentMethod) {
        PaymentAccount paymentAccount = PaymentAccountFactory.getPaymentAccount(paymentMethod);
        paymentAccount.init();
        return getPaymentMethodForm(paymentAccount);
    }

    private PaymentMethodForm getPaymentMethodForm(PaymentAccount paymentAccount) {
        return new AssetsForm(paymentAccount, accountAgeWitnessService, altCoinAddressValidator,
                inputValidator, root, gridRow, formatter, assetService, filterManager);
    }

    private void removeNewAccountForm() {
        saveNewAccountButton.disableProperty().unbind();
        removeAccountRows();
        addAccountButton.setDisable(false);
    }

    @Override
    protected void removeSelectAccountForm() {
        FormBuilder.removeRowsFromGridPane(root, 2, gridRow);
        gridRow = 1;
        addAccountButton.setDisable(false);
        paymentAccountsListView.getSelectionModel().clearSelection();
    }

    @Override
    protected boolean deleteAccountFromModel(PaymentAccount paymentAccount) {
        return model.onDeleteAccount(paymentAccount);
    }

    private void removeAccountRows() {
        FormBuilder.removeRowsFromGridPane(root, 2, gridRow);
        gridRow = 1;
    }
}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 123 437 381 2005 2006 59 437 381 2007 2008 59 437 381 2009 2010 59 437 381 2011 2012 59 437 381 2013 2014 59 437 381 2015 2016 59 437 2017 2018 59 437 2019 2020 59 437 2021 2022 59 437 404 2023 61 1500 59 64 2024 439 2001 40 2004 2025 44 2005 2006 44 2007 2008 44 2026 2027 44 2009 2010 44 2011 2012 44 64 2028 40 2029 46 2030 41 2013 2014 44 2015 2016 41 123 463 40 2025 44 2027 41 59 467 46 2006 61 2006 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 467 46 2012 61 2012 59 467 46 2014 61 2014 59 467 46 2016 61 2016 59 125 64 2031 438 2032 60 2033 62 2034 40 41 123 450 2025 46 2034 40 41 59 125 64 2031 438 492 2035 40 41 123 2025 46 2036 46 2035 40 40 2037 41 2038 46 2039 40 41 46 2040 40 41 41 59 125 64 2031 438 492 2041 40 41 123 2025 46 2042 46 2041 40 40 2043 41 2044 46 2045 40 41 46 2046 40 41 41 59 125 621 621 621 437 492 2047 40 2033 2048 41 123 2049 2050 61 2048 46 2051 40 41 59 392 40 2050 631 424 41 123 392 40 2050 402 2052 605 40 40 2052 41 2050 41 46 2053 40 41 41 123 2054 2055 61 2050 46 2056 40 41 59 418 2057 40 41 46 2058 40 2059 46 2060 40 648 44 2050 46 2061 40 41 44 2055 44 2055 41 41 46 2062 40 2059 46 2060 40 648 41 41 46 2063 40 41 59 125 381 2064 60 2065 62 2066 61 2067 46 2068 40 2050 46 2069 40 41 41 59 392 40 2066 46 2070 40 41 41 123 381 2071 2072 61 2066 46 2073 40 41 46 2074 40 41 46 2075 40 2071 46 334 41 59 392 40 2072 631 424 41 123 418 2076 40 41 46 2077 40 2066 46 2073 40 41 402 2078 63 1504 58 1504 41 46 2079 40 1505 41 46 2080 40 2081 46 2073 40 2072 46 2082 40 41 41 41 46 2083 40 41 46 2084 40 41 59 125 125 392 40 2025 46 2034 40 41 46 2085 40 41 46 2086 40 2087 45 62 2087 46 2088 40 41 631 424 605 2087 46 2088 40 41 46 2089 40 2048 46 2088 40 41 41 41 41 123 2025 46 2047 40 2048 41 59 2090 40 41 59 125 360 123 418 2091 40 41 46 494 40 2092 46 2093 40 648 41 41 46 2094 40 41 59 125 2016 46 2095 40 2096 44 473 41 59 125 125 437 492 2097 40 41 123 2098 40 41 59 2016 46 2099 40 2100 44 473 41 59 125 621 621 621 438 492 2101 40 41 123 2102 40 2103 44 2023 44 1502 44 2104 46 2105 40 648 41 41 59 2106 60 2107 44 2108 60 2033 62 44 2109 62 2110 61 2111 40 2103 44 2023 44 2104 46 2105 40 648 41 44 2112 46 2113 41 59 2114 61 2110 46 2115 59 404 2116 61 2117 46 2118 40 1502 44 2117 46 2119 40 1502 44 2025 46 2120 46 2121 40 41 41 41 59 2114 46 2122 40 2116 42 2112 46 2123 43 1503 41 59 2124 40 41 59 2106 60 2021 44 2021 44 2021 62 2125 61 2126 40 2103 44 637 2023 44 2104 46 2105 40 648 41 44 2104 46 2105 40 648 41 44 2104 46 2105 40 648 41 41 59 2127 61 2125 46 2128 59 2129 61 2125 46 2115 59 2130 61 2125 46 2131 59 125 621 438 492 2132 40 41 123 2133 46 2134 40 41 46 2135 40 41 59 2136 40 41 59 2137 46 2138 40 473 41 59 2020 61 2139 40 2140 44 637 2023 44 1501 44 2141 46 2142 40 648 41 44 2143 46 2144 41 59 392 40 2018 631 424 41 123 2145 46 2146 40 2140 44 1502 44 2018 46 2147 40 41 43 1501 41 59 2003 46 2148 40 2020 44 2018 46 2149 40 41 43 1501 41 59 125 2023 61 1502 59 2018 61 2150 40 2151 46 2152 41 59 2018 46 2153 40 41 59 2023 61 2018 46 2154 40 41 59 2155 60 2021 44 2021 62 2156 61 2157 40 2140 44 637 2023 44 2141 46 2142 40 648 41 44 2141 46 2142 40 648 41 41 59 2022 61 2156 46 2158 59 2022 46 2159 40 373 45 62 2047 40 2018 46 2160 40 41 41 41 59 2022 46 2161 40 41 46 2162 40 2018 46 2163 40 41 46 422 40 41 41 59 2021 2164 61 2156 46 2165 59 2164 46 2159 40 373 45 62 2097 40 41 41 59 2003 46 2166 40 2020 44 2018 46 2167 40 41 43 1501 41 59 125 621 438 492 2168 40 2033 2048 41 123 2169 40 41 59 2170 46 2171 40 380 41 59 2020 61 2172 40 2173 44 637 2023 44 1502 44 2174 46 2175 40 648 41 44 2176 46 2177 41 59 2018 61 2178 40 2048 41 59 2018 46 2179 40 41 59 2023 61 2018 46 2180 40 41 59 2181 60 2021 44 2021 62 2182 61 2183 40 2173 44 637 2023 44 2174 46 2175 40 648 41 44 2174 46 2175 40 648 41 41 59 2021 2184 61 2182 46 2185 59 2184 46 2186 40 373 45 62 2187 40 2048 41 41 59 2021 2188 61 2182 46 2189 59 2188 46 2186 40 373 45 62 2190 40 41 41 59 2003 46 2191 40 2020 44 2018 46 2192 40 41 41 59 2025 46 2168 40 2048 41 59 125 621 621 621 437 2017 2193 40 2194 2195 41 123 2033 2048 61 2196 46 2197 40 2195 41 59 2048 46 2198 40 41 59 450 2193 40 2048 41 59 125 437 2017 2193 40 2033 2048 41 123 450 418 2199 40 2048 44 2027 44 2008 44 2006 44 2200 44 2023 44 2014 44 2010 44 2012 41 59 125 437 492 2201 40 41 123 2022 46 2202 40 41 46 2203 40 41 59 2204 40 41 59 2205 46 2206 40 380 41 59 125 64 2031 438 492 2207 40 41 123 2208 46 2209 40 2210 44 1502 44 2023 41 59 2023 61 1501 59 2211 46 2212 40 380 41 59 2213 46 2214 40 41 46 2215 40 41 59 125 64 2031 438 324 2216 40 2033 2048 41 123 450 2025 46 2217 40 2048 41 59 125 437 492 2218 40 41 123 2219 46 2220 40 2221 44 1502 44 2023 41 59 2023 61 1501 59 125 125 
17675,Java,"public abstract class DownloadService extends Service {

  /**
   * Starts a download service to resume any ongoing downloads. Extras:
   *
   * <ul>
   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
   * </ul>
   */
  public static final String ACTION_INIT =
      ""com.google.android.exoplayer.downloadService.action.INIT"";

  /** Like {@link #ACTION_INIT}, but with {@link #KEY_FOREGROUND} implicitly set to true. */
  private static final String ACTION_RESTART =
      ""com.google.android.exoplayer.downloadService.action.RESTART"";

  /**
   * Adds a new download. Extras:
   *
   * <ul>
   *   <li>{@link #KEY_DOWNLOAD_REQUEST} - A {@link DownloadRequest} defining the download to be
   *       added.
   *   <li>{@link #KEY_STOP_REASON} - An initial stop reason for the download. If omitted {@link
   *       Download#STOP_REASON_NONE} is used.
   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
   * </ul>
   */
  public static final String ACTION_ADD_DOWNLOAD =
      ""com.google.android.exoplayer.downloadService.action.ADD_DOWNLOAD"";

  /**
   * Removes a download. Extras:
   *
   * <ul>
   *   <li>{@link #KEY_CONTENT_ID} - The content id of a download to remove.
   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
   * </ul>
   */
  public static final String ACTION_REMOVE_DOWNLOAD =
      ""com.google.android.exoplayer.downloadService.action.REMOVE_DOWNLOAD"";

  /**
   * Removes all downloads. Extras:
   *
   * <ul>
   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
   * </ul>
   */
  public static final String ACTION_REMOVE_ALL_DOWNLOADS =
      ""com.google.android.exoplayer.downloadService.action.REMOVE_ALL_DOWNLOADS"";

  /**
   * Resumes all downloads except those that have a non-zero {@link Download#stopReason}. Extras:
   *
   * <ul>
   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
   * </ul>
   */
  public static final String ACTION_RESUME_DOWNLOADS =
      ""com.google.android.exoplayer.downloadService.action.RESUME_DOWNLOADS"";

  /**
   * Pauses all downloads. Extras:
   *
   * <ul>
   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
   * </ul>
   */
  public static final String ACTION_PAUSE_DOWNLOADS =
      ""com.google.android.exoplayer.downloadService.action.PAUSE_DOWNLOADS"";

  /**
   * Sets the stop reason for one or all downloads. To clear the stop reason, pass {@link
   * Download#STOP_REASON_NONE}. Extras:
   *
   * <ul>
   *   <li>{@link #KEY_CONTENT_ID} - The content id of a single download to update with the stop
   *       reason. If omitted, all downloads will be updated.
   *   <li>{@link #KEY_STOP_REASON} - An application provided reason for stopping the download or
   *       downloads, or {@link Download#STOP_REASON_NONE} to clear the stop reason.
   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
   * </ul>
   */
  public static final String ACTION_SET_STOP_REASON =
      ""com.google.android.exoplayer.downloadService.action.SET_STOP_REASON"";

  /**
   * Sets the requirements that need to be met for downloads to progress. Extras:
   *
   * <ul>
   *   <li>{@link #KEY_REQUIREMENTS} - A {@link Requirements}.
   *   <li>{@link #KEY_FOREGROUND} - See {@link #KEY_FOREGROUND}.
   * </ul>
   */
  public static final String ACTION_SET_REQUIREMENTS =
      ""com.google.android.exoplayer.downloadService.action.SET_REQUIREMENTS"";

  /** Key for the {@link DownloadRequest} in {@link #ACTION_ADD_DOWNLOAD} intents. */
  public static final String KEY_DOWNLOAD_REQUEST = ""download_request"";

  /**
   * Key for the {@link String} content id in {@link #ACTION_SET_STOP_REASON} and {@link
   * #ACTION_REMOVE_DOWNLOAD} intents.
   */
  public static final String KEY_CONTENT_ID = ""content_id"";

  /**
   * Key for the integer stop reason in {@link #ACTION_SET_STOP_REASON} and {@link
   * #ACTION_ADD_DOWNLOAD} intents.
   */
  public static final String KEY_STOP_REASON = ""stop_reason"";

  /** Key for the {@link Requirements} in {@link #ACTION_SET_REQUIREMENTS} intents. */
  public static final String KEY_REQUIREMENTS = ""requirements"";

  /**
   * Key for a boolean extra that can be set on any intent to indicate whether the service was
   * started in the foreground. If set, the service is guaranteed to call {@link
   * #startForeground(int, Notification)}.
   */
  public static final String KEY_FOREGROUND = ""foreground"";

  /** Invalid foreground notification id that can be used to run the service in the background. */
  public static final int FOREGROUND_NOTIFICATION_ID_NONE = 0;

  /** Default foreground notification update interval in milliseconds. */
  public static final long DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL = 1000;

  private static final String TAG = ""DownloadService"";

  // Keep a DownloadManagerHelper for each DownloadService as long as the process is running. The
  // helper is needed to restart the DownloadService when there's no scheduler. Even when there is a
  // scheduler, the DownloadManagerHelper is typically able to restart the DownloadService faster.
  private static final HashMap<Class<? extends DownloadService>, DownloadManagerHelper>
      downloadManagerHelpers = new HashMap<>();

  @Nullable private final ForegroundNotificationUpdater foregroundNotificationUpdater;
  @Nullable private final String channelId;
  @StringRes private final int channelNameResourceId;
  @StringRes private final int channelDescriptionResourceId;

  private @MonotonicNonNull DownloadManagerHelper downloadManagerHelper;
  private int lastStartId;
  private boolean startedInForeground;
  private boolean taskRemoved;
  private boolean isStopped;
  private boolean isDestroyed;

  /**
   * Creates a DownloadService.
   *
   * <p>If {@code foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE} then the
   * service will only ever run in the background, and no foreground notification will be displayed.
   *
   * <p>If {@code foregroundNotificationId} is not {@link #FOREGROUND_NOTIFICATION_ID_NONE} then the
   * service will run in the foreground. The foreground notification will be updated at least as
   * often as the interval specified by {@link #DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL}.
   *
   * @param foregroundNotificationId The notification id for the foreground notification, or {@link
   *     #FOREGROUND_NOTIFICATION_ID_NONE} if the service should only ever run in the background.
   */
  protected DownloadService(int foregroundNotificationId) {
    this(foregroundNotificationId, DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL);
  }

  /**
   * Creates a DownloadService.
   *
   * @param foregroundNotificationId The notification id for the foreground notification, or {@link
   *     #FOREGROUND_NOTIFICATION_ID_NONE} if the service should only ever run in the background.
   * @param foregroundNotificationUpdateInterval The maximum interval between updates to the
   *     foreground notification, in milliseconds. Ignored if {@code foregroundNotificationId} is
   *     {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
   */
  protected DownloadService(
      int foregroundNotificationId, long foregroundNotificationUpdateInterval) {
    this(
        foregroundNotificationId,
        foregroundNotificationUpdateInterval,
        /* channelId= */ null,
        /* channelNameResourceId= */ 0,
        /* channelDescriptionResourceId= */ 0);
  }

  /** @deprecated Use {@link #DownloadService(int, long, String, int, int)}. */
  @Deprecated
  protected DownloadService(
      int foregroundNotificationId,
      long foregroundNotificationUpdateInterval,
      @Nullable String channelId,
      @StringRes int channelNameResourceId) {
    this(
        foregroundNotificationId,
        foregroundNotificationUpdateInterval,
        channelId,
        channelNameResourceId,
        /* channelDescriptionResourceId= */ 0);
  }

  /**
   * Creates a DownloadService.
   *
   * @param foregroundNotificationId The notification id for the foreground notification, or {@link
   *     #FOREGROUND_NOTIFICATION_ID_NONE} if the service should only ever run in the background.
   * @param foregroundNotificationUpdateInterval The maximum interval between updates to the
   *     foreground notification, in milliseconds. Ignored if {@code foregroundNotificationId} is
   *     {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
   * @param channelId An id for a low priority notification channel to create, or {@code null} if
   *     the app will take care of creating a notification channel if needed. If specified, must be
   *     unique per package. The value may be truncated if it's too long. Ignored if {@code
   *     foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
   * @param channelNameResourceId A string resource identifier for the user visible name of the
   *     notification channel. The recommended maximum length is 40 characters. The value may be
   *     truncated if it's too long. Ignored if {@code channelId} is null or if {@code
   *     foregroundNotificationId} is {@link #FOREGROUND_NOTIFICATION_ID_NONE}.
   * @param channelDescriptionResourceId A string resource identifier for the user visible
   *     description of the notification channel, or 0 if no description is provided. The
   *     recommended maximum length is 300 characters. The value may be truncated if it is too long.
   *     Ignored if {@code channelId} is null or if {@code foregroundNotificationId} is {@link
   *     #FOREGROUND_NOTIFICATION_ID_NONE}.
   */
  protected DownloadService(
      int foregroundNotificationId,
      long foregroundNotificationUpdateInterval,
      @Nullable String channelId,
      @StringRes int channelNameResourceId,
      @StringRes int channelDescriptionResourceId) {
    if (foregroundNotificationId == FOREGROUND_NOTIFICATION_ID_NONE) {
      this.foregroundNotificationUpdater = null;
      this.channelId = null;
      this.channelNameResourceId = 0;
      this.channelDescriptionResourceId = 0;
    } else {
      this.foregroundNotificationUpdater =
          new ForegroundNotificationUpdater(
              foregroundNotificationId, foregroundNotificationUpdateInterval);
      this.channelId = channelId;
      this.channelNameResourceId = channelNameResourceId;
      this.channelDescriptionResourceId = channelDescriptionResourceId;
    }
  }

  /**
   * Builds an {@link Intent} for adding a new download.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service being targeted by the intent.
   * @param downloadRequest The request to be executed.
   * @param foreground Whether this intent will be used to start the service in the foreground.
   * @return The created intent.
   */
  public static Intent buildAddDownloadIntent(
      Context context,
      Class<? extends DownloadService> clazz,
      DownloadRequest downloadRequest,
      boolean foreground) {
    return buildAddDownloadIntent(context, clazz, downloadRequest, STOP_REASON_NONE, foreground);
  }

  /**
   * Builds an {@link Intent} for adding a new download.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service being targeted by the intent.
   * @param downloadRequest The request to be executed.
   * @param stopReason An initial stop reason for the download, or {@link Download#STOP_REASON_NONE}
   *     if the download should be started.
   * @param foreground Whether this intent will be used to start the service in the foreground.
   * @return The created intent.
   */
  public static Intent buildAddDownloadIntent(
      Context context,
      Class<? extends DownloadService> clazz,
      DownloadRequest downloadRequest,
      int stopReason,
      boolean foreground) {
    return getIntent(context, clazz, ACTION_ADD_DOWNLOAD, foreground)
        .putExtra(KEY_DOWNLOAD_REQUEST, downloadRequest)
        .putExtra(KEY_STOP_REASON, stopReason);
  }

  /**
   * Builds an {@link Intent} for removing the download with the {@code id}.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service being targeted by the intent.
   * @param id The content id.
   * @param foreground Whether this intent will be used to start the service in the foreground.
   * @return The created intent.
   */
  public static Intent buildRemoveDownloadIntent(
      Context context, Class<? extends DownloadService> clazz, String id, boolean foreground) {
    return getIntent(context, clazz, ACTION_REMOVE_DOWNLOAD, foreground)
        .putExtra(KEY_CONTENT_ID, id);
  }

  /**
   * Builds an {@link Intent} for removing all downloads.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service being targeted by the intent.
   * @param foreground Whether this intent will be used to start the service in the foreground.
   * @return The created intent.
   */
  public static Intent buildRemoveAllDownloadsIntent(
      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
    return getIntent(context, clazz, ACTION_REMOVE_ALL_DOWNLOADS, foreground);
  }

  /**
   * Builds an {@link Intent} for resuming all downloads.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service being targeted by the intent.
   * @param foreground Whether this intent will be used to start the service in the foreground.
   * @return The created intent.
   */
  public static Intent buildResumeDownloadsIntent(
      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
    return getIntent(context, clazz, ACTION_RESUME_DOWNLOADS, foreground);
  }

  /**
   * Builds an {@link Intent} to pause all downloads.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service being targeted by the intent.
   * @param foreground Whether this intent will be used to start the service in the foreground.
   * @return The created intent.
   */
  public static Intent buildPauseDownloadsIntent(
      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
    return getIntent(context, clazz, ACTION_PAUSE_DOWNLOADS, foreground);
  }

  /**
   * Builds an {@link Intent} for setting the stop reason for one or all downloads. To clear the
   * stop reason, pass {@link Download#STOP_REASON_NONE}.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service being targeted by the intent.
   * @param id The content id, or {@code null} to set the stop reason for all downloads.
   * @param stopReason An application defined stop reason.
   * @param foreground Whether this intent will be used to start the service in the foreground.
   * @return The created intent.
   */
  public static Intent buildSetStopReasonIntent(
      Context context,
      Class<? extends DownloadService> clazz,
      @Nullable String id,
      int stopReason,
      boolean foreground) {
    return getIntent(context, clazz, ACTION_SET_STOP_REASON, foreground)
        .putExtra(KEY_CONTENT_ID, id)
        .putExtra(KEY_STOP_REASON, stopReason);
  }

  /**
   * Builds an {@link Intent} for setting the requirements that need to be met for downloads to
   * progress.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service being targeted by the intent.
   * @param requirements A {@link Requirements}.
   * @param foreground Whether this intent will be used to start the service in the foreground.
   * @return The created intent.
   */
  public static Intent buildSetRequirementsIntent(
      Context context,
      Class<? extends DownloadService> clazz,
      Requirements requirements,
      boolean foreground) {
    return getIntent(context, clazz, ACTION_SET_REQUIREMENTS, foreground)
        .putExtra(KEY_REQUIREMENTS, requirements);
  }

  /**
   * Starts the service if not started already and adds a new download.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @param downloadRequest The request to be executed.
   * @param foreground Whether the service is started in the foreground.
   */
  public static void sendAddDownload(
      Context context,
      Class<? extends DownloadService> clazz,
      DownloadRequest downloadRequest,
      boolean foreground) {
    Intent intent = buildAddDownloadIntent(context, clazz, downloadRequest, foreground);
    startService(context, intent, foreground);
  }

  /**
   * Starts the service if not started already and adds a new download.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @param downloadRequest The request to be executed.
   * @param stopReason An initial stop reason for the download, or {@link Download#STOP_REASON_NONE}
   *     if the download should be started.
   * @param foreground Whether the service is started in the foreground.
   */
  public static void sendAddDownload(
      Context context,
      Class<? extends DownloadService> clazz,
      DownloadRequest downloadRequest,
      int stopReason,
      boolean foreground) {
    Intent intent = buildAddDownloadIntent(context, clazz, downloadRequest, stopReason, foreground);
    startService(context, intent, foreground);
  }

  /**
   * Starts the service if not started already and removes a download.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @param id The content id.
   * @param foreground Whether the service is started in the foreground.
   */
  public static void sendRemoveDownload(
      Context context, Class<? extends DownloadService> clazz, String id, boolean foreground) {
    Intent intent = buildRemoveDownloadIntent(context, clazz, id, foreground);
    startService(context, intent, foreground);
  }

  /**
   * Starts the service if not started already and removes all downloads.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @param foreground Whether the service is started in the foreground.
   */
  public static void sendRemoveAllDownloads(
      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
    Intent intent = buildRemoveAllDownloadsIntent(context, clazz, foreground);
    startService(context, intent, foreground);
  }

  /**
   * Starts the service if not started already and resumes all downloads.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @param foreground Whether the service is started in the foreground.
   */
  public static void sendResumeDownloads(
      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
    Intent intent = buildResumeDownloadsIntent(context, clazz, foreground);
    startService(context, intent, foreground);
  }

  /**
   * Starts the service if not started already and pauses all downloads.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @param foreground Whether the service is started in the foreground.
   */
  public static void sendPauseDownloads(
      Context context, Class<? extends DownloadService> clazz, boolean foreground) {
    Intent intent = buildPauseDownloadsIntent(context, clazz, foreground);
    startService(context, intent, foreground);
  }

  /**
   * Starts the service if not started already and sets the stop reason for one or all downloads. To
   * clear stop reason, pass {@link Download#STOP_REASON_NONE}.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @param id The content id, or {@code null} to set the stop reason for all downloads.
   * @param stopReason An application defined stop reason.
   * @param foreground Whether the service is started in the foreground.
   */
  public static void sendSetStopReason(
      Context context,
      Class<? extends DownloadService> clazz,
      @Nullable String id,
      int stopReason,
      boolean foreground) {
    Intent intent = buildSetStopReasonIntent(context, clazz, id, stopReason, foreground);
    startService(context, intent, foreground);
  }

  /**
   * Starts the service if not started already and sets the requirements that need to be met for
   * downloads to progress.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @param requirements A {@link Requirements}.
   * @param foreground Whether the service is started in the foreground.
   */
  public static void sendSetRequirements(
      Context context,
      Class<? extends DownloadService> clazz,
      Requirements requirements,
      boolean foreground) {
    Intent intent = buildSetRequirementsIntent(context, clazz, requirements, foreground);
    startService(context, intent, foreground);
  }

  /**
   * Starts a download service to resume any ongoing downloads.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @see #startForeground(Context, Class)
   */
  public static void start(Context context, Class<? extends DownloadService> clazz) {
    context.startService(getIntent(context, clazz, ACTION_INIT));
  }

  /**
   * Starts the service in the foreground without adding a new download request. If there are any
   * not finished downloads and the requirements are met, the service resumes downloading. Otherwise
   * it stops immediately.
   *
   * @param context A {@link Context}.
   * @param clazz The concrete download service to be started.
   * @see #start(Context, Class)
   */
  public static void startForeground(Context context, Class<? extends DownloadService> clazz) {
    Intent intent = getIntent(context, clazz, ACTION_INIT, true);
    Util.startForegroundService(context, intent);
  }

  @Override
  public void onCreate() {
    if (channelId != null) {
      NotificationUtil.createNotificationChannel(
          this,
          channelId,
          channelNameResourceId,
          channelDescriptionResourceId,
          NotificationUtil.IMPORTANCE_LOW);
    }
    Class<? extends DownloadService> clazz = getClass();
    @Nullable DownloadManagerHelper downloadManagerHelper = downloadManagerHelpers.get(clazz);
    if (downloadManagerHelper == null) {
      boolean foregroundAllowed = foregroundNotificationUpdater != null;
      // See https://developer.android.com/about/versions/12/foreground-services.
      boolean canStartForegroundServiceFromBackground = Util.SDK_INT < 31;
      @Nullable
      Scheduler scheduler =
          foregroundAllowed && canStartForegroundServiceFromBackground ? getScheduler() : null;
      DownloadManager downloadManager = getDownloadManager();
      downloadManager.resumeDownloads();
      downloadManagerHelper =
          new DownloadManagerHelper(
              getApplicationContext(), downloadManager, foregroundAllowed, scheduler, clazz);
      downloadManagerHelpers.put(clazz, downloadManagerHelper);
    }
    this.downloadManagerHelper = downloadManagerHelper;
    downloadManagerHelper.attachService(this);
  }

  @Override
  public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
    lastStartId = startId;
    taskRemoved = false;
    @Nullable String intentAction = null;
    @Nullable String contentId = null;
    if (intent != null) {
      intentAction = intent.getAction();
      contentId = intent.getStringExtra(KEY_CONTENT_ID);
      startedInForeground |=
          intent.getBooleanExtra(KEY_FOREGROUND, false) || ACTION_RESTART.equals(intentAction);
    }
    // intentAction is null if the service is restarted or no action is specified.
    if (intentAction == null) {
      intentAction = ACTION_INIT;
    }
    DownloadManager downloadManager =
        Assertions.checkNotNull(downloadManagerHelper).downloadManager;
    switch (intentAction) {
      case ACTION_INIT:
      case ACTION_RESTART:
        // Do nothing.
        break;
      case ACTION_ADD_DOWNLOAD:
        @Nullable
        DownloadRequest downloadRequest =
            Assertions.checkNotNull(intent).getParcelableExtra(KEY_DOWNLOAD_REQUEST);
        if (downloadRequest == null) {
          Log.e(TAG, ""Ignored ADD_DOWNLOAD: Missing "" + KEY_DOWNLOAD_REQUEST + "" extra"");
        } else {
          int stopReason = intent.getIntExtra(KEY_STOP_REASON, Download.STOP_REASON_NONE);
          downloadManager.addDownload(downloadRequest, stopReason);
        }
        break;
      case ACTION_REMOVE_DOWNLOAD:
        if (contentId == null) {
          Log.e(TAG, ""Ignored REMOVE_DOWNLOAD: Missing "" + KEY_CONTENT_ID + "" extra"");
        } else {
          downloadManager.removeDownload(contentId);
        }
        break;
      case ACTION_REMOVE_ALL_DOWNLOADS:
        downloadManager.removeAllDownloads();
        break;
      case ACTION_RESUME_DOWNLOADS:
        downloadManager.resumeDownloads();
        break;
      case ACTION_PAUSE_DOWNLOADS:
        downloadManager.pauseDownloads();
        break;
      case ACTION_SET_STOP_REASON:
        if (!Assertions.checkNotNull(intent).hasExtra(KEY_STOP_REASON)) {
          Log.e(TAG, ""Ignored SET_STOP_REASON: Missing "" + KEY_STOP_REASON + "" extra"");
        } else {
          int stopReason = intent.getIntExtra(KEY_STOP_REASON, /* defaultValue= */ 0);
          downloadManager.setStopReason(contentId, stopReason);
        }
        break;
      case ACTION_SET_REQUIREMENTS:
        @Nullable
        Requirements requirements =
            Assertions.checkNotNull(intent).getParcelableExtra(KEY_REQUIREMENTS);
        if (requirements == null) {
          Log.e(TAG, ""Ignored SET_REQUIREMENTS: Missing "" + KEY_REQUIREMENTS + "" extra"");
        } else {
          downloadManager.setRequirements(requirements);
        }
        break;
      default:
        Log.e(TAG, ""Ignored unrecognized action: "" + intentAction);
        break;
    }

    if (Util.SDK_INT >= 26 && startedInForeground && foregroundNotificationUpdater != null) {
      // From API level 26, services started in the foreground are required to show a notification.
      foregroundNotificationUpdater.showNotificationIfNotAlready();
    }

    isStopped = false;
    if (downloadManager.isIdle()) {
      onIdle();
    }
    return START_STICKY;
  }

  @Override
  public void onTaskRemoved(Intent rootIntent) {
    taskRemoved = true;
  }

  @Override
  public void onDestroy() {
    isDestroyed = true;
    Assertions.checkNotNull(downloadManagerHelper).detachService(this);
    if (foregroundNotificationUpdater != null) {
      foregroundNotificationUpdater.stopPeriodicUpdates();
    }
  }

  /**
   * Throws {@link UnsupportedOperationException} because this service is not designed to be bound.
   */
  @Override
  @Nullable
  public final IBinder onBind(Intent intent) {
    throw new UnsupportedOperationException();
  }

  /**
   * Returns a {@link DownloadManager} to be used to downloaded content. Called only once in the
   * life cycle of the process.
   */
  protected abstract DownloadManager getDownloadManager();

  /**
   * Returns a {@link Scheduler} to restart the service when requirements for downloads to continue
   * are met.
   *
   * <p>This method is not called on all devices or for all service configurations. When it is
   * called, it's called only once in the life cycle of the process. If a service has unfinished
   * downloads that cannot make progress due to unmet requirements, it will behave according to the
   * first matching case below:
   *
   * <ul>
   *   <li>If the service has {@code foregroundNotificationId} set to {@link
   *       #FOREGROUND_NOTIFICATION_ID_NONE}, then this method will not be called. The service will
   *       remain in the background until the downloads are able to continue to completion or the
   *       service is killed by the platform.
   *   <li>If the device API level is less than 31, a {@link Scheduler} is returned from this
   *       method, and the returned {@link Scheduler} {@link Scheduler#getSupportedRequirements
   *       supports} all of the requirements that have been specified for downloads to continue,
   *       then the service will stop itself and the {@link Scheduler} will be used to restart it in
   *       the foreground when the requirements are met.
   *   <li>If the device API level is less than 31 and either {@code null} or a {@link Scheduler}
   *       that does not {@link Scheduler#getSupportedRequirements support} all of the requirements
   *       is returned from this method, then the service will remain in the foreground until the
   *       downloads are able to continue to completion.
   *   <li>If the device API level is 31 or above, then this method will not be called and the
   *       service will remain in the foreground until the downloads are able to continue to
   *       completion. A {@link Scheduler} cannot be used for this case due to <a
   *       href=""https://developer.android.com/about/versions/12/foreground-services"">Android 12
   *       foreground service launch restrictions</a>.
   *   <li>
   * </ul>
   */
  @Nullable
  protected abstract Scheduler getScheduler();

  /**
   * Returns a notification to be displayed when this service running in the foreground.
   *
   * <p>Download services that do not wish to run in the foreground should be created by setting the
   * {@code foregroundNotificationId} constructor argument to {@link
   * #FOREGROUND_NOTIFICATION_ID_NONE}. This method is not called for such services, meaning it can
   * be implemented to throw {@link UnsupportedOperationException}.
   *
   * @param downloads The current downloads.
   * @param notMetRequirements Any requirements for downloads that are not currently met.
   * @return The foreground notification to display.
   */
  protected abstract Notification getForegroundNotification(
      List<Download> downloads, @RequirementFlags int notMetRequirements);

  /**
   * Invalidates the current foreground notification and causes {@link
   * #getForegroundNotification(List, int)} to be invoked again if the service isn't stopped.
   */
  protected final void invalidateForegroundNotification() {
    if (foregroundNotificationUpdater != null && !isDestroyed) {
      foregroundNotificationUpdater.invalidate();
    }
  }

  /**
   * Called after the service is created, once the downloads are known.
   *
   * @param downloads The current downloads.
   */
  private void notifyDownloads(List<Download> downloads) {
    if (foregroundNotificationUpdater != null) {
      for (int i = 0; i < downloads.size(); i++) {
        if (needsStartedService(downloads.get(i).state)) {
          foregroundNotificationUpdater.startPeriodicUpdates();
          break;
        }
      }
    }
  }

  /**
   * Called when the state of a download changes.
   *
   * @param download The state of the download.
   */
  private void notifyDownloadChanged(Download download) {
    if (foregroundNotificationUpdater != null) {
      if (needsStartedService(download.state)) {
        foregroundNotificationUpdater.startPeriodicUpdates();
      } else {
        foregroundNotificationUpdater.invalidate();
      }
    }
  }

  /** Called when a download is removed. */
  private void notifyDownloadRemoved() {
    if (foregroundNotificationUpdater != null) {
      foregroundNotificationUpdater.invalidate();
    }
  }

  /** Returns whether the service is stopped. */
  private boolean isStopped() {
    return isStopped;
  }

  private void onIdle() {
    if (foregroundNotificationUpdater != null) {
      // Whether the service remains started or not, we don't need periodic notification updates
      // when the DownloadManager is idle.
      foregroundNotificationUpdater.stopPeriodicUpdates();
    }

    if (!Assertions.checkNotNull(downloadManagerHelper).updateScheduler()) {
      // We failed to schedule the service to restart when requirements that the DownloadManager is
      // waiting for are met, so remain started.
      return;
    }

    // Stop the service, either because the DownloadManager is not waiting for requirements to be
    // met, or because we've scheduled the service to be restarted when they are.
    if (Util.SDK_INT < 28 && taskRemoved) { // See [Internal: b/74248644].
      stopSelf();
      isStopped = true;
    } else {
      isStopped |= stopSelfResult(lastStartId);
    }
  }

  private static boolean needsStartedService(@Download.State int state) {
    return state == Download.STATE_DOWNLOADING
        || state == Download.STATE_REMOVING
        || state == Download.STATE_RESTARTING;
  }

  private static Intent getIntent(
      Context context, Class<? extends DownloadService> clazz, String action, boolean foreground) {
    return getIntent(context, clazz, action).putExtra(KEY_FOREGROUND, foreground);
  }

  private static Intent getIntent(
      Context context, Class<? extends DownloadService> clazz, String action) {
    return new Intent(context, clazz).setAction(action);
  }

  private static void startService(Context context, Intent intent, boolean foreground) {
    if (foreground) {
      Util.startForegroundService(context, intent);
    } else {
      context.startService(intent);
    }
  }

  private final class ForegroundNotificationUpdater {

    private final int notificationId;
    private final long updateInterval;
    private final Handler handler;

    private boolean periodicUpdatesStarted;
    private boolean notificationDisplayed;

    public ForegroundNotificationUpdater(int notificationId, long updateInterval) {
      this.notificationId = notificationId;
      this.updateInterval = updateInterval;
      this.handler = new Handler(Looper.getMainLooper());
    }

    public void startPeriodicUpdates() {
      periodicUpdatesStarted = true;
      update();
    }

    public void stopPeriodicUpdates() {
      periodicUpdatesStarted = false;
      handler.removeCallbacksAndMessages(null);
    }

    public void showNotificationIfNotAlready() {
      if (!notificationDisplayed) {
        update();
      }
    }

    public void invalidate() {
      if (notificationDisplayed) {
        update();
      }
    }

    private void update() {
      DownloadManager downloadManager =
          Assertions.checkNotNull(downloadManagerHelper).downloadManager;
      List<Download> downloads = downloadManager.getCurrentDownloads();
      @RequirementFlags int notMetRequirements = downloadManager.getNotMetRequirements();
      Notification notification = getForegroundNotification(downloads, notMetRequirements);
      if (!notificationDisplayed) {
        startForeground(notificationId, notification);
        notificationDisplayed = true;
      } else {
        // Update the notification via NotificationManager rather than by repeatedly calling
        // startForeground, since the latter can cause ActivityManager log spam.
        ((NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE))
            .notify(notificationId, notification);
      }
      if (periodicUpdatesStarted) {
        handler.removeCallbacksAndMessages(null);
        handler.postDelayed(this::update, updateInterval);
      }
    }
  }

  private static final class DownloadManagerHelper implements DownloadManager.Listener {

    private final Context context;
    private final DownloadManager downloadManager;
    private final boolean foregroundAllowed;
    @Nullable private final Scheduler scheduler;
    private final Class<? extends DownloadService> serviceClass;

    @Nullable private DownloadService downloadService;
    private @MonotonicNonNull Requirements scheduledRequirements;

    private DownloadManagerHelper(
        Context context,
        DownloadManager downloadManager,
        boolean foregroundAllowed,
        @Nullable Scheduler scheduler,
        Class<? extends DownloadService> serviceClass) {
      this.context = context;
      this.downloadManager = downloadManager;
      this.foregroundAllowed = foregroundAllowed;
      this.scheduler = scheduler;
      this.serviceClass = serviceClass;
      downloadManager.addListener(this);
      updateScheduler();
    }

    public void attachService(DownloadService downloadService) {
      Assertions.checkState(this.downloadService == null);
      this.downloadService = downloadService;
      if (downloadManager.isInitialized()) {
        // The call to DownloadService.notifyDownloads is posted to avoid it being called directly
        // from DownloadService.onCreate. This is a good idea because it may in turn call
        // DownloadService.getForegroundNotification, and concrete subclass implementations may
        // not anticipate the possibility of this method being called before their onCreate
        // implementation has finished executing.
        Util.createHandlerForCurrentOrMainLooper()
            .postAtFrontOfQueue(
                () -> downloadService.notifyDownloads(downloadManager.getCurrentDownloads()));
      }
    }

    public void detachService(DownloadService downloadService) {
      Assertions.checkState(this.downloadService == downloadService);
      this.downloadService = null;
    }

    /**
     * Schedules or cancels restarting the service, as needed for the current state.
     *
     * @return True if the DownloadManager is not waiting for requirements, or if it is waiting for
     *     requirements and the service has been successfully scheduled to be restarted when they
     *     are met. False if the DownloadManager is waiting for requirements and the service has not
     *     been scheduled for restart.
     */
    public boolean updateScheduler() {
      boolean waitingForRequirements = downloadManager.isWaitingForRequirements();
      if (scheduler == null) {
        return !waitingForRequirements;
      }

      if (!waitingForRequirements) {
        cancelScheduler();
        return true;
      }

      Requirements requirements = downloadManager.getRequirements();
      Requirements supportedRequirements = scheduler.getSupportedRequirements(requirements);
      if (!supportedRequirements.equals(requirements)) {
        cancelScheduler();
        return false;
      }

      if (!schedulerNeedsUpdate(requirements)) {
        return true;
      }

      String servicePackage = context.getPackageName();
      if (scheduler.schedule(requirements, servicePackage, ACTION_RESTART)) {
        scheduledRequirements = requirements;
        return true;
      } else {
        Log.w(TAG, ""Failed to schedule restart"");
        cancelScheduler();
        return false;
      }
    }

    // DownloadManager.Listener implementation.

    @Override
    public void onInitialized(DownloadManager downloadManager) {
      if (downloadService != null) {
        downloadService.notifyDownloads(downloadManager.getCurrentDownloads());
      }
    }

    @Override
    public void onDownloadChanged(
        DownloadManager downloadManager, Download download, @Nullable Exception finalException) {
      if (downloadService != null) {
        downloadService.notifyDownloadChanged(download);
      }
      if (serviceMayNeedRestart() && needsStartedService(download.state)) {
        // This shouldn't happen unless (a) application code is changing the downloads by calling
        // the DownloadManager directly rather than sending actions through the service, or (b) if
        // the service is background only and a previous attempt to start it was prevented. Try and
        // restart the service to robust against such cases.
        Log.w(TAG, ""DownloadService wasn't running. Restarting."");
        restartService();
      }
    }

    @Override
    public void onDownloadRemoved(DownloadManager downloadManager, Download download) {
      if (downloadService != null) {
        downloadService.notifyDownloadRemoved();
      }
    }

    @Override
    public final void onIdle(DownloadManager downloadManager) {
      if (downloadService != null) {
        downloadService.onIdle();
      }
    }

    @Override
    public void onRequirementsStateChanged(
        DownloadManager downloadManager,
        Requirements requirements,
        @RequirementFlags int notMetRequirements) {
      updateScheduler();
    }

    @Override
    public void onWaitingForRequirementsChanged(
        DownloadManager downloadManager, boolean waitingForRequirements) {
      if (!waitingForRequirements
          && !downloadManager.getDownloadsPaused()
          && serviceMayNeedRestart()) {
        // We're no longer waiting for requirements and downloads aren't paused, meaning the manager
        // will be able to resume downloads that are currently queued. If there exist queued
        // downloads then we should ensure the service is started.
        List<Download> downloads = downloadManager.getCurrentDownloads();
        for (int i = 0; i < downloads.size(); i++) {
          if (downloads.get(i).state == Download.STATE_QUEUED) {
            restartService();
            return;
          }
        }
      }
    }

    // Internal methods.

    private boolean schedulerNeedsUpdate(Requirements requirements) {
      return !Util.areEqual(scheduledRequirements, requirements);
    }

    @RequiresNonNull(""scheduler"")
    private void cancelScheduler() {
      Requirements canceledRequirements = new Requirements(/* requirements= */ 0);
      if (schedulerNeedsUpdate(canceledRequirements)) {
        scheduler.cancel();
        scheduledRequirements = canceledRequirements;
      }
    }

    private boolean serviceMayNeedRestart() {
      return downloadService == null || downloadService.isStopped();
    }

    private void restartService() {
      if (foregroundAllowed) {
        try {
          Intent intent = getIntent(context, serviceClass, DownloadService.ACTION_RESTART);
          Util.startForegroundService(context, intent);
        } catch (IllegalStateException e) {
          // The process is running in the background, and is not allowed to start a foreground
          // service due to foreground service launch restrictions
          // (https://developer.android.com/about/versions/12/foreground-services).
          Log.w(TAG, ""Failed to restart (foreground launch restriction)"");
        }
      } else {
        // The service is background only. Use ACTION_INIT rather than ACTION_RESTART because
        // ACTION_RESTART is handled as though KEY_FOREGROUND is set to true.
        try {
          Intent intent = getIntent(context, serviceClass, DownloadService.ACTION_INIT);
          context.startService(intent);
        } catch (IllegalStateException e) {
          // The process is classed as idle by the platform. Starting a background service is not
          // allowed in this state.
          Log.w(TAG, ""Failed to restart (process is idle)"");
        }
      }
    }
  }
}",1,439 305 334 2000 378 2001 123 618 439 457 381 2002 2003 61 648 59 618 437 457 381 2002 2004 61 648 59 618 439 457 381 2002 2005 61 648 59 618 439 457 381 2002 2006 61 648 59 618 439 457 381 2002 2007 61 648 59 618 439 457 381 2002 2008 61 648 59 618 439 457 381 2002 2009 61 648 59 618 439 457 381 2002 2010 61 648 59 618 439 457 381 2002 2011 61 648 59 618 439 457 381 2002 2012 61 648 59 618 439 457 381 2002 2013 61 648 59 618 439 457 381 2002 2014 61 648 59 618 439 457 381 2002 2015 61 648 59 618 439 457 381 2002 2016 61 648 59 618 439 457 381 404 2017 61 1500 59 618 439 457 381 413 2018 61 1504 59 437 457 381 2002 2019 61 648 59 621 621 621 437 457 381 2020 60 2021 60 63 378 2000 62 44 2022 62 2023 61 418 2020 60 62 40 41 59 64 2024 437 381 2025 2026 59 64 2024 437 381 2002 2027 59 64 2028 437 381 404 2029 59 64 2028 437 381 404 2030 59 437 64 2031 2022 2032 59 437 404 2033 59 437 324 2034 59 437 324 2035 59 437 324 2036 59 437 324 2037 59 618 438 2000 40 404 2038 41 123 467 40 2038 44 2018 41 59 125 618 438 2000 40 404 2038 44 413 2039 41 123 467 40 2038 44 2039 44 604 424 44 604 1500 44 604 1500 41 59 125 618 64 2040 438 2000 40 404 2038 44 413 2039 44 64 2024 2002 2027 44 64 2028 404 2029 41 123 467 40 2038 44 2039 44 2027 44 2029 44 604 1500 41 59 125 618 438 2000 40 404 2038 44 413 2039 44 64 2024 2002 2027 44 64 2028 404 2029 44 64 2028 404 2030 41 123 392 40 2038 614 2017 41 123 467 46 2026 61 424 59 467 46 2027 61 424 59 467 46 2029 61 1500 59 467 46 2030 61 1500 59 125 360 123 467 46 2026 61 418 2025 40 2038 44 2039 41 59 467 46 2027 61 2027 59 467 46 2029 61 2029 59 467 46 2030 61 2030 59 125 125 618 439 457 2041 2042 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2046 2047 44 324 2048 41 123 450 2042 40 2044 44 2045 44 2047 44 2049 44 2048 41 59 125 618 439 457 2041 2042 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2046 2047 44 404 2050 44 324 2048 41 123 450 2051 40 2044 44 2045 44 2005 44 2048 41 46 2052 40 2012 44 2047 41 46 2052 40 2014 44 2050 41 59 125 618 439 457 2041 2053 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2002 2054 44 324 2048 41 123 450 2055 40 2044 44 2045 44 2006 44 2048 41 46 2056 40 2013 44 2054 41 59 125 618 439 457 2041 2057 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 324 2048 41 123 450 2058 40 2044 44 2045 44 2007 44 2048 41 59 125 618 439 457 2041 2059 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 324 2048 41 123 450 2060 40 2044 44 2045 44 2008 44 2048 41 59 125 618 439 457 2041 2061 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 324 2048 41 123 450 2062 40 2044 44 2045 44 2009 44 2048 41 59 125 618 439 457 2041 2063 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 64 2024 2002 2054 44 404 2050 44 324 2048 41 123 450 2064 40 2044 44 2045 44 2010 44 2048 41 46 2065 40 2013 44 2054 41 46 2065 40 2014 44 2050 41 59 125 618 439 457 2041 2066 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2067 2068 44 324 2048 41 123 450 2069 40 2044 44 2045 44 2011 44 2048 41 46 2070 40 2015 44 2068 41 59 125 618 439 457 492 2071 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2046 2047 44 324 2048 41 123 2041 2072 61 2042 40 2044 44 2045 44 2047 44 2048 41 59 2073 40 2044 44 2072 44 2048 41 59 125 618 439 457 492 2071 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2046 2047 44 404 2050 44 324 2048 41 123 2041 2074 61 2042 40 2044 44 2045 44 2047 44 2050 44 2048 41 59 2075 40 2044 44 2074 44 2048 41 59 125 618 439 457 492 2076 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2002 2054 44 324 2048 41 123 2041 2077 61 2053 40 2044 44 2045 44 2054 44 2048 41 59 2078 40 2044 44 2077 44 2048 41 59 125 618 439 457 492 2079 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 324 2048 41 123 2041 2080 61 2057 40 2044 44 2045 44 2048 41 59 2081 40 2044 44 2080 44 2048 41 59 125 618 439 457 492 2082 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 324 2048 41 123 2041 2083 61 2059 40 2044 44 2045 44 2048 41 59 2084 40 2044 44 2083 44 2048 41 59 125 618 439 457 492 2085 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 324 2048 41 123 2041 2086 61 2061 40 2044 44 2045 44 2048 41 59 2087 40 2044 44 2086 44 2048 41 59 125 618 439 457 492 2088 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 64 2024 2002 2054 44 404 2050 44 324 2048 41 123 2041 2089 61 2063 40 2044 44 2045 44 2054 44 2050 44 2048 41 59 2090 40 2044 44 2089 44 2048 41 59 125 618 439 457 492 2091 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2067 2068 44 324 2048 41 123 2041 2092 61 2066 40 2044 44 2045 44 2068 44 2048 41 59 2093 40 2044 44 2092 44 2048 41 59 125 618 439 457 492 2094 40 2043 2044 44 2021 60 63 378 2000 62 2045 41 123 2044 46 2095 40 2096 40 2044 44 2045 44 2003 41 41 59 125 618 439 457 492 2097 40 2043 2044 44 2021 60 63 378 2000 62 2045 41 123 2041 2098 61 2099 40 2044 44 2045 44 2003 44 473 41 59 2100 46 2101 40 2044 44 2098 41 59 125 64 2102 439 492 2103 40 41 123 392 40 2027 631 424 41 123 2104 46 2105 40 467 44 2027 44 2029 44 2030 44 2104 46 2106 41 59 125 2021 60 63 378 2000 62 2045 61 2107 40 41 59 64 2024 2022 2032 61 2023 46 2108 40 2045 41 59 392 40 2032 614 424 41 123 324 2109 61 2026 631 424 59 621 324 2110 61 2111 46 2112 60 1503 59 64 2024 2113 2114 61 2109 605 2110 63 2115 40 41 58 424 59 2116 2117 61 2118 40 41 59 2117 46 2119 40 41 59 2032 61 418 2022 40 2120 40 41 44 2117 44 2109 44 2114 44 2045 41 59 2023 46 2121 40 2045 44 2032 41 59 125 467 46 2032 61 2032 59 2032 46 2122 40 467 41 59 125 64 2102 439 404 2123 40 64 2024 2041 2124 44 404 2125 44 404 2126 41 123 2033 61 2126 59 2035 61 380 59 64 2024 2002 2127 61 424 59 64 2024 2002 2128 61 424 59 392 40 2124 631 424 41 123 2127 61 2124 46 2129 40 41 59 2128 61 2124 46 2130 40 2013 41 59 2034 635 2124 46 2131 40 2016 44 380 41 606 2004 46 2132 40 2127 41 59 125 621 392 40 2127 614 424 41 123 2127 61 2003 59 125 2133 2134 61 2135 46 2136 40 2032 41 46 2134 59 464 40 2127 41 123 328 2003 58 328 2004 58 621 325 59 328 2005 58 64 2024 2046 2047 61 2135 46 2136 40 2124 41 46 2137 40 2012 41 59 392 40 2047 614 424 41 123 2138 46 2139 40 2019 44 648 43 2012 43 648 41 59 125 360 123 404 2050 61 2124 46 2140 40 2014 44 2141 46 2142 41 59 2134 46 2143 40 2047 44 2050 41 59 125 325 59 328 2006 58 392 40 2128 614 424 41 123 2144 46 2145 40 2019 44 648 43 2013 43 648 41 59 125 360 123 2134 46 2146 40 2128 41 59 125 325 59 328 2007 58 2134 46 2147 40 41 59 325 59 328 2008 58 2134 46 2148 40 41 59 325 59 328 2009 58 2134 46 2149 40 41 59 325 59 328 2010 58 392 40 33 2135 46 2136 40 2124 41 46 2150 40 2014 41 41 123 2151 46 2152 40 2019 44 648 43 2014 43 648 41 59 125 360 123 404 2050 61 2124 46 2153 40 2014 44 604 1500 41 59 2134 46 2154 40 2128 44 2050 41 59 125 325 59 328 2011 58 64 2024 2067 2068 61 2135 46 2136 40 2124 41 46 2137 40 2015 41 59 392 40 2068 614 424 41 123 2155 46 2156 40 2019 44 648 43 2015 43 648 41 59 125 360 123 2134 46 2157 40 2068 41 59 125 325 59 349 58 2158 46 2159 40 2019 44 648 43 2127 41 59 325 59 125 392 40 2160 46 2161 615 1503 605 2034 605 2026 631 424 41 123 621 2026 46 2162 40 41 59 125 2036 61 380 59 392 40 2134 46 2163 40 41 41 123 2164 40 41 59 125 450 2165 59 125 64 2102 439 492 2166 40 2041 2167 41 123 2035 61 473 59 125 64 2102 439 492 2168 40 41 123 2037 61 473 59 2169 46 2170 40 2032 41 46 2171 40 467 41 59 392 40 2026 631 424 41 123 2026 46 2172 40 41 59 125 125 618 64 2102 64 2024 439 381 2173 2174 40 2041 2124 41 123 469 418 2175 40 41 59 125 618 438 305 2176 2177 40 41 59 618 64 2024 438 305 2178 2179 40 41 59 618 438 305 2180 2181 40 2182 60 2183 62 2184 44 64 2185 404 2186 41 59 618 438 381 492 2187 40 41 123 392 40 2026 631 424 605 33 2037 41 123 2026 46 2188 40 41 59 125 125 618 437 492 2189 40 2182 60 2183 62 2184 41 123 392 40 2026 631 424 41 123 385 40 404 2190 61 1500 59 2190 60 2184 46 2191 40 41 59 2190 637 41 123 392 40 2192 40 2184 46 2193 40 2190 41 46 2194 41 41 123 2026 46 2195 40 41 59 325 59 125 125 125 125 618 437 492 2196 40 2183 2197 41 123 392 40 2026 631 424 41 123 392 40 2198 40 2197 46 2199 41 41 123 2026 46 2200 40 41 59 125 360 123 2026 46 2201 40 41 59 125 125 125 618 437 492 2202 40 41 123 392 40 2026 631 424 41 123 2026 46 2203 40 41 59 125 125 618 437 324 2036 40 41 123 450 2036 59 125 437 492 2204 40 41 123 392 40 2026 631 424 41 123 621 621 2026 46 2205 40 41 59 125 392 40 33 2206 46 2207 40 2032 41 46 2208 40 41 41 123 621 621 450 59 125 621 621 392 40 2209 46 2210 60 1503 605 2035 41 123 621 2211 40 41 59 2036 61 473 59 125 360 123 2036 635 2212 40 2033 41 59 125 125 437 457 324 2213 40 64 2183 46 2214 404 2215 41 123 450 2215 614 2183 46 2216 606 2215 614 2183 46 2217 606 2215 614 2183 46 2218 59 125 437 457 2041 2219 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2002 2220 44 324 2048 41 123 450 2219 40 2044 44 2045 44 2220 41 46 2221 40 2016 44 2048 41 59 125 437 457 2041 2219 40 2043 2044 44 2021 60 63 378 2000 62 2045 44 2002 2220 41 123 450 418 2041 40 2044 44 2045 41 46 2222 40 2220 41 59 125 437 457 492 2223 40 2043 2044 44 2041 2124 44 324 2048 41 123 392 40 2048 41 123 2224 46 2225 40 2044 44 2124 41 59 125 360 123 2044 46 2223 40 2124 41 59 125 125 437 381 334 2025 123 437 381 404 2226 59 437 381 413 2227 59 437 381 2228 2229 59 437 324 2230 59 437 324 2231 59 439 2025 40 404 2226 44 413 2227 41 123 467 46 2226 61 2226 59 467 46 2227 61 2227 59 467 46 2229 61 418 2228 40 2232 46 2233 40 41 41 59 125 439 492 2234 40 41 123 2230 61 473 59 2235 40 41 59 125 439 492 2236 40 41 123 2230 61 380 59 2229 46 2237 40 424 41 59 125 439 492 2238 40 41 123 392 40 33 2231 41 123 2239 40 41 59 125 125 439 492 2240 40 41 123 392 40 2231 41 123 2241 40 41 59 125 125 437 492 2242 40 41 123 2176 2243 61 2244 46 2245 40 2032 41 46 2243 59 2182 60 2183 62 2184 61 2243 46 2246 40 41 59 64 2185 404 2186 61 2243 46 2247 40 41 59 2180 2248 61 2181 40 2184 44 2186 41 59 392 40 33 2231 41 123 2097 40 2226 44 2248 41 59 2231 61 473 59 125 360 123 621 621 40 40 2249 41 2250 40 2043 46 2251 41 41 46 2252 40 2226 44 2248 41 59 125 392 40 2230 41 123 2229 46 2253 40 424 41 59 2229 46 2254 40 467 58 58 2242 44 2227 41 59 125 125 125 437 457 381 334 2022 395 2176 46 2255 123 437 381 2043 2044 59 437 381 2176 2256 59 437 381 324 2257 59 64 2024 437 381 2178 2258 59 437 381 2021 60 63 378 2000 62 2259 59 64 2024 437 2000 2260 59 437 64 2031 2067 2261 59 437 2022 40 2043 2044 44 2176 2256 44 324 2257 44 64 2024 2178 2258 44 2021 60 63 378 2000 62 2259 41 123 467 46 2044 61 2044 59 467 46 2256 61 2256 59 467 46 2257 61 2257 59 467 46 2258 61 2258 59 467 46 2259 61 2259 59 2256 46 2262 40 467 41 59 2263 40 41 59 125 439 492 2264 40 2000 2260 41 123 2265 46 2266 40 467 46 2260 614 424 41 59 467 46 2260 61 2260 59 392 40 2256 46 2267 40 41 41 123 621 621 621 621 621 2268 46 2269 40 41 46 2270 40 40 41 45 62 2260 46 2189 40 2256 46 2271 40 41 41 41 59 125 125 439 492 2272 40 2000 2260 41 123 2273 46 2274 40 467 46 2260 614 2260 41 59 467 46 2260 61 424 59 125 618 439 324 2275 40 41 123 324 2276 61 2256 46 2277 40 41 59 392 40 2258 614 424 41 123 450 33 2276 59 125 392 40 33 2276 41 123 2278 40 41 59 450 473 59 125 2067 2068 61 2256 46 2279 40 41 59 2067 2280 61 2258 46 2281 40 2068 41 59 392 40 33 2280 46 2282 40 2068 41 41 123 2283 40 41 59 450 380 59 125 392 40 33 2284 40 2068 41 41 123 450 473 59 125 2002 2285 61 2044 46 2286 40 41 59 392 40 2258 46 2287 40 2068 44 2285 44 2004 41 41 123 2261 61 2068 59 450 473 59 125 360 123 2288 46 2289 40 2019 44 648 41 59 2290 40 41 59 450 380 59 125 125 621 64 2102 439 492 2291 40 2176 2256 41 123 392 40 2260 631 424 41 123 2260 46 2189 40 2256 46 2292 40 41 41 59 125 125 64 2102 439 492 2293 40 2176 2256 44 2183 2197 44 64 2024 2294 2295 41 123 392 40 2260 631 424 41 123 2260 46 2196 40 2197 41 59 125 392 40 2296 40 41 605 2213 40 2197 46 2215 41 41 123 621 621 621 621 2297 46 2298 40 2019 44 648 41 59 2299 40 41 59 125 125 64 2102 439 492 2300 40 2176 2256 44 2183 2197 41 123 392 40 2260 631 424 41 123 2260 46 2202 40 41 59 125 125 64 2102 439 381 492 2204 40 2176 2256 41 123 392 40 2260 631 424 41 123 2260 46 2204 40 41 59 125 125 64 2102 439 492 2301 40 2176 2256 44 2067 2068 44 64 2185 404 2186 41 123 2275 40 41 59 125 64 2102 439 492 2302 40 2176 2256 44 324 2303 41 123 392 40 33 2303 605 33 2256 46 2304 40 41 605 2305 40 41 41 123 621 621 621 2182 60 2183 62 2184 61 2256 46 2306 40 41 59 385 40 404 2307 61 1500 59 2307 60 2184 46 2308 40 41 59 2307 637 41 123 392 40 2184 46 2309 40 2307 41 46 2215 614 2183 46 2310 41 123 2311 40 41 59 450 59 125 125 125 125 621 437 324 2312 40 2067 2068 41 123 450 33 2313 46 2314 40 2261 44 2068 41 59 125 64 2315 40 648 41 437 492 2316 40 41 123 2067 2317 61 418 2067 40 604 1500 41 59 392 40 2312 40 2317 41 41 123 2258 46 2318 40 41 59 2261 61 2317 59 125 125 437 324 2319 40 41 123 450 2260 614 424 606 2260 46 2036 40 41 59 125 437 492 2320 40 41 123 392 40 2257 41 123 474 123 2041 2124 61 2219 40 2044 44 2259 44 2000 46 2004 41 59 2321 46 2322 40 2044 44 2124 41 59 125 329 40 2323 2324 41 123 621 621 621 2325 46 2326 40 2019 44 648 41 59 125 125 360 123 621 621 474 123 2041 2124 61 2219 40 2044 44 2259 44 2000 46 2003 41 59 2044 46 2223 40 2124 41 59 125 329 40 2327 2328 41 123 621 621 2329 46 2330 40 2019 44 648 41 59 125 125 125 125 125 
3253,Java,"@FxmlView
public class VoteResultView extends ActivatableView<GridPane, Void> implements DaoStateListener {
    private final DaoFacade daoFacade;
    private final PhasesView phasesView;
    private final DaoStateService daoStateService;
    private final CycleService cycleService;
    private final VoteResultService voteResultService;
    private final ProposalService proposalService;
    private final PeriodService periodService;
    private final BsqWalletService bsqWalletService;
    private final BsqFormatter bsqFormatter;
    private final ProposalResultsWindow proposalResultsWindow;

    private Button exportButton;

    private int gridRow = 0;

    private TableView<CycleListItem> cyclesTableView;
    private final ObservableList<CycleListItem> cycleListItemList = FXCollections.observableArrayList();
    private final SortedList<CycleListItem> sortedCycleListItemList = new SortedList<>(cycleListItemList);

    private TableView<ProposalListItem> proposalsTableView;
    private final ObservableList<ProposalListItem> proposalList = FXCollections.observableArrayList();
    private final SortedList<ProposalListItem> sortedProposalList = new SortedList<>(proposalList);

    private final ObservableList<VoteListItem> voteListItemList = FXCollections.observableArrayList();
    private final SortedList<VoteListItem> sortedVoteListItemList = new SortedList<>(voteListItemList);

    private Subscription selectedProposalSubscription;
    private ChangeListener<CycleListItem> selectedVoteResultListItemListener;
    private ResultsOfCycle resultsOfCycle;
    private ProposalListItem selectedProposalListItem;
    private boolean isVoteIncludedInResult;
    private final Set<Cycle> cyclesAdded = new HashSet<>();
    private boolean hasCalculatedResult = false;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public VoteResultView(DaoFacade daoFacade,
                          PhasesView phasesView,
                          DaoStateService daoStateService,
                          CycleService cycleService,
                          VoteResultService voteResultService,
                          ProposalService proposalService,
                          PeriodService periodService,
                          BsqWalletService bsqWalletService,
                          BsqFormatter bsqFormatter,
                          ProposalResultsWindow proposalResultsWindow) {
        this.daoFacade = daoFacade;
        this.phasesView = phasesView;
        this.daoStateService = daoStateService;
        this.cycleService = cycleService;
        this.voteResultService = voteResultService;
        this.proposalService = proposalService;
        this.periodService = periodService;
        this.bsqWalletService = bsqWalletService;
        this.bsqFormatter = bsqFormatter;
        this.proposalResultsWindow = proposalResultsWindow;
    }

    @Override
    public void initialize() {
        gridRow = phasesView.addGroup(root, gridRow);

        selectedVoteResultListItemListener = (observable, oldValue, newValue) -> onResultsListItemSelected(newValue);

        createCyclesTable();
        exportButton = addButton(root, ++gridRow, Res.get(""shared.exportJSON""));
        exportButton.getStyleClass().add(""text-button"");
        GridPane.setMargin(exportButton, new Insets(10, -10, -50, 0));
        GridPane.setColumnSpan(exportButton, 2);
        GridPane.setHalignment(exportButton, HPos.RIGHT);

        proposalResultsWindow.onClose(() -> proposalsTableView.getSelectionModel().clearSelection());
    }

    @Override
    protected void activate() {
        super.activate();

        phasesView.activate();

        daoFacade.addBsqStateListener(this);
        cyclesTableView.getSelectionModel().selectedItemProperty().addListener(selectedVoteResultListItemListener);

        if (daoStateService.isParseBlockChainComplete()) {
            checkForResultPhase(daoStateService.getChainHeight());
            fillCycleList();
        }

        exportButton.setOnAction(event -> {
            JsonElement cyclesJsonArray = getVotingHistoryJson();
            GUIUtil.exportJSON(""voteResultsHistory.json"", cyclesJsonArray, (Stage) root.getScene().getWindow());
        });
        if (proposalsTableView != null) {
            GUIUtil.setFitToRowsForTableView(proposalsTableView, 25, 28, 6, 6);

            selectedProposalSubscription = EasyBind.subscribe(proposalsTableView.getSelectionModel().selectedItemProperty(),
                    this::onSelectProposalResultListItem);
        }
        GUIUtil.setFitToRowsForTableView(cyclesTableView, 25, 28, 6, 6);
    }

    @Override
    protected void deactivate() {
        super.deactivate();

        phasesView.deactivate();

        daoFacade.removeBsqStateListener(this);
        cyclesTableView.getSelectionModel().selectedItemProperty().removeListener(selectedVoteResultListItemListener);

        if (selectedProposalSubscription != null)
            selectedProposalSubscription.unsubscribe();
        exportButton.setOnAction(null);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // DaoStateListener
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onParseBlockCompleteAfterBatchProcessing(Block block) {
        checkForResultPhase(daoStateService.getChainHeight());
        fillCycleList();
    }

    private void checkForResultPhase(int chainHeight) {
        if (periodService.isInPhase(chainHeight, DaoPhase.Phase.RESULT)) {
            if (!hasCalculatedResult) {
                hasCalculatedResult = true;
                // We had set the cycle initially but at the vote result we want to update it with the actual result.
                // We remove the empty cycle to make space for the one with the result.
                Optional<Cycle> optionalCurrentCycle = cyclesAdded.stream()
                        .filter(cycle -> cycle.isInCycle(chainHeight))
                        .findAny();
                optionalCurrentCycle.ifPresent(cyclesAdded::remove);
                Optional<CycleListItem> optionalCurrentCycleListItem = cycleListItemList.stream()
                        .filter(cycleListItem -> cycleListItem.getResultsOfCycle().getCycle().isInCycle(chainHeight))
                        .findAny();
                optionalCurrentCycleListItem.ifPresent(cycleListItemList::remove);
            }
        } else {
            // Reset to be ready to calculate result for next RESULT phase
            hasCalculatedResult = false;
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // UI handlers
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onResultsListItemSelected(CycleListItem item) {
        if (selectedProposalSubscription != null)
            selectedProposalSubscription.unsubscribe();

        GUIUtil.removeChildrenFromGridPaneRows(root, 3, gridRow);
        gridRow = 2;

        if (item != null) {
            resultsOfCycle = item.getResultsOfCycle();

            // Check if my vote is included in result
            isVoteIncludedInResult = false;
            resultsOfCycle.getEvaluatedProposals().forEach(evProposal -> resultsOfCycle.getDecryptedVotesForCycle()
                    .forEach(decryptedBallotsWithMerits -> {
                        // Iterate through all included votes to see if any of those are ours
                        if (!isVoteIncludedInResult) {
                            isVoteIncludedInResult = bsqWalletService.isWalletTransaction(decryptedBallotsWithMerits
                                    .getVoteRevealTxId()).isPresent();
                        }
                    }));


            maybeShowVoteResultErrors(item.getResultsOfCycle().getCycle());
            createProposalsTable();

            selectedProposalSubscription = EasyBind.subscribe(proposalsTableView.getSelectionModel().selectedItemProperty(),
                    this::onSelectProposalResultListItem);

            StringBuilder sb = new StringBuilder();
            voteResultService.getInvalidDecryptedBallotsWithMeritItems().stream()
                    .filter(e -> periodService.isTxInCorrectCycle(e.getVoteRevealTxId(),
                            item.getResultsOfCycle().getCycle().getHeightOfFirstBlock()))
                    .forEach(e -> {
                        sb.append(""\n"")
                                .append(Res.getWithCol(""shared.blindVoteTxId"")).append("" "")
                                .append(e.getBlindVoteTxId()).append(""\n"")
                                .append(Res.getWithCol(""dao.results.votes.table.header.stake"")).append("" "")
                                .append(bsqFormatter.formatCoinWithCode(Coin.valueOf(e.getStake()))).append(""\n"");
                        e.getBallotList().stream().forEach(ballot -> {
                            sb.append(Res.getWithCol(""shared.proposal"")).append(""\n\t"")
                                    .append(Res.getWithCol(""shared.name"")).append("" "")
                                    .append(ballot.getProposal().getName()).append(""\n\t"");
                            sb.append(Res.getWithCol(""dao.bond.table.column.link"")).append("" "")
                                    .append(ballot.getProposal().getLink()).append(""\n\t"");
                            Vote vote = ballot.getVote();
                            String voteString = vote == null ? Res.get(""dao.proposal.display.myVote.ignored"") :
                                    vote.isAccepted() ?
                                            Res.get(""dao.proposal.display.myVote.accepted"") :
                                            Res.get(""dao.proposal.display.myVote.rejected"");
                            sb.append(Res.getWithCol(""dao.results.votes.table.header.vote"")).append("" "")
                                    .append(voteString).append(""\n"");

                        });
                    });
            if (sb.length() != 0) {
                new Popup().information(Res.get(""dao.results.invalidVotes"", sb.toString())).show();
            }
        }
    }

    private void maybeShowVoteResultErrors(Cycle cycle) {
        List<VoteResultException> exceptions = voteResultService.getVoteResultExceptions().stream()
                .filter(voteResultException -> cycle.getHeightOfFirstBlock() == voteResultException.getHeightOfFirstBlockInCycle())
                .collect(Collectors.toList());
        if (!exceptions.isEmpty()) {
            TextArea textArea = FormBuilder.addTextArea(root, ++gridRow, """");
            GridPane.setMargin(textArea, new Insets(Layout.GROUP_DISTANCE, -15, 0, -10));
            textArea.setPrefHeight(100);

            StringBuilder sb = new StringBuilder(Res.getWithCol(""dao.results.exceptions"") + ""\n"");
            exceptions.forEach(exception -> {
                if (exception.getCause() != null)
                    sb.append(exception.getCause().getMessage());
                else
                    sb.append(exception.getMessage());
                sb.append(""\n"");
            });

            textArea.setText(sb.toString());
        }
    }

    private void onSelectProposalResultListItem(ProposalListItem item) {
        selectedProposalListItem = item;

        if (selectedProposalListItem != null) {
            EvaluatedProposal evaluatedProposal = selectedProposalListItem.getEvaluatedProposal();
            Optional<Ballot> optionalBallot = daoFacade.getAllValidBallots().stream()
                    .filter(ballot -> ballot.getTxId().equals(evaluatedProposal.getProposalTxId()))
                    .findAny();

            Ballot ballot = optionalBallot.orElse(null);
            voteListItemList.clear();
            resultsOfCycle.getEvaluatedProposals().stream()
                    .filter(evProposal -> evProposal.getProposal().equals(selectedProposalListItem.getEvaluatedProposal().getProposal()))
                    .forEach(evProposal -> resultsOfCycle.getDecryptedVotesForCycle().forEach(decryptedBallotsWithMerits ->
                            voteListItemList.add(new VoteListItem(evProposal.getProposal(), decryptedBallotsWithMerits,
                                    daoStateService, bsqFormatter))));

            voteListItemList.sort(Comparator.comparing(VoteListItem::getBlindVoteTxId));

            showProposalResultWindow(evaluatedProposal, ballot, isVoteIncludedInResult, sortedVoteListItemList);
        }
    }

    private void showProposalResultWindow(EvaluatedProposal evaluatedProposal,
                                          Ballot ballot,
                                          boolean isVoteIncludedInResult,
                                          SortedList<VoteListItem> sortedVoteListItemList) {
        proposalResultsWindow.show(evaluatedProposal, ballot, isVoteIncludedInResult, sortedVoteListItemList);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Fill lists: Cycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void fillCycleList() {
        // At data creation we delay a bit so that the UI has a chance to display the placeholder.
        if (cyclesAdded.isEmpty()) {
            UserThread.runAfter(this::doFillCycleList, 50, TimeUnit.MILLISECONDS);
        } else {
            doFillCycleList();
        }
    }

    private void doFillCycleList() {
        // Creating our data structure is a bit expensive so we ensure to only create the CycleListItems once.
        daoStateService.getCycles().stream()
                .filter(cycle -> !cyclesAdded.contains(cycle))
                .forEach(cycle -> {
                    List<Proposal> proposalsForCycle = proposalService.getValidatedProposals().stream()
                            .filter(proposal -> cycleService.isTxInCycle(cycle, proposal.getTxId()))
                            .collect(Collectors.toList());

                    List<EvaluatedProposal> evaluatedProposalsForCycle = daoStateService.getEvaluatedProposalList().stream()
                            .filter(evaluatedProposal -> cycleService.isTxInCycle(cycle, evaluatedProposal.getProposal().getTxId()))
                            .collect(Collectors.toList());

                    AtomicLong stakeAndMerit = new AtomicLong();
                    List<DecryptedBallotsWithMerits> decryptedVotesForCycle = daoStateService.getDecryptedBallotsWithMeritsList().stream()
                            .filter(decryptedBallotsWithMerits -> cycleService.isTxInCycle(cycle, decryptedBallotsWithMerits.getBlindVoteTxId()))
                            .filter(decryptedBallotsWithMerits -> cycleService.isTxInCycle(cycle, decryptedBallotsWithMerits.getVoteRevealTxId()))
                            .peek(decryptedBallotsWithMerits -> stakeAndMerit.getAndAdd(decryptedBallotsWithMerits.getStake() + decryptedBallotsWithMerits.getMerit(daoStateService)))
                            .collect(Collectors.toList());

                    long cycleStartTime = daoStateService.getBlockTimeAtBlockHeight(cycle.getHeightOfFirstBlock());
                    int cycleIndex = cycleService.getCycleIndex(cycle);
                    ResultsOfCycle resultsOfCycle = new ResultsOfCycle(cycle,
                            cycleIndex,
                            cycleStartTime,
                            proposalsForCycle,
                            evaluatedProposalsForCycle,
                            decryptedVotesForCycle,
                            stakeAndMerit.get(),
                            daoStateService);
                    CycleListItem cycleListItem = new CycleListItem(resultsOfCycle, bsqFormatter);
                    cycleListItemList.add(cycleListItem);

                    cyclesAdded.add(resultsOfCycle.getCycle());
                });
        cycleListItemList.sort(Comparator.comparing(e -> ((CycleListItem) e).getResultsOfCycle().getCycleIndex()).reversed());

        GUIUtil.setFitToRowsForTableView(cyclesTableView, 25, 28, 6, 6);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Create views: cyclesTableView
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void createCyclesTable() {
        TableGroupHeadline headline = new TableGroupHeadline(Res.get(""dao.results.cycles.header""));
        GridPane.setRowIndex(headline, ++gridRow);
        GridPane.setMargin(headline, new Insets(Layout.GROUP_DISTANCE, -10, -10, -10));
        GridPane.setColumnSpan(headline, 2);
        root.getChildren().add(headline);

        cyclesTableView = new TableView<>();
        cyclesTableView.setPlaceholder(new AutoTooltipLabel(Res.get(""table.placeholder.processingData"")));
        cyclesTableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        createCycleColumns(cyclesTableView);

        GridPane.setRowIndex(cyclesTableView, gridRow);
        GridPane.setMargin(cyclesTableView, new Insets(Layout.FIRST_ROW_AND_GROUP_DISTANCE, -10, -15, -10));
        GridPane.setColumnSpan(cyclesTableView, 2);
        GridPane.setVgrow(cyclesTableView, Priority.SOMETIMES);
        root.getChildren().add(cyclesTableView);

        cyclesTableView.setItems(sortedCycleListItemList);
        sortedCycleListItemList.comparatorProperty().bind(cyclesTableView.comparatorProperty());


    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Create views: proposalsTableView
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void createProposalsTable() {
        TableGroupHeadline proposalsTableHeader = new TableGroupHeadline(Res.get(""dao.results.proposals.header""));
        GridPane.setRowIndex(proposalsTableHeader, ++gridRow);
        GridPane.setMargin(proposalsTableHeader, new Insets(Layout.GROUP_DISTANCE, -10, -10, -10));
        GridPane.setColumnSpan(proposalsTableHeader, 2);
        root.getChildren().add(proposalsTableHeader);

        proposalsTableView = new TableView<>();
        proposalsTableView.setPlaceholder(new AutoTooltipLabel(Res.get(""table.placeholder.noData"")));
        proposalsTableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        createProposalsColumns(proposalsTableView);

        GridPane.setRowIndex(proposalsTableView, gridRow);
        GridPane.setMargin(proposalsTableView, new Insets(Layout.FIRST_ROW_AND_GROUP_DISTANCE, -10, 0, -10));
        GridPane.setColumnSpan(proposalsTableView, 2);
        GridPane.setVgrow(proposalsTableView, Priority.ALWAYS);
        root.getChildren().add(proposalsTableView);

        proposalsTableView.setItems(sortedProposalList);
        sortedProposalList.comparatorProperty().bind(proposalsTableView.comparatorProperty());

        proposalList.forEach(ProposalListItem::resetTableRow);
        proposalList.clear();

        Map<String, Ballot> ballotByProposalTxIdMap = daoFacade.getAllValidBallots().stream()
                .collect(Collectors.toMap(Ballot::getTxId, ballot -> ballot));
        proposalList.setAll(resultsOfCycle.getEvaluatedProposals().stream()
                .filter(evaluatedProposal -> {
                    boolean containsKey = ballotByProposalTxIdMap.containsKey(evaluatedProposal.getProposalTxId());

                    // We saw in testing that the ballot was not there for an evaluatedProposal. We could not reproduce that
                    // so far but to avoid a nullPointer we filter out such cases.
                    if (!containsKey)
                        log.warn(""ballotByProposalTxIdMap does not contain expected proposalTxId()={}"", evaluatedProposal.getProposalTxId());

                    return containsKey;
                })
                .map(evaluatedProposal -> new ProposalListItem(evaluatedProposal,
                        ballotByProposalTxIdMap.get(evaluatedProposal.getProposalTxId()),
                        isVoteIncludedInResult,
                        bsqFormatter))
                .collect(Collectors.toList()));
        GUIUtil.setFitToRowsForTableView(proposalsTableView, 25, 28, 6, 100);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // TableColumns: CycleListItem
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void createCycleColumns(TableView<CycleListItem> votesTableView) {
        TableColumn<CycleListItem, CycleListItem> column;
        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.cycles.table.header.cycle""));
        column.setMinWidth(160);
        column.getStyleClass().add(""first-column"");
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getCycle());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(CycleListItem::getCycleStartTime));
        votesTableView.getColumns().add(column);

        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.cycles.table.header.numProposals""));
        column.setMinWidth(90);
        column.setMaxWidth(90);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getNumProposals());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(CycleListItem::getNumProposals));
        votesTableView.getColumns().add(column);

        column = new AutoTooltipTableColumn<>(Res.get(""shared.votes""));
        column.setMinWidth(70);
        column.setMaxWidth(70);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getNumVotesAsString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(CycleListItem::getNumVotesAsString));
        votesTableView.getColumns().add(column);

        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.cycles.table.header.voteWeight""));
        column.setMinWidth(70);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getMeritAndStake());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(CycleListItem::getMeritAndStake));
        votesTableView.getColumns().add(column);

        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.cycles.table.header.issuance""));
        column.setMinWidth(70);
        column.getStyleClass().add(""last-column"");
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<CycleListItem, CycleListItem> call(
                            TableColumn<CycleListItem, CycleListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final CycleListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getIssuance());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(CycleListItem::getIssuance));
        votesTableView.getColumns().add(column);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // TableColumns: ProposalListItem
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void createProposalsColumns(TableView<ProposalListItem> votesTableView) {
        TableColumn<ProposalListItem, ProposalListItem> column;

        column = new AutoTooltipTableColumn<>(Res.get(""shared.dateTime""));
        column.setMinWidth(160);
        column.getStyleClass().add(""first-column"");
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(DisplayUtils.formatDateTime(item.getProposal().getCreationDateAsDate()));
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(item -> item.getProposal().getCreationDateAsDate()));
        column.setSortType(TableColumn.SortType.DESCENDING);
        votesTableView.getColumns().add(column);
        votesTableView.getSortOrder().add(column);


        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.proposals.table.header.nameLink""));
        column.setMinWidth(130);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(TableColumn<ProposalListItem,
                            ProposalListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon field;

                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    Proposal proposal = item.getProposal();
                                    String link = proposal.getLink();
                                    String proposalOwnerName = item.getProposalOwnerName();
                                    String[] tokens = link.split(""/"");
                                    String nameLink = proposalOwnerName;
                                    if (tokens.length > 0) {
                                        String proposalNr = tokens[tokens.length - 1];
                                        nameLink += "" (#"" + proposalNr + "")"";
                                    }

                                    field = new ExternalHyperlink(nameLink);
                                    field.setOnAction(event -> GUIUtil.openWebPage(link));
                                    field.setTooltip(new Tooltip(proposalOwnerName + "" ("" + link + "")""));
                                    setGraphic(field);
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing((item -> item.getProposalOwnerName() + item.getProposal().getLink())));
        votesTableView.getColumns().add(column);


        column = new AutoTooltipTableColumn<>(Res.get(""dao.proposal.table.header.proposalType""));
        column.setMinWidth(150);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getProposal().getType().getShortDisplayName());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(o2 -> o2.getProposal().getType().getShortDisplayName()));
        votesTableView.getColumns().add(column);


        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.proposals.table.header.details""));
        column.setMinWidth(100);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getDetails());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        // We sort by issued amount
        column.setComparator(Comparator.comparing(ProposalListItem::getDetails));
        votesTableView.getColumns().add(column);


        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.proposals.table.header.myVote""));
        column.setMinWidth(60);
        column.setMaxWidth(column.getMinWidth());
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {

            @Override
            public TableCell<ProposalListItem, ProposalListItem> call(TableColumn<ProposalListItem,
                    ProposalListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProposalListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            setGraphic(item.getMyVoteIcon());
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });
        column.setSortable(false);
        votesTableView.getColumns().add(column);


        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.proposals.table.header.threshold""));
        column.setMinWidth(80);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getThresholdAsString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(ProposalListItem::getThreshold));
        votesTableView.getColumns().add(column);


        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.proposals.table.header.quorum""));
        column.setMinWidth(90);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<ProposalListItem, ProposalListItem> call(
                            TableColumn<ProposalListItem, ProposalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final ProposalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getQuorumAsString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        column.setComparator(Comparator.comparing(ProposalListItem::getQuorum));
        votesTableView.getColumns().add(column);


        column = new AutoTooltipTableColumn<>(Res.get(""dao.results.proposals.table.header.result""));
        column.setMinWidth(80);
        column.setMaxWidth(column.getMinWidth());
        column.getStyleClass().add(""last-column"");
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProposalListItem, ProposalListItem> call(TableColumn<ProposalListItem,
                    ProposalListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProposalListItem item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null && !empty) {
                            Label icon = new Label();
                            AwesomeDude.setIcon(icon, item.getIcon());
                            icon.getStyleClass().add(item.getColorStyleClass());
                            setGraphic(icon);
                        } else {
                            setGraphic(null);
                        }
                    }
                };
            }
        });
        column.setComparator(Comparator.comparing(ProposalListItem::isAccepted));
        votesTableView.getColumns().add(column);
    }

    private JsonElement getVotingHistoryJson() {
        JsonArray cyclesArray = new JsonArray();

        sortedCycleListItemList.sorted(Comparator.comparing(CycleListItem::getCycleStartTime)).forEach(cycleListItem -> {
            JsonObject cycleJson = new JsonObject();
            // No domain data, taken from UI model
            // TODO move the data structure needed for UI to core and use as pure domain model and use that here
            cycleJson.addProperty(""cycleIndex"", cycleListItem.getCycleIndex());
            cycleJson.addProperty(""cycleDateTime"", cycleListItem.getCycleDateTime(false));
            cycleJson.addProperty(""votesCount"", cycleListItem.getNumVotesAsString());
            cycleJson.addProperty(""voteWeight"", cycleListItem.getMeritAndStake());
            cycleJson.addProperty(""issuance"", cycleListItem.getIssuance());
            cycleJson.addProperty(""startTime"", cycleListItem.getCycleStartTime());
            cycleJson.addProperty(""totalAcceptedVotes"", cycleListItem.getResultsOfCycle().getNumAcceptedVotes());
            cycleJson.addProperty(""totalRejectedVotes"", cycleListItem.getResultsOfCycle().getNumRejectedVotes());

            JsonArray proposalsArray = new JsonArray();
            List<EvaluatedProposal> evaluatedProposals = cycleListItem.getResultsOfCycle().getEvaluatedProposals();
            evaluatedProposals.sort(Comparator.comparingLong(o -> o.getProposal().getCreationDate()));

            evaluatedProposals.forEach(evaluatedProp -> {
                JsonObject proposalJson = new JsonObject();
                proposalJson.addProperty(""isAccepted"", evaluatedProp.isAccepted() ? ""Accepted"" : ""Rejected"");

                // Proposal
                Proposal proposal = evaluatedProp.getProposal();
                proposalJson.addProperty(""proposal.name"", proposal.getName());
                proposalJson.addProperty(""proposal.link"", proposal.getLink());
                proposalJson.addProperty(""proposal.version"", proposal.getVersion());
                proposalJson.addProperty(""proposal.creationDate"", proposal.getCreationDate());
                proposalJson.addProperty(""proposal.txId"", proposal.getTxId());
                proposalJson.addProperty(""proposal.txType"", proposal.getTxType().name());
                proposalJson.addProperty(""proposal.quorumParam"", proposal.getQuorumParam().name());
                proposalJson.addProperty(""proposal.thresholdParam"", proposal.getThresholdParam().name());
                proposalJson.addProperty(""proposal.proposalType"", proposal.getType().name());

                if (proposal.getExtraDataMap() != null)
                    proposalJson.addProperty(""proposal.extraDataMap"", proposal.getExtraDataMap().toString());

                switch (proposal.getType()) {
                    case UNDEFINED:
                        break;
                    case COMPENSATION_REQUEST:
                        CompensationProposal compensationProposal = (CompensationProposal) proposal;
                        proposalJson.addProperty(""proposal.requestedBsq"", compensationProposal.getRequestedBsq().getValue());
                        proposalJson.addProperty(""proposal.bsqAddress"", compensationProposal.getBsqAddress());
                        break;
                    case REIMBURSEMENT_REQUEST:
                        ReimbursementProposal reimbursementProposal = (ReimbursementProposal) proposal;
                        proposalJson.addProperty(""proposal.requestedBsq"", reimbursementProposal.getRequestedBsq().getValue());
                        proposalJson.addProperty(""proposal.bsqAddress"", reimbursementProposal.getBsqAddress());
                        break;
                    case CHANGE_PARAM:
                        ChangeParamProposal changeParamProposal = (ChangeParamProposal) proposal;
                        Param param = changeParamProposal.getParam();
                        proposalJson.addProperty(""proposal.param"", param.name());
                        proposalJson.addProperty(""proposal.param.defaultValue"", param.getDefaultValue());
                        proposalJson.addProperty(""proposal.param.type"", param.getParamType().name());
                        proposalJson.addProperty(""proposal.param.maxDecrease"", param.getMaxDecrease());
                        proposalJson.addProperty(""proposal.param.maxIncrease"", param.getMaxIncrease());
                        proposalJson.addProperty(""proposal.paramValue"", changeParamProposal.getParamValue());
                        break;
                    case BONDED_ROLE:
                        RoleProposal roleProposal = (RoleProposal) proposal;
                        Role role = roleProposal.getRole();
                        proposalJson.addProperty(""proposal.requiredBondUnit"", roleProposal.getRequiredBondUnit());
                        proposalJson.addProperty(""proposal.unlockTime"", roleProposal.getUnlockTime());
                        proposalJson.addProperty(""proposal.role.uid"", role.getUid());
                        proposalJson.addProperty(""proposal.role.name"", role.getName());
                        proposalJson.addProperty(""proposal.role.link"", role.getLink());
                        BondedRoleType bondedRoleType = role.getBondedRoleType();
                        proposalJson.addProperty(""proposal.bondedRoleType"", bondedRoleType.name());
                        // bondedRoleType enum must not change anyway so we don't print it
                        break;
                    case CONFISCATE_BOND:
                        ConfiscateBondProposal confiscateBondProposal = (ConfiscateBondProposal) proposal;
                        proposalJson.addProperty(""proposal.lockupTxId"", confiscateBondProposal.getLockupTxId());
                        break;
                    case GENERIC:
                        // No extra fields
                        break;
                    case REMOVE_ASSET:
                        RemoveAssetProposal removeAssetProposal = (RemoveAssetProposal) proposal;
                        proposalJson.addProperty(""proposal.tickerSymbol"", removeAssetProposal.getTickerSymbol());
                        break;
                }

                ProposalVoteResult proposalVoteResult = evaluatedProp.getProposalVoteResult();
                proposalJson.addProperty(""stakeOfAcceptedVotes"", proposalVoteResult.getStakeOfAcceptedVotes());
                proposalJson.addProperty(""stakeOfRejectedVotes"", proposalVoteResult.getStakeOfRejectedVotes());
                proposalJson.addProperty(""numAcceptedVotes"", proposalVoteResult.getNumAcceptedVotes());
                proposalJson.addProperty(""numRejectedVotes"", proposalVoteResult.getNumRejectedVotes());
                proposalJson.addProperty(""numIgnoredVotes"", proposalVoteResult.getNumIgnoredVotes());
                proposalJson.addProperty(""numActiveVotes"", proposalVoteResult.getNumActiveVotes());
                proposalJson.addProperty(""quorum"", proposalVoteResult.getQuorum());
                proposalJson.addProperty(""threshold"", proposalVoteResult.getThreshold());

                // Not part of pure domain data, but useful to add here
                // required quorum and threshold for cycle for proposal type
                proposalJson.addProperty(""requiredQuorum"", proposalService.getRequiredQuorum(proposal).value);
                proposalJson.addProperty(""requiredThreshold"", proposalService.getRequiredThreshold(proposal));

                // TODO provide better domain object as now we loop inside the loop. Use lookup map instead....
                JsonArray votesArray = new JsonArray();
                evaluatedProposals.stream()
                        .filter(evaluatedProposal -> evaluatedProposal.getProposal().equals(proposal))
                        .forEach(evaluatedProposal -> {
                            List<DecryptedBallotsWithMerits> decryptedVotesForCycle = cycleListItem.getResultsOfCycle().getDecryptedVotesForCycle();
                            // Make sure the votes are sorted so we can easier compare json files from different users
                            decryptedVotesForCycle.sort(Comparator.comparing(DecryptedBallotsWithMerits::getBlindVoteTxId));
                            decryptedVotesForCycle.forEach(decryptedBallotsWithMerits -> {
                                JsonObject voteJson = new JsonObject();
                                // Domain data of decryptedBallotsWithMerits
                                voteJson.addProperty(""hashOfBlindVoteList"", Utilities.bytesAsHexString(decryptedBallotsWithMerits.getHashOfBlindVoteList()));
                                voteJson.addProperty(""blindVoteTxId"", decryptedBallotsWithMerits.getBlindVoteTxId());
                                voteJson.addProperty(""voteRevealTxId"", decryptedBallotsWithMerits.getVoteRevealTxId());
                                voteJson.addProperty(""stake"", decryptedBallotsWithMerits.getStake());

                                voteJson.addProperty(""voteWeight"", decryptedBallotsWithMerits.getMerit(daoStateService));
                                String voteResult = decryptedBallotsWithMerits.getVote(evaluatedProp.getProposalTxId())
                                        .map(vote -> vote.isAccepted() ? ""Accepted"" : ""Rejected"")
                                        .orElse(""Ignored"");
                                voteJson.addProperty(""vote"", voteResult);
                                votesArray.add(voteJson);
                            });
                        });

                proposalJson.addProperty(""numberOfVotes"", votesArray.size());
                proposalJson.add(""votes"", votesArray);

                proposalsArray.add(proposalJson);
            });
            cycleJson.addProperty(""numberOfProposals"", proposalsArray.size());
            cycleJson.add(""proposals"", proposalsArray);
            cyclesArray.add(cycleJson);
        });
        return cyclesArray;
    }
}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 395 2005 123 437 381 2006 2007 59 437 381 2008 2009 59 437 381 2010 2011 59 437 381 2012 2013 59 437 381 2014 2015 59 437 381 2016 2017 59 437 381 2018 2019 59 437 381 2020 2021 59 437 381 2022 2023 59 437 381 2024 2025 59 437 2026 2027 59 437 404 2028 61 1500 59 437 2029 60 2030 62 2031 59 437 381 2032 60 2030 62 2033 61 2034 46 2035 40 41 59 437 381 2036 60 2030 62 2037 61 418 2036 60 62 40 2033 41 59 437 2029 60 2038 62 2039 59 437 381 2032 60 2038 62 2040 61 2034 46 2035 40 41 59 437 381 2036 60 2038 62 2041 61 418 2036 60 62 40 2040 41 59 437 381 2032 60 2042 62 2043 61 2034 46 2035 40 41 59 437 381 2036 60 2042 62 2044 61 418 2036 60 62 40 2043 41 59 437 2045 2046 59 437 2047 60 2030 62 2048 59 437 2049 2050 59 437 2038 2051 59 437 324 2052 59 437 381 2053 60 2054 62 2055 61 418 2056 60 62 40 41 59 437 324 2057 61 380 59 621 621 621 64 2058 439 2001 40 2006 2007 44 2008 2009 44 2010 2011 44 2012 2013 44 2014 2015 44 2016 2017 44 2018 2019 44 2020 2021 44 2022 2023 44 2024 2025 41 123 467 46 2007 61 2007 59 467 46 2009 61 2009 59 467 46 2011 61 2011 59 467 46 2013 61 2013 59 467 46 2015 61 2015 59 467 46 2017 61 2017 59 467 46 2019 61 2019 59 467 46 2021 61 2021 59 467 46 2023 61 2023 59 467 46 2025 61 2025 59 125 64 2059 439 492 2060 40 41 123 2028 61 2009 46 2061 40 2062 44 2028 41 59 2048 61 40 2063 44 2064 44 2065 41 45 62 2066 40 2065 41 59 2067 40 41 59 2027 61 2068 40 2062 44 637 2028 44 2069 46 2070 40 648 41 41 59 2027 46 2071 40 41 46 2072 40 648 41 59 2003 46 2073 40 2027 44 418 2074 40 1502 44 45 1502 44 45 1503 44 1500 41 41 59 2003 46 2075 40 2027 44 1502 41 59 2003 46 2076 40 2027 44 2077 46 2078 41 59 2025 46 2079 40 40 41 45 62 2039 46 2080 40 41 46 2081 40 41 41 59 125 64 2059 438 492 2082 40 41 123 463 46 2082 40 41 59 2009 46 2082 40 41 59 2007 46 2083 40 467 41 59 2031 46 2084 40 41 46 2085 40 41 46 2086 40 2048 41 59 392 40 2011 46 2087 40 41 41 123 2088 40 2011 46 2089 40 41 41 59 2090 40 41 59 125 2027 46 2091 40 373 45 62 123 2092 2093 61 2094 40 41 59 2095 46 2096 40 648 44 2093 44 40 2097 41 2098 46 2099 40 41 46 2100 40 41 41 59 125 41 59 392 40 2039 631 424 41 123 2101 46 2102 40 2039 44 1503 44 1503 44 1502 44 1502 41 59 2046 61 2103 46 2104 40 2039 46 2084 40 41 46 2085 40 41 44 467 58 58 2105 41 59 125 2106 46 2107 40 2031 44 1503 44 1503 44 1502 44 1502 41 59 125 64 2059 438 492 2108 40 41 123 463 46 2108 40 41 59 2009 46 2108 40 41 59 2007 46 2109 40 467 41 59 2031 46 2110 40 41 46 2111 40 41 46 2112 40 2048 41 59 392 40 2046 631 424 41 2046 46 2113 40 41 59 2027 46 2114 40 424 41 59 125 621 621 621 64 2059 439 492 2115 40 2116 2117 41 123 2118 40 2011 46 2119 40 41 41 59 2120 40 41 59 125 437 492 2121 40 404 2122 41 123 392 40 2019 46 2123 40 2122 44 2124 46 2125 46 2126 41 41 123 392 40 33 2057 41 123 2057 61 473 59 621 621 2127 60 2054 62 2128 61 2055 46 2129 40 41 46 2130 40 2131 45 62 2131 46 2132 40 2122 41 41 46 2133 40 41 59 2128 46 2134 40 2055 58 58 2135 41 59 2127 60 2030 62 2136 61 2033 46 2129 40 41 46 2130 40 2137 45 62 2137 46 2138 40 41 46 2139 40 41 46 2132 40 2122 41 41 46 2133 40 41 59 2136 46 2134 40 2033 58 58 2135 41 59 125 125 360 123 621 2057 61 380 59 125 125 621 621 621 437 492 2140 40 2030 2141 41 123 392 40 2046 631 424 41 2046 46 2142 40 41 59 2143 46 2144 40 2145 44 1502 44 2028 41 59 2028 61 1502 59 392 40 2141 631 424 41 123 2050 61 2141 46 2146 40 41 59 621 2052 61 380 59 2050 46 2147 40 41 46 2148 40 2149 45 62 2050 46 2150 40 41 46 2148 40 2151 45 62 123 621 392 40 33 2052 41 123 2052 61 2021 46 2152 40 2151 46 2153 40 41 41 46 2154 40 41 59 125 125 41 41 59 2155 40 2141 46 2146 40 41 46 2156 40 41 41 59 2157 40 41 59 2046 61 2158 46 2159 40 2039 46 2160 40 41 46 2161 40 41 44 467 58 58 2162 41 59 2163 2164 61 418 2163 40 41 59 2015 46 2165 40 41 46 2166 40 41 46 2167 40 2168 45 62 2019 46 2169 40 2168 46 2170 40 41 44 2141 46 2146 40 41 46 2156 40 41 46 2171 40 41 41 41 46 2148 40 2168 45 62 123 2164 46 2172 40 648 41 46 2172 40 2173 46 2174 40 648 41 41 46 2172 40 648 41 46 2172 40 2168 46 2175 40 41 41 46 2172 40 648 41 46 2172 40 2173 46 2174 40 648 41 41 46 2172 40 648 41 46 2172 40 2023 46 2176 40 2177 46 2178 40 2168 46 2179 40 41 41 41 41 46 2172 40 648 41 59 2168 46 2180 40 41 46 2166 40 41 46 2148 40 2181 45 62 123 2164 46 2172 40 2173 46 2174 40 648 41 41 46 2172 40 648 41 46 2172 40 2173 46 2174 40 648 41 41 46 2172 40 648 41 46 2172 40 2181 46 2182 40 41 46 2183 40 41 41 46 2172 40 648 41 59 2164 46 2172 40 2173 46 2174 40 648 41 41 46 2172 40 648 41 46 2172 40 2181 46 2182 40 41 46 2184 40 41 41 46 2172 40 648 41 59 2185 2186 61 2181 46 2187 40 41 59 2188 2189 61 2186 614 424 63 2173 46 2190 40 648 41 58 2186 46 2191 40 41 63 2173 46 2190 40 648 41 58 2173 46 2190 40 648 41 59 2164 46 2172 40 2173 46 2174 40 648 41 41 46 2172 40 648 41 46 2172 40 2189 41 46 2172 40 648 41 59 125 41 59 125 41 59 392 40 2164 46 2192 40 41 631 1500 41 123 418 2193 40 41 46 2194 40 2195 46 2196 40 648 44 2164 46 2197 40 41 41 41 46 2198 40 41 59 125 125 125 437 492 2199 40 2054 2200 41 123 2201 60 2202 62 2203 61 2015 46 2204 40 41 46 2205 40 41 46 2206 40 2207 45 62 2200 46 2208 40 41 614 2207 46 2209 40 41 41 46 2210 40 2211 46 2212 40 41 41 59 392 40 33 2203 46 2213 40 41 41 123 2214 2215 61 2216 46 2217 40 2218 44 637 2028 44 648 41 59 2003 46 2219 40 2215 44 418 2220 40 2221 46 2222 44 45 1503 44 1500 44 45 1502 41 41 59 2215 46 2223 40 1503 41 59 2224 2225 61 418 2224 40 2226 46 2227 40 648 41 43 648 41 59 2203 46 2228 40 2229 45 62 123 392 40 2229 46 2230 40 41 631 424 41 2225 46 2231 40 2229 46 2230 40 41 46 2232 40 41 41 59 360 2225 46 2231 40 2229 46 2232 40 41 41 59 2225 46 2231 40 648 41 59 125 41 59 2215 46 2233 40 2225 46 2234 40 41 41 59 125 125 437 492 2235 40 2038 2141 41 123 2051 61 2141 59 392 40 2051 631 424 41 123 2236 2237 61 2051 46 2238 40 41 59 2239 60 2240 62 2241 61 2007 46 2242 40 41 46 2243 40 41 46 2244 40 2245 45 62 2245 46 2246 40 41 46 2247 40 2237 46 2248 40 41 41 41 46 2249 40 41 59 2240 2245 61 2241 46 2250 40 424 41 59 2043 46 2251 40 41 59 2050 46 2252 40 41 46 2243 40 41 46 2244 40 2253 45 62 2253 46 2254 40 41 46 2247 40 2051 46 2238 40 41 46 2254 40 41 41 41 46 2255 40 2253 45 62 2050 46 2256 40 41 46 2255 40 2257 45 62 2043 46 2258 40 418 2042 40 2253 46 2254 40 41 44 2257 44 2011 44 2023 41 41 41 41 59 2043 46 2259 40 2260 46 2261 40 2042 58 58 2262 41 41 59 2263 40 2237 44 2245 44 2052 44 2044 41 59 125 125 437 492 2264 40 2265 2266 44 2267 2268 44 324 2052 44 2036 60 2042 62 2044 41 123 2025 46 2269 40 2266 44 2268 44 2052 44 2044 41 59 125 621 621 621 437 492 2270 40 41 123 621 392 40 2055 46 2271 40 41 41 123 2272 46 2273 40 467 58 58 2274 44 1503 44 2275 46 2276 41 59 125 360 123 2277 40 41 59 125 125 437 492 2278 40 41 123 621 2011 46 2279 40 41 46 2280 40 41 46 2281 40 2200 45 62 33 2055 46 2282 40 2200 41 41 46 2283 40 2200 45 62 123 2284 60 2285 62 2286 61 2017 46 2287 40 41 46 2280 40 41 46 2281 40 2288 45 62 2013 46 2289 40 2200 44 2288 46 2290 40 41 41 41 46 2291 40 2292 46 2293 40 41 41 59 2284 60 2265 62 2294 61 2011 46 2295 40 41 46 2280 40 41 46 2281 40 2266 45 62 2013 46 2289 40 2200 44 2266 46 2296 40 41 46 2290 40 41 41 41 46 2291 40 2292 46 2293 40 41 41 59 2297 2298 61 418 2297 40 41 59 2284 60 2299 62 2300 61 2011 46 2301 40 41 46 2280 40 41 46 2281 40 2302 45 62 2013 46 2289 40 2200 44 2302 46 2303 40 41 41 41 46 2281 40 2302 45 62 2013 46 2289 40 2200 44 2302 46 2304 40 41 41 41 46 2305 40 2302 45 62 2298 46 2306 40 2302 46 2307 40 41 43 2302 46 2308 40 2011 41 41 41 46 2291 40 2292 46 2293 40 41 41 59 413 2309 61 2011 46 2310 40 2200 46 2311 40 41 41 59 404 2312 61 2013 46 2313 40 2200 41 59 2049 2050 61 418 2049 40 2200 44 2312 44 2309 44 2286 44 2294 44 2300 44 2298 46 2314 40 41 44 2011 41 59 2030 2315 61 418 2030 40 2050 44 2023 41 59 2033 46 2316 40 2315 41 59 2055 46 2316 40 2050 46 2317 40 41 41 59 125 41 59 2033 46 2318 40 2319 46 2320 40 2321 45 62 40 40 2030 41 2321 41 46 2322 40 41 46 2323 40 41 41 46 2324 40 41 41 59 2325 46 2326 40 2031 44 1503 44 1503 44 1502 44 1502 41 59 125 621 621 621 437 492 2327 40 41 123 2328 2329 61 418 2328 40 2330 46 2331 40 648 41 41 59 2003 46 2332 40 2329 44 637 2028 41 59 2003 46 2333 40 2329 44 418 2334 40 2335 46 2336 44 45 1502 44 45 1502 44 45 1502 41 41 59 2003 46 2337 40 2329 44 1502 41 59 2338 46 2339 40 41 46 2340 40 2329 41 59 2031 61 418 2029 60 62 40 41 59 2031 46 2341 40 418 2342 40 2330 46 2331 40 648 41 41 41 59 2031 46 2343 40 2029 46 2344 41 59 2345 40 2031 41 59 2003 46 2332 40 2031 44 2028 41 59 2003 46 2333 40 2031 44 418 2334 40 2335 46 2346 44 45 1502 44 45 1503 44 45 1502 41 41 59 2003 46 2337 40 2031 44 1502 41 59 2003 46 2347 40 2031 44 2348 46 2349 41 59 2338 46 2339 40 41 46 2340 40 2031 41 59 2031 46 2350 40 2037 41 59 2037 46 2351 40 41 46 2352 40 2031 46 2351 40 41 41 59 125 621 621 621 437 492 2353 40 41 123 2354 2355 61 418 2354 40 2356 46 2357 40 648 41 41 59 2003 46 2358 40 2355 44 637 2028 41 59 2003 46 2359 40 2355 44 418 2360 40 2361 46 2362 44 45 1502 44 45 1502 44 45 1502 41 41 59 2003 46 2363 40 2355 44 1502 41 59 2364 46 2365 40 41 46 2366 40 2355 41 59 2039 61 418 2029 60 62 40 41 59 2039 46 2367 40 418 2368 40 2356 46 2357 40 648 41 41 41 59 2039 46 2369 40 2029 46 2370 41 59 2371 40 2039 41 59 2003 46 2358 40 2039 44 2028 41 59 2003 46 2359 40 2039 44 418 2360 40 2361 46 2372 44 45 1502 44 1500 44 45 1502 41 41 59 2003 46 2363 40 2039 44 1502 41 59 2003 46 2373 40 2039 44 2374 46 2375 41 59 2364 46 2365 40 41 46 2366 40 2039 41 59 2039 46 2376 40 2041 41 59 2041 46 2377 40 41 46 2378 40 2039 46 2377 40 41 41 59 2040 46 2379 40 2038 58 58 2380 41 59 2040 46 2381 40 41 59 2382 60 2383 44 2267 62 2384 61 2007 46 2385 40 41 46 2386 40 41 46 2387 40 2388 46 2389 40 2267 58 58 2390 44 2268 45 62 2268 41 41 59 2040 46 2391 40 2050 46 2392 40 41 46 2386 40 41 46 2393 40 2266 45 62 123 324 2394 61 2384 46 2394 40 2266 46 2395 40 41 41 59 621 621 392 40 33 2394 41 2396 46 2397 40 648 44 2266 46 2395 40 41 41 59 450 2394 59 125 41 46 2398 40 2266 45 62 418 2038 40 2266 44 2384 46 2357 40 2266 46 2399 40 41 41 44 2052 44 2023 41 41 46 2387 40 2388 46 2400 40 41 41 41 59 2401 46 2402 40 2039 44 1503 44 1503 44 1502 44 1503 41 59 125 621 621 621 437 492 2403 40 2029 60 2030 62 2404 41 123 2405 60 2030 44 2030 62 2406 59 2406 61 418 2407 60 62 40 2408 46 2409 40 648 41 41 59 2406 46 2410 40 1504 41 59 2406 46 2411 40 41 46 2412 40 648 41 59 2406 46 2413 40 40 2141 41 45 62 418 2414 60 62 40 2141 46 2415 40 41 41 41 59 2406 46 2416 40 418 2417 60 62 40 41 123 64 2059 439 2418 60 2030 44 2030 62 2419 40 2405 60 2030 44 2030 62 2406 41 123 450 418 2418 60 62 40 41 123 64 2059 439 492 2420 40 381 2030 2141 44 324 362 41 123 463 46 2420 40 2141 44 362 41 59 392 40 2141 631 424 41 2421 40 2141 46 2422 40 41 41 59 360 2421 40 648 41 59 125 125 59 125 125 41 59 2406 46 2423 40 2424 46 2425 40 2030 58 58 2426 41 41 59 2404 46 2427 40 41 46 2412 40 2406 41 59 2406 61 418 2407 60 62 40 2408 46 2409 40 648 41 41 59 2406 46 2410 40 1503 41 59 2406 46 2428 40 1503 41 59 2406 46 2413 40 40 2141 41 45 62 418 2414 60 62 40 2141 46 2415 40 41 41 41 59 2406 46 2416 40 418 2417 60 62 40 41 123 64 2059 439 2429 60 2030 44 2030 62 2430 40 2405 60 2030 44 2030 62 2406 41 123 450 418 2429 60 62 40 41 123 64 2059 439 492 2431 40 381 2030 2141 44 324 362 41 123 463 46 2431 40 2141 44 362 41 59 392 40 2141 631 424 41 2432 40 2141 46 2433 40 41 41 59 360 2432 40 648 41 59 125 125 59 125 125 41 59 2406 46 2423 40 2424 46 2425 40 2030 58 58 2434 41 41 59 2404 46 2427 40 41 46 2412 40 2406 41 59 2406 61 418 2407 60 62 40 2408 46 2409 40 648 41 41 59 2406 46 2410 40 1503 41 59 2406 46 2428 40 1503 41 59 2406 46 2413 40 40 2141 41 45 62 418 2414 60 62 40 2141 46 2415 40 41 41 41 59 2406 46 2416 40 418 2417 60 62 40 41 123 64 2059 439 2435 60 2030 44 2030 62 2436 40 2405 60 2030 44 2030 62 2406 41 123 450 418 2435 60 62 40 41 123 64 2059 439 492 2437 40 381 2030 2141 44 324 362 41 123 463 46 2437 40 2141 44 362 41 59 392 40 2141 631 424 41 2438 40 2141 46 2439 40 41 41 59 360 2438 40 648 41 59 125 125 59 125 125 41 59 2406 46 2423 40 2424 46 2425 40 2030 58 58 2440 41 41 59 2404 46 2427 40 41 46 2412 40 2406 41 59 2406 61 418 2407 60 62 40 2408 46 2409 40 648 41 41 59 2406 46 2410 40 1503 41 59 2406 46 2413 40 40 2141 41 45 62 418 2414 60 62 40 2141 46 2415 40 41 41 41 59 2406 46 2416 40 418 2417 60 62 40 41 123 64 2059 439 2441 60 2030 44 2030 62 2442 40 2405 60 2030 44 2030 62 2406 41 123 450 418 2441 60 62 40 41 123 64 2059 439 492 2443 40 381 2030 2141 44 324 362 41 123 463 46 2443 40 2141 44 362 41 59 392 40 2141 631 424 41 2444 40 2141 46 2445 40 41 41 59 360 2444 40 648 41 59 125 125 59 125 125 41 59 2406 46 2423 40 2424 46 2425 40 2030 58 58 2446 41 41 59 2404 46 2427 40 41 46 2412 40 2406 41 59 2406 61 418 2407 60 62 40 2408 46 2409 40 648 41 41 59 2406 46 2410 40 1503 41 59 2406 46 2411 40 41 46 2412 40 648 41 59 2406 46 2413 40 40 2141 41 45 62 418 2414 60 62 40 2141 46 2415 40 41 41 41 59 2406 46 2416 40 418 2417 60 62 40 41 123 64 2059 439 2447 60 2030 44 2030 62 2448 40 2405 60 2030 44 2030 62 2406 41 123 450 418 2447 60 62 40 41 123 64 2059 439 492 2449 40 381 2030 2141 44 324 362 41 123 463 46 2449 40 2141 44 362 41 59 392 40 2141 631 424 41 2450 40 2141 46 2451 40 41 41 59 360 2450 40 648 41 59 125 125 59 125 125 41 59 2406 46 2423 40 2424 46 2425 40 2030 58 58 2452 41 41 59 2404 46 2427 40 41 46 2412 40 2406 41 59 125 621 621 621 437 492 2453 40 2029 60 2038 62 2404 41 123 2454 60 2038 44 2038 62 2455 59 2455 61 418 2456 60 62 40 2457 46 2458 40 648 41 41 59 2455 46 2459 40 1504 41 59 2455 46 2460 40 41 46 2461 40 648 41 59 2455 46 2462 40 40 2141 41 45 62 418 2463 60 62 40 2141 46 2464 40 41 41 41 59 2455 46 2465 40 418 2466 60 62 40 41 123 64 2059 439 2467 60 2038 44 2038 62 2468 40 2454 60 2038 44 2038 62 2455 41 123 450 418 2467 60 62 40 41 123 64 2059 439 492 2469 40 381 2038 2141 44 324 362 41 123 463 46 2469 40 2141 44 362 41 59 392 40 2141 631 424 41 2470 40 2471 46 2472 40 2141 46 2473 40 41 46 2474 40 41 41 41 59 360 2470 40 648 41 59 125 125 59 125 125 41 59 2455 46 2475 40 2476 46 2477 40 2141 45 62 2141 46 2478 40 41 46 2479 40 41 41 41 59 2455 46 2480 40 2454 46 2481 46 2482 41 59 2404 46 2483 40 41 46 2461 40 2455 41 59 2404 46 2484 40 41 46 2461 40 2455 41 59 2455 61 418 2456 60 62 40 2457 46 2458 40 648 41 41 59 2455 46 2459 40 1504 41 59 2455 46 2462 40 40 2141 41 45 62 418 2463 60 62 40 2141 46 2464 40 41 41 41 59 2455 46 2465 40 418 2466 60 62 40 41 123 64 2059 439 2485 60 2038 44 2038 62 2486 40 2454 60 2038 44 2038 62 2455 41 123 450 418 2485 60 62 40 41 123 437 2487 2488 59 64 2059 439 492 2489 40 381 2038 2141 44 324 362 41 123 463 46 2489 40 2141 44 362 41 59 392 40 2141 631 424 605 33 362 41 123 2490 2491 61 2141 46 2478 40 41 59 2492 2493 61 2491 46 2494 40 41 59 2492 2495 61 2141 46 2496 40 41 59 2492 91 93 2497 61 2493 46 2498 40 648 41 59 2492 2499 61 2495 59 392 40 2497 46 2500 62 1500 41 123 2492 2501 61 2497 91 2497 46 2500 45 1501 93 59 2499 636 648 43 2501 43 648 59 125 2488 61 418 2502 40 2499 41 59 2488 46 2503 40 373 45 62 2504 46 2505 40 2493 41 41 59 2488 46 2506 40 418 2507 40 2495 43 648 43 2493 43 648 41 41 59 2508 40 2488 41 59 125 360 123 2509 40 424 41 59 392 40 2488 631 424 41 2488 46 2510 40 424 41 59 125 125 125 59 125 125 41 59 2455 46 2475 40 2476 46 2477 40 40 2141 45 62 2141 46 2511 40 41 43 2141 46 2478 40 41 46 2512 40 41 41 41 41 59 2404 46 2483 40 41 46 2461 40 2455 41 59 2455 61 418 2456 60 62 40 2457 46 2458 40 648 41 41 59 2455 46 2459 40 1504 41 59 2455 46 2462 40 40 2141 41 45 62 418 2463 60 62 40 2141 46 2464 40 41 41 41 59 2455 46 2465 40 418 2466 60 62 40 41 123 64 2059 439 2513 60 2038 44 2038 62 2514 40 2454 60 2038 44 2038 62 2455 41 123 450 418 2513 60 62 40 41 123 64 2059 439 492 2515 40 381 2038 2141 44 324 362 41 123 463 46 2515 40 2141 44 362 41 59 392 40 2141 631 424 41 2516 40 2141 46 2478 40 41 46 2517 40 41 46 2518 40 41 41 59 360 2516 40 648 41 59 125 125 59 125 125 41 59 2455 46 2475 40 2476 46 2477 40 2519 45 62 2519 46 2478 40 41 46 2520 40 41 46 2521 40 41 41 41 59 2404 46 2483 40 41 46 2461 40 2455 41 59 2455 61 418 2456 60 62 40 2457 46 2458 40 648 41 41 59 2455 46 2459 40 1503 41 59 2455 46 2462 40 40 2141 41 45 62 418 2463 60 62 40 2141 46 2464 40 41 41 41 59 2455 46 2465 40 418 2466 60 62 40 41 123 64 2059 439 2522 60 2038 44 2038 62 2523 40 2454 60 2038 44 2038 62 2455 41 123 450 418 2522 60 62 40 41 123 64 2059 439 492 2524 40 381 2038 2141 44 324 362 41 123 463 46 2524 40 2141 44 362 41 59 392 40 2141 631 424 41 2525 40 2141 46 2526 40 41 41 59 360 2525 40 648 41 59 125 125 59 125 125 41 59 621 2455 46 2475 40 2476 46 2477 40 2038 58 58 2527 41 41 59 2404 46 2483 40 41 46 2461 40 2455 41 59 2455 61 418 2456 60 62 40 2457 46 2458 40 648 41 41 59 2455 46 2459 40 1503 41 59 2455 46 2528 40 2455 46 2529 40 41 41 59 2455 46 2462 40 40 2141 41 45 62 418 2463 60 62 40 2141 46 2464 40 41 41 41 59 2455 46 2465 40 418 2466 60 62 40 41 123 64 2059 439 2530 60 2038 44 2038 62 2531 40 2454 60 2038 44 2038 62 2455 41 123 450 418 2530 60 62 40 41 123 64 2059 439 492 2532 40 381 2038 2141 44 324 362 41 123 463 46 2532 40 2141 44 362 41 59 392 40 2141 631 424 605 33 362 41 123 2533 40 2141 46 2534 40 41 41 59 125 360 123 2535 40 424 41 59 125 125 125 59 125 125 41 59 2455 46 2536 40 380 41 59 2404 46 2483 40 41 46 2461 40 2455 41 59 2455 61 418 2456 60 62 40 2457 46 2458 40 648 41 41 59 2455 46 2459 40 1503 41 59 2455 46 2462 40 40 2141 41 45 62 418 2463 60 62 40 2141 46 2464 40 41 41 41 59 2455 46 2465 40 418 2466 60 62 40 41 123 64 2059 439 2537 60 2038 44 2038 62 2538 40 2454 60 2038 44 2038 62 2455 41 123 450 418 2537 60 62 40 41 123 64 2059 439 492 2539 40 381 2038 2141 44 324 362 41 123 463 46 2539 40 2141 44 362 41 59 392 40 2141 631 424 41 2540 40 2141 46 2541 40 41 41 59 360 2540 40 648 41 59 125 125 59 125 125 41 59 2455 46 2475 40 2476 46 2477 40 2038 58 58 2542 41 41 59 2404 46 2483 40 41 46 2461 40 2455 41 59 2455 61 418 2456 60 62 40 2457 46 2458 40 648 41 41 59 2455 46 2459 40 1503 41 59 2455 46 2462 40 40 2141 41 45 62 418 2463 60 62 40 2141 46 2464 40 41 41 41 59 2455 46 2465 40 418 2466 60 62 40 41 123 64 2059 439 2543 60 2038 44 2038 62 2544 40 2454 60 2038 44 2038 62 2455 41 123 450 418 2543 60 62 40 41 123 64 2059 439 492 2545 40 381 2038 2141 44 324 362 41 123 463 46 2545 40 2141 44 362 41 59 392 40 2141 631 424 41 2546 40 2141 46 2547 40 41 41 59 360 2546 40 648 41 59 125 125 59 125 125 41 59 2455 46 2475 40 2476 46 2477 40 2038 58 58 2548 41 41 59 2404 46 2483 40 41 46 2461 40 2455 41 59 2455 61 418 2456 60 62 40 2457 46 2458 40 648 41 41 59 2455 46 2459 40 1503 41 59 2455 46 2528 40 2455 46 2529 40 41 41 59 2455 46 2460 40 41 46 2461 40 648 41 59 2455 46 2462 40 40 2141 41 45 62 418 2463 60 62 40 2141 46 2464 40 41 41 41 59 2455 46 2465 40 418 2466 60 62 40 41 123 64 2059 439 2549 60 2038 44 2038 62 2550 40 2454 60 2038 44 2038 62 2455 41 123 450 418 2549 60 62 40 41 123 64 2059 439 492 2551 40 381 2038 2141 44 324 362 41 123 463 46 2551 40 2141 44 362 41 59 392 40 2141 631 424 605 33 362 41 123 2552 2553 61 418 2552 40 41 59 2554 46 2555 40 2553 44 2141 46 2556 40 41 41 59 2553 46 2460 40 41 46 2461 40 2141 46 2557 40 41 41 59 2558 40 2553 41 59 125 360 123 2559 40 424 41 59 125 125 125 59 125 125 41 59 2455 46 2475 40 2476 46 2477 40 2038 58 58 2560 41 41 59 2404 46 2483 40 41 46 2461 40 2455 41 59 125 437 2561 2562 40 41 123 2563 2564 61 418 2563 40 41 59 2037 46 2565 40 2566 46 2567 40 2030 58 58 2568 41 41 46 2569 40 2570 45 62 123 2571 2572 61 418 2571 40 41 59 621 621 2572 46 2573 40 648 44 2570 46 2574 40 41 41 59 2572 46 2573 40 648 44 2570 46 2575 40 380 41 41 59 2572 46 2573 40 648 44 2570 46 2576 40 41 41 59 2572 46 2573 40 648 44 2570 46 2577 40 41 41 59 2572 46 2573 40 648 44 2570 46 2578 40 41 41 59 2572 46 2573 40 648 44 2570 46 2568 40 41 41 59 2572 46 2573 40 648 44 2570 46 2579 40 41 46 2580 40 41 41 59 2572 46 2573 40 648 44 2570 46 2579 40 41 46 2581 40 41 41 59 2563 2582 61 418 2563 40 41 59 2583 60 2265 62 2584 61 2570 46 2579 40 41 46 2585 40 41 59 2584 46 2586 40 2566 46 2587 40 2588 45 62 2588 46 2589 40 41 46 2590 40 41 41 41 59 2584 46 2569 40 2591 45 62 123 2571 2592 61 418 2571 40 41 59 2592 46 2573 40 648 44 2591 46 2593 40 41 63 648 58 648 41 59 621 2594 2595 61 2591 46 2589 40 41 59 2592 46 2573 40 648 44 2595 46 2596 40 41 41 59 2592 46 2573 40 648 44 2595 46 2597 40 41 41 59 2592 46 2573 40 648 44 2595 46 2598 40 41 41 59 2592 46 2573 40 648 44 2595 46 2590 40 41 41 59 2592 46 2573 40 648 44 2595 46 2599 40 41 41 59 2592 46 2573 40 648 44 2595 46 2600 40 41 46 2601 40 41 41 59 2592 46 2573 40 648 44 2595 46 2602 40 41 46 2601 40 41 41 59 2592 46 2573 40 648 44 2595 46 2603 40 41 46 2601 40 41 41 59 2592 46 2573 40 648 44 2595 46 2604 40 41 46 2601 40 41 41 59 392 40 2595 46 2605 40 41 631 424 41 2592 46 2573 40 648 44 2595 46 2605 40 41 46 2606 40 41 41 59 464 40 2595 46 2604 40 41 41 123 328 2607 58 325 59 328 2608 58 2609 2610 61 40 2609 41 2595 59 2592 46 2573 40 648 44 2610 46 2611 40 41 46 2612 40 41 41 59 2592 46 2573 40 648 44 2610 46 2613 40 41 41 59 325 59 328 2614 58 2615 2616 61 40 2615 41 2595 59 2592 46 2573 40 648 44 2616 46 2611 40 41 46 2612 40 41 41 59 2592 46 2573 40 648 44 2616 46 2613 40 41 41 59 325 59 328 2617 58 2618 2619 61 40 2618 41 2595 59 2620 2621 61 2619 46 2622 40 41 59 2592 46 2573 40 648 44 2621 46 2601 40 41 41 59 2592 46 2573 40 648 44 2621 46 2623 40 41 41 59 2592 46 2573 40 648 44 2621 46 2624 40 41 46 2601 40 41 41 59 2592 46 2573 40 648 44 2621 46 2625 40 41 41 59 2592 46 2573 40 648 44 2621 46 2626 40 41 41 59 2592 46 2573 40 648 44 2619 46 2627 40 41 41 59 325 59 328 2628 58 2629 2630 61 40 2629 41 2595 59 2631 2632 61 2630 46 2633 40 41 59 2592 46 2573 40 648 44 2630 46 2634 40 41 41 59 2592 46 2573 40 648 44 2630 46 2635 40 41 41 59 2592 46 2573 40 648 44 2632 46 2636 40 41 41 59 2592 46 2573 40 648 44 2632 46 2596 40 41 41 59 2592 46 2573 40 648 44 2632 46 2597 40 41 41 59 2637 2638 61 2632 46 2639 40 41 59 2592 46 2573 40 648 44 2638 46 2601 40 41 41 59 621 325 59 328 2640 58 2641 2642 61 40 2641 41 2595 59 2592 46 2573 40 648 44 2642 46 2643 40 41 41 59 325 59 328 2644 58 621 325 59 328 2645 58 2646 2647 61 40 2646 41 2595 59 2592 46 2573 40 648 44 2647 46 2648 40 41 41 59 325 59 125 2649 2650 61 2591 46 2651 40 41 59 2592 46 2573 40 648 44 2650 46 2652 40 41 41 59 2592 46 2573 40 648 44 2650 46 2653 40 41 41 59 2592 46 2573 40 648 44 2650 46 2580 40 41 41 59 2592 46 2573 40 648 44 2650 46 2581 40 41 41 59 2592 46 2573 40 648 44 2650 46 2654 40 41 41 59 2592 46 2573 40 648 44 2650 46 2655 40 41 41 59 2592 46 2573 40 648 44 2650 46 2656 40 41 41 59 2592 46 2573 40 648 44 2650 46 2657 40 41 41 59 621 621 2592 46 2573 40 648 44 2017 46 2658 40 2595 41 46 2659 41 59 2592 46 2573 40 648 44 2017 46 2660 40 2595 41 41 59 621 2563 2661 61 418 2563 40 41 59 2584 46 2662 40 41 46 2663 40 2266 45 62 2266 46 2589 40 41 46 2664 40 2595 41 41 46 2569 40 2266 45 62 123 2583 60 2665 62 2666 61 2570 46 2579 40 41 46 2667 40 41 59 621 2666 46 2586 40 2566 46 2567 40 2665 58 58 2668 41 41 59 2666 46 2569 40 2669 45 62 123 2571 2670 61 418 2571 40 41 59 621 2670 46 2573 40 648 44 2671 46 2672 40 2669 46 2673 40 41 41 41 59 2670 46 2573 40 648 44 2669 46 2668 40 41 41 59 2670 46 2573 40 648 44 2669 46 2674 40 41 41 59 2670 46 2573 40 648 44 2669 46 2675 40 41 41 59 2670 46 2573 40 648 44 2669 46 2676 40 2011 41 41 59 2677 2678 61 2669 46 2679 40 2591 46 2680 40 41 41 46 2681 40 2682 45 62 2682 46 2593 40 41 63 648 58 648 41 46 2683 40 648 41 59 2670 46 2573 40 648 44 2678 41 59 2661 46 2684 40 2670 41 59 125 41 59 125 41 59 2592 46 2573 40 648 44 2661 46 2685 40 41 41 59 2592 46 2686 40 648 44 2661 41 59 2582 46 2686 40 2592 41 59 125 41 59 2572 46 2573 40 648 44 2582 46 2687 40 41 41 59 2572 46 2688 40 648 44 2582 41 59 2564 46 2688 40 2572 41 59 125 41 59 450 2564 59 125 125 
32707,Java,"@SuppressWarnings(""serial"")
public class StubbingUsingDoReturnTest extends TestBase {

    @Mock private IMethods mock;

    @After
    public void reset_state() {
        super.resetState();
    }

    @Test
    public void should_stub() throws Exception {
        doReturn(""foo"").when(mock).simpleMethod();
        doReturn(""bar"").when(mock).simpleMethod();

        Assertions.assertThat(mock.simpleMethod()).isEqualTo(""bar"");
    }

    @Test
    public void should_stub_with_args() throws Exception {
        doReturn(""foo"").when(mock).simpleMethod(""foo"");
        doReturn(""bar"").when(mock).simpleMethod(eq(""one""), anyInt());

        Assertions.assertThat(mock.simpleMethod(""foo"")).isEqualTo(""foo"");
        Assertions.assertThat(mock.simpleMethod(""one"", 234)).isEqualTo(""bar"");
        Assertions.assertThat(mock.simpleMethod(""xxx"", 234)).isEqualTo(null);
    }

    class FooRuntimeException extends RuntimeException {}

    @Test
    public void should_stub_with_throwable() throws Exception {
        doThrow(new FooRuntimeException()).when(mock).voidMethod();
        try {
            mock.voidMethod();
            fail();
        } catch (FooRuntimeException e) {
        }
    }

    @Test
    public void should_allow_setting_valid_checked_exception() throws Exception {
        doThrow(new IOException()).when(mock).throwsIOException(0);

        try {
            mock.throwsIOException(0);
            fail();
        } catch (IOException e) {
        }
    }

    class FooCheckedException extends Exception {}

    @Test
    public void should_detect_invalid_checked_exception() throws Exception {
        try {
            doThrow(new FooCheckedException()).when(mock).throwsIOException(0);
            fail();
        } catch (Exception e) {
            assertThat(e).hasMessageContaining(""Checked exception is invalid"");
        }
    }

    @Test
    public void should_scream_when_return_set_for_void() throws Exception {
        try {
            doReturn(""foo"").when(mock).voidMethod();
            fail();
        } catch (MockitoException e) {
            assertThat(e).hasMessageContaining(""void method"").hasMessageContaining(""cannot"");
        }
    }

    @Test
    public void should_scream_when_not_a_mock_passed() throws Exception {
        try {
            doReturn(""foo"").when(""foo"").toString();
            fail();
        } catch (Exception e) {
            assertThat(e).hasMessageContaining(""Argument passed to when() is not a mock"");
        }
    }

    @Test
    public void should_scream_when_null_passed() throws Exception {
        try {
            doReturn(""foo"").when((Object) null).toString();
            fail();
        } catch (Exception e) {
            assertThat(e).hasMessageContaining(""Argument passed to when() is null"");
        }
    }

    @Test
    public void should_allow_chained_stubbing() {
        doReturn(""foo"").doThrow(new RuntimeException()).doReturn(""bar"").when(mock).simpleMethod();

        Assertions.assertThat(mock.simpleMethod()).isEqualTo(""foo"");
        try {
            mock.simpleMethod();
            fail();
        } catch (RuntimeException expected) {
        }

        Assertions.assertThat(mock.simpleMethod()).isEqualTo(""bar"");
        Assertions.assertThat(mock.simpleMethod()).isEqualTo(""bar"");
    }

    @Test
    public void should_allow_consecutive_return_values() {
        doReturn(""foo"", ""bar"")
                .doThrow(new RuntimeException())
                .doReturn(430L, new byte[0], ""qix"")
                .when(mock)
                .objectReturningMethodNoArgs();

        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(""foo"");
        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(""bar"");
        try {
            mock.objectReturningMethodNoArgs();
            fail(""exception not raised"");
        } catch (RuntimeException expected) {
        }

        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(430L);
        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(new byte[0]);
        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(""qix"");
        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(""qix"");
    }

    @Test
    public void should_allow_do_call_real_method_in_chained_stubbing() throws Exception {
        MethodsImpl methods = mock(MethodsImpl.class);
        doReturn(""A"").doCallRealMethod().when(methods).simpleMethod();

        Assertions.assertThat(methods.simpleMethod()).isEqualTo(""A"");
        Assertions.assertThat(methods.simpleMethod()).isEqualTo(null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void should_allow_chained_stubbing_with_exception_class() throws Exception {
        doReturn(""whatever"").doThrow(IllegalArgumentException.class).when(mock).simpleMethod();

        Assertions.assertThat(mock.simpleMethod()).isEqualTo(""whatever"");
        mock.simpleMethod();
    }

    @Test
    public void should_allow_chained_stubbing_on_void_methods() {
        doNothing().doNothing().doThrow(new RuntimeException()).when(mock).voidMethod();

        mock.voidMethod();
        mock.voidMethod();
        try {
            mock.voidMethod();
            fail();
        } catch (RuntimeException e) {
        }
        try {
            mock.voidMethod();
            fail();
        } catch (RuntimeException e) {
        }
    }

    @Test
    public void should_stub_with_generic_answer() {
        doAnswer(
                        new Answer<Object>() {
                            public Object answer(InvocationOnMock invocation) throws Throwable {
                                return ""foo"";
                            }
                        })
                .when(mock)
                .simpleMethod();

        Assertions.assertThat(mock.simpleMethod()).isEqualTo(""foo"");
    }

    @Test
    public void should_not_allow_do_nothing_on_non_voids() {
        try {
            doNothing().when(mock).simpleMethod();
            fail();
        } catch (MockitoException e) {
            assertThat(e).hasMessageContaining(""Only void methods can doNothing()"");
        }
    }

    @Test
    public void should_stubbing_be_treated_as_interaction() throws Exception {
        doReturn(""foo"").when(mock).simpleMethod();
        mock.simpleMethod();
        try {
            verifyNoMoreInteractions(mock);
            fail();
        } catch (NoInteractionsWanted e) {
        }
    }

    @Test
    public void should_verify_stubbed_call() throws Exception {
        doReturn(""foo"").when(mock).simpleMethod();
        mock.simpleMethod();
        mock.simpleMethod();

        verify(mock, times(2)).simpleMethod();
        verifyNoMoreInteractions(mock);
    }

    @Test
    public void should_allow_stubbing_to_string() throws Exception {
        doReturn(""test"").when(mock).toString();
        Assertions.assertThat(mock.toString()).isEqualTo(""test"");
    }

    @Test
    public void should_detect_invalid_return_type() throws Exception {
        try {
            doReturn(""foo"").when(mock).booleanObjectReturningMethod();
            fail();
        } catch (Exception e) {
            assertThat(e)
                    .hasMessageContaining(
                            ""String cannot be returned by booleanObjectReturningMethod()""
                                    + ""\n""
                                    + ""booleanObjectReturningMethod() should return Boolean"");
        }
    }

    @Test
    public void should_detect_when_null_assigned_to_boolean() throws Exception {
        try {
            doReturn(null).when(mock).intReturningMethod();
            fail();
        } catch (Exception e) {
            assertThat(e).hasMessageContaining(""null cannot be returned by intReturningMethod"");
        }
    }

    @Test
    public void should_allow_stubbing_when_types_match_signature() throws Exception {
        doReturn(""foo"").when(mock).objectReturningMethodNoArgs();
        doReturn(""foo"").when(mock).simpleMethod();
        doReturn(1).when(mock).intReturningMethod();
        doReturn(2).when(mock).intReturningMethod();
    }
}",1,64 2000 40 648 41 439 334 2001 378 2002 123 64 2003 437 2004 2005 59 64 2006 439 492 2007 40 41 123 463 46 2008 40 41 59 125 64 2009 439 492 2010 40 41 470 2011 123 2012 40 648 41 46 2013 40 2005 41 46 2014 40 41 59 2012 40 648 41 46 2013 40 2005 41 46 2014 40 41 59 2015 46 2016 40 2005 46 2014 40 41 41 46 2017 40 648 41 59 125 64 2009 439 492 2018 40 41 470 2011 123 2019 40 648 41 46 2020 40 2005 41 46 2021 40 648 41 59 2019 40 648 41 46 2020 40 2005 41 46 2021 40 2022 40 648 41 44 2023 40 41 41 59 2024 46 2025 40 2005 46 2021 40 648 41 41 46 2026 40 648 41 59 2024 46 2025 40 2005 46 2021 40 648 44 1504 41 41 46 2026 40 648 41 59 2024 46 2025 40 2005 46 2021 40 648 44 1504 41 41 46 2026 40 424 41 59 125 334 2027 378 2028 123 125 64 2009 439 492 2029 40 41 470 2011 123 2030 40 418 2027 40 41 41 46 2031 40 2005 41 46 2032 40 41 59 474 123 2005 46 2032 40 41 59 2033 40 41 59 125 329 40 2027 2034 41 123 125 125 64 2009 439 492 2035 40 41 470 2011 123 2036 40 418 2037 40 41 41 46 2038 40 2005 41 46 2039 40 1500 41 59 474 123 2005 46 2039 40 1500 41 59 2040 40 41 59 125 329 40 2037 2041 41 123 125 125 334 2042 378 2011 123 125 64 2009 439 492 2043 40 41 470 2011 123 474 123 2044 40 418 2042 40 41 41 46 2045 40 2005 41 46 2046 40 1500 41 59 2047 40 41 59 125 329 40 2011 2048 41 123 2049 40 2048 41 46 2050 40 648 41 59 125 125 64 2009 439 492 2051 40 41 470 2011 123 474 123 2052 40 648 41 46 2053 40 2005 41 46 2054 40 41 59 2055 40 41 59 125 329 40 2056 2057 41 123 2058 40 2057 41 46 2059 40 648 41 46 2059 40 648 41 59 125 125 64 2009 439 492 2060 40 41 470 2011 123 474 123 2061 40 648 41 46 2062 40 648 41 46 2063 40 41 59 2064 40 41 59 125 329 40 2011 2065 41 123 2066 40 2065 41 46 2067 40 648 41 59 125 125 64 2009 439 492 2068 40 41 470 2011 123 474 123 2069 40 648 41 46 2070 40 40 2071 41 424 41 46 2072 40 41 59 2073 40 41 59 125 329 40 2011 2074 41 123 2075 40 2074 41 46 2076 40 648 41 59 125 125 64 2009 439 492 2077 40 41 123 2078 40 648 41 46 2079 40 418 2028 40 41 41 46 2078 40 648 41 46 2080 40 2005 41 46 2081 40 41 59 2082 46 2083 40 2005 46 2081 40 41 41 46 2084 40 648 41 59 474 123 2005 46 2081 40 41 59 2085 40 41 59 125 329 40 2028 2086 41 123 125 2082 46 2083 40 2005 46 2081 40 41 41 46 2084 40 648 41 59 2082 46 2083 40 2005 46 2081 40 41 41 46 2084 40 648 41 59 125 64 2009 439 492 2087 40 41 123 2088 40 648 44 648 41 46 2089 40 418 2028 40 41 41 46 2088 40 1504 44 418 326 91 1500 93 44 648 41 46 2090 40 2005 41 46 2091 40 41 59 2092 46 2093 40 2005 46 2091 40 41 41 46 2094 40 648 41 59 2092 46 2093 40 2005 46 2091 40 41 41 46 2094 40 648 41 59 474 123 2005 46 2091 40 41 59 2095 40 648 41 59 125 329 40 2028 2096 41 123 125 2092 46 2093 40 2005 46 2091 40 41 41 46 2094 40 1504 41 59 2092 46 2093 40 2005 46 2091 40 41 41 46 2094 40 418 326 91 1500 93 41 59 2092 46 2093 40 2005 46 2091 40 41 41 46 2094 40 648 41 59 2092 46 2093 40 2005 46 2091 40 41 41 46 2094 40 648 41 59 125 64 2009 439 492 2097 40 41 470 2011 123 2098 2099 61 2005 40 2098 46 334 41 59 2100 40 648 41 46 2101 40 41 46 2102 40 2099 41 46 2103 40 41 59 2104 46 2105 40 2099 46 2103 40 41 41 46 2106 40 648 41 59 2104 46 2105 40 2099 46 2103 40 41 41 46 2106 40 424 41 59 125 64 2009 40 2107 61 2108 46 334 41 439 492 2109 40 41 470 2011 123 2110 40 648 41 46 2111 40 2108 46 334 41 46 2112 40 2005 41 46 2113 40 41 59 2114 46 2115 40 2005 46 2113 40 41 41 46 2116 40 648 41 59 2005 46 2113 40 41 59 125 64 2009 439 492 2117 40 41 123 2118 40 41 46 2118 40 41 46 2119 40 418 2028 40 41 41 46 2120 40 2005 41 46 2121 40 41 59 2005 46 2121 40 41 59 2005 46 2121 40 41 59 474 123 2005 46 2121 40 41 59 2122 40 41 59 125 329 40 2028 2123 41 123 125 474 123 2005 46 2121 40 41 59 2124 40 41 59 125 329 40 2028 2123 41 123 125 125 64 2009 439 492 2125 40 41 123 2126 40 418 2127 60 2128 62 40 41 123 439 2128 2129 40 2130 2131 41 470 2132 123 450 648 59 125 125 41 46 2133 40 2005 41 46 2134 40 41 59 2135 46 2136 40 2005 46 2134 40 41 41 46 2137 40 648 41 59 125 64 2009 439 492 2138 40 41 123 474 123 2139 40 41 46 2140 40 2005 41 46 2141 40 41 59 2142 40 41 59 125 329 40 2143 2144 41 123 2145 40 2144 41 46 2146 40 648 41 59 125 125 64 2009 439 492 2147 40 41 470 2011 123 2148 40 648 41 46 2149 40 2005 41 46 2150 40 41 59 2005 46 2150 40 41 59 474 123 2151 40 2005 41 59 2152 40 41 59 125 329 40 2153 2154 41 123 125 125 64 2009 439 492 2155 40 41 470 2011 123 2156 40 648 41 46 2157 40 2005 41 46 2158 40 41 59 2005 46 2158 40 41 59 2005 46 2158 40 41 59 2159 40 2005 44 2160 40 1502 41 41 46 2158 40 41 59 2161 40 2005 41 59 125 64 2009 439 492 2162 40 41 470 2011 123 2163 40 648 41 46 2164 40 2005 41 46 2165 40 41 59 2166 46 2167 40 2005 46 2165 40 41 41 46 2168 40 648 41 59 125 64 2009 439 492 2169 40 41 470 2011 123 474 123 2170 40 648 41 46 2171 40 2005 41 46 2172 40 41 59 2173 40 41 59 125 329 40 2011 2174 41 123 2175 40 2174 41 46 2176 40 648 43 648 43 648 41 59 125 125 64 2009 439 492 2177 40 41 470 2011 123 474 123 2178 40 424 41 46 2179 40 2005 41 46 2180 40 41 59 2181 40 41 59 125 329 40 2011 2182 41 123 2183 40 2182 41 46 2184 40 648 41 59 125 125 64 2009 439 492 2185 40 41 470 2011 123 2186 40 648 41 46 2187 40 2005 41 46 2188 40 41 59 2186 40 648 41 46 2187 40 2005 41 46 2189 40 41 59 2186 40 1501 41 46 2187 40 2005 41 46 2190 40 41 59 2186 40 1502 41 46 2187 40 2005 41 46 2190 40 41 59 125 125 
30563,Java,"public class OnXJava8Style {
  @interface Foo {
    String value() default """";
  }
  @interface Bar {
    String stuff() default """";
  }
  @interface Array {
    String[] value() default {};
  }
  @lombok.Getter() String a;
  @lombok.Setter() String b;
  @lombok.Setter() String c;
  @lombok.Setter() String d;
  @lombok.Getter() String e;
  @lombok.Getter() String f;
  @lombok.Getter() String g;
  @lombok.Getter() String h;
  @lombok.Getter() String i;
  public OnXJava8Style() {
    super();
  }
  public @Foo @java.lang.SuppressWarnings(""all"") String getA() {
    return this.a;
  }
  public @Foo() @java.lang.SuppressWarnings(""all"") void setB(final String b) {
    this.b = b;
  }
  public @java.lang.SuppressWarnings(""all"") void setC(final @Foo(""a"") String c) {
    this.c = c;
  }
  public @java.lang.SuppressWarnings(""all"") void setD(final @Bar(stuff = ""b"") String d) {
    this.d = d;
  }
  public @Foo(value = ""c"") @Bar(stuff = ""d"") @java.lang.SuppressWarnings(""all"") String getE() {
    return this.e;
  }
  public @Array @java.lang.SuppressWarnings(""all"") String getF() {
    return this.f;
  }
  public @Array() @java.lang.SuppressWarnings(""all"") String getG() {
    return this.g;
  }
  public @Array({}) @java.lang.SuppressWarnings(""all"") String getH() {
    return this.h;
  }
  public @Array({""a"", ""b""}) @java.lang.SuppressWarnings(""all"") String getI() {
    return this.i;
  }
}",1,439 334 2000 123 64 405 2001 123 2002 2003 40 41 349 648 59 125 64 405 2004 123 2005 2006 40 41 349 648 59 125 64 405 2007 123 2008 91 93 2009 40 41 349 123 125 59 125 64 2010 46 2011 40 41 2012 2013 59 64 2010 46 2014 40 41 2012 2015 59 64 2010 46 2014 40 41 2012 2016 59 64 2010 46 2014 40 41 2012 2017 59 64 2010 46 2011 40 41 2012 2018 59 64 2010 46 2011 40 41 2012 2019 59 64 2010 46 2011 40 41 2012 2020 59 64 2010 46 2011 40 41 2012 2021 59 64 2010 46 2011 40 41 2012 2022 59 439 2000 40 41 123 463 40 41 59 125 439 64 2001 64 2023 46 2024 46 2025 40 648 41 2012 2026 40 41 123 450 467 46 2013 59 125 439 64 2001 40 41 64 2023 46 2024 46 2025 40 648 41 492 2027 40 381 2012 2015 41 123 467 46 2015 61 2015 59 125 439 64 2023 46 2024 46 2025 40 648 41 492 2028 40 381 64 2001 40 648 41 2012 2016 41 123 467 46 2016 61 2016 59 125 439 64 2023 46 2024 46 2025 40 648 41 492 2029 40 381 64 2004 40 2030 61 648 41 2012 2017 41 123 467 46 2017 61 2017 59 125 439 64 2001 40 2031 61 648 41 64 2004 40 2030 61 648 41 64 2023 46 2024 46 2025 40 648 41 2012 2032 40 41 123 450 467 46 2018 59 125 439 64 2007 64 2023 46 2024 46 2025 40 648 41 2012 2033 40 41 123 450 467 46 2019 59 125 439 64 2007 40 41 64 2023 46 2024 46 2025 40 648 41 2012 2034 40 41 123 450 467 46 2020 59 125 439 64 2007 40 123 125 41 64 2023 46 2024 46 2025 40 648 41 2012 2035 40 41 123 450 467 46 2021 59 125 439 64 2007 40 123 648 44 648 125 41 64 2023 46 2024 46 2025 40 648 41 2012 2036 40 41 123 450 467 46 2022 59 125 125 
2982,Java,"@Slf4j
@AllArgsConstructor
@Singleton
public class User implements PersistedDataHost {
    private final PersistenceManager<UserPayload> persistenceManager;
    private final KeyRing keyRing;

    private ObservableSet<PaymentAccount> paymentAccountsAsObservable;
    private ObjectProperty<PaymentAccount> currentPaymentAccountProperty;

    private UserPayload userPayload = new UserPayload();
    private boolean isPaymentAccountImport = false;

    @Inject
    public User(PersistenceManager<UserPayload> persistenceManager, KeyRing keyRing) {
        this.persistenceManager = persistenceManager;
        this.keyRing = keyRing;
    }

    // for unit tests
    public User() {
        persistenceManager = null;
        keyRing = null;
    }

    @Override
    public void readPersisted(Runnable completeHandler) {
        checkNotNull(persistenceManager).readPersisted(""UserPayload"",
                persisted -> {
                    userPayload = persisted;
                    init();
                    completeHandler.run();
                },
                () -> {
                    init();
                    completeHandler.run();
                });
    }

    private void init() {
        checkNotNull(persistenceManager).initialize(userPayload, PersistenceManager.Source.PRIVATE);

        checkNotNull(userPayload.getPaymentAccounts(), ""userPayload.getPaymentAccounts() must not be null"");
        checkNotNull(userPayload.getAcceptedLanguageLocaleCodes(), ""userPayload.getAcceptedLanguageLocaleCodes() must not be null"");
        paymentAccountsAsObservable = FXCollections.observableSet(userPayload.getPaymentAccounts());
        currentPaymentAccountProperty = new SimpleObjectProperty<>(userPayload.getCurrentPaymentAccount());
        userPayload.setAccountId(String.valueOf(Math.abs(checkNotNull(keyRing).getPubKeyRing().hashCode())));

        // language setup
        if (!userPayload.getAcceptedLanguageLocaleCodes().contains(LanguageUtil.getDefaultLanguageLocaleAsCode()))
            userPayload.getAcceptedLanguageLocaleCodes().add(LanguageUtil.getDefaultLanguageLocaleAsCode());
        String english = LanguageUtil.getEnglishLanguageLocaleCode();
        if (!userPayload.getAcceptedLanguageLocaleCodes().contains(english))
            userPayload.getAcceptedLanguageLocaleCodes().add(english);

        paymentAccountsAsObservable.addListener((SetChangeListener<PaymentAccount>) change -> {
            userPayload.setPaymentAccounts(new HashSet<>(paymentAccountsAsObservable));
            requestPersistence();
        });
        currentPaymentAccountProperty.addListener((ov) -> {
            userPayload.setCurrentPaymentAccount(currentPaymentAccountProperty.get());
            requestPersistence();
        });

        // We create a default placeholder account for BSQ swaps. The account has not content, it is just used
        // so that the BsqSwap use case fits into the current domain
        addBsqSwapAccount();

        requestPersistence();
    }

    private void addBsqSwapAccount() {
        checkNotNull(userPayload.getPaymentAccounts(), ""userPayload.getPaymentAccounts() must not be null"");
        if (userPayload.getPaymentAccounts().stream()
                .anyMatch(paymentAccount -> paymentAccount instanceof BsqSwapAccount))
            return;

        var account = new BsqSwapAccount();
        account.init();
        account.setAccountName(Res.get(""BSQ_SWAP""));
        account.setSingleTradeCurrency(new CryptoCurrency(""BSQ"", ""BSQ""));
        addPaymentAccount(account);
    }

    public void requestPersistence() {
        if (persistenceManager != null)
            persistenceManager.requestPersistence();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Nullable
    public Arbitrator getAcceptedArbitratorByAddress(NodeAddress nodeAddress) {
        final List<Arbitrator> acceptedArbitrators = userPayload.getAcceptedArbitrators();
        if (acceptedArbitrators != null) {
            Optional<Arbitrator> arbitratorOptional = acceptedArbitrators.stream()
                    .filter(e -> e.getNodeAddress().equals(nodeAddress))
                    .findFirst();
            return arbitratorOptional.orElse(null);
        } else {
            return null;
        }
    }

    @Nullable
    public Mediator getAcceptedMediatorByAddress(NodeAddress nodeAddress) {
        final List<Mediator> acceptedMediators = userPayload.getAcceptedMediators();
        if (acceptedMediators != null) {
            Optional<Mediator> mediatorOptionalOptional = acceptedMediators.stream()
                    .filter(e -> e.getNodeAddress().equals(nodeAddress))
                    .findFirst();
            return mediatorOptionalOptional.orElse(null);
        } else {
            return null;
        }
    }

    @Nullable
    public RefundAgent getAcceptedRefundAgentByAddress(NodeAddress nodeAddress) {
        final List<RefundAgent> acceptedRefundAgents = userPayload.getAcceptedRefundAgents();
        if (acceptedRefundAgents != null) {
            Optional<RefundAgent> refundAgentOptional = acceptedRefundAgents.stream()
                    .filter(e -> e.getNodeAddress().equals(nodeAddress))
                    .findFirst();
            return refundAgentOptional.orElse(null);
        } else {
            return null;
        }
    }

    @Nullable
    public PaymentAccount findFirstPaymentAccountWithCurrency(TradeCurrency tradeCurrency) {
        if (userPayload.getPaymentAccounts() != null) {
            for (PaymentAccount paymentAccount : userPayload.getPaymentAccounts()) {
                for (TradeCurrency currency : paymentAccount.getTradeCurrencies()) {
                    if (currency.equals(tradeCurrency))
                        return paymentAccount;
                }
            }
            return null;
        } else {
            return null;
        }
    }

    public boolean hasPaymentAccountForCurrency(TradeCurrency tradeCurrency) {
        return findFirstPaymentAccountWithCurrency(tradeCurrency) != null;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Collection operations
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void addPaymentAccountIfNotExists(PaymentAccount paymentAccount) {
        if (!paymentAccountExists(paymentAccount)) {
            addPaymentAccount(paymentAccount);
            requestPersistence();
        }
    }

    public void addPaymentAccount(PaymentAccount paymentAccount) {
        paymentAccount.onAddToUser();

        boolean changed = paymentAccountsAsObservable.add(paymentAccount);
        setCurrentPaymentAccount(paymentAccount);
        if (changed)
            requestPersistence();
    }

    public void addImportedPaymentAccounts(Collection<PaymentAccount> paymentAccounts) {
        isPaymentAccountImport = true;

        boolean changed = paymentAccountsAsObservable.addAll(paymentAccounts);
        paymentAccounts.stream().findFirst().ifPresent(this::setCurrentPaymentAccount);
        if (changed)
            requestPersistence();

        isPaymentAccountImport = false;
    }

    public void removePaymentAccount(PaymentAccount paymentAccount) {
        boolean changed = paymentAccountsAsObservable.remove(paymentAccount);
        if (changed)
            requestPersistence();
    }

    public boolean addAcceptedArbitrator(Arbitrator arbitrator) {
        List<Arbitrator> arbitrators = userPayload.getAcceptedArbitrators();
        if (arbitrators != null && !arbitrators.contains(arbitrator) && !isMyOwnRegisteredArbitrator(arbitrator)) {
            arbitrators.add(arbitrator);
            requestPersistence();
            return true;
        } else {
            return false;
        }
    }

    public void removeAcceptedArbitrator(Arbitrator arbitrator) {
        if (userPayload.getAcceptedArbitrators() != null) {
            boolean changed = userPayload.getAcceptedArbitrators().remove(arbitrator);
            if (changed)
                requestPersistence();
        }
    }

    public void clearAcceptedArbitrators() {
        if (userPayload.getAcceptedArbitrators() != null) {
            userPayload.getAcceptedArbitrators().clear();
            requestPersistence();
        }
    }

    public boolean addAcceptedMediator(Mediator mediator) {
        List<Mediator> mediators = userPayload.getAcceptedMediators();
        if (mediators != null && !mediators.contains(mediator) && !isMyOwnRegisteredMediator(mediator)) {
            mediators.add(mediator);
            requestPersistence();
            return true;
        } else {
            return false;
        }
    }

    public void removeAcceptedMediator(Mediator mediator) {
        if (userPayload.getAcceptedMediators() != null) {
            boolean changed = userPayload.getAcceptedMediators().remove(mediator);
            if (changed)
                requestPersistence();
        }
    }

    public void clearAcceptedMediators() {
        if (userPayload.getAcceptedMediators() != null) {
            userPayload.getAcceptedMediators().clear();
            requestPersistence();
        }
    }

    public boolean addAcceptedRefundAgent(RefundAgent refundAgent) {
        List<RefundAgent> refundAgents = userPayload.getAcceptedRefundAgents();
        if (refundAgents != null && !refundAgents.contains(refundAgent) && !isMyOwnRegisteredRefundAgent(refundAgent)) {
            refundAgents.add(refundAgent);
            requestPersistence();
            return true;
        } else {
            return false;
        }
    }

    public void removeAcceptedRefundAgent(RefundAgent refundAgent) {
        if (userPayload.getAcceptedRefundAgents() != null) {
            boolean changed = userPayload.getAcceptedRefundAgents().remove(refundAgent);
            if (changed)
                requestPersistence();
        }
    }

    public void clearAcceptedRefundAgents() {
        if (userPayload.getAcceptedRefundAgents() != null) {
            userPayload.getAcceptedRefundAgents().clear();
            requestPersistence();
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Setters
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void setCurrentPaymentAccount(PaymentAccount paymentAccount) {
        currentPaymentAccountProperty.set(paymentAccount);
        requestPersistence();
    }

    public void setRegisteredArbitrator(@Nullable Arbitrator arbitrator) {
        userPayload.setRegisteredArbitrator(arbitrator);
        requestPersistence();
    }

    public void setRegisteredMediator(@Nullable Mediator mediator) {
        userPayload.setRegisteredMediator(mediator);
        requestPersistence();
    }

    public void setRegisteredRefundAgent(@Nullable RefundAgent refundAgent) {
        userPayload.setRegisteredRefundAgent(refundAgent);
        requestPersistence();
    }

    public void setDevelopersFilter(@Nullable Filter developersFilter) {
        userPayload.setDevelopersFilter(developersFilter);
        requestPersistence();
    }

    public void setDevelopersAlert(@Nullable Alert developersAlert) {
        userPayload.setDevelopersAlert(developersAlert);
        requestPersistence();
    }

    public void setDisplayedAlert(@Nullable Alert displayedAlert) {
        userPayload.setDisplayedAlert(displayedAlert);
        requestPersistence();
    }

    public void addMarketAlertFilter(MarketAlertFilter filter) {
        getMarketAlertFilters().add(filter);
        requestPersistence();
    }

    public void removeMarketAlertFilter(MarketAlertFilter filter) {
        getMarketAlertFilters().remove(filter);
        requestPersistence();
    }

    public void setPriceAlertFilter(PriceAlertFilter filter) {
        userPayload.setPriceAlertFilter(filter);
        requestPersistence();
    }

    public void removePriceAlertFilter() {
        userPayload.setPriceAlertFilter(null);
        requestPersistence();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Nullable
    public PaymentAccount getPaymentAccount(String paymentAccountId) {
        Optional<PaymentAccount> optional = userPayload.getPaymentAccounts() != null ?
                userPayload.getPaymentAccounts().stream().filter(e -> e.getId().equals(paymentAccountId)).findAny() :
                Optional.empty();
        return optional.orElse(null);
    }

    public String getAccountId() {
        return userPayload.getAccountId();
    }

    public ReadOnlyObjectProperty<PaymentAccount> currentPaymentAccountProperty() {
        return currentPaymentAccountProperty;
    }

    @Nullable
    public Set<PaymentAccount> getPaymentAccounts() {
        return userPayload.getPaymentAccounts();
    }

    public ObservableSet<PaymentAccount> getPaymentAccountsAsObservable() {
        return paymentAccountsAsObservable;
    }

    /**
     * If this user is an arbitrator it returns the registered arbitrator.
     *
     * @return The arbitrator registered for this user
     */
    @Nullable
    public Arbitrator getRegisteredArbitrator() {
        return userPayload.getRegisteredArbitrator();
    }

    @Nullable
    public Mediator getRegisteredMediator() {
        return userPayload.getRegisteredMediator();
    }

    @Nullable
    public RefundAgent getRegisteredRefundAgent() {
        return userPayload.getRegisteredRefundAgent();
    }

    @Nullable
    public List<Arbitrator> getAcceptedArbitrators() {
        return userPayload.getAcceptedArbitrators();
    }

    @Nullable
    public List<Mediator> getAcceptedMediators() {
        return userPayload.getAcceptedMediators();
    }

    @Nullable
    public List<RefundAgent> getAcceptedRefundAgents() {
        return userPayload.getAcceptedRefundAgents();
    }

    @Nullable
    public List<NodeAddress> getAcceptedArbitratorAddresses() {
        return userPayload.getAcceptedArbitrators() != null ?
                userPayload.getAcceptedArbitrators().stream().map(Arbitrator::getNodeAddress).collect(Collectors.toList()) :
                null;
    }

    @Nullable
    public List<NodeAddress> getAcceptedMediatorAddresses() {
        return userPayload.getAcceptedMediators() != null ?
                userPayload.getAcceptedMediators().stream().map(Mediator::getNodeAddress).collect(Collectors.toList()) :
                null;
    }

    @Nullable
    public List<NodeAddress> getAcceptedRefundAgentAddresses() {
        return userPayload.getAcceptedRefundAgents() != null ?
                userPayload.getAcceptedRefundAgents().stream().map(RefundAgent::getNodeAddress).collect(Collectors.toList()) :
                null;
    }

    public boolean hasAcceptedArbitrators() {
        return getAcceptedArbitrators() != null && !getAcceptedArbitrators().isEmpty();
    }

    public boolean hasAcceptedMediators() {
        return getAcceptedMediators() != null && !getAcceptedMediators().isEmpty();
    }

    public boolean hasAcceptedRefundAgents() {
        return getAcceptedRefundAgents() != null && !getAcceptedRefundAgents().isEmpty();
    }

    @Nullable
    public Filter getDevelopersFilter() {
        return userPayload.getDevelopersFilter();
    }

    @Nullable
    public Alert getDevelopersAlert() {
        return userPayload.getDevelopersAlert();
    }

    @Nullable
    public Alert getDisplayedAlert() {
        return userPayload.getDisplayedAlert();
    }

    public boolean isMyOwnRegisteredArbitrator(Arbitrator arbitrator) {
        return arbitrator.equals(userPayload.getRegisteredArbitrator());
    }

    public boolean isMyOwnRegisteredMediator(Mediator mediator) {
        return mediator.equals(userPayload.getRegisteredMediator());
    }

    public boolean isMyOwnRegisteredRefundAgent(RefundAgent refundAgent) {
        return refundAgent.equals(userPayload.getRegisteredRefundAgent());
    }

    public List<MarketAlertFilter> getMarketAlertFilters() {
        return userPayload.getMarketAlertFilters();
    }

    @Nullable
    public PriceAlertFilter getPriceAlertFilter() {
        return userPayload.getPriceAlertFilter();
    }

    public boolean isPaymentAccountImport() {
        return isPaymentAccountImport;
    }

    private boolean paymentAccountExists(PaymentAccount paymentAccount) {
        return getPaymentAccountsAsObservable().stream().anyMatch(e -> e.equals(paymentAccount));
    }

    public Cookie getCookie() {
        return userPayload.getCookie();
    }
}",1,64 2000 64 2001 64 2002 439 334 2003 395 2004 123 437 381 2005 60 2006 62 2007 59 437 381 2008 2009 59 437 2010 60 2011 62 2012 59 437 2013 60 2011 62 2014 59 437 2006 2015 61 418 2006 40 41 59 437 324 2016 61 380 59 64 2017 439 2003 40 2005 60 2006 62 2007 44 2008 2009 41 123 467 46 2007 61 2007 59 467 46 2009 61 2009 59 125 621 439 2003 40 41 123 2007 61 424 59 2009 61 424 59 125 64 2018 439 492 2019 40 2020 2021 41 123 2022 40 2007 41 46 2019 40 648 44 2023 45 62 123 2015 61 2023 59 2024 40 41 59 2021 46 2025 40 41 59 125 44 40 41 45 62 123 2026 40 41 59 2021 46 2027 40 41 59 125 41 59 125 437 492 2028 40 41 123 2029 40 2007 41 46 2030 40 2015 44 2005 46 2031 46 2032 41 59 2029 40 2015 46 2033 40 41 44 648 41 59 2029 40 2015 46 2034 40 41 44 648 41 59 2012 61 2035 46 2036 40 2015 46 2033 40 41 41 59 2014 61 418 2037 60 62 40 2015 46 2038 40 41 41 59 2015 46 2039 40 2040 46 2041 40 2042 46 2043 40 2029 40 2009 41 46 2044 40 41 46 2045 40 41 41 41 41 59 621 392 40 33 2015 46 2034 40 41 46 2046 40 2047 46 2048 40 41 41 41 2015 46 2034 40 41 46 2049 40 2047 46 2048 40 41 41 59 2040 2050 61 2047 46 2051 40 41 59 392 40 33 2015 46 2034 40 41 46 2046 40 2050 41 41 2015 46 2034 40 41 46 2049 40 2050 41 59 2012 46 2052 40 40 2053 60 2011 62 41 2054 45 62 123 2015 46 2055 40 418 2056 60 62 40 2012 41 41 59 2057 40 41 59 125 41 59 2014 46 2052 40 40 2058 41 45 62 123 2015 46 2059 40 2014 46 2060 40 41 41 59 2061 40 41 59 125 41 59 621 621 2062 40 41 59 2063 40 41 59 125 437 492 2064 40 41 123 2065 40 2015 46 2066 40 41 44 648 41 59 392 40 2015 46 2066 40 41 46 2067 40 41 46 2068 40 2069 45 62 2069 402 2070 41 41 450 59 490 2071 61 418 2070 40 41 59 2071 46 2028 40 41 59 2071 46 2072 40 2073 46 2074 40 648 41 41 59 2071 46 2075 40 418 2076 40 648 44 648 41 41 59 2077 40 2071 41 59 125 439 492 2078 40 41 123 392 40 2007 631 424 41 2007 46 2078 40 41 59 125 621 621 621 64 2079 439 2080 2081 40 2082 2083 41 123 381 2084 60 2080 62 2085 61 2015 46 2086 40 41 59 392 40 2085 631 424 41 123 2087 60 2080 62 2088 61 2085 46 2089 40 41 46 2090 40 2091 45 62 2091 46 2092 40 41 46 2093 40 2083 41 41 46 2094 40 41 59 450 2088 46 2095 40 424 41 59 125 360 123 450 424 59 125 125 64 2079 439 2096 2097 40 2082 2083 41 123 381 2098 60 2096 62 2099 61 2015 46 2100 40 41 59 392 40 2099 631 424 41 123 2101 60 2096 62 2102 61 2099 46 2103 40 41 46 2104 40 2105 45 62 2105 46 2106 40 41 46 2107 40 2083 41 41 46 2108 40 41 59 450 2102 46 2109 40 424 41 59 125 360 123 450 424 59 125 125 64 2079 439 2110 2111 40 2082 2083 41 123 381 2112 60 2110 62 2113 61 2015 46 2114 40 41 59 392 40 2113 631 424 41 123 2115 60 2110 62 2116 61 2113 46 2117 40 41 46 2118 40 2119 45 62 2119 46 2120 40 41 46 2121 40 2083 41 41 46 2122 40 41 59 450 2116 46 2123 40 424 41 59 125 360 123 450 424 59 125 125 64 2079 439 2011 2124 40 2125 2126 41 123 392 40 2015 46 2127 40 41 631 424 41 123 385 40 2011 2128 58 2015 46 2127 40 41 41 123 385 40 2125 2129 58 2128 46 2130 40 41 41 123 392 40 2129 46 2131 40 2126 41 41 450 2128 59 125 125 450 424 59 125 360 123 450 424 59 125 125 439 324 2132 40 2125 2126 41 123 450 2124 40 2126 41 631 424 59 125 621 621 621 439 492 2133 40 2011 2134 41 123 392 40 33 2135 40 2134 41 41 123 2136 40 2134 41 59 2078 40 41 59 125 125 439 492 2137 40 2011 2134 41 123 2134 46 2138 40 41 59 324 2139 61 2012 46 2140 40 2134 41 59 2141 40 2134 41 59 392 40 2139 41 2078 40 41 59 125 439 492 2142 40 2143 60 2011 62 2144 41 123 2016 61 473 59 324 2145 61 2012 46 2146 40 2144 41 59 2144 46 2147 40 41 46 2148 40 41 46 2149 40 467 58 58 2150 41 59 392 40 2145 41 2078 40 41 59 2016 61 380 59 125 439 492 2151 40 2011 2134 41 123 324 2152 61 2012 46 2153 40 2134 41 59 392 40 2152 41 2078 40 41 59 125 439 324 2154 40 2080 2155 41 123 2156 60 2080 62 2157 61 2015 46 2158 40 41 59 392 40 2157 631 424 605 33 2157 46 2159 40 2155 41 605 33 2160 40 2155 41 41 123 2157 46 2161 40 2155 41 59 2078 40 41 59 450 473 59 125 360 123 450 380 59 125 125 439 492 2162 40 2080 2155 41 123 392 40 2015 46 2163 40 41 631 424 41 123 324 2164 61 2015 46 2163 40 41 46 2165 40 2155 41 59 392 40 2164 41 2078 40 41 59 125 125 439 492 2166 40 41 123 392 40 2015 46 2167 40 41 631 424 41 123 2015 46 2167 40 41 46 2168 40 41 59 2078 40 41 59 125 125 439 324 2169 40 2096 2170 41 123 2171 60 2096 62 2172 61 2015 46 2173 40 41 59 392 40 2172 631 424 605 33 2172 46 2174 40 2170 41 605 33 2175 40 2170 41 41 123 2172 46 2176 40 2170 41 59 2078 40 41 59 450 473 59 125 360 123 450 380 59 125 125 439 492 2177 40 2096 2170 41 123 392 40 2015 46 2178 40 41 631 424 41 123 324 2179 61 2015 46 2178 40 41 46 2180 40 2170 41 59 392 40 2179 41 2078 40 41 59 125 125 439 492 2181 40 41 123 392 40 2015 46 2182 40 41 631 424 41 123 2015 46 2182 40 41 46 2183 40 41 59 2078 40 41 59 125 125 439 324 2184 40 2110 2185 41 123 2186 60 2110 62 2187 61 2015 46 2188 40 41 59 392 40 2187 631 424 605 33 2187 46 2189 40 2185 41 605 33 2190 40 2185 41 41 123 2187 46 2191 40 2185 41 59 2078 40 41 59 450 473 59 125 360 123 450 380 59 125 125 439 492 2192 40 2110 2185 41 123 392 40 2015 46 2193 40 41 631 424 41 123 324 2194 61 2015 46 2193 40 41 46 2195 40 2185 41 59 392 40 2194 41 2078 40 41 59 125 125 439 492 2196 40 41 123 392 40 2015 46 2197 40 41 631 424 41 123 2015 46 2197 40 41 46 2198 40 41 59 2078 40 41 59 125 125 621 621 621 439 492 2199 40 2011 2134 41 123 2014 46 2200 40 2134 41 59 2078 40 41 59 125 439 492 2201 40 64 2079 2080 2155 41 123 2015 46 2201 40 2155 41 59 2078 40 41 59 125 439 492 2202 40 64 2079 2096 2170 41 123 2015 46 2202 40 2170 41 59 2078 40 41 59 125 439 492 2203 40 64 2079 2110 2185 41 123 2015 46 2203 40 2185 41 59 2078 40 41 59 125 439 492 2204 40 64 2079 2205 2206 41 123 2015 46 2204 40 2206 41 59 2078 40 41 59 125 439 492 2207 40 64 2079 2208 2209 41 123 2015 46 2207 40 2209 41 59 2078 40 41 59 125 439 492 2210 40 64 2079 2208 2211 41 123 2015 46 2210 40 2211 41 59 2078 40 41 59 125 439 492 2212 40 2213 2214 41 123 2215 40 41 46 2216 40 2214 41 59 2078 40 41 59 125 439 492 2217 40 2213 2214 41 123 2218 40 41 46 2219 40 2214 41 59 2078 40 41 59 125 439 492 2220 40 2221 2214 41 123 2015 46 2220 40 2214 41 59 2078 40 41 59 125 439 492 2222 40 41 123 2015 46 2220 40 424 41 59 2078 40 41 59 125 621 621 621 64 2079 439 2011 2223 40 2224 2225 41 123 2226 60 2011 62 2227 61 2015 46 2228 40 41 631 424 63 2015 46 2228 40 41 46 2229 40 41 46 2214 40 2230 45 62 2230 46 2231 40 41 46 2232 40 2225 41 41 46 2233 40 41 58 2226 46 362 40 41 59 450 2227 46 2234 40 424 41 59 125 439 2224 2235 40 41 123 450 2015 46 2235 40 41 59 125 439 2236 60 2011 62 2014 40 41 123 450 2014 59 125 64 2079 439 2237 60 2011 62 2238 40 41 123 450 2015 46 2238 40 41 59 125 439 2010 60 2011 62 2239 40 41 123 450 2012 59 125 618 64 2079 439 2080 2240 40 41 123 450 2015 46 2240 40 41 59 125 64 2079 439 2096 2241 40 41 123 450 2015 46 2241 40 41 59 125 64 2079 439 2110 2242 40 41 123 450 2015 46 2242 40 41 59 125 64 2079 439 2243 60 2080 62 2244 40 41 123 450 2015 46 2244 40 41 59 125 64 2079 439 2243 60 2096 62 2245 40 41 123 450 2015 46 2245 40 41 59 125 64 2079 439 2243 60 2110 62 2246 40 41 123 450 2015 46 2246 40 41 59 125 64 2079 439 2243 60 2082 62 2247 40 41 123 450 2015 46 2244 40 41 631 424 63 2015 46 2244 40 41 46 2248 40 41 46 2249 40 2080 58 58 2250 41 46 2251 40 2252 46 2253 40 41 41 58 424 59 125 64 2079 439 2243 60 2082 62 2254 40 41 123 450 2015 46 2245 40 41 631 424 63 2015 46 2245 40 41 46 2255 40 41 46 2256 40 2096 58 58 2257 41 46 2258 40 2259 46 2260 40 41 41 58 424 59 125 64 2079 439 2243 60 2082 62 2261 40 41 123 450 2015 46 2246 40 41 631 424 63 2015 46 2246 40 41 46 2262 40 41 46 2263 40 2110 58 58 2264 41 46 2265 40 2266 46 2267 40 41 41 58 424 59 125 439 324 2268 40 41 123 450 2244 40 41 631 424 605 33 2244 40 41 46 2269 40 41 59 125 439 324 2270 40 41 123 450 2245 40 41 631 424 605 33 2245 40 41 46 2271 40 41 59 125 439 324 2272 40 41 123 450 2246 40 41 631 424 605 33 2246 40 41 46 2273 40 41 59 125 64 2079 439 2205 2274 40 41 123 450 2015 46 2274 40 41 59 125 64 2079 439 2208 2275 40 41 123 450 2015 46 2275 40 41 59 125 64 2079 439 2208 2276 40 41 123 450 2015 46 2276 40 41 59 125 439 324 2277 40 2080 2155 41 123 450 2155 46 2278 40 2015 46 2240 40 41 41 59 125 439 324 2279 40 2096 2170 41 123 450 2170 46 2280 40 2015 46 2241 40 41 41 59 125 439 324 2281 40 2110 2185 41 123 450 2185 46 2282 40 2015 46 2242 40 41 41 59 125 439 2243 60 2213 62 2283 40 41 123 450 2015 46 2283 40 41 59 125 64 2079 439 2221 2284 40 41 123 450 2015 46 2284 40 41 59 125 439 324 2016 40 41 123 450 2016 59 125 437 324 2285 40 2011 2134 41 123 450 2239 40 41 46 2286 40 41 46 2287 40 2288 45 62 2288 46 2289 40 2134 41 41 59 125 439 2290 2291 40 41 123 450 2015 46 2291 40 41 59 125 125 
4754,Java,"@Slf4j
class TransactionsListItem {
    private final BtcWalletService btcWalletService;
    private final CoinFormatter formatter;
    private String dateString;
    private final Date date;
    private final String txId;
    @Nullable
    private Tradable tradable;
    private String details = """";
    private String addressString = """";
    private String direction = """";
    private TxConfidenceListener txConfidenceListener;
    private boolean received;
    private boolean detailsAvailable;
    private Coin amountAsCoin = Coin.ZERO;
    private String memo = """";
    private int confirmations = 0;
    @Getter
    private final boolean isDustAttackTx;
    private boolean initialTxConfidenceVisibility = true;
    private final Supplier<LazyFields> lazyFieldsSupplier;

    private static class LazyFields {
        TxConfidenceIndicator txConfidenceIndicator;
        Tooltip tooltip;
    }

    private LazyFields lazy() {
        return lazyFieldsSupplier.get();
    }

    // used at exportCSV
    TransactionsListItem() {
        date = null;
        btcWalletService = null;
        txId = null;
        formatter = null;
        isDustAttackTx = false;
        lazyFieldsSupplier = null;
    }

    TransactionsListItem(Transaction transaction,
                         BtcWalletService btcWalletService,
                         BsqWalletService bsqWalletService,
                         TransactionAwareTradable transactionAwareTradable,
                         DaoFacade daoFacade,
                         CoinFormatter formatter,
                         long ignoreDustThreshold) {
        this.btcWalletService = btcWalletService;
        this.formatter = formatter;
        this.memo = transaction.getMemo();

        txId = transaction.getTxId().toString();

        Optional<Tradable> optionalTradable = Optional.ofNullable(transactionAwareTradable)
                .map(TransactionAwareTradable::asTradable);

        Coin valueSentToMe = btcWalletService.getValueSentToMeForTransaction(transaction);
        Coin valueSentFromMe = btcWalletService.getValueSentFromMeForTransaction(transaction);

        // TODO check and refactor
        boolean txFeeForBsqPayment = false;
        boolean withdrawalFromBSQWallet = false;
        if (valueSentToMe.isZero()) {
            amountAsCoin = valueSentFromMe.multiply(-1);
            for (TransactionOutput output : transaction.getOutputs()) {
                if (!btcWalletService.isTransactionOutputMine(output)) {
                    received = false;
                    if (WalletService.isOutputScriptConvertibleToAddress(output)) {
                        addressString = WalletService.getAddressStringFromOutput(output);
                        if (bsqWalletService.isTransactionOutputMine(output)) {
                            txFeeForBsqPayment = true;
                        } else {
                            direction = Res.get(""funds.tx.direction.sentTo"");
                        }
                        break;
                    }
                }
            }
        } else if (valueSentFromMe.isZero()) {
            amountAsCoin = valueSentToMe;
            direction = Res.get(""funds.tx.direction.receivedWith"");
            received = true;
            for (TransactionOutput output : transaction.getOutputs()) {
                if (btcWalletService.isTransactionOutputMine(output) &&
                        WalletService.isOutputScriptConvertibleToAddress(output)) {
                    addressString = WalletService.getAddressStringFromOutput(output);
                    break;
                }
            }
        } else {
            amountAsCoin = valueSentToMe.subtract(valueSentFromMe);
            boolean outgoing = false;
            for (TransactionOutput output : transaction.getOutputs()) {
                if (!btcWalletService.isTransactionOutputMine(output)) {
                    if (WalletService.isOutputScriptConvertibleToAddress(output)) {
                        addressString = WalletService.getAddressStringFromOutput(output);
                        if (bsqWalletService.isTransactionOutputMine(output)) {
                            outgoing = false;
                            txFeeForBsqPayment = true;

                            Optional<TxType> txTypeOptional = daoFacade.getOptionalTxType(txId);
                            if (txTypeOptional.isPresent()) {
                                if (txTypeOptional.get().equals(TxType.COMPENSATION_REQUEST))
                                    details = Res.get(""funds.tx.compensationRequestTxFee"");
                                else if (txTypeOptional.get().equals(TxType.REIMBURSEMENT_REQUEST))
                                    details = Res.get(""funds.tx.reimbursementRequestTxFee"");
                                else
                                    details = Res.get(""funds.tx.daoTxFee"");
                            }
                        } else {
                            outgoing = true;
                        }
                        break;
                    }
                } else {
                    addressString = WalletService.getAddressStringFromOutput(output);
                    outgoing = (valueSentToMe.getValue() < valueSentFromMe.getValue());
                    if (!outgoing) {
                        direction = Res.get(""funds.tx.direction.receivedWith"");
                        received = true;
                        withdrawalFromBSQWallet = true;
                    }
                }
            }

            if (outgoing) {
                direction = Res.get(""funds.tx.direction.sentTo"");
                received = false;
            }
        }

        if (txFeeForBsqPayment) {
            // direction = Res.get(""funds.tx.txFeePaymentForBsqTx"");
            direction = Res.get(""funds.tx.direction.sentTo"");
            //addressString = """";
        }

        if (optionalTradable.isPresent()) {
            tradable = optionalTradable.get();
            detailsAvailable = true;
            String tradeId = tradable.getShortId();
            if (tradable instanceof OpenOffer) {
                details = Res.get(""funds.tx.createOfferFee"", tradeId);
            } else if (tradable instanceof Trade) {
                Trade trade = (Trade) tradable;
                TransactionAwareTrade transactionAwareTrade = (TransactionAwareTrade) transactionAwareTradable;
                if (trade.getTakerFeeTxId() != null && trade.getTakerFeeTxId().equals(txId)) {
                    details = Res.get(""funds.tx.takeOfferFee"", tradeId);
                } else {
                    Offer offer = trade.getOffer();
                    String offerFeePaymentTxID = offer.getOfferFeePaymentTxId();
                    if (offerFeePaymentTxID != null && offerFeePaymentTxID.equals(txId)) {
                        details = Res.get(""funds.tx.createOfferFee"", tradeId);
                    } else if (trade.getDepositTx() != null &&
                            trade.getDepositTx().getTxId().equals(Sha256Hash.wrap(txId))) {
                        details = Res.get(""funds.tx.multiSigDeposit"", tradeId);
                    } else if (trade.getPayoutTx() != null &&
                            trade.getPayoutTx().getTxId().equals(Sha256Hash.wrap(txId))) {
                        details = Res.get(""funds.tx.multiSigPayout"", tradeId);

                        if (amountAsCoin.isZero()) {
                            initialTxConfidenceVisibility = false;
                        }
                    } else {
                        Trade.DisputeState disputeState = trade.getDisputeState();
                        if (disputeState == Trade.DisputeState.DISPUTE_CLOSED) {
                            if (valueSentToMe.isPositive()) {
                                details = Res.get(""funds.tx.disputePayout"", tradeId);
                            } else {
                                details = Res.get(""funds.tx.disputeLost"", tradeId);
                                initialTxConfidenceVisibility = false;
                            }
                        } else if (disputeState == Trade.DisputeState.REFUND_REQUEST_CLOSED ||
                                disputeState == Trade.DisputeState.REFUND_REQUESTED ||
                                disputeState == Trade.DisputeState.REFUND_REQUEST_STARTED_BY_PEER) {
                            if (valueSentToMe.isPositive()) {
                                details = Res.get(""funds.tx.refund"", tradeId);
                            } else {
                                // We have spent the deposit tx outputs to the Bisq donation address to enable
                                // the refund process (refund agent -> reimbursement). As the funds have left our wallet
                                // already when funding the deposit tx we show 0 BTC as amount.
                                // Confirmation is not known from the BitcoinJ side (not 100% clear why) as no funds
                                // left our wallet nor we received funds. So we set indicator invisible.
                                amountAsCoin = Coin.ZERO;
                                details = Res.get(""funds.tx.collateralForRefund"", tradeId);
                                initialTxConfidenceVisibility = false;
                            }
                        } else {
                            if (transactionAwareTrade.isDelayedPayoutTx(txId)) {
                                details = Res.get(""funds.tx.timeLockedPayoutTx"", tradeId);
                                initialTxConfidenceVisibility = false;
                            } else {
                                details = Res.get(""funds.tx.unknown"", tradeId);
                            }
                        }
                    }
                }
            } else if (tradable instanceof BsqSwapTrade) {
                direction = amountAsCoin.isPositive() ? Res.get(""funds.tx.bsqSwapBuy"") :
                        Res.get(""funds.tx.bsqSwapSell"");

                // Find my BTC output address
                var tx = btcWalletService.getTransaction(((BsqSwapTrade) tradable).getTxId());
                addressString = tx != null ?
                        tx.getOutputs().stream()
                                .filter(output -> output.isMine(btcWalletService.getWallet()))
                                .map(output -> output.getScriptPubKey().getToAddress(btcWalletService.getParams()))
                                .map(Object::toString)
                                .findFirst()
                                .orElse("""") :
                        """";
                details = Res.get(""funds.tx.bsqSwapTx"", tradeId);
            }
        } else {
            if (amountAsCoin.isZero()) {
                details = Res.get(""funds.tx.noFundsFromDispute"");
                initialTxConfidenceVisibility = false;
            } else if (withdrawalFromBSQWallet) {
                details = Res.get(""funds.tx.withdrawnFromBSQWallet"");
            } else if (!txFeeForBsqPayment) {
                details = received ? Res.get(""funds.tx.receivedFunds"") : Res.get(""funds.tx.withdrawnFromWallet"");
            } else if (details.isEmpty()) {
                details = Res.get(""funds.tx.txFeePaymentForBsqTx"");
            }
        }
        // Use tx.getIncludedInBestChainAt() when available, otherwise use tx.getUpdateTime()
        date = transaction.getIncludedInBestChainAt() != null ? transaction.getIncludedInBestChainAt() : transaction.getUpdateTime();
        dateString = DisplayUtils.formatDateTime(date);

        isDustAttackTx = received && valueSentToMe.value < ignoreDustThreshold;
        if (isDustAttackTx) {
            details = Res.get(""funds.tx.dustAttackTx"");
        }

        // confidence
        lazyFieldsSupplier = Suppliers.memoize(() -> new LazyFields() {{
            txConfidenceIndicator = new TxConfidenceIndicator();
            txConfidenceIndicator.setId(""funds-confidence"");
            tooltip = new Tooltip(Res.get(""shared.notUsedYet""));
            txConfidenceIndicator.setProgress(0);
            txConfidenceIndicator.setTooltip(tooltip);
            txConfidenceIndicator.setVisible(initialTxConfidenceVisibility);

            TransactionConfidence confidence = transaction.getConfidence();
            GUIUtil.updateConfidence(confidence, tooltip, txConfidenceIndicator);
            confirmations = confidence.getDepthInBlocks();
        }});

        txConfidenceListener = new TxConfidenceListener(txId) {
            @Override
            public void onTransactionConfidenceChanged(TransactionConfidence confidence) {
                GUIUtil.updateConfidence(confidence, lazy().tooltip, lazy().txConfidenceIndicator);
                confirmations = confidence.getDepthInBlocks();
            }
        };
        btcWalletService.addTxConfidenceListener(txConfidenceListener);
    }

    public void cleanup() {
        btcWalletService.removeTxConfidenceListener(txConfidenceListener);
    }


    public TxConfidenceIndicator getTxConfidenceIndicator() {
        return lazy().txConfidenceIndicator;
    }

    public final String getDateString() {
        return dateString;
    }


    public String getAmount() {
        return formatter.formatCoin(amountAsCoin);
    }

    public Coin getAmountAsCoin() {
        return amountAsCoin;
    }


    public String getAddressString() {
        return addressString;
    }

    public String getDirection() {
        return direction;
    }

    public String getTxId() {
        return txId;
    }

    public boolean getReceived() {
        return received;
    }

    public String getDetails() {
        return details;
    }

    public boolean getDetailsAvailable() {
        return detailsAvailable;
    }

    public Date getDate() {
        return date;
    }

    @Nullable
    public Tradable getTradable() {
        return tradable;
    }

    public String getNumConfirmations() {
        return String.valueOf(confirmations);
    }

    public String getMemo() {
        return memo;
    }
}",1,64 2000 334 2001 123 437 381 2002 2003 59 437 381 2004 2005 59 437 2006 2007 59 437 381 2008 2009 59 437 381 2006 2010 59 64 2011 437 2012 2013 59 437 2006 2014 61 648 59 437 2006 2015 61 648 59 437 2006 2016 61 648 59 437 2017 2018 59 437 324 2019 59 437 324 2020 59 437 2021 2022 61 2021 46 2023 59 437 2006 2024 61 648 59 437 404 2025 61 1500 59 64 2026 437 381 324 2027 59 437 324 2028 61 473 59 437 381 2029 60 2030 62 2031 59 437 457 334 2030 123 2032 2033 59 2034 2035 59 125 437 2030 2036 40 41 123 450 2031 46 2037 40 41 59 125 621 2001 40 41 123 2009 61 424 59 2003 61 424 59 2010 61 424 59 2005 61 424 59 2027 61 380 59 2031 61 424 59 125 2001 40 2038 2039 44 2002 2003 44 2040 2041 44 2042 2043 44 2044 2045 44 2004 2005 44 413 2046 41 123 467 46 2003 61 2003 59 467 46 2005 61 2005 59 467 46 2024 61 2039 46 2047 40 41 59 2010 61 2039 46 2048 40 41 46 2049 40 41 59 2050 60 2012 62 2051 61 2050 46 2052 40 2043 41 46 2053 40 2042 58 58 2054 41 59 2021 2055 61 2003 46 2056 40 2039 41 59 2021 2057 61 2003 46 2058 40 2039 41 59 621 324 2059 61 380 59 324 2060 61 380 59 392 40 2055 46 2061 40 41 41 123 2022 61 2057 46 2062 40 45 1501 41 59 385 40 2063 2064 58 2039 46 2065 40 41 41 123 392 40 33 2003 46 2066 40 2064 41 41 123 2019 61 380 59 392 40 2067 46 2068 40 2064 41 41 123 2015 61 2067 46 2069 40 2064 41 59 392 40 2041 46 2066 40 2064 41 41 123 2059 61 473 59 125 360 123 2016 61 2070 46 2071 40 648 41 59 125 325 59 125 125 125 125 360 392 40 2057 46 2061 40 41 41 123 2022 61 2055 59 2016 61 2072 46 2073 40 648 41 59 2019 61 473 59 385 40 2074 2075 58 2039 46 2076 40 41 41 123 392 40 2003 46 2077 40 2075 41 605 2078 46 2079 40 2075 41 41 123 2015 61 2078 46 2080 40 2075 41 59 325 59 125 125 125 360 123 2022 61 2055 46 2081 40 2057 41 59 324 2082 61 380 59 385 40 2083 2084 58 2039 46 2085 40 41 41 123 392 40 33 2003 46 2086 40 2084 41 41 123 392 40 2087 46 2088 40 2084 41 41 123 2015 61 2087 46 2089 40 2084 41 59 392 40 2041 46 2086 40 2084 41 41 123 2082 61 380 59 2059 61 473 59 2050 60 2090 62 2091 61 2045 46 2092 40 2010 41 59 392 40 2091 46 2093 40 41 41 123 392 40 2091 46 2094 40 41 46 2095 40 2090 46 2096 41 41 2014 61 2097 46 2094 40 648 41 59 360 392 40 2091 46 2094 40 41 46 2095 40 2090 46 2098 41 41 2014 61 2097 46 2094 40 648 41 59 360 2014 61 2097 46 2094 40 648 41 59 125 125 360 123 2082 61 473 59 125 325 59 125 125 360 123 2015 61 2099 46 2100 40 2084 41 59 2082 61 40 2055 46 2101 40 41 60 2057 46 2101 40 41 41 59 392 40 33 2082 41 123 2016 61 2102 46 2103 40 648 41 59 2019 61 473 59 2060 61 473 59 125 125 125 392 40 2082 41 123 2016 61 2104 46 2105 40 648 41 59 2019 61 380 59 125 125 392 40 2059 41 123 621 2016 61 2106 46 2107 40 648 41 59 621 125 392 40 2051 46 2108 40 41 41 123 2013 61 2051 46 2109 40 41 59 2020 61 473 59 2006 2110 61 2013 46 2111 40 41 59 392 40 2013 402 2112 41 123 2014 61 2113 46 2109 40 648 44 2110 41 59 125 360 392 40 2013 402 2114 41 123 2114 2115 61 40 2114 41 2013 59 2116 2117 61 40 2116 41 2043 59 392 40 2115 46 2118 40 41 631 424 605 2115 46 2118 40 41 46 2119 40 2010 41 41 123 2014 61 2120 46 2109 40 648 44 2110 41 59 125 360 123 2121 2122 61 2115 46 2123 40 41 59 2006 2124 61 2122 46 2125 40 41 59 392 40 2124 631 424 605 2124 46 2119 40 2010 41 41 123 2014 61 2126 46 2109 40 648 44 2110 41 59 125 360 392 40 2115 46 2127 40 41 631 424 605 2115 46 2127 40 41 46 2048 40 41 46 2119 40 2128 46 2129 40 2010 41 41 41 123 2014 61 2130 46 2109 40 648 44 2110 41 59 125 360 392 40 2115 46 2131 40 41 631 424 605 2115 46 2131 40 41 46 2048 40 41 46 2119 40 2128 46 2129 40 2010 41 41 41 123 2014 61 2132 46 2109 40 648 44 2110 41 59 392 40 2022 46 2061 40 41 41 123 2028 61 380 59 125 125 360 123 2114 46 2133 2134 61 2115 46 2135 40 41 59 392 40 2134 614 2114 46 2133 46 2136 41 123 392 40 2055 46 2137 40 41 41 123 2014 61 2138 46 2109 40 648 44 2110 41 59 125 360 123 2014 61 2139 46 2109 40 648 44 2110 41 59 2028 61 380 59 125 125 360 392 40 2134 614 2114 46 2133 46 2140 606 2134 614 2114 46 2133 46 2141 606 2134 614 2114 46 2133 46 2142 41 123 392 40 2055 46 2143 40 41 41 123 2014 61 2144 46 2109 40 648 44 2110 41 59 125 360 123 621 621 621 621 621 2022 61 2021 46 2023 59 2014 61 2145 46 2109 40 648 44 2110 41 59 2028 61 380 59 125 125 360 123 392 40 2117 46 2146 40 2010 41 41 123 2014 61 2147 46 2109 40 648 44 2110 41 59 2028 61 380 59 125 360 123 2014 61 2148 46 2109 40 648 44 2110 41 59 125 125 125 125 125 360 392 40 2013 402 2149 41 123 2016 61 2022 46 2150 40 41 63 2151 46 2109 40 648 41 58 2151 46 2109 40 648 41 59 621 490 2152 61 2003 46 2153 40 40 40 2149 41 2013 41 46 2048 40 41 41 59 2015 61 2152 631 424 63 2152 46 2154 40 41 46 2155 40 41 46 2156 40 2157 45 62 2157 46 2158 40 2003 46 2159 40 41 41 41 46 2053 40 2157 45 62 2157 46 2160 40 41 46 2161 40 2003 46 2162 40 41 41 41 46 2053 40 2163 58 58 2049 41 46 2164 40 41 46 2165 40 648 41 58 648 59 2014 61 2151 46 2109 40 648 44 2110 41 59 125 125 360 123 392 40 2022 46 2061 40 41 41 123 2014 61 2166 46 2167 40 648 41 59 2028 61 380 59 125 360 392 40 2060 41 123 2014 61 2168 46 2169 40 648 41 59 125 360 392 40 33 2059 41 123 2014 61 2019 63 2170 46 2171 40 648 41 58 2170 46 2171 40 648 41 59 125 360 392 40 2014 46 2172 40 41 41 123 2014 61 2173 46 2174 40 648 41 59 125 125 621 2009 61 2039 46 2175 40 41 631 424 63 2039 46 2175 40 41 58 2039 46 2176 40 41 59 2007 61 2177 46 2178 40 2009 41 59 2027 61 2019 605 2055 46 2179 60 2046 59 392 40 2027 41 123 2014 61 2180 46 2181 40 648 41 59 125 621 2031 61 2182 46 2183 40 40 41 45 62 418 2030 40 41 123 123 2184 61 418 2185 40 41 59 2184 46 2186 40 648 41 59 2187 61 418 2188 40 2189 46 2190 40 648 41 41 59 2184 46 2191 40 1500 41 59 2184 46 2192 40 2187 41 59 2184 46 2193 40 2028 41 59 2194 2195 61 2039 46 2196 40 41 59 2197 46 2198 40 2195 44 2187 44 2184 41 59 2025 61 2195 46 2199 40 41 59 125 125 41 59 2018 61 418 2017 40 2010 41 123 64 2200 439 492 2201 40 2202 2203 41 123 2204 46 2205 40 2203 44 2036 40 41 46 2206 44 2036 40 41 46 2207 41 59 2025 61 2203 46 2208 40 41 59 125 125 59 2003 46 2209 40 2018 41 59 125 439 492 2210 40 41 123 2003 46 2211 40 2018 41 59 125 439 2212 2213 40 41 123 450 2036 40 41 46 2214 59 125 439 381 2006 2215 40 41 123 450 2007 59 125 439 2006 2216 40 41 123 450 2005 46 2217 40 2022 41 59 125 439 2021 2218 40 41 123 450 2022 59 125 439 2006 2219 40 41 123 450 2015 59 125 439 2006 2220 40 41 123 450 2016 59 125 439 2006 2221 40 41 123 450 2010 59 125 439 324 2222 40 41 123 450 2019 59 125 439 2006 2223 40 41 123 450 2014 59 125 439 324 2224 40 41 123 450 2020 59 125 439 2008 2225 40 41 123 450 2009 59 125 64 2011 439 2012 2226 40 41 123 450 2013 59 125 439 2006 2227 40 41 123 450 2006 46 2228 40 2025 41 59 125 439 2006 2229 40 41 123 450 2024 59 125 125 
2869,Java,"@Slf4j
public class Version {
    // The application versions
    // VERSION = 0.5.0 introduces proto buffer for the P2P network and local DB and is a not backward compatible update
    // Therefore all sub versions start again with 1
    // We use semantic versioning with major, minor and patch
    public static final String VERSION = ""1.8.0"";

    /**
     * Holds a list of the tagged resource files for optimizing the getData requests.
     * This must not contain each version but only those where we add new version-tagged resource files for
     * historical data stores.
     */
    public static final List<String> HISTORICAL_RESOURCE_FILE_VERSION_TAGS = Arrays.asList(""1.4.0"", ""1.5.0"", ""1.5.2"",
            ""1.5.5"", ""1.5.7"", ""1.6.0"", ""1.6.3"", ""1.6.5"", ""1.7.2"", ""1.7.4"", ""1.8.0"");

    public static int getMajorVersion(String version) {
        return getSubVersion(version, 0);
    }

    public static int getMinorVersion(String version) {
        return getSubVersion(version, 1);
    }

    public static int getPatchVersion(String version) {
        return getSubVersion(version, 2);
    }

    public static boolean isNewVersion(String newVersion) {
        return isNewVersion(newVersion, VERSION);
    }

    public static boolean isNewVersion(String newVersion, String currentVersion) {
        if (newVersion.equals(currentVersion))
            return false;
        else if (getMajorVersion(newVersion) > getMajorVersion(currentVersion))
            return true;
        else if (getMajorVersion(newVersion) < getMajorVersion(currentVersion))
            return false;
        else if (getMinorVersion(newVersion) > getMinorVersion(currentVersion))
            return true;
        else if (getMinorVersion(newVersion) < getMinorVersion(currentVersion))
            return false;
        else if (getPatchVersion(newVersion) > getPatchVersion(currentVersion))
            return true;
        else if (getPatchVersion(newVersion) < getPatchVersion(currentVersion))
            return false;
        else
            return false;
    }

    private static int getSubVersion(String version, int index) {
        final String[] split = version.split(""\\."");
        checkArgument(split.length == 3, ""Version number must be in semantic version format (contain 2 '.'). version="" + version);
        return Integer.parseInt(split[index]);
    }

    // The version no. for the objects sent over the network. A change will break the serialization of old objects.
    // If objects are used for both network and database the network version is applied.
    // VERSION = 0.5.0 -> P2P_NETWORK_VERSION = 1
    // With version 1.2.2 we change to version 2 (new trade protocol)
    public static final int P2P_NETWORK_VERSION = 1;

    // The version no. of the serialized data stored to disc. A change will break the serialization of old objects.
    // VERSION = 0.5.0 -> LOCAL_DB_VERSION = 1
    public static final int LOCAL_DB_VERSION = 1;

    // The version no. of the current protocol. The offer holds that version.
    // A taker will check the version of the offers to see if his version is compatible.
    // For the switch to version 2, offers created with the old version will become invalid and have to be canceled.
    // For the switch to version 3, offers created with the old version can be migrated to version 3 just by opening
    // the Bisq app.
    // VERSION = 0.5.0 -> TRADE_PROTOCOL_VERSION = 1
    // Version 1.2.2 -> TRADE_PROTOCOL_VERSION = 2
    // Version 1.5.0 -> TRADE_PROTOCOL_VERSION = 3
    // Version 1.7.0 -> TRADE_PROTOCOL_VERSION = 4
    public static final int TRADE_PROTOCOL_VERSION = 4;
    private static int p2pMessageVersion;

    public static final String BSQ_TX_VERSION = ""1"";

    public static int getP2PMessageVersion() {
        return p2pMessageVersion;
    }

    // The version for the crypto network (BTC_Mainnet = 0, BTC_TestNet = 1, BTC_Regtest = 2, ...)
    private static int BASE_CURRENCY_NETWORK;

    public static void setBaseCryptoNetworkId(int baseCryptoNetworkId) {
        BASE_CURRENCY_NETWORK = baseCryptoNetworkId;

        // CRYPTO_NETWORK_ID is ordinal of enum. We use for changes at NETWORK_PROTOCOL_VERSION a multiplication with 10
        // to not mix up networks:
        p2pMessageVersion = BASE_CURRENCY_NETWORK + 10 * P2P_NETWORK_VERSION;
    }

    public static int getBaseCurrencyNetwork() {
        return BASE_CURRENCY_NETWORK;
    }

    public static void printVersion() {
        log.info(""Version{"" +
                ""VERSION="" + VERSION +
                "", P2P_NETWORK_VERSION="" + P2P_NETWORK_VERSION +
                "", LOCAL_DB_VERSION="" + LOCAL_DB_VERSION +
                "", TRADE_PROTOCOL_VERSION="" + TRADE_PROTOCOL_VERSION +
                "", BASE_CURRENCY_NETWORK="" + BASE_CURRENCY_NETWORK +
                "", getP2PNetworkId()="" + getP2PMessageVersion() +
                '}');
    }

    public static final byte COMPENSATION_REQUEST = (byte) 0x01;
    public static final byte REIMBURSEMENT_REQUEST = (byte) 0x01;
    public static final byte PROPOSAL = (byte) 0x01;
    public static final byte BLIND_VOTE = (byte) 0x01;
    public static final byte VOTE_REVEAL = (byte) 0x01;
    public static final byte LOCKUP = (byte) 0x01;
    public static final byte ASSET_LISTING_FEE = (byte) 0x01;
    public static final byte PROOF_OF_BURN = (byte) 0x01;
}",1,64 2000 439 334 2001 123 621 621 621 621 439 457 381 2002 2003 61 648 59 618 439 457 381 2004 60 2002 62 2005 61 2006 46 2007 40 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 41 59 439 457 404 2008 40 2002 2009 41 123 450 2010 40 2009 44 1500 41 59 125 439 457 404 2011 40 2002 2009 41 123 450 2012 40 2009 44 1501 41 59 125 439 457 404 2013 40 2002 2009 41 123 450 2014 40 2009 44 1502 41 59 125 439 457 324 2015 40 2002 2016 41 123 450 2015 40 2016 44 2003 41 59 125 439 457 324 2015 40 2002 2016 44 2002 2017 41 123 392 40 2016 46 2018 40 2017 41 41 450 380 59 360 392 40 2008 40 2016 41 62 2008 40 2017 41 41 450 473 59 360 392 40 2008 40 2016 41 60 2008 40 2017 41 41 450 380 59 360 392 40 2011 40 2016 41 62 2011 40 2017 41 41 450 473 59 360 392 40 2011 40 2016 41 60 2011 40 2017 41 41 450 380 59 360 392 40 2013 40 2016 41 62 2013 40 2017 41 41 450 473 59 360 392 40 2013 40 2016 41 60 2013 40 2017 41 41 450 380 59 360 450 380 59 125 437 457 404 2019 40 2002 2009 44 404 2020 41 123 381 2002 91 93 2021 61 2009 46 2021 40 648 41 59 2022 40 2021 46 2023 614 1502 44 648 43 2009 41 59 450 2024 46 2025 40 2021 91 2020 93 41 59 125 621 621 621 621 439 457 381 404 2026 61 1501 59 621 621 439 457 381 404 2027 61 1501 59 621 621 621 621 621 621 621 621 621 439 457 381 404 2028 61 1502 59 437 457 404 2029 59 439 457 381 2002 2030 61 648 59 439 457 404 2031 40 41 123 450 2029 59 125 621 437 457 404 2032 59 439 457 492 2033 40 404 2034 41 123 2032 61 2034 59 621 621 2029 61 2032 43 1502 42 2026 59 125 439 457 404 2035 40 41 123 450 2032 59 125 439 457 492 2036 40 41 123 2037 46 2038 40 648 43 648 43 2003 43 648 43 2026 43 648 43 2027 43 648 43 2028 43 648 43 2032 43 648 43 2031 40 41 43 607 41 59 125 439 457 381 326 2039 61 40 326 41 1501 59 439 457 381 326 2040 61 40 326 41 1501 59 439 457 381 326 2041 61 40 326 41 1501 59 439 457 381 326 2042 61 40 326 41 1501 59 439 457 381 326 2043 61 40 326 41 1501 59 439 457 381 326 2044 61 40 326 41 1501 59 439 457 381 326 2045 61 40 326 41 1501 59 439 457 381 326 2046 61 40 326 41 1501 59 125 
2786,Java,"public class FormBuilder {
    private static final String MATERIAL_DESIGN_ICONS = ""'Material Design Icons'"";

    ///////////////////////////////////////////////////////////////////////////////////////////
    // TitledGroupBg
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static TitledGroupBg addTitledGroupBg(GridPane gridPane, int rowIndex, int rowSpan, String title) {
        return addTitledGroupBg(gridPane, rowIndex, rowSpan, title, 0);
    }

    public static TitledGroupBg addTitledGroupBg(GridPane gridPane,
                                                 int rowIndex,
                                                 int columnIndex,
                                                 int rowSpan,
                                                 String title) {
        TitledGroupBg titledGroupBg = addTitledGroupBg(gridPane, rowIndex, rowSpan, title, 0);
        GridPane.setColumnIndex(titledGroupBg, columnIndex);
        return titledGroupBg;
    }

    public static TitledGroupBg addTitledGroupBg(GridPane gridPane,
                                                 int rowIndex,
                                                 int columnIndex,
                                                 int rowSpan,
                                                 String title,
                                                 double top) {
        TitledGroupBg titledGroupBg = addTitledGroupBg(gridPane, rowIndex, rowSpan, title, top);
        GridPane.setColumnIndex(titledGroupBg, columnIndex);
        return titledGroupBg;
    }

    public static TitledGroupBg addTitledGroupBg(GridPane gridPane,
                                                 int rowIndex,
                                                 int rowSpan,
                                                 String title,
                                                 double top) {
        TitledGroupBg titledGroupBg = new TitledGroupBg();
        titledGroupBg.setText(title);
        titledGroupBg.prefWidthProperty().bind(gridPane.widthProperty());
        GridPane.setRowIndex(titledGroupBg, rowIndex);
        GridPane.setRowSpan(titledGroupBg, rowSpan);
        GridPane.setMargin(titledGroupBg, new Insets(top + 8, -10, -12, -10));
        gridPane.getChildren().add(titledGroupBg);
        return titledGroupBg;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Label addLabel(GridPane gridPane, int rowIndex, String title) {
        return addLabel(gridPane, rowIndex, title, 0);
    }

    public static Label addLabel(GridPane gridPane, int rowIndex, String title, double top) {
        Label label = new AutoTooltipLabel(title);
        GridPane.setRowIndex(label, rowIndex);
        GridPane.setMargin(label, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(label);
        return label;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + Subtext
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, Label, VBox> addLabelWithSubText(GridPane gridPane,
                                                                 int rowIndex,
                                                                 String title,
                                                                 String description) {
        return addLabelWithSubText(gridPane, rowIndex, title, description, 0);
    }

    public static Tuple3<Label, Label, VBox> addLabelWithSubText(GridPane gridPane,
                                                                 int rowIndex,
                                                                 String title,
                                                                 String description,
                                                                 double top) {
        Label label = new AutoTooltipLabel(title);
        Label subText = new AutoTooltipLabel(description);

        VBox vBox = new VBox();
        vBox.getChildren().setAll(label, subText);

        GridPane.setRowIndex(vBox, rowIndex);
        GridPane.setMargin(vBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(vBox);

        return new Tuple3<>(label, subText, vBox);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Multiline Label
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Label addMultilineLabel(GridPane gridPane, int rowIndex) {
        return addMultilineLabel(gridPane, rowIndex, 0);
    }

    public static Label addMultilineLabel(GridPane gridPane, int rowIndex, String text) {
        return addMultilineLabel(gridPane, rowIndex, text, 0);
    }

    public static Label addMultilineLabel(GridPane gridPane, int rowIndex, double top) {
        return addMultilineLabel(gridPane, rowIndex, """", top);
    }

    public static Label addMultilineLabel(GridPane gridPane, int rowIndex, String text, double top) {
        return addMultilineLabel(gridPane, rowIndex, text, top, 600);
    }

    public static Label addMultilineLabel(GridPane gridPane, int rowIndex, String text, double top, double maxWidth) {
        Label label = new AutoTooltipLabel(text);
        label.setWrapText(true);
        label.setMaxWidth(maxWidth);
        GridPane.setHalignment(label, HPos.LEFT);
        GridPane.setHgrow(label, Priority.ALWAYS);
        GridPane.setRowIndex(label, rowIndex);
        GridPane.setMargin(label, new Insets(top + Layout.FLOATING_LABEL_DISTANCE, 0, 0, 0));
        gridPane.getChildren().add(label);
        return label;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + TextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, TextField, VBox> addTopLabelReadOnlyTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String title) {
        return addTopLabelTextField(gridPane, rowIndex, title, """", -15);
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelReadOnlyTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              int columnIndex,
                                                                              String title) {
        Tuple3<Label, TextField, VBox> tuple = addTopLabelTextField(gridPane, rowIndex, title, """", -15);
        GridPane.setColumnIndex(tuple.third, columnIndex);
        return tuple;
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelReadOnlyTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String title,
                                                                              double top) {
        return addTopLabelTextField(gridPane, rowIndex, title, """", top - 15);
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelReadOnlyTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String title,
                                                                              String value) {
        return addTopLabelReadOnlyTextField(gridPane, rowIndex, title, value, 0);
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelReadOnlyTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              int columnIndex,
                                                                              String title,
                                                                              String value,
                                                                              double top) {
        Tuple3<Label, TextField, VBox> tuple = addTopLabelTextField(gridPane, rowIndex, title, value, top - 15);
        GridPane.setColumnIndex(tuple.third, columnIndex);
        return tuple;
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelReadOnlyTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              int columnIndex,
                                                                              String title,
                                                                              double top) {
        Tuple3<Label, TextField, VBox> tuple = addTopLabelTextField(gridPane, rowIndex, title, """", top - 15);
        GridPane.setColumnIndex(tuple.third, columnIndex);
        return tuple;
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelReadOnlyTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String title,
                                                                              String value,
                                                                              double top) {
        return addTopLabelTextField(gridPane, rowIndex, title, value, top - 15);
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelTextField(GridPane gridPane, int rowIndex, String title) {
        return addTopLabelTextField(gridPane, rowIndex, title, """", 0);
    }

    public static Tuple3<Label, TextField, VBox> addCompactTopLabelTextField(GridPane gridPane,
                                                                             int rowIndex,
                                                                             String title,
                                                                             String value) {
        return addTopLabelTextField(gridPane, rowIndex, title, value, -Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple3<Label, TextField, VBox> addCompactTopLabelTextField(GridPane gridPane,
                                                                             int rowIndex,
                                                                             int colIndex,
                                                                             String title,
                                                                             String value) {
        final Tuple3<Label, TextField, VBox> labelTextFieldVBoxTuple3 = addTopLabelTextField(gridPane, rowIndex, title, value, -Layout.FLOATING_LABEL_DISTANCE);
        GridPane.setColumnIndex(labelTextFieldVBoxTuple3.third, colIndex);
        return labelTextFieldVBoxTuple3;
    }

    public static Tuple3<Label, TextField, VBox> addCompactTopLabelTextField(GridPane gridPane,
                                                                             int rowIndex,
                                                                             String title,
                                                                             String value,
                                                                             double top) {
        return addTopLabelTextField(gridPane, rowIndex, title, value, top - Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelTextField(GridPane gridPane,
                                                                      int rowIndex,
                                                                      String title,
                                                                      String value) {
        return addTopLabelTextField(gridPane, rowIndex, title, value, 0);
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelTextField(GridPane gridPane,
                                                                      int rowIndex,
                                                                      String title,
                                                                      double top) {
        return addTopLabelTextField(gridPane, rowIndex, title, """", top);
    }

    public static Tuple3<Label, TextField, VBox> addTopLabelTextField(GridPane gridPane,
                                                                      int rowIndex,
                                                                      String title,
                                                                      String value,
                                                                      double top) {
        TextField textField = new BisqTextField(value);
        textField.setEditable(false);
        textField.setFocusTraversable(false);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, textField, top);

        // TODO not 100% sure if that is a good idea....
        //topLabelWithVBox.first.getStyleClass().add(""jfx-text-field-top-label"");

        return new Tuple3<>(topLabelWithVBox.first, textField, topLabelWithVBox.second);
    }

    public static Tuple2<TextField, Button> addTextFieldWithEditButton(GridPane gridPane, int rowIndex, String title) {
        TextField textField = new BisqTextField();
        textField.setPromptText(title);
        textField.setEditable(false);
        textField.setFocusTraversable(false);
        textField.setPrefWidth(Layout.INITIAL_WINDOW_WIDTH);

        Button button = new AutoTooltipButton(""..."");
        button.setStyle(""-fx-min-width: 35px; -fx-pref-height: 20; -fx-padding: 3 3 3 3; -fx-border-insets: 5px;"");
        button.managedProperty().bind(button.visibleProperty());
        VBox vBoxButton = new VBox(button);
        vBoxButton.setAlignment(Pos.CENTER);
        HBox hBox2 = new HBox(textField, vBoxButton);

        Label label = getTopLabel(title);
        VBox textFieldVbox = getTopLabelVBox(0);
        textFieldVbox.getChildren().addAll(label, hBox2);

        gridPane.getChildren().add(textFieldVbox);
        GridPane.setRowIndex(textFieldVbox, rowIndex);
        GridPane.setMargin(textFieldVbox, new Insets(Layout.FLOATING_LABEL_DISTANCE, 0, 0, 0));

        return new Tuple2<>(textField, button);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Confirmation Fields
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, Label> addConfirmationLabelLabel(GridPane gridPane,
                                                                 int rowIndex,
                                                                 String title1,
                                                                 String title2) {
        return addConfirmationLabelLabel(gridPane, rowIndex, title1, title2, 0);
    }

    public static Tuple2<Label, Label> addConfirmationLabelLabel(GridPane gridPane,
                                                                 int rowIndex,
                                                                 String title1,
                                                                 String title2,
                                                                 double top) {
        Label label1 = addLabel(gridPane, rowIndex, title1);
        label1.getStyleClass().add(""confirmation-label"");
        Label label2 = addLabel(gridPane, rowIndex, title2);
        label2.getStyleClass().add(""confirmation-value"");
        GridPane.setColumnIndex(label2, 1);
        GridPane.setMargin(label1, new Insets(top, 0, 0, 0));
        GridPane.setHalignment(label1, HPos.LEFT);
        GridPane.setMargin(label2, new Insets(top, 0, 0, 0));

        return new Tuple2<>(label1, label2);
    }

    public static Tuple2<Label, TextField> addConfirmationLabelTextField(GridPane gridPane,
                                                     int rowIndex,
                                                     String title1,
                                                     String title2) {
        return addConfirmationLabelTextField(gridPane, rowIndex, title1, title2, 0);
    }

    public static Tuple2<Label, TextField> addConfirmationLabelTextField(GridPane gridPane,
                                                     int rowIndex,
                                                     String title1,
                                                     String title2,
                                                     double top) {
        Label label1 = addLabel(gridPane, rowIndex, title1);
        label1.getStyleClass().add(""confirmation-label"");
        TextField label2 = new BisqTextField(title2);
        gridPane.getChildren().add(label2);
        label2.getStyleClass().add(""confirmation-text-field-as-label"");
        label2.setEditable(false);
        label2.setFocusTraversable(false);
        GridPane.setRowIndex(label2, rowIndex);
        GridPane.setColumnIndex(label2, 1);
        GridPane.setMargin(label1, new Insets(top, 0, 0, 0));
        GridPane.setHalignment(label1, HPos.LEFT);
        GridPane.setMargin(label2, new Insets(top, 0, 0, 0));
        return new Tuple2<>(label1, label2);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addConfirmationLabelLabelWithCopyIcon(GridPane gridPane,
                                                                 int rowIndex,
                                                                 String title1,
                                                                 String title2) {
        Label label1 = addLabel(gridPane, rowIndex, title1);
        label1.getStyleClass().add(""confirmation-label"");
        TextFieldWithCopyIcon label2 = new TextFieldWithCopyIcon(""confirmation-value"");
        label2.setText(title2);
        GridPane.setRowIndex(label2, rowIndex);
        gridPane.getChildren().add(label2);
        GridPane.setColumnIndex(label2, 1);
        GridPane.setHalignment(label1, HPos.LEFT);
        return new Tuple2<>(label1, label2);
    }

    public static Tuple2<Label, TextArea> addConfirmationLabelTextArea(GridPane gridPane,
                                                                       int rowIndex,
                                                                       String title1,
                                                                       String title2,
                                                                       double top) {
        Label label = addLabel(gridPane, rowIndex, title1);
        label.getStyleClass().add(""confirmation-label"");

        TextArea textArea = addTextArea(gridPane, rowIndex, title2);
        ((JFXTextArea) textArea).setLabelFloat(false);

        GridPane.setColumnIndex(textArea, 1);
        GridPane.setMargin(label, new Insets(top, 0, 0, 0));
        GridPane.setHalignment(label, HPos.LEFT);
        GridPane.setMargin(textArea, new Insets(top, 0, 0, 0));

        return new Tuple2<>(label, textArea);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + TextFieldWithIcon
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, TextFieldWithIcon> addTopLabelTextFieldWithIcon(GridPane gridPane,
                                                                                int rowIndex,
                                                                                String title,
                                                                                double top) {
        return addTopLabelTextFieldWithIcon(gridPane, rowIndex, 0, title, top);
    }

    public static Tuple2<Label, TextFieldWithIcon> addTopLabelTextFieldWithIcon(GridPane gridPane,
                                                                                int rowIndex,
                                                                                int columnIndex,
                                                                                String title,
                                                                                double top) {

        TextFieldWithIcon textFieldWithIcon = new TextFieldWithIcon();
        textFieldWithIcon.setFocusTraversable(false);

        return new Tuple2<>(addTopLabelWithVBox(gridPane, rowIndex, columnIndex, title, textFieldWithIcon, top).first, textFieldWithIcon);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    //  HyperlinkWithIcon
    ///////////////////////////////////////////////////////////////////////////////////////////


    public static HyperlinkWithIcon addHyperlinkWithIcon(GridPane gridPane, int rowIndex, String title, String url) {
        return addHyperlinkWithIcon(gridPane, rowIndex, title, url, 0);
    }

    public static HyperlinkWithIcon addHyperlinkWithIcon(GridPane gridPane,
                                                         int rowIndex,
                                                         String title,
                                                         String url,
                                                         double top) {
        HyperlinkWithIcon hyperlinkWithIcon = new ExternalHyperlink(title);
        hyperlinkWithIcon.setOnAction(e -> GUIUtil.openWebPage(url));
        GridPane.setRowIndex(hyperlinkWithIcon, rowIndex);
        GridPane.setColumnIndex(hyperlinkWithIcon, 0);
        GridPane.setMargin(hyperlinkWithIcon, new Insets(top, 0, 0, 0));
        GridPane.setHalignment(hyperlinkWithIcon, HPos.LEFT);
        gridPane.getChildren().add(hyperlinkWithIcon);
        return hyperlinkWithIcon;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + HyperlinkWithIcon
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, HyperlinkWithIcon> addLabelHyperlinkWithIcon(GridPane gridPane,
                                                                             int rowIndex,
                                                                             String labelTitle,
                                                                             String title,
                                                                             String url) {
        return addLabelHyperlinkWithIcon(gridPane, rowIndex, labelTitle, title, url, 0);
    }

    public static Tuple2<Label, HyperlinkWithIcon> addLabelHyperlinkWithIcon(GridPane gridPane,
                                                                             int rowIndex,
                                                                             String labelTitle,
                                                                             String title,
                                                                             String url,
                                                                             double top) {
        Label label = addLabel(gridPane, rowIndex, labelTitle, top);

        HyperlinkWithIcon hyperlinkWithIcon = new ExternalHyperlink(title);
        hyperlinkWithIcon.setOnAction(e -> GUIUtil.openWebPage(url));
        GridPane.setRowIndex(hyperlinkWithIcon, rowIndex);
        GridPane.setMargin(hyperlinkWithIcon, new Insets(top, 0, 0, -4));
        gridPane.getChildren().add(hyperlinkWithIcon);
        return new Tuple2<>(label, hyperlinkWithIcon);
    }

    public static Tuple3<Label, HyperlinkWithIcon, VBox> addTopLabelHyperlinkWithIcon(GridPane gridPane,
                                                                                      int rowIndex,
                                                                                      int columnIndex,
                                                                                      String title,
                                                                                      String value,
                                                                                      String url,
                                                                                      double top) {
        Tuple3<Label, HyperlinkWithIcon, VBox> tuple = addTopLabelHyperlinkWithIcon(gridPane,
                rowIndex,
                title,
                value,
                url,
                top);
        GridPane.setColumnIndex(tuple.third, columnIndex);
        return tuple;
    }

    public static Tuple3<Label, HyperlinkWithIcon, VBox> addTopLabelHyperlinkWithIcon(GridPane gridPane,
                                                                                      int rowIndex,
                                                                                      String title,
                                                                                      String value,
                                                                                      String url,
                                                                                      double top) {
        HyperlinkWithIcon hyperlinkWithIcon = new ExternalHyperlink(value);
        hyperlinkWithIcon.setOnAction(e -> GUIUtil.openWebPage(url));
        hyperlinkWithIcon.getStyleClass().add(""hyperlink-with-icon"");
        GridPane.setRowIndex(hyperlinkWithIcon, rowIndex);
        Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, hyperlinkWithIcon, top - 15);
        return new Tuple3<>(topLabelWithVBox.first, hyperlinkWithIcon, topLabelWithVBox.second);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // TextArea
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static TextArea addTextArea(GridPane gridPane, int rowIndex, String prompt) {
        return addTextArea(gridPane, rowIndex, prompt, 0);
    }

    public static TextArea addTextArea(GridPane gridPane, int rowIndex, String prompt, double top) {

        JFXTextArea textArea = new BisqTextArea();
        textArea.setPromptText(prompt);
        textArea.setLabelFloat(true);
        textArea.setWrapText(true);

        GridPane.setRowIndex(textArea, rowIndex);
        GridPane.setColumnIndex(textArea, 0);
        GridPane.setMargin(textArea, new Insets(top + Layout.FLOATING_LABEL_DISTANCE, 0, 0, 0));
        gridPane.getChildren().add(textArea);

        return textArea;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + TextArea
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, TextArea> addCompactTopLabelTextArea(GridPane gridPane,
                                                                     int rowIndex,
                                                                     String title,
                                                                     String prompt) {
        return addTopLabelTextArea(gridPane, rowIndex, title, prompt, -Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple2<Label, TextArea> addCompactTopLabelTextArea(GridPane gridPane,
                                                                     int rowIndex,
                                                                     int colIndex,
                                                                     String title,
                                                                     String prompt) {
        return addTopLabelTextArea(gridPane, rowIndex, colIndex, title, prompt, -Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple2<Label, TextArea> addTopLabelTextArea(GridPane gridPane,
                                                              int rowIndex,
                                                              String title,
                                                              String prompt) {
        return addTopLabelTextArea(gridPane, rowIndex, title, prompt, 0);
    }

    public static Tuple2<Label, TextArea> addTopLabelTextArea(GridPane gridPane,
                                                              int rowIndex,
                                                              int colIndex,
                                                              String title,
                                                              String prompt) {
        return addTopLabelTextArea(gridPane, rowIndex, colIndex, title, prompt, 0);
    }

    public static Tuple2<Label, TextArea> addTopLabelTextArea(GridPane gridPane,
                                                              int rowIndex,
                                                              String title,
                                                              String prompt,
                                                              double top) {

        return addTopLabelTextArea(gridPane, rowIndex, 0, title, prompt, top);
    }

    public static Tuple2<Label, TextArea> addTopLabelTextArea(GridPane gridPane, int rowIndex, int colIndex,
                                                              String title, String prompt, double top) {

        TextArea textArea = new BisqTextArea();
        textArea.setPromptText(prompt);
        textArea.setWrapText(true);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, textArea, top);
        GridPane.setColumnIndex(topLabelWithVBox.second, colIndex);

        return new Tuple2<>(topLabelWithVBox.first, textArea);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + DatePicker
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, DatePicker> addTopLabelDatePicker(GridPane gridPane,
                                                                  int rowIndex,
                                                                  String title,
                                                                  double top) {
        return addTopLabelDatePicker(gridPane, rowIndex, 0, title, top);
    }

    public static Tuple2<Label, DatePicker> addTopLabelDatePicker(GridPane gridPane,
                                                                  int rowIndex,
                                                                  int columnIndex,
                                                                  String title,
                                                                  double top) {
        DatePicker datePicker = new JFXDatePicker();
        Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, columnIndex, title, datePicker, top);
        return new Tuple2<>(topLabelWithVBox.first, datePicker);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // 2 DatePickers
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<DatePicker, DatePicker> add2TopLabelDatePicker(GridPane gridPane,
                                                                        int rowIndex,
                                                                        int columnIndex,
                                                                        String title1,
                                                                        String title2,
                                                                        double top) {
        DatePicker datePicker1 = new JFXDatePicker();
        Tuple2<Label, VBox> topLabelWithVBox1 = getTopLabelWithVBox(title1, datePicker1);
        VBox vBox1 = topLabelWithVBox1.second;

        DatePicker datePicker2 = new JFXDatePicker();
        Tuple2<Label, VBox> topLabelWithVBox2 = getTopLabelWithVBox(title2, datePicker2);
        VBox vBox2 = topLabelWithVBox2.second;

        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.getChildren().addAll(spacer, vBox1, vBox2);

        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setColumnIndex(hBox, columnIndex);
        GridPane.setMargin(hBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(hBox);
        return new Tuple2<>(datePicker1, datePicker2);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + TxIdTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    @SuppressWarnings(""UnusedReturnValue"")
    public static Tuple2<Label, TxIdTextField> addLabelTxIdTextField(GridPane gridPane,
                                                                     int rowIndex,
                                                                     String title,
                                                                     String value) {
        return addLabelTxIdTextField(gridPane, rowIndex, title, value, 0);
    }

    public static Tuple2<Label, TxIdTextField> addLabelTxIdTextField(GridPane gridPane,
                                                                     int rowIndex,
                                                                     String title,
                                                                     String value,
                                                                     double top) {
        Label label = addLabel(gridPane, rowIndex, title, top);
        label.getStyleClass().add(""confirmation-label"");
        GridPane.setHalignment(label, HPos.LEFT);

        TxIdTextField txTextField = new TxIdTextField();
        txTextField.setup(value);
        GridPane.setRowIndex(txTextField, rowIndex);
        GridPane.setColumnIndex(txTextField, 1);
        gridPane.getChildren().add(txTextField);

        return new Tuple2<>(label, txTextField);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + ExplorerAddressTextField
    ///////////////////////////////////////////////////////////////////////////////////////////
    public static void addLabelExplorerAddressTextField(GridPane gridPane,
                                                        int rowIndex,
                                                        String title,
                                                        String address) {
        Label label = addLabel(gridPane, rowIndex, title, 0);
        label.getStyleClass().add(""confirmation-label"");
        GridPane.setHalignment(label, HPos.LEFT);

        ExplorerAddressTextField addressTextField = new ExplorerAddressTextField();
        addressTextField.setup(address);
        GridPane.setRowIndex(addressTextField, rowIndex);
        GridPane.setColumnIndex(addressTextField, 1);
        gridPane.getChildren().add(addressTextField);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + InputTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static InputTextField addInputTextField(GridPane gridPane, int rowIndex, String title) {
        return addInputTextField(gridPane, rowIndex, title, 0);
    }

    public static InputTextField addInputTextField(GridPane gridPane, int rowIndex, String title, double top) {

        InputTextField inputTextField = new InputTextField();
        inputTextField.setLabelFloat(true);
        inputTextField.setPromptText(title);
        GridPane.setRowIndex(inputTextField, rowIndex);
        GridPane.setColumnIndex(inputTextField, 0);
        GridPane.setMargin(inputTextField, new Insets(top + Layout.FLOATING_LABEL_DISTANCE, 0, 0, 0));
        gridPane.getChildren().add(inputTextField);

        return inputTextField;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + InputTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, InputTextField> addTopLabelInputTextField(GridPane gridPane,
                                                                          int rowIndex,
                                                                          String title) {
        return addTopLabelInputTextField(gridPane, rowIndex, title, 0);
    }

    public static Tuple2<Label, InputTextField> addTopLabelInputTextField(GridPane gridPane,
                                                                          int rowIndex,
                                                                          String title,
                                                                          double top) {

        final Tuple3<Label, InputTextField, VBox> topLabelWithVBox = addTopLabelInputTextFieldWithVBox(gridPane, rowIndex, title, top);

        return new Tuple2<>(topLabelWithVBox.first, topLabelWithVBox.second);
    }

    public static Tuple3<Label, InputTextField, VBox> addTopLabelInputTextFieldWithVBox(GridPane gridPane,
                                                                                        int rowIndex,
                                                                                        String title,
                                                                                        double top) {

        InputTextField inputTextField = new InputTextField();

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, inputTextField, top);

        return new Tuple3<>(topLabelWithVBox.first, inputTextField, topLabelWithVBox.second);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + InfoInputTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, InfoInputTextField> addTopLabelInfoInputTextField(GridPane gridPane,
                                                                                  int rowIndex,
                                                                                  String title) {
        return addTopLabelInfoInputTextField(gridPane, rowIndex, title, 0);
    }

    public static Tuple2<Label, InfoInputTextField> addTopLabelInfoInputTextField(GridPane gridPane,
                                                                                  int rowIndex,
                                                                                  String title,
                                                                                  double top) {

        InfoInputTextField inputTextField = new InfoInputTextField();

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, inputTextField, top);

        return new Tuple2<>(topLabelWithVBox.first, inputTextField);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // PasswordField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static PasswordTextField addPasswordTextField(GridPane gridPane, int rowIndex, String title) {
        return addPasswordTextField(gridPane, rowIndex, title, 0);
    }

    public static PasswordTextField addPasswordTextField(GridPane gridPane, int rowIndex, String title, double top) {
        PasswordTextField passwordField = new PasswordTextField();
        passwordField.setPromptText(title);
        GridPane.setRowIndex(passwordField, rowIndex);
        GridPane.setColumnIndex(passwordField, 0);
        GridPane.setColumnSpan(passwordField, 2);
        GridPane.setMargin(passwordField, new Insets(top + 10, 0, 20, 0));
        gridPane.getChildren().add(passwordField);

        return passwordField;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + InputTextField + CheckBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, InputTextField, ToggleButton> addTopLabelInputTextFieldSlideToggleButton(GridPane gridPane,
                                                                                                         int rowIndex,
                                                                                                         String title,
                                                                                                         String toggleButtonTitle) {

        InputTextField inputTextField = new InputTextField();
        ToggleButton toggleButton = new JFXToggleButton();
        toggleButton.setText(toggleButtonTitle);
        VBox.setMargin(toggleButton, new Insets(4, 0, 0, 0));

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, inputTextField, 0);

        topLabelWithVBox.second.getChildren().add(toggleButton);

        return new Tuple3<>(topLabelWithVBox.first, inputTextField, toggleButton);
    }


    public static Tuple3<Label, InputTextField, ToggleButton> addTopLabelInputTextFieldSlideToggleButtonRight(GridPane gridPane,
                                                                                                         int rowIndex,
                                                                                                         String title,
                                                                                                         String toggleButtonTitle) {

        InputTextField inputTextField = new InputTextField();
        Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, inputTextField, 0);
        ToggleButton toggleButton = new JFXToggleButton();
        toggleButton.setText(toggleButtonTitle);
        HBox hBox = new HBox();
        hBox.getChildren().addAll(topLabelWithVBox.second, toggleButton);
        HBox.setMargin(toggleButton, new Insets(9, 0, 0, 0));
        gridPane.add(hBox, 0, rowIndex);
        GridPane.setMargin(hBox, new Insets(Layout.FLOATING_LABEL_DISTANCE, 0, 0, 0));
        return new Tuple3<>(topLabelWithVBox.first, inputTextField, toggleButton);
    }



    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + InputTextField + Button
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, InputTextField, Button> addTopLabelInputTextFieldButton(GridPane gridPane,
                                                                                        int rowIndex,
                                                                                        String title,
                                                                                        String buttonTitle) {
        InputTextField inputTextField = new InputTextField();
        Button button = new AutoTooltipButton(buttonTitle);
        button.setDefaultButton(true);

        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.getChildren().addAll(inputTextField, button);
        HBox.setHgrow(inputTextField, Priority.ALWAYS);

        final Tuple2<Label, VBox> labelVBoxTuple2 = addTopLabelWithVBox(gridPane, rowIndex, title, hBox, 0);

        return new Tuple3<>(labelVBoxTuple2.first, inputTextField, button);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + TextField + Button
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, TextField, Button> addTopLabelTextFieldButton(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String title,
                                                                              String buttonTitle) {
        return addTopLabelTextFieldButton(gridPane, rowIndex, title, buttonTitle, 0);
    }

    public static Tuple3<Label, TextField, Button> addTopLabelTextFieldButton(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String title,
                                                                              String buttonTitle,
                                                                              double top) {

        TextField textField = new BisqTextField();
        textField.setEditable(false);
        textField.setMouseTransparent(true);
        textField.setFocusTraversable(false);
        Button button = new AutoTooltipButton(buttonTitle);
        button.setDefaultButton(true);

        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.getChildren().addAll(textField, button);
        HBox.setHgrow(textField, Priority.ALWAYS);

        final Tuple2<Label, VBox> labelVBoxTuple2 = addTopLabelWithVBox(gridPane, rowIndex, title, hBox, top);

        return new Tuple3<>(labelVBoxTuple2.first, textField, button);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + InputTextField + Label  + InputTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<InputTextField, InputTextField> addInputTextFieldInputTextField(GridPane gridPane,
                                                                                         int rowIndex,
                                                                                         String title1,
                                                                                         String title2) {

        InputTextField inputTextField1 = new InputTextField();
        inputTextField1.setPromptText(title1);
        inputTextField1.setLabelFloat(true);
        InputTextField inputTextField2 = new InputTextField();
        inputTextField2.setLabelFloat(true);
        inputTextField2.setPromptText(title2);

        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.getChildren().addAll(inputTextField1, inputTextField2);
        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setColumnIndex(hBox, 0);
        GridPane.setMargin(hBox, new Insets(Layout.FLOATING_LABEL_DISTANCE, 0, 0, 0));
        gridPane.getChildren().add(hBox);

        return new Tuple2<>(inputTextField1, inputTextField2);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + TextField + Label  + TextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple4<Label, TextField, Label, TextField> addCompactTopLabelTextFieldTopLabelTextField(GridPane gridPane,
                                                                                                          int rowIndex,
                                                                                                          String title1,
                                                                                                          String title2) {
        TextField textField1 = new BisqTextField();
        textField1.setEditable(false);
        textField1.setMouseTransparent(true);
        textField1.setFocusTraversable(false);

        final Tuple2<Label, VBox> topLabelWithVBox1 = getTopLabelWithVBox(title1, textField1);

        TextField textField2 = new BisqTextField();
        textField2.setEditable(false);
        textField2.setMouseTransparent(true);
        textField2.setFocusTraversable(false);

        final Tuple2<Label, VBox> topLabelWithVBox2 = getTopLabelWithVBox(title2, textField2);

        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.getChildren().addAll(topLabelWithVBox1.second, topLabelWithVBox2.second);
        GridPane.setRowIndex(hBox, rowIndex);
        gridPane.getChildren().add(hBox);

        return new Tuple4<>(topLabelWithVBox1.first, textField1, topLabelWithVBox2.first, textField2);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Button + CheckBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Button, CheckBox> addButtonCheckBox(GridPane gridPane,
                                                             int rowIndex,
                                                             String buttonTitle,
                                                             String checkBoxTitle) {
        return addButtonCheckBox(gridPane, rowIndex, buttonTitle, checkBoxTitle, 0);
    }

    public static Tuple2<Button, CheckBox> addButtonCheckBox(GridPane gridPane,
                                                             int rowIndex,
                                                             String buttonTitle,
                                                             String checkBoxTitle,
                                                             double top) {
        final Tuple3<Button, CheckBox, HBox> tuple = addButtonCheckBoxWithBox(gridPane, rowIndex, buttonTitle, checkBoxTitle, top);
        return new Tuple2<>(tuple.first, tuple.second);
    }

    public static Tuple3<Button, CheckBox, HBox> addButtonCheckBoxWithBox(GridPane gridPane,
                                                                          int rowIndex,
                                                                          String buttonTitle,
                                                                          String checkBoxTitle,
                                                                          double top) {
        Button button = new AutoTooltipButton(buttonTitle);
        CheckBox checkBox = new AutoTooltipCheckBox(checkBoxTitle);

        HBox hBox = new HBox(20);
        hBox.setAlignment(Pos.CENTER_LEFT);
        hBox.getChildren().addAll(button, checkBox);
        GridPane.setRowIndex(hBox, rowIndex);
        hBox.setPadding(new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(hBox);

        return new Tuple3<>(button, checkBox, hBox);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // CheckBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static CheckBox addCheckBox(GridPane gridPane, int rowIndex, String checkBoxTitle) {
        return addCheckBox(gridPane, rowIndex, checkBoxTitle, 0);
    }

    public static CheckBox addCheckBox(GridPane gridPane, int rowIndex, String checkBoxTitle, double top) {
        return addCheckBox(gridPane, rowIndex, 0, checkBoxTitle, top);
    }

    public static CheckBox addCheckBox(GridPane gridPane,
                                       int rowIndex,
                                       int colIndex,
                                       String checkBoxTitle,
                                       double top) {
        CheckBox checkBox = new AutoTooltipCheckBox(checkBoxTitle);
        GridPane.setMargin(checkBox, new Insets(top, 0, 0, 0));
        GridPane.setRowIndex(checkBox, rowIndex);
        GridPane.setColumnIndex(checkBox, colIndex);
        gridPane.getChildren().add(checkBox);
        return checkBox;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // RadioButton
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static RadioButton addRadioButton(GridPane gridPane, int rowIndex, ToggleGroup toggleGroup, String title) {
        RadioButton radioButton = new AutoTooltipRadioButton(title);
        radioButton.setToggleGroup(toggleGroup);
        GridPane.setRowIndex(radioButton, rowIndex);
        gridPane.getChildren().add(radioButton);
        return radioButton;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + RadioButton + RadioButton
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, RadioButton, RadioButton> addTopLabelRadioButtonRadioButton(GridPane gridPane,
                                                                                            int rowIndex,
                                                                                            ToggleGroup toggleGroup,
                                                                                            String title,
                                                                                            String radioButtonTitle1,
                                                                                            String radioButtonTitle2,
                                                                                            double top) {
        RadioButton radioButton1 = new AutoTooltipRadioButton(radioButtonTitle1);
        radioButton1.setToggleGroup(toggleGroup);
        radioButton1.setPadding(new Insets(6, 0, 0, 0));

        RadioButton radioButton2 = new AutoTooltipRadioButton(radioButtonTitle2);
        radioButton2.setToggleGroup(toggleGroup);
        radioButton2.setPadding(new Insets(6, 0, 0, 0));

        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.getChildren().addAll(radioButton1, radioButton2);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, hBox, top);

        return new Tuple3<>(topLabelWithVBox.first, radioButton1, radioButton2);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + TextField + RadioButton + RadioButton
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple4<Label, TextField, RadioButton, RadioButton> addTopLabelTextFieldRadioButtonRadioButton(GridPane gridPane,
                                                                                                                int rowIndex,
                                                                                                                ToggleGroup toggleGroup,
                                                                                                                String title,
                                                                                                                String textFieldTitle,
                                                                                                                String radioButtonTitle1,
                                                                                                                String radioButtonTitle2,
                                                                                                                double top) {
        TextField textField = new BisqTextField();
        textField.setPromptText(textFieldTitle);

        RadioButton radioButton1 = new AutoTooltipRadioButton(radioButtonTitle1);
        radioButton1.setToggleGroup(toggleGroup);
        radioButton1.setPadding(new Insets(6, 0, 0, 0));

        RadioButton radioButton2 = new AutoTooltipRadioButton(radioButtonTitle2);
        radioButton2.setToggleGroup(toggleGroup);
        radioButton2.setPadding(new Insets(6, 0, 0, 0));

        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.getChildren().addAll(textField, radioButton1, radioButton2);

        final Tuple2<Label, VBox> labelVBoxTuple2 = addTopLabelWithVBox(gridPane, rowIndex, title, hBox, top);

        return new Tuple4<>(labelVBoxTuple2.first, textField, radioButton1, radioButton2);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + CheckBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static CheckBox addLabelCheckBox(GridPane gridPane, int rowIndex, String title) {
        return addLabelCheckBox(gridPane, rowIndex, title, 0);
    }

    public static CheckBox addLabelCheckBox(GridPane gridPane, int rowIndex, String title, double top) {
        CheckBox checkBox = new AutoTooltipCheckBox(title);
        GridPane.setRowIndex(checkBox, rowIndex);
        GridPane.setColumnIndex(checkBox, 0);
        GridPane.setMargin(checkBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(checkBox);

        return checkBox;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // SlideToggleButton
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static ToggleButton addSlideToggleButton(GridPane gridPane, int rowIndex, String title) {
        return addSlideToggleButton(gridPane, rowIndex, title, 0);
    }

    public static ToggleButton addSlideToggleButton(GridPane gridPane, int rowIndex, String title, double top) {
        ToggleButton toggleButton = new AutoTooltipSlideToggleButton();
        toggleButton.setText(title);
        GridPane.setRowIndex(toggleButton, rowIndex);
        GridPane.setColumnIndex(toggleButton, 0);
        GridPane.setMargin(toggleButton, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(toggleButton);

        return toggleButton;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // ComboBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> ComboBox<T> addComboBox(GridPane gridPane, int rowIndex, int top) {
        final JFXComboBox<T> comboBox = new JFXComboBox<>();

        GridPane.setRowIndex(comboBox, rowIndex);
        GridPane.setMargin(comboBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(comboBox);
        return comboBox;

    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + ComboBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> Tuple2<Label, ComboBox<T>> addTopLabelComboBox(GridPane gridPane,
                                                                     int rowIndex,
                                                                     String title,
                                                                     String prompt,
                                                                     int top) {
        final Tuple3<VBox, Label, ComboBox<T>> tuple3 = addTopLabelComboBox(title, prompt, 0);
        final VBox vBox = tuple3.first;

        GridPane.setRowIndex(vBox, rowIndex);
        GridPane.setMargin(vBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(vBox);

        return new Tuple2<>(tuple3.second, tuple3.third);
    }

    public static <T> Tuple3<VBox, Label, ComboBox<T>> addTopLabelComboBox(String title, String prompt) {
        return addTopLabelComboBox(title, prompt, 0);
    }

    public static <T> Tuple3<VBox, Label, ComboBox<T>> addTopLabelComboBox(String title, String prompt, int top) {
        Label label = getTopLabel(title);
        VBox vBox = getTopLabelVBox(top);

        final JFXComboBox<T> comboBox = new JFXComboBox<>();
        comboBox.setPromptText(prompt);

        vBox.getChildren().addAll(label, comboBox);

        return new Tuple3<>(vBox, label, comboBox);
    }

    public static <T> Tuple3<VBox, Label, AutocompleteComboBox<T>> addTopLabelAutocompleteComboBox(String title) {
        return addTopLabelAutocompleteComboBox(title, 0);
    }

    public static <T> Tuple3<VBox, Label, AutocompleteComboBox<T>> addTopLabelAutocompleteComboBox(String title,
                                                                                                   int top) {
        Label label = getTopLabel(title);
        VBox vBox = getTopLabelVBox(top);

        final AutocompleteComboBox<T> comboBox = new AutocompleteComboBox<>();

        vBox.getChildren().addAll(label, comboBox);

        return new Tuple3<>(vBox, label, comboBox);
    }

    @NotNull
    private static VBox getTopLabelVBox(int top) {
        VBox vBox = new VBox();
        vBox.setSpacing(0);
        vBox.setPadding(new Insets(top, 0, 0, 0));
        vBox.setAlignment(Pos.CENTER_LEFT);
        return vBox;
    }

    @NotNull
    private static Label getTopLabel(String title) {
        Label label = new AutoTooltipLabel(title);
        label.getStyleClass().add(""small-text"");
        return label;
    }

    public static Tuple2<Label, VBox> addTopLabelWithVBox(GridPane gridPane,
                                                          int rowIndex,
                                                          String title,
                                                          Node node,
                                                          double top) {
        return addTopLabelWithVBox(gridPane, rowIndex, 0, title, node, top);
    }

    @NotNull
    public static Tuple2<Label, VBox> addTopLabelWithVBox(GridPane gridPane,
                                                          int rowIndex,
                                                          int columnIndex,
                                                          String title,
                                                          Node node,
                                                          double top) {
        final Tuple2<Label, VBox> topLabelWithVBox = getTopLabelWithVBox(title, node);
        VBox vBox = topLabelWithVBox.second;

        GridPane.setRowIndex(vBox, rowIndex);
        GridPane.setColumnIndex(vBox, columnIndex);
        GridPane.setMargin(vBox, new Insets(top + Layout.FLOATING_LABEL_DISTANCE, 0, 0, 0));
        gridPane.getChildren().add(vBox);

        return new Tuple2<>(topLabelWithVBox.first, vBox);
    }

    @NotNull
    public static Tuple2<Label, VBox> getTopLabelWithVBox(String title, Node node) {
        Label label = getTopLabel(title);
        VBox vBox = getTopLabelVBox(0);
        vBox.getChildren().addAll(label, node);

        return new Tuple2<>(label, vBox);
    }

    public static Tuple3<Label, TextField, HBox> addTopLabelTextFieldWithHbox(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String titleTextfield,
                                                                              double top) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);

        TextField textField = new BisqTextField();

        final VBox topLabelVBox = getTopLabelVBox(5);
        final Label topLabel = getTopLabel(titleTextfield);
        topLabelVBox.getChildren().addAll(topLabel, textField);

        hBox.getChildren().addAll(topLabelVBox);

        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setMargin(hBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(hBox);

        return new Tuple3<>(topLabel, textField, hBox);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + ComboBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> ComboBox<T> addComboBox(GridPane gridPane, int rowIndex) {
        return addComboBox(gridPane, rowIndex, null, 0);
    }

    public static <T> ComboBox<T> addComboBox(GridPane gridPane, int rowIndex, String title) {
        return addComboBox(gridPane, rowIndex, title, 0);
    }

    public static <T> ComboBox<T> addComboBox(GridPane gridPane, int rowIndex, String title, double top) {
        JFXComboBox<T> comboBox = new JFXComboBox<>();
        comboBox.setLabelFloat(true);
        comboBox.setPromptText(title);
        comboBox.setMaxWidth(Double.MAX_VALUE);

        // Default ComboBox does not show promptText after clear selection.
        // https://stackoverflow.com/questions/50569330/how-to-reset-combobox-and-display-prompttext?noredirect=1&lq=1
        comboBox.setButtonCell(getComboBoxButtonCell(title, comboBox));

        GridPane.setRowIndex(comboBox, rowIndex);
        GridPane.setColumnIndex(comboBox, 0);
        GridPane.setMargin(comboBox, new Insets(top + Layout.FLOATING_LABEL_DISTANCE, 0, 0, 0));
        gridPane.getChildren().add(comboBox);

        return comboBox;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + AutocompleteComboBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> Tuple2<Label, ComboBox<T>> addLabelAutocompleteComboBox(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String title,
                                                                              double top) {
        AutocompleteComboBox<T> comboBox = new AutocompleteComboBox<>();
        final Tuple2<Label, VBox> labelVBoxTuple2 = addTopLabelWithVBox(gridPane, rowIndex, title, comboBox, top);
        return new Tuple2<>(labelVBoxTuple2.first, comboBox);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + TextField + AutocompleteComboBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> Tuple4<Label, TextField, Label, ComboBox<T>> addTopLabelTextFieldAutocompleteComboBox(
            GridPane gridPane,
            int rowIndex,
            String titleTextfield,
            String titleCombobox
    ) {
        return addTopLabelTextFieldAutocompleteComboBox(gridPane, rowIndex, titleTextfield, titleCombobox, 0);
    }

    public static <T> Tuple4<Label, TextField, Label, ComboBox<T>> addTopLabelTextFieldAutocompleteComboBox(
            GridPane gridPane,
            int rowIndex,
            String titleTextfield,
            String titleCombobox,
            double top
    ) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);

        final VBox topLabelVBox1 = getTopLabelVBox(5);
        final Label topLabel1 = getTopLabel(titleTextfield);
        final TextField textField = new BisqTextField();
        topLabelVBox1.getChildren().addAll(topLabel1, textField);

        final VBox topLabelVBox2 = getTopLabelVBox(5);
        final Label topLabel2 = getTopLabel(titleCombobox);
        AutocompleteComboBox<T> comboBox = new AutocompleteComboBox<>();
        comboBox.setPromptText(titleCombobox);
        comboBox.setLabelFloat(true);
        topLabelVBox2.getChildren().addAll(topLabel2, comboBox);

        hBox.getChildren().addAll(topLabelVBox1, topLabelVBox2);

        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setMargin(hBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(hBox);

        return new Tuple4<>(topLabel1, textField, topLabel2, comboBox);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + ComboBox + ComboBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T, R> Tuple3<Label, ComboBox<R>, ComboBox<T>> addTopLabelComboBoxComboBox(GridPane gridPane,
                                                                                             int rowIndex,
                                                                                             String title) {
        return addTopLabelComboBoxComboBox(gridPane, rowIndex, title, 0);
    }

    public static <T, R> Tuple3<Label, ComboBox<T>, ComboBox<R>> addTopLabelComboBoxComboBox(GridPane gridPane,
                                                                                             int rowIndex,
                                                                                             String title,
                                                                                             double top) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);

        ComboBox<T> comboBox1 = new JFXComboBox<>();
        ComboBox<R> comboBox2 = new JFXComboBox<>();
        hBox.getChildren().addAll(comboBox1, comboBox2);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, hBox, top);

        return new Tuple3<>(topLabelWithVBox.first, comboBox1, comboBox2);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + ComboBox + TextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> Tuple4<ComboBox<T>, Label, TextField, HBox> addComboBoxTopLabelTextField(GridPane gridPane,
                                                                                               int rowIndex,
                                                                                               String titleCombobox,
                                                                                               String titleTextfield) {
        return addComboBoxTopLabelTextField(gridPane, rowIndex, titleCombobox, titleTextfield, 0);
    }

    public static <T> Tuple4<ComboBox<T>, Label, TextField, HBox> addComboBoxTopLabelTextField(GridPane gridPane,
                                                                                               int rowIndex,
                                                                                               String titleCombobox,
                                                                                               String titleTextfield,
                                                                                               double top) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);

        JFXComboBox<T> comboBox = new JFXComboBox<>();
        comboBox.setPromptText(titleCombobox);
        comboBox.setLabelFloat(true);

        TextField textField = new BisqTextField();

        final VBox topLabelVBox = getTopLabelVBox(5);
        final Label topLabel = getTopLabel(titleTextfield);
        topLabelVBox.getChildren().addAll(topLabel, textField);

        hBox.getChildren().addAll(comboBox, topLabelVBox);

        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setMargin(hBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(hBox);

        return new Tuple4<>(comboBox, topLabel, textField, hBox);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + ComboBox + Button
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> Tuple3<Label, ComboBox<T>, Button> addLabelComboBoxButton(GridPane gridPane,
                                                                                int rowIndex,
                                                                                String title,
                                                                                String buttonTitle) {
        return addLabelComboBoxButton(gridPane, rowIndex, title, buttonTitle, 0);
    }

    public static <T> Tuple3<Label, ComboBox<T>, Button> addLabelComboBoxButton(GridPane gridPane,
                                                                                int rowIndex,
                                                                                String title,
                                                                                String buttonTitle,
                                                                                double top) {
        Label label = addLabel(gridPane, rowIndex, title, top);

        HBox hBox = new HBox();
        hBox.setSpacing(10);

        Button button = new AutoTooltipButton(buttonTitle);
        button.setDefaultButton(true);

        ComboBox<T> comboBox = new JFXComboBox<>();

        hBox.getChildren().addAll(comboBox, button);

        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setColumnIndex(hBox, 1);
        GridPane.setMargin(hBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(hBox);

        return new Tuple3<>(label, comboBox, button);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + ComboBox + Label
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> Tuple3<Label, ComboBox<T>, TextField> addLabelComboBoxLabel(GridPane gridPane,
                                                                                  int rowIndex,
                                                                                  String title,
                                                                                  String textFieldText) {
        return addLabelComboBoxLabel(gridPane, rowIndex, title, textFieldText, 0);
    }

    public static <T> Tuple3<Label, ComboBox<T>, TextField> addLabelComboBoxLabel(GridPane gridPane,
                                                                                  int rowIndex,
                                                                                  String title,
                                                                                  String textFieldText,
                                                                                  double top) {
        Label label = addLabel(gridPane, rowIndex, title, top);

        HBox hBox = new HBox();
        hBox.setSpacing(10);

        ComboBox<T> comboBox = new JFXComboBox<>();
        TextField textField = new TextField(textFieldText);
        textField.setEditable(false);
        textField.setMouseTransparent(true);
        textField.setFocusTraversable(false);

        hBox.getChildren().addAll(comboBox, textField);
        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setColumnIndex(hBox, 1);
        GridPane.setMargin(hBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(hBox);

        return new Tuple3<>(label, comboBox, textField);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + TxIdTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, TxIdTextField> addLabelTxIdTextField(GridPane gridPane,
                                                                     int rowIndex,
                                                                     int columnIndex,
                                                                     String title) {
        return addLabelTxIdTextField(gridPane, rowIndex, columnIndex, title, 0);
    }

    public static Tuple2<Label, TxIdTextField> addLabelTxIdTextField(GridPane gridPane,
                                                                     int rowIndex,
                                                                     int columnIndex,
                                                                     String title,
                                                                     double top) {
        Label label = addLabel(gridPane, rowIndex, title, top);

        TxIdTextField txIdTextField = new TxIdTextField();
        GridPane.setRowIndex(txIdTextField, rowIndex);
        GridPane.setColumnIndex(txIdTextField, columnIndex);
        GridPane.setMargin(txIdTextField, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(txIdTextField);

        return new Tuple2<>(label, txIdTextField);
    }


    public static Tuple3<Label, TxIdTextField, VBox> addTopLabelTxIdTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String title,
                                                                              double top) {
        TxIdTextField textField = new TxIdTextField();
        textField.setFocusTraversable(false);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, textField, top);

        // TODO not 100% sure if that is a good idea....
        //topLabelWithVBox.first.getStyleClass().add(""jfx-text-field-top-label"");

        return new Tuple3<>(topLabelWithVBox.first, textField, topLabelWithVBox.second);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + TextFieldWithCopyIcon
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, TextFieldWithCopyIcon> addCompactTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                               int rowIndex,
                                                                                               String title,
                                                                                               String value) {
        return addTopLabelTextFieldWithCopyIcon(gridPane, rowIndex, title, value, -Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addCompactTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                               int rowIndex,
                                                                                               int colIndex,
                                                                                               String title,
                                                                                               String value,
                                                                                               double top) {
        return addTopLabelTextFieldWithCopyIcon(gridPane, rowIndex, colIndex, title, value, top - Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addCompactTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                               int rowIndex,
                                                                                               int colIndex,
                                                                                               String title) {
        return addTopLabelTextFieldWithCopyIcon(gridPane, rowIndex, colIndex, title, """", -Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addCompactTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                               int rowIndex,
                                                                                               int colIndex,
                                                                                               String title,
                                                                                               String value) {
        return addTopLabelTextFieldWithCopyIcon(gridPane, rowIndex, colIndex, title, value, -Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addCompactTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                               int rowIndex,
                                                                                               int colIndex,
                                                                                               String title,
                                                                                               String value,
                                                                                               boolean onlyCopyTextAfterDelimiter) {
        return addTopLabelTextFieldWithCopyIcon(gridPane, rowIndex, colIndex, title, value, -Layout.FLOATING_LABEL_DISTANCE, onlyCopyTextAfterDelimiter);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                        int rowIndex,
                                                                                        String title,
                                                                                        String value) {
        return addTopLabelTextFieldWithCopyIcon(gridPane, rowIndex, title, value, 0);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                        int rowIndex,
                                                                                        String title,
                                                                                        String value,
                                                                                        double top) {
        return addTopLabelTextFieldWithCopyIcon(gridPane, rowIndex, title, value, top, null);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                        int rowIndex,
                                                                                        String title,
                                                                                        String value,
                                                                                        double top,
                                                                                        String styleClass) {
        TextFieldWithCopyIcon textFieldWithCopyIcon = new TextFieldWithCopyIcon(styleClass);
        textFieldWithCopyIcon.setText(value);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, textFieldWithCopyIcon, top);

        return new Tuple2<>(topLabelWithVBox.first, textFieldWithCopyIcon);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                        int rowIndex,
                                                                                        int colIndex,
                                                                                        String title,
                                                                                        String value,
                                                                                        double top,
                                                                                        boolean onlyCopyTextAfterDelimiter) {

        TextFieldWithCopyIcon textFieldWithCopyIcon = new TextFieldWithCopyIcon();
        textFieldWithCopyIcon.setText(value);
        textFieldWithCopyIcon.setCopyTextAfterDelimiter(true);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, textFieldWithCopyIcon, top);
        topLabelWithVBox.second.setAlignment(Pos.TOP_LEFT);
        GridPane.setColumnIndex(topLabelWithVBox.second, colIndex);

        return new Tuple2<>(topLabelWithVBox.first, textFieldWithCopyIcon);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addTopLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                        int rowIndex,
                                                                                        int colIndex,
                                                                                        String title,
                                                                                        String value,
                                                                                        double top) {

        TextFieldWithCopyIcon textFieldWithCopyIcon = new TextFieldWithCopyIcon();
        textFieldWithCopyIcon.setText(value);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, textFieldWithCopyIcon, top);
        topLabelWithVBox.second.setAlignment(Pos.TOP_LEFT);
        GridPane.setColumnIndex(topLabelWithVBox.second, colIndex);

        return new Tuple2<>(topLabelWithVBox.first, textFieldWithCopyIcon);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addConfirmationLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                                 int rowIndex,
                                                                                                 String title,
                                                                                                 String value) {
        return addConfirmationLabelTextFieldWithCopyIcon(gridPane, rowIndex, title, value, 0);
    }

    public static Tuple2<Label, TextFieldWithCopyIcon> addConfirmationLabelTextFieldWithCopyIcon(GridPane gridPane,
                                                                                                 int rowIndex,
                                                                                                 String title,
                                                                                                 String value,
                                                                                                 double top) {
        Label label = addLabel(gridPane, rowIndex, title, top);
        label.getStyleClass().add(""confirmation-label"");
        GridPane.setHalignment(label, HPos.LEFT);

        TextFieldWithCopyIcon textFieldWithCopyIcon = new TextFieldWithCopyIcon(""confirmation-text-field-as-label"");
        textFieldWithCopyIcon.setText(value);
        GridPane.setRowIndex(textFieldWithCopyIcon, rowIndex);
        GridPane.setColumnIndex(textFieldWithCopyIcon, 1);
        GridPane.setMargin(textFieldWithCopyIcon, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(textFieldWithCopyIcon);

        return new Tuple2<>(label, textFieldWithCopyIcon);
    }
    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + AddressTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static AddressTextField addAddressTextField(GridPane gridPane, int rowIndex, String title) {
        return addAddressTextField(gridPane, rowIndex, title, 0);
    }

    public static AddressTextField addAddressTextField(GridPane gridPane, int rowIndex, String title, double top) {
        AddressTextField addressTextField = new AddressTextField(title);
        GridPane.setRowIndex(addressTextField, rowIndex);
        GridPane.setColumnIndex(addressTextField, 0);
        GridPane.setMargin(addressTextField, new Insets(top + 20, 0, 0, 0));
        gridPane.getChildren().add(addressTextField);

        return addressTextField;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + FundsTextField
    ///////////////////////////////////////////////////////////////////////////////////////////
    public static FundsTextField addFundsTextfield(GridPane gridPane, int rowIndex, String text) {
        return addFundsTextfield(gridPane, rowIndex, text, 0);
    }

    public static FundsTextField addFundsTextfield(GridPane gridPane, int rowIndex, String text, double top) {

        FundsTextField fundsTextField = new FundsTextField();
        fundsTextField.getTextField().setPromptText(text);
        GridPane.setRowIndex(fundsTextField, rowIndex);
        GridPane.setColumnIndex(fundsTextField, 0);
        GridPane.setMargin(fundsTextField, new Insets(top + 20, 0, 0, 0));
        gridPane.getChildren().add(fundsTextField);

        return fundsTextField;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + InfoTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, InfoTextField, VBox> addCompactTopLabelInfoTextField(GridPane gridPane,
                                                                                     int rowIndex,
                                                                                     String labelText,
                                                                                     String fieldText) {
        return addTopLabelInfoTextField(gridPane, rowIndex, labelText, fieldText,
                -Layout.FLOATING_LABEL_DISTANCE);
    }

    public static Tuple3<Label, InfoTextField, VBox> addTopLabelInfoTextField(GridPane gridPane,
                                                                              int rowIndex,
                                                                              String labelText,
                                                                              String fieldText,
                                                                              double top) {
        InfoTextField infoTextField = new InfoTextField();
        infoTextField.setText(fieldText);

        final Tuple2<Label, VBox> labelVBoxTuple2 = addTopLabelWithVBox(gridPane, rowIndex, labelText, infoTextField, top);

        return new Tuple3<>(labelVBoxTuple2.first, infoTextField, labelVBoxTuple2.second);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + BsqAddressTextField
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, BsqAddressTextField, VBox> addLabelBsqAddressTextField(GridPane gridPane,
                                                                                       int rowIndex,
                                                                                       String title) {
        return addLabelBsqAddressTextField(gridPane, rowIndex, title, 0);
    }

    public static Tuple3<Label, BsqAddressTextField, VBox> addLabelBsqAddressTextField(GridPane gridPane,
                                                                                       int rowIndex,
                                                                                       String title,
                                                                                       double top) {
        BsqAddressTextField addressTextField = new BsqAddressTextField();
        addressTextField.setFocusTraversable(false);

        Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, addressTextField, top - 15);

        return new Tuple3<>(topLabelWithVBox.first, addressTextField, topLabelWithVBox.second);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + BalanceTextField
    ///////////////////////////////////////////////////////////////////////////////////////////


    public static BalanceTextField addBalanceTextField(GridPane gridPane, int rowIndex, String title) {
        return addBalanceTextField(gridPane, rowIndex, title, 20);
    }

    public static BalanceTextField addBalanceTextField(GridPane gridPane, int rowIndex, String title, double top) {
        BalanceTextField balanceTextField = new BalanceTextField(title);
        GridPane.setRowIndex(balanceTextField, rowIndex);
        GridPane.setColumnIndex(balanceTextField, 0);
        GridPane.setMargin(balanceTextField, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(balanceTextField);

        return balanceTextField;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + Button
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, Button> addTopLabelButton(GridPane gridPane,
                                                          int rowIndex,
                                                          String labelText,
                                                          String buttonTitle) {
        return addTopLabelButton(gridPane, rowIndex, labelText, buttonTitle, 0);
    }

    public static Tuple2<Label, Button> addTopLabelButton(GridPane gridPane,
                                                          int rowIndex,
                                                          String labelText,
                                                          String buttonTitle,
                                                          double top) {
        Button button = new AutoTooltipButton(buttonTitle);
        button.setDefaultButton(true);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, labelText, button, top);

        return new Tuple2<>(topLabelWithVBox.first, button);
    }

    public static Tuple2<Label, Button> addConfirmationLabelButton(GridPane gridPane,
                                                                   int rowIndex,
                                                                   String labelText,
                                                                   String buttonTitle,
                                                                   double top) {
        Label label = addLabel(gridPane, rowIndex, labelText);
        label.getStyleClass().add(""confirmation-label"");

        Button button = new AutoTooltipButton(buttonTitle);
        button.getStyleClass().add(""confirmation-value"");
        button.setDefaultButton(true);

        GridPane.setColumnIndex(button, 1);
        GridPane.setRowIndex(button, rowIndex);
        GridPane.setMargin(label, new Insets(top, 0, 0, 0));
        GridPane.setHalignment(label, HPos.LEFT);
        GridPane.setMargin(button, new Insets(top, 0, 0, 0));

        gridPane.getChildren().add(button);

        return new Tuple2<>(label, button);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label + Button + Button
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Label, Button, Button> addTopLabel2Buttons(GridPane gridPane,
                                                                    int rowIndex,
                                                                    String labelText,
                                                                    String title1,
                                                                    String title2,
                                                                    double top) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);

        Button button1 = new AutoTooltipButton(title1);
        button1.setDefaultButton(true);
        button1.getStyleClass().add(""action-button"");
        button1.setDefaultButton(true);
        button1.setMaxWidth(Double.MAX_VALUE);
        HBox.setHgrow(button1, Priority.ALWAYS);

        Button button2 = new AutoTooltipButton(title2);
        button2.setMaxWidth(Double.MAX_VALUE);
        HBox.setHgrow(button2, Priority.ALWAYS);

        hBox.getChildren().addAll(button1, button2);

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, labelText, hBox, top);

        return new Tuple3<>(topLabelWithVBox.first, button1, button2);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Button
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Button addButton(GridPane gridPane, int rowIndex, String title) {
        return addButton(gridPane, rowIndex, title, 0);
    }

    public static Button addButtonAfterGroup(GridPane gridPane, int rowIndex, String title) {
        return addButton(gridPane, rowIndex, title, 15);
    }

    public static Button addPrimaryActionButton(GridPane gridPane, int rowIndex, String title, double top) {
        return addButton(gridPane, rowIndex, title, top, true);
    }

    public static Button addPrimaryActionButtonAFterGroup(GridPane gridPane, int rowIndex, String title) {
        return addPrimaryActionButton(gridPane, rowIndex, title, 15);
    }

    public static Button addButton(GridPane gridPane, int rowIndex, String title, double top) {
        return addButton(gridPane, rowIndex, title, top, false);
    }

    public static Button addButton(GridPane gridPane, int rowIndex, String title, double top, boolean isPrimaryAction) {
        Button button = new AutoTooltipButton(title);
        if (isPrimaryAction) {
            button.setDefaultButton(true);
            button.getStyleClass().add(""action-button"");
        }

        GridPane.setRowIndex(button, rowIndex);
        GridPane.setColumnIndex(button, 0);
        gridPane.getChildren().add(button);
        GridPane.setMargin(button, new Insets(top, 0, 0, 0));
        return button;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Button + Button
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Button, Button> add2Buttons(GridPane gridPane,
                                                     int rowIndex,
                                                     String title1,
                                                     String title2) {
        return add2Buttons(gridPane, rowIndex, title1, title2, 0);
    }

    public static Tuple2<Button, Button> add2ButtonsAfterGroup(GridPane gridPane,
                                                               int rowIndex,
                                                               String title1,
                                                               String title2) {
        return add2ButtonsAfterGroup(gridPane, rowIndex, title1, title2, true);
    }

    public static Tuple2<Button, Button> add2ButtonsAfterGroup(GridPane gridPane,
                                                               int rowIndex,
                                                               String title1,
                                                               String title2,
                                                               boolean hasPrimaryButton) {
        return add2Buttons(gridPane, rowIndex, title1, title2, 15, hasPrimaryButton);
    }

    public static Tuple2<Button, Button> add2Buttons(GridPane gridPane,
                                                     int rowIndex,
                                                     String title1,
                                                     String title2,
                                                     double top) {
        return add2Buttons(gridPane, rowIndex, title1, title2, top, true);
    }

    public static Tuple2<Button, Button> add2Buttons(GridPane gridPane, int rowIndex, String title1,
                                                     String title2, double top, boolean hasPrimaryButton) {
        final Tuple3<Button, Button, HBox> buttonButtonHBoxTuple3 = add2ButtonsWithBox(gridPane, rowIndex, title1, title2, top, hasPrimaryButton);
        return new Tuple2<>(buttonButtonHBoxTuple3.first, buttonButtonHBoxTuple3.second);
    }

    public static Tuple3<Button, Button, HBox> add2ButtonsWithBox(GridPane gridPane, int rowIndex, String title1,
                                                                  String title2, double top, boolean hasPrimaryButton) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);

        Button button1 = new AutoTooltipButton(title1);

        if (hasPrimaryButton) {
            button1.getStyleClass().add(""action-button"");
            button1.setDefaultButton(true);
        }

        button1.setMaxWidth(Double.MAX_VALUE);
        HBox.setHgrow(button1, Priority.ALWAYS);

        Button button2 = new AutoTooltipButton(title2);
        button2.setMaxWidth(Double.MAX_VALUE);
        HBox.setHgrow(button2, Priority.ALWAYS);

        hBox.getChildren().addAll(button1, button2);

        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setColumnIndex(hBox, 0);
        GridPane.setMargin(hBox, new Insets(top, 10, 0, 0));
        gridPane.getChildren().add(hBox);
        return new Tuple3<>(button1, button2, hBox);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Button + Button + Button
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<Button, Button, Button> add3Buttons(GridPane gridPane,
                                                             int rowIndex,
                                                             String title1,
                                                             String title2,
                                                             String title3) {
        return add3Buttons(gridPane, rowIndex, title1, title2, title3, 0);
    }

    public static Tuple3<Button, Button, Button> add3ButtonsAfterGroup(GridPane gridPane,
                                                                       int rowIndex,
                                                                       String title1,
                                                                       String title2,
                                                                       String title3) {
        return add3Buttons(gridPane, rowIndex, title1, title2, title3, 15);
    }

    public static Tuple3<Button, Button, Button> add3Buttons(GridPane gridPane,
                                                             int rowIndex,
                                                             String title1,
                                                             String title2,
                                                             String title3,
                                                             double top) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        Button button1 = new AutoTooltipButton(title1);

        button1.getStyleClass().add(""action-button"");
        button1.setDefaultButton(true);
        button1.setMaxWidth(Double.MAX_VALUE);
        HBox.setHgrow(button1, Priority.ALWAYS);

        Button button2 = new AutoTooltipButton(title2);
        button2.setMaxWidth(Double.MAX_VALUE);
        HBox.setHgrow(button2, Priority.ALWAYS);

        Button button3 = new AutoTooltipButton(title3);
        button3.setMaxWidth(Double.MAX_VALUE);
        HBox.setHgrow(button3, Priority.ALWAYS);

        hBox.getChildren().addAll(button1, button2, button3);
        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setColumnIndex(hBox, 0);
        GridPane.setMargin(hBox, new Insets(top, 10, 0, 0));
        gridPane.getChildren().add(hBox);
        return new Tuple3<>(button1, button2, button3);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Button + ProgressIndicator + Label
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple4<Button, BusyAnimation, Label, HBox> addButtonBusyAnimationLabelAfterGroup(GridPane gridPane,
                                                                                                   int rowIndex,
                                                                                                   int colIndex,
                                                                                                   String buttonTitle) {
        return addButtonBusyAnimationLabel(gridPane, rowIndex, colIndex, buttonTitle, 15);
    }

    public static Tuple4<Button, BusyAnimation, Label, HBox> addButtonBusyAnimationLabelAfterGroup(GridPane gridPane,
                                                                                                   int rowIndex,
                                                                                                   String buttonTitle) {
        return addButtonBusyAnimationLabelAfterGroup(gridPane, rowIndex, 0, buttonTitle);
    }

    public static Tuple4<Button, BusyAnimation, Label, HBox> addButtonBusyAnimationLabel(GridPane gridPane,
                                                                                         int rowIndex,
                                                                                         int colIndex,
                                                                                         String buttonTitle,
                                                                                         double top) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);

        Button button = new AutoTooltipButton(buttonTitle);
        button.setDefaultButton(true);
        button.getStyleClass().add(""action-button"");

        BusyAnimation busyAnimation = new BusyAnimation(false);

        Label label = new AutoTooltipLabel();
        hBox.setAlignment(Pos.CENTER_LEFT);
        hBox.getChildren().addAll(button, busyAnimation, label);

        GridPane.setRowIndex(hBox, rowIndex);
        GridPane.setHalignment(hBox, HPos.LEFT);
        GridPane.setColumnIndex(hBox, colIndex);
        GridPane.setMargin(hBox, new Insets(top, 0, 0, 0));
        gridPane.getChildren().add(hBox);

        return new Tuple4<>(button, busyAnimation, label, hBox);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Trade: HBox, InputTextField, Label
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple3<HBox, InputTextField, Label> getEditableValueBox(String promptText) {
        InputTextField input = new InputTextField(60);
        input.setPromptText(promptText);

        Label label = new AutoTooltipLabel(Res.getBaseCurrencyCode());
        label.getStyleClass().add(""input-label"");

        HBox box = new HBox();
        HBox.setHgrow(input, Priority.ALWAYS);
        input.setMaxWidth(Double.MAX_VALUE);
        box.getStyleClass().add(""input-with-border"");
        box.getChildren().addAll(input, label);
        return new Tuple3<>(box, input, label);
    }

    public static Tuple3<HBox, InfoInputTextField, Label> getEditableValueBoxWithInfo(String promptText) {
        InfoInputTextField infoInputTextField = new InfoInputTextField(60);
        InputTextField input = infoInputTextField.getInputTextField();
        input.setPromptText(promptText);

        Label label = new AutoTooltipLabel(Res.getBaseCurrencyCode());
        label.getStyleClass().add(""input-label"");

        HBox box = new HBox();
        HBox.setHgrow(infoInputTextField, Priority.ALWAYS);
        infoInputTextField.setMaxWidth(Double.MAX_VALUE);
        box.getStyleClass().add(""input-with-border"");
        box.getChildren().addAll(infoInputTextField, label);
        return new Tuple3<>(box, infoInputTextField, label);
    }

    public static Tuple3<HBox, TextField, Label> getNonEditableValueBox() {
        final Tuple3<HBox, InputTextField, Label> editableValueBox = getEditableValueBox("""");
        final TextField textField = editableValueBox.second;

        textField.setDisable(true);

        return new Tuple3<>(editableValueBox.first, editableValueBox.second, editableValueBox.third);
    }

    public static Tuple3<HBox, InfoInputTextField, Label> getNonEditableValueBoxWithInfo() {

        final Tuple3<HBox, InfoInputTextField, Label> editableValueBoxWithInfo = getEditableValueBoxWithInfo("""");

        TextField textField = editableValueBoxWithInfo.second.getInputTextField();
        textField.setDisable(true);

        return editableValueBoxWithInfo;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Trade: Label, VBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, VBox> getTradeInputBox(Pane amountValueBox, String descriptionText) {
        Label descriptionLabel = new AutoTooltipLabel(descriptionText);
        descriptionLabel.setId(""input-description-label"");
        descriptionLabel.setPrefWidth(190);

        VBox box = new VBox();
        box.setPadding(new Insets(10, 0, 0, 0));
        box.setSpacing(2);
        box.getChildren().addAll(descriptionLabel, amountValueBox);
        return new Tuple2<>(descriptionLabel, box);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + List
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static <T> Tuple3<Label, ListView<T>, VBox> addTopLabelListView(GridPane gridPane,
                                                                           int rowIndex,
                                                                           String title) {
        return addTopLabelListView(gridPane, rowIndex, title, 0);
    }

    public static <T> Tuple3<Label, ListView<T>, VBox> addTopLabelListView(GridPane gridPane,
                                                                           int rowIndex,
                                                                           String title,
                                                                           double top) {
        ListView<T> listView = new ListView<>();

        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, listView, top);
        return new Tuple3<>(topLabelWithVBox.first, listView, topLabelWithVBox.second);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Label  + FlowPane
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Tuple2<Label, FlowPane> addTopLabelFlowPane(GridPane gridPane,
                                                              int rowIndex,
                                                              String title,
                                                              double top) {
        return addTopLabelFlowPane(gridPane, rowIndex, title, top, 0);
    }

    public static Tuple2<Label, FlowPane> addTopLabelFlowPane(GridPane gridPane,
                                                              int rowIndex,
                                                              String title,
                                                              double top,
                                                              double bottom) {
        FlowPane flowPane = new FlowPane();
        flowPane.setPadding(new Insets(10, 10, 10, 10));
        flowPane.setVgap(10);
        flowPane.setHgap(10);
        final Tuple2<Label, VBox> topLabelWithVBox = addTopLabelWithVBox(gridPane, rowIndex, title, flowPane, top);

        GridPane.setMargin(topLabelWithVBox.second, new Insets(top + Layout.FLOATING_LABEL_DISTANCE,
                0, bottom, 0));

        return new Tuple2<>(topLabelWithVBox.first, flowPane);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Remove
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static void removeRowFromGridPane(GridPane gridPane, int gridRow) {
        removeRowsFromGridPane(gridPane, gridRow, gridRow);
    }

    public static void removeRowsFromGridPane(GridPane gridPane, int fromGridRow, int toGridRow) {
        Set<Node> nodes = new CopyOnWriteArraySet<>(gridPane.getChildren());
        nodes.stream()
                .filter(e -> GridPane.getRowIndex(e) != null && GridPane.getRowIndex(e) >= fromGridRow && GridPane.getRowIndex(e) <= toGridRow)
                .forEach(e -> gridPane.getChildren().remove(e));
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Icons
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static Text getIconForLabel(GlyphIcons icon, String iconSize, Label label, String style) {
        if (icon.fontFamily().equals(MATERIAL_DESIGN_ICONS)) {
            final Text textIcon = MaterialDesignIconFactory.get().createIcon(icon, iconSize);
            textIcon.setOpacity(0.7);
            if (style != null) {
                textIcon.getStyleClass().add(style);
            }
            label.setContentDisplay(ContentDisplay.LEFT);
            label.setGraphic(textIcon);
            return textIcon;
        } else {
            throw new IllegalArgumentException(""Not supported icon type"");
        }
    }

    public static Text getIconForLabel(GlyphIcons icon, String iconSize, Label label) {
        return getIconForLabel(icon, iconSize, label, null);
    }

    public static Text getSmallIconForLabel(GlyphIcons icon, Label label, String style) {
        return getIconForLabel(icon, ""0.769em"", label, style);
    }

    public static Text getSmallIconForLabel(GlyphIcons icon, Label label) {
        return getIconForLabel(icon, ""0.769em"", label);
    }

    public static Text getRegularIconForLabel(GlyphIcons icon, Label label) {
        return getIconForLabel(icon, ""1.231em"", label);
    }

    public static Text getIcon(GlyphIcons icon) {
        return getIcon(icon, ""1.231em"");
    }

    public static Text getBigIcon(GlyphIcons icon) {
        return getIcon(icon, ""2em"");
    }

    public static Text getMediumSizeIcon(GlyphIcons icon) {
        return getIcon(icon, ""1.5em"");
    }

    public static Text getIcon(GlyphIcons icon, String iconSize) {
        Text textIcon;

        if (icon.fontFamily().equals(MATERIAL_DESIGN_ICONS)) {
            textIcon = MaterialDesignIconFactory.get().createIcon(icon, iconSize);
        } else {
            throw new IllegalArgumentException(""Not supported icon type"");
        }

        return textIcon;
    }


    public static Label getIcon(AwesomeIcon icon) {
        final Label label = new Label();
        AwesomeDude.setIcon(label, icon);
        return label;
    }

    public static Label getIconForLabel(AwesomeIcon icon, Label label, String fontSize) {
        AwesomeDude.setIcon(label, icon, fontSize);
        return label;
    }

    public static Button getIconButton(GlyphIcons icon) {
        return getIconButton(icon, ""highlight"");
    }

    public static Button getIconButton(GlyphIcons icon, String styleClass) {
        return getIconButton(icon, styleClass, ""2em"");
    }

    public static Button getRegularIconButton(GlyphIcons icon) {
        return getIconButton(icon, ""highlight"", ""1.6em"");
    }

    public static Button getRegularIconButton(GlyphIcons icon, String styleClass) {
        return getIconButton(icon, styleClass, ""1.6em"");
    }

    public static Button getIconButton(GlyphIcons icon, String styleClass, String iconSize) {
        if (icon.fontFamily().equals(MATERIAL_DESIGN_ICONS)) {
            Button iconButton = MaterialDesignIconFactory.get().createIconButton(icon,
                    """", iconSize, null, ContentDisplay.CENTER);
            iconButton.setId(""icon-button"");
            iconButton.getGraphic().getStyleClass().add(styleClass);
            iconButton.setPrefWidth(20);
            iconButton.setPrefHeight(20);
            iconButton.setPadding(new Insets(0));
            return iconButton;
        } else {
            throw new IllegalArgumentException(""Not supported icon type"");
        }
    }

    public static <T> TableView<T> addTableViewWithHeader(GridPane gridPane, int rowIndex, String headerText) {
        return addTableViewWithHeader(gridPane, rowIndex, headerText, 0, null);
    }

    public static <T> TableView<T> addTableViewWithHeader(GridPane gridPane,
                                                          int rowIndex,
                                                          String headerText,
                                                          String groupStyle) {
        return addTableViewWithHeader(gridPane, rowIndex, headerText, 0, groupStyle);
    }

    public static <T> TableView<T> addTableViewWithHeader(GridPane gridPane, int rowIndex, String headerText, int top) {
        return addTableViewWithHeader(gridPane, rowIndex, headerText, top, null);
    }

    public static <T> TableView<T> addTableViewWithHeader(GridPane gridPane,
                                                          int rowIndex,
                                                          String headerText,
                                                          int top,
                                                          String groupStyle) {
        TitledGroupBg titledGroupBg = addTitledGroupBg(gridPane, rowIndex, 1, headerText, top);

        if (groupStyle != null) titledGroupBg.getStyleClass().add(groupStyle);

        TableView<T> tableView = new TableView<>();
        GridPane.setRowIndex(tableView, rowIndex);
        GridPane.setMargin(tableView, new Insets(top + 30, -10, 5, -10));
        gridPane.getChildren().add(tableView);
        tableView.setPlaceholder(new AutoTooltipLabel(Res.get(""table.placeholder.noData"")));
        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        return tableView;
    }
}",1,439 334 2000 123 437 457 381 2001 2002 61 648 59 621 621 621 439 457 2003 2004 40 2005 2006 44 404 2007 44 404 2008 44 2001 2009 41 123 450 2004 40 2006 44 2007 44 2008 44 2009 44 1500 41 59 125 439 457 2003 2004 40 2005 2006 44 404 2007 44 404 2010 44 404 2008 44 2001 2009 41 123 2003 2011 61 2004 40 2006 44 2007 44 2008 44 2009 44 1500 41 59 2005 46 2012 40 2011 44 2010 41 59 450 2011 59 125 439 457 2003 2004 40 2005 2006 44 404 2007 44 404 2010 44 404 2008 44 2001 2009 44 356 2013 41 123 2003 2014 61 2004 40 2006 44 2007 44 2008 44 2009 44 2013 41 59 2005 46 2015 40 2014 44 2010 41 59 450 2014 59 125 439 457 2003 2004 40 2005 2006 44 404 2007 44 404 2008 44 2001 2009 44 356 2013 41 123 2003 2016 61 418 2003 40 41 59 2016 46 2017 40 2009 41 59 2016 46 2018 40 41 46 2019 40 2006 46 2020 40 41 41 59 2005 46 2021 40 2016 44 2007 41 59 2005 46 2022 40 2016 44 2008 41 59 2005 46 2023 40 2016 44 418 2024 40 2013 43 1502 44 45 1502 44 45 1503 44 45 1502 41 41 59 2006 46 2025 40 41 46 2026 40 2016 41 59 450 2016 59 125 621 621 621 439 457 2027 2028 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2028 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2027 2028 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2027 2029 61 418 2030 40 2009 41 59 2005 46 2031 40 2029 44 2007 41 59 2005 46 2032 40 2029 44 418 2033 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2034 40 41 46 2035 40 2029 41 59 450 2029 59 125 621 621 621 439 457 2036 60 2027 44 2027 44 2037 62 2038 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2039 41 123 450 2038 40 2006 44 2007 44 2009 44 2039 44 1500 41 59 125 439 457 2036 60 2027 44 2027 44 2037 62 2038 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2039 44 356 2013 41 123 2027 2040 61 418 2041 40 2009 41 59 2027 2042 61 418 2041 40 2039 41 59 2037 2043 61 418 2037 40 41 59 2043 46 2044 40 41 46 2045 40 2040 44 2042 41 59 2005 46 2046 40 2043 44 2007 41 59 2005 46 2047 40 2043 44 418 2048 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2044 40 41 46 2049 40 2043 41 59 450 418 2036 60 62 40 2040 44 2042 44 2043 41 59 125 621 621 621 439 457 2027 2050 40 2005 2006 44 404 2007 41 123 450 2050 40 2006 44 2007 44 1500 41 59 125 439 457 2027 2050 40 2005 2006 44 404 2007 44 2001 2051 41 123 450 2050 40 2006 44 2007 44 2051 44 1500 41 59 125 439 457 2027 2050 40 2005 2006 44 404 2007 44 356 2013 41 123 450 2050 40 2006 44 2007 44 648 44 2013 41 59 125 439 457 2027 2050 40 2005 2006 44 404 2007 44 2001 2051 44 356 2013 41 123 450 2050 40 2006 44 2007 44 2051 44 2013 44 1504 41 59 125 439 457 2027 2050 40 2005 2006 44 404 2007 44 2001 2051 44 356 2013 44 356 2052 41 123 2027 2053 61 418 2054 40 2051 41 59 2053 46 2055 40 473 41 59 2053 46 2056 40 2052 41 59 2005 46 2057 40 2053 44 2058 46 2059 41 59 2005 46 2060 40 2053 44 2061 46 2062 41 59 2005 46 2063 40 2053 44 2007 41 59 2005 46 2064 40 2053 44 418 2065 40 2013 43 2066 46 2067 44 1500 44 1500 44 1500 41 41 59 2006 46 2068 40 41 46 2069 40 2053 41 59 450 2053 59 125 621 621 621 439 457 2036 60 2027 44 2070 44 2037 62 2071 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2072 40 2006 44 2007 44 2009 44 648 44 45 1503 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2071 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 41 123 2036 60 2027 44 2070 44 2037 62 2073 61 2074 40 2006 44 2007 44 2009 44 648 44 45 1503 41 59 2005 46 2075 40 2073 46 2076 44 2010 41 59 450 2073 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2071 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 450 2077 40 2006 44 2007 44 2009 44 648 44 2013 45 1503 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2071 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 41 123 450 2071 40 2006 44 2007 44 2009 44 2078 44 1500 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2071 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 44 2001 2078 44 356 2013 41 123 2036 60 2027 44 2070 44 2037 62 2079 61 2080 40 2006 44 2007 44 2009 44 2078 44 2013 45 1503 41 59 2005 46 2081 40 2079 46 2082 44 2010 41 59 450 2079 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2071 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 44 356 2013 41 123 2036 60 2027 44 2070 44 2037 62 2083 61 2084 40 2006 44 2007 44 2009 44 648 44 2013 45 1503 41 59 2005 46 2085 40 2083 46 2086 44 2010 41 59 450 2083 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2071 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 44 356 2013 41 123 450 2087 40 2006 44 2007 44 2009 44 2078 44 2013 45 1503 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2088 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2088 40 2006 44 2007 44 2009 44 648 44 1500 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2089 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 41 123 450 2088 40 2006 44 2007 44 2009 44 2078 44 45 2090 46 2091 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2089 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2078 41 123 381 2036 60 2027 44 2070 44 2037 62 2093 61 2088 40 2006 44 2007 44 2009 44 2078 44 45 2094 46 2095 41 59 2005 46 2096 40 2093 46 2097 44 2092 41 59 450 2093 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2089 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 44 356 2013 41 123 450 2088 40 2006 44 2007 44 2009 44 2078 44 2013 45 2098 46 2099 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2088 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 41 123 450 2088 40 2006 44 2007 44 2009 44 2078 44 1500 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2088 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 450 2088 40 2006 44 2007 44 2009 44 648 44 2013 41 59 125 439 457 2036 60 2027 44 2070 44 2037 62 2088 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 44 356 2013 41 123 2070 2100 61 418 2101 40 2078 41 59 2100 46 2102 40 380 41 59 2100 46 2103 40 380 41 59 381 2104 60 2027 44 2037 62 2105 61 2106 40 2006 44 2007 44 2009 44 2100 44 2013 41 59 621 621 450 418 2036 60 62 40 2105 46 2107 44 2100 44 2105 46 2108 41 59 125 439 457 2109 60 2070 44 2110 62 2111 40 2005 2006 44 404 2007 44 2001 2009 41 123 2070 2112 61 418 2113 40 41 59 2112 46 2114 40 2009 41 59 2112 46 2115 40 380 41 59 2112 46 2116 40 380 41 59 2112 46 2117 40 2118 46 2119 41 59 2110 2120 61 418 2121 40 648 41 59 2120 46 2122 40 648 41 59 2120 46 2123 40 41 46 2124 40 2120 46 2125 40 41 41 59 2037 2126 61 418 2037 40 2120 41 59 2126 46 2127 40 2128 46 2129 41 59 2130 2131 61 418 2130 40 2112 44 2126 41 59 2027 2132 61 2133 40 2009 41 59 2037 2134 61 2135 40 1500 41 59 2134 46 2136 40 41 46 2137 40 2132 44 2131 41 59 2006 46 2136 40 41 46 2138 40 2134 41 59 2005 46 2139 40 2134 44 2007 41 59 2005 46 2140 40 2134 44 418 2141 40 2118 46 2142 44 1500 44 1500 44 1500 41 41 59 450 418 2109 60 62 40 2112 44 2120 41 59 125 621 621 621 439 457 2109 60 2027 44 2027 62 2143 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 41 123 450 2143 40 2006 44 2007 44 2144 44 2145 44 1500 41 59 125 439 457 2109 60 2027 44 2027 62 2143 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 356 2013 41 123 2027 2146 61 2028 40 2006 44 2007 44 2144 41 59 2146 46 2147 40 41 46 2148 40 648 41 59 2027 2149 61 2028 40 2006 44 2007 44 2145 41 59 2149 46 2147 40 41 46 2148 40 648 41 59 2005 46 2150 40 2149 44 1501 41 59 2005 46 2151 40 2146 44 418 2152 40 2013 44 1500 44 1500 44 1500 41 41 59 2005 46 2153 40 2146 44 2154 46 2155 41 59 2005 46 2151 40 2149 44 418 2152 40 2013 44 1500 44 1500 44 1500 41 41 59 450 418 2109 60 62 40 2146 44 2149 41 59 125 439 457 2109 60 2027 44 2070 62 2156 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 41 123 450 2156 40 2006 44 2007 44 2144 44 2145 44 1500 41 59 125 439 457 2109 60 2027 44 2070 62 2156 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 356 2013 41 123 2027 2157 61 2028 40 2006 44 2007 44 2144 41 59 2157 46 2158 40 41 46 2159 40 648 41 59 2070 2160 61 418 2161 40 2145 41 59 2006 46 2162 40 41 46 2159 40 2160 41 59 2160 46 2158 40 41 46 2159 40 648 41 59 2160 46 2163 40 380 41 59 2160 46 2164 40 380 41 59 2005 46 2165 40 2160 44 2007 41 59 2005 46 2166 40 2160 44 1501 41 59 2005 46 2167 40 2157 44 418 2168 40 2013 44 1500 44 1500 44 1500 41 41 59 2005 46 2169 40 2157 44 2170 46 2171 41 59 2005 46 2167 40 2160 44 418 2168 40 2013 44 1500 44 1500 44 1500 41 41 59 450 418 2109 60 62 40 2157 44 2160 41 59 125 439 457 2109 60 2027 44 2172 62 2173 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 41 123 2027 2174 61 2028 40 2006 44 2007 44 2144 41 59 2174 46 2175 40 41 46 2176 40 648 41 59 2172 2177 61 418 2172 40 648 41 59 2177 46 2178 40 2145 41 59 2005 46 2179 40 2177 44 2007 41 59 2006 46 2180 40 41 46 2176 40 2177 41 59 2005 46 2181 40 2177 44 1501 41 59 2005 46 2182 40 2174 44 2183 46 2184 41 59 450 418 2109 60 62 40 2174 44 2177 41 59 125 439 457 2109 60 2027 44 2185 62 2186 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 356 2013 41 123 2027 2187 61 2028 40 2006 44 2007 44 2144 41 59 2187 46 2188 40 41 46 2189 40 648 41 59 2185 2190 61 2191 40 2006 44 2007 44 2145 41 59 40 40 2192 41 2190 41 46 2193 40 380 41 59 2005 46 2194 40 2190 44 1501 41 59 2005 46 2195 40 2187 44 418 2196 40 2013 44 1500 44 1500 44 1500 41 41 59 2005 46 2197 40 2187 44 2198 46 2199 41 59 2005 46 2195 40 2190 44 418 2196 40 2013 44 1500 44 1500 44 1500 41 41 59 450 418 2109 60 62 40 2187 44 2190 41 59 125 621 621 621 439 457 2109 60 2027 44 2200 62 2201 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 450 2201 40 2006 44 2007 44 1500 44 2009 44 2013 41 59 125 439 457 2109 60 2027 44 2200 62 2201 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 44 356 2013 41 123 2200 2202 61 418 2200 40 41 59 2202 46 2203 40 380 41 59 450 418 2109 60 62 40 2204 40 2006 44 2007 44 2010 44 2009 44 2202 44 2013 41 46 2205 44 2202 41 59 125 621 621 621 439 457 2206 2207 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2208 41 123 450 2207 40 2006 44 2007 44 2009 44 2208 44 1500 41 59 125 439 457 2206 2207 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2208 44 356 2013 41 123 2206 2209 61 418 2210 40 2009 41 59 2209 46 2211 40 2212 45 62 2213 46 2214 40 2208 41 41 59 2005 46 2215 40 2209 44 2007 41 59 2005 46 2216 40 2209 44 1500 41 59 2005 46 2217 40 2209 44 418 2218 40 2013 44 1500 44 1500 44 1500 41 41 59 2005 46 2219 40 2209 44 2220 46 2221 41 59 2006 46 2222 40 41 46 2223 40 2209 41 59 450 2209 59 125 621 621 621 439 457 2109 60 2027 44 2206 62 2224 40 2005 2006 44 404 2007 44 2001 2225 44 2001 2009 44 2001 2208 41 123 450 2224 40 2006 44 2007 44 2225 44 2009 44 2208 44 1500 41 59 125 439 457 2109 60 2027 44 2206 62 2224 40 2005 2006 44 404 2007 44 2001 2225 44 2001 2009 44 2001 2208 44 356 2013 41 123 2027 2226 61 2028 40 2006 44 2007 44 2225 44 2013 41 59 2206 2227 61 418 2228 40 2009 41 59 2227 46 2229 40 2230 45 62 2231 46 2232 40 2208 41 41 59 2005 46 2233 40 2227 44 2007 41 59 2005 46 2234 40 2227 44 418 2235 40 2013 44 1500 44 1500 44 45 1502 41 41 59 2006 46 2236 40 41 46 2237 40 2227 41 59 450 418 2109 60 62 40 2226 44 2227 41 59 125 439 457 2036 60 2027 44 2206 44 2037 62 2238 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 44 2001 2078 44 2001 2208 44 356 2013 41 123 2036 60 2027 44 2206 44 2037 62 2239 61 2238 40 2006 44 2007 44 2009 44 2078 44 2208 44 2013 41 59 2005 46 2240 40 2239 46 2241 44 2010 41 59 450 2239 59 125 439 457 2036 60 2027 44 2206 44 2037 62 2238 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 44 2001 2208 44 356 2013 41 123 2206 2242 61 418 2243 40 2078 41 59 2242 46 2244 40 2245 45 62 2246 46 2247 40 2208 41 41 59 2242 46 2248 40 41 46 2249 40 648 41 59 2005 46 2250 40 2242 44 2007 41 59 2109 60 2027 44 2037 62 2251 61 2252 40 2006 44 2007 44 2009 44 2242 44 2013 45 1503 41 59 450 418 2036 60 62 40 2251 46 2253 44 2242 44 2251 46 2254 41 59 125 621 621 621 439 457 2185 2255 40 2005 2006 44 404 2007 44 2001 2256 41 123 450 2255 40 2006 44 2007 44 2256 44 1500 41 59 125 439 457 2185 2255 40 2005 2006 44 404 2007 44 2001 2256 44 356 2013 41 123 2257 2258 61 418 2259 40 41 59 2258 46 2260 40 2256 41 59 2258 46 2261 40 473 41 59 2258 46 2262 40 473 41 59 2005 46 2263 40 2258 44 2007 41 59 2005 46 2264 40 2258 44 1500 41 59 2005 46 2265 40 2258 44 418 2266 40 2013 43 2267 46 2268 44 1500 44 1500 44 1500 41 41 59 2006 46 2269 40 41 46 2270 40 2258 41 59 450 2258 59 125 621 621 621 439 457 2109 60 2027 44 2185 62 2271 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2256 41 123 450 2272 40 2006 44 2007 44 2009 44 2256 44 45 2273 46 2274 41 59 125 439 457 2109 60 2027 44 2185 62 2271 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2256 41 123 450 2275 40 2006 44 2007 44 2092 44 2009 44 2256 44 45 2276 46 2277 41 59 125 439 457 2109 60 2027 44 2185 62 2278 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2256 41 123 450 2278 40 2006 44 2007 44 2009 44 2256 44 1500 41 59 125 439 457 2109 60 2027 44 2185 62 2278 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2256 41 123 450 2278 40 2006 44 2007 44 2092 44 2009 44 2256 44 1500 41 59 125 439 457 2109 60 2027 44 2185 62 2278 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2256 44 356 2013 41 123 450 2278 40 2006 44 2007 44 1500 44 2009 44 2256 44 2013 41 59 125 439 457 2109 60 2027 44 2185 62 2278 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2256 44 356 2013 41 123 2185 2279 61 418 2280 40 41 59 2279 46 2281 40 2256 41 59 2279 46 2282 40 473 41 59 381 2109 60 2027 44 2037 62 2283 61 2284 40 2006 44 2007 44 2009 44 2279 44 2013 41 59 2005 46 2285 40 2283 46 2286 44 2092 41 59 450 418 2109 60 62 40 2283 46 2287 44 2279 41 59 125 621 621 621 439 457 2109 60 2027 44 2288 62 2289 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 450 2289 40 2006 44 2007 44 1500 44 2009 44 2013 41 59 125 439 457 2109 60 2027 44 2288 62 2289 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 44 356 2013 41 123 2288 2290 61 418 2291 40 41 59 2109 60 2027 44 2037 62 2292 61 2293 40 2006 44 2007 44 2010 44 2009 44 2290 44 2013 41 59 450 418 2109 60 62 40 2292 46 2294 44 2290 41 59 125 621 621 621 439 457 2109 60 2288 44 2288 62 2295 40 2005 2006 44 404 2007 44 404 2010 44 2001 2144 44 2001 2145 44 356 2013 41 123 2288 2296 61 418 2297 40 41 59 2109 60 2027 44 2037 62 2298 61 2299 40 2144 44 2296 41 59 2037 2300 61 2298 46 2301 59 2288 2302 61 418 2297 40 41 59 2109 60 2027 44 2037 62 2303 61 2299 40 2145 44 2302 41 59 2037 2304 61 2303 46 2301 59 2305 2306 61 418 2305 40 41 59 2307 46 2308 40 2306 44 2309 46 2310 41 59 2307 2311 61 418 2307 40 41 59 2311 46 2312 40 1502 41 59 2311 46 2313 40 41 46 2314 40 2306 44 2300 44 2304 41 59 2005 46 2315 40 2311 44 2007 41 59 2005 46 2316 40 2311 44 2010 41 59 2005 46 2317 40 2311 44 418 2318 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2313 40 41 46 2319 40 2311 41 59 450 418 2109 60 62 40 2296 44 2302 41 59 125 621 621 621 64 2320 40 648 41 439 457 2109 60 2027 44 2321 62 2322 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 41 123 450 2322 40 2006 44 2007 44 2009 44 2078 44 1500 41 59 125 439 457 2109 60 2027 44 2321 62 2322 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 44 356 2013 41 123 2027 2323 61 2028 40 2006 44 2007 44 2009 44 2013 41 59 2323 46 2324 40 41 46 2325 40 648 41 59 2005 46 2326 40 2323 44 2327 46 2328 41 59 2321 2329 61 418 2321 40 41 59 2329 46 2330 40 2078 41 59 2005 46 2331 40 2329 44 2007 41 59 2005 46 2332 40 2329 44 1501 41 59 2006 46 2333 40 41 46 2325 40 2329 41 59 450 418 2109 60 62 40 2323 44 2329 41 59 125 621 621 621 439 457 492 2334 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2335 41 123 2027 2336 61 2028 40 2006 44 2007 44 2009 44 1500 41 59 2336 46 2337 40 41 46 2338 40 648 41 59 2005 46 2339 40 2336 44 2340 46 2341 41 59 2342 2343 61 418 2342 40 41 59 2343 46 2344 40 2335 41 59 2005 46 2345 40 2343 44 2007 41 59 2005 46 2346 40 2343 44 1501 41 59 2006 46 2347 40 41 46 2338 40 2343 41 59 125 621 621 621 439 457 2348 2349 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2349 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2348 2349 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2348 2350 61 418 2348 40 41 59 2350 46 2351 40 473 41 59 2350 46 2352 40 2009 41 59 2005 46 2353 40 2350 44 2007 41 59 2005 46 2354 40 2350 44 1500 41 59 2005 46 2355 40 2350 44 418 2356 40 2013 43 2357 46 2358 44 1500 44 1500 44 1500 41 41 59 2006 46 2359 40 41 46 2360 40 2350 41 59 450 2350 59 125 621 621 621 439 457 2109 60 2027 44 2348 62 2361 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2361 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2109 60 2027 44 2348 62 2361 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 381 2036 60 2027 44 2348 44 2037 62 2362 61 2363 40 2006 44 2007 44 2009 44 2013 41 59 450 418 2109 60 62 40 2362 46 2364 44 2362 46 2365 41 59 125 439 457 2036 60 2027 44 2348 44 2037 62 2366 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2348 2367 61 418 2348 40 41 59 381 2109 60 2027 44 2037 62 2368 61 2369 40 2006 44 2007 44 2009 44 2367 44 2013 41 59 450 418 2036 60 62 40 2368 46 2370 44 2367 44 2368 46 2371 41 59 125 621 621 621 439 457 2109 60 2027 44 2372 62 2373 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2373 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2109 60 2027 44 2372 62 2373 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2372 2374 61 418 2372 40 41 59 381 2109 60 2027 44 2037 62 2375 61 2376 40 2006 44 2007 44 2009 44 2374 44 2013 41 59 450 418 2109 60 62 40 2375 46 2377 44 2374 41 59 125 621 621 621 439 457 2378 2379 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2379 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2378 2379 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2378 2380 61 418 2378 40 41 59 2380 46 2381 40 2009 41 59 2005 46 2382 40 2380 44 2007 41 59 2005 46 2383 40 2380 44 1500 41 59 2005 46 2384 40 2380 44 1502 41 59 2005 46 2385 40 2380 44 418 2386 40 2013 43 1502 44 1500 44 1503 44 1500 41 41 59 2006 46 2387 40 41 46 2388 40 2380 41 59 450 2380 59 125 621 621 621 439 457 2036 60 2027 44 2348 44 2389 62 2390 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2391 41 123 2348 2392 61 418 2348 40 41 59 2389 2393 61 418 2394 40 41 59 2393 46 2395 40 2391 41 59 2037 46 2396 40 2393 44 418 2397 40 1502 44 1500 44 1500 44 1500 41 41 59 381 2109 60 2027 44 2037 62 2398 61 2399 40 2006 44 2007 44 2009 44 2392 44 1500 41 59 2398 46 2400 46 2401 40 41 46 2402 40 2393 41 59 450 418 2036 60 62 40 2398 46 2403 44 2392 44 2393 41 59 125 439 457 2036 60 2027 44 2348 44 2389 62 2404 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2391 41 123 2348 2405 61 418 2348 40 41 59 2109 60 2027 44 2037 62 2406 61 2407 40 2006 44 2007 44 2009 44 2405 44 1500 41 59 2389 2408 61 418 2409 40 41 59 2408 46 2410 40 2391 41 59 2411 2412 61 418 2411 40 41 59 2412 46 2413 40 41 46 2414 40 2406 46 2415 44 2408 41 59 2411 46 2416 40 2408 44 418 2417 40 1502 44 1500 44 1500 44 1500 41 41 59 2006 46 2418 40 2412 44 1500 44 2007 41 59 2005 46 2416 40 2412 44 418 2417 40 2419 46 2420 44 1500 44 1500 44 1500 41 41 59 450 418 2036 60 62 40 2406 46 2421 44 2405 44 2408 41 59 125 621 621 621 439 457 2036 60 2027 44 2348 44 2110 62 2422 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2423 41 123 2348 2424 61 418 2348 40 41 59 2110 2425 61 418 2426 40 2423 41 59 2425 46 2427 40 473 41 59 2428 2429 61 418 2428 40 41 59 2429 46 2430 40 1502 41 59 2429 46 2431 40 41 46 2432 40 2424 44 2425 41 59 2428 46 2433 40 2424 44 2434 46 2435 41 59 381 2109 60 2027 44 2037 62 2436 61 2437 40 2006 44 2007 44 2009 44 2429 44 1500 41 59 450 418 2036 60 62 40 2436 46 2438 44 2424 44 2425 41 59 125 621 621 621 439 457 2036 60 2027 44 2070 44 2110 62 2439 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2423 41 123 450 2439 40 2006 44 2007 44 2009 44 2423 44 1500 41 59 125 439 457 2036 60 2027 44 2070 44 2110 62 2439 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2423 44 356 2013 41 123 2070 2440 61 418 2441 40 41 59 2440 46 2442 40 380 41 59 2440 46 2443 40 473 41 59 2440 46 2444 40 380 41 59 2110 2445 61 418 2446 40 2423 41 59 2445 46 2447 40 473 41 59 2448 2449 61 418 2448 40 41 59 2449 46 2450 40 1502 41 59 2449 46 2451 40 41 46 2452 40 2440 44 2445 41 59 2448 46 2453 40 2440 44 2454 46 2455 41 59 381 2109 60 2027 44 2037 62 2456 61 2457 40 2006 44 2007 44 2009 44 2449 44 2013 41 59 450 418 2036 60 62 40 2456 46 2458 44 2440 44 2445 41 59 125 621 621 621 439 457 2109 60 2348 44 2348 62 2459 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 41 123 2348 2460 61 418 2348 40 41 59 2460 46 2461 40 2144 41 59 2460 46 2462 40 473 41 59 2348 2463 61 418 2348 40 41 59 2463 46 2462 40 473 41 59 2463 46 2461 40 2145 41 59 2464 2465 61 418 2464 40 41 59 2465 46 2466 40 1502 41 59 2465 46 2467 40 41 46 2468 40 2460 44 2463 41 59 2005 46 2469 40 2465 44 2007 41 59 2005 46 2470 40 2465 44 1500 41 59 2005 46 2471 40 2465 44 418 2472 40 2473 46 2474 44 1500 44 1500 44 1500 41 41 59 2006 46 2467 40 41 46 2475 40 2465 41 59 450 418 2109 60 62 40 2460 44 2463 41 59 125 621 621 621 439 457 2476 60 2027 44 2070 44 2027 44 2070 62 2477 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 41 123 2070 2478 61 418 2479 40 41 59 2478 46 2480 40 380 41 59 2478 46 2481 40 473 41 59 2478 46 2482 40 380 41 59 381 2109 60 2027 44 2037 62 2483 61 2484 40 2144 44 2478 41 59 2070 2485 61 418 2479 40 41 59 2485 46 2480 40 380 41 59 2485 46 2481 40 473 41 59 2485 46 2482 40 380 41 59 381 2109 60 2027 44 2037 62 2486 61 2484 40 2145 44 2485 41 59 2487 2488 61 418 2487 40 41 59 2488 46 2489 40 1502 41 59 2488 46 2490 40 41 46 2491 40 2483 46 2492 44 2486 46 2492 41 59 2005 46 2493 40 2488 44 2007 41 59 2006 46 2490 40 41 46 2494 40 2488 41 59 450 418 2476 60 62 40 2483 46 2495 44 2478 44 2486 46 2495 44 2485 41 59 125 621 621 621 439 457 2109 60 2110 44 2496 62 2497 40 2005 2006 44 404 2007 44 2001 2423 44 2001 2498 41 123 450 2497 40 2006 44 2007 44 2423 44 2498 44 1500 41 59 125 439 457 2109 60 2110 44 2496 62 2497 40 2005 2006 44 404 2007 44 2001 2423 44 2001 2498 44 356 2013 41 123 381 2036 60 2110 44 2496 44 2499 62 2500 61 2501 40 2006 44 2007 44 2423 44 2498 44 2013 41 59 450 418 2109 60 62 40 2500 46 2502 44 2500 46 2503 41 59 125 439 457 2036 60 2110 44 2496 44 2504 62 2505 40 2005 2006 44 404 2007 44 2001 2423 44 2001 2498 44 356 2013 41 123 2110 2506 61 418 2507 40 2423 41 59 2496 2508 61 418 2509 40 2498 41 59 2504 2510 61 418 2504 40 1503 41 59 2510 46 2511 40 2512 46 2513 41 59 2510 46 2514 40 41 46 2515 40 2506 44 2508 41 59 2005 46 2516 40 2510 44 2007 41 59 2510 46 2517 40 418 2518 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2514 40 41 46 2519 40 2510 41 59 450 418 2036 60 62 40 2506 44 2508 44 2510 41 59 125 621 621 621 439 457 2496 2520 40 2005 2006 44 404 2007 44 2001 2498 41 123 450 2520 40 2006 44 2007 44 2498 44 1500 41 59 125 439 457 2496 2520 40 2005 2006 44 404 2007 44 2001 2498 44 356 2013 41 123 450 2520 40 2006 44 2007 44 1500 44 2498 44 2013 41 59 125 439 457 2496 2520 40 2005 2006 44 404 2007 44 404 2092 44 2001 2498 44 356 2013 41 123 2496 2521 61 418 2522 40 2498 41 59 2005 46 2523 40 2521 44 418 2524 40 2013 44 1500 44 1500 44 1500 41 41 59 2005 46 2525 40 2521 44 2007 41 59 2005 46 2526 40 2521 44 2092 41 59 2006 46 2527 40 41 46 2528 40 2521 41 59 450 2521 59 125 621 621 621 439 457 2529 2530 40 2005 2006 44 404 2007 44 2531 2532 44 2001 2009 41 123 2529 2533 61 418 2534 40 2009 41 59 2533 46 2535 40 2532 41 59 2005 46 2536 40 2533 44 2007 41 59 2006 46 2537 40 41 46 2538 40 2533 41 59 450 2533 59 125 621 621 621 439 457 2036 60 2027 44 2529 44 2529 62 2539 40 2005 2006 44 404 2007 44 2531 2532 44 2001 2009 44 2001 2540 44 2001 2541 44 356 2013 41 123 2529 2542 61 418 2543 40 2540 41 59 2542 46 2544 40 2532 41 59 2542 46 2545 40 418 2546 40 1502 44 1500 44 1500 44 1500 41 41 59 2529 2547 61 418 2543 40 2541 41 59 2547 46 2544 40 2532 41 59 2547 46 2545 40 418 2546 40 1502 44 1500 44 1500 44 1500 41 41 59 2504 2548 61 418 2504 40 41 59 2548 46 2549 40 1502 41 59 2548 46 2550 40 41 46 2551 40 2542 44 2547 41 59 381 2109 60 2027 44 2037 62 2552 61 2553 40 2006 44 2007 44 2009 44 2548 44 2013 41 59 450 418 2036 60 62 40 2552 46 2554 44 2542 44 2547 41 59 125 621 621 621 439 457 2476 60 2027 44 2070 44 2529 44 2529 62 2555 40 2005 2006 44 404 2007 44 2531 2532 44 2001 2009 44 2001 2556 44 2001 2540 44 2001 2541 44 356 2013 41 123 2070 2557 61 418 2558 40 41 59 2557 46 2559 40 2556 41 59 2529 2560 61 418 2561 40 2540 41 59 2560 46 2562 40 2532 41 59 2560 46 2563 40 418 2564 40 1502 44 1500 44 1500 44 1500 41 41 59 2529 2565 61 418 2561 40 2541 41 59 2565 46 2562 40 2532 41 59 2565 46 2563 40 418 2564 40 1502 44 1500 44 1500 44 1500 41 41 59 2504 2566 61 418 2504 40 41 59 2566 46 2567 40 1502 41 59 2566 46 2568 40 41 46 2569 40 2557 44 2560 44 2565 41 59 381 2109 60 2027 44 2037 62 2570 61 2571 40 2006 44 2007 44 2009 44 2566 44 2013 41 59 450 418 2476 60 62 40 2570 46 2572 44 2557 44 2560 44 2565 41 59 125 621 621 621 439 457 2496 2573 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2573 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2496 2573 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2496 2574 61 418 2575 40 2009 41 59 2005 46 2576 40 2574 44 2007 41 59 2005 46 2577 40 2574 44 1500 41 59 2005 46 2578 40 2574 44 418 2579 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2580 40 41 46 2581 40 2574 41 59 450 2574 59 125 621 621 621 439 457 2389 2582 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2582 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2389 2582 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2389 2583 61 418 2584 40 41 59 2583 46 2585 40 2009 41 59 2005 46 2586 40 2583 44 2007 41 59 2005 46 2587 40 2583 44 1500 41 59 2005 46 2588 40 2583 44 418 2589 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2590 40 41 46 2591 40 2583 41 59 450 2583 59 125 621 621 621 439 457 60 2592 62 2593 60 2592 62 2594 40 2005 2006 44 404 2007 44 404 2013 41 123 381 2595 60 2592 62 2596 61 418 2595 60 62 40 41 59 2005 46 2597 40 2596 44 2007 41 59 2005 46 2598 40 2596 44 418 2599 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2600 40 41 46 2601 40 2596 41 59 450 2596 59 125 621 621 621 439 457 60 2592 62 2109 60 2027 44 2593 60 2592 641 2602 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2256 44 404 2013 41 123 381 2036 60 2037 44 2027 44 2593 60 2592 641 2603 61 2602 40 2009 44 2256 44 1500 41 59 381 2037 2604 61 2603 46 2605 59 2005 46 2606 40 2604 44 2007 41 59 2005 46 2607 40 2604 44 418 2608 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2609 40 41 46 2610 40 2604 41 59 450 418 2109 60 62 40 2603 46 2611 44 2603 46 2612 41 59 125 439 457 60 2592 62 2036 60 2037 44 2027 44 2593 60 2592 641 2602 40 2001 2009 44 2001 2256 41 123 450 2602 40 2009 44 2256 44 1500 41 59 125 439 457 60 2592 62 2036 60 2037 44 2027 44 2593 60 2592 641 2602 40 2001 2009 44 2001 2256 44 404 2013 41 123 2027 2613 61 2614 40 2009 41 59 2037 2615 61 2616 40 2013 41 59 381 2617 60 2592 62 2618 61 418 2617 60 62 40 41 59 2618 46 2619 40 2256 41 59 2615 46 2620 40 41 46 2621 40 2613 44 2618 41 59 450 418 2036 60 62 40 2615 44 2613 44 2618 41 59 125 439 457 60 2592 62 2036 60 2037 44 2027 44 2622 60 2592 641 2623 40 2001 2009 41 123 450 2623 40 2009 44 1500 41 59 125 439 457 60 2592 62 2036 60 2037 44 2027 44 2622 60 2592 641 2623 40 2001 2009 44 404 2013 41 123 2027 2624 61 2625 40 2009 41 59 2037 2626 61 2627 40 2013 41 59 381 2622 60 2592 62 2628 61 418 2622 60 62 40 41 59 2626 46 2629 40 41 46 2630 40 2624 44 2628 41 59 450 418 2036 60 62 40 2626 44 2624 44 2628 41 59 125 64 2631 437 457 2037 2632 40 404 2013 41 123 2037 2633 61 418 2037 40 41 59 2633 46 2634 40 1500 41 59 2633 46 2635 40 418 2636 40 2013 44 1500 44 1500 44 1500 41 41 59 2633 46 2637 40 2638 46 2639 41 59 450 2633 59 125 64 2631 437 457 2027 2640 40 2001 2009 41 123 2027 2641 61 418 2642 40 2009 41 59 2641 46 2643 40 41 46 2644 40 648 41 59 450 2641 59 125 439 457 2109 60 2027 44 2037 62 2645 40 2005 2006 44 404 2007 44 2001 2009 44 2646 2647 44 356 2013 41 123 450 2645 40 2006 44 2007 44 1500 44 2009 44 2647 44 2013 41 59 125 64 2631 439 457 2109 60 2027 44 2037 62 2645 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 44 2646 2647 44 356 2013 41 123 381 2109 60 2027 44 2037 62 2648 61 2649 40 2009 44 2647 41 59 2037 2650 61 2648 46 2651 59 2005 46 2652 40 2650 44 2007 41 59 2005 46 2653 40 2650 44 2010 41 59 2005 46 2654 40 2650 44 418 2655 40 2013 43 2656 46 2657 44 1500 44 1500 44 1500 41 41 59 2006 46 2658 40 41 46 2659 40 2650 41 59 450 418 2109 60 62 40 2648 46 2660 44 2650 41 59 125 64 2631 439 457 2109 60 2027 44 2037 62 2661 40 2001 2009 44 2646 2647 41 123 2027 2662 61 2640 40 2009 41 59 2037 2663 61 2632 40 1500 41 59 2663 46 2664 40 41 46 2665 40 2662 44 2647 41 59 450 418 2109 60 62 40 2662 44 2663 41 59 125 439 457 2036 60 2027 44 2070 44 2504 62 2666 40 2005 2006 44 404 2007 44 2001 2667 44 356 2013 41 123 2504 2668 61 418 2504 40 41 59 2668 46 2669 40 1502 41 59 2070 2670 61 418 2671 40 41 59 381 2037 2672 61 2632 40 1502 41 59 381 2027 2673 61 2640 40 2667 41 59 2672 46 2674 40 41 46 2675 40 2673 44 2670 41 59 2668 46 2674 40 41 46 2675 40 2672 41 59 2005 46 2676 40 2668 44 2007 41 59 2005 46 2677 40 2668 44 418 2678 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2674 40 41 46 2679 40 2668 41 59 450 418 2036 60 62 40 2673 44 2670 44 2668 41 59 125 621 621 621 439 457 60 2592 62 2593 60 2592 62 2594 40 2005 2006 44 404 2007 41 123 450 2594 40 2006 44 2007 44 424 44 1500 41 59 125 439 457 60 2592 62 2593 60 2592 62 2594 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2594 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 60 2592 62 2593 60 2592 62 2594 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2680 60 2592 62 2681 61 418 2680 60 62 40 41 59 2681 46 2682 40 473 41 59 2681 46 2683 40 2009 41 59 2681 46 2684 40 2685 46 2686 41 59 621 621 2681 46 2687 40 2688 40 2009 44 2681 41 41 59 2005 46 2689 40 2681 44 2007 41 59 2005 46 2690 40 2681 44 1500 41 59 2005 46 2691 40 2681 44 418 2692 40 2013 43 2693 46 2694 44 1500 44 1500 44 1500 41 41 59 2006 46 2695 40 41 46 2696 40 2681 41 59 450 2681 59 125 621 621 621 439 457 60 2592 62 2109 60 2027 44 2593 60 2592 641 2697 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2622 60 2592 62 2698 61 418 2622 60 62 40 41 59 381 2109 60 2027 44 2037 62 2699 61 2645 40 2006 44 2007 44 2009 44 2698 44 2013 41 59 450 418 2109 60 62 40 2699 46 2700 44 2698 41 59 125 621 621 621 439 457 60 2592 62 2476 60 2027 44 2070 44 2027 44 2593 60 2592 641 2701 40 2005 2006 44 404 2007 44 2001 2667 44 2001 2702 41 123 450 2701 40 2006 44 2007 44 2667 44 2702 44 1500 41 59 125 439 457 60 2592 62 2476 60 2027 44 2070 44 2027 44 2593 60 2592 641 2701 40 2005 2006 44 404 2007 44 2001 2667 44 2001 2702 44 356 2013 41 123 2504 2703 61 418 2504 40 41 59 2703 46 2704 40 1502 41 59 381 2037 2705 61 2632 40 1502 41 59 381 2027 2706 61 2640 40 2667 41 59 381 2070 2707 61 418 2708 40 41 59 2705 46 2709 40 41 46 2710 40 2706 44 2707 41 59 381 2037 2711 61 2632 40 1502 41 59 381 2027 2712 61 2640 40 2702 41 59 2622 60 2592 62 2713 61 418 2622 60 62 40 41 59 2713 46 2714 40 2702 41 59 2713 46 2715 40 473 41 59 2711 46 2709 40 41 46 2710 40 2712 44 2713 41 59 2703 46 2709 40 41 46 2710 40 2705 44 2711 41 59 2005 46 2716 40 2703 44 2007 41 59 2005 46 2717 40 2703 44 418 2718 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2709 40 41 46 2719 40 2703 41 59 450 418 2476 60 62 40 2706 44 2707 44 2712 44 2713 41 59 125 621 621 621 439 457 60 2592 44 2720 62 2036 60 2027 44 2593 60 2720 62 44 2593 60 2592 641 2721 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2721 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 60 2592 44 2720 62 2036 60 2027 44 2593 60 2592 62 44 2593 60 2720 641 2721 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2504 2722 61 418 2504 40 41 59 2722 46 2723 40 1502 41 59 2593 60 2592 62 2724 61 418 2725 60 62 40 41 59 2593 60 2720 62 2726 61 418 2725 60 62 40 41 59 2722 46 2727 40 41 46 2728 40 2724 44 2726 41 59 381 2109 60 2027 44 2037 62 2729 61 2645 40 2006 44 2007 44 2009 44 2722 44 2013 41 59 450 418 2036 60 62 40 2729 46 2730 44 2724 44 2726 41 59 125 621 621 621 439 457 60 2592 62 2476 60 2593 60 2592 62 44 2027 44 2070 44 2504 62 2731 40 2005 2006 44 404 2007 44 2001 2702 44 2001 2667 41 123 450 2731 40 2006 44 2007 44 2702 44 2667 44 1500 41 59 125 439 457 60 2592 62 2476 60 2593 60 2592 62 44 2027 44 2070 44 2504 62 2731 40 2005 2006 44 404 2007 44 2001 2702 44 2001 2667 44 356 2013 41 123 2504 2732 61 418 2504 40 41 59 2732 46 2733 40 1502 41 59 2734 60 2592 62 2735 61 418 2734 60 62 40 41 59 2735 46 2736 40 2702 41 59 2735 46 2737 40 473 41 59 2070 2738 61 418 2739 40 41 59 381 2037 2740 61 2632 40 1502 41 59 381 2027 2741 61 2640 40 2667 41 59 2740 46 2742 40 41 46 2743 40 2741 44 2738 41 59 2732 46 2742 40 41 46 2743 40 2735 44 2740 41 59 2005 46 2744 40 2732 44 2007 41 59 2005 46 2745 40 2732 44 418 2746 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2742 40 41 46 2747 40 2732 41 59 450 418 2476 60 62 40 2735 44 2741 44 2738 44 2732 41 59 125 621 621 621 439 457 60 2592 62 2036 60 2027 44 2593 60 2592 62 44 2110 62 2748 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2423 41 123 450 2748 40 2006 44 2007 44 2009 44 2423 44 1500 41 59 125 439 457 60 2592 62 2036 60 2027 44 2593 60 2592 62 44 2110 62 2748 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2423 44 356 2013 41 123 2027 2749 61 2028 40 2006 44 2007 44 2009 44 2013 41 59 2504 2750 61 418 2504 40 41 59 2750 46 2751 40 1502 41 59 2110 2752 61 418 2753 40 2423 41 59 2752 46 2754 40 473 41 59 2593 60 2592 62 2755 61 418 2756 60 62 40 41 59 2750 46 2757 40 41 46 2758 40 2755 44 2752 41 59 2005 46 2759 40 2750 44 2007 41 59 2005 46 2760 40 2750 44 1501 41 59 2005 46 2761 40 2750 44 418 2762 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2757 40 41 46 2763 40 2750 41 59 450 418 2036 60 62 40 2749 44 2755 44 2752 41 59 125 621 621 621 439 457 60 2592 62 2036 60 2027 44 2593 60 2592 62 44 2070 62 2764 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2765 41 123 450 2764 40 2006 44 2007 44 2009 44 2765 44 1500 41 59 125 439 457 60 2592 62 2036 60 2027 44 2593 60 2592 62 44 2070 62 2764 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2765 44 356 2013 41 123 2027 2766 61 2028 40 2006 44 2007 44 2009 44 2013 41 59 2504 2767 61 418 2504 40 41 59 2767 46 2768 40 1502 41 59 2593 60 2592 62 2769 61 418 2770 60 62 40 41 59 2070 2771 61 418 2070 40 2765 41 59 2771 46 2772 40 380 41 59 2771 46 2773 40 473 41 59 2771 46 2774 40 380 41 59 2767 46 2775 40 41 46 2776 40 2769 44 2771 41 59 2005 46 2777 40 2767 44 2007 41 59 2005 46 2778 40 2767 44 1501 41 59 2005 46 2779 40 2767 44 418 2780 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2775 40 41 46 2781 40 2767 41 59 450 418 2036 60 62 40 2766 44 2769 44 2771 41 59 125 621 621 621 439 457 2109 60 2027 44 2321 62 2322 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 41 123 450 2322 40 2006 44 2007 44 2010 44 2009 44 1500 41 59 125 439 457 2109 60 2027 44 2321 62 2322 40 2005 2006 44 404 2007 44 404 2010 44 2001 2009 44 356 2013 41 123 2027 2782 61 2028 40 2006 44 2007 44 2009 44 2013 41 59 2321 2783 61 418 2321 40 41 59 2005 46 2784 40 2783 44 2007 41 59 2005 46 2785 40 2783 44 2010 41 59 2005 46 2786 40 2783 44 418 2787 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2788 40 41 46 2789 40 2783 41 59 450 418 2109 60 62 40 2782 44 2783 41 59 125 439 457 2036 60 2027 44 2321 44 2037 62 2790 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2321 2791 61 418 2321 40 41 59 2791 46 2792 40 380 41 59 381 2109 60 2027 44 2037 62 2793 61 2645 40 2006 44 2007 44 2009 44 2791 44 2013 41 59 621 621 450 418 2036 60 62 40 2793 46 2794 44 2791 44 2793 46 2795 41 59 125 621 621 621 439 457 2109 60 2027 44 2172 62 2796 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 41 123 450 2797 40 2006 44 2007 44 2009 44 2078 44 45 2798 46 2799 41 59 125 439 457 2109 60 2027 44 2172 62 2796 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2078 44 356 2013 41 123 450 2800 40 2006 44 2007 44 2092 44 2009 44 2078 44 2013 45 2801 46 2802 41 59 125 439 457 2109 60 2027 44 2172 62 2796 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 41 123 450 2803 40 2006 44 2007 44 2092 44 2009 44 648 44 45 2804 46 2805 41 59 125 439 457 2109 60 2027 44 2172 62 2796 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2078 41 123 450 2806 40 2006 44 2007 44 2092 44 2009 44 2078 44 45 2807 46 2808 41 59 125 439 457 2109 60 2027 44 2172 62 2796 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2078 44 324 2809 41 123 450 2810 40 2006 44 2007 44 2092 44 2009 44 2078 44 45 2811 46 2812 44 2809 41 59 125 439 457 2109 60 2027 44 2172 62 2813 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 41 123 450 2813 40 2006 44 2007 44 2009 44 2078 44 1500 41 59 125 439 457 2109 60 2027 44 2172 62 2813 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 44 356 2013 41 123 450 2813 40 2006 44 2007 44 2009 44 2078 44 2013 44 424 41 59 125 439 457 2109 60 2027 44 2172 62 2813 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 44 356 2013 44 2001 2814 41 123 2172 2815 61 418 2172 40 2814 41 59 2815 46 2816 40 2078 41 59 381 2109 60 2027 44 2037 62 2817 61 2645 40 2006 44 2007 44 2009 44 2815 44 2013 41 59 450 418 2109 60 62 40 2817 46 2818 44 2815 41 59 125 439 457 2109 60 2027 44 2172 62 2813 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2078 44 356 2013 44 324 2809 41 123 2172 2819 61 418 2172 40 41 59 2819 46 2820 40 2078 41 59 2819 46 2821 40 473 41 59 381 2109 60 2027 44 2037 62 2822 61 2645 40 2006 44 2007 44 2009 44 2819 44 2013 41 59 2822 46 2823 46 2824 40 2825 46 2826 41 59 2005 46 2827 40 2822 46 2823 44 2092 41 59 450 418 2109 60 62 40 2822 46 2828 44 2819 41 59 125 439 457 2109 60 2027 44 2172 62 2813 40 2005 2006 44 404 2007 44 404 2092 44 2001 2009 44 2001 2078 44 356 2013 41 123 2172 2829 61 418 2172 40 41 59 2829 46 2830 40 2078 41 59 381 2109 60 2027 44 2037 62 2831 61 2645 40 2006 44 2007 44 2009 44 2829 44 2013 41 59 2831 46 2832 46 2833 40 2834 46 2835 41 59 2005 46 2836 40 2831 46 2832 44 2092 41 59 450 418 2109 60 62 40 2831 46 2837 44 2829 41 59 125 439 457 2109 60 2027 44 2172 62 2838 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 41 123 450 2838 40 2006 44 2007 44 2009 44 2078 44 1500 41 59 125 439 457 2109 60 2027 44 2172 62 2838 40 2005 2006 44 404 2007 44 2001 2009 44 2001 2078 44 356 2013 41 123 2027 2839 61 2028 40 2006 44 2007 44 2009 44 2013 41 59 2839 46 2840 40 41 46 2841 40 648 41 59 2005 46 2842 40 2839 44 2843 46 2844 41 59 2172 2845 61 418 2172 40 648 41 59 2845 46 2846 40 2078 41 59 2005 46 2847 40 2845 44 2007 41 59 2005 46 2848 40 2845 44 1501 41 59 2005 46 2849 40 2845 44 418 2850 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2851 40 41 46 2841 40 2845 41 59 450 418 2109 60 62 40 2839 44 2845 41 59 125 621 621 621 439 457 2852 2853 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2853 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2852 2853 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2852 2854 61 418 2852 40 2009 41 59 2005 46 2855 40 2854 44 2007 41 59 2005 46 2856 40 2854 44 1500 41 59 2005 46 2857 40 2854 44 418 2858 40 2013 43 1503 44 1500 44 1500 44 1500 41 41 59 2006 46 2859 40 41 46 2860 40 2854 41 59 450 2854 59 125 621 621 621 439 457 2861 2862 40 2005 2006 44 404 2007 44 2001 2051 41 123 450 2862 40 2006 44 2007 44 2051 44 1500 41 59 125 439 457 2861 2862 40 2005 2006 44 404 2007 44 2001 2051 44 356 2013 41 123 2861 2863 61 418 2861 40 41 59 2863 46 2864 40 41 46 2865 40 2051 41 59 2005 46 2866 40 2863 44 2007 41 59 2005 46 2867 40 2863 44 1500 41 59 2005 46 2868 40 2863 44 418 2869 40 2013 43 1503 44 1500 44 1500 44 1500 41 41 59 2006 46 2870 40 41 46 2871 40 2863 41 59 450 2863 59 125 621 621 621 439 457 2036 60 2027 44 2872 44 2037 62 2873 40 2005 2006 44 404 2007 44 2001 2874 44 2001 2875 41 123 450 2876 40 2006 44 2007 44 2874 44 2875 44 45 2877 46 2878 41 59 125 439 457 2036 60 2027 44 2872 44 2037 62 2879 40 2005 2006 44 404 2007 44 2001 2874 44 2001 2875 44 356 2013 41 123 2872 2880 61 418 2872 40 41 59 2880 46 2881 40 2875 41 59 381 2109 60 2027 44 2037 62 2882 61 2645 40 2006 44 2007 44 2874 44 2880 44 2013 41 59 450 418 2036 60 62 40 2882 46 2883 44 2880 44 2882 46 2884 41 59 125 621 621 621 439 457 2036 60 2027 44 2885 44 2037 62 2886 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2886 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2036 60 2027 44 2885 44 2037 62 2886 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2885 2887 61 418 2885 40 41 59 2887 46 2888 40 380 41 59 2109 60 2027 44 2037 62 2889 61 2645 40 2006 44 2007 44 2009 44 2887 44 2013 45 1503 41 59 450 418 2036 60 62 40 2889 46 2890 44 2887 44 2889 46 2891 41 59 125 621 621 621 439 457 2892 2893 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2893 40 2006 44 2007 44 2009 44 1503 41 59 125 439 457 2892 2893 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 2892 2894 61 418 2892 40 2009 41 59 2005 46 2895 40 2894 44 2007 41 59 2005 46 2896 40 2894 44 1500 41 59 2005 46 2897 40 2894 44 418 2898 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2899 40 41 46 2900 40 2894 41 59 450 2894 59 125 621 621 621 439 457 2109 60 2027 44 2110 62 2901 40 2005 2006 44 404 2007 44 2001 2874 44 2001 2423 41 123 450 2901 40 2006 44 2007 44 2874 44 2423 44 1500 41 59 125 439 457 2109 60 2027 44 2110 62 2901 40 2005 2006 44 404 2007 44 2001 2874 44 2001 2423 44 356 2013 41 123 2110 2902 61 418 2903 40 2423 41 59 2902 46 2904 40 473 41 59 381 2109 60 2027 44 2037 62 2905 61 2645 40 2006 44 2007 44 2874 44 2902 44 2013 41 59 450 418 2109 60 62 40 2905 46 2906 44 2902 41 59 125 439 457 2109 60 2027 44 2110 62 2907 40 2005 2006 44 404 2007 44 2001 2874 44 2001 2423 44 356 2013 41 123 2027 2908 61 2028 40 2006 44 2007 44 2874 41 59 2908 46 2909 40 41 46 2910 40 648 41 59 2110 2911 61 418 2912 40 2423 41 59 2911 46 2909 40 41 46 2910 40 648 41 59 2911 46 2913 40 473 41 59 2005 46 2914 40 2911 44 1501 41 59 2005 46 2915 40 2911 44 2007 41 59 2005 46 2916 40 2908 44 418 2917 40 2013 44 1500 44 1500 44 1500 41 41 59 2005 46 2918 40 2908 44 2919 46 2920 41 59 2005 46 2916 40 2911 44 418 2917 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 2921 40 41 46 2910 40 2911 41 59 450 418 2109 60 62 40 2908 44 2911 41 59 125 621 621 621 439 457 2036 60 2027 44 2110 44 2110 62 2922 40 2005 2006 44 404 2007 44 2001 2874 44 2001 2144 44 2001 2145 44 356 2013 41 123 2504 2923 61 418 2504 40 41 59 2923 46 2924 40 1502 41 59 2110 2925 61 418 2926 40 2144 41 59 2925 46 2927 40 473 41 59 2925 46 2928 40 41 46 2929 40 648 41 59 2925 46 2927 40 473 41 59 2925 46 2930 40 2931 46 2932 41 59 2504 46 2933 40 2925 44 2934 46 2935 41 59 2110 2936 61 418 2926 40 2145 41 59 2936 46 2930 40 2931 46 2932 41 59 2504 46 2933 40 2936 44 2934 46 2935 41 59 2923 46 2937 40 41 46 2938 40 2925 44 2936 41 59 381 2109 60 2027 44 2037 62 2939 61 2645 40 2006 44 2007 44 2874 44 2923 44 2013 41 59 450 418 2036 60 62 40 2939 46 2940 44 2925 44 2936 41 59 125 621 621 621 439 457 2110 2941 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2941 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 2110 2942 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2941 40 2006 44 2007 44 2009 44 1503 41 59 125 439 457 2110 2943 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 450 2941 40 2006 44 2007 44 2009 44 2013 44 473 41 59 125 439 457 2110 2944 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 2943 40 2006 44 2007 44 2009 44 1503 41 59 125 439 457 2110 2941 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 450 2941 40 2006 44 2007 44 2009 44 2013 44 380 41 59 125 439 457 2110 2941 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 44 324 2945 41 123 2110 2946 61 418 2947 40 2009 41 59 392 40 2945 41 123 2946 46 2948 40 473 41 59 2946 46 2949 40 41 46 2950 40 648 41 59 125 2005 46 2951 40 2946 44 2007 41 59 2005 46 2952 40 2946 44 1500 41 59 2006 46 2953 40 41 46 2954 40 2946 41 59 2005 46 2955 40 2946 44 418 2956 40 2013 44 1500 44 1500 44 1500 41 41 59 450 2946 59 125 621 621 621 439 457 2109 60 2110 44 2110 62 2957 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 41 123 450 2957 40 2006 44 2007 44 2144 44 2145 44 1500 41 59 125 439 457 2109 60 2110 44 2110 62 2958 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 41 123 450 2958 40 2006 44 2007 44 2144 44 2145 44 473 41 59 125 439 457 2109 60 2110 44 2110 62 2958 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 324 2959 41 123 450 2957 40 2006 44 2007 44 2144 44 2145 44 1503 44 2959 41 59 125 439 457 2109 60 2110 44 2110 62 2957 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 356 2013 41 123 450 2957 40 2006 44 2007 44 2144 44 2145 44 2013 44 473 41 59 125 439 457 2109 60 2110 44 2110 62 2957 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 356 2013 44 324 2959 41 123 381 2036 60 2110 44 2110 44 2504 62 2960 61 2961 40 2006 44 2007 44 2144 44 2145 44 2013 44 2959 41 59 450 418 2109 60 62 40 2960 46 2962 44 2960 46 2963 41 59 125 439 457 2036 60 2110 44 2110 44 2504 62 2964 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 356 2013 44 324 2959 41 123 2504 2965 61 418 2504 40 41 59 2965 46 2966 40 1502 41 59 2110 2967 61 418 2968 40 2144 41 59 392 40 2959 41 123 2967 46 2969 40 41 46 2970 40 648 41 59 2967 46 2971 40 473 41 59 125 2967 46 2972 40 2973 46 2974 41 59 2504 46 2975 40 2967 44 2976 46 2977 41 59 2110 2978 61 418 2968 40 2145 41 59 2978 46 2972 40 2973 46 2974 41 59 2504 46 2975 40 2978 44 2976 46 2977 41 59 2965 46 2979 40 41 46 2980 40 2967 44 2978 41 59 2005 46 2981 40 2965 44 2007 41 59 2005 46 2982 40 2965 44 1500 41 59 2005 46 2983 40 2965 44 418 2984 40 2013 44 1502 44 1500 44 1500 41 41 59 2006 46 2979 40 41 46 2985 40 2965 41 59 450 418 2036 60 62 40 2967 44 2978 44 2965 41 59 125 621 621 621 439 457 2036 60 2110 44 2110 44 2110 62 2986 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 2001 2987 41 123 450 2986 40 2006 44 2007 44 2144 44 2145 44 2987 44 1500 41 59 125 439 457 2036 60 2110 44 2110 44 2110 62 2988 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 2001 2987 41 123 450 2986 40 2006 44 2007 44 2144 44 2145 44 2987 44 1503 41 59 125 439 457 2036 60 2110 44 2110 44 2110 62 2986 40 2005 2006 44 404 2007 44 2001 2144 44 2001 2145 44 2001 2987 44 356 2013 41 123 2504 2989 61 418 2504 40 41 59 2989 46 2990 40 1502 41 59 2110 2991 61 418 2992 40 2144 41 59 2991 46 2993 40 41 46 2994 40 648 41 59 2991 46 2995 40 473 41 59 2991 46 2996 40 2997 46 2998 41 59 2504 46 2999 40 2991 44 3000 46 3001 41 59 2110 3002 61 418 2992 40 2145 41 59 3002 46 2996 40 2997 46 2998 41 59 2504 46 2999 40 3002 44 3000 46 3001 41 59 2110 3003 61 418 2992 40 2987 41 59 3003 46 2996 40 2997 46 2998 41 59 2504 46 2999 40 3003 44 3000 46 3001 41 59 2989 46 3004 40 41 46 3005 40 2991 44 3002 44 3003 41 59 2005 46 3006 40 2989 44 2007 41 59 2005 46 3007 40 2989 44 1500 41 59 2005 46 3008 40 2989 44 418 3009 40 2013 44 1502 44 1500 44 1500 41 41 59 2006 46 3004 40 41 46 2994 40 2989 41 59 450 418 2036 60 62 40 2991 44 3002 44 3003 41 59 125 621 621 621 439 457 2476 60 2110 44 3010 44 2027 44 2504 62 3011 40 2005 2006 44 404 2007 44 404 2092 44 2001 2423 41 123 450 3012 40 2006 44 2007 44 2092 44 2423 44 1503 41 59 125 439 457 2476 60 2110 44 3010 44 2027 44 2504 62 3011 40 2005 2006 44 404 2007 44 2001 2423 41 123 450 3011 40 2006 44 2007 44 1500 44 2423 41 59 125 439 457 2476 60 2110 44 3010 44 2027 44 2504 62 3013 40 2005 2006 44 404 2007 44 404 2092 44 2001 2423 44 356 2013 41 123 2504 3014 61 418 2504 40 41 59 3014 46 3015 40 1502 41 59 2110 3016 61 418 3017 40 2423 41 59 3016 46 3018 40 473 41 59 3016 46 3019 40 41 46 3020 40 648 41 59 3010 3021 61 418 3010 40 380 41 59 2027 3022 61 418 3023 40 41 59 3014 46 3024 40 3025 46 3026 41 59 3014 46 3027 40 41 46 3028 40 3016 44 3021 44 3022 41 59 2005 46 3029 40 3014 44 2007 41 59 2005 46 3030 40 3014 44 3031 46 3032 41 59 2005 46 3033 40 3014 44 2092 41 59 2005 46 3034 40 3014 44 418 3035 40 2013 44 1500 44 1500 44 1500 41 41 59 2006 46 3027 40 41 46 3020 40 3014 41 59 450 418 2476 60 62 40 3016 44 3021 44 3022 44 3014 41 59 125 621 621 621 439 457 2036 60 2504 44 2348 44 2027 62 3036 40 2001 3037 41 123 2348 3038 61 418 2348 40 1503 41 59 3038 46 3039 40 3037 41 59 2027 3040 61 418 3041 40 3042 46 3043 40 41 41 59 3040 46 3044 40 41 46 3045 40 648 41 59 2504 3046 61 418 2504 40 41 59 2504 46 3047 40 3038 44 3048 46 3049 41 59 3038 46 3050 40 3051 46 3052 41 59 3046 46 3044 40 41 46 3045 40 648 41 59 3046 46 3053 40 41 46 3054 40 3038 44 3040 41 59 450 418 2036 60 62 40 3046 44 3038 44 3040 41 59 125 439 457 2036 60 2504 44 2372 44 2027 62 3055 40 2001 3037 41 123 2372 3056 61 418 2372 40 1503 41 59 2348 3057 61 3056 46 3058 40 41 59 3057 46 3059 40 3037 41 59 2027 3060 61 418 3061 40 3062 46 3063 40 41 41 59 3060 46 3064 40 41 46 3065 40 648 41 59 2504 3066 61 418 2504 40 41 59 2504 46 3067 40 3056 44 3068 46 3069 41 59 3056 46 3070 40 3071 46 3072 41 59 3066 46 3064 40 41 46 3065 40 648 41 59 3066 46 3073 40 41 46 3074 40 3056 44 3060 41 59 450 418 2036 60 62 40 3066 44 3056 44 3060 41 59 125 439 457 2036 60 2504 44 2070 44 2027 62 3075 40 41 123 381 2036 60 2504 44 2348 44 2027 62 3076 61 3036 40 648 41 59 381 2070 3077 61 3076 46 3078 59 3077 46 3079 40 473 41 59 450 418 2036 60 62 40 3076 46 3080 44 3076 46 3078 44 3076 46 3081 41 59 125 439 457 2036 60 2504 44 2372 44 2027 62 3082 40 41 123 381 2036 60 2504 44 2372 44 2027 62 3083 61 3055 40 648 41 59 2070 3084 61 3083 46 3085 46 3086 40 41 59 3084 46 3087 40 473 41 59 450 3083 59 125 621 621 621 439 457 2109 60 2027 44 2037 62 3088 40 3089 3090 44 2001 3091 41 123 2027 3092 61 418 3093 40 3091 41 59 3092 46 3094 40 648 41 59 3092 46 3095 40 1504 41 59 2037 3096 61 418 2037 40 41 59 3096 46 3097 40 418 3098 40 1502 44 1500 44 1500 44 1500 41 41 59 3096 46 3099 40 1502 41 59 3096 46 3100 40 41 46 3101 40 3092 44 3090 41 59 450 418 2109 60 62 40 3092 44 3096 41 59 125 621 621 621 439 457 60 2592 62 2036 60 2027 44 3102 60 2592 62 44 2037 62 3103 40 2005 2006 44 404 2007 44 2001 2009 41 123 450 3103 40 2006 44 2007 44 2009 44 1500 41 59 125 439 457 60 2592 62 2036 60 2027 44 3102 60 2592 62 44 2037 62 3103 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 3102 60 2592 62 3104 61 418 3102 60 62 40 41 59 381 2109 60 2027 44 2037 62 3105 61 2645 40 2006 44 2007 44 2009 44 3104 44 2013 41 59 450 418 2036 60 62 40 3105 46 3106 44 3104 44 3105 46 3107 41 59 125 621 621 621 439 457 2109 60 2027 44 3108 62 3109 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 41 123 450 3109 40 2006 44 2007 44 2009 44 2013 44 1500 41 59 125 439 457 2109 60 2027 44 3108 62 3109 40 2005 2006 44 404 2007 44 2001 2009 44 356 2013 44 356 3110 41 123 3108 3111 61 418 3108 40 41 59 3111 46 3112 40 418 3113 40 1502 44 1502 44 1502 44 1502 41 41 59 3111 46 3114 40 1502 41 59 3111 46 3115 40 1502 41 59 381 2109 60 2027 44 2037 62 3116 61 2645 40 2006 44 2007 44 2009 44 3111 44 2013 41 59 2005 46 3117 40 3116 46 3118 44 418 3113 40 2013 43 3119 46 3120 44 1500 44 3110 44 1500 41 41 59 450 418 2109 60 62 40 3116 46 3121 44 3111 41 59 125 621 621 621 439 457 492 3122 40 2005 2006 44 404 3123 41 123 3124 40 2006 44 3123 44 3123 41 59 125 439 457 492 3125 40 2005 2006 44 404 3126 44 404 3127 41 123 3128 60 2646 62 3129 61 418 3130 60 62 40 2006 46 3131 40 41 41 59 3129 46 3132 40 41 46 3133 40 3134 45 62 2005 46 3135 40 3134 41 631 424 605 2005 46 3135 40 3134 41 615 3126 605 2005 46 3135 40 3134 41 620 3127 41 46 3136 40 3134 45 62 2006 46 3131 40 41 46 3137 40 3134 41 41 59 125 621 621 621 439 457 3138 3139 40 3140 3141 44 2001 3142 44 2027 3143 44 2001 3144 41 123 392 40 3141 46 3145 40 41 46 3146 40 2002 41 41 123 381 3138 3147 61 3148 46 3149 40 41 46 3150 40 3141 44 3142 41 59 3147 46 3151 40 1499 41 59 392 40 3144 631 424 41 123 3147 46 3152 40 41 46 3153 40 3144 41 59 125 3143 46 3154 40 3155 46 3156 41 59 3143 46 3157 40 3147 41 59 450 3147 59 125 360 123 469 418 3158 40 648 41 59 125 125 439 457 3138 3139 40 3140 3141 44 2001 3142 44 2027 3143 41 123 450 3139 40 3141 44 3142 44 3143 44 424 41 59 125 439 457 3138 3159 40 3140 3141 44 2027 3143 44 2001 3144 41 123 450 3139 40 3141 44 648 44 3143 44 3144 41 59 125 439 457 3138 3159 40 3140 3141 44 2027 3143 41 123 450 3139 40 3141 44 648 44 3143 41 59 125 439 457 3138 3160 40 3140 3141 44 2027 3143 41 123 450 3139 40 3141 44 648 44 3143 41 59 125 439 457 3138 3161 40 3140 3141 41 123 450 3161 40 3141 44 648 41 59 125 439 457 3138 3162 40 3140 3141 41 123 450 3161 40 3141 44 648 41 59 125 439 457 3138 3163 40 3140 3141 41 123 450 3161 40 3141 44 648 41 59 125 439 457 3138 3161 40 3140 3141 44 2001 3142 41 123 3138 3164 59 392 40 3141 46 3165 40 41 46 3166 40 2002 41 41 123 3164 61 3167 46 3168 40 41 46 3169 40 3141 44 3142 41 59 125 360 123 469 418 3170 40 648 41 59 125 450 3164 59 125 439 457 2027 3161 40 3171 3141 41 123 381 2027 3143 61 418 2027 40 41 59 3172 46 3173 40 3143 44 3141 41 59 450 3143 59 125 439 457 2027 3139 40 3171 3141 44 2027 3143 44 2001 3174 41 123 3175 46 3176 40 3143 44 3141 44 3174 41 59 450 3143 59 125 439 457 2110 3177 40 3140 3141 41 123 450 3177 40 3141 44 648 41 59 125 439 457 2110 3177 40 3140 3141 44 2001 2814 41 123 450 3177 40 3141 44 2814 44 648 41 59 125 439 457 2110 3178 40 3140 3141 41 123 450 3177 40 3141 44 648 44 648 41 59 125 439 457 2110 3178 40 3140 3141 44 2001 2814 41 123 450 3177 40 3141 44 2814 44 648 41 59 125 439 457 2110 3177 40 3140 3141 44 2001 2814 44 2001 3142 41 123 392 40 3141 46 3179 40 41 46 3180 40 2002 41 41 123 2110 3181 61 3182 46 3183 40 41 46 3184 40 3141 44 648 44 3142 44 424 44 3185 46 3186 41 59 3181 46 3187 40 648 41 59 3181 46 3188 40 41 46 3189 40 41 46 3190 40 2814 41 59 3181 46 3191 40 1503 41 59 3181 46 3192 40 1503 41 59 3181 46 3193 40 418 3194 40 1500 41 41 59 450 3181 59 125 360 123 469 418 3195 40 648 41 59 125 125 439 457 60 2592 62 3196 60 2592 62 3197 40 2005 2006 44 404 2007 44 2001 3198 41 123 450 3197 40 2006 44 2007 44 3198 44 1500 44 424 41 59 125 439 457 60 2592 62 3196 60 2592 62 3197 40 2005 2006 44 404 2007 44 2001 3198 44 2001 3199 41 123 450 3197 40 2006 44 2007 44 3198 44 1500 44 3199 41 59 125 439 457 60 2592 62 3196 60 2592 62 3197 40 2005 2006 44 404 2007 44 2001 3198 44 404 2013 41 123 450 3197 40 2006 44 2007 44 3198 44 2013 44 424 41 59 125 439 457 60 2592 62 3196 60 2592 62 3197 40 2005 2006 44 404 2007 44 2001 3198 44 404 2013 44 2001 3199 41 123 2003 3200 61 2004 40 2006 44 2007 44 1501 44 3198 44 2013 41 59 392 40 3199 631 424 41 3200 46 3201 40 41 46 3202 40 3199 41 59 3196 60 2592 62 3203 61 418 3196 60 62 40 41 59 2005 46 3204 40 3203 44 2007 41 59 2005 46 3205 40 3203 44 418 3206 40 2013 43 1503 44 45 1502 44 1502 44 45 1502 41 41 59 2006 46 3207 40 41 46 3202 40 3203 41 59 3203 46 3208 40 418 3209 40 3210 46 3211 40 648 41 41 41 59 3203 46 3212 40 3196 46 3213 41 59 450 3203 59 125 125 
2614,Java,"public final class MemoryBehavior extends Behavior {

    private final List<FutureInventory> futureInventories = new ArrayList<>(); // this is per-bot

    private Integer enderChestWindowId; // nae nae

    public MemoryBehavior(Baritone baritone) {
        super(baritone);
    }

    @Override
    public synchronized void onTick(TickEvent event) {
        if (!Baritone.settings().containerMemory.value) {
            return;
        }
        if (event.getType() == TickEvent.Type.OUT) {
            enderChestWindowId = null;
            futureInventories.clear();
        }
    }

    @Override
    public synchronized void onPlayerUpdate(PlayerUpdateEvent event) {
        if (event.getState() == EventState.PRE) {
            updateInventory();
        }
    }

    @Override
    public synchronized void onSendPacket(PacketEvent event) {
        if (!Baritone.settings().containerMemory.value) {
            return;
        }
        Packet p = event.getPacket();

        if (event.getState() == EventState.PRE) {
            if (p instanceof CPacketPlayerTryUseItemOnBlock) {
                CPacketPlayerTryUseItemOnBlock packet = event.cast();

                TileEntity tileEntity = ctx.world().getTileEntity(packet.getPos());
                // if tileEntity is an ender chest, we don't need to do anything. ender chests are treated the same regardless of what coordinate right clicked

                // Ensure the TileEntity is a container of some sort
                if (tileEntity instanceof TileEntityLockable) {

                    TileEntityLockable lockable = (TileEntityLockable) tileEntity;
                    int size = lockable.getSizeInventory();
                    BetterBlockPos position = BetterBlockPos.from(tileEntity.getPos());
                    BetterBlockPos adj = BetterBlockPos.from(neighboringConnectedBlock(position));
                    System.out.println(position + "" "" + adj);
                    if (adj != null) {
                        size *= 2; // double chest or double trapped chest
                        if (adj.getX() < position.getX() || adj.getZ() < position.getZ()) {
                            position = adj; // standardize on the lower coordinate, regardless of which side of the large chest we right clicked
                        }
                    }

                    this.futureInventories.add(new FutureInventory(System.nanoTime() / 1000000L, size, lockable.getGuiID(), position));
                }
            }

            if (p instanceof CPacketCloseWindow) {
                getCurrent().save();
            }
        }
    }

    @Override
    public synchronized void onReceivePacket(PacketEvent event) {
        if (!Baritone.settings().containerMemory.value) {
            return;
        }
        Packet p = event.getPacket();

        if (event.getState() == EventState.PRE) {
            if (p instanceof SPacketOpenWindow) {
                SPacketOpenWindow packet = event.cast();
                // Remove any entries that were created over a second ago, this should make up for INSANE latency
                futureInventories.removeIf(i -> System.nanoTime() / 1000000L - i.time > 1000);

                System.out.println(""Received packet "" + packet.getGuiId() + "" "" + packet.getEntityId() + "" "" + packet.getSlotCount() + "" "" + packet.getWindowId());
                System.out.println(packet.getWindowTitle());
                if (packet.getWindowTitle() instanceof TextComponentTranslation && ((TextComponentTranslation) packet.getWindowTitle()).getKey().equals(""container.enderchest"")) {
                    // title is not customized (i.e. this isn't just a renamed shulker)
                    enderChestWindowId = packet.getWindowId();
                    return;
                }
                futureInventories.stream()
                        .filter(i -> i.type.equals(packet.getGuiId()) && i.slots == packet.getSlotCount())
                        .findFirst().ifPresent(matched -> {
                    // Remove the future inventory
                    futureInventories.remove(matched);

                    // Setup the remembered inventory
                    getCurrentContainer().setup(matched.pos, packet.getWindowId(), packet.getSlotCount());
                });
            }

            if (p instanceof SPacketCloseWindow) {
                getCurrent().save();
            }
        }
    }

    @Override
    public void onBlockInteract(BlockInteractEvent event) {
        if (event.getType() == BlockInteractEvent.Type.USE) {
            BetterBlockPos pos = BetterBlockPos.from(event.getPos());
            IBlockState state = BlockStateInterface.get(ctx, pos);
            if (state.getBlock() instanceof BlockBed) {
                if (state.getValue(BlockBed.PART) == BlockBed.EnumPartType.FOOT) {
                    pos = pos.offset(state.getValue(BlockBed.FACING));
                }
                Set<IWaypoint> waypoints = baritone.getWorldProvider().getCurrentWorld().getWaypoints().getByTag(IWaypoint.Tag.BED);
                boolean exists = waypoints.stream().map(IWaypoint::getLocation).filter(pos::equals).findFirst().isPresent();
                if (!exists) {
                    baritone.getWorldProvider().getCurrentWorld().getWaypoints().addWaypoint(new Waypoint(""bed"", Waypoint.Tag.BED, pos));
                }
            }
        }
    }

    @Override
    public void onPlayerDeath() {
        Waypoint deathWaypoint = new Waypoint(""death"", Waypoint.Tag.DEATH, ctx.playerFeet());
        baritone.getWorldProvider().getCurrentWorld().getWaypoints().addWaypoint(deathWaypoint);
        ITextComponent component = new TextComponentString(""Death position saved."");
        component.getStyle()
                .setColor(TextFormatting.WHITE)
                .setHoverEvent(new HoverEvent(
                        HoverEvent.Action.SHOW_TEXT,
                        new TextComponentString(""Click to goto death"")
                ))
                .setClickEvent(new ClickEvent(
                        ClickEvent.Action.RUN_COMMAND,
                        String.format(
                                ""%s%s goto %s @ %d"",
                                FORCE_COMMAND_PREFIX,
                                ""wp"",
                                deathWaypoint.getTag().getName(),
                                deathWaypoint.getCreationTimestamp()
                        )
                ));
        Helper.HELPER.logDirect(component);
    }


    private void updateInventory() {
        if (!Baritone.settings().containerMemory.value) {
            return;
        }
        int windowId = ctx.player().openContainer.windowId;
        if (enderChestWindowId != null) {
            if (windowId == enderChestWindowId) {
                getCurrent().contents = ctx.player().openContainer.getInventory().subList(0, 27);
            } else {
                getCurrent().save();
                enderChestWindowId = null;
            }
        }
        if (getCurrentContainer() != null) {
            getCurrentContainer().getInventoryFromWindow(windowId).ifPresent(inventory -> inventory.updateFromOpenWindow(ctx));
        }
    }

    private ContainerMemory getCurrentContainer() {
        if (baritone.getWorldProvider().getCurrentWorld() == null) {
            return null;
        }
        return (ContainerMemory) baritone.getWorldProvider().getCurrentWorld().getContainerMemory();
    }

    private BlockPos neighboringConnectedBlock(BlockPos in) {
        BlockStateInterface bsi = baritone.bsi;
        Block block = bsi.get0(in).getBlock();
        if (block != Blocks.TRAPPED_CHEST && block != Blocks.CHEST) {
            return null; // other things that have contents, but can be placed adjacent without combining
        }
        for (int i = 0; i < 4; i++) {
            BlockPos adj = in.offset(EnumFacing.byHorizontalIndex(i));
            if (bsi.get0(adj).getBlock() == block) {
                return adj;
            }
        }
        return null;
    }

    /**
     * An inventory that we are not yet fully aware of, but are expecting to exist at some point in the future.
     */
    private static final class FutureInventory {

        /**
         * The time that we initially expected the inventory to be provided, in milliseconds
         */
        private final long time;

        /**
         * The amount of slots in the inventory
         */
        private final int slots;

        /**
         * The type of inventory
         */
        private final String type;

        /**
         * The position of the inventory container
         */
        private final BlockPos pos;

        private FutureInventory(long time, int slots, String type, BlockPos pos) {
            this.time = time;
            this.slots = slots;
            this.type = type;
            this.pos = pos;
            // betterblockpos has censoring
            System.out.println(""Future inventory created "" + time + "" "" + slots + "" "" + type + "" "" + BetterBlockPos.from(pos));
        }
    }

    public Optional<List<ItemStack>> echest() {
        return Optional.ofNullable(getCurrent().contents).map(Collections::unmodifiableList);
    }

    public EnderChestMemory getCurrent() {
        Path path = baritone.getWorldProvider().getCurrentWorld().directory;
        return EnderChestMemory.getByServerAndPlayer(path.getParent(), ctx.player().getUniqueID());
    }

    public static class EnderChestMemory {

        private static final Map<Path, EnderChestMemory> memory = new HashMap<>();
        private final Path enderChest;
        private List<ItemStack> contents;

        private EnderChestMemory(Path enderChest) {
            this.enderChest = enderChest;
            System.out.println(""Echest storing in "" + enderChest);
            try {
                this.contents = ContainerMemory.readItemStacks(Files.readAllBytes(enderChest));
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println(""CANNOT read echest =( =("");
                this.contents = null;
            }
        }

        public synchronized void save() {
            System.out.println(""Saving"");
            if (contents != null) {
                try {
                    enderChest.getParent().toFile().mkdir();
                    Files.write(enderChest, ContainerMemory.writeItemStacks(contents));
                } catch (IOException e) {
                    e.printStackTrace();
                    System.out.println(""CANNOT save echest =( =("");
                }
            }
        }

        private static synchronized EnderChestMemory getByServerAndPlayer(Path serverStorage, UUID player) {
            return memory.computeIfAbsent(serverStorage.resolve(""echests"").resolve(player.toString()), EnderChestMemory::new);
        }
    }
}",1,439 381 334 2000 378 2001 123 437 381 2002 60 2003 62 2004 61 418 2005 60 62 40 41 59 621 437 2006 2007 59 621 439 2000 40 2008 2009 41 123 463 40 2009 41 59 125 64 2010 439 465 492 2011 40 2012 373 41 123 392 40 33 2008 46 2013 40 41 46 2014 46 2015 41 123 450 59 125 392 40 373 46 2016 40 41 614 2012 46 2017 46 2018 41 123 2007 61 424 59 2004 46 2019 40 41 59 125 125 64 2010 439 465 492 2020 40 2021 373 41 123 392 40 373 46 2022 40 41 614 2023 46 2024 41 123 2025 40 41 59 125 125 64 2010 439 465 492 2026 40 2027 373 41 123 392 40 33 2008 46 2028 40 41 46 2029 46 2030 41 123 450 59 125 2031 2032 61 373 46 2033 40 41 59 392 40 373 46 2034 40 41 614 2035 46 2036 41 123 392 40 2032 402 2037 41 123 2037 2038 61 373 46 2039 40 41 59 2040 2041 61 2042 46 2043 40 41 46 2044 40 2038 46 2045 40 41 41 59 621 621 392 40 2041 402 2046 41 123 2046 2047 61 40 2046 41 2041 59 404 2048 61 2047 46 2049 40 41 59 2050 2051 61 2050 46 388 40 2041 46 2045 40 41 41 59 2050 2052 61 2050 46 388 40 2053 40 2051 41 41 59 2054 46 430 46 2055 40 2051 43 648 43 2052 41 59 392 40 2052 631 424 41 123 2048 649 1502 59 621 392 40 2052 46 2056 40 41 60 2051 46 2056 40 41 606 2052 46 2057 40 41 60 2051 46 2057 40 41 41 123 2051 61 2052 59 621 125 125 467 46 2004 46 2058 40 418 2003 40 2054 46 2059 40 41 47 1507 44 2048 44 2047 46 2060 40 41 44 2051 41 41 59 125 125 392 40 2032 402 2061 41 123 2062 40 41 46 2063 40 41 59 125 125 125 64 2010 439 465 492 2064 40 2027 373 41 123 392 40 33 2008 46 2065 40 41 46 2066 46 2067 41 123 450 59 125 2068 2069 61 373 46 2070 40 41 59 392 40 373 46 2071 40 41 614 2072 46 2073 41 123 392 40 2069 402 2074 41 123 2074 2075 61 373 46 2076 40 41 59 621 2004 46 2077 40 2078 45 62 2079 46 2080 40 41 47 1507 45 2078 46 2081 62 1504 41 59 2079 46 430 46 2082 40 648 43 2075 46 2083 40 41 43 648 43 2075 46 2084 40 41 43 648 43 2075 46 2085 40 41 43 648 43 2075 46 2086 40 41 41 59 2079 46 430 46 2082 40 2075 46 2087 40 41 41 59 392 40 2075 46 2087 40 41 402 2088 605 40 40 2088 41 2075 46 2087 40 41 41 46 2089 40 41 46 2090 40 648 41 41 123 621 2007 61 2075 46 2086 40 41 59 450 59 125 2004 46 2091 40 41 46 2092 40 2078 45 62 2078 46 2093 46 2090 40 2075 46 2083 40 41 41 605 2078 46 2094 614 2075 46 2085 40 41 41 46 2095 40 41 46 2096 40 2097 45 62 123 621 2004 46 2098 40 2097 41 59 621 2099 40 41 46 2100 40 2097 46 2101 44 2075 46 2086 40 41 44 2075 46 2085 40 41 41 59 125 41 59 125 392 40 2069 402 2102 41 123 2103 40 41 46 2104 40 41 59 125 125 125 64 2010 439 492 2105 40 2106 373 41 123 392 40 373 46 2107 40 41 614 2106 46 2108 46 2109 41 123 2110 2111 61 2110 46 388 40 373 46 2112 40 41 41 59 2113 2114 61 2115 46 2116 40 2117 44 2111 41 59 392 40 2114 46 2118 40 41 402 2119 41 123 392 40 2114 46 2120 40 2119 46 2121 41 614 2119 46 2122 46 2123 41 123 2111 61 2111 46 2124 40 2114 46 2120 40 2119 46 2125 41 41 59 125 2126 60 2127 62 2128 61 2009 46 2129 40 41 46 2130 40 41 46 2131 40 41 46 2132 40 2127 46 2133 46 2134 41 59 324 2135 61 2128 46 2136 40 41 46 2137 40 2127 58 58 2138 41 46 2139 40 2111 58 58 2140 41 46 2141 40 41 46 2142 40 41 59 392 40 33 2135 41 123 2009 46 2129 40 41 46 2130 40 41 46 2131 40 41 46 2143 40 418 2144 40 648 44 2144 46 2133 46 2134 44 2111 41 41 59 125 125 125 125 64 2010 439 492 2145 40 41 123 2146 2147 61 418 2146 40 648 44 2146 46 2148 46 2149 44 2150 46 2151 40 41 41 59 2009 46 2152 40 41 46 2153 40 41 46 2154 40 41 46 2155 40 2147 41 59 2156 2157 61 418 2158 40 648 41 59 2157 46 2159 40 41 46 2160 40 2161 46 2162 41 46 2163 40 418 2164 40 2164 46 2165 46 2166 44 418 2158 40 648 41 41 41 46 2167 40 418 2168 40 2168 46 2165 46 2169 44 2170 46 2171 40 648 44 2172 44 648 44 2147 46 2173 40 41 46 2174 40 41 44 2147 46 2175 40 41 41 41 41 59 2176 46 2177 46 2178 40 2157 41 59 125 437 492 2179 40 41 123 392 40 33 2008 46 2180 40 41 46 2181 46 2182 41 123 450 59 125 404 2183 61 2184 46 2185 40 41 46 2186 46 2183 59 392 40 2007 631 424 41 123 392 40 2183 614 2007 41 123 2187 40 41 46 2188 61 2184 46 2185 40 41 46 2186 46 2189 40 41 46 2190 40 1500 44 1503 41 59 125 360 123 2191 40 41 46 2192 40 41 59 2007 61 424 59 125 125 392 40 2193 40 41 631 424 41 123 2193 40 41 46 2194 40 2183 41 46 2195 40 2196 45 62 2196 46 2197 40 2184 41 41 59 125 125 437 2198 2199 40 41 123 392 40 2009 46 2200 40 41 46 2201 40 41 614 424 41 123 450 424 59 125 450 40 2198 41 2009 46 2200 40 41 46 2201 40 41 46 2202 40 41 59 125 437 2203 2204 40 2203 398 41 123 2205 2206 61 2009 46 2206 59 2207 2208 61 2206 46 2209 40 398 41 46 2210 40 41 59 392 40 2208 631 2211 46 2212 605 2208 631 2211 46 2213 41 123 450 424 59 621 125 385 40 404 2214 61 1500 59 2214 60 1502 59 2214 637 41 123 2203 2215 61 398 46 2216 40 2217 46 2218 40 2214 41 41 59 392 40 2206 46 2209 40 2215 41 46 2210 40 41 614 2208 41 123 450 2215 59 125 125 450 424 59 125 618 437 457 381 334 2003 123 618 437 381 413 2219 59 618 437 381 404 2220 59 618 437 381 2221 2222 59 618 437 381 2203 2223 59 437 2003 40 413 2219 44 404 2220 44 2221 2222 44 2203 2223 41 123 467 46 2219 61 2219 59 467 46 2220 61 2220 59 467 46 2222 61 2222 59 467 46 2223 61 2223 59 621 2224 46 430 46 2225 40 648 43 2219 43 648 43 2220 43 648 43 2222 43 648 43 2226 46 388 40 2223 41 41 59 125 125 439 2227 60 2002 60 2228 641 2229 40 41 123 450 2227 46 2230 40 2231 40 41 46 2232 41 46 2233 40 2234 58 58 2235 41 59 125 439 2236 2237 40 41 123 2238 2239 61 2009 46 2240 40 41 46 2241 40 41 46 2242 59 450 2236 46 2243 40 2239 46 2244 40 41 44 2245 46 2246 40 41 46 2247 40 41 41 59 125 439 457 334 2236 123 437 457 381 2248 60 2249 44 2236 62 2250 61 418 2251 60 62 40 41 59 437 381 2249 2252 59 437 2002 60 2228 62 2253 59 437 2236 40 2249 2252 41 123 467 46 2252 61 2252 59 2254 46 430 46 2255 40 648 43 2252 41 59 474 123 467 46 2253 61 2198 46 2256 40 2257 46 2258 40 2252 41 41 59 125 329 40 2259 2260 41 123 2260 46 2261 40 41 59 2254 46 430 46 2255 40 648 41 59 467 46 2253 61 424 59 125 125 439 465 492 2262 40 41 123 2263 46 430 46 2264 40 648 41 59 392 40 2253 631 424 41 123 474 123 2252 46 2265 40 41 46 2266 40 41 46 2267 40 41 59 2268 46 2269 40 2252 44 2198 46 2270 40 2253 41 41 59 125 329 40 2271 2272 41 123 2272 46 2273 40 41 59 2263 46 430 46 2264 40 648 41 59 125 125 125 437 457 465 2236 2274 40 2249 2275 44 2276 2277 41 123 450 2250 46 2278 40 2275 46 2279 40 648 41 46 2279 40 2277 46 2280 40 41 41 44 2236 58 58 418 41 59 125 125 125 
5244,Java,"@FxmlView
public class PendingTradesView extends ActivatableViewAndModel<VBox, PendingTradesViewModel> {
    public interface ChatCallback {
        void onOpenChat(Trade trade);
    }

    private final TradeDetailsWindow tradeDetailsWindow;
    private final Navigation navigation;
    private final KeyRing keyRing;
    private final CoinFormatter formatter;
    private final PrivateNotificationManager privateNotificationManager;
    private final boolean useDevPrivilegeKeys;
    private final boolean useDevModeHeader;
    private final Preferences preferences;
    @FXML
    TableView<PendingTradesListItem> tableView;
    @FXML
    TableColumn<PendingTradesListItem, PendingTradesListItem> priceColumn, volumeColumn, amountColumn, avatarColumn,
            marketColumn, roleColumn, paymentMethodColumn, tradeIdColumn, dateColumn, chatColumn, moveTradeToFailedColumn;
    private SortedList<PendingTradesListItem> sortedList;
    private TradeSubView selectedSubView;
    private EventHandler<KeyEvent> keyEventEventHandler;
    private Scene scene;
    private Subscription selectedTableItemSubscription;
    private Subscription selectedItemSubscription;
    private Stage chatPopupStage;
    private ListChangeListener<PendingTradesListItem> tradesListChangeListener;
    private final Map<String, Long> newChatMessagesByTradeMap = new HashMap<>();
    private String tradeIdOfOpenChat;
    private double chatPopupStageXPosition = -1;
    private double chatPopupStageYPosition = -1;
    private ChangeListener<Number> xPositionListener;
    private ChangeListener<Number> yPositionListener;

    private final Map<String, Button> buttonByTrade = new HashMap<>();
    private final Map<String, JFXBadge> badgeByTrade = new HashMap<>();
    private final Map<String, ListChangeListener<ChatMessage>> listenerByTrade = new HashMap<>();
    private ChangeListener<Trade.DisputeState> disputeStateListener;
    private ChangeListener<MediationResultState> mediationResultStateListener;
    private ChangeListener<Number> getMempoolStatusListener;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, Initialisation
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public PendingTradesView(PendingTradesViewModel model,
                             TradeDetailsWindow tradeDetailsWindow,
                             Navigation navigation,
                             KeyRing keyRing,
                             @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter formatter,
                             PrivateNotificationManager privateNotificationManager,
                             Preferences preferences,
                             @Named(Config.USE_DEV_PRIVILEGE_KEYS) boolean useDevPrivilegeKeys,
                             @Named(Config.USE_DEV_MODE_HEADER) boolean useDevModeHeader) {
        super(model);
        this.tradeDetailsWindow = tradeDetailsWindow;
        this.navigation = navigation;
        this.keyRing = keyRing;
        this.formatter = formatter;
        this.privateNotificationManager = privateNotificationManager;
        this.preferences = preferences;
        this.useDevPrivilegeKeys = useDevPrivilegeKeys;
        this.useDevModeHeader = useDevModeHeader;
    }

    @Override
    public void initialize() {
        priceColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.price"")));
        amountColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.amountWithCur"", Res.getBaseCurrencyCode())));
        volumeColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.amount"")));
        marketColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.market"")));
        roleColumn.setGraphic(new AutoTooltipLabel(Res.get(""portfolio.pending.role"")));
        dateColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.dateTime"")));
        tradeIdColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.tradeId"")));
        paymentMethodColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.paymentMethod"")));
        avatarColumn.setText("""");
        chatColumn.setText("""");
        moveTradeToFailedColumn.setText("""");

        setTradeIdColumnCellFactory();
        setDateColumnCellFactory();
        setAmountColumnCellFactory();
        setPriceColumnCellFactory();
        setVolumeColumnCellFactory();
        setPaymentMethodColumnCellFactory();
        setMarketColumnCellFactory();
        setRoleColumnCellFactory();
        setAvatarColumnCellFactory();
        setChatColumnCellFactory();
        setRemoveTradeColumnCellFactory();

        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        tableView.setPlaceholder(new AutoTooltipLabel(Res.get(""table.placeholder.noItems"", Res.get(""shared.openTrades""))));
        tableView.setMinHeight(100);

        tradeIdColumn.setComparator(Comparator.comparing(o -> o.getTrade().getId()));
        dateColumn.setComparator(Comparator.comparing(o -> o.getTrade().getDate()));
        volumeColumn.setComparator(Comparator.comparing(o -> o.getTrade().getVolume(), Comparator.nullsFirst(Comparator.naturalOrder())));
        amountColumn.setComparator(Comparator.comparing(o -> o.getTrade().getAmount(), Comparator.nullsFirst(Comparator.naturalOrder())));
        priceColumn.setComparator(Comparator.comparing(item -> FormattingUtils.formatPrice(item.getPrice())));
        paymentMethodColumn.setComparator(Comparator.comparing(
                item -> item.getTrade().getOffer() != null ?
                        Res.get(item.getTrade().getOffer().getPaymentMethod().getId()) :
                        null,
                Comparator.nullsFirst(Comparator.naturalOrder())));

        marketColumn.setComparator(Comparator.comparing(model::getMarketLabel));
        roleColumn.setComparator(Comparator.comparing(model::getMyRole));
        avatarColumn.setComparator(Comparator.comparing(
                o -> model.getNumPastTrades(o.getTrade()),
                Comparator.nullsFirst(Comparator.naturalOrder())
        ));
        dateColumn.setSortType(TableColumn.SortType.DESCENDING);
        tableView.getSortOrder().add(dateColumn);

        tableView.setRowFactory(
                tableView -> {
                    final TableRow<PendingTradesListItem> row = new TableRow<>();
                    final ContextMenu rowMenu = new ContextMenu();
                    MenuItem duplicateItem = new MenuItem(Res.get(""portfolio.context.offerLikeThis""));
                    duplicateItem.setOnAction((event) -> {
                        try {
                            OfferPayload offerPayload = row.getItem().getTrade().getOffer().getOfferPayload().orElseThrow();
                            if (offerPayload.getPubKeyRing().equals(keyRing.getPubKeyRing())) {
                                PortfolioUtil.duplicateOffer(navigation, offerPayload);
                            } else {
                                new Popup().warning(Res.get(""portfolio.context.notYourOffer"")).show();
                            }
                        } catch (NullPointerException e) {
                            log.warn(""Unable to get offerPayload - {}"", e.toString());
                        }
                    });
                    rowMenu.getItems().add(duplicateItem);
                    row.contextMenuProperty().bind(
                            Bindings.when(Bindings.isNotNull(row.itemProperty()))
                                    .then(rowMenu)
                                    .otherwise((ContextMenu) null));
                    return row;
                });

        // we use a hidden emergency shortcut to open support ticket
        keyEventEventHandler = keyEvent -> {
            if (Utilities.isAltOrCtrlPressed(KeyCode.O, keyEvent)) {
                Popup popup = new Popup();
                popup.headLine(Res.get(""portfolio.pending.openSupportTicket.headline""))
                        .message(Res.get(""portfolio.pending.openSupportTicket.msg""))
                        .actionButtonText(Res.get(""portfolio.pending.openSupportTicket.headline""))
                        .onAction(model.dataModel::onOpenSupportTicket)
                        .closeButtonText(Res.get(""shared.cancel""))
                        .onClose(popup::hide)
                        .show();
            }
        };

        tradesListChangeListener = c -> onListChanged();

        getMempoolStatusListener = (observable, oldValue, newValue) -> {
            // -1 status is unknown
            // 0 status is FAIL
            // 1 status is PASS
            if (newValue.longValue() >= 0) {
                log.info(""Taker fee validation returned {}"", newValue.longValue());
            }
        };
    }

    @Override
    protected void activate() {
        ObservableList<PendingTradesListItem> list = model.dataModel.list;
        sortedList = new SortedList<>(list);
        sortedList.comparatorProperty().bind(tableView.comparatorProperty());
        tableView.setItems(sortedList);

        updateMoveTradeToFailedColumnState();

        scene = root.getScene();
        if (scene != null) {
            scene.addEventHandler(KeyEvent.KEY_RELEASED, keyEventEventHandler);
        }

        selectedItemSubscription = EasyBind.subscribe(model.dataModel.selectedItemProperty, selectedItem -> {
            if (selectedItem != null) {
                if (selectedSubView != null)
                    selectedSubView.deactivate();

                if (selectedItem.getTrade() != null) {
                    selectedSubView = model.dataModel.tradeManager.isBuyer(model.dataModel.getOffer()) ?
                            new BuyerSubView(model) : new SellerSubView(model);

                    selectedSubView.setMinHeight(440);
                    VBox.setVgrow(selectedSubView, Priority.ALWAYS);
                    if (root.getChildren().size() == 1)
                        root.getChildren().add(selectedSubView);
                    else if (root.getChildren().size() == 2)
                        root.getChildren().set(1, selectedSubView);

                    // create and register a callback so we can be notified when the subview
                    // wants to open the chat window
                    ChatCallback chatCallback = this::openChat;
                    selectedSubView.setChatCallback(chatCallback);
                }

                updateTableSelection();
            } else {
                removeSelectedSubView();
            }

            model.onSelectedItemChanged(selectedItem);

            if (selectedSubView != null && selectedItem != null)
                selectedSubView.activate();
        });

        selectedTableItemSubscription = EasyBind.subscribe(tableView.getSelectionModel().selectedItemProperty(),
                selectedItem -> {
                    if (selectedItem != null && !selectedItem.equals(model.dataModel.selectedItemProperty.get()))
                        model.dataModel.onSelectItem(selectedItem);
                });

        updateTableSelection();

        list.addListener(tradesListChangeListener);
        updateNewChatMessagesByTradeMap();
        model.getMempoolStatus().addListener(getMempoolStatusListener);
    }

    @Override
    protected void deactivate() {
        sortedList.comparatorProperty().unbind();
        selectedItemSubscription.unsubscribe();
        selectedTableItemSubscription.unsubscribe();

        removeSelectedSubView();

        model.dataModel.list.removeListener(tradesListChangeListener);
        model.getMempoolStatus().removeListener(getMempoolStatusListener);

        if (scene != null)
            scene.removeEventHandler(KeyEvent.KEY_RELEASED, keyEventEventHandler);
    }

    private void removeSelectedSubView() {
        if (selectedSubView != null) {
            selectedSubView.deactivate();
            root.getChildren().remove(selectedSubView);
            selectedSubView = null;
        }
    }

    private void updateMoveTradeToFailedColumnState() {
        moveTradeToFailedColumn.setVisible(model.dataModel.list.stream().anyMatch(item -> isMaybeInvalidTrade(item.getTrade())));
    }

    private boolean isMaybeInvalidTrade(Trade trade) {
        return trade.hasErrorMessage() ||
                (Trade.Phase.DEPOSIT_PUBLISHED.ordinal() <= trade.getTradePhase().ordinal() && trade.isTxChainInvalid());
    }

    private void onMoveInvalidTradeToFailedTrades(Trade trade) {
        String msg = trade.isTxChainInvalid() ?
                Res.get(""portfolio.pending.failedTrade.txChainInvalid.moveToFailed"",
                        getInvalidTradeDetails(trade)) :
                Res.get(""portfolio.pending.failedTrade.txChainValid.moveToFailed"",
                        getInvalidTradeDetails(trade));
        new Popup().width(900).attention(msg)
                .onAction(() -> {
                    model.dataModel.onMoveInvalidTradeToFailedTrades(trade);
                    updateMoveTradeToFailedColumnState();
                })
                .actionButtonText(Res.get(""shared.yes""))
                .closeButtonText(Res.get(""shared.no""))
                .show();
    }

    private void onShowInfoForInvalidTrade(Trade trade) {
        new Popup().width(900).attention(Res.get(""portfolio.pending.failedTrade.info.popup"",
                getInvalidTradeDetails(trade)))
                .show();
    }

    private String getInvalidTradeDetails(Trade trade) {
        Contract contract = trade.getContract();
        if (contract == null) {
            return Res.get(""portfolio.pending.failedTrade.missingContract"");
        }

        PubKeyRing myPubKeyRing = model.dataModel.getPubKeyRing();
        boolean isMyRoleBuyer = contract.isMyRoleBuyer(myPubKeyRing);
        boolean isMyRoleMaker = contract.isMyRoleMaker(myPubKeyRing);

        if (trade.getTakerFeeTxId() == null) {
            return isMyRoleMaker ?
                    Res.get(""portfolio.pending.failedTrade.maker.missingTakerFeeTx"") :
                    Res.get(""portfolio.pending.failedTrade.taker.missingTakerFeeTx"");
        }

        if (trade.getDepositTx() == null) {
            return Res.get(""portfolio.pending.failedTrade.missingDepositTx"");
        }

        if (trade.getDelayedPayoutTx() == null) {
            return isMyRoleBuyer ?
                    Res.get(""portfolio.pending.failedTrade.buyer.existingDepositTxButMissingDelayedPayoutTx"") :
                    Res.get(""portfolio.pending.failedTrade.seller.existingDepositTxButMissingDelayedPayoutTx"");
        }

        if (trade.hasErrorMessage()) {
            return Res.get(""portfolio.pending.failedTrade.errorMsgSet"", trade.getErrorMessage());
        }

        return Res.get(""shared.na"");
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Chat
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void updateNewChatMessagesByTradeMap() {
        model.dataModel.list.forEach(t -> {
            Trade trade = t.getTrade();
            newChatMessagesByTradeMap.put(trade.getId(),
                    trade.getChatMessages().stream()
                            .filter(m -> !m.isWasDisplayed())
                            .filter(m -> !m.isSystemMessage())
                            .count());
        });
    }

    private void openChat(Trade trade) {
        if (chatPopupStage != null)
            chatPopupStage.close();

        TraderChatManager traderChatManager = model.dataModel.getTraderChatManager();
        if (trade.getChatMessages().isEmpty()) {
            traderChatManager.addSystemMsg(trade);
        }

        trade.getChatMessages().forEach(m -> m.setWasDisplayed(true));
        model.dataModel.getTradeManager().requestPersistence();
        tradeIdOfOpenChat = trade.getId();

        ChatView chatView = new ChatView(traderChatManager, Res.get(""offerbook.trader""));
        chatView.setAllowAttachments(false);
        chatView.setDisplayHeader(false);
        chatView.initialize();

        AnchorPane pane = new AnchorPane(chatView);
        pane.setPrefSize(760, 500);
        AnchorPane.setLeftAnchor(chatView, 10d);
        AnchorPane.setRightAnchor(chatView, 10d);
        AnchorPane.setTopAnchor(chatView, -20d);
        AnchorPane.setBottomAnchor(chatView, 10d);

        boolean isTaker = !model.dataModel.isMaker(trade.getOffer());
        TradeChatSession tradeChatSession = new TradeChatSession(trade, isTaker);

        disputeStateListener = (observable, oldValue, newValue) -> {
            if (newValue == Trade.DisputeState.DISPUTE_CLOSED || newValue == Trade.DisputeState.REFUND_REQUEST_CLOSED) {
                chatPopupStage.hide();
            }
        };
        trade.disputeStateProperty().addListener(disputeStateListener);

        mediationResultStateListener = (observable, oldValue, newValue) -> {
            if (newValue == MediationResultState.PAYOUT_TX_PUBLISHED ||
                    newValue == MediationResultState.RECEIVED_PAYOUT_TX_PUBLISHED_MSG ||
                    newValue == MediationResultState.PAYOUT_TX_SEEN_IN_NETWORK) {
                chatPopupStage.hide();
            }
        };
        trade.mediationResultStateProperty().addListener(mediationResultStateListener);

        chatView.display(tradeChatSession, pane.widthProperty());

        chatView.activate();
        chatView.scrollToBottom();

        chatPopupStage = new Stage();
        chatPopupStage.setTitle(Res.get(""tradeChat.chatWindowTitle"", trade.getShortId()));
        StackPane owner = MainView.getRootContainer();
        Scene rootScene = owner.getScene();
        chatPopupStage.initOwner(rootScene.getWindow());
        chatPopupStage.initModality(Modality.NONE);
        chatPopupStage.initStyle(StageStyle.DECORATED);
        chatPopupStage.setOnHiding(event -> {
            chatView.deactivate();
            // at close we set all as displayed. While open we ignore updates of the numNewMsg in the list icon.
            trade.getChatMessages().forEach(m -> m.setWasDisplayed(true));
            model.dataModel.getTradeManager().requestPersistence();
            tradeIdOfOpenChat = null;

            if (xPositionListener != null) {
                chatPopupStage.xProperty().removeListener(xPositionListener);
            }
            if (yPositionListener != null) {
                chatPopupStage.xProperty().removeListener(yPositionListener);
            }

            trade.disputeStateProperty().addListener(disputeStateListener);
            trade.mediationResultStateProperty().addListener(mediationResultStateListener);
            traderChatManager.requestPersistence();
        });

        Scene scene = new Scene(pane);
        CssTheme.loadSceneStyles(scene, preferences.getCssTheme(), useDevModeHeader);
        scene.addEventHandler(KeyEvent.KEY_RELEASED, ev -> {
            if (ev.getCode() == KeyCode.ESCAPE) {
                ev.consume();
                chatPopupStage.hide();
            }
        });
        chatPopupStage.setScene(scene);

        chatPopupStage.setOpacity(0);
        chatPopupStage.show();

        xPositionListener = (observable, oldValue, newValue) -> chatPopupStageXPosition = (double) newValue;
        chatPopupStage.xProperty().addListener(xPositionListener);
        yPositionListener = (observable, oldValue, newValue) -> chatPopupStageYPosition = (double) newValue;
        chatPopupStage.yProperty().addListener(yPositionListener);

        if (chatPopupStageXPosition == -1) {
            Window rootSceneWindow = rootScene.getWindow();
            double titleBarHeight = rootSceneWindow.getHeight() - rootScene.getHeight();
            chatPopupStage.setX(Math.round(rootSceneWindow.getX() + (owner.getWidth() - chatPopupStage.getWidth() / 4 * 3)));
            chatPopupStage.setY(Math.round(rootSceneWindow.getY() + titleBarHeight + (owner.getHeight() - chatPopupStage.getHeight() / 4 * 3)));
        } else {
            chatPopupStage.setX(chatPopupStageXPosition);
            chatPopupStage.setY(chatPopupStageYPosition);
        }

        // Delay display to next render frame to avoid that the popup is first quickly displayed in default position
        // and after a short moment in the correct position
        UserThread.execute(() -> chatPopupStage.setOpacity(1));
        updateChatMessageCount(trade, badgeByTrade.get(trade.getId()));
    }

    private void updateChatMessageCount(Trade trade, JFXBadge badge) {
        if (!trade.getId().equals(tradeIdOfOpenChat)) {
            updateNewChatMessagesByTradeMap();
            long num = newChatMessagesByTradeMap.get(trade.getId());
            if (num > 0) {
                badge.setText(String.valueOf(num));
                badge.setEnabled(true);
            } else {
                badge.setText("""");
                badge.setEnabled(false);
            }
        } else {
            badge.setText("""");
            badge.setEnabled(false);
        }
        badge.refreshBadge();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void updateTableSelection() {
        PendingTradesListItem selectedItemFromModel = model.dataModel.selectedItemProperty.get();
        if (selectedItemFromModel != null) {
            // Select and focus selectedItem from model
            int index = tableView.getItems().indexOf(selectedItemFromModel);
            UserThread.execute(() -> tableView.getSelectionModel().select(index));
        }
    }

    private void onListChanged() {
        updateNewChatMessagesByTradeMap();
        updateMoveTradeToFailedColumnState();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // CellFactories
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void setTradeIdColumnCellFactory() {
        tradeIdColumn.getStyleClass().add(""first-column"");
        tradeIdColumn.setCellValueFactory((pendingTradesListItem) -> new ReadOnlyObjectWrapper<>(pendingTradesListItem.getValue()));
        tradeIdColumn.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem,
                            PendingTradesListItem> column) {
                        return new TableCell<>() {
                            private Trade trade;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    trade = item.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    setGraphic(null);
                                    if (trade != null && listener != null) {
                                        trade.stateProperty().removeListener(listener);
                                        trade = null;
                                        listener = null;
                                    }
                                }
                            }

                            private void update() {
                                HyperlinkWithIcon field;
                                if (trade == null) return;

                                if (isMaybeInvalidTrade(trade)) {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setIcon(FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE));
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.invalidTradeState.warning"")));
                                    if (trade.isTxChainInvalid()) {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }
                                } else {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                }
                                setGraphic(field);
                            }
                        };
                    }
                });
    }

    private void setDateColumnCellFactory() {
        dateColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        dateColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(DisplayUtils.formatDateTime(item.getTrade().getDate())));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
    }

    private void setAmountColumnCellFactory() {
        amountColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        amountColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(formatter.formatCoin(item.getTrade().getAmount())));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setPriceColumnCellFactory() {
        priceColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        priceColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(FormattingUtils.formatPrice(item.getPrice())));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setVolumeColumnCellFactory() {
        volumeColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        volumeColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    try {
                                        String volume = VolumeUtil.formatVolumeWithCode(item.getTrade().getVolume());
                                        setGraphic(new AutoTooltipLabel(volume));
                                    } catch (Throwable ignore) {
                                        log.debug(ignore.toString()); // Stupidity to make Codacy happy
                                    }
                                } else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setPaymentMethodColumnCellFactory() {
        paymentMethodColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        paymentMethodColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getPaymentMethod(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setMarketColumnCellFactory() {
        marketColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        marketColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                            }
                        };
                    }
                });
    }

    private void setRoleColumnCellFactory() {
        roleColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        roleColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getMyRole(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    @SuppressWarnings(""UnusedReturnValue"")
    private TableColumn<PendingTradesListItem, PendingTradesListItem> setAvatarColumnCellFactory() {
        avatarColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        avatarColumn.getStyleClass().addAll(""last-column"", ""avatar-column"");
        avatarColumn.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    final Trade trade = newItem.getTrade();
                                    final NodeAddress tradingPeerNodeAddress = trade.getTradingPeerNodeAddress();
                                    int numPastTrades = model.getNumPastTrades(trade);
                                    String role = Res.get(""peerInfoIcon.tooltip.tradePeer"");
                                    Node peerInfoIcon = new PeerInfoIconTrading(tradingPeerNodeAddress,
                                            role,
                                            numPastTrades,
                                            privateNotificationManager,
                                            trade,
                                            preferences,
                                            model.accountAgeWitnessService,
                                            useDevPrivilegeKeys);
                                    setPadding(new Insets(1, 0, 0, 0));
                                    setGraphic(peerInfoIcon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
        return avatarColumn;
    }

    @SuppressWarnings(""UnusedReturnValue"")
    private TableColumn<PendingTradesListItem, PendingTradesListItem> setChatColumnCellFactory() {
        chatColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        chatColumn.getStyleClass().addAll(""last-column"", ""avatar-column"");
        chatColumn.setSortable(false);
        chatColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);

                                if (!empty && newItem != null) {
                                    Trade trade = newItem.getTrade();
                                    String id = trade.getId();

                                    // We use maps for each trade to avoid multiple listener registrations when
                                    // switching views. With current implementation we avoid that but we do not
                                    // remove listeners when a trade is removed (completed) but that has no consequences
                                    // as we will not receive any message anyway from a closed trade. Supporting it
                                    // more correctly would require more effort and managing listener deactivation at
                                    // screen switches (currently we get the update called if we have selected another
                                    // view.
                                    Button button;
                                    if (!buttonByTrade.containsKey(id)) {
                                        button = FormBuilder.getIconButton(MaterialDesignIcon.COMMENT_MULTIPLE_OUTLINE);
                                        buttonByTrade.put(id, button);
                                        button.setTooltip(new Tooltip(Res.get(""tradeChat.openChat"")));
                                    } else {
                                        button = buttonByTrade.get(id);
                                    }

                                    JFXBadge badge;
                                    if (!badgeByTrade.containsKey(id)) {
                                        badge = new JFXBadge(button);
                                        badgeByTrade.put(id, badge);
                                        badge.setPosition(Pos.TOP_RIGHT);
                                    } else {
                                        badge = badgeByTrade.get(id);
                                    }

                                    button.setOnAction(e -> {
                                        tableView.getSelectionModel().select(this.getIndex());
                                        openChat(trade);
                                    });

                                    if (!listenerByTrade.containsKey(id)) {
                                        ListChangeListener<ChatMessage> listener = c -> updateChatMessageCount(trade, badge);
                                        listenerByTrade.put(id, listener);
                                        trade.getChatMessages().addListener(listener);
                                    }

                                    updateChatMessageCount(trade, badge);

                                    setGraphic(badge);
                                } else {
                                    setGraphic(null);
                                }
                            }

                        };
                    }
                });
        return chatColumn;
    }

    private void setRemoveTradeColumnCellFactory() {
        moveTradeToFailedColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        moveTradeToFailedColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem,
                            PendingTradesListItem> column) {
                        return new TableCell<>() {
                            private Trade trade;
                            private JFXButton warnIconButton, trashIconButton;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    trade = newItem.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    cleanup();
                                }
                            }

                            private void update() {
                                if (isMaybeInvalidTrade(trade)) {
                                    Text warnIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE);
                                    Text trashIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ARROW_RIGHT_BOLD_BOX_OUTLINE);
                                    if (trade.isTxChainInvalid()) {
                                        trashIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        trashIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }

                                    warnIconButton = new JFXButton("""", warnIcon);
                                    warnIconButton.getStyleClass().add(""hidden-icon-button"");
                                    warnIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.warningIcon.tooltip"")));
                                    warnIconButton.setOnAction(e -> onShowInfoForInvalidTrade(trade));

                                    trashIconButton = new JFXButton("""", trashIcon);
                                    trashIconButton.getStyleClass().add(""hidden-icon-button"");
                                    trashIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.moveTradeToFailedIcon.tooltip"")));
                                    trashIconButton.setOnAction(e -> onMoveInvalidTradeToFailedTrades(trade));

                                    HBox hBox = new HBox();
                                    hBox.setSpacing(0);
                                    hBox.getChildren().addAll(warnIconButton, trashIconButton);
                                    setGraphic(hBox);
                                } else {
                                    cleanup();
                                }

                                updateMoveTradeToFailedColumnState();
                            }

                            private void cleanup() {
                                if (warnIconButton != null) {
                                    warnIconButton.setOnAction(null);
                                }
                                if (trashIconButton != null) {
                                    trashIconButton.setOnAction(null);
                                }
                                if (listener != null && trade != null) {
                                    trade.stateProperty().removeListener(listener);
                                }
                                setGraphic(null);
                            }
                        };
                    }
                });
    }
}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 123 439 405 2005 123 492 2006 40 2007 2008 41 59 125 437 381 2009 2010 59 437 381 2011 2012 59 437 381 2013 2014 59 437 381 2015 2016 59 437 381 2017 2018 59 437 381 324 2019 59 437 381 324 2020 59 437 381 2021 2022 59 64 2023 2024 60 2025 62 2026 59 64 2023 2027 60 2025 44 2025 62 2028 44 2029 44 2030 44 2031 44 2032 44 2033 44 2034 44 2035 44 2036 44 2037 44 2038 59 437 2039 60 2025 62 2040 59 437 2041 2042 59 437 2043 60 2044 62 2045 59 437 2046 2047 59 437 2048 2049 59 437 2048 2050 59 437 2051 2052 59 437 2053 60 2025 62 2054 59 437 381 2055 60 2056 44 2057 62 2058 61 418 2059 60 62 40 41 59 437 2056 2060 59 437 356 2061 61 45 1501 59 437 356 2062 61 45 1501 59 437 2063 60 2064 62 2065 59 437 2063 60 2064 62 2066 59 437 381 2055 60 2056 44 2067 62 2068 61 418 2059 60 62 40 41 59 437 381 2055 60 2056 44 2069 62 2070 61 418 2059 60 62 40 41 59 437 381 2055 60 2056 44 2053 60 2071 641 2072 61 418 2059 60 62 40 41 59 437 2063 60 2073 46 2074 62 2075 59 437 2063 60 2076 62 2077 59 437 2063 60 2064 62 2078 59 621 621 621 64 2079 439 2001 40 2004 2080 44 2009 2010 44 2011 2012 44 2013 2014 44 64 2081 40 2082 46 2083 41 2015 2016 44 2017 2018 44 2021 2022 44 64 2081 40 2084 46 2085 41 324 2019 44 64 2081 40 2084 46 2086 41 324 2020 41 123 463 40 2080 41 59 467 46 2010 61 2010 59 467 46 2012 61 2012 59 467 46 2014 61 2014 59 467 46 2016 61 2016 59 467 46 2018 61 2018 59 467 46 2022 61 2022 59 467 46 2019 61 2019 59 467 46 2020 61 2020 59 125 64 2087 439 492 2088 40 41 123 2028 46 2089 40 418 2090 40 2091 46 2092 40 648 41 41 41 59 2030 46 2089 40 418 2090 40 2091 46 2092 40 648 44 2091 46 2093 40 41 41 41 41 59 2029 46 2089 40 418 2090 40 2091 46 2092 40 648 41 41 41 59 2032 46 2089 40 418 2090 40 2091 46 2092 40 648 41 41 41 59 2033 46 2089 40 418 2090 40 2091 46 2092 40 648 41 41 41 59 2036 46 2089 40 418 2090 40 2091 46 2092 40 648 41 41 41 59 2035 46 2089 40 418 2090 40 2091 46 2092 40 648 41 41 41 59 2034 46 2089 40 418 2090 40 2091 46 2092 40 648 41 41 41 59 2031 46 2094 40 648 41 59 2037 46 2094 40 648 41 59 2038 46 2094 40 648 41 59 2095 40 41 59 2096 40 41 59 2097 40 41 59 2098 40 41 59 2099 40 41 59 2100 40 41 59 2101 40 41 59 2102 40 41 59 2103 40 41 59 2104 40 41 59 2105 40 41 59 2026 46 2106 40 2024 46 2107 41 59 2026 46 2108 40 418 2090 40 2091 46 2092 40 648 44 2091 46 2092 40 648 41 41 41 41 59 2026 46 2109 40 1503 41 59 2035 46 2110 40 2111 46 2112 40 2113 45 62 2113 46 2114 40 41 46 2115 40 41 41 41 59 2036 46 2110 40 2111 46 2112 40 2113 45 62 2113 46 2114 40 41 46 2116 40 41 41 41 59 2029 46 2110 40 2111 46 2112 40 2113 45 62 2113 46 2114 40 41 46 2117 40 41 44 2111 46 2118 40 2111 46 2119 40 41 41 41 41 59 2030 46 2110 40 2111 46 2112 40 2113 45 62 2113 46 2114 40 41 46 2120 40 41 44 2111 46 2118 40 2111 46 2119 40 41 41 41 41 59 2028 46 2110 40 2111 46 2112 40 2121 45 62 2082 46 2122 40 2121 46 2123 40 41 41 41 41 59 2034 46 2110 40 2111 46 2112 40 2121 45 62 2121 46 2114 40 41 46 2124 40 41 631 424 63 2091 46 2092 40 2121 46 2114 40 41 46 2124 40 41 46 2125 40 41 46 2115 40 41 41 58 424 44 2111 46 2118 40 2111 46 2119 40 41 41 41 41 59 2032 46 2110 40 2111 46 2112 40 2080 58 58 2126 41 41 59 2033 46 2110 40 2111 46 2112 40 2080 58 58 2127 41 41 59 2031 46 2110 40 2111 46 2112 40 2113 45 62 2080 46 2128 40 2113 46 2114 40 41 41 44 2111 46 2118 40 2111 46 2119 40 41 41 41 41 59 2036 46 2129 40 2027 46 2130 46 2131 41 59 2026 46 2132 40 41 46 2133 40 2036 41 59 2026 46 2134 40 2026 45 62 123 381 2135 60 2025 62 2136 61 418 2135 60 62 40 41 59 381 2137 2138 61 418 2137 40 41 59 2139 2140 61 418 2139 40 2091 46 2092 40 648 41 41 59 2140 46 2141 40 40 373 41 45 62 123 474 123 2142 2143 61 2136 46 2144 40 41 46 2114 40 41 46 2124 40 41 46 2145 40 41 46 2146 40 41 59 392 40 2143 46 2147 40 41 46 2148 40 2014 46 2147 40 41 41 41 123 2149 46 2150 40 2012 44 2143 41 59 125 360 123 418 2151 40 41 46 494 40 2091 46 2092 40 648 41 41 46 2152 40 41 59 125 125 329 40 2153 2154 41 123 2155 46 2156 40 648 44 2154 46 2157 40 41 41 59 125 125 41 59 2138 46 2158 40 41 46 2133 40 2140 41 59 2136 46 2159 40 41 46 2160 40 2161 46 2162 40 2161 46 2163 40 2136 46 2164 40 41 41 41 46 2165 40 2138 41 46 2166 40 40 2137 41 424 41 41 59 450 2136 59 125 41 59 621 2045 61 2167 45 62 123 392 40 2168 46 2169 40 2170 46 2171 44 2167 41 41 123 2172 2173 61 418 2172 40 41 59 2173 46 2174 40 2091 46 2092 40 648 41 41 46 2175 40 2091 46 2092 40 648 41 41 46 2176 40 2091 46 2092 40 648 41 41 46 2177 40 2080 46 2178 58 58 2179 41 46 2180 40 2091 46 2092 40 648 41 41 46 2181 40 2173 58 58 2182 41 46 2183 40 41 59 125 125 59 2054 61 2184 45 62 2185 40 41 59 2078 61 40 2186 44 2187 44 2188 41 45 62 123 621 621 621 392 40 2188 46 2189 40 41 615 1500 41 123 2190 46 2191 40 648 44 2188 46 2189 40 41 41 59 125 125 59 125 64 2087 438 492 2192 40 41 123 2193 60 2025 62 411 61 2080 46 2194 46 411 59 2040 61 418 2039 60 62 40 411 41 59 2040 46 2195 40 41 46 2196 40 2026 46 2195 40 41 41 59 2026 46 2197 40 2040 41 59 2198 40 41 59 2047 61 2199 46 2200 40 41 59 392 40 2047 631 424 41 123 2047 46 2201 40 2044 46 2202 44 2045 41 59 125 2050 61 2203 46 2204 40 2080 46 2194 46 2205 44 2206 45 62 123 392 40 2206 631 424 41 123 392 40 2042 631 424 41 2042 46 2207 40 41 59 392 40 2206 46 2208 40 41 631 424 41 123 2042 61 2080 46 2194 46 2209 46 2210 40 2080 46 2194 46 2211 40 41 41 63 418 2212 40 2080 41 58 418 2213 40 2080 41 59 2042 46 2214 40 1504 41 59 2003 46 2215 40 2042 44 2216 46 2217 41 59 392 40 2199 46 2218 40 41 46 2219 40 41 614 1501 41 2199 46 2218 40 41 46 2220 40 2042 41 59 360 392 40 2199 46 2218 40 41 46 2219 40 41 614 1502 41 2199 46 2218 40 41 46 2221 40 1501 44 2042 41 59 621 621 2005 2222 61 467 58 58 2223 59 2042 46 2224 40 2222 41 59 125 2225 40 41 59 125 360 123 2226 40 41 59 125 2080 46 2227 40 2206 41 59 392 40 2042 631 424 605 2206 631 424 41 2042 46 2192 40 41 59 125 41 59 2049 61 2203 46 2204 40 2026 46 2228 40 41 46 2205 40 41 44 2206 45 62 123 392 40 2206 631 424 605 33 2206 46 2229 40 2080 46 2194 46 2205 46 2230 40 41 41 41 2080 46 2194 46 2231 40 2206 41 59 125 41 59 2232 40 41 59 411 46 2233 40 2054 41 59 2234 40 41 59 2080 46 2235 40 41 46 2233 40 2078 41 59 125 64 2087 438 492 2236 40 41 123 2040 46 2237 40 41 46 2238 40 41 59 2050 46 2239 40 41 59 2049 46 2239 40 41 59 2240 40 41 59 2080 46 2241 46 411 46 2242 40 2054 41 59 2080 46 2243 40 41 46 2242 40 2078 41 59 392 40 2047 631 424 41 2047 46 2244 40 2044 46 2245 44 2045 41 59 125 437 492 2246 40 41 123 392 40 2042 631 424 41 123 2042 46 2236 40 41 59 2247 46 2248 40 41 46 2249 40 2042 41 59 2042 61 424 59 125 125 437 492 2250 40 41 123 2038 46 2251 40 2080 46 2252 46 411 46 2253 40 41 46 2254 40 2255 45 62 2256 40 2255 46 2257 40 41 41 41 41 59 125 437 324 2258 40 2073 2259 41 123 450 2259 46 2260 40 41 606 40 2073 46 2261 46 2262 46 2263 40 41 620 2259 46 2264 40 41 46 2263 40 41 605 2259 46 2265 40 41 41 59 125 437 492 2266 40 2073 2259 41 123 2056 2267 61 2259 46 2268 40 41 63 2269 46 2270 40 648 44 2271 40 2259 41 41 58 2269 46 2270 40 648 44 2271 40 2259 41 41 59 418 2272 40 41 46 2273 40 1504 41 46 2274 40 2267 41 46 2275 40 40 41 45 62 123 2080 46 2276 46 2266 40 2259 41 59 2250 40 41 59 125 41 46 2277 40 2269 46 2270 40 648 41 41 46 2278 40 2269 46 2270 40 648 41 41 46 2279 40 41 59 125 437 492 2280 40 2073 2259 41 123 418 2281 40 41 46 2282 40 1504 41 46 2283 40 2284 46 2285 40 648 44 2286 40 2259 41 41 41 46 2287 40 41 59 125 437 2056 2288 40 2073 2259 41 123 2289 2290 61 2259 46 2291 40 41 59 392 40 2290 614 424 41 123 450 2292 46 2293 40 648 41 59 125 2294 2295 61 2080 46 2296 46 2297 40 41 59 324 2298 61 2290 46 2298 40 2295 41 59 324 2299 61 2290 46 2299 40 2295 41 59 392 40 2259 46 2300 40 41 614 424 41 123 450 2299 63 2301 46 2302 40 648 41 58 2301 46 2302 40 648 41 59 125 392 40 2259 46 2303 40 41 614 424 41 123 450 2304 46 2305 40 648 41 59 125 392 40 2259 46 2306 40 41 614 424 41 123 450 2298 63 2307 46 2308 40 648 41 58 2307 46 2308 40 648 41 59 125 392 40 2259 46 2309 40 41 41 123 450 2310 46 2311 40 648 44 2259 46 2312 40 41 41 59 125 450 2313 46 2314 40 648 41 59 125 621 621 621 437 492 2315 40 41 123 2080 46 2316 46 411 46 2317 40 2318 45 62 123 2073 2259 61 2318 46 2319 40 41 59 2058 46 2320 40 2259 46 2321 40 41 44 2259 46 2322 40 41 46 2323 40 41 46 2324 40 2325 45 62 33 2325 46 2326 40 41 41 46 2324 40 2325 45 62 33 2325 46 2327 40 41 41 46 2328 40 41 41 59 125 41 59 125 437 492 2329 40 2073 2259 41 123 392 40 2052 631 424 41 2052 46 2330 40 41 59 2331 2332 61 2080 46 2333 46 2334 40 41 59 392 40 2259 46 2335 40 41 46 2336 40 41 41 123 2332 46 2337 40 2259 41 59 125 2259 46 2335 40 41 46 2338 40 2339 45 62 2339 46 2340 40 473 41 41 59 2080 46 2333 46 2341 40 41 46 2342 40 41 59 2060 61 2259 46 2343 40 41 59 2344 2345 61 418 2344 40 2332 44 2346 46 2347 40 648 41 41 59 2345 46 2348 40 380 41 59 2345 46 2349 40 380 41 59 2345 46 2088 40 41 59 2350 2351 61 418 2350 40 2345 41 59 2351 46 2352 40 1504 44 1504 41 59 2350 46 2353 40 2345 44 1502 41 59 2350 46 2354 40 2345 44 1502 41 59 2350 46 2355 40 2345 44 45 1503 41 59 2350 46 2356 40 2345 44 1502 41 59 324 2357 61 33 2080 46 2333 46 2358 40 2259 46 2359 40 41 41 59 2360 2361 61 418 2360 40 2259 44 2357 41 59 2075 61 40 2362 44 2363 44 2364 41 45 62 123 392 40 2364 614 2073 46 2074 46 2365 606 2364 614 2073 46 2074 46 2366 41 123 2052 46 2367 40 41 59 125 125 59 2259 46 2368 40 41 46 2369 40 2075 41 59 2077 61 40 2362 44 2363 44 2364 41 45 62 123 392 40 2364 614 2076 46 2370 606 2364 614 2076 46 2371 606 2364 614 2076 46 2372 41 123 2052 46 2373 40 41 59 125 125 59 2259 46 2374 40 41 46 2369 40 2077 41 59 2345 46 2375 40 2361 44 2351 46 2376 40 41 41 59 2345 46 2192 40 41 59 2345 46 2377 40 41 59 2052 61 418 2051 40 41 59 2052 46 2378 40 2346 46 2347 40 648 44 2259 46 2379 40 41 41 41 59 2380 2381 61 2382 46 2383 40 41 59 2046 2384 61 2381 46 2385 40 41 59 2052 46 2386 40 2384 46 2387 40 41 41 59 2052 46 2388 40 2389 46 2390 41 59 2052 46 2391 40 2392 46 2393 41 59 2052 46 2394 40 373 45 62 123 2345 46 2236 40 41 59 621 2259 46 2335 40 41 46 2338 40 2339 45 62 2339 46 2340 40 473 41 41 59 2080 46 2333 46 2341 40 41 46 2342 40 41 59 2060 61 424 59 392 40 2065 631 424 41 123 2052 46 2395 40 41 46 2396 40 2065 41 59 125 392 40 2066 631 424 41 123 2052 46 2397 40 41 46 2398 40 2066 41 59 125 2259 46 2368 40 41 46 2369 40 2075 41 59 2259 46 2374 40 41 46 2369 40 2077 41 59 2332 46 2342 40 41 59 125 41 59 2046 2047 61 418 2046 40 2351 41 59 2399 46 2400 40 2047 44 2022 46 2401 40 41 44 2020 41 59 2047 46 2402 40 2044 46 2403 44 2404 45 62 123 392 40 2404 46 2405 40 41 614 2406 46 2407 41 123 2404 46 2408 40 41 59 2052 46 2409 40 41 59 125 125 41 59 2052 46 2410 40 2047 41 59 2052 46 2411 40 1500 41 59 2052 46 2412 40 41 59 2065 61 40 2362 44 2363 44 2364 41 45 62 2061 61 40 356 41 2364 59 2052 46 2413 40 41 46 2369 40 2065 41 59 2066 61 40 2362 44 2363 44 2364 41 45 62 2062 61 40 356 41 2364 59 2052 46 2414 40 41 46 2369 40 2066 41 59 392 40 2061 614 45 1501 41 123 2415 2416 61 2384 46 2387 40 41 59 356 2417 61 2416 46 2418 40 41 45 2384 46 2418 40 41 59 2052 46 2419 40 2420 46 2421 40 2416 46 2422 40 41 43 40 2381 46 2423 40 41 45 2052 46 2423 40 41 47 1502 42 1502 41 41 41 59 2052 46 2424 40 2420 46 2421 40 2416 46 2425 40 41 43 2417 43 40 2381 46 2418 40 41 45 2052 46 2418 40 41 47 1502 42 1502 41 41 41 59 125 360 123 2052 46 2426 40 2061 41 59 2052 46 2427 40 2062 41 59 125 621 621 2428 46 2429 40 40 41 45 62 2052 46 2411 40 1501 41 41 59 2430 40 2259 44 2070 46 2347 40 2259 46 2343 40 41 41 41 59 125 437 492 2431 40 2073 2259 44 2069 2432 41 123 392 40 33 2259 46 2433 40 41 46 2434 40 2060 41 41 123 2315 40 41 59 413 2435 61 2058 46 2436 40 2259 46 2433 40 41 41 59 392 40 2435 62 1500 41 123 2432 46 2437 40 2056 46 2438 40 2435 41 41 59 2432 46 2439 40 473 41 59 125 360 123 2432 46 2440 40 648 41 59 2432 46 2441 40 380 41 59 125 125 360 123 2432 46 2442 40 648 41 59 2432 46 2443 40 380 41 59 125 2432 46 2444 40 41 59 125 621 621 621 437 492 2445 40 41 123 2025 2446 61 2080 46 2447 46 2448 46 2449 40 41 59 392 40 2446 631 424 41 123 621 404 2450 61 2026 46 2451 40 41 46 2452 40 2446 41 59 2453 46 2454 40 40 41 45 62 2026 46 2455 40 41 46 2456 40 2450 41 41 59 125 125 437 492 2457 40 41 123 2315 40 41 59 2250 40 41 59 125 621 621 621 437 492 2458 40 41 123 2035 46 2459 40 41 46 2460 40 648 41 59 2035 46 2461 40 40 2462 41 45 62 418 2463 60 62 40 2462 46 2464 40 41 41 41 59 2035 46 2465 40 418 2466 60 62 40 41 123 64 2087 439 2467 60 2025 44 2025 62 2468 40 2027 60 2025 44 2025 62 2469 41 123 450 418 2467 60 62 40 41 123 437 2073 2259 59 437 2063 60 2073 46 2470 62 2471 59 64 2087 439 492 2472 40 381 2025 2473 44 324 362 41 123 463 46 2472 40 2473 44 362 41 59 392 40 2473 631 424 605 33 362 41 123 2259 61 2473 46 2474 40 41 59 2471 61 40 2475 44 2476 44 2477 41 45 62 2478 40 41 59 2259 46 2479 40 41 46 2480 40 2471 41 59 2478 40 41 59 125 360 123 2481 40 424 41 59 392 40 2259 631 424 605 2471 631 424 41 123 2259 46 2482 40 41 46 2483 40 2471 41 59 2259 61 424 59 2471 61 424 59 125 125 125 437 492 2484 40 41 123 2485 2486 59 392 40 2259 614 424 41 450 59 392 40 2258 40 2259 41 41 123 2486 61 418 2485 40 2259 46 2487 40 41 41 59 2486 46 2488 40 2489 46 2490 40 2491 46 2492 41 41 59 2486 46 2493 40 373 45 62 2010 46 2494 40 2259 41 41 59 2486 46 2495 40 418 2496 40 2497 46 2498 40 648 41 41 41 59 392 40 2259 46 2499 40 41 41 123 2486 46 2500 40 41 46 2459 40 41 46 2501 40 648 44 648 41 59 125 360 123 2486 46 2502 40 41 46 2459 40 41 46 2503 40 648 44 648 41 59 125 125 360 123 2486 61 418 2485 40 2259 46 2504 40 41 41 59 2486 46 2505 40 373 45 62 2010 46 2506 40 2259 41 41 59 2486 46 2507 40 418 2508 40 2509 46 2510 40 648 41 41 41 59 125 2511 40 2486 41 59 125 125 59 125 125 41 59 125 437 492 2512 40 41 123 2036 46 2513 40 40 2259 41 45 62 418 2514 60 62 40 2259 46 2515 40 41 41 41 59 2036 46 2516 40 418 2517 60 62 40 41 123 64 2087 439 2518 60 2025 44 2025 62 2519 40 2027 60 2025 44 2025 62 2520 41 123 450 418 2518 60 62 40 41 123 64 2087 439 492 2521 40 381 2025 2522 44 324 362 41 123 463 46 2521 40 2522 44 362 41 59 392 40 2522 631 424 605 33 362 41 123 2523 40 418 2524 40 2525 46 2526 40 2522 46 2527 40 41 46 2528 40 41 41 41 41 59 125 360 123 2529 40 424 41 59 125 125 125 59 125 125 41 59 125 437 492 2530 40 41 123 2030 46 2531 40 40 2259 41 45 62 418 2532 60 62 40 2259 46 2533 40 41 41 41 59 2030 46 2534 40 418 2535 60 62 40 41 123 64 2087 439 2536 60 2025 44 2025 62 2537 40 2027 60 2025 44 2025 62 2538 41 123 450 418 2536 60 62 40 41 123 64 2087 439 492 2539 40 381 2025 2540 44 324 362 41 123 463 46 2539 40 2540 44 362 41 59 392 40 2540 631 424 605 33 362 41 2541 40 418 2542 40 2016 46 2543 40 2540 46 2544 40 41 46 2545 40 41 41 41 41 59 360 2541 40 424 41 59 125 125 59 125 125 41 59 125 437 492 2546 40 41 123 2028 46 2547 40 40 2259 41 45 62 418 2548 60 62 40 2259 46 2549 40 41 41 41 59 2028 46 2550 40 418 2551 60 62 40 41 123 64 2087 439 2552 60 2025 44 2025 62 2553 40 2027 60 2025 44 2025 62 2554 41 123 450 418 2552 60 62 40 41 123 64 2087 439 492 2555 40 381 2025 2556 44 324 362 41 123 463 46 2555 40 2556 44 362 41 59 392 40 2556 631 424 605 33 362 41 2557 40 418 2558 40 2082 46 2559 40 2556 46 2560 40 41 41 41 41 59 360 2557 40 424 41 59 125 125 59 125 125 41 59 125 437 492 2561 40 41 123 2029 46 2562 40 40 2259 41 45 62 418 2563 60 62 40 2259 46 2564 40 41 41 41 59 2029 46 2565 40 418 2566 60 62 40 41 123 64 2087 439 2567 60 2025 44 2025 62 2568 40 2027 60 2025 44 2025 62 2569 41 123 450 418 2567 60 62 40 41 123 64 2087 439 492 2570 40 381 2025 2571 44 324 362 41 123 463 46 2570 40 2571 44 362 41 59 392 40 2571 631 424 605 33 362 41 123 474 123 2056 2572 61 2573 46 2574 40 2571 46 2575 40 41 46 2576 40 41 41 59 2577 40 418 2578 40 2572 41 41 59 125 329 40 2579 2580 41 123 2581 46 2582 40 2580 46 2583 40 41 41 59 621 125 125 360 2584 40 424 41 59 125 125 59 125 125 41 59 125 437 492 2585 40 41 123 2034 46 2586 40 40 2259 41 45 62 418 2587 60 62 40 2259 46 2588 40 41 41 41 59 2034 46 2589 40 418 2590 60 62 40 41 123 64 2087 439 2591 60 2025 44 2025 62 2592 40 2027 60 2025 44 2025 62 2593 41 123 450 418 2591 60 62 40 41 123 64 2087 439 492 2594 40 381 2025 2595 44 324 362 41 123 463 46 2594 40 2595 44 362 41 59 392 40 2595 631 424 605 33 362 41 2596 40 418 2597 40 2080 46 2598 40 2595 41 41 41 59 360 2596 40 424 41 59 125 125 59 125 125 41 59 125 437 492 2599 40 41 123 2032 46 2600 40 40 2259 41 45 62 418 2601 60 62 40 2259 46 2602 40 41 41 41 59 2032 46 2603 40 418 2604 60 62 40 41 123 64 2087 439 2605 60 2025 44 2025 62 2606 40 2027 60 2025 44 2025 62 2607 41 123 450 418 2605 60 62 40 41 123 64 2087 439 492 2608 40 381 2025 2609 44 324 362 41 123 463 46 2608 40 2609 44 362 41 59 2610 40 418 2611 40 2080 46 2612 40 2609 41 41 41 59 125 125 59 125 125 41 59 125 437 492 2613 40 41 123 2033 46 2614 40 40 2259 41 45 62 418 2615 60 62 40 2259 46 2616 40 41 41 41 59 2033 46 2617 40 418 2618 60 62 40 41 123 64 2087 439 2619 60 2025 44 2025 62 2620 40 2027 60 2025 44 2025 62 2621 41 123 450 418 2619 60 62 40 41 123 64 2087 439 492 2622 40 381 2025 2623 44 324 362 41 123 463 46 2622 40 2623 44 362 41 59 392 40 2623 631 424 605 33 362 41 2624 40 418 2625 40 2080 46 2626 40 2623 41 41 41 59 360 2624 40 424 41 59 125 125 59 125 125 41 59 125 64 2627 40 648 41 437 2027 60 2025 44 2025 62 2628 40 41 123 2031 46 2629 40 40 2259 41 45 62 418 2630 60 62 40 2259 46 2631 40 41 41 41 59 2031 46 2632 40 41 46 2633 40 648 44 648 41 59 2031 46 2634 40 418 2635 60 62 40 41 123 64 2087 439 2636 60 2025 44 2025 62 2637 40 2027 60 2025 44 2025 62 2638 41 123 450 418 2636 60 62 40 41 123 64 2087 439 492 2639 40 2025 2640 44 324 362 41 123 463 46 2639 40 2640 44 362 41 59 392 40 33 362 605 2640 631 424 41 123 381 2073 2259 61 2640 46 2641 40 41 59 381 2642 2643 61 2259 46 2644 40 41 59 404 2645 61 2080 46 2646 40 2259 41 59 2056 2647 61 2648 46 2649 40 648 41 59 2650 2651 61 418 2652 40 2643 44 2647 44 2645 44 2018 44 2259 44 2022 44 2080 46 2653 44 2019 41 59 2654 40 418 2655 40 1501 44 1500 44 1500 44 1500 41 41 59 2656 40 2651 41 59 125 360 123 2657 40 424 41 59 125 125 125 59 125 125 41 59 450 2031 59 125 64 2627 40 648 41 437 2027 60 2025 44 2025 62 2658 40 41 123 2037 46 2659 40 40 2259 41 45 62 418 2660 60 62 40 2259 46 2661 40 41 41 41 59 2037 46 2662 40 41 46 2663 40 648 44 648 41 59 2037 46 2664 40 380 41 59 2037 46 2665 40 418 2666 60 62 40 41 123 64 2087 439 2667 60 2025 44 2025 62 2668 40 2027 60 2025 44 2025 62 2669 41 123 450 418 2667 60 62 40 41 123 64 2087 439 492 2670 40 2025 2671 44 324 362 41 123 463 46 2670 40 2671 44 362 41 59 392 40 33 362 605 2671 631 424 41 123 2073 2259 61 2671 46 2672 40 41 59 2056 2673 61 2259 46 2674 40 41 59 621 621 621 621 621 621 621 2067 2675 59 392 40 33 2068 46 2676 40 2673 41 41 123 2675 61 2677 46 2678 40 2679 46 2680 41 59 2068 46 2681 40 2673 44 2675 41 59 2675 46 2682 40 418 2683 40 2684 46 2685 40 648 41 41 41 59 125 360 123 2675 61 2068 46 2686 40 2673 41 59 125 2069 2432 59 392 40 33 2070 46 2676 40 2673 41 41 123 2432 61 418 2069 40 2675 41 59 2070 46 2687 40 2673 44 2432 41 59 2432 46 2688 40 2689 46 2690 41 59 125 360 123 2432 61 2070 46 2691 40 2673 41 59 125 2675 46 2692 40 2693 45 62 123 2026 46 2694 40 41 46 2695 40 467 46 2696 40 41 41 59 2329 40 2259 41 59 125 41 59 392 40 33 2072 46 2676 40 2673 41 41 123 2053 60 2071 62 2697 61 2698 45 62 2431 40 2259 44 2432 41 59 2072 46 2699 40 2673 44 2697 41 59 2259 46 2700 40 41 46 2701 40 2697 41 59 125 2431 40 2259 44 2432 41 59 2702 40 2432 41 59 125 360 123 2703 40 424 41 59 125 125 125 59 125 125 41 59 450 2037 59 125 437 492 2704 40 41 123 2038 46 2705 40 40 2259 41 45 62 418 2706 60 62 40 2259 46 2707 40 41 41 41 59 2038 46 2708 40 418 2709 60 62 40 41 123 64 2087 439 2710 60 2025 44 2025 62 2711 40 2027 60 2025 44 2025 62 2712 41 123 450 418 2710 60 62 40 41 123 437 2073 2259 59 437 2713 2714 44 2715 59 437 2063 60 2073 46 2716 62 2717 59 64 2087 439 492 2718 40 2025 2719 44 324 362 41 123 463 46 2718 40 2719 44 362 41 59 392 40 33 362 605 2719 631 424 41 123 2259 61 2719 46 2720 40 41 59 2717 61 40 2721 44 2722 44 2723 41 45 62 2724 40 41 59 2259 46 2725 40 41 46 2726 40 2717 41 59 2724 40 41 59 125 360 123 2727 40 41 59 125 125 437 492 2728 40 41 123 392 40 2258 40 2259 41 41 123 2729 2730 61 2731 46 2732 40 2733 46 2734 41 59 2729 2735 61 2731 46 2732 40 2733 46 2736 41 59 392 40 2259 46 2737 40 41 41 123 2735 46 2738 40 41 46 2739 40 648 44 648 41 59 2730 46 2738 40 41 46 2739 40 648 44 648 41 59 125 360 123 2735 46 2740 40 41 46 2741 40 648 44 648 41 59 2730 46 2740 40 41 46 2741 40 648 44 648 41 59 125 2714 61 418 2713 40 648 44 2730 41 59 2714 46 2742 40 41 46 2743 40 648 41 59 2714 46 2744 40 418 2745 40 2746 46 2747 40 648 41 41 41 59 2714 46 2748 40 2749 45 62 2280 40 2259 41 41 59 2715 61 418 2713 40 648 44 2735 41 59 2715 46 2742 40 41 46 2743 40 648 41 59 2715 46 2744 40 418 2745 40 2746 46 2747 40 648 41 41 41 59 2715 46 2748 40 2749 45 62 2266 40 2259 41 41 59 2750 2751 61 418 2750 40 41 59 2751 46 2752 40 1500 41 59 2751 46 2753 40 41 46 2754 40 2714 44 2715 41 59 2755 40 2751 41 59 125 360 123 2756 40 41 59 125 2250 40 41 59 125 437 492 2757 40 41 123 392 40 2714 631 424 41 123 2714 46 2758 40 424 41 59 125 392 40 2715 631 424 41 123 2715 46 2759 40 424 41 59 125 392 40 2717 631 424 605 2259 631 424 41 123 2259 46 2760 40 41 46 2761 40 2717 41 59 125 2762 40 424 41 59 125 125 59 125 125 41 59 125 125 
2511,Java,"public final class LookBehavior extends Behavior implements ILookBehavior {

    /**
     * Target's values are as follows:
     * <p>
     * getFirst() -> yaw
     * getSecond() -> pitch
     */
    private Rotation target;

    /**
     * Whether or not rotations are currently being forced
     */
    private boolean force;

    /**
     * The last player yaw angle. Used when free looking
     *
     * @see Settings#freeLook
     */
    private float lastYaw;

    public LookBehavior(Baritone baritone) {
        super(baritone);
    }

    @Override
    public void updateTarget(Rotation target, boolean force) {
        this.target = target;
        this.force = force || !Baritone.settings().freeLook.value;
    }

    @Override
    public void onPlayerUpdate(PlayerUpdateEvent event) {
        if (this.target == null) {
            return;
        }

        // Whether or not we're going to silently set our angles
        boolean silent = Baritone.settings().antiCheatCompatibility.value && !this.force;

        switch (event.getState()) {
            case PRE: {
                if (this.force) {
                    ctx.player().rotationYaw = this.target.getYaw();
                    float oldPitch = ctx.player().rotationPitch;
                    float desiredPitch = this.target.getPitch();
                    ctx.player().rotationPitch = desiredPitch;
                    ctx.player().rotationYaw += (Math.random() - 0.5) * Baritone.settings().randomLooking.value;
                    ctx.player().rotationPitch += (Math.random() - 0.5) * Baritone.settings().randomLooking.value;
                    if (desiredPitch == oldPitch && !Baritone.settings().freeLook.value) {
                        nudgeToLevel();
                    }
                    this.target = null;
                }
                if (silent) {
                    this.lastYaw = ctx.player().rotationYaw;
                    ctx.player().rotationYaw = this.target.getYaw();
                }
                break;
            }
            case POST: {
                if (silent) {
                    ctx.player().rotationYaw = this.lastYaw;
                    this.target = null;
                }
                break;
            }
            default:
                break;
        }
    }

    public void pig() {
        if (this.target != null) {
            ctx.player().rotationYaw = this.target.getYaw();
        }
    }

    @Override
    public void onPlayerRotationMove(RotationMoveEvent event) {
        if (this.target != null) {

            event.setYaw(this.target.getYaw());

            // If we have antiCheatCompatibility on, we're going to use the target value later in onPlayerUpdate()
            // Also the type has to be MOTION_UPDATE because that is called after JUMP
            if (!Baritone.settings().antiCheatCompatibility.value && event.getType() == RotationMoveEvent.Type.MOTION_UPDATE && !this.force) {
                this.target = null;
            }
        }
    }

    /**
     * Nudges the player's pitch to a regular level. (Between {@code -20} and {@code 10}, increments are by {@code 1})
     */
    private void nudgeToLevel() {
        if (ctx.player().rotationPitch < -20) {
            ctx.player().rotationPitch++;
        } else if (ctx.player().rotationPitch > 10) {
            ctx.player().rotationPitch--;
        }
    }
}",1,439 381 334 2000 378 2001 395 2002 123 618 437 2003 2004 59 618 437 324 2005 59 618 437 384 2006 59 439 2000 40 2007 2008 41 123 463 40 2008 41 59 125 64 2009 439 492 2010 40 2003 2004 44 324 2005 41 123 467 46 2004 61 2004 59 467 46 2005 61 2005 606 33 2007 46 2011 40 41 46 2012 46 2013 59 125 64 2009 439 492 2014 40 2015 373 41 123 392 40 467 46 2004 614 424 41 123 450 59 125 621 324 2016 61 2007 46 2017 40 41 46 2018 46 2019 605 33 467 46 2005 59 464 40 373 46 2020 40 41 41 123 328 2021 58 123 392 40 467 46 2005 41 123 2022 46 2023 40 41 46 2024 61 467 46 2004 46 2025 40 41 59 384 2026 61 2022 46 2023 40 41 46 2027 59 384 2028 61 467 46 2004 46 2029 40 41 59 2022 46 2023 40 41 46 2027 61 2028 59 2022 46 2023 40 41 46 2024 636 40 2030 46 2031 40 41 45 1499 41 42 2007 46 2017 40 41 46 2032 46 2019 59 2022 46 2023 40 41 46 2027 636 40 2030 46 2031 40 41 45 1499 41 42 2007 46 2017 40 41 46 2032 46 2019 59 392 40 2028 614 2026 605 33 2007 46 2017 40 41 46 2033 46 2019 41 123 2034 40 41 59 125 467 46 2004 61 424 59 125 392 40 2016 41 123 467 46 2006 61 2035 46 2036 40 41 46 2037 59 2035 46 2036 40 41 46 2037 61 467 46 2004 46 2038 40 41 59 125 325 59 125 328 2039 58 123 392 40 2016 41 123 2040 46 2041 40 41 46 2042 61 467 46 2006 59 467 46 2004 61 424 59 125 325 59 125 349 58 325 59 125 125 439 492 2043 40 41 123 392 40 467 46 2004 631 424 41 123 2044 46 2045 40 41 46 2046 61 467 46 2004 46 2047 40 41 59 125 125 64 2009 439 492 2048 40 2049 373 41 123 392 40 467 46 2004 631 424 41 123 373 46 2050 40 467 46 2004 46 2051 40 41 41 59 621 621 392 40 33 2007 46 2052 40 41 46 2053 46 2054 605 373 46 2055 40 41 614 2049 46 2056 46 2057 605 33 467 46 2005 41 123 467 46 2004 61 424 59 125 125 125 618 437 492 2058 40 41 123 392 40 2059 46 2060 40 41 46 2061 60 45 1503 41 123 2059 46 2060 40 41 46 2061 637 59 125 360 392 40 2059 46 2060 40 41 46 2061 62 1502 41 123 2059 46 2060 40 41 46 2061 629 59 125 125 125 
29392,Java,"@Provides(EclipseASTVisitor.class)
@DeferUntilPostDiet
@HandlerPriority(65536) // 2^16; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
public class HandleVal extends EclipseASTAdapter {
	@Override public void visitLocal(EclipseNode localNode, LocalDeclaration local) {
		TypeReference type = local.type;
		boolean isVal = typeMatches(val.class, localNode, type);
		boolean isVar = typeMatches(var.class, localNode, type);
		if (!(isVal || isVar)) return;
		
		if (isVal) handleFlagUsage(localNode, ConfigurationKeys.VAL_FLAG_USAGE, ""val"");
		if (isVar) handleFlagUsage(localNode, ConfigurationKeys.VAR_FLAG_USAGE, ""var"");
		
		boolean variableOfForEach = false;
		
		if (localNode.directUp().get() instanceof ForeachStatement) {
			ForeachStatement fs = (ForeachStatement) localNode.directUp().get();
			variableOfForEach = fs.elementVariable == local;
		}
		
		String annotation = isVal ? ""val"" : ""var"";
		if (local.initialization == null && !variableOfForEach) {
			localNode.addError(""'"" + annotation + ""' on a local variable requires an initializer expression"");
			return;
		}
		
		if (local.initialization instanceof ArrayInitializer) {
			localNode.addError(""'"" + annotation + ""' is not compatible with array initializer expressions. Use the full form (new int[] { ... } instead of just { ... })"");
			return;
		}
		
		ASTNode parentRaw = localNode.directUp().get();
		
		if (isVal && parentRaw instanceof ForStatement) {
			localNode.addError(""'val' is not allowed in old-style for loops"");
			return;
		}
		
		if (parentRaw instanceof ForStatement && ((ForStatement) parentRaw).initializations != null && ((ForStatement) parentRaw).initializations.length > 1) {
			localNode.addError(""'var' is not allowed in old-style for loops if there is more than 1 initializer"");
			return;
		}
		
		if (local.initialization != null && local.initialization.getClass().getName().equals(""org.eclipse.jdt.internal.compiler.ast.LambdaExpression"")) {
			localNode.addError(""'"" + annotation + ""' is not allowed with lambda expressions."");
			return;
		}
		
		if(isVar && local.initialization instanceof NullLiteral) {
			localNode.addError(""variable initializer is 'null'"");
			return;
		}
	}
}",1,64 2000 40 2001 46 334 41 64 2002 64 2003 40 1506 41 621 439 334 2004 378 2005 123 64 2006 439 492 2007 40 2008 2009 44 2010 2011 41 123 2012 2013 61 2011 46 2013 59 324 2014 61 2015 40 2016 46 334 44 2009 44 2013 41 59 324 2017 61 2015 40 490 46 334 44 2009 44 2013 41 59 392 40 33 40 2014 606 2017 41 41 450 59 392 40 2014 41 2018 40 2009 44 2019 46 2020 44 648 41 59 392 40 2017 41 2018 40 2009 44 2019 46 2021 44 648 41 59 324 2022 61 380 59 392 40 2009 46 2023 40 41 46 2024 40 41 402 2025 41 123 2025 2026 61 40 2025 41 2009 46 2023 40 41 46 2024 40 41 59 2022 61 2026 46 2027 614 2011 59 125 2028 2029 61 2014 63 648 58 648 59 392 40 2011 46 2030 614 424 605 33 2022 41 123 2009 46 2031 40 648 43 2029 43 648 41 59 450 59 125 392 40 2011 46 2030 402 2032 41 123 2009 46 2033 40 648 43 2029 43 648 41 59 450 59 125 2034 2035 61 2009 46 2023 40 41 46 2024 40 41 59 392 40 2014 605 2035 402 2036 41 123 2009 46 2037 40 648 41 59 450 59 125 392 40 2035 402 2036 605 40 40 2036 41 2035 41 46 2038 631 424 605 40 40 2036 41 2035 41 46 2038 46 2039 62 1501 41 123 2009 46 2040 40 648 41 59 450 59 125 392 40 2011 46 2030 631 424 605 2011 46 2030 46 2041 40 41 46 2042 40 41 46 2043 40 648 41 41 123 2009 46 2044 40 648 43 2029 43 648 41 59 450 59 125 392 40 2017 605 2011 46 2030 402 2045 41 123 2009 46 2046 40 648 41 59 450 59 125 125 125 
2746,Java,"@Slf4j
public class BsqWalletService extends WalletService implements DaoStateListener {

    public interface WalletTransactionsChangeListener {

        void onWalletTransactionsChange();
    }

    private final DaoKillSwitch daoKillSwitch;
    private final BsqCoinSelector bsqCoinSelector;
    private final NonBsqCoinSelector nonBsqCoinSelector;
    private final DaoStateService daoStateService;
    private final UnconfirmedBsqChangeOutputListService unconfirmedBsqChangeOutputListService;
    private final List<Transaction> walletTransactions = new ArrayList<>();
    private final CopyOnWriteArraySet<BsqBalanceListener> bsqBalanceListeners = new CopyOnWriteArraySet<>();
    private final List<WalletTransactionsChangeListener> walletTransactionsChangeListeners = new ArrayList<>();
    private boolean updateBsqWalletTransactionsPending;
    @Getter
    private final BsqFormatter bsqFormatter;


    // balance of non BSQ satoshis
    @Getter
    private Coin availableNonBsqBalance = Coin.ZERO;
    @Getter
    private Coin availableBalance = Coin.ZERO;
    @Getter
    private Coin unverifiedBalance = Coin.ZERO;
    @Getter
    private Coin verifiedBalance = Coin.ZERO;
    @Getter
    private Coin unconfirmedChangeBalance = Coin.ZERO;
    @Getter
    private Coin lockedForVotingBalance = Coin.ZERO;
    @Getter
    private Coin lockupBondsBalance = Coin.ZERO;
    @Getter
    private Coin unlockingBondsBalance = Coin.ZERO;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public BsqWalletService(WalletsSetup walletsSetup,
                            BsqCoinSelector bsqCoinSelector,
                            NonBsqCoinSelector nonBsqCoinSelector,
                            DaoStateService daoStateService,
                            UnconfirmedBsqChangeOutputListService unconfirmedBsqChangeOutputListService,
                            Preferences preferences,
                            FeeService feeService,
                            DaoKillSwitch daoKillSwitch,
                            BsqFormatter bsqFormatter) {
        super(walletsSetup,
                preferences,
                feeService);

        this.bsqCoinSelector = bsqCoinSelector;
        this.nonBsqCoinSelector = nonBsqCoinSelector;
        this.daoStateService = daoStateService;
        this.unconfirmedBsqChangeOutputListService = unconfirmedBsqChangeOutputListService;
        this.daoKillSwitch = daoKillSwitch;
        this.bsqFormatter = bsqFormatter;

        nonBsqCoinSelector.setPreferences(preferences);

        walletsSetup.addSetupCompletedHandler(() -> {
            wallet = walletsSetup.getBsqWallet();
            if (wallet != null) {
                wallet.setCoinSelector(bsqCoinSelector);
                addListenersToWallet();
            }

            BlockChain chain = walletsSetup.getChain();
            if (chain != null) {
                chain.addNewBestBlockListener(block -> chainHeightProperty.set(block.getHeight()));
                chainHeightProperty.set(chain.getBestChainHeight());
            }
        });

        daoStateService.addDaoStateListener(this);
    }

    @Override
    protected void addListenersToWallet() {
        super.addListenersToWallet();

        wallet.addCoinsReceivedEventListener((wallet, tx, prevBalance, newBalance) ->
                updateBsqWalletTransactions()
        );
        wallet.addCoinsSentEventListener((wallet, tx, prevBalance, newBalance) ->
                updateBsqWalletTransactions()
        );
        wallet.addReorganizeEventListener(wallet -> {
            log.warn(""onReorganize "");
            updateBsqWalletTransactions();
            unconfirmedBsqChangeOutputListService.onReorganize();
        });
        wallet.addTransactionConfidenceEventListener((wallet, tx) -> {
            // We are only interested in updates from unconfirmed txs and confirmed txs at the
            // time when it gets into a block. Otherwise we would get called
            // updateBsqWalletTransactions for each tx as the block depth changes for all.
            if (tx != null && tx.getConfidence() != null && tx.getConfidence().getDepthInBlocks() <= 1 &&
                    daoStateService.isParseBlockChainComplete()) {
                updateBsqWalletTransactions();
            }
            unconfirmedBsqChangeOutputListService.onTransactionConfidenceChanged(tx);
        });
        wallet.addKeyChainEventListener(keys ->
                updateBsqWalletTransactions()
        );
        wallet.addScriptsChangeEventListener((wallet, scripts, isAddingScripts) ->
                updateBsqWalletTransactions()
        );
        wallet.addChangeEventListener(wallet ->
                updateBsqWalletTransactions()
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // DaoStateListener
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onParseBlockCompleteAfterBatchProcessing(Block block) {
        if (isWalletReady()) {
            wallet.getTransactions(false).forEach(unconfirmedBsqChangeOutputListService::onTransactionConfidenceChanged);
            updateBsqWalletTransactions();
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Overridden Methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    String getWalletAsString(boolean includePrivKeys) {
        return wallet.toString(true, includePrivKeys, this.aesKey, true, true, walletsSetup.getChain()) + ""\n\n"" +
                ""All pubKeys as hex:\n"" +
                wallet.printAllPubKeysAsHex();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Balance
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void updateBsqBalance() {
        long ts = System.currentTimeMillis();
        unverifiedBalance = Coin.valueOf(
                getTransactions(false).stream()
                        .filter(tx -> tx.getConfidence().getConfidenceType() == PENDING)
                        .mapToLong(tx -> {
                            // Sum up outputs into BSQ wallet and subtract the inputs using lockup or unlocking
                            // outputs since those inputs will be accounted for in lockupBondsBalance and
                            // unlockingBondsBalance
                            long outputs = tx.getOutputs().stream()
                                    .filter(out -> out.isMine(wallet))
                                    .filter(TransactionOutput::isAvailableForSpending)
                                    .mapToLong(out -> out.getValue().value)
                                    .sum();
                            // Account for spending of locked connectedOutputs
                            long lockedInputs = tx.getInputs().stream()
                                    .filter(in -> {
                                        TransactionOutput connectedOutput = in.getConnectedOutput();
                                        if (connectedOutput != null) {
                                            Transaction parentTransaction = connectedOutput.getParentTransaction();
                                            // TODO SQ
                                            if (parentTransaction != null/* &&
                                                    parentTransaction.getConfidence().getConfidenceType() == BUILDING*/) {
                                                TxOutputKey key = new TxOutputKey(parentTransaction.getTxId().toString(),
                                                        connectedOutput.getIndex());

                                                return (connectedOutput.isMine(wallet)
                                                        && (daoStateService.isLockupOutput(key)
                                                        || daoStateService.isUnlockingAndUnspent(key)));
                                            }
                                        }
                                        return false;
                                    })
                                    .mapToLong(in -> in.getValue() != null ? in.getValue().value : 0)
                                    .sum();
                            return outputs - lockedInputs;
                        })
                        .sum()
        );

        Set<String> confirmedTxIdSet = getTransactions(false).stream()
                .filter(tx -> tx.getConfidence().getConfidenceType() == BUILDING)
                .map(Transaction::getTxId)
                .map(Sha256Hash::toString)
                .collect(Collectors.toSet());

        lockedForVotingBalance = Coin.valueOf(daoStateService.getUnspentBlindVoteStakeTxOutputs().stream()
                .filter(txOutput -> confirmedTxIdSet.contains(txOutput.getTxId()))
                .mapToLong(TxOutput::getValue)
                .sum());

        lockupBondsBalance = Coin.valueOf(daoStateService.getLockupTxOutputs().stream()
                .filter(txOutput -> daoStateService.isUnspent(txOutput.getKey()))
                .filter(txOutput -> !daoStateService.isConfiscatedLockupTxOutput(txOutput.getTxId()))
                .filter(txOutput -> confirmedTxIdSet.contains(txOutput.getTxId()))
                .mapToLong(TxOutput::getValue)
                .sum());

        unlockingBondsBalance = Coin.valueOf(daoStateService.getUnspentUnlockingTxOutputsStream()
                .filter(txOutput -> confirmedTxIdSet.contains(txOutput.getTxId()))
                .filter(txOutput -> !daoStateService.isConfiscatedUnlockTxOutput(txOutput.getTxId()))
                .mapToLong(TxOutput::getValue)
                .sum());

        availableBalance = bsqCoinSelector.select(NetworkParameters.MAX_MONEY,
                wallet.calculateAllSpendCandidates()).valueGathered;

        if (availableBalance.isNegative())
            availableBalance = Coin.ZERO;

        unconfirmedChangeBalance = unconfirmedBsqChangeOutputListService.getBalance();

        availableNonBsqBalance = nonBsqCoinSelector.select(NetworkParameters.MAX_MONEY,
                wallet.calculateAllSpendCandidates()).valueGathered;

        verifiedBalance = availableBalance.subtract(unconfirmedChangeBalance);

        bsqBalanceListeners.forEach(e -> e.onUpdateBalances(availableBalance, availableNonBsqBalance, unverifiedBalance,
                unconfirmedChangeBalance, lockedForVotingBalance, lockupBondsBalance, unlockingBondsBalance));
        log.info(""updateBsqBalance took {} ms"", System.currentTimeMillis() - ts);
    }

    public void addBsqBalanceListener(BsqBalanceListener listener) {
        bsqBalanceListeners.add(listener);
    }

    public void removeBsqBalanceListener(BsqBalanceListener listener) {
        bsqBalanceListeners.remove(listener);
    }

    public void addWalletTransactionsChangeListener(WalletTransactionsChangeListener listener) {
        walletTransactionsChangeListeners.add(listener);
    }

    public void removeWalletTransactionsChangeListener(WalletTransactionsChangeListener listener) {
        walletTransactionsChangeListeners.remove(listener);
    }

    public List<TransactionOutput> getSpendableBsqTransactionOutputs() {
        return new ArrayList<>(bsqCoinSelector.select(NetworkParameters.MAX_MONEY,
                wallet.calculateAllSpendCandidates()).gathered);
    }

    public List<TransactionOutput> getSpendableNonBsqTransactionOutputs() {
        return new ArrayList<>(nonBsqCoinSelector.select(NetworkParameters.MAX_MONEY,
                wallet.calculateAllSpendCandidates()).gathered);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // BSQ TransactionOutputs and Transactions
    ///////////////////////////////////////////////////////////////////////////////////////////

    public List<Transaction> getClonedWalletTransactions() {
        return new ArrayList<>(walletTransactions);
    }

    public Stream<Transaction> getPendingWalletTransactionsStream() {
        return walletTransactions.stream()
                .filter(transaction -> transaction.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.PENDING);
    }

    private void updateBsqWalletTransactions() {
        if (daoStateService.isParseBlockChainComplete()) {
            // We get called updateBsqWalletTransactions multiple times from onWalletChanged, onTransactionConfidenceChanged
            // and from onParseBlockCompleteAfterBatchProcessing. But as updateBsqBalance is an expensive operation we do
            // not want to call it in a short interval series so we use a flag and a delay to not call it multiple times
            // in a 100 ms period.
            if (!updateBsqWalletTransactionsPending) {
                updateBsqWalletTransactionsPending = true;
                UserThread.runAfter(() -> {
                    walletTransactions.clear();
                    walletTransactions.addAll(getTransactions(false));
                    walletTransactionsChangeListeners.forEach(WalletTransactionsChangeListener::onWalletTransactionsChange);
                    updateBsqBalance();
                    updateBsqWalletTransactionsPending = false;
                }, 100, TimeUnit.MILLISECONDS);
            }
        }
    }

    private Set<Transaction> getBsqWalletTransactions() {
        return getTransactions(false).stream()
                .filter(transaction -> transaction.getConfidence().getConfidenceType() == PENDING ||
                        daoStateService.containsTx(transaction.getTxId().toString()))
                .collect(Collectors.toSet());
    }

    public Set<Transaction> getUnverifiedBsqTransactions() {
        Set<Transaction> bsqWalletTransactions = getBsqWalletTransactions();
        Set<Transaction> walletTxs = new HashSet<>(getTransactions(false));
        checkArgument(walletTxs.size() >= bsqWalletTransactions.size(),
                ""We cannot have more txsWithOutputsFoundInBsqTxo than walletTxs"");
        if (walletTxs.size() == bsqWalletTransactions.size()) {
            // As expected
            return new HashSet<>();
        } else {
            Map<String, Transaction> map = walletTxs.stream()
                    .collect(Collectors.toMap(t -> t.getTxId().toString(), Function.identity()));

            Set<String> walletTxIds = walletTxs.stream()
                    .map(Transaction::getTxId).map(Sha256Hash::toString).collect(Collectors.toSet());
            Set<String> bsqTxIds = bsqWalletTransactions.stream()
                    .map(Transaction::getTxId).map(Sha256Hash::toString).collect(Collectors.toSet());

            walletTxIds.stream()
                    .filter(bsqTxIds::contains)
                    .forEach(map::remove);
            return new HashSet<>(map.values());
        }
    }

    @Override
    public Coin getValueSentFromMeForTransaction(Transaction transaction) throws ScriptException {
        Coin result = Coin.ZERO;
        // We check all our inputs and get the connected outputs.
        for (int i = 0; i < transaction.getInputs().size(); i++) {
            TransactionInput input = transaction.getInputs().get(i);
            // We grab the connected output for that input
            TransactionOutput connectedOutput = input.getConnectedOutput();
            if (connectedOutput != null) {
                // We grab the parent tx of the connected output
                final Transaction parentTransaction = connectedOutput.getParentTransaction();
                final boolean isConfirmed = parentTransaction != null &&
                        parentTransaction.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING;
                if (connectedOutput.isMineOrWatched(wallet)) {
                    if (isConfirmed) {
                        // We lookup if we have a BSQ tx matching the parent tx
                        // We cannot make that findTx call outside of the loop as the parent tx can change at each iteration
                        Optional<Tx> txOptional = daoStateService.getTx(parentTransaction.getTxId().toString());
                        if (txOptional.isPresent()) {
                            TxOutput txOutput = txOptional.get().getTxOutputs().get(connectedOutput.getIndex());
                            if (daoStateService.isBsqTxOutputType(txOutput)) {
                                //TODO check why values are not the same
                                if (txOutput.getValue() != connectedOutput.getValue().value)
                                    log.warn(""getValueSentToMeForTransaction: Value of BSQ output do not match BitcoinJ tx output. "" +
                                                    ""txOutput.getValue()={}, output.getValue().value={}, txId={}"",
                                            txOutput.getValue(), connectedOutput.getValue().value, txOptional.get().getId());

                                // If it is a valid BSQ output we add it
                                result = result.add(Coin.valueOf(txOutput.getValue()));
                            }
                        }
                    } /*else {
                        // TODO atm we don't display amounts of unconfirmed txs but that might change so we leave that code
                        // if it will be required
                        // If the tx is not confirmed yet we add the value and assume it is a valid BSQ output.
                        result = result.add(connectedOutput.getValue());
                    }*/
                }
            }
        }
        return result;
    }

    @Override
    public Coin getValueSentToMeForTransaction(Transaction transaction) throws ScriptException {
        Coin result = Coin.ZERO;
        final String txId = transaction.getTxId().toString();
        // We check if we have a matching BSQ tx. We do that call here to avoid repeated calls in the loop.
        Optional<Tx> txOptional = daoStateService.getTx(txId);
        // We check all the outputs of our tx
        for (int i = 0; i < transaction.getOutputs().size(); i++) {
            TransactionOutput output = transaction.getOutputs().get(i);
            final boolean isConfirmed = output.getParentTransaction() != null &&
                    output.getParentTransaction().getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING;
            if (output.isMineOrWatched(wallet)) {
                if (isConfirmed) {
                    if (txOptional.isPresent()) {
                        // The index of the BSQ tx outputs are the same like the bitcoinj tx outputs
                        TxOutput txOutput = txOptional.get().getTxOutputs().get(i);
                        if (daoStateService.isBsqTxOutputType(txOutput)) {
                            //TODO check why values are not the same
                            if (txOutput.getValue() != output.getValue().value) {
                                log.warn(""getValueSentToMeForTransaction: Value of BSQ output do not match BitcoinJ tx output. "" +
                                                ""txOutput.getValue()={}, output.getValue().value={}, txId={}"",
                                        txOutput.getValue(), output.getValue().value, txId);
                            }

                            // If it is a valid BSQ output we add it
                            result = result.add(Coin.valueOf(txOutput.getValue()));
                        }
                    }
                } /*else {
                    // TODO atm we don't display amounts of unconfirmed txs but that might change so we leave that code
                    // if it will be required
                    // If the tx is not confirmed yet we add the value and assume it is a valid BSQ output.
                    result = result.add(output.getValue());
                }*/
            }
        }
        return result;
    }

    public Optional<Transaction> isWalletTransaction(String txId) {
        return walletTransactions.stream().filter(e -> e.getTxId().toString().equals(txId)).findAny();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Sign tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction signTxAndVerifyNoDustOutputs(Transaction tx)
            throws WalletException, TransactionVerificationException {
        WalletService.signTx(wallet, aesKey, tx);
        WalletService.verifyNonDustTxo(tx);
        return tx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Commit tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void commitTx(Transaction tx, TxType txType) {
        wallet.commitTx(tx);
        //printTx(""BSQ commit Tx"", tx);

        unconfirmedBsqChangeOutputListService.onCommitTx(tx, txType, wallet);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Send BSQ with BTC fee
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction getPreparedSendBsqTx(String receiverAddress, Coin receiverAmount)
            throws AddressFormatException, InsufficientBsqException, WalletException,
            TransactionVerificationException, BsqChangeBelowDustException {
        return getPreparedSendTx(receiverAddress, receiverAmount, bsqCoinSelector);
    }

    public Transaction getPreparedSendBsqTx(String receiverAddress,
                                            Coin receiverAmount,
                                            @Nullable Set<TransactionOutput> utxoCandidates)
            throws AddressFormatException, InsufficientBsqException, WalletException,
            TransactionVerificationException, BsqChangeBelowDustException {
        if (utxoCandidates != null) {
            bsqCoinSelector.setUtxoCandidates(utxoCandidates);
        }
        return getPreparedSendTx(receiverAddress, receiverAmount, bsqCoinSelector);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Send BTC (non-BSQ) with BTC fee (e.g. the issuance output from a  lost comp. request)
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction getPreparedSendBtcTx(String receiverAddress, Coin receiverAmount)
            throws AddressFormatException, InsufficientBsqException, WalletException,
            TransactionVerificationException, BsqChangeBelowDustException {
        return getPreparedSendTx(receiverAddress, receiverAmount, nonBsqCoinSelector);
    }

    public Transaction getPreparedSendBtcTx(String receiverAddress,
                                            Coin receiverAmount,
                                            @Nullable Set<TransactionOutput> utxoCandidates)
            throws AddressFormatException, InsufficientBsqException, WalletException,
            TransactionVerificationException, BsqChangeBelowDustException {
        if (utxoCandidates != null) {
            nonBsqCoinSelector.setUtxoCandidates(utxoCandidates);
        }
        return getPreparedSendTx(receiverAddress, receiverAmount, nonBsqCoinSelector);
    }

    private Transaction getPreparedSendTx(String receiverAddress,
                                          Coin receiverAmount,
                                          BisqDefaultCoinSelector coinSelector)
            throws AddressFormatException, InsufficientBsqException, WalletException, TransactionVerificationException, BsqChangeBelowDustException {
        daoKillSwitch.assertDaoIsNotDisabled();
        Transaction tx = new Transaction(params);
        checkArgument(Restrictions.isAboveDust(receiverAmount),
                ""The amount is too low (dust limit)."");
        tx.addOutput(receiverAmount, Address.fromString(params, receiverAddress));
        try {
            var selection = coinSelector.select(receiverAmount, wallet.calculateAllSpendCandidates());
            var change = coinSelector.getChange(receiverAmount, selection);
            if (Restrictions.isAboveDust(change)) {
                tx.addOutput(change, getChangeAddress());
            } else if (!change.isZero()) {
                String msg = ""BSQ change output is below dust limit. outputValue="" + change.value / 100 + "" BSQ"";
                log.warn(msg);
                throw new BsqChangeBelowDustException(msg, change);
            }

            SendRequest sendRequest = SendRequest.forTx(tx);
            sendRequest.fee = Coin.ZERO;
            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;
            sendRequest.aesKey = aesKey;
            sendRequest.shuffleOutputs = false;
            sendRequest.signInputs = false;
            sendRequest.changeAddress = getChangeAddress();
            sendRequest.coinSelector = coinSelector;
            wallet.completeTx(sendRequest);
            checkWalletConsistency(wallet);
            verifyTransaction(tx);

            return tx;
        } catch (InsufficientMoneyException e) {
            log.error(""getPreparedSendTx: tx={}"", tx.toString());
            log.error(e.toString());
            throw new InsufficientBsqException(e.missing);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Burn fee txs
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction getPreparedTradeFeeTx(Coin fee) throws InsufficientBsqException {
        daoKillSwitch.assertDaoIsNotDisabled();

        Transaction tx = new Transaction(params);
        addInputsAndChangeOutputForTx(tx, fee, bsqCoinSelector);
        return tx;
    }

    // We create a tx with Bsq inputs for the fee and optional BSQ change output.
    // As the fee amount will be missing in the output those BSQ fees are burned.
    public Transaction getPreparedProposalTx(Coin fee) throws InsufficientBsqException {
        return getPreparedTxWithMandatoryBsqChangeOutput(fee);
    }

    public Transaction getPreparedIssuanceTx(Coin fee) throws InsufficientBsqException {
        return getPreparedTxWithMandatoryBsqChangeOutput(fee);
    }

    public Transaction getPreparedProofOfBurnTx(Coin fee) throws InsufficientBsqException {
        return getPreparedTxWithMandatoryBsqChangeOutput(fee);
    }

    public Transaction getPreparedBurnFeeTxForAssetListing(Coin fee) throws InsufficientBsqException {
        return getPreparedTxWithMandatoryBsqChangeOutput(fee);
    }

    // We need to require one BSQ change output as we could otherwise not be able to distinguish between 2
    // structurally same transactions where only the BSQ fee is different. In case of asset listing fee and proof of
    // burn it is a user input, so it is not known to the parser, instead we derive the burned fee from the parser.

    // In case of proposal fee we could derive it from the params.

    // For issuance txs we also require a BSQ change output before the issuance output gets added. There was a
    // minor bug with the old version that multiple inputs would have caused an exception in case there was no
    // change output (e.g. inputs of 21 and 6 BSQ for BSQ fee of 21 BSQ would have caused that only 1 input was used
    // and then caused an error as we enforced a change output. This new version handles such cases correctly.

    // Examples for the structurally indistinguishable transactions:
    // Case 1: 10 BSQ fee to burn
    // In: 17 BSQ
    // Out: BSQ change 7 BSQ -> valid BSQ
    // Out: OpReturn
    // Miner fee: 1000 sat  (10 BSQ burned)

    // Case 2: 17 BSQ fee to burn
    // In: 17 BSQ
    // Out: burned BSQ change 7 BSQ -> BTC (7 BSQ burned)
    // Out: OpReturn
    // Miner fee: 1000 sat  (10 BSQ burned)

    private Transaction getPreparedTxWithMandatoryBsqChangeOutput(Coin fee) throws InsufficientBsqException {
        daoKillSwitch.assertDaoIsNotDisabled();

        Transaction tx = new Transaction(params);
        // We look for inputs covering out BSQ fee we want to pay.
        CoinSelection coinSelection = bsqCoinSelector.select(fee, wallet.calculateAllSpendCandidates());
        try {
            Coin change = bsqCoinSelector.getChange(fee, coinSelection);
            if (change.isZero() || Restrictions.isDust(change)) {
                // If change is zero or below dust we increase required input amount to enforce a BSQ change output.
                // All outputs after that are considered BTC and therefore would be burned BSQ if BSQ is left from what
                // we use for miner fee.

                Coin minDustThreshold = Coin.valueOf(preferences.getIgnoreDustThreshold());
                Coin increasedRequiredInput = fee.add(minDustThreshold);
                coinSelection = bsqCoinSelector.select(increasedRequiredInput, wallet.calculateAllSpendCandidates());
                change = bsqCoinSelector.getChange(fee, coinSelection);

                log.warn(""We increased required input as change output was zero or dust: New change value={}"", change);
                String info = ""Available BSQ balance="" + coinSelection.valueGathered.value / 100 + "" BSQ. "" +
                        ""Intended fee to burn="" + fee.value / 100 + "" BSQ. "" +
                        ""Please increase your balance to at least "" + (fee.value + minDustThreshold.value) / 100 + "" BSQ."";
                checkArgument(coinSelection.valueGathered.compareTo(fee) > 0,
                        ""This transaction require a change output of at least "" + minDustThreshold.value / 100 + "" BSQ (dust limit). "" +
                                info);

                checkArgument(!Restrictions.isDust(change),
                        ""This transaction would create a dust output of "" + change.value / 100 + "" BSQ. "" +
                                ""It requires a change output of at least "" + minDustThreshold.value / 100 + "" BSQ (dust limit). "" +
                                info);
            }

            coinSelection.gathered.forEach(tx::addInput);
            tx.addOutput(change, getChangeAddress());

            return tx;

        } catch (InsufficientMoneyException e) {
            log.error(""coinSelection.gathered={}"", coinSelection.gathered);
            throw new InsufficientBsqException(e.missing);
        }
    }

    private void addInputsAndChangeOutputForTx(Transaction tx,
                                               Coin fee,
                                               BsqCoinSelector bsqCoinSelector)
            throws InsufficientBsqException {
        Coin requiredInput;
        // If our fee is less then dust limit we increase it so we are sure to not get any dust output.
        if (Restrictions.isDust(fee)) {
            requiredInput = fee.add(Restrictions.getMinNonDustOutput());
        } else {
            requiredInput = fee;
        }

        CoinSelection coinSelection = bsqCoinSelector.select(requiredInput, wallet.calculateAllSpendCandidates());
        coinSelection.gathered.forEach(tx::addInput);
        try {
            Coin change = bsqCoinSelector.getChange(fee, coinSelection);
            // Change can be ZERO, then no change output is created so don't rely on a BSQ change output
            if (change.isPositive()) {
                checkArgument(Restrictions.isAboveDust(change),
                        ""The change output of "" + change.value / 100d + "" BSQ is below the min. dust value of ""
                                + Restrictions.getMinNonDustOutput().value / 100d +
                                "". At least "" + Restrictions.getMinNonDustOutput().add(fee).value / 100d +
                                "" BSQ is needed for this transaction"");
                tx.addOutput(change, getChangeAddress());
            }
        } catch (InsufficientMoneyException e) {
            log.error(tx.toString());
            throw new InsufficientBsqException(e.missing);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // BsqSwap tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Tuple2<List<RawTransactionInput>, Coin> getBuyersBsqInputsForBsqSwapTx(Coin required)
            throws InsufficientBsqException {
        daoKillSwitch.assertDaoIsNotDisabled();
        // As unconfirmed BSQ inputs cannot be verified by the peer we can only use confirmed BSQ.
        boolean prev = bsqCoinSelector.isAllowSpendMyOwnUnconfirmedTxOutputs();
        bsqCoinSelector.setAllowSpendMyOwnUnconfirmedTxOutputs(false);
        CoinSelection coinSelection = bsqCoinSelector.select(required, wallet.calculateAllSpendCandidates());
        Coin change;
        try {
            change = bsqCoinSelector.getChange(required, coinSelection);
        } catch (InsufficientMoneyException e) {
            throw new InsufficientBsqException(e.missing);
        } finally {
            bsqCoinSelector.setAllowSpendMyOwnUnconfirmedTxOutputs(prev);
        }

        Transaction dummyTx = new Transaction(params);
        coinSelection.gathered.forEach(dummyTx::addInput);
        List<RawTransactionInput> inputs = dummyTx.getInputs().stream()
                .map(RawTransactionInput::new)
                .collect(Collectors.toList());
        return new Tuple2<>(inputs, change);
    }

    public void signBsqSwapTransaction(Transaction transaction, List<TransactionInput> myInputs)
            throws TransactionVerificationException {
        for (TransactionInput input : myInputs) {
            TransactionOutput connectedOutput = input.getConnectedOutput();
            checkNotNull(connectedOutput, ""connectedOutput must not be null"");
            checkArgument(connectedOutput.isMine(wallet), ""connectedOutput is not mine"");
            signTransactionInput(wallet, aesKey, transaction, input, input.getIndex());
            checkScriptSig(transaction, input, input.getIndex());
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Blind vote tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    // We create a tx with Bsq inputs for the fee, one output for the stake and optional one BSQ change output.
    // As the fee amount will be missing in the output those BSQ fees are burned.
    public Transaction getPreparedBlindVoteTx(Coin fee, Coin stake) throws InsufficientBsqException {
        daoKillSwitch.assertDaoIsNotDisabled();
        Transaction tx = new Transaction(params);
        tx.addOutput(new TransactionOutput(params, tx, stake, getUnusedAddress()));
        addInputsAndChangeOutputForTx(tx, fee.add(stake), bsqCoinSelector);
        //printTx(""getPreparedBlindVoteTx"", tx);
        return tx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // MyVote reveal tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction getPreparedVoteRevealTx(TxOutput stakeTxOutput) {
        daoKillSwitch.assertDaoIsNotDisabled();
        Transaction tx = new Transaction(params);
        final Coin stake = Coin.valueOf(stakeTxOutput.getValue());
        Transaction blindVoteTx = getTransaction(stakeTxOutput.getTxId());
        checkNotNull(blindVoteTx, ""blindVoteTx must not be null"");
        TransactionOutPoint outPoint = new TransactionOutPoint(params, stakeTxOutput.getIndex(), blindVoteTx);
        // Input is not signed yet so we use new byte[]{}
        tx.addInput(new TransactionInput(params, tx, new byte[]{}, outPoint, stake));
        tx.addOutput(new TransactionOutput(params, tx, stake, getUnusedAddress()));
        // printTx(""getPreparedVoteRevealTx"", tx);
        return tx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Lockup bond tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction getPreparedLockupTx(Coin lockupAmount) throws AddressFormatException, InsufficientBsqException {
        daoKillSwitch.assertDaoIsNotDisabled();
        Transaction tx = new Transaction(params);
        checkArgument(Restrictions.isAboveDust(lockupAmount), ""The amount is too low (dust limit)."");
        tx.addOutput(new TransactionOutput(params, tx, lockupAmount, getUnusedAddress()));
        addInputsAndChangeOutputForTx(tx, lockupAmount, bsqCoinSelector);
        printTx(""prepareLockupTx"", tx);
        return tx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Unlock bond tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction getPreparedUnlockTx(TxOutput lockupTxOutput) throws AddressFormatException {
        daoKillSwitch.assertDaoIsNotDisabled();
        Transaction tx = new Transaction(params);
        // Unlocking means spending the full value of the locked txOutput to another txOutput with the same value
        Coin amountToUnlock = Coin.valueOf(lockupTxOutput.getValue());
        checkArgument(Restrictions.isAboveDust(amountToUnlock), ""The amount is too low (dust limit)."");
        Transaction lockupTx = getTransaction(lockupTxOutput.getTxId());
        checkNotNull(lockupTx, ""lockupTx must not be null"");
        TransactionOutPoint outPoint = new TransactionOutPoint(params, lockupTxOutput.getIndex(), lockupTx);
        // Input is not signed yet so we use new byte[]{}
        tx.addInput(new TransactionInput(params, tx, new byte[]{}, outPoint, amountToUnlock));
        tx.addOutput(new TransactionOutput(params, tx, amountToUnlock, getUnusedAddress()));
        printTx(""prepareUnlockTx"", tx);
        return tx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Addresses
    ///////////////////////////////////////////////////////////////////////////////////////////

    private Address getChangeAddress() {
        return getUnusedAddress();
    }

    public Address getUnusedAddress() {
        return wallet.getIssuedReceiveAddresses().stream()
                .filter(address -> Script.ScriptType.P2WPKH.equals(address.getOutputScriptType()))
                .filter(this::isAddressUnused)
                .findAny()
                .orElse(wallet.freshReceiveAddress());
    }

    public String getUnusedBsqAddressAsString() {
        return ""B"" + getUnusedAddress().toString();
    }

    // For BSQ we do not check for dust attack utxos as they are 5.46 BSQ and a considerable value.
    // The default 546 sat dust limit is handled in the BitcoinJ side anyway.
    @Override
    protected boolean isDustAttackUtxo(TransactionOutput output) {
        return false;
    }
}",1,64 2000 439 334 2001 378 2002 395 2003 123 439 405 2004 123 492 2005 40 41 59 125 437 381 2006 2007 59 437 381 2008 2009 59 437 381 2010 2011 59 437 381 2012 2013 59 437 381 2014 2015 59 437 381 2016 60 2017 62 2018 61 418 2019 60 62 40 41 59 437 381 2020 60 2021 62 2022 61 418 2020 60 62 40 41 59 437 381 2016 60 2004 62 2023 61 418 2019 60 62 40 41 59 437 324 2024 59 64 2025 437 381 2026 2027 59 621 64 2025 437 2028 2029 61 2028 46 2030 59 64 2025 437 2028 2031 61 2028 46 2030 59 64 2025 437 2028 2032 61 2028 46 2030 59 64 2025 437 2028 2033 61 2028 46 2030 59 64 2025 437 2028 2034 61 2028 46 2030 59 64 2025 437 2028 2035 61 2028 46 2030 59 64 2025 437 2028 2036 61 2028 46 2030 59 64 2025 437 2028 2037 61 2028 46 2030 59 621 621 621 64 2038 439 2001 40 2039 2040 44 2008 2009 44 2010 2011 44 2012 2013 44 2014 2015 44 2041 2042 44 2043 2044 44 2006 2007 44 2026 2027 41 123 463 40 2040 44 2042 44 2044 41 59 467 46 2009 61 2009 59 467 46 2011 61 2011 59 467 46 2013 61 2013 59 467 46 2015 61 2015 59 467 46 2007 61 2007 59 467 46 2027 61 2027 59 2011 46 2045 40 2042 41 59 2040 46 2046 40 40 41 45 62 123 2047 61 2040 46 2048 40 41 59 392 40 2047 631 424 41 123 2047 46 2049 40 2009 41 59 2050 40 41 59 125 2051 2052 61 2040 46 2053 40 41 59 392 40 2052 631 424 41 123 2052 46 2054 40 2055 45 62 2056 46 2057 40 2055 46 2058 40 41 41 41 59 2056 46 2057 40 2052 46 2059 40 41 41 59 125 125 41 59 2013 46 2060 40 467 41 59 125 64 2061 438 492 2062 40 41 123 463 46 2062 40 41 59 2063 46 2064 40 40 2063 44 2065 44 2066 44 2067 41 45 62 2068 40 41 41 59 2063 46 2069 40 40 2063 44 2065 44 2066 44 2067 41 45 62 2068 40 41 41 59 2063 46 2070 40 2063 45 62 123 2071 46 2072 40 648 41 59 2068 40 41 59 2015 46 2073 40 41 59 125 41 59 2063 46 2074 40 40 2063 44 2065 41 45 62 123 621 621 621 392 40 2065 631 424 605 2065 46 2075 40 41 631 424 605 2065 46 2075 40 41 46 2076 40 41 620 1501 605 2013 46 2077 40 41 41 123 2068 40 41 59 125 2015 46 2078 40 2065 41 59 125 41 59 2063 46 2079 40 2080 45 62 2068 40 41 41 59 2063 46 2081 40 40 2063 44 2082 44 2083 41 45 62 2068 40 41 41 59 2063 46 2084 40 2063 45 62 2068 40 41 41 59 125 621 621 621 64 2061 439 492 2085 40 2086 2087 41 123 392 40 2088 40 41 41 123 2089 46 2090 40 380 41 46 2091 40 2015 58 58 2092 41 59 2093 40 41 59 125 125 621 621 621 64 2061 2094 2095 40 324 2096 41 123 450 2097 46 2098 40 473 44 2096 44 467 46 2099 44 473 44 473 44 2040 46 2100 40 41 41 43 648 43 648 43 2097 46 2101 40 41 59 125 621 621 621 437 492 2102 40 41 123 413 2103 61 2104 46 2105 40 41 59 2032 61 2028 46 2106 40 2107 40 380 41 46 2108 40 41 46 2109 40 2110 45 62 2110 46 2111 40 41 46 2112 40 41 614 2113 41 46 2114 40 2110 45 62 123 621 621 621 413 2115 61 2110 46 2116 40 41 46 2108 40 41 46 2109 40 430 45 62 430 46 2117 40 2118 41 41 46 2109 40 2119 58 58 2120 41 46 2114 40 430 45 62 430 46 2121 40 41 46 2122 41 46 2123 40 41 59 621 413 2124 61 2110 46 2125 40 41 46 2108 40 41 46 2109 40 398 45 62 123 2119 2126 61 398 46 2127 40 41 59 392 40 2126 631 424 41 123 2017 2128 61 2126 46 2129 40 41 59 621 392 40 2128 631 424 604 41 123 2130 2131 61 418 2130 40 2128 46 2132 40 41 46 2133 40 41 44 2126 46 2134 40 41 41 59 450 40 2126 46 2117 40 2118 41 605 40 2013 46 2135 40 2131 41 606 2013 46 2136 40 2131 41 41 41 59 125 125 450 380 59 125 41 46 2114 40 398 45 62 398 46 2121 40 41 631 424 63 398 46 2121 40 41 46 2122 58 1500 41 46 2123 40 41 59 450 2115 45 2124 59 125 41 46 2137 40 41 41 59 2138 60 2094 62 2139 61 2107 40 380 41 46 2108 40 41 46 2109 40 2110 45 62 2110 46 2111 40 41 46 2112 40 41 614 2140 41 46 2141 40 2017 58 58 2142 41 46 2141 40 2143 58 58 2144 41 46 2145 40 2146 46 2147 40 41 41 59 2035 61 2028 46 2106 40 2013 46 2148 40 41 46 2108 40 41 46 2109 40 2149 45 62 2139 46 2150 40 2149 46 2142 40 41 41 41 46 2114 40 2151 58 58 2152 41 46 2137 40 41 41 59 2036 61 2028 46 2106 40 2013 46 2153 40 41 46 2108 40 41 46 2109 40 2149 45 62 2013 46 2154 40 2149 46 2155 40 41 41 41 46 2109 40 2149 45 62 33 2013 46 2156 40 2149 46 2142 40 41 41 41 46 2109 40 2149 45 62 2139 46 2150 40 2149 46 2142 40 41 41 41 46 2114 40 2151 58 58 2152 41 46 2137 40 41 41 59 2037 61 2028 46 2106 40 2013 46 2157 40 41 46 2109 40 2149 45 62 2139 46 2150 40 2149 46 2142 40 41 41 41 46 2109 40 2149 45 62 33 2013 46 2158 40 2149 46 2142 40 41 41 41 46 2114 40 2151 58 58 2152 41 46 2137 40 41 41 59 2031 61 2009 46 2159 40 2160 46 2161 44 2162 46 2163 40 41 41 46 2164 59 392 40 2031 46 2165 40 41 41 2031 61 2028 46 2030 59 2034 61 2015 46 2166 40 41 59 2029 61 2011 46 2159 40 2160 46 2161 44 2162 46 2163 40 41 41 46 2164 59 2033 61 2031 46 2167 40 2034 41 59 2022 46 2168 40 2169 45 62 2169 46 2170 40 2031 44 2029 44 2032 44 2034 44 2035 44 2036 44 2037 41 41 59 2171 46 2172 40 648 44 2104 46 2105 40 41 45 2103 41 59 125 439 492 2173 40 2021 2174 41 123 2022 46 2175 40 2174 41 59 125 439 492 2176 40 2021 2174 41 123 2022 46 2177 40 2174 41 59 125 439 492 2178 40 2004 2174 41 123 2023 46 2179 40 2174 41 59 125 439 492 2180 40 2004 2174 41 123 2023 46 2181 40 2174 41 59 125 439 2016 60 2182 62 2183 40 41 123 450 418 2019 60 62 40 2009 46 2184 40 2185 46 2186 44 2187 46 2188 40 41 41 46 2189 41 59 125 439 2016 60 2182 62 2190 40 41 123 450 418 2019 60 62 40 2011 46 2191 40 2192 46 2193 44 2194 46 2195 40 41 41 46 2196 41 59 125 621 621 621 439 2016 60 2017 62 2197 40 41 123 450 418 2019 60 62 40 2018 41 59 125 439 2198 60 2017 62 2199 40 41 123 450 2018 46 2200 40 41 46 2201 40 2202 45 62 2202 46 2203 40 41 46 2204 40 41 614 2205 46 2206 46 2207 41 59 125 437 492 2208 40 41 123 392 40 2013 46 2209 40 41 41 123 621 621 621 621 392 40 33 2024 41 123 2024 61 473 59 2210 46 2211 40 40 41 45 62 123 2018 46 2212 40 41 59 2018 46 2213 40 2214 40 380 41 41 59 2023 46 2215 40 2004 58 58 2216 41 59 2102 40 41 59 2024 61 380 59 125 44 1503 44 2217 46 2218 41 59 125 125 125 437 2219 60 2017 62 2220 40 41 123 450 2221 40 380 41 46 2222 40 41 46 2223 40 2224 45 62 2224 46 2225 40 41 46 2226 40 41 614 2227 606 2013 46 2228 40 2224 46 2229 40 41 46 2230 40 41 41 41 46 2231 40 2232 46 2233 40 41 41 59 125 439 2219 60 2017 62 2234 40 41 123 2219 60 2017 62 2235 61 2220 40 41 59 2219 60 2017 62 2236 61 418 2237 60 62 40 2238 40 380 41 41 59 2239 40 2236 46 2240 40 41 615 2235 46 2240 40 41 44 648 41 59 392 40 2236 46 2240 40 41 614 2235 46 2240 40 41 41 123 621 450 418 2237 60 62 40 41 59 125 360 123 2241 60 2094 44 2017 62 2242 61 2236 46 2243 40 41 46 2244 40 2245 46 2246 40 2247 45 62 2247 46 2248 40 41 46 2249 40 41 44 2250 46 2251 40 41 41 41 59 2219 60 2094 62 2252 61 2236 46 2243 40 41 46 2242 40 2017 58 58 2248 41 46 2242 40 2253 58 58 2249 41 46 2244 40 2245 46 2254 40 41 41 59 2219 60 2094 62 2255 61 2235 46 2243 40 41 46 2242 40 2017 58 58 2248 41 46 2242 40 2253 58 58 2249 41 46 2244 40 2245 46 2254 40 41 41 59 2252 46 2243 40 41 46 2256 40 2255 58 58 2257 41 46 2258 40 2242 58 58 2259 41 59 450 418 2237 60 62 40 2242 46 2260 40 41 41 59 125 125 64 2061 439 2028 2261 40 2017 2262 41 470 2263 123 2028 2264 61 2028 46 2030 59 621 385 40 404 2265 61 1500 59 2265 60 2262 46 2266 40 41 46 2267 40 41 59 2265 637 41 123 2268 2269 61 2262 46 2266 40 41 46 2270 40 2265 41 59 621 2182 2271 61 2269 46 2272 40 41 59 392 40 2271 631 424 41 123 621 381 2017 2273 61 2271 46 2274 40 41 59 381 324 2275 61 2273 631 424 605 2273 46 2276 40 41 46 2277 40 41 614 2278 46 2279 46 2280 59 392 40 2271 46 2281 40 2282 41 41 123 392 40 2275 41 123 621 621 2283 60 2284 62 2285 61 2013 46 2286 40 2273 46 2287 40 41 46 2288 40 41 41 59 392 40 2285 46 2289 40 41 41 123 2290 2291 61 2285 46 2270 40 41 46 2292 40 41 46 2270 40 2271 46 2293 40 41 41 59 392 40 2013 46 2294 40 2291 41 41 123 621 392 40 2291 46 2295 40 41 631 2271 46 2295 40 41 46 2296 41 2297 46 2298 40 648 43 648 44 2291 46 2295 40 41 44 2271 46 2295 40 41 46 2296 44 2285 46 2270 40 41 46 2299 40 41 41 59 621 2264 61 2264 46 2300 40 2028 46 2301 40 2291 46 2295 40 41 41 41 59 125 125 125 604 125 125 125 450 2264 59 125 64 2061 439 2028 2302 40 2017 2262 41 470 2263 123 2028 2303 61 2028 46 2030 59 381 2094 2304 61 2262 46 2305 40 41 46 2306 40 41 59 621 2307 60 2308 62 2309 61 2013 46 2310 40 2304 41 59 621 385 40 404 2311 61 1500 59 2311 60 2262 46 2312 40 41 46 2313 40 41 59 2311 637 41 123 2182 2314 61 2262 46 2312 40 41 46 2315 40 2311 41 59 381 324 2316 61 2314 46 2317 40 41 631 424 605 2314 46 2317 40 41 46 2318 40 41 46 2319 40 41 614 2320 46 2321 46 2322 59 392 40 2314 46 2323 40 2324 41 41 123 392 40 2316 41 123 392 40 2309 46 2325 40 41 41 123 621 2326 2327 61 2309 46 2315 40 41 46 2328 40 41 46 2315 40 2311 41 59 392 40 2013 46 2329 40 2327 41 41 123 621 392 40 2327 46 2330 40 41 631 2314 46 2330 40 41 46 2331 41 123 2332 46 2333 40 648 43 648 44 2327 46 2330 40 41 44 2314 46 2330 40 41 46 2331 44 2304 41 59 125 621 2303 61 2303 46 2334 40 2028 46 2335 40 2327 46 2330 40 41 41 41 59 125 125 125 604 125 125 450 2303 59 125 439 2336 60 2017 62 2337 40 2094 2338 41 123 450 2018 46 2339 40 41 46 2340 40 2341 45 62 2341 46 2342 40 41 46 2343 40 41 46 2344 40 2338 41 41 46 2345 40 41 59 125 621 621 621 439 2017 2346 40 2017 2347 41 470 2348 44 2349 123 2002 46 2350 40 2351 44 2352 44 2347 41 59 2002 46 2353 40 2347 41 59 450 2347 59 125 621 621 621 439 492 2354 40 2017 2347 44 2355 2356 41 123 2357 46 2354 40 2347 41 59 621 2015 46 2358 40 2347 44 2356 44 2357 41 59 125 621 621 621 439 2017 2359 40 2094 2360 44 2028 2361 41 470 2362 44 2363 44 2348 44 2349 44 2364 123 450 2365 40 2360 44 2361 44 2009 41 59 125 439 2017 2359 40 2094 2360 44 2028 2361 44 64 2366 2219 60 2182 62 2367 41 470 2362 44 2363 44 2348 44 2349 44 2364 123 392 40 2367 631 424 41 123 2009 46 2368 40 2367 41 59 125 450 2369 40 2360 44 2361 44 2009 41 59 125 621 621 621 439 2017 2370 40 2094 2360 44 2028 2361 41 470 2362 44 2363 44 2348 44 2349 44 2364 123 450 2371 40 2360 44 2361 44 2011 41 59 125 439 2017 2370 40 2094 2360 44 2028 2361 44 64 2366 2219 60 2182 62 2367 41 470 2362 44 2363 44 2348 44 2349 44 2364 123 392 40 2367 631 424 41 123 2011 46 2372 40 2367 41 59 125 450 2373 40 2360 44 2361 44 2011 41 59 125 437 2017 2374 40 2094 2360 44 2028 2361 44 2375 2376 41 470 2362 44 2363 44 2348 44 2349 44 2364 123 2007 46 2377 40 41 59 2017 2347 61 418 2017 40 433 41 59 2378 40 2379 46 2380 40 2361 41 44 648 41 59 2347 46 2381 40 2361 44 2382 46 2383 40 433 44 2360 41 41 59 474 123 490 2384 61 2376 46 2385 40 2361 44 2386 46 2387 40 41 41 59 490 2388 61 2376 46 2389 40 2361 44 2384 41 59 392 40 2379 46 2380 40 2388 41 41 123 2347 46 2381 40 2388 44 2390 40 41 41 59 125 360 392 40 33 2388 46 2391 40 41 41 123 2094 2392 61 648 43 2388 46 2393 47 1503 43 648 59 2394 46 2395 40 2392 41 59 469 418 2364 40 2392 44 2388 41 59 125 2396 2397 61 2396 46 2398 40 2347 41 59 2397 46 2399 61 2028 46 2030 59 2397 46 2400 61 2028 46 2030 59 2397 46 2401 61 380 59 2397 46 2402 61 2402 59 2397 46 2403 61 380 59 2397 46 2404 61 380 59 2397 46 2405 61 2406 40 41 59 2397 46 2376 61 2376 59 2386 46 2407 40 2397 41 59 2408 40 2386 41 59 2409 40 2347 41 59 450 2347 59 125 329 40 2410 2411 41 123 2412 46 371 40 648 44 2347 46 2413 40 41 41 59 2412 46 371 40 2411 46 2413 40 41 41 59 469 418 2363 40 2411 46 2414 41 59 125 125 621 621 621 439 2017 2415 40 2028 2416 41 470 2363 123 2007 46 2417 40 41 59 2017 2347 61 418 2017 40 433 41 59 2418 40 2347 44 2416 44 2009 41 59 450 2347 59 125 621 621 439 2017 2419 40 2028 2416 41 470 2363 123 450 2420 40 2416 41 59 125 439 2017 2421 40 2028 2416 41 470 2363 123 450 2422 40 2416 41 59 125 439 2017 2423 40 2028 2416 41 470 2363 123 450 2424 40 2416 41 59 125 439 2017 2425 40 2028 2416 41 470 2363 123 450 2426 40 2416 41 59 125 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 437 2017 2427 40 2028 2416 41 470 2363 123 2007 46 2428 40 41 59 2017 2347 61 418 2017 40 433 41 59 621 2429 2430 61 2009 46 2431 40 2416 44 2432 46 2433 40 41 41 59 474 123 2028 2434 61 2009 46 2435 40 2416 44 2430 41 59 392 40 2434 46 2436 40 41 606 2437 46 2438 40 2434 41 41 123 621 621 621 2028 2439 61 2028 46 2440 40 2042 46 2441 40 41 41 59 2028 2442 61 2416 46 2443 40 2439 41 59 2430 61 2009 46 2431 40 2442 44 2432 46 2433 40 41 41 59 2434 61 2009 46 2435 40 2416 44 2430 41 59 2444 46 2445 40 648 44 2434 41 59 2094 2446 61 648 43 2430 46 2447 46 2448 47 1503 43 648 43 648 43 2416 46 2448 47 1503 43 648 43 648 43 40 2416 46 2448 43 2439 46 2448 41 47 1503 43 648 59 2449 40 2430 46 2447 46 2450 40 2416 41 62 1500 44 648 43 2439 46 2448 47 1503 43 648 43 2446 41 59 2449 40 33 2437 46 2438 40 2434 41 44 648 43 2434 46 2448 47 1503 43 648 43 648 43 2439 46 2448 47 1503 43 648 43 2446 41 59 125 2430 46 2451 46 2452 40 2347 58 58 2453 41 59 2347 46 2454 40 2434 44 2455 40 41 41 59 450 2347 59 125 329 40 2456 2457 41 123 2458 46 371 40 648 44 2430 46 2459 41 59 469 418 2363 40 2457 46 2460 41 59 125 125 437 492 2461 40 2017 2347 44 2028 2416 44 2008 2009 41 470 2363 123 2028 2462 59 621 392 40 2463 46 2464 40 2416 41 41 123 2462 61 2416 46 2465 40 2463 46 2466 40 41 41 59 125 360 123 2462 61 2416 59 125 2467 2468 61 2009 46 2469 40 2462 44 2470 46 2471 40 41 41 59 2468 46 2472 46 2473 40 2347 58 58 2474 41 59 474 123 2028 2475 61 2009 46 2476 40 2416 44 2468 41 59 621 392 40 2475 46 2477 40 41 41 123 2478 40 2463 46 2479 40 2475 41 44 648 43 2475 46 2480 47 1503 43 648 43 2463 46 2481 40 41 46 2480 47 1503 43 648 43 2463 46 2481 40 41 46 2482 40 2416 41 46 2480 47 1503 43 648 41 59 2347 46 2483 40 2475 44 2484 40 41 41 59 125 125 329 40 2485 2486 41 123 2487 46 371 40 2347 46 2488 40 41 41 59 469 418 2363 40 2486 46 2489 41 59 125 125 621 621 621 439 2490 60 2016 60 2491 62 44 2028 62 2492 40 2028 2493 41 470 2363 123 2007 46 2494 40 41 59 621 324 2495 61 2009 46 2496 40 41 59 2009 46 2497 40 380 41 59 2498 2499 61 2009 46 2500 40 2493 44 2501 46 2502 40 41 41 59 2028 2503 59 474 123 2503 61 2009 46 2504 40 2493 44 2499 41 59 125 329 40 2505 2506 41 123 469 418 2363 40 2506 46 2507 41 59 125 382 123 2009 46 2497 40 2495 41 59 125 2017 2508 61 418 2017 40 433 41 59 2499 46 2509 46 2510 40 2508 58 58 2511 41 59 2016 60 2491 62 2512 61 2508 46 2513 40 41 46 2514 40 41 46 2515 40 2491 58 58 418 41 46 2516 40 2517 46 2518 40 41 41 59 450 418 2490 60 62 40 2512 44 2503 41 59 125 439 492 2519 40 2017 2262 44 2016 60 2520 62 2521 41 470 2349 123 385 40 2520 2522 58 2521 41 123 2182 2523 61 2522 46 2524 40 41 59 2525 40 2523 44 648 41 59 2526 40 2523 46 2527 40 2528 41 44 648 41 59 2529 40 2528 44 2530 44 2262 44 2522 44 2522 46 2531 40 41 41 59 2532 40 2262 44 2522 44 2522 46 2531 40 41 41 59 125 125 621 621 621 621 621 439 2017 2533 40 2028 2416 44 2028 2534 41 470 2363 123 2007 46 2535 40 41 59 2017 2347 61 418 2017 40 433 41 59 2347 46 2536 40 418 2182 40 433 44 2347 44 2534 44 2537 40 41 41 41 59 2461 40 2347 44 2416 46 2538 40 2534 41 44 2009 41 59 621 450 2347 59 125 621 621 621 439 2017 2539 40 2540 2541 41 123 2007 46 2542 40 41 59 2017 2347 61 418 2017 40 433 41 59 381 2028 2534 61 2028 46 2543 40 2541 46 2544 40 41 41 59 2017 2545 61 2546 40 2541 46 2547 40 41 41 59 2548 40 2545 44 648 41 59 2549 2550 61 418 2549 40 433 44 2541 46 2551 40 41 44 2545 41 59 621 2347 46 2552 40 418 2520 40 433 44 2347 44 418 326 91 93 123 125 44 2550 44 2534 41 41 59 2347 46 2553 40 418 2182 40 433 44 2347 44 2534 44 2554 40 41 41 41 59 621 450 2347 59 125 621 621 621 439 2017 2555 40 2028 2556 41 470 2362 44 2363 123 2007 46 2557 40 41 59 2017 2347 61 418 2017 40 433 41 59 2558 40 2559 46 2560 40 2556 41 44 648 41 59 2347 46 2561 40 418 2182 40 433 44 2347 44 2556 44 2562 40 41 41 41 59 2461 40 2347 44 2556 44 2009 41 59 2563 40 648 44 2347 41 59 450 2347 59 125 621 621 621 439 2017 2564 40 2540 2565 41 470 2362 123 2007 46 2566 40 41 59 2017 2347 61 418 2017 40 433 41 59 621 2028 2567 61 2028 46 2568 40 2565 46 2569 40 41 41 59 2570 40 2571 46 2572 40 2567 41 44 648 41 59 2017 2573 61 2574 40 2565 46 2575 40 41 41 59 2576 40 2573 44 648 41 59 2577 2578 61 418 2577 40 433 44 2565 46 2579 40 41 44 2573 41 59 621 2347 46 2580 40 418 2520 40 433 44 2347 44 418 326 91 93 123 125 44 2578 44 2567 41 41 59 2347 46 2581 40 418 2182 40 433 44 2347 44 2567 44 2582 40 41 41 41 59 2583 40 648 44 2347 41 59 450 2347 59 125 621 621 621 437 2584 2585 40 41 123 450 2586 40 41 59 125 439 2584 2587 40 41 123 450 2588 46 2589 40 41 46 2590 40 41 46 2591 40 2592 45 62 2593 46 2594 46 2595 46 2596 40 2592 46 2597 40 41 41 41 46 2591 40 467 58 58 2598 41 46 2599 40 41 46 2600 40 2588 46 2601 40 41 41 59 125 439 2094 2602 40 41 123 450 648 43 2587 40 41 46 2603 40 41 59 125 621 621 64 2061 438 324 2604 40 2182 2605 41 123 450 380 59 125 125 
3680,Java,"@Slf4j
class OfferBookViewModel extends ActivatableViewModel {
    private final OpenOfferManager openOfferManager;
    private final User user;
    private final OfferBook offerBook;
    final Preferences preferences;
    private final WalletsSetup walletsSetup;
    private final P2PService p2PService;
    final PriceFeedService priceFeedService;
    private final ClosedTradableManager closedTradableManager;
    final AccountAgeWitnessService accountAgeWitnessService;
    private final Navigation navigation;
    private final PriceUtil priceUtil;
    final OfferFilterService offerFilterService;
    private final CoinFormatter btcFormatter;
    private final BsqFormatter bsqFormatter;

    private final FilteredList<OfferBookListItem> filteredItems;
    private final BsqWalletService bsqWalletService;
    private final CoreApi coreApi;
    private final SortedList<OfferBookListItem> sortedItems;
    private final ListChangeListener<TradeCurrency> tradeCurrencyListChangeListener;
    private final ListChangeListener<OfferBookListItem> filterItemsListener;
    private TradeCurrency selectedTradeCurrency;
    private final ObservableList<TradeCurrency> allTradeCurrencies = FXCollections.observableArrayList();

    private OfferDirection direction;

    final StringProperty tradeCurrencyCode = new SimpleStringProperty();

    private OfferView.OfferActionHandler offerActionHandler;

    // If id is empty string we ignore filter (display all methods)

    PaymentMethod selectedPaymentMethod = getShowAllEntryForPaymentMethod();

    private boolean isTabSelected;
    final BooleanProperty showAllTradeCurrenciesProperty = new SimpleBooleanProperty(true);
    final BooleanProperty disableMatchToggle = new SimpleBooleanProperty();
    final IntegerProperty maxPlacesForAmount = new SimpleIntegerProperty();
    final IntegerProperty maxPlacesForVolume = new SimpleIntegerProperty();
    final IntegerProperty maxPlacesForPrice = new SimpleIntegerProperty();
    final IntegerProperty maxPlacesForMarketPriceMargin = new SimpleIntegerProperty();
    boolean showAllPaymentMethods = true;
    boolean useOffersMatchingMyAccountsFilter;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public OfferBookViewModel(User user,
                              OpenOfferManager openOfferManager,
                              OfferBook offerBook,
                              Preferences preferences,
                              WalletsSetup walletsSetup,
                              P2PService p2PService,
                              PriceFeedService priceFeedService,
                              ClosedTradableManager closedTradableManager,
                              AccountAgeWitnessService accountAgeWitnessService,
                              Navigation navigation,
                              PriceUtil priceUtil,
                              OfferFilterService offerFilterService,
                              @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter btcFormatter,
                              BsqFormatter bsqFormatter,
                              BsqWalletService bsqWalletService,
                              CoreApi coreApi) {
        super();

        this.openOfferManager = openOfferManager;
        this.user = user;
        this.offerBook = offerBook;
        this.preferences = preferences;
        this.walletsSetup = walletsSetup;
        this.p2PService = p2PService;
        this.priceFeedService = priceFeedService;
        this.closedTradableManager = closedTradableManager;
        this.accountAgeWitnessService = accountAgeWitnessService;
        this.navigation = navigation;
        this.priceUtil = priceUtil;
        this.offerFilterService = offerFilterService;
        this.btcFormatter = btcFormatter;
        this.bsqFormatter = bsqFormatter;

        this.filteredItems = new FilteredList<>(offerBook.getOfferBookListItems());
        this.bsqWalletService = bsqWalletService;
        this.coreApi = coreApi;
        this.sortedItems = new SortedList<>(filteredItems);

        tradeCurrencyListChangeListener = c -> fillAllTradeCurrencies();

        filterItemsListener = c -> {
            final Optional<OfferBookListItem> highestAmountOffer = filteredItems.stream()
                    .max(Comparator.comparingLong(o -> o.getOffer().getAmount().getValue()));

            final boolean containsRangeAmount = filteredItems.stream().anyMatch(o -> o.getOffer().isRange());

            if (highestAmountOffer.isPresent()) {
                final OfferBookListItem item = highestAmountOffer.get();
                if (!item.getOffer().isRange() && containsRangeAmount) {
                    maxPlacesForAmount.set(formatAmount(item.getOffer(), false)
                            .length() * 2 + FormattingUtils.RANGE_SEPARATOR.length());
                    maxPlacesForVolume.set(formatVolume(item.getOffer(), false)
                            .length() * 2 + FormattingUtils.RANGE_SEPARATOR.length());
                } else {
                    maxPlacesForAmount.set(formatAmount(item.getOffer(), false).length());
                    maxPlacesForVolume.set(formatVolume(item.getOffer(), false).length());
                }

            }

            final Optional<OfferBookListItem> highestPriceOffer = filteredItems.stream()
                    .filter(o -> o.getOffer().getPrice() != null)
                    .max(Comparator.comparingLong(o -> o.getOffer().getPrice() != null ? o.getOffer().getPrice().getValue() : 0));

            highestPriceOffer.ifPresent(offerBookListItem -> maxPlacesForPrice.set(formatPrice(offerBookListItem.getOffer(), false).length()));

            final Optional<OfferBookListItem> highestMarketPriceMarginOffer = filteredItems.stream()
                    .filter(o -> o.getOffer().isUseMarketBasedPrice())
                    .max(Comparator.comparing(o -> new DecimalFormat(""#0.00"").format(o.getOffer().getMarketPriceMargin() * 100).length()));

            highestMarketPriceMarginOffer.ifPresent(offerBookListItem -> maxPlacesForMarketPriceMargin.set(formatMarketPriceMargin(offerBookListItem.getOffer()).length()));
        };
    }

    @Override
    protected void activate() {
        filteredItems.addListener(filterItemsListener);

        updateSelectedTradeCurrency();

        if (user != null) {
            disableMatchToggle.set(user.getPaymentAccounts() == null || user.getPaymentAccounts().isEmpty());
        }
        useOffersMatchingMyAccountsFilter = !disableMatchToggle.get() && isShowOffersMatchingMyAccounts();

        fillAllTradeCurrencies();
        preferences.getTradeCurrenciesAsObservable().addListener(tradeCurrencyListChangeListener);
        offerBook.fillOfferBookListItems();
        filterOffers();
        setMarketPriceFeedCurrency();

        priceUtil.recalculateBsq30DayAveragePrice();
    }

    @Override
    protected void deactivate() {
        filteredItems.removeListener(filterItemsListener);
        preferences.getTradeCurrenciesAsObservable().removeListener(tradeCurrencyListChangeListener);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    void initWithDirection(OfferDirection direction) {
        this.direction = direction;
    }

    void onTabSelected(boolean isSelected) {
        this.isTabSelected = isSelected;
        setMarketPriceFeedCurrency();

        if (isTabSelected) {
            updateSelectedTradeCurrency();
            filterOffers();
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // UI actions
    ///////////////////////////////////////////////////////////////////////////////////////////

    void onSetTradeCurrency(TradeCurrency tradeCurrency) {
        if (tradeCurrency != null) {
            String code = tradeCurrency.getCode();
            boolean showAllEntry = isShowAllEntry(code);
            showAllTradeCurrenciesProperty.set(showAllEntry);
            if (isEditEntry(code))
                navigation.navigateTo(MainView.class, SettingsView.class, PreferencesView.class);
            else if (!showAllEntry) {
                this.selectedTradeCurrency = tradeCurrency;
                tradeCurrencyCode.set(code);
            }

            setMarketPriceFeedCurrency();
            filterOffers();

            if (direction == OfferDirection.BUY)
                preferences.setBuyScreenCurrencyCode(code);
            else
                preferences.setSellScreenCurrencyCode(code);
        }
    }

    void onSetPaymentMethod(PaymentMethod paymentMethod) {
        if (paymentMethod == null)
            return;

        showAllPaymentMethods = isShowAllEntry(paymentMethod.getId());
        if (!showAllPaymentMethods) {
            this.selectedPaymentMethod = paymentMethod;

            // If we select TransferWise we switch to show all currencies as TransferWise supports
            // sending to most currencies.
            if (paymentMethod.getId().equals(PaymentMethod.TRANSFERWISE_ID)) {
                onSetTradeCurrency(getShowAllEntryForCurrency());
            }
        } else {
            this.selectedPaymentMethod = getShowAllEntryForPaymentMethod();
        }

        filterOffers();
    }

    void onRemoveOpenOffer(Offer offer, ResultHandler resultHandler, ErrorMessageHandler errorMessageHandler) {
        openOfferManager.removeOffer(offer, resultHandler, errorMessageHandler);
    }

    void onShowOffersMatchingMyAccounts(boolean isSelected) {
        useOffersMatchingMyAccountsFilter = isSelected;
        preferences.setShowOffersMatchingMyAccounts(useOffersMatchingMyAccountsFilter);
        filterOffers();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    ///////////////////////////////////////////////////////////////////////////////////////////

    boolean isShowOffersMatchingMyAccounts() {
        return preferences.isShowOffersMatchingMyAccounts();
    }

    SortedList<OfferBookListItem> getOfferList() {
        return sortedItems;
    }

    Map<String, Integer> getBuyOfferCounts() {
        return offerBook.getBuyOfferCountMap();
    }

    Map<String, Integer> getSellOfferCounts() {
        return offerBook.getSellOfferCountMap();
    }

    boolean isMyOffer(Offer offer) {
        return openOfferManager.isMyOffer(offer);
    }

    OfferDirection getDirection() {
        return direction;
    }

    public ObservableList<TradeCurrency> getTradeCurrencies() {
        return allTradeCurrencies;
    }

    boolean isBootstrappedOrShowPopup() {
        return GUIUtil.isBootstrappedOrShowPopup(p2PService);
    }

    TradeCurrency getSelectedTradeCurrency() {
        return selectedTradeCurrency;
    }

    ObservableList<PaymentMethod> getPaymentMethods() {
        ObservableList<PaymentMethod> list = FXCollections.observableArrayList(PaymentMethod.getPaymentMethods());
        if (preferences.isHideNonAccountPaymentMethods() && user.getPaymentAccounts() != null) {
            Set<PaymentMethod> supportedPaymentMethods = user.getPaymentAccounts().stream()
                    .map(PaymentAccount::getPaymentMethod).collect(Collectors.toSet());
            if (!supportedPaymentMethods.isEmpty()) {
                list = FXCollections.observableArrayList(supportedPaymentMethods);
            }
        }

        list.sort(Comparator.naturalOrder());
        list.add(0, getShowAllEntryForPaymentMethod());
        return list;
    }

    String getAmount(OfferBookListItem item) {
        return formatAmount(item.getOffer(), true);
    }

    private String formatAmount(Offer offer, boolean decimalAligned) {
        return DisplayUtils.formatAmount(offer, GUIUtil.AMOUNT_DECIMALS, decimalAligned, maxPlacesForAmount.get(), btcFormatter);
    }


    String getPrice(OfferBookListItem item) {
        if ((item == null)) {
            return """";
        }

        Offer offer = item.getOffer();
        Price price = offer.getPrice();
        if (price != null) {
            return formatPrice(offer, true);
        } else {
            return Res.get(""shared.na"");
        }
    }

    String getAbsolutePriceMargin(Offer offer) {
        return FormattingUtils.formatPercentagePrice(Math.abs(offer.getMarketPriceMargin()));
    }

    private String formatPrice(Offer offer, boolean decimalAligned) {
        return DisplayUtils.formatPrice(offer.getPrice(), decimalAligned, maxPlacesForPrice.get());
    }

    String getPriceAsPercentage(OfferBookListItem item) {
        return getMarketBasedPrice(item.getOffer())
                .map(price -> ""("" + FormattingUtils.formatPercentagePrice(price) + "")"")
                .orElse("""");
    }

    public Optional<Double> getMarketBasedPrice(Offer offer) {
        return priceUtil.getMarketBasedPrice(offer, direction);
    }

    String formatMarketPriceMargin(Offer offer) {
        String postFix = """";
        if (offer.isUseMarketBasedPrice()) {
            postFix = "" ("" + FormattingUtils.formatPercentagePrice(offer.getMarketPriceMargin()) + "")"";
        }

        return postFix;
    }

    String getVolume(OfferBookListItem item) {
        return formatVolume(item.getOffer(), true);
    }

    private String formatVolume(Offer offer, boolean decimalAligned) {
        Volume offerVolume = offer.getVolume();
        Volume minOfferVolume = offer.getMinVolume();
        if (offerVolume != null && minOfferVolume != null) {
            String postFix = showAllTradeCurrenciesProperty.get() ? "" "" + offer.getCurrencyCode() : """";
            decimalAligned = decimalAligned && !showAllTradeCurrenciesProperty.get();
            return VolumeUtil.formatVolume(offer, decimalAligned, maxPlacesForVolume.get()) + postFix;
        } else {
            return Res.get(""shared.na"");
        }
    }

    int getNumberOfDecimalsForVolume(OfferBookListItem item) {
        return CurrencyUtil.isFiatCurrency(item.getOffer().getCurrencyCode()) ? GUIUtil.FIAT_DECIMALS_WITH_ZEROS : GUIUtil.ALTCOINS_DECIMALS_WITH_ZEROS;
    }

    String getPaymentMethod(OfferBookListItem item) {
        String result = """";
        if (item != null) {
            Offer offer = item.getOffer();
            String method = Res.get(offer.getPaymentMethod().getId() + ""_SHORT"");
            String methodCountryCode = offer.getCountryCode();
            if (isF2F(offer)) {
                result = method + "" ("" + methodCountryCode + "", "" + offer.getF2FCity() + "")"";
            } else {
                if (methodCountryCode != null)
                    result = method + "" ("" + methodCountryCode + "")"";
                else
                    result = method;
            }

        }
        return result;
    }

    String getPaymentMethodToolTip(OfferBookListItem item) {
        String result = """";
        if (item != null) {
            Offer offer = item.getOffer();
            result = Res.getWithCol(""shared.paymentMethod"") + "" "" + Res.get(offer.getPaymentMethod().getId());
            result += ""\n"" + Res.getWithCol(""shared.currency"") + "" "" + CurrencyUtil.getNameAndCode(offer.getCurrencyCode());

            if (offer.isXmr()) {
                String isAutoConf = offer.isXmrAutoConf() ?
                        Res.get(""shared.yes"") :
                        Res.get(""shared.no"");
                result += ""\n"" + Res.getWithCol(""offerbook.xmrAutoConf"") + "" "" + isAutoConf;
            }

            String countryCode = offer.getCountryCode();
            if (isF2F(offer)) {
                if (countryCode != null) {
                    result += ""\n"" + Res.get(""payment.f2f.offerbook.tooltip.countryAndCity"",
                            CountryUtil.getNameByCode(countryCode), offer.getF2FCity());

                    result += ""\n"" + Res.get(""payment.f2f.offerbook.tooltip.extra"", offer.getExtraInfo());
                }
            } else {
                if (countryCode != null) {
                    String bankId = offer.getBankId();
                    if (bankId != null && !bankId.equals(""null"")) {
                        if (BankUtil.isBankIdRequired(countryCode))
                            result += ""\n"" + Res.get(""offerbook.offerersBankId"", bankId);
                        else if (BankUtil.isBankNameRequired(countryCode))
                            result += ""\n"" + Res.get(""offerbook.offerersBankName"", bankId);
                    }
                }

                if (countryCode != null)
                    result += ""\n"" + Res.get(""offerbook.offerersBankSeat"", CountryUtil.getNameByCode(countryCode));

                List<String> acceptedCountryCodes = offer.getAcceptedCountryCodes();
                List<String> acceptedBanks = offer.getAcceptedBankIds();
                if (acceptedCountryCodes != null && !acceptedCountryCodes.isEmpty()) {
                    if (CountryUtil.containsAllSepaEuroCountries(acceptedCountryCodes))
                        result += ""\n"" + Res.get(""offerbook.offerersAcceptedBankSeatsEuro"");
                    else
                        result += ""\n"" + Res.get(""offerbook.offerersAcceptedBankSeats"", CountryUtil.getNamesByCodesString(acceptedCountryCodes));
                } else if (acceptedBanks != null && !acceptedBanks.isEmpty()) {
                    if (offer.getPaymentMethod().equals(PaymentMethod.SAME_BANK))
                        result += ""\n"" + Res.getWithCol(""shared.bankName"") + "" "" + acceptedBanks.get(0);
                    else if (offer.getPaymentMethod().equals(PaymentMethod.SPECIFIC_BANKS))
                        result += ""\n"" + Res.getWithCol(""shared.acceptedBanks"") + "" "" + Joiner.on("", "").join(acceptedBanks);
                }
            }
        }
        return result;
    }

    private boolean isF2F(Offer offer) {
        return offer.getPaymentMethod().equals(PaymentMethod.F2F);
    }

    String getDirectionLabelTooltip(Offer offer) {
        return getDirectionWithCodeDetailed(offer.getMirroredDirection(), offer.getCurrencyCode());
    }

    Optional<PaymentAccount> getMostMaturePaymentAccountForOffer(Offer offer) {
        return PaymentAccountUtil.getMostMaturePaymentAccountForOffer(offer, user.getPaymentAccounts(), accountAgeWitnessService);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void setMarketPriceFeedCurrency() {
        if (isTabSelected) {
            if (showAllTradeCurrenciesProperty.get())
                priceFeedService.setCurrencyCode(GlobalSettings.getDefaultTradeCurrency().getCode());
            else
                priceFeedService.setCurrencyCode(tradeCurrencyCode.get());
        }
    }

    private void fillAllTradeCurrencies() {
        allTradeCurrencies.clear();
        // Used for ignoring filter (show all)
        allTradeCurrencies.add(getShowAllEntryForCurrency());
        allTradeCurrencies.addAll(preferences.getTradeCurrenciesAsObservable());
        allTradeCurrencies.add(getEditEntryForCurrency());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Checks
    ///////////////////////////////////////////////////////////////////////////////////////////

    boolean hasPaymentAccountForCurrency() {
        return (showAllTradeCurrenciesProperty.get() &&
                user.getPaymentAccounts() != null &&
                !user.getPaymentAccounts().isEmpty()) ||
                user.hasPaymentAccountForCurrency(selectedTradeCurrency);
    }

    boolean canCreateOrTakeOffer() {
        return GUIUtil.canCreateOrTakeOfferOrShowPopup(user, navigation, selectedTradeCurrency) &&
                GUIUtil.isChainHeightSyncedWithinToleranceOrShowPopup(walletsSetup) &&
                GUIUtil.isBootstrappedOrShowPopup(p2PService);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Filters
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void filterOffers() {
        Predicate<OfferBookListItem> predicate = useOffersMatchingMyAccountsFilter ?
                getCurrencyAndMethodPredicate().and(getOffersMatchingMyAccountsPredicate()) :
                getCurrencyAndMethodPredicate();
        filteredItems.setPredicate(predicate);
    }

    private Predicate<OfferBookListItem> getCurrencyAndMethodPredicate() {
        return offerBookListItem -> {
            Offer offer = offerBookListItem.getOffer();
            boolean directionResult = offer.getDirection() != direction;
            boolean currencyResult = (showAllTradeCurrenciesProperty.get()) ||
                    offer.getCurrencyCode().equals(selectedTradeCurrency.getCode());
            boolean paymentMethodResult = showAllPaymentMethods ||
                    offer.getPaymentMethod().equals(selectedPaymentMethod);
            boolean notMyOfferOrShowMyOffersActivated = !isMyOffer(offerBookListItem.getOffer()) || preferences.isShowOwnOffersInOfferBook();
            return directionResult && currencyResult && paymentMethodResult && notMyOfferOrShowMyOffersActivated;
        };
    }

    private Predicate<OfferBookListItem> getOffersMatchingMyAccountsPredicate() {
        // This code duplicates code in the view at the button column. We need there the different results for
        // display in popups so we cannot replace that with the predicate. Any change need to be applied in both
        // places.
        return offerBookListItem -> offerFilterService.canTakeOffer(offerBookListItem.getOffer(), false).isValid();
    }

    boolean isOfferBanned(Offer offer) {
        return offerFilterService.isOfferBanned(offer);
    }

    private boolean isShowAllEntry(String id) {
        return id.equals(GUIUtil.SHOW_ALL_FLAG);
    }

    private boolean isEditEntry(String id) {
        return id.equals(GUIUtil.EDIT_FLAG);
    }

    int getNumTrades(Offer offer) {
        return closedTradableManager.getObservableList().stream()
                .filter(e -> {
                    final NodeAddress tradingPeerNodeAddress = e instanceof Trade ? ((Trade) e).getTradingPeerNodeAddress() : null;
                    return tradingPeerNodeAddress != null &&
                            tradingPeerNodeAddress.getFullAddress().equals(offer.getMakerNodeAddress().getFullAddress());
                })
                .collect(Collectors.toSet())
                .size();
    }

    public boolean hasSelectionAccountSigning() {
        if (showAllTradeCurrenciesProperty.get()) {
            if (!isShowAllEntry(selectedPaymentMethod.getId())) {
                return PaymentMethod.hasChargebackRisk(selectedPaymentMethod);
            }
        } else {
            if (isShowAllEntry(selectedPaymentMethod.getId()))
                return CurrencyUtil.getMatureMarketCurrencies().stream()
                        .anyMatch(c -> c.getCode().equals(selectedTradeCurrency.getCode()));
            else
                return PaymentMethod.hasChargebackRisk(selectedPaymentMethod, tradeCurrencyCode.get());
        }
        return true;
    }

    public String getMakerFeeAsString(Offer offer) {
        return offer.isCurrencyForMakerFeeBtc() ?
                btcFormatter.formatCoinWithCode(offer.getMakerFee()) :
                bsqFormatter.formatCoinWithCode(offer.getMakerFee());
    }

    private static String getDirectionWithCodeDetailed(OfferDirection direction, String currencyCode) {
        if (CurrencyUtil.isFiatCurrency(currencyCode))
            return (direction == OfferDirection.BUY) ? Res.get(""shared.buyingBTCWith"", currencyCode) : Res.get(""shared.sellingBTCFor"", currencyCode);
        else
            return (direction == OfferDirection.SELL) ? Res.get(""shared.buyingCurrency"", currencyCode) : Res.get(""shared.sellingCurrency"", currencyCode);
    }

    public String formatDepositString(Coin deposit, long amount) {
        var percentage = FormattingUtils.formatToRoundedPercentWithSymbol(deposit.getValue() / (double) amount);
        return btcFormatter.formatCoin(deposit) + "" ("" + percentage + "")"";
    }

    private TradeCurrency getShowAllEntryForCurrency() {
        return new CryptoCurrency(GUIUtil.SHOW_ALL_FLAG, """");
    }

    private TradeCurrency getEditEntryForCurrency() {
        return new CryptoCurrency(GUIUtil.EDIT_FLAG, """");
    }

    PaymentMethod getShowAllEntryForPaymentMethod() {
        return PaymentMethod.getDummyPaymentMethod(GUIUtil.SHOW_ALL_FLAG);
    }

    public boolean isInstantPaymentMethod(Offer offer) {
        return offer.getPaymentMethod().equals(PaymentMethod.BLOCK_CHAINS_INSTANT);
    }

    public PaymentAccount createBsqAccount(Offer offer) {
        var unusedBsqAddressAsString = bsqWalletService.getUnusedBsqAddressAsString();

        return coreApi.createCryptoCurrencyPaymentAccount(DisplayUtils.createAssetsAccountName(""BSQ"", unusedBsqAddressAsString),
                ""BSQ"",
                unusedBsqAddressAsString,
                isInstantPaymentMethod(offer));
    }

    public void setOfferActionHandler(OfferView.OfferActionHandler offerActionHandler) {
        this.offerActionHandler = offerActionHandler;
    }

    public void onCreateOffer() {
        offerActionHandler.onCreateOffer(getSelectedTradeCurrency(), selectedPaymentMethod);
    }

    public void onTakeOffer(Offer offer) {
        offerActionHandler.onTakeOffer(offer);
    }

    private void updateSelectedTradeCurrency() {
        String code = direction == OfferDirection.BUY ? preferences.getBuyScreenCurrencyCode() : preferences.getSellScreenCurrencyCode();
        if (code != null && !code.isEmpty() && !isShowAllEntry(code) &&
                CurrencyUtil.getTradeCurrency(code).isPresent()) {
            showAllTradeCurrenciesProperty.set(false);
            selectedTradeCurrency = CurrencyUtil.getTradeCurrency(code).get();
        } else {
            showAllTradeCurrenciesProperty.set(true);
            selectedTradeCurrency = GlobalSettings.getDefaultTradeCurrency();
        }
        tradeCurrencyCode.set(selectedTradeCurrency.getCode());
    }
}",1,64 2000 334 2001 378 2002 123 437 381 2003 2004 59 437 381 2005 2006 59 437 381 2007 2008 59 381 2009 2010 59 437 381 2011 2012 59 437 381 2013 2014 59 381 2015 2016 59 437 381 2017 2018 59 381 2019 2020 59 437 381 2021 2022 59 437 381 2023 2024 59 381 2025 2026 59 437 381 2027 2028 59 437 381 2029 2030 59 437 381 2031 60 2032 62 2033 59 437 381 2034 2035 59 437 381 2036 2037 59 437 381 2038 60 2032 62 2039 59 437 381 2040 60 2041 62 2042 59 437 381 2040 60 2032 62 2043 59 437 2041 2044 59 437 381 2045 60 2041 62 2046 61 2047 46 2048 40 41 59 437 2049 2050 59 381 2051 2052 61 418 2053 40 41 59 437 2054 46 2055 2056 59 621 2057 2058 61 2059 40 41 59 437 324 2060 59 381 2061 2062 61 418 2063 40 473 41 59 381 2061 2064 61 418 2063 40 41 59 381 2065 2066 61 418 2067 40 41 59 381 2065 2068 61 418 2067 40 41 59 381 2065 2069 61 418 2067 40 41 59 381 2065 2070 61 418 2067 40 41 59 324 2071 61 473 59 324 2072 59 621 621 621 64 2073 439 2001 40 2005 2006 44 2003 2004 44 2007 2008 44 2009 2010 44 2011 2012 44 2013 2014 44 2015 2016 44 2017 2018 44 2019 2020 44 2021 2022 44 2023 2024 44 2025 2026 44 64 2074 40 2075 46 2076 41 2027 2028 44 2029 2030 44 2034 2035 44 2036 2037 41 123 463 40 41 59 467 46 2004 61 2004 59 467 46 2006 61 2006 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 467 46 2012 61 2012 59 467 46 2014 61 2014 59 467 46 2016 61 2016 59 467 46 2018 61 2018 59 467 46 2020 61 2020 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2026 61 2026 59 467 46 2028 61 2028 59 467 46 2030 61 2030 59 467 46 2033 61 418 2031 60 62 40 2008 46 2077 40 41 41 59 467 46 2035 61 2035 59 467 46 2037 61 2037 59 467 46 2039 61 418 2038 60 62 40 2033 41 59 2042 61 2078 45 62 2079 40 41 59 2043 61 2078 45 62 123 381 2080 60 2032 62 2081 61 2033 46 2082 40 41 46 2083 40 2084 46 2085 40 2086 45 62 2086 46 2087 40 41 46 2088 40 41 46 2089 40 41 41 41 59 381 324 2090 61 2033 46 2082 40 41 46 2091 40 2086 45 62 2086 46 2087 40 41 46 2092 40 41 41 59 392 40 2081 46 2093 40 41 41 123 381 2032 2094 61 2081 46 2095 40 41 59 392 40 33 2094 46 2087 40 41 46 2092 40 41 605 2090 41 123 2066 46 2096 40 2097 40 2094 46 2087 40 41 44 380 41 46 2098 40 41 42 1502 43 2075 46 2099 46 2098 40 41 41 59 2068 46 2096 40 2100 40 2094 46 2087 40 41 44 380 41 46 2098 40 41 42 1502 43 2075 46 2099 46 2098 40 41 41 59 125 360 123 2066 46 2101 40 2102 40 2094 46 2087 40 41 44 380 41 46 2103 40 41 41 59 2068 46 2101 40 2104 40 2094 46 2087 40 41 44 380 41 46 2103 40 41 41 59 125 125 381 2080 60 2032 62 2105 61 2033 46 2082 40 41 46 2106 40 2086 45 62 2086 46 2087 40 41 46 2107 40 41 631 424 41 46 2083 40 2084 46 2085 40 2086 45 62 2086 46 2087 40 41 46 2107 40 41 631 424 63 2086 46 2087 40 41 46 2107 40 41 46 2089 40 41 58 1500 41 41 59 2105 46 2108 40 2109 45 62 2069 46 2110 40 2111 40 2109 46 2087 40 41 44 380 41 46 2112 40 41 41 41 59 381 2080 60 2032 62 2113 61 2033 46 2082 40 41 46 2106 40 2086 45 62 2086 46 2087 40 41 46 2114 40 41 41 46 2083 40 2084 46 2115 40 2086 45 62 418 2116 40 648 41 46 2117 40 2086 46 2087 40 41 46 2118 40 41 42 1503 41 46 2112 40 41 41 41 59 2113 46 2108 40 2109 45 62 2070 46 2110 40 2119 40 2109 46 2087 40 41 41 46 2112 40 41 41 41 59 125 59 125 64 2120 438 492 2121 40 41 123 2033 46 2122 40 2043 41 59 2123 40 41 59 392 40 2006 631 424 41 123 2064 46 2124 40 2006 46 2125 40 41 614 424 606 2006 46 2125 40 41 46 2126 40 41 41 59 125 2072 61 33 2064 46 2127 40 41 605 2128 40 41 59 2129 40 41 59 2010 46 2130 40 41 46 2122 40 2042 41 59 2008 46 2131 40 41 59 2132 40 41 59 2133 40 41 59 2024 46 2134 40 41 59 125 64 2120 438 492 2135 40 41 123 2033 46 2136 40 2043 41 59 2010 46 2137 40 41 46 2136 40 2042 41 59 125 621 621 621 492 2138 40 2049 2050 41 123 467 46 2050 61 2050 59 125 492 2139 40 324 2140 41 123 467 46 2060 61 2140 59 2141 40 41 59 392 40 2060 41 123 2142 40 41 59 2143 40 41 59 125 125 621 621 621 492 2144 40 2041 2145 41 123 392 40 2145 631 424 41 123 2146 2147 61 2145 46 2148 40 41 59 324 2149 61 2150 40 2147 41 59 2062 46 2151 40 2149 41 59 392 40 2152 40 2147 41 41 2022 46 2153 40 2154 46 334 44 2155 46 334 44 2156 46 334 41 59 360 392 40 33 2149 41 123 467 46 2044 61 2145 59 2052 46 2151 40 2147 41 59 125 2157 40 41 59 2158 40 41 59 392 40 2050 614 2049 46 2159 41 2010 46 2160 40 2147 41 59 360 2010 46 2161 40 2147 41 59 125 125 492 2162 40 2057 2163 41 123 392 40 2163 614 424 41 450 59 2071 61 2164 40 2163 46 2165 40 41 41 59 392 40 33 2071 41 123 467 46 2058 61 2163 59 621 621 392 40 2163 46 2165 40 41 46 2166 40 2057 46 2167 41 41 123 2144 40 2168 40 41 41 59 125 125 360 123 467 46 2058 61 2059 40 41 59 125 2169 40 41 59 125 492 2170 40 2171 2172 44 2173 2174 44 2175 2176 41 123 2004 46 2177 40 2172 44 2174 44 2176 41 59 125 492 2178 40 324 2140 41 123 2072 61 2140 59 2010 46 2179 40 2072 41 59 2180 40 41 59 125 621 621 621 324 2181 40 41 123 450 2010 46 2181 40 41 59 125 2038 60 2032 62 2182 40 41 123 450 2039 59 125 2183 60 2184 44 2185 62 2186 40 41 123 450 2008 46 2187 40 41 59 125 2183 60 2184 44 2185 62 2188 40 41 123 450 2008 46 2189 40 41 59 125 324 2190 40 2171 2172 41 123 450 2004 46 2190 40 2172 41 59 125 2049 2191 40 41 123 450 2050 59 125 439 2045 60 2041 62 2192 40 41 123 450 2046 59 125 324 2193 40 41 123 450 2194 46 2193 40 2014 41 59 125 2041 2195 40 41 123 450 2044 59 125 2045 60 2057 62 2196 40 41 123 2045 60 2057 62 411 61 2047 46 2048 40 2057 46 2196 40 41 41 59 392 40 2010 46 2197 40 41 605 2006 46 2198 40 41 631 424 41 123 2199 60 2057 62 2200 61 2006 46 2198 40 41 46 2201 40 41 46 2202 40 2203 58 58 2204 41 46 2205 40 2206 46 2207 40 41 41 59 392 40 33 2200 46 2208 40 41 41 123 411 61 2047 46 2048 40 2200 41 59 125 125 411 46 2209 40 2210 46 2211 40 41 41 59 411 46 2212 40 1500 44 2059 40 41 41 59 450 411 59 125 2184 2213 40 2032 2214 41 123 450 2215 40 2214 46 2216 40 41 44 473 41 59 125 437 2184 2217 40 2171 2172 44 324 2218 41 123 450 2219 46 2217 40 2172 44 2220 46 2221 44 2218 44 2066 46 2222 40 41 44 2028 41 59 125 2184 2223 40 2032 2214 41 123 392 40 40 2214 614 424 41 41 123 450 648 59 125 2171 2172 61 2214 46 2224 40 41 59 2225 2226 61 2172 46 2223 40 41 59 392 40 2226 631 424 41 123 450 2227 40 2172 44 473 41 59 125 360 123 450 2228 46 2229 40 648 41 59 125 125 2184 2230 40 2171 2172 41 123 450 2075 46 2231 40 2232 46 2233 40 2172 46 2234 40 41 41 41 59 125 437 2184 2235 40 2171 2172 44 324 2218 41 123 450 2236 46 2235 40 2172 46 2223 40 41 44 2218 44 2069 46 2237 40 41 41 59 125 2184 2238 40 2032 2214 41 123 450 2239 40 2214 46 2240 40 41 41 46 2241 40 2242 45 62 648 43 2075 46 2243 40 2242 41 43 648 41 46 2244 40 648 41 59 125 439 2245 60 2246 62 2247 40 2171 2172 41 123 450 2024 46 2247 40 2172 44 2050 41 59 125 2184 2248 40 2171 2172 41 123 2184 2249 61 648 59 392 40 2172 46 2250 40 41 41 123 2249 61 648 43 2075 46 2251 40 2172 46 2252 40 41 41 43 648 59 125 450 2249 59 125 2184 2253 40 2032 2214 41 123 450 2254 40 2214 46 2255 40 41 44 473 41 59 125 437 2184 2256 40 2171 2172 44 324 2218 41 123 2257 2258 61 2172 46 2253 40 41 59 2257 2259 61 2172 46 2260 40 41 59 392 40 2258 631 424 605 2259 631 424 41 123 2184 2261 61 2062 46 2262 40 41 63 648 43 2172 46 2263 40 41 58 648 59 2218 61 2218 605 33 2062 46 2262 40 41 59 450 2264 46 2256 40 2172 44 2218 44 2068 46 2262 40 41 41 43 2261 59 125 360 123 450 2265 46 2266 40 648 41 59 125 125 404 2267 40 2032 2214 41 123 450 2268 46 2269 40 2214 46 2270 40 41 46 2271 40 41 41 63 2272 46 2273 58 2272 46 2274 59 125 2184 2275 40 2032 2214 41 123 2184 2276 61 648 59 392 40 2214 631 424 41 123 2171 2172 61 2214 46 2277 40 41 59 2184 2278 61 2279 46 2280 40 2172 46 2275 40 41 46 2281 40 41 43 648 41 59 2184 2282 61 2172 46 2283 40 41 59 392 40 2284 40 2172 41 41 123 2276 61 2278 43 648 43 2282 43 648 43 2172 46 2285 40 41 43 648 59 125 360 123 392 40 2282 631 424 41 2276 61 2278 43 648 43 2282 43 648 59 360 2276 61 2278 59 125 125 450 2276 59 125 2184 2286 40 2032 2214 41 123 2184 2287 61 648 59 392 40 2214 631 424 41 123 2171 2172 61 2214 46 2288 40 41 59 2287 61 2289 46 2290 40 648 41 43 648 43 2289 46 2291 40 2172 46 2275 40 41 46 2292 40 41 41 59 2287 636 648 43 2289 46 2290 40 648 41 43 648 43 2293 46 2294 40 2172 46 2295 40 41 41 59 392 40 2172 46 2296 40 41 41 123 2184 2297 61 2172 46 2298 40 41 63 2289 46 2291 40 648 41 58 2289 46 2291 40 648 41 59 2287 636 648 43 2289 46 2290 40 648 41 43 648 43 2297 59 125 2184 2299 61 2172 46 2300 40 41 59 392 40 2301 40 2172 41 41 123 392 40 2299 631 424 41 123 2287 636 648 43 2289 46 2291 40 648 44 2302 46 2303 40 2299 41 44 2172 46 2304 40 41 41 59 2287 636 648 43 2289 46 2291 40 648 44 2172 46 2305 40 41 41 59 125 125 360 123 392 40 2299 631 424 41 123 2184 2306 61 2172 46 2307 40 41 59 392 40 2306 631 424 605 33 2306 46 2308 40 648 41 41 123 392 40 2309 46 2310 40 2299 41 41 2287 636 648 43 2289 46 2291 40 648 44 2306 41 59 360 392 40 2309 46 2311 40 2299 41 41 2287 636 648 43 2289 46 2291 40 648 44 2306 41 59 125 125 392 40 2299 631 424 41 2287 636 648 43 2289 46 2291 40 648 44 2312 46 2313 40 2299 41 41 59 2314 60 2184 62 2315 61 2172 46 2316 40 41 59 2314 60 2184 62 2317 61 2172 46 2318 40 41 59 392 40 2315 631 424 605 33 2315 46 2319 40 41 41 123 392 40 2312 46 2320 40 2315 41 41 2287 636 648 43 2289 46 2291 40 648 41 59 360 2287 636 648 43 2289 46 2291 40 648 44 2312 46 2321 40 2315 41 41 59 125 360 392 40 2317 631 424 605 33 2317 46 2319 40 41 41 123 392 40 2172 46 2275 40 41 46 2322 40 2057 46 2323 41 41 2287 636 648 43 2289 46 2290 40 648 41 43 648 43 2317 46 2291 40 1500 41 59 360 392 40 2172 46 2275 40 41 46 2322 40 2057 46 2324 41 41 2287 636 648 43 2289 46 2290 40 648 41 43 648 43 2325 46 2326 40 648 41 46 2327 40 2317 41 59 125 125 125 450 2287 59 125 437 324 2328 40 2171 2172 41 123 450 2172 46 2275 40 41 46 2329 40 2057 46 2330 41 59 125 2184 2331 40 2171 2172 41 123 450 2332 40 2172 46 2333 40 41 44 2172 46 2334 40 41 41 59 125 2245 60 2335 62 2336 40 2171 2172 41 123 450 2337 46 2336 40 2172 44 2006 46 2338 40 41 44 2020 41 59 125 621 621 621 437 492 2339 40 41 123 392 40 2060 41 123 392 40 2062 46 2340 40 41 41 2016 46 2341 40 2342 46 2343 40 41 46 2344 40 41 41 59 360 2016 46 2341 40 2052 46 2340 40 41 41 59 125 125 437 492 2345 40 41 123 2046 46 2346 40 41 59 621 2046 46 2347 40 2348 40 41 41 59 2046 46 2349 40 2010 46 2350 40 41 41 59 2046 46 2347 40 2351 40 41 41 59 125 621 621 621 324 2352 40 41 123 450 40 2062 46 2353 40 41 605 2006 46 2354 40 41 631 424 605 33 2006 46 2354 40 41 46 2355 40 41 41 606 2006 46 2352 40 2044 41 59 125 324 2356 40 41 123 450 2357 46 2358 40 2006 44 2022 44 2044 41 605 2357 46 2359 40 2012 41 605 2357 46 2193 40 2014 41 59 125 621 621 621 437 492 2360 40 41 123 2361 60 2032 62 2362 61 2072 63 2363 40 41 46 308 40 2364 40 41 41 58 2363 40 41 59 2033 46 2365 40 2362 41 59 125 437 2366 60 2032 62 2367 40 41 123 450 2368 45 62 123 2171 2172 61 2368 46 2369 40 41 59 324 2370 61 2172 46 2191 40 41 631 2050 59 324 2371 61 40 2062 46 2372 40 41 41 606 2172 46 2373 40 41 46 2374 40 2044 46 2375 40 41 41 59 324 2376 61 2071 606 2172 46 2275 40 41 46 2374 40 2058 41 59 324 2377 61 33 2190 40 2368 46 2369 40 41 41 606 2010 46 2378 40 41 59 450 2370 605 2371 605 2376 605 2377 59 125 59 125 437 2366 60 2032 62 2379 40 41 123 621 621 621 450 2380 45 62 2026 46 2381 40 2380 46 2382 40 41 44 380 41 46 2383 40 41 59 125 324 2384 40 2171 2172 41 123 450 2026 46 2384 40 2172 41 59 125 437 324 2385 40 2184 2386 41 123 450 2386 46 2387 40 2388 46 2389 41 59 125 437 324 2390 40 2184 2386 41 123 450 2386 46 2391 40 2392 46 2393 41 59 125 404 2394 40 2171 2172 41 123 450 2018 46 2395 40 41 46 2396 40 41 46 2397 40 2398 45 62 123 381 2399 2400 61 2398 402 2401 63 40 40 2401 41 2398 41 46 2402 40 41 58 424 59 450 2400 631 424 605 2400 46 2403 40 41 46 2404 40 2172 46 2405 40 41 46 2403 40 41 41 59 125 41 46 2406 40 2407 46 2408 40 41 41 46 2409 40 41 59 125 439 324 2410 40 41 123 392 40 2062 46 2411 40 41 41 123 392 40 33 2385 40 2058 46 2412 40 41 41 41 123 450 2057 46 2413 40 2058 41 59 125 125 360 123 392 40 2385 40 2058 46 2414 40 41 41 41 450 2415 46 2416 40 41 46 2417 40 41 46 2418 40 2419 45 62 2419 46 2420 40 41 46 2421 40 2044 46 2420 40 41 41 41 59 360 450 2057 46 2422 40 2058 44 2052 46 2411 40 41 41 59 125 450 473 59 125 439 2184 2423 40 2171 2172 41 123 450 2172 46 2424 40 41 63 2028 46 2425 40 2172 46 2426 40 41 41 58 2030 46 2425 40 2172 46 2426 40 41 41 59 125 437 457 2184 2427 40 2049 2050 44 2184 2428 41 123 392 40 2429 46 2430 40 2428 41 41 450 40 2050 614 2049 46 2431 41 63 2432 46 2433 40 648 44 2428 41 58 2432 46 2433 40 648 44 2428 41 59 360 450 40 2050 614 2049 46 2434 41 63 2432 46 2433 40 648 44 2428 41 58 2432 46 2433 40 648 44 2428 41 59 125 439 2184 2435 40 2436 2437 44 413 2438 41 123 490 2439 61 2075 46 2440 40 2437 46 2441 40 41 47 40 356 41 2438 41 59 450 2028 46 2442 40 2437 41 43 648 43 2439 43 648 59 125 437 2041 2443 40 41 123 450 418 2444 40 2445 46 2446 44 648 41 59 125 437 2041 2447 40 41 123 450 418 2448 40 2449 46 2450 44 648 41 59 125 2057 2059 40 41 123 450 2057 46 2451 40 2452 46 2453 41 59 125 439 324 2454 40 2171 2172 41 123 450 2172 46 2275 40 41 46 2455 40 2057 46 2456 41 59 125 439 2335 2457 40 2171 2172 41 123 490 2458 61 2035 46 2459 40 41 59 450 2037 46 2460 40 2461 46 2462 40 648 44 2458 41 44 648 44 2458 44 2454 40 2172 41 41 59 125 439 492 2463 40 2054 46 2055 2056 41 123 467 46 2056 61 2056 59 125 439 492 2464 40 41 123 2056 46 2464 40 2195 40 41 44 2058 41 59 125 439 492 2465 40 2171 2172 41 123 2056 46 2465 40 2172 41 59 125 437 492 2466 40 41 123 2184 2467 61 2050 614 2049 46 2468 63 2010 46 2469 40 41 58 2010 46 2470 40 41 59 392 40 2467 631 424 605 33 2467 46 2471 40 41 605 33 2385 40 2467 41 605 2472 46 2473 40 2467 41 46 2474 40 41 41 123 2062 46 2475 40 380 41 59 2044 61 2472 46 2473 40 2467 41 46 2476 40 41 59 125 360 123 2062 46 2477 40 473 41 59 2044 61 2478 46 2479 40 41 59 125 2052 46 2480 40 2044 46 2481 40 41 41 59 125 125 
32544,Java,"@CheckReturnValue
@SuppressWarnings(""unchecked"")
public class Mockito extends ArgumentMatchers {

    static final MockitoCore MOCKITO_CORE = new MockitoCore();

    /**
     * The default <code>Answer</code> of every mock <b>if</b> the mock was not stubbed.
     *
     * Typically it just returns some empty value.
     * <p>
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * <p>
     * This implementation first tries the global configuration and if there is no global configuration then
     * it will use a default answer that returns zeros, empty collections, nulls, etc.
     */
    public static final Answer<Object> RETURNS_DEFAULTS = Answers.RETURNS_DEFAULTS;

    /**
     * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}.
     * <p>
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * <p>
     * This implementation can be helpful when working with legacy code.
     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
     * This implementation of Answer <b>returns SmartNull instead of null</b>.
     * <code>SmartNull</code> gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
     * <p>
     * <code>ReturnsSmartNulls</code> first tries to return ordinary values (zeros, empty collections, empty string, etc.)
     * then it tries to return SmartNull. If the return type is final then plain <code>null</code> is returned.
     * <p>
     * Example:
     * <pre class=""code""><code class=""java"">
     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
     *
     *   //calling unstubbed method here:
     *   Stuff stuff = mock.getStuff();
     *
     *   //using object returned by unstubbed call:
     *   stuff.doSomething();
     *
     *   //Above doesn't yield NullPointerException this time!
     *   //Instead, SmartNullPointerException is thrown.
     *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.
     * </code></pre>
     */
    public static final Answer<Object> RETURNS_SMART_NULLS = Answers.RETURNS_SMART_NULLS;

    /**
     * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}
     * <p>
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * <p>
     * This implementation can be helpful when working with legacy code.
     * <p>
     * ReturnsMocks first tries to return ordinary values (zeros, empty collections, empty string, etc.)
     * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain <code>null</code> is returned.
     * <p>
     */
    public static final Answer<Object> RETURNS_MOCKS = Answers.RETURNS_MOCKS;

    /**
     * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}.
     * <p>
     * Example that shows how deep stub works:
     * <pre class=""code""><code class=""java"">
     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
     *
     *   // note that we're stubbing a chain of methods here: getBar().getName()
     *   when(mock.getBar().getName()).thenReturn(""deep"");
     *
     *   // note that we're chaining method calls: getBar().getName()
     *   assertEquals(""deep"", mock.getBar().getName());
     * </code></pre>
     * </p>
     *
     * <p>
     * <strong>WARNING: </strong>
     * This feature should rarely be required for regular clean code! Leave it for legacy code.
     * Mocking a mock to return a mock, to return a mock, (...), to return something meaningful
     * hints at violation of Law of Demeter or mocking a value object (a well known anti-pattern).
     * </p>
     *
     * <p>
     * Good quote I've seen one day on the web: <strong>every time a mock returns a mock a fairy dies</strong>.
     * </p>
     *
     * <p>
     * Please note that this answer will return existing mocks that matches the stub. This
     * behavior is ok with deep stubs and allows verification to work on the last mock of the chain.
     * <pre class=""code""><code class=""java"">
     *   when(mock.getBar(anyString()).getThingy().getName()).thenReturn(""deep"");
     *
     *   mock.getBar(""candy bar"").getThingy().getName();
     *
     *   assertSame(mock.getBar(anyString()).getThingy().getName(), mock.getBar(anyString()).getThingy().getName());
     *   verify(mock.getBar(""candy bar"").getThingy()).getName();
     *   verify(mock.getBar(anyString()).getThingy()).getName();
     * </code></pre>
     * </p>
     *
     * <p>
     * Verification only works with the last mock in the chain. You can use verification modes.
     * <pre class=""code""><code class=""java"">
     *   when(person.getAddress(anyString()).getStreet().getName()).thenReturn(""deep"");
     *   when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn(""deep"");
     *   when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn(""deep"");
     *
     *   person.getAddress(""the docks"").getStreet().getName();
     *   person.getAddress(""the docks"").getStreet().getLongName();
     *   person.getAddress(""the docks"").getStreet(Locale.ITALIAN).getName();
     *   person.getAddress(""the docks"").getStreet(Locale.CHINESE).getName();
     *
     *   // note that we are actually referring to the very last mock in the stubbing chain.
     *   InOrder inOrder = inOrder(
     *       person.getAddress(""the docks"").getStreet(),
     *       person.getAddress(""the docks"").getStreet(Locale.CHINESE),
     *       person.getAddress(""the docks"").getStreet(Locale.ITALIAN)
     *   );
     *   inOrder.verify(person.getAddress(""the docks"").getStreet(), times(1)).getName();
     *   inOrder.verify(person.getAddress(""the docks"").getStreet()).getLongName();
     *   inOrder.verify(person.getAddress(""the docks"").getStreet(Locale.ITALIAN), atLeast(1)).getName();
     *   inOrder.verify(person.getAddress(""the docks"").getStreet(Locale.CHINESE)).getName();
     * </code></pre>
     * </p>
     *
     * <p>
     * How deep stub work internally?
     * <pre class=""code""><code class=""java"">
     *   //this:
     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
     *   when(mock.getBar().getName(), ""deep"");
     *
     *   //is equivalent of
     *   Foo foo = mock(Foo.class);
     *   Bar bar = mock(Bar.class);
     *   when(foo.getBar()).thenReturn(bar);
     *   when(bar.getName()).thenReturn(""deep"");
     * </code></pre>
     * </p>
     *
     * <p>
     * This feature will not work when any return type of methods included in the chain cannot be mocked
     * (for example: is a primitive or a final class). This is because of java type system.
     * </p>
     */
    public static final Answer<Object> RETURNS_DEEP_STUBS = Answers.RETURNS_DEEP_STUBS;

    /**
     * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}
     *
     * <p>
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * <p>
     * This implementation can be helpful when working with legacy code.
     * When this implementation is used, unstubbed methods will delegate to the real implementation.
     * This is a way to create a partial mock object that calls real methods by default.
     * <p>
     * As usual you are going to read <b>the partial mock warning</b>:
     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * <p>
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
     * <p>
     * Example:
     * <pre class=""code""><code class=""java"">
     * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);
     *
     * // this calls the real implementation of Foo.getSomething()
     * value = mock.getSomething();
     *
     * doReturn(fakeValue).when(mock).getSomething();
     *
     * // now fakeValue is returned
     * value = mock.getSomething();
     * </code></pre>
     *
     * <p>
     * <u>Note 1:</u> Stubbing partial mocks using <code>when(mock.getSomething()).thenReturn(fakeValue)</code>
     * syntax will call the real method. For partial mock it's recommended to use <code>doReturn</code> syntax.
     * <p>
     * <u>Note 2:</u> If the mock is serialized then deserialized, then this answer will not be able to understand
     * generics metadata.
     */
    public static final Answer<Object> CALLS_REAL_METHODS = Answers.CALLS_REAL_METHODS;

    /**
     * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}.
     *
     * Allows Builder mocks to return itself whenever a method is invoked that returns a Type equal
     * to the class or a superclass.
     *
     * <p><b>Keep in mind this answer uses the return type of a method.
     * If this type is assignable to the class of the mock, it will return the mock.
     * Therefore if you have a method returning a superclass (for example {@code Object}) it will match and return the mock.</b></p>
     *
     * Consider a HttpBuilder used in a HttpRequesterWithHeaders.
     *
     * <pre class=""code""><code class=""java"">
     * public class HttpRequesterWithHeaders {
     *
     *      private HttpBuilder builder;
     *
     *      public HttpRequesterWithHeaders(HttpBuilder builder) {
     *          this.builder = builder;
     *      }
     *
     *      public String request(String uri) {
     *          return builder.withUrl(uri)
     *                  .withHeader(""Content-type: application/json"")
     *                  .withHeader(""Authorization: Bearer"")
     *                  .request();
     *      }
     *  }
     *
     *  private static class HttpBuilder {
     *
     *      private String uri;
     *      private List&lt;String&gt; headers;
     *
     *      public HttpBuilder() {
     *          this.headers = new ArrayList&lt;String&gt;();
     *      }
     *
     *       public HttpBuilder withUrl(String uri) {
     *           this.uri = uri;
     *           return this;
     *       }
     *
     *       public HttpBuilder withHeader(String header) {
     *           this.headers.add(header);
     *           return this;
     *       }
     *
     *       public String request() {
     *          return uri + headers.toString();
     *       }
     *  }
     * </code></pre>
     *
     * The following test will succeed
     *
     * <pre><code>
     * &#064;Test
     *  public void use_full_builder_with_terminating_method() {
     *      HttpBuilder builder = mock(HttpBuilder.class, RETURNS_SELF);
     *      HttpRequesterWithHeaders requester = new HttpRequesterWithHeaders(builder);
     *      String response = ""StatusCode: 200"";
     *
     *      when(builder.request()).thenReturn(response);
     *
     *      assertThat(requester.request(""URI"")).isEqualTo(response);
     *  }
     * </code></pre>
     */
    public static final Answer<Object> RETURNS_SELF = Answers.RETURNS_SELF;

    /**
     * Creates mock object of given class or interface.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @return mock object
     */
    public static <T> T mock(Class<T> classToMock) {
        return mock(classToMock, withSettings());
    }

    /**
     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.
     * <p>
     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.
     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.
     * <p>
     * <b>If you use <code>&#064;Mock</code> annotation then you've got naming mocks for free!</b> <code>&#064;Mock</code> uses field name as mock name. {@link Mock Read more.}
     * <p>
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @param name of the mock
     * @return mock object
     */
    public static <T> T mock(Class<T> classToMock, String name) {
        return mock(classToMock, withSettings().name(name).defaultAnswer(RETURNS_DEFAULTS));
    }

    /**
     * Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information.
     * Can be used to find out if given object is a Mockito mock
     * or to find out if a given mock is a spy or mock.
     * <p>
     * In future Mockito versions MockingDetails may grow and provide other useful information about the mock,
     * e.g. invocations, stubbing info, etc.
     *
     * @param toInspect - object to inspect. null input is allowed.
     * @return A {@link org.mockito.MockingDetails} instance.
     * @since 1.9.5
     */
    public static MockingDetails mockingDetails(Object toInspect) {
        return MOCKITO_CORE.mockingDetails(toInspect);
    }

    /**
     * Creates mock with a specified strategy for its answers to interactions.
     * It's quite an advanced feature and typically you don't need it to write decent tests.
     * However it can be helpful when working with legacy systems.
     * <p>
     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
     *
     * <pre class=""code""><code class=""java"">
     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
     * </code></pre>
     *
     * <p>See examples in javadoc for {@link Mockito} class</p>
     *
     * @param classToMock class or interface to mock
     * @param defaultAnswer default answer for unstubbed methods
     *
     * @return mock object
     */
    public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
        return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
    }

    /**
     * Creates a mock with some non-standard settings.
     * <p>
     * The number of configuration points for a mock grows
     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.
     * Hence {@link MockSettings}.
     * <pre class=""code""><code class=""java"">
     *   Listener mock = mock(Listener.class, withSettings()
     *     .name(""firstListner"").defaultBehavior(RETURNS_SMART_NULLS));
     *   );
     * </code></pre>
     * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?
     * Is the code under test so complicated that it requires non-standard mocks?
     * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?
     * <p>
     * See also {@link Mockito#withSettings()}
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @param mockSettings additional mock settings
     * @return mock object
     */
    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
        return MOCKITO_CORE.mock(classToMock, mockSettings);
    }

    /**
     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.
     * <p>
     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
     * <p>
     * As usual you are going to read <b>the partial mock warning</b>:
     * Object oriented programming tackles complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * <p>
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
     * <p>
     * Example:
     *
     * <pre class=""code""><code class=""java"">
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //optionally, you can stub out some methods:
     *   when(spy.size()).thenReturn(100);
     *
     *   //using the spy calls <b>real</b> methods
     *   spy.add(""one"");
     *   spy.add(""two"");
     *
     *   //prints ""one"" - the first element of a list
     *   System.out.println(spy.get(0));
     *
     *   //size() method was stubbed - 100 is printed
     *   System.out.println(spy.size());
     *
     *   //optionally, you can verify
     *   verify(spy).add(""one"");
     *   verify(spy).add(""two"");
     * </code></pre>
     *
     * <h4>Important gotcha on spying real objects!</h4>
     * <ol>
     * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.
     * Therefore for spies it is recommended to always use <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>|<code>CallRealMethod</code>
     * family of methods for stubbing. Example:
     *
     * <pre class=""code""><code class=""java"">
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(""foo"");
     *
     *   //You have to use doReturn() for stubbing
     *   doReturn(""foo"").when(spy).get(0);
     * </code></pre>
     * </li>
     *
     * <li>Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.
     * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction
     * and their effect on real instance state.
     * The corollary is that when an <b>*unstubbed*</b> method is called <b>*on the spy*</b> but <b>*not on the real instance*</b>,
     * you won't see any effects on the real instance.</li>
     *
     * <li>Watch out for final methods.
     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
     * Also you won't be able to verify those method as well.
     * </li>
     * </ol>
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * <p>Note that the spy won't have any annotations of the spied type, because CGLIB won't rewrite them.
     * It may troublesome for code that rely on the spy to have these annotations.</p>
     *
     *
     * @param object
     *            to spy on
     * @return a spy of the real object
     */
    public static <T> T spy(T object) {
        return MOCKITO_CORE.mock(
                (Class<T>) object.getClass(),
                withSettings().spiedInstance(object).defaultAnswer(CALLS_REAL_METHODS));
    }

    /**
     * Please refer to the documentation of {@link #spy(Object)}.
     * Overusing spies hints at code design smells.
     * <p>
     * This method, in contrast to the original {@link #spy(Object)}, creates a spy based on class instead of an object.
     * Sometimes it is more convenient to create spy based on the class and avoid providing an instance of a spied object.
     * This is particularly useful for spying on abstract classes because they cannot be instantiated.
     * See also {@link MockSettings#useConstructor(Object...)}.
     * <p>
     * Examples:
     * <pre class=""code""><code class=""java"">
     *   SomeAbstract spy = spy(SomeAbstract.class);
     *
     *   //Robust API, via settings builder:
     *   OtherAbstract spy = mock(OtherAbstract.class, withSettings()
     *      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
     *
     *   //Mocking a non-static inner abstract class:
     *   InnerAbstract spy = mock(InnerAbstract.class, withSettings()
     *      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
     * </code></pre>
     *
     * @param classToSpy the class to spy
     * @param <T> type of the spy
     * @return a spy of the provided class
     * @since 1.10.12
     */
    public static <T> T spy(Class<T> classToSpy) {
        return MOCKITO_CORE.mock(
                classToSpy, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
    }

    /**
     * Creates a thread-local mock controller for all static methods of the given class or interface.
     * The returned object's {@link MockedStatic#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * <b>Note</b>: We recommend against mocking static methods of classes in the standard library or
     * classes used by custom class loaders used to executed the block with the mocked class. A mock
     * maker might forbid mocking static methods of know classes that are known to cause problems.
     * Also, if a static method is a JVM-intrinsic, it cannot typically be mocked even if not
     * explicitly forbidden.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface of which static mocks should be mocked.
     * @return mock controller
     */
    public static <T> MockedStatic<T> mockStatic(Class<T> classToMock) {
        return mockStatic(classToMock, withSettings());
    }

    /**
     * Creates a thread-local mock controller for all static methods of the given class or interface.
     * The returned object's {@link MockedStatic#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * <b>Note</b>: We recommend against mocking static methods of classes in the standard library or
     * classes used by custom class loaders used to executed the block with the mocked class. A mock
     * maker might forbid mocking static methods of know classes that are known to cause problems.
     * Also, if a static method is a JVM-intrinsic, it cannot typically be mocked even if not
     * explicitly forbidden.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface of which static mocks should be mocked.
     * @param defaultAnswer the default answer when invoking static methods.
     * @return mock controller
     */
    public static <T> MockedStatic<T> mockStatic(Class<T> classToMock, Answer defaultAnswer) {
        return mockStatic(classToMock, withSettings().defaultAnswer(defaultAnswer));
    }

    /**
     * Creates a thread-local mock controller for all static methods of the given class or interface.
     * The returned object's {@link MockedStatic#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * <b>Note</b>: We recommend against mocking static methods of classes in the standard library or
     * classes used by custom class loaders used to executed the block with the mocked class. A mock
     * maker might forbid mocking static methods of know classes that are known to cause problems.
     * Also, if a static method is a JVM-intrinsic, it cannot typically be mocked even if not
     * explicitly forbidden.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface of which static mocks should be mocked.
     * @param name the name of the mock to use in error messages.
     * @return mock controller
     */
    public static <T> MockedStatic<T> mockStatic(Class<T> classToMock, String name) {
        return mockStatic(classToMock, withSettings().name(name));
    }

    /**
     * Creates a thread-local mock controller for all static methods of the given class or interface.
     * The returned object's {@link MockedStatic#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * <b>Note</b>: We recommend against mocking static methods of classes in the standard library or
     * classes used by custom class loaders used to executed the block with the mocked class. A mock
     * maker might forbid mocking static methods of know classes that are known to cause problems.
     * Also, if a static method is a JVM-intrinsic, it cannot typically be mocked even if not
     * explicitly forbidden.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface of which static mocks should be mocked.
     * @param mockSettings the settings to use where only name and default answer are considered.
     * @return mock controller
     */
    public static <T> MockedStatic<T> mockStatic(Class<T> classToMock, MockSettings mockSettings) {
        return MOCKITO_CORE.mockStatic(classToMock, mockSettings);
    }

    /**
     * Creates a thread-local mock controller for all constructions of the given class.
     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock non-abstract class of which constructions should be mocked.
     * @param defaultAnswer the default answer for the first created mock.
     * @param additionalAnswers the default answer for all additional mocks. For any access mocks, the
     *                         last answer is used. If this array is empty, the {@code defaultAnswer} is used.
     * @return mock controller
     */
    public static <T> MockedConstruction<T> mockConstructionWithAnswer(
            Class<T> classToMock, Answer defaultAnswer, Answer... additionalAnswers) {
        return mockConstruction(
                classToMock,
                context -> {
                    if (context.getCount() == 1 || additionalAnswers.length == 0) {
                        return withSettings().defaultAnswer(defaultAnswer);
                    } else if (context.getCount() >= additionalAnswers.length) {
                        return withSettings()
                                .defaultAnswer(additionalAnswers[additionalAnswers.length - 1]);
                    } else {
                        return withSettings()
                                .defaultAnswer(additionalAnswers[context.getCount() - 2]);
                    }
                },
                (mock, context) -> {});
    }

    /**
     * Creates a thread-local mock controller for all constructions of the given class.
     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock non-abstract class of which constructions should be mocked.
     * @return mock controller
     */
    public static <T> MockedConstruction<T> mockConstruction(Class<T> classToMock) {
        return mockConstruction(classToMock, index -> withSettings(), (mock, context) -> {});
    }

    /**
     * Creates a thread-local mock controller for all constructions of the given class.
     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock non-abstract class of which constructions should be mocked.
     * @param mockInitializer a callback to prepare a mock's methods after its instantiation.
     * @return mock controller
     */
    public static <T> MockedConstruction<T> mockConstruction(
            Class<T> classToMock, MockedConstruction.MockInitializer<T> mockInitializer) {
        return mockConstruction(classToMock, withSettings(), mockInitializer);
    }

    /**
     * Creates a thread-local mock controller for all constructions of the given class.
     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock non-abstract class of which constructions should be mocked.
     * @param mockSettings the mock settings to use.
     * @return mock controller
     */
    public static <T> MockedConstruction<T> mockConstruction(
            Class<T> classToMock, MockSettings mockSettings) {
        return mockConstruction(classToMock, context -> mockSettings);
    }

    /**
     * Creates a thread-local mock controller for all constructions of the given class.
     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock non-abstract class of which constructions should be mocked.
     * @param mockSettingsFactory the mock settings to use.
     * @return mock controller
     */
    public static <T> MockedConstruction<T> mockConstruction(
            Class<T> classToMock,
            Function<MockedConstruction.Context, MockSettings> mockSettingsFactory) {
        return mockConstruction(classToMock, mockSettingsFactory, (mock, context) -> {});
    }

    /**
     * Creates a thread-local mock controller for all constructions of the given class.
     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock non-abstract class of which constructions should be mocked.
     * @param mockSettings the settings to use.
     * @param mockInitializer a callback to prepare a mock's methods after its instantiation.
     * @return mock controller
     */
    public static <T> MockedConstruction<T> mockConstruction(
            Class<T> classToMock,
            MockSettings mockSettings,
            MockedConstruction.MockInitializer<T> mockInitializer) {
        return mockConstruction(classToMock, index -> mockSettings, mockInitializer);
    }

    /**
     * Creates a thread-local mock controller for all constructions of the given class.
     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
     * test or the mock will remain active on the current thread.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock non-abstract class of which constructions should be mocked.
     * @param mockSettingsFactory a function to create settings to use.
     * @param mockInitializer a callback to prepare a mock's methods after its instantiation.
     * @return mock controller
     */
    public static <T> MockedConstruction<T> mockConstruction(
            Class<T> classToMock,
            Function<MockedConstruction.Context, MockSettings> mockSettingsFactory,
            MockedConstruction.MockInitializer<T> mockInitializer) {
        return MOCKITO_CORE.mockConstruction(classToMock, mockSettingsFactory, mockInitializer);
    }

    /**
     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.
     * <p>
     * Simply put: ""<b>When</b> the x method is called <b>then</b> return y"".
     *
     * <p>
     * Examples:
     *
     * <pre class=""code""><code class=""java"">
     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);
     *
     * //you can use flexible argument matchers, e.g:
     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);
     *
     * //setting exception to be thrown:
     * when(mock.someMethod(""some arg"")).thenThrow(new RuntimeException());
     *
     * //you can set different behavior for consecutive method calls.
     * //Last stubbing (e.g: thenReturn(""foo"")) determines the behavior of further consecutive calls.
     * when(mock.someMethod(""some arg""))
     *  .thenThrow(new RuntimeException())
     *  .thenReturn(""foo"");
     *
     * //Alternative, shorter version for consecutive stubbing:
     * when(mock.someMethod(""some arg""))
     *  .thenReturn(""one"", ""two"");
     * //is the same as:
     * when(mock.someMethod(""some arg""))
     *  .thenReturn(""one"")
     *  .thenReturn(""two"");
     *
     * //shorter version for consecutive method calls throwing exceptions:
     * when(mock.someMethod(""some arg""))
     *  .thenThrow(new RuntimeException(), new NullPointerException();
     *
     * </code></pre>
     *
     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable...)}
     * <p>
     * Stubbing can be overridden: for example common stubbing can go to fixture
     * setup but the test methods can override it.
     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.
     * <p>
     * Once stubbed, the method will always return stubbed value regardless
     * of how many times it is called.
     * <p>
     * Last stubbing is more important - when you stubbed the same method with
     * the same arguments many times.
     * <p>
     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
     * Let's say you've stubbed <code>foo.bar()</code>.
     * If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).
     * If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.
     *
     * <p>
     * See examples in javadoc for {@link Mockito} class
     * @param methodCall method to be stubbed
     * @return OngoingStubbing object used to stub fluently.
     *         <strong>Do not</strong> create a reference to this returned object.
     */
    public static <T> OngoingStubbing<T> when(T methodCall) {
        return MOCKITO_CORE.when(methodCall);
    }

    /**
     * Verifies certain behavior <b>happened once</b>.
     * <p>
     * Alias to <code>verify(mock, times(1))</code> E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock).someMethod(""some arg"");
     * </code></pre>
     * Above is equivalent to:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, times(1)).someMethod(""some arg"");
     * </code></pre>
     * <p>
     * Arguments passed are compared using <code>equals()</code> method.
     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
     * <p>
     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
     * Let's say you've stubbed <code>foo.bar()</code>.
     * If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).
     * If your code doesn't care what <code>foo.bar()</code> returns then it should not be stubbed.
     *
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mock to be verified
     * @return mock object itself
     */
    public static <T> T verify(T mock) {
        return MOCKITO_CORE.verify(mock, times(1));
    }

    /**
     * Verifies certain behavior happened at least once / exact number of times / never. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, times(5)).someMethod(""was called five times"");
     *
     *   verify(mock, atLeast(2)).someMethod(""was called at least two times"");
     *
     *   //you can use flexible argument matchers, e.g:
     *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);
     * </code></pre>
     *
     * <b>times(1) is the default</b> and can be omitted
     * <p>
     * Arguments passed are compared using <code>equals()</code> method.
     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
     * <p>
     *
     * @param mock to be verified
     * @param mode times(x), atLeastOnce() or never()
     *
     * @return mock object itself
     */
    public static <T> T verify(T mock, VerificationMode mode) {
        return MOCKITO_CORE.verify(mock, mode);
    }

    /**
     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
     * Normally, you don't need to reset your mocks, just create new mocks for each test method.
     * <p>
     * Instead of <code>#reset()</code> please consider writing simple, small and focused test methods over lengthy, over-specified tests.
     * <b>First potential code smell is <code>reset()</code> in the middle of the test method.</b> This probably means you're testing too much.
     * Follow the whisper of your test methods: ""Please keep us small and focused on single behavior"".
     * There are several threads about it on mockito mailing list.
     * <p>
     * The only reason we added <code>reset()</code> method is to
     * make it possible to work with container-injected mocks.
     * For more information see the FAQ (<a href=""https://github.com/mockito/mockito/wiki/FAQ"">here</a>).
     * <p>
     * <b>Don't harm yourself.</b> <code>reset()</code> in the middle of the test method is a code smell (you're probably testing too much).
     * <pre class=""code""><code class=""java"">
     *   List mock = mock(List.class);
     *   when(mock.size()).thenReturn(10);
     *   mock.add(1);
     *
     *   reset(mock);
     *   //at this point the mock forgot any interactions and stubbing
     * </code></pre>
     *
     * @param <T> The Type of the mocks
     * @param mocks to be reset
     */
    public static <T> void reset(T... mocks) {
        MOCKITO_CORE.reset(mocks);
    }

    /**
     * Clears all mocks, type caches and instrumentations.
     * <p>
     * By clearing Mockito's state, previously created mocks might begin to malfunction. This option can be used if
     * Mockito's caches take up too much space or if the inline mock maker's instrumentation is causing performance
     * issues in code where mocks are no longer used. Normally, you would not need to use this option.
     */
    public static void clearAllCaches() {
        MOCKITO_CORE.clearAllCaches();
    }

    /**
     * Use this method in order to only clear invocations, when stubbing is non-trivial. Use-cases can be:
     * <ul>
     *     <li>You are using a dependency injection framework to inject your mocks.</li>
     *     <li>The mock is used in a stateful scenario. For example a class is Singleton which depends on your mock.</li>
     * </ul>
     *
     * <b>Try to avoid this method at all costs. Only clear invocations if you are unable to efficiently test your program.</b>
     * @param <T> The type of the mocks
     * @param mocks The mocks to clear the invocations for
     */
    public static <T> void clearInvocations(T... mocks) {
        MOCKITO_CORE.clearInvocations(mocks);
    }

    /**
     * Checks if any of given mocks has any unverified interaction.
     * <p>
     * You can use this method after you verified your mocks - to make sure that nothing
     * else was invoked on your mocks.
     * <p>
     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
     * <p>
     * Stubbed invocations (if called) are also treated as interactions.
     * If you want stubbed invocations automatically verified, check out {@link Strictness#STRICT_STUBS} feature
     * introduced in Mockito 2.3.0.
     * If you want to ignore stubs for verification, see {@link #ignoreStubs(Object...)}.
     * <p>
     * A word of <b>warning</b>:
     * Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.
     * <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.
     * <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
     * Abusing it leads to overspecified, less maintainable tests.
     * <p>
     * This method will also detect unverified invocations that occurred before the test method,
     * for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.
     * Consider writing nice code that makes interactions only in test methods.
     *
     * <p>
     * Example:
     *
     * <pre class=""code""><code class=""java"">
     * //interactions
     * mock.doSomething();
     * mock.doSomethingUnexpected();
     *
     * //verification
     * verify(mock).doSomething();
     *
     * //following will fail because 'doSomethingUnexpected()' is unexpected
     * verifyNoMoreInteractions(mock);
     *
     * </code></pre>
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified
     */
    public static void verifyNoMoreInteractions(Object... mocks) {
        MOCKITO_CORE.verifyNoMoreInteractions(mocks);
    }

    /**
     * Verifies that no interactions happened on given mocks.
     * <pre class=""code""><code class=""java"">
     *   verifyNoInteractions(mockOne, mockTwo);
     * </code></pre>
     * This method will also detect invocations
     * that occurred before the test method, for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.
     * Consider writing nice code that makes interactions only in test methods.
     * <p>
     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified
     * @since 3.0.1
     */
    public static void verifyNoInteractions(Object... mocks) {
        MOCKITO_CORE.verifyNoInteractions(mocks);
    }

    /**
     * Use <code>doThrow()</code> when you want to stub the void method with an exception.
     * <p>
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * <p>
     * Example:
     *
     * <pre class=""code""><code class=""java"">
     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();
     * </code></pre>
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    public static Stubber doThrow(Throwable... toBeThrown) {
        return MOCKITO_CORE.stubber().doThrow(toBeThrown);
    }

    /**
     * Use <code>doThrow()</code> when you want to stub the void method with an exception.
     * <p>
     * A new exception instance will be created for each method invocation.
     * <p>
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * <p>
     * Example:
     *
     * <pre class=""code""><code class=""java"">
     *   doThrow(RuntimeException.class).when(mock).someVoidMethod();
     * </code></pre>
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.1.0
     */
    public static Stubber doThrow(Class<? extends Throwable> toBeThrown) {
        return MOCKITO_CORE.stubber().doThrow(toBeThrown);
    }

    /**
     * Same as {@link #doThrow(Class)} but sets consecutive exception classes to be thrown. Remember to use
     * <code>doThrow()</code> when you want to stub the void method to throw several exception of specified class.
     * <p>
     * A new exception instance will be created for each method invocation.
     * <p>
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * <p>
     * Example:
     *
     * <pre class=""code""><code class=""java"">
     *   doThrow(RuntimeException.class, BigFailure.class).when(mock).someVoidMethod();
     * </code></pre>
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @param toBeThrownNext next to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.1.0
     */
    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array
    // creation
    @SuppressWarnings({""unchecked"", ""varargs""})
    public static Stubber doThrow(
            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... toBeThrownNext) {
        return MOCKITO_CORE.stubber().doThrow(toBeThrown, toBeThrownNext);
    }

    /**
     * Use <code>doCallRealMethod()</code> when you want to call the real implementation of a method.
     * <p>
     * As usual you are going to read <b>the partial mock warning</b>:
     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * <p>
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
     * <p>
     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks.
     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b>
     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.
     * <p>
     * Example:
     * <pre class=""code""><code class=""java"">
     *   Foo mock = mock(Foo.class);
     *   doCallRealMethod().when(mock).someVoidMethod();
     *
     *   // this will call the real implementation of Foo.someVoidMethod()
     *   mock.someVoidMethod();
     * </code></pre>
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @return stubber - to select a method for stubbing
     * @since 1.9.5
     */
    public static Stubber doCallRealMethod() {
        return MOCKITO_CORE.stubber().doCallRealMethod();
    }

    /**
     * Use <code>doAnswer()</code> when you want to stub a void method with generic {@link Answer}.
     * <p>
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
     * <p>
     * Example:
     *
     * <pre class=""code""><code class=""java"">
     *  doAnswer(new Answer() {
     *      public Object answer(InvocationOnMock invocation) {
     *          Object[] args = invocation.getArguments();
     *          Mock mock = invocation.getMock();
     *          return null;
     *      }})
     *  .when(mock).someMethod();
     * </code></pre>
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param answer to answer when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    public static Stubber doAnswer(Answer answer) {
        return MOCKITO_CORE.stubber().doAnswer(answer);
    }

    /**
     * Use <code>doNothing()</code> for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b>
     * However, there are rare situations when doNothing() comes handy:
     * <p>
     * <ol>
     * <li>Stubbing consecutive calls on a void method:
     * <pre class=""code""><code class=""java"">
     *   doNothing().
     *   doThrow(new RuntimeException())
     *   .when(mock).someVoidMethod();
     *
     *   //does nothing the first time:
     *   mock.someVoidMethod();
     *
     *   //throws RuntimeException the next time:
     *   mock.someVoidMethod();
     * </code></pre>
     * </li>
     * <li>When you spy real objects and you want the void method to do nothing:
     * <pre class=""code""><code class=""java"">
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //let's make clear() do nothing
     *   doNothing().when(spy).clear();
     *
     *   spy.add(""one"");
     *
     *   //clear() does nothing, so the list still contains ""one""
     *   spy.clear();
     * </code></pre>
     * </li>
     * </ol>
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @return stubber - to select a method for stubbing
     */
    public static Stubber doNothing() {
        return MOCKITO_CORE.stubber().doNothing();
    }

    /**
     * Use <code>doReturn()</code> in those rare occasions when you cannot use {@link Mockito#when(Object)}.
     * <p>
     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
     * and more readable</b> (especially when stubbing consecutive calls).
     * <p>
     * Here are those rare occasions when doReturn() comes handy:
     * <p>
     *
     * <ol>
     * <li>When spying real objects and calling real methods on a spy brings side effects
     *
     * <pre class=""code""><code class=""java"">
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(""foo"");
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(""foo"").when(spy).get(0);
     * </code></pre>
     * </li>
     *
     * <li>Overriding a previous exception-stubbing:
     * <pre class=""code""><code class=""java"">
     *   when(mock.foo()).thenThrow(new RuntimeException());
     *
     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
     *   when(mock.foo()).thenReturn(""bar"");
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(""bar"").when(mock).foo();
     * </code></pre>
     * </li>
     * </ol>
     *
     * Above scenarios shows a tradeoff of Mockito's elegant syntax. Note that the scenarios are very rare, though.
     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
     * overridding stubbing is a potential code smell that points out too much stubbing.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param toBeReturned to be returned when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    public static Stubber doReturn(Object toBeReturned) {
        return MOCKITO_CORE.stubber().doReturn(toBeReturned);
    }

    /**
     * Same as {@link #doReturn(Object)} but sets consecutive values to be returned. Remember to use
     * <code>doReturn()</code> in those rare occasions when you cannot use {@link Mockito#when(Object)}.
     * <p>
     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
     * and more readable</b> (especially when stubbing consecutive calls).
     * <p>
     * Here are those rare occasions when doReturn() comes handy:
     * <p>
     *
     * <ol>
     * <li>When spying real objects and calling real methods on a spy brings side effects
     *
     * <pre class=""code""><code class=""java"">
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(""foo"", ""bar"", ""qix"");
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(""foo"", ""bar"", ""qix"").when(spy).get(0);
     * </code></pre>
     * </li>
     *
     * <li>Overriding a previous exception-stubbing:
     * <pre class=""code""><code class=""java"">
     *   when(mock.foo()).thenThrow(new RuntimeException());
     *
     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
     *   when(mock.foo()).thenReturn(""bar"", ""foo"", ""qix"");
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(""bar"", ""foo"", ""qix"").when(mock).foo();
     * </code></pre>
     * </li>
     * </ol>
     *
     * Above scenarios shows a trade-off of Mockito's elegant syntax. Note that the scenarios are very rare, though.
     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
     * overridding stubbing is a potential code smell that points out too much stubbing.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param toBeReturned to be returned when the stubbed method is called
     * @param toBeReturnedNext to be returned in consecutive calls when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.1.0
     */
    @SuppressWarnings({""unchecked"", ""varargs""})
    public static Stubber doReturn(Object toBeReturned, Object... toBeReturnedNext) {
        return MOCKITO_CORE.stubber().doReturn(toBeReturned, toBeReturnedNext);
    }

    /**
     * Creates {@link org.mockito.InOrder} object that allows verifying mocks in order.
     *
     * <pre class=""code""><code class=""java"">
     *   InOrder inOrder = inOrder(firstMock, secondMock);
     *
     *   inOrder.verify(firstMock).add(""was called first"");
     *   inOrder.verify(secondMock).add(""was called second"");
     * </code></pre>
     *
     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one
     * but only those that you are interested in testing in order.
     * <p>
     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.
     * <p>
     * <code>InOrder</code> verification is 'greedy', but you will hardly ever notice it.
     * If you want to find out more, read
     * <a href=""https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verification-InOrder"">this wiki page</a>.
     * <p>
     * As of Mockito 1.8.4 you can verifyNoMoreInteractions() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified in order
     *
     * @return InOrder object to be used to verify in order
     */
    public static InOrder inOrder(Object... mocks) {
        return MOCKITO_CORE.inOrder(mocks);
    }

    /**
     * Ignores stubbed methods of given mocks for the sake of verification.
     * Please consider using {@link Strictness#STRICT_STUBS} feature which eliminates the need for <code>ignoreStubs()</code>
     * and provides other benefits.
     * <p>
     * <code>ignoreStubs()</code> is sometimes useful when coupled with <code>verifyNoMoreInteractions()</code> or verification <code>inOrder()</code>.
     * Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs.
     * <p>
     * <b>Warning</b>, <code>ignoreStubs()</code> might lead to overuse of <code>verifyNoMoreInteractions(ignoreStubs(...));</code>
     * Bear in mind that Mockito does not recommend bombarding every test with <code>verifyNoMoreInteractions()</code>
     * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}
     * Other words: all <b>*stubbed*</b> methods of given mocks are marked <b>*verified*</b> so that they don't get in a way during verifyNoMoreInteractions().
     * <p>
     * This method <b>changes the input mocks</b>! This method returns input mocks just for convenience.
     * <p>
     * Ignored stubs will also be ignored for verification inOrder, including {@link org.mockito.InOrder#verifyNoMoreInteractions()}.
     * See the second example.
     * <p>
     * Example:
     * <pre class=""code""><code class=""java"">
     *  //mocking lists for the sake of the example (if you mock List in real you will burn in hell)
     *  List mock1 = mock(List.class), mock2 = mock(List.class);
     *
     *  //stubbing mocks:
     *  when(mock1.get(0)).thenReturn(10);
     *  when(mock2.get(0)).thenReturn(20);
     *
     *  //using mocks by calling stubbed get(0) methods:
     *  System.out.println(mock1.get(0)); //prints 10
     *  System.out.println(mock2.get(0)); //prints 20
     *
     *  //using mocks by calling clear() methods:
     *  mock1.clear();
     *  mock2.clear();
     *
     *  //verification:
     *  verify(mock1).clear();
     *  verify(mock2).clear();
     *
     *  //verifyNoMoreInteractions() fails because get() methods were not accounted for.
     *  try { verifyNoMoreInteractions(mock1, mock2); } catch (NoInteractionsWanted e);
     *
     *  //However, if we ignore stubbed methods then we can verifyNoMoreInteractions()
     *  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));
     *
     *  //Remember that ignoreStubs() <b>*changes*</b> the input mocks and returns them for convenience.
     * </code></pre>
     * Ignoring stubs can be used with <b>verification in order</b>:
     * <pre class=""code""><code class=""java"">
     *  List list = mock(List.class);
     *  when(list.get(0)).thenReturn(""foo"");
     *
     *  list.add(0);
     *  list.clear();
     *  System.out.println(list.get(0)); //we don't want to verify this
     *
     *  InOrder inOrder = inOrder(ignoreStubs(list));
     *  inOrder.verify(list).add(0);
     *  inOrder.verify(list).clear();
     *  inOrder.verifyNoMoreInteractions();
     * </code></pre>
     * Stubbed invocations are automatically verified with {@link Strictness#STRICT_STUBS} feature
     * and it eliminates the need for <code>ignoreStubs()</code>. Example below uses JUnit Rules:
     * <pre class=""code""><code class=""java"">
     *  &#064;Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
     *
     *  List list = mock(List.class);
     *  when(list.get(0)).thenReturn(""foo"");
     *
     *  list.size();
     *  verify(list).size();
     *
     *  list.get(0); // Automatically verified by STRICT_STUBS
     *  verifyNoMoreInteractions(list); // No need of ignoreStubs()
     * </code></pre>
     *
     * @since 1.9.0
     * @param mocks input mocks that will be changed
     * @return the same mocks that were passed in as parameters
     */
    public static Object[] ignoreStubs(Object... mocks) {
        return MOCKITO_CORE.ignoreStubs(mocks);
    }

    /**
     * Allows verifying exact number of invocations. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, times(2)).someMethod(""some arg"");
     * </code></pre>
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param wantedNumberOfInvocations wanted number of invocations
     *
     * @return verification mode
     */
    public static VerificationMode times(int wantedNumberOfInvocations) {
        return VerificationModeFactory.times(wantedNumberOfInvocations);
    }

    /**
     * Alias to <code>times(0)</code>, see {@link Mockito#times(int)}
     * <p>
     * Verifies that interaction did not happen. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, never()).someMethod();
     * </code></pre>
     *
     * <p>
     * If you want to verify there were NO interactions with the mock
     * check out {@link Mockito#verifyNoMoreInteractions(Object...)}
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    public static VerificationMode never() {
        return times(0);
    }

    /**
     * Allows at-least-once verification. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, atLeastOnce()).someMethod(""some arg"");
     * </code></pre>
     * Alias to <code>atLeast(1)</code>.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    public static VerificationMode atLeastOnce() {
        return VerificationModeFactory.atLeastOnce();
    }

    /**
     * Allows at-least-x verification. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, atLeast(3)).someMethod(""some arg"");
     * </code></pre>
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param minNumberOfInvocations minimum number of invocations
     *
     * @return verification mode
     */
    public static VerificationMode atLeast(int minNumberOfInvocations) {
        return VerificationModeFactory.atLeast(minNumberOfInvocations);
    }

    /**
     * Allows at-most-once verification. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, atMostOnce()).someMethod(""some arg"");
     * </code></pre>
     * Alias to <code>atMost(1)</code>.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    public static VerificationMode atMostOnce() {
        return VerificationModeFactory.atMostOnce();
    }

    /**
     * Allows at-most-x verification. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, atMost(3)).someMethod(""some arg"");
     * </code></pre>
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param maxNumberOfInvocations max number of invocations
     *
     * @return verification mode
     */
    public static VerificationMode atMost(int maxNumberOfInvocations) {
        return VerificationModeFactory.atMost(maxNumberOfInvocations);
    }

    /**
     * Allows non-greedy verification in order.  For example
     * <pre class=""code""><code class=""java"">
     *   inOrder.verify( mock, calls( 2 )).someMethod( ""some arg"" );
     * </code></pre>
     * <ul>
     * <li>will not fail if the method is called 3 times, unlike times( 2 )</li>
     * <li>will not mark the third invocation as verified, unlike atLeast( 2 )</li>
     * </ul>
     * This verification mode can only be used with in order verification.
     * @param wantedNumberOfInvocations number of invocations to verify
     * @return  verification mode
     */
    public static VerificationMode calls(int wantedNumberOfInvocations) {
        return VerificationModeFactory.calls(wantedNumberOfInvocations);
    }

    /**
     * Allows checking if given method was the only one invoked. E.g:
     * <pre class=""code""><code class=""java"">
     *   verify(mock, only()).someMethod();
     *   //above is a shorthand for following 2 lines of code:
     *   verify(mock).someMethod();
     *   verifyNoMoreInteractions(mock);
     * </code></pre>
     *
     * <p>
     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}
     * <p>
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    public static VerificationMode only() {
        return VerificationModeFactory.only();
    }

    /**
     * Verification will be triggered over and over until the given amount of millis, allowing testing of async code.
     * Useful when interactions with the mock object did not happened yet.
     * Extensive use of {@code timeout()} method can be a code smell - there are better ways of testing concurrent code.
     * <p>
     * See also {@link #after(long)} method for testing async code.
     * Differences between {@code timeout()} and {@code after} are explained in Javadoc for {@link #after(long)}.
     *
     * <pre class=""code""><code class=""java"">
     *   //passes when someMethod() is called no later than within 100 ms
     *   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
     *   verify(mock, timeout(100)).someMethod();
     *   //above is an alias to:
     *   verify(mock, timeout(100).times(1)).someMethod();
     *
     *   //passes as soon as someMethod() has been called 2 times under 100 ms
     *   verify(mock, timeout(100).times(2)).someMethod();
     *
     *   //equivalent: this also passes as soon as someMethod() has been called 2 times under 100 ms
     *   verify(mock, timeout(100).atLeast(2)).someMethod();
     * </code></pre>
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param millis - duration in milliseconds
     *
     * @return object that allows fluent specification of the verification (times(x), atLeast(y), etc.)
     */
    public static VerificationWithTimeout timeout(long millis) {
        return new Timeout(millis, VerificationModeFactory.times(1));
    }

    /**
     * Verification will be triggered after given amount of millis, allowing testing of async code.
     * Useful when interactions with the mock object did not happened yet.
     * Extensive use of {@code after()} method can be a code smell - there are better ways of testing concurrent code.
     * <p>
     * Not yet implemented to work with InOrder verification.
     * <p>
     * See also {@link #timeout(long)} method for testing async code.
     * Differences between {@code timeout()} and {@code after()} are explained below.
     *
     * <pre class=""code""><code class=""java"">
     *   //passes after 100ms, if someMethod() has only been called once at that time.
     *   verify(mock, after(100)).someMethod();
     *   //above is an alias to:
     *   verify(mock, after(100).times(1)).someMethod();
     *
     *   //passes if someMethod() is called <b>*exactly*</b> 2 times, as tested after 100 millis
     *   verify(mock, after(100).times(2)).someMethod();
     *
     *   //passes if someMethod() has not been called, as tested after 100 millis
     *   verify(mock, after(100).never()).someMethod();
     *
     *   //verifies someMethod() after a given time span using given verification mode
     *   //useful only if you have your own custom verification modes.
     *   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();
     * </code></pre>
     *
     * <strong>timeout() vs. after()</strong>
     * <ul>
     *     <li>timeout() exits immediately with success when verification passes</li>
     *     <li>after() awaits full duration to check if verification passes</li>
     * </ul>
     * Examples:
     * <pre class=""code""><code class=""java"">
     *   //1.
     *   mock.foo();
     *   verify(mock, after(1000)).foo();
     *   //waits 1000 millis and succeeds
     *
     *   //2.
     *   mock.foo();
     *   verify(mock, timeout(1000)).foo();
     *   //succeeds immediately
     * </code></pre>
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param millis - duration in milliseconds
     *
     * @return object that allows fluent specification of the verification
     */
    public static VerificationAfterDelay after(long millis) {
        return new After(millis, VerificationModeFactory.times(1));
    }

    /**
     * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=""https://github.com/mockito/mockito/wiki/FAQ"">https://github.com/mockito/mockito/wiki/FAQ</a>
     * <p>
     * In case of questions you may also post to mockito mailing list: <a href=""https://groups.google.com/group/mockito"">https://groups.google.com/group/mockito</a>
     * <p>
     * <code>validateMockitoUsage()</code> <b>explicitly validates</b> the framework state to detect invalid use of Mockito.
     * However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.
     * <p>
     * Examples of incorrect use:
     * <pre class=""code""><code class=""java"">
     * //Oops, thenReturn() part is missing:
     * when(mock.get());
     *
     * //Oops, verified method call is inside verify() where it should be on the outside:
     * verify(mock.execute());
     *
     * //Oops, missing method to verify:
     * verify(mock);
     * </code></pre>
     *
     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly.
     * The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.).
     * But even though the exception might be thrown in the next test,
     * the exception <b>message contains a navigable stack trace element</b> with location of the defect.
     * Hence you can click and find the place where Mockito was misused.
     * <p>
     * Sometimes though, you might want to validate the framework usage explicitly.
     * For example, one of the users wanted to put <code>validateMockitoUsage()</code> in his <code>&#064;After</code> method
     * so that he knows immediately when he misused Mockito.
     * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.
     * One more benefit of having <code>validateMockitoUsage()</code> in <code>&#064;After</code> is that jUnit runner and rule will always fail in the test method with defect
     * whereas ordinary 'next-time' validation might fail the <b>next</b> test method.
     * But even though JUnit might report next test as red, don't worry about it
     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.
     * <p>
     * <b>Both built-in runner: {@link MockitoJUnitRunner} and rule: {@link MockitoRule}</b> do validateMockitoUsage() after each test method.
     * <p>
     * Bear in mind that <b>usually you don't have to <code>validateMockitoUsage()</code></b>
     * and framework validation triggered on next-time basis should be just enough,
     * mainly because of enhanced exception message with clickable location of defect.
     * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure
     * (like your own runner or base class for all tests) because adding a special action to <code>&#064;After</code> has zero cost.
     * <p>
     * See examples in javadoc for {@link Mockito} class
     */
    public static void validateMockitoUsage() {
        MOCKITO_CORE.validateMockitoUsage();
    }

    /**
     * Allows mock creation with additional mock settings.
     * <p>
     * Don't use it too often.
     * Consider writing simple tests that use simple mocks.
     * Repeat after me: simple tests push simple, KISSy, readable and maintainable code.
     * If you cannot write a test in a simple way - refactor the code under test.
     * <p>
     * Examples of mock settings:
     * <pre class=""code""><code class=""java"">
     *   //Creates mock with different default answer and name
     *   Foo mock = mock(Foo.class, withSettings()
     *       .defaultAnswer(RETURNS_SMART_NULLS)
     *       .name(""cool mockie""));
     *
     *   //Creates mock with different default answer, descriptive name and extra interfaces
     *   Foo mock = mock(Foo.class, withSettings()
     *       .defaultAnswer(RETURNS_SMART_NULLS)
     *       .name(""cool mockie"")
     *       .extraInterfaces(Bar.class));
     * </code></pre>
     * {@link MockSettings} has been introduced for two reasons.
     * Firstly, to make it easy to add another mock settings when the demand comes.
     * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.
     * <p>
     * See javadoc for {@link MockSettings} to learn about possible mock settings.
     * <p>
     *
     * @return mock settings instance with defaults.
     */
    public static MockSettings withSettings() {
        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);
    }

    /**
     * Adds a description to be printed if verification fails.
     * <pre class=""code""><code class=""java"">
     * verify(mock, description(""This will print on failure"")).someMethod(""some arg"");
     * </code></pre>
     * @param description The description to print on failure.
     * @return verification mode
     * @since 2.1.0
     */
    public static VerificationMode description(String description) {
        return times(1).description(description);
    }

    /**
     * For advanced users or framework integrators. See {@link MockitoFramework} class.
     *
     * @since 2.1.0
     */
    public static MockitoFramework framework() {
        return new DefaultMockitoFramework();
    }

    /**
     * {@code MockitoSession} is an optional, highly recommended feature
     * that helps driving cleaner tests by eliminating boilerplate code and adding extra validation.
     * <p>
     * For more information, including use cases and sample code, see the javadoc for {@link MockitoSession}.
     *
     * @since 2.7.0
     */
    public static MockitoSessionBuilder mockitoSession() {
        return new DefaultMockitoSessionBuilder();
    }

    /**
     * Lenient stubs bypass ""strict stubbing"" validation (see {@link Strictness#STRICT_STUBS}).
     * When stubbing is declared as lenient, it will not be checked for potential stubbing problems such as
     * 'unnecessary stubbing' ({@link UnnecessaryStubbingException}) or for 'stubbing argument mismatch' {@link PotentialStubbingProblem}.
     *
     * <pre class=""code""><code class=""java"">
     *   lenient().when(mock.foo()).thenReturn(""ok"");
     * </code></pre>
     *
     * Most mocks in most tests don't need leniency and should happily prosper with {@link Strictness#STRICT_STUBS}.
     * <ul>
     *     <li>If a specific stubbing needs to be lenient - use this method</li>
     *     <li>If a specific mock need to have stubbings lenient - use {@link MockSettings#lenient()}</li>
     *     <li>If a specific test method / test class needs to have all stubbings lenient
     *          - configure strictness using our JUnit support ({@link MockitoJUnit} or Mockito Session ({@link MockitoSession})</li>
     *
     * <h3>Elaborate example</h3>
     *
     * In below example, 'foo.foo()' is a stubbing that was moved to 'before()' method to avoid duplication.
     * Doing so makes one of the test methods ('test3()') fail with 'unnecessary stubbing'.
     * To resolve it we can configure 'foo.foo()' stubbing in 'before()' method to be lenient.
     * Alternatively, we can configure entire 'foo' mock as lenient.
     * <p>
     * This example is simplified and not realistic.
     * Pushing stubbings to 'before()' method may cause tests to be less readable.
     * Some repetition in tests is OK, use your own judgement to write great tests!
     * It is not desired to eliminate all possible duplication from the test code
     * because it may add complexity and conceal important test information.
     *
     * <pre class=""code""><code class=""java"">
     * public class SomeTest {
     *
     *     &#064;Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(STRICT_STUBS);
     *
     *     &#064;Mock Foo foo;
     *     &#064;Mock Bar bar;
     *
     *     &#064;Before public void before() {
     *         when(foo.foo()).thenReturn(""ok"");
     *
     *         // it is better to configure the stubbing to be lenient:
     *         // lenient().when(foo.foo()).thenReturn(""ok"");
     *
     *         // or the entire mock to be lenient:
     *         // foo = mock(Foo.class, withSettings().lenient());
     *     }
     *
     *     &#064;Test public void test1() {
     *         foo.foo();
     *     }
     *
     *     &#064;Test public void test2() {
     *         foo.foo();
     *     }
     *
     *     &#064;Test public void test3() {
     *         bar.bar();
     *     }
     * }
     * </code></pre>
     *
     * @since 2.20.0
     */
    public static LenientStubber lenient() {
        return MOCKITO_CORE.lenient();
    }
}",1,64 2000 64 2001 40 648 41 439 334 2002 378 2003 123 457 381 2004 2005 61 418 2004 40 41 59 618 439 457 381 2006 60 2007 62 2008 61 2009 46 2008 59 618 439 457 381 2006 60 2007 62 2010 61 2009 46 2010 59 618 439 457 381 2006 60 2007 62 2011 61 2009 46 2011 59 618 439 457 381 2006 60 2007 62 2012 61 2009 46 2012 59 618 439 457 381 2006 60 2007 62 2013 61 2009 46 2013 59 618 439 457 381 2006 60 2007 62 2014 61 2009 46 2014 59 618 439 457 60 2015 62 2015 2016 40 2017 60 2015 62 2018 41 123 450 2016 40 2018 44 2019 40 41 41 59 125 618 439 457 60 2015 62 2015 2016 40 2017 60 2015 62 2018 44 2020 2021 41 123 450 2016 40 2018 44 2022 40 41 46 2021 40 2021 41 46 2023 40 2008 41 41 59 125 618 439 457 2024 2025 40 2007 2026 41 123 450 2005 46 2025 40 2026 41 59 125 618 439 457 60 2015 62 2015 2016 40 2017 60 2015 62 2018 44 2006 2027 41 123 450 2016 40 2018 44 2028 40 41 46 2027 40 2027 41 41 59 125 618 439 457 60 2015 62 2015 2016 40 2017 60 2015 62 2018 44 2029 2030 41 123 450 2005 46 2016 40 2018 44 2030 41 59 125 618 439 457 60 2015 62 2015 2031 40 2015 426 41 123 450 2005 46 2016 40 40 2017 60 2015 62 41 426 46 2032 40 41 44 2033 40 41 46 2034 40 426 41 46 2027 40 2013 41 41 59 125 618 439 457 60 2015 62 2015 2031 40 2017 60 2015 62 2035 41 123 450 2005 46 2016 40 2035 44 2036 40 41 46 2037 40 41 46 2027 40 2013 41 41 59 125 618 439 457 60 2015 62 2038 60 2015 62 2039 40 2017 60 2015 62 2018 41 123 450 2039 40 2018 44 2040 40 41 41 59 125 618 439 457 60 2015 62 2038 60 2015 62 2039 40 2017 60 2015 62 2018 44 2006 2027 41 123 450 2039 40 2018 44 2041 40 41 46 2027 40 2027 41 41 59 125 618 439 457 60 2015 62 2038 60 2015 62 2039 40 2017 60 2015 62 2018 44 2020 2021 41 123 450 2039 40 2018 44 2042 40 41 46 2021 40 2021 41 41 59 125 618 439 457 60 2015 62 2038 60 2015 62 2039 40 2017 60 2015 62 2018 44 2029 2030 41 123 450 2005 46 2039 40 2018 44 2030 41 59 125 618 439 457 60 2015 62 2043 60 2015 62 2044 40 2017 60 2015 62 2018 44 2006 2027 44 2006 613 2045 41 123 450 2046 40 2018 44 2047 45 62 123 392 40 2047 46 2048 40 41 614 1501 606 2045 46 2049 614 1500 41 123 450 2050 40 41 46 2027 40 2027 41 59 125 360 392 40 2047 46 2048 40 41 615 2045 46 2049 41 123 450 2051 40 41 46 2027 40 2045 91 2045 46 2049 45 1501 93 41 59 125 360 123 450 2052 40 41 46 2027 40 2045 91 2047 46 2048 40 41 45 1502 93 41 59 125 125 44 40 2016 44 2047 41 45 62 123 125 41 59 125 618 439 457 60 2015 62 2043 60 2015 62 2053 40 2017 60 2015 62 2018 41 123 450 2053 40 2018 44 2054 45 62 2055 40 41 44 40 2016 44 2056 41 45 62 123 125 41 59 125 618 439 457 60 2015 62 2043 60 2015 62 2053 40 2017 60 2015 62 2018 44 2043 46 2057 60 2015 62 2058 41 123 450 2053 40 2018 44 2059 40 41 44 2058 41 59 125 618 439 457 60 2015 62 2043 60 2015 62 2053 40 2017 60 2015 62 2018 44 2029 2030 41 123 450 2053 40 2018 44 2060 45 62 2030 41 59 125 618 439 457 60 2015 62 2043 60 2015 62 2053 40 2017 60 2015 62 2018 44 2061 60 2043 46 2062 44 2029 62 2063 41 123 450 2053 40 2018 44 2063 44 40 2016 44 2064 41 45 62 123 125 41 59 125 618 439 457 60 2015 62 2043 60 2015 62 2053 40 2017 60 2015 62 2018 44 2029 2030 44 2043 46 2057 60 2015 62 2058 41 123 450 2053 40 2018 44 2065 45 62 2030 44 2058 41 59 125 618 439 457 60 2015 62 2043 60 2015 62 2053 40 2017 60 2015 62 2018 44 2061 60 2043 46 2062 44 2029 62 2063 44 2043 46 2057 60 2015 62 2058 41 123 450 2005 46 2053 40 2018 44 2063 44 2058 41 59 125 618 439 457 60 2015 62 2066 60 2015 62 2067 40 2015 2068 41 123 450 2005 46 2067 40 2068 41 59 125 618 439 457 60 2015 62 2015 2069 40 2015 2016 41 123 450 2005 46 2069 40 2016 44 2070 40 1501 41 41 59 125 618 439 457 60 2015 62 2015 2069 40 2015 2016 44 2071 2072 41 123 450 2005 46 2069 40 2016 44 2072 41 59 125 618 439 457 60 2015 62 492 2073 40 2015 613 2074 41 123 2005 46 2073 40 2074 41 59 125 618 439 457 492 2075 40 41 123 2005 46 2075 40 41 59 125 618 439 457 60 2015 62 492 2076 40 2015 613 2074 41 123 2005 46 2076 40 2074 41 59 125 618 439 457 492 2077 40 2007 613 2074 41 123 2005 46 2077 40 2074 41 59 125 618 439 457 492 2078 40 2007 613 2074 41 123 2005 46 2078 40 2074 41 59 125 618 439 457 2079 2080 40 2081 613 2082 41 123 450 2005 46 2083 40 41 46 2080 40 2082 41 59 125 618 439 457 2079 2080 40 2017 60 63 378 2081 62 2082 41 123 450 2005 46 2084 40 41 46 2080 40 2082 41 59 125 618 621 621 64 2001 40 123 648 44 648 125 41 439 457 2079 2080 40 2017 60 63 378 2081 62 2082 44 2017 60 63 378 2081 62 613 2085 41 123 450 2005 46 2086 40 41 46 2080 40 2082 44 2085 41 59 125 618 439 457 2079 2087 40 41 123 450 2005 46 2088 40 41 46 2087 40 41 59 125 618 439 457 2079 2089 40 2006 2090 41 123 450 2005 46 2091 40 41 46 2089 40 2090 41 59 125 618 439 457 2079 2092 40 41 123 450 2005 46 2093 40 41 46 2092 40 41 59 125 618 439 457 2079 2094 40 2007 2095 41 123 450 2005 46 2096 40 41 46 2094 40 2095 41 59 125 618 64 2001 40 123 648 44 648 125 41 439 457 2079 2094 40 2007 2095 44 2007 613 2097 41 123 450 2005 46 2098 40 41 46 2094 40 2095 44 2097 41 59 125 618 439 457 2099 2100 40 2007 613 2074 41 123 450 2005 46 2100 40 2074 41 59 125 618 439 457 2007 91 93 2101 40 2007 613 2074 41 123 450 2005 46 2101 40 2074 41 59 125 618 439 457 2071 2102 40 404 2103 41 123 450 2104 46 2102 40 2103 41 59 125 618 439 457 2071 2105 40 41 123 450 2102 40 1500 41 59 125 618 439 457 2071 2106 40 41 123 450 2107 46 2106 40 41 59 125 618 439 457 2071 2108 40 404 2109 41 123 450 2110 46 2108 40 2109 41 59 125 618 439 457 2071 2111 40 41 123 450 2112 46 2111 40 41 59 125 618 439 457 2071 2113 40 404 2114 41 123 450 2115 46 2113 40 2114 41 59 125 618 439 457 2071 2116 40 404 2103 41 123 450 2117 46 2116 40 2103 41 59 125 618 439 457 2071 2118 40 41 123 450 2119 46 2118 40 41 59 125 618 439 457 2120 2121 40 413 2122 41 123 450 418 2123 40 2122 44 2124 46 2102 40 1501 41 41 59 125 618 439 457 2125 2126 40 413 2122 41 123 450 418 2127 40 2122 44 2128 46 2102 40 1501 41 41 59 125 618 439 457 492 2129 40 41 123 2005 46 2129 40 41 59 125 618 439 457 2029 2130 40 41 123 450 418 2131 40 41 46 2027 40 2008 41 59 125 618 439 457 2071 2132 40 2020 2132 41 123 450 2102 40 1501 41 46 2132 40 2132 41 59 125 618 439 457 2133 2134 40 41 123 450 418 2135 40 41 59 125 618 439 457 2136 2137 40 41 123 450 418 2138 40 41 59 125 618 439 457 2139 2140 40 41 123 450 2005 46 2140 40 41 59 125 125 
29301,Java,"@Provides
public class HandleGetter extends JavacAnnotationHandler<Getter> {
	private static final String GETTER_NODE_NOT_SUPPORTED_ERR = ""@Getter is only supported on a class, an enum, or a field."";
	
	public void generateGetterForType(JavacNode typeNode, JavacNode errorNode, AccessLevel level, boolean checkForTypeLevelGetter, List<JCAnnotation> onMethod) {
		if (checkForTypeLevelGetter) {
			if (hasAnnotation(Getter.class, typeNode)) {
				//The annotation will make it happen, so we can skip it.
				return;
			}
		}
		
		if (!isClassOrEnum(typeNode)) {
			errorNode.addError(GETTER_NODE_NOT_SUPPORTED_ERR);
			return;
		}
		
		for (JavacNode field : typeNode.down()) {
			if (fieldQualifiesForGetterGeneration(field)) generateGetterForField(field, errorNode.get(), level, false, onMethod);
		}
	}
	
	public static boolean fieldQualifiesForGetterGeneration(JavacNode field) {
		if (field.getKind() != Kind.FIELD) return false;
		JCVariableDecl fieldDecl = (JCVariableDecl) field.get();
		//Skip fields that start with $
		if (fieldDecl.name.toString().startsWith(""$"")) return false;
		//Skip static fields.
		if ((fieldDecl.mods.flags & Flags.STATIC) != 0) return false;
		return true;
	}
	
	/**
	 * Generates a getter on the stated field.
	 * 
	 * Used by {@link HandleData}.
	 * 
	 * The difference between this call and the handle method is as follows:
	 * 
	 * If there is a {@code lombok.Getter} annotation on the field, it is used and the
	 * same rules apply (e.g. warning if the method already exists, stated access level applies).
	 * If not, the getter is still generated if it isn't already there, though there will not
	 * be a warning if its already there. The default access level is used.
	 * 
	 * @param fieldNode The node representing the field you want a getter for.
	 * @param pos The node responsible for generating the getter (the {@code @Data} or {@code @Getter} annotation).
	 */
	public void generateGetterForField(JavacNode fieldNode, DiagnosticPosition pos, AccessLevel level, boolean lazy, List<JCAnnotation> onMethod) {
		if (hasAnnotation(Getter.class, fieldNode)) {
			//The annotation will make it happen, so we can skip it.
			return;
		}
		createGetterForField(level, fieldNode, fieldNode, false, lazy, onMethod);
	}
	
	@Override public void handle(AnnotationValues<Getter> annotation, JCAnnotation ast, JavacNode annotationNode) {
		handleFlagUsage(annotationNode, ConfigurationKeys.GETTER_FLAG_USAGE, ""@Getter"");
		
		Collection<JavacNode> fields = annotationNode.upFromAnnotationToFields();
		deleteAnnotationIfNeccessary(annotationNode, Getter.class);
		deleteImportFromCompilationUnit(annotationNode, ""lombok.AccessLevel"");
		JavacNode node = annotationNode.up();
		Getter annotationInstance = annotation.getInstance();
		AccessLevel level = annotationInstance.value();
		boolean lazy = annotationInstance.lazy();
		if (lazy) handleFlagUsage(annotationNode, ConfigurationKeys.GETTER_LAZY_FLAG_USAGE, ""@Getter(lazy=true)"");
		
		if (level == AccessLevel.NONE) {
			if (lazy) annotationNode.addWarning(""'lazy' does not work with AccessLevel.NONE."");
			return;
		}
		
		if (node == null) return;
		
		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, ""onMethod"", ""@Getter(onMethod"", annotationNode);
		
		switch (node.getKind()) {
		case FIELD:
			createGetterForFields(level, fields, annotationNode, true, lazy, onMethod);
			break;
		case TYPE:
			if (lazy) annotationNode.addError(""'lazy' is not supported for @Getter on a type."");
			generateGetterForType(node, annotationNode, level, false, onMethod);
			break;
		}
	}
	
	public void createGetterForFields(AccessLevel level, Collection<JavacNode> fieldNodes, JavacNode errorNode, boolean whineIfExists, boolean lazy, List<JCAnnotation> onMethod) {
		for (JavacNode fieldNode : fieldNodes) {
			createGetterForField(level, fieldNode, errorNode, whineIfExists, lazy, onMethod);
		}
	}
	
	public void createGetterForField(AccessLevel level,
			JavacNode fieldNode, JavacNode source, boolean whineIfExists, boolean lazy, List<JCAnnotation> onMethod) {
		
		if (fieldNode.getKind() != Kind.FIELD) {
			source.addError(GETTER_NODE_NOT_SUPPORTED_ERR);
			return;
		}
		
		JCVariableDecl fieldDecl = (JCVariableDecl)fieldNode.get();
		
		if (lazy) {
			if ((fieldDecl.mods.flags & Flags.PRIVATE) == 0 || (fieldDecl.mods.flags & Flags.FINAL) == 0) {
				source.addError(""'lazy' requires the field to be private and final."");
				return;
			}
			if ((fieldDecl.mods.flags & Flags.TRANSIENT) != 0) {
				source.addError(""'lazy' is not supported on transient fields."");
				return;
			}
			if (fieldDecl.init == null) {
				source.addError(""'lazy' requires field initialization."");
				return;
			}
		}
		
		String methodName = toGetterName(fieldNode);
		
		if (methodName == null) {
			source.addWarning(""Not generating getter for this field: It does not fit your @Accessors prefix list."");
			return;
		}
		
		for (String altName : toAllGetterNames(fieldNode)) {
			switch (methodExists(altName, fieldNode, false, 0)) {
			case EXISTS_BY_LOMBOK:
				return;
			case EXISTS_BY_USER:
				if (whineIfExists) {
					String altNameExpl = """";
					if (!altName.equals(methodName)) altNameExpl = String.format("" (%s)"", altName);
					source.addWarning(
						String.format(""Not generating %s(): A method with that name already exists%s"", methodName, altNameExpl));
				}
				return;
			default:
			case NOT_EXISTS:
				//continue scanning the other alt names.
			}
		}
		
		long access = toJavacModifier(level) | (fieldDecl.mods.flags & Flags.STATIC);
		
		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
	}
	
	public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker treeMaker, JavacNode source, boolean lazy, List<JCAnnotation> onMethod) {
		JCVariableDecl fieldNode = (JCVariableDecl) field.get();
		
		// Remember the type; lazy will change it
		JCExpression methodType = cloneType(treeMaker, copyType(treeMaker, fieldNode), source);
		// Generate the methodName; lazy will change the field type
		Name methodName = field.toName(toGetterName(field));
		
		List<JCStatement> statements;
		JCTree toClearOfMarkers = null;
		int[] methodArgPos = null;
		boolean addSuppressWarningsUnchecked = false;
		if (lazy && !inNetbeansEditor(field)) {
			toClearOfMarkers = fieldNode.init;
			if (toClearOfMarkers instanceof JCMethodInvocation) {
				List<JCExpression> args = ((JCMethodInvocation) toClearOfMarkers).args;
				methodArgPos = new int[args.length()];
				for (int i = 0; i < methodArgPos.length; i++) {
					methodArgPos[i] = args.get(i).pos;
				}
			}
			statements = createLazyGetterBody(treeMaker, field, source);
			addSuppressWarningsUnchecked = LombokOptionsFactory.getDelombokOptions(field.getContext()).getFormatPreferences().generateSuppressWarnings();
		} else {
			statements = createSimpleGetterBody(treeMaker, field);
		}
		
		JCBlock methodBody = treeMaker.Block(0, statements);
		
		List<JCTypeParameter> methodGenericParams = List.nil();
		List<JCVariableDecl> parameters = List.nil();
		List<JCExpression> throwsClauses = List.nil();
		JCExpression annotationMethodDefaultValue = null;
		
		List<JCAnnotation> copyableAnnotations = findCopyableAnnotations(field);
		List<JCAnnotation> delegates = findDelegatesAndRemoveFromField(field);
		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod).appendList(copyableAnnotations);
		if (field.isFinal()) {
			if (getCheckerFrameworkVersion(field).generatePure()) annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genTypeRef(field, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()));
		} else {
			if (getCheckerFrameworkVersion(field).generateSideEffectFree()) annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genTypeRef(field, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));
		}
		if (isFieldDeprecated(field)) annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genJavaLangTypeRef(field, ""Deprecated""), List.<JCExpression>nil()));
		
		JCMethodDecl decl = recursiveSetGeneratedBy(treeMaker.MethodDef(treeMaker.Modifiers(access, annsOnMethod), methodName, methodType,
			methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source);
		
		if (toClearOfMarkers != null) recursiveSetGeneratedBy(toClearOfMarkers, null);
		if (methodArgPos != null) {
			for (int i = 0; i < methodArgPos.length; i++) {
				((JCMethodInvocation) toClearOfMarkers).args.get(i).pos = methodArgPos[i];
			}
		}
		decl.mods.annotations = decl.mods.annotations.appendList(delegates);
		
		if (addSuppressWarningsUnchecked) {
			ListBuffer<JCExpression> suppressions = new ListBuffer<JCExpression>();
			if (!Boolean.FALSE.equals(field.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS))) {
				suppressions.append(treeMaker.Literal(""all""));
			}
			suppressions.append(treeMaker.Literal(""unchecked""));
			addAnnotation(decl.mods, field, source, ""java.lang.SuppressWarnings"", treeMaker.NewArray(null, List.<JCExpression>nil(), suppressions.toList()));
		}
		
		copyJavadoc(field, decl, CopyJavadoc.GETTER);
		return decl;
	}
	
	public static List<JCAnnotation> findDelegatesAndRemoveFromField(JavacNode field) {
		JCVariableDecl fieldNode = (JCVariableDecl) field.get();
		
		List<JCAnnotation> delegates = List.nil();
		for (JCAnnotation annotation : fieldNode.mods.annotations) {
			if (typeMatches(Delegate.class, field, annotation.annotationType)) {
				delegates = delegates.append(annotation);
			}
		}
		
		if (!delegates.isEmpty()) {
			ListBuffer<JCAnnotation> withoutDelegates = new ListBuffer<JCAnnotation>();
			for (JCAnnotation annotation : fieldNode.mods.annotations) {
				if (!delegates.contains(annotation)) {
					withoutDelegates.append(annotation);
				}
			}
			fieldNode.mods.annotations = withoutDelegates.toList();
			field.rebuild();
		}
		return delegates;
	}
	
	public List<JCStatement> createSimpleGetterBody(JavacTreeMaker treeMaker, JavacNode field) {
		return List.<JCStatement>of(treeMaker.Return(createFieldAccessor(treeMaker, field, FieldAccess.ALWAYS_FIELD)));
	}
	
	private static final String AR = ""java.util.concurrent.atomic.AtomicReference"";
	private static final List<JCExpression> NIL_EXPRESSION = List.nil();
	
	public static final java.util.Map<TypeTag, String> TYPE_MAP;
	static {
		Map<TypeTag, String> m = new HashMap<TypeTag, String>();
		m.put(CTC_INT, ""Integer"");
		m.put(CTC_DOUBLE, ""Double"");
		m.put(CTC_FLOAT, ""Float"");
		m.put(CTC_SHORT, ""Short"");
		m.put(CTC_BYTE, ""Byte"");
		m.put(CTC_LONG, ""Long"");
		m.put(CTC_BOOLEAN, ""Boolean"");
		m.put(CTC_CHAR, ""Character"");
		TYPE_MAP = Collections.unmodifiableMap(m);
	}
	
	public List<JCStatement> createLazyGetterBody(JavacTreeMaker maker, JavacNode fieldNode, JavacNode source) {
		/*
		java.lang.Object value = this.fieldName.get();
		if (value == null) {
			synchronized (this.fieldName) {
				value = this.fieldName.get();
				if (value == null) {
					final RawValueType actualValue = INITIALIZER_EXPRESSION;
					[IF PRIMITIVE]
					value = actualValue;
					[ELSE]
					value = actualValue == null ? this.fieldName : actualValue;
					[END IF]
					this.fieldName.set(value);
				}
			}
		}
		[IF PRIMITIVE]
		return (BoxedValueType) value;
		[ELSE]
		return (BoxedValueType) (value == this.fieldName ? null : value);
		[END IF]
		*/
		
		ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();
		
		JCVariableDecl field = (JCVariableDecl) fieldNode.get();
		JCExpression copyOfRawFieldType = copyType(maker, field);
		JCExpression copyOfBoxedFieldType = null;
		field.type = null;
		boolean isPrimitive = false;
		if (field.vartype instanceof JCPrimitiveTypeTree) {
			String boxed = TYPE_MAP.get(typeTag(field.vartype));
			if (boxed != null) {
				isPrimitive = true;
				field.vartype = genJavaLangTypeRef(fieldNode, boxed);
				copyOfBoxedFieldType = genJavaLangTypeRef(fieldNode, boxed);
			}
		}
		if (copyOfBoxedFieldType == null) copyOfBoxedFieldType = copyType(maker, field);
		
		Name valueName = fieldNode.toName(""value"");
		Name actualValueName = fieldNode.toName(""actualValue"");
		
		/* java.lang.Object value = this.fieldName.get();*/ {
			JCExpression valueVarType = genJavaLangTypeRef(fieldNode, ""Object"");
			statements.append(maker.VarDef(maker.Modifiers(0L), valueName, valueVarType, callGet(fieldNode, createFieldAccessor(maker, fieldNode, FieldAccess.ALWAYS_FIELD))));
		}
		
		/* if (value == null) { */ {
			JCSynchronized synchronizedStatement;
			/* synchronized (this.fieldName) { */ {
				ListBuffer<JCStatement> synchronizedStatements = new ListBuffer<JCStatement>();
				/* value = this.fieldName.get(); */ {
					JCExpressionStatement newAssign = maker.Exec(maker.Assign(maker.Ident(valueName), callGet(fieldNode, createFieldAccessor(maker, fieldNode, FieldAccess.ALWAYS_FIELD))));
					synchronizedStatements.append(newAssign);
				}
				
				/* if (value == null) { */ {
					ListBuffer<JCStatement> innerIfStatements = new ListBuffer<JCStatement>();
					/* final RawValueType actualValue = INITIALIZER_EXPRESSION; */ {
						innerIfStatements.append(maker.VarDef(maker.Modifiers(Flags.FINAL), actualValueName, copyOfRawFieldType, field.init));
					}
					/* [IF primitive] value = actualValue; */ {
						if (isPrimitive) {
							JCStatement statement = maker.Exec(maker.Assign(maker.Ident(valueName), maker.Ident(actualValueName)));
							innerIfStatements.append(statement);
						}
					}
					/* [ELSE] value = actualValue == null ? this.fieldName : actualValue; */ {
						if (!isPrimitive) {
							JCExpression actualValueIsNull = maker.Binary(CTC_EQUAL, maker.Ident(actualValueName), maker.Literal(CTC_BOT, null));
							JCExpression thisDotFieldName = createFieldAccessor(maker, fieldNode, FieldAccess.ALWAYS_FIELD);
							JCExpression ternary = maker.Conditional(actualValueIsNull, thisDotFieldName, maker.Ident(actualValueName));
							JCStatement statement = maker.Exec(maker.Assign(maker.Ident(valueName), ternary));
							innerIfStatements.append(statement);
						}
					}
					/* this.fieldName.set(value); */ {
						JCStatement statement = callSet(fieldNode, createFieldAccessor(maker, fieldNode, FieldAccess.ALWAYS_FIELD), maker.Ident(valueName));
						innerIfStatements.append(statement);
					}
					
					JCBinary isNull = maker.Binary(CTC_EQUAL, maker.Ident(valueName), maker.Literal(CTC_BOT, null));
					JCIf ifStatement = maker.If(isNull, maker.Block(0, innerIfStatements.toList()), null);
					synchronizedStatements.append(ifStatement);
				}
				
				synchronizedStatement = maker.Synchronized(createFieldAccessor(maker, fieldNode, FieldAccess.ALWAYS_FIELD), maker.Block(0, synchronizedStatements.toList()));
			}
			
			JCBinary isNull = maker.Binary(CTC_EQUAL, maker.Ident(valueName), maker.Literal(CTC_BOT, null));
			JCIf ifStatement = maker.If(isNull, maker.Block(0, List.<JCStatement>of(synchronizedStatement)), null);
			statements.append(ifStatement);
		}
		/* [IF PRIMITIVE] return (BoxedValueType) value; */ {
			if (isPrimitive) {
				statements.append(maker.Return(maker.TypeCast(copyOfBoxedFieldType, maker.Ident(valueName))));
			}
		}
		/* [ELSE] return (BoxedValueType) (value == this.fieldName ? null : value); */ {
			if (!isPrimitive) {
				JCExpression valueEqualsSelf = maker.Binary(CTC_EQUAL, maker.Ident(valueName), createFieldAccessor(maker, fieldNode, FieldAccess.ALWAYS_FIELD));
				JCExpression ternary = maker.Conditional(valueEqualsSelf, maker.Literal(CTC_BOT,  null), maker.Ident(valueName));
				JCExpression typeCast = maker.TypeCast(copyOfBoxedFieldType, maker.Parens(ternary));
				statements.append(maker.Return(typeCast));
			}
		}
		
		// update the field type and init last
		
		/*	private final java.util.concurrent.atomic.AtomicReference<Object> fieldName = new java.util.concurrent.atomic.AtomicReference<Object>(); */ {
			field.vartype = recursiveSetGeneratedBy(
				maker.TypeApply(chainDotsString(fieldNode, AR), List.<JCExpression>of(genJavaLangTypeRef(fieldNode, ""Object""))), source);
			field.init = recursiveSetGeneratedBy(maker.NewClass(null, NIL_EXPRESSION, copyType(maker, field), NIL_EXPRESSION, null), source);
		}
		
		return statements.toList();
	}
	
	public JCMethodInvocation callGet(JavacNode source, JCExpression receiver) {
		JavacTreeMaker maker = source.getTreeMaker();
		return maker.Apply(NIL_EXPRESSION, maker.Select(receiver, source.toName(""get"")), NIL_EXPRESSION);
	}
	
	public JCStatement callSet(JavacNode source, JCExpression receiver, JCExpression value) {
		JavacTreeMaker maker = source.getTreeMaker();
		return maker.Exec(maker.Apply(NIL_EXPRESSION, maker.Select(receiver, source.toName(""set"")), List.<JCExpression>of(value)));
	}
	
	public JCExpression copyType(JavacTreeMaker treeMaker, JCVariableDecl fieldNode) {
		return fieldNode.type != null ? treeMaker.Type(fieldNode.type) : fieldNode.vartype;
	}
}",1,64 2000 439 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 648 59 439 492 2006 40 2007 2008 44 2007 2009 44 2010 2011 44 324 2012 44 2013 60 2014 62 2015 41 123 392 40 2012 41 123 392 40 2016 40 2003 46 334 44 2008 41 41 123 621 450 59 125 125 392 40 33 2017 40 2008 41 41 123 2009 46 2018 40 2005 41 59 450 59 125 385 40 2007 2019 58 2008 46 2020 40 41 41 123 392 40 2021 40 2019 41 41 2022 40 2019 44 2009 46 2023 40 41 44 2011 44 380 44 2015 41 59 125 125 439 457 324 2024 40 2007 2025 41 123 392 40 2025 46 2026 40 41 631 2027 46 2028 41 450 380 59 2029 2030 61 40 2029 41 2025 46 2031 40 41 59 621 392 40 2030 46 2032 46 2033 40 41 46 2034 40 648 41 41 450 380 59 621 392 40 40 2030 46 2035 46 2036 38 2037 46 2038 41 631 1500 41 450 380 59 450 473 59 125 618 439 492 2039 40 2007 2040 44 2041 2042 44 2010 2011 44 324 2043 44 2013 60 2014 62 2015 41 123 392 40 2044 40 2003 46 334 44 2040 41 41 123 621 450 59 125 2045 40 2011 44 2040 44 2040 44 380 44 2043 44 2015 41 59 125 64 2046 439 492 2047 40 2048 60 2003 62 2049 44 2014 2050 44 2007 2051 41 123 2052 40 2051 44 2053 46 2054 44 648 41 59 2055 60 2007 62 2056 61 2051 46 2057 40 41 59 2058 40 2051 44 2003 46 334 41 59 2059 40 2051 44 648 41 59 2007 2060 61 2051 46 2061 40 41 59 2003 2062 61 2049 46 2063 40 41 59 2010 2011 61 2062 46 2064 40 41 59 324 2043 61 2062 46 2043 40 41 59 392 40 2043 41 2052 40 2051 44 2053 46 2065 44 648 41 59 392 40 2011 614 2010 46 2066 41 123 392 40 2043 41 2051 46 2067 40 648 41 59 450 59 125 392 40 2060 614 424 41 450 59 2013 60 2014 62 2015 61 2068 40 2050 44 648 44 648 44 2051 41 59 464 40 2060 46 2069 40 41 41 123 328 2070 58 2071 40 2011 44 2056 44 2051 44 473 44 2043 44 2015 41 59 325 59 328 2072 58 392 40 2043 41 2051 46 2073 40 648 41 59 2006 40 2060 44 2051 44 2011 44 380 44 2015 41 59 325 59 125 125 439 492 2074 40 2010 2011 44 2075 60 2007 62 2076 44 2007 2009 44 324 2077 44 324 2043 44 2013 60 2014 62 2015 41 123 385 40 2007 2040 58 2076 41 123 2078 40 2011 44 2040 44 2009 44 2077 44 2043 44 2015 41 59 125 125 439 492 2079 40 2010 2011 44 2007 2040 44 2007 2080 44 324 2077 44 324 2043 44 2013 60 2014 62 2015 41 123 392 40 2040 46 2081 40 41 631 2082 46 2083 41 123 2080 46 2084 40 2005 41 59 450 59 125 2085 2086 61 40 2085 41 2040 46 2087 40 41 59 392 40 2043 41 123 392 40 40 2086 46 2088 46 2089 38 2090 46 2091 41 614 1500 606 40 2086 46 2088 46 2089 38 2090 46 2092 41 614 1500 41 123 2080 46 2093 40 648 41 59 450 59 125 392 40 40 2086 46 2088 46 2089 38 2090 46 2094 41 631 1500 41 123 2080 46 2095 40 648 41 59 450 59 125 392 40 2086 46 2096 614 424 41 123 2080 46 2097 40 648 41 59 450 59 125 125 2004 2098 61 2099 40 2040 41 59 392 40 2098 614 424 41 123 2080 46 2100 40 648 41 59 450 59 125 385 40 2004 2101 58 2102 40 2040 41 41 123 464 40 2103 40 2101 44 2040 44 380 44 1500 41 41 123 328 2104 58 450 59 328 2105 58 392 40 2077 41 123 2004 2106 61 648 59 392 40 33 2101 46 2107 40 2098 41 41 2106 61 2004 46 2108 40 648 44 2101 41 59 2080 46 2109 40 2004 46 2108 40 648 44 2098 44 2106 41 41 59 125 450 59 349 58 328 2110 58 621 125 125 413 2111 61 2112 40 2011 41 124 40 2086 46 2113 46 2114 38 2115 46 2116 41 59 2117 40 2040 46 2118 40 41 44 2119 40 2111 44 2040 44 2040 46 2120 40 41 44 2080 44 2043 44 2015 41 41 59 125 439 2121 2122 40 413 2123 44 2007 2025 44 2124 2125 44 2007 2080 44 324 2043 44 2013 60 2014 62 2015 41 123 2126 2040 61 40 2126 41 2025 46 2127 40 41 59 621 2128 2129 61 2130 40 2125 44 2131 40 2125 44 2040 41 44 2080 41 59 621 2132 2133 61 2025 46 2134 40 2135 40 2025 41 41 59 2013 60 2136 62 2137 59 2138 2139 61 424 59 404 91 93 2140 61 424 59 324 2141 61 380 59 392 40 2043 605 33 2142 40 2025 41 41 123 2139 61 2040 46 2143 59 392 40 2139 402 2144 41 123 2013 60 2128 62 2145 61 40 40 2144 41 2139 41 46 2145 59 2140 61 418 404 91 2145 46 2146 40 41 93 59 385 40 404 2147 61 1500 59 2147 60 2140 46 2146 59 2147 637 41 123 2140 91 2147 93 61 2145 46 2127 40 2147 41 46 2042 59 125 125 2137 61 2148 40 2125 44 2025 44 2080 41 59 2141 61 2149 46 2150 40 2025 46 2151 40 41 41 46 2152 40 41 46 2153 40 41 59 125 360 123 2137 61 2154 40 2125 44 2025 41 59 125 2155 2156 61 2125 46 2157 40 1500 44 2137 41 59 2013 60 2158 62 2159 61 2013 46 2160 40 41 59 2013 60 2126 62 2161 61 2013 46 2160 40 41 59 2013 60 2128 62 2162 61 2013 46 2160 40 41 59 2128 2163 61 424 59 2013 60 2014 62 2164 61 2165 40 2025 41 59 2013 60 2014 62 2166 61 2167 40 2025 41 59 2013 60 2014 62 2168 61 2169 40 2015 41 46 2170 40 2164 41 59 392 40 2025 46 2171 40 41 41 123 392 40 2172 40 2025 41 46 2173 40 41 41 2168 61 2168 46 2174 40 2125 46 2175 40 2176 40 2025 44 2177 46 2178 41 44 2013 46 60 2128 62 2160 40 41 41 41 59 125 360 123 392 40 2179 40 2025 41 46 2180 40 41 41 2168 61 2168 46 2181 40 2125 46 2182 40 2183 40 2025 44 2184 46 2185 41 44 2013 46 60 2128 62 2160 40 41 41 41 59 125 392 40 2186 40 2025 41 41 2168 61 2168 46 2187 40 2125 46 2188 40 2189 40 2025 44 648 41 44 2013 46 60 2128 62 2160 40 41 41 41 59 2121 2190 61 2191 40 2125 46 2192 40 2125 46 2193 40 2123 44 2168 41 44 2133 44 2129 44 2159 44 2161 44 2162 44 2156 44 2163 41 44 2080 41 59 392 40 2139 631 424 41 2191 40 2139 44 424 41 59 392 40 2140 631 424 41 123 385 40 404 2194 61 1500 59 2194 60 2140 46 2195 59 2194 637 41 123 40 40 2196 41 2139 41 46 2197 46 2127 40 2194 41 46 2042 61 2140 91 2194 93 59 125 125 2190 46 2198 46 2199 61 2190 46 2198 46 2199 46 2170 40 2166 41 59 392 40 2141 41 123 2200 60 2128 62 2201 61 418 2200 60 2128 62 40 41 59 392 40 33 2202 46 2203 46 2204 40 2025 46 2205 40 41 46 2206 40 2207 46 2208 41 41 41 123 2201 46 2209 40 2125 46 2210 40 648 41 41 59 125 2201 46 2211 40 2125 46 2212 40 648 41 41 59 2213 40 2190 46 2198 44 2025 44 2080 44 648 44 2125 46 2214 40 424 44 2013 46 60 2128 62 2160 40 41 44 2201 46 2215 40 41 41 41 59 125 2216 40 2025 44 2190 44 2217 46 2218 41 59 450 2190 59 125 439 457 2013 60 2014 62 2219 40 2007 2025 41 123 2220 2040 61 40 2220 41 2025 46 2221 40 41 59 2013 60 2014 62 2222 61 2013 46 2223 40 41 59 385 40 2014 2049 58 2040 46 2224 46 2225 41 123 392 40 2226 40 2227 46 334 44 2025 44 2049 46 2228 41 41 123 2222 61 2222 46 2229 40 2049 41 59 125 125 392 40 33 2222 46 2230 40 41 41 123 2231 60 2014 62 2232 61 418 2231 60 2014 62 40 41 59 385 40 2014 2049 58 2040 46 2224 46 2225 41 123 392 40 33 2222 46 2233 40 2049 41 41 123 2232 46 2234 40 2049 41 59 125 125 2040 46 2224 46 2225 61 2232 46 2235 40 41 59 2025 46 2236 40 41 59 125 450 2222 59 125 439 2013 60 2237 62 2238 40 2124 2125 44 2007 2025 41 123 450 2013 46 60 2237 62 2239 40 2125 46 2240 40 2241 40 2125 44 2025 44 2242 46 2243 41 41 41 59 125 437 457 381 2004 2244 61 648 59 437 457 381 2013 60 2245 62 2246 61 2013 46 2247 40 41 59 439 457 381 2248 46 2249 46 2250 60 2251 44 2004 62 2252 59 457 123 2250 60 2251 44 2004 62 2253 61 418 2254 60 2251 44 2004 62 40 41 59 2253 46 2255 40 2256 44 648 41 59 2253 46 2255 40 2257 44 648 41 59 2253 46 2255 40 2258 44 648 41 59 2253 46 2255 40 2259 44 648 41 59 2253 46 2255 40 2260 44 648 41 59 2253 46 2255 40 2261 44 648 41 59 2253 46 2255 40 2262 44 648 41 59 2253 46 2255 40 2263 44 648 41 59 2252 61 2264 46 2265 40 2253 41 59 125 439 2013 60 2237 62 2266 40 2124 2267 44 2007 2040 44 2007 2080 41 123 604 2268 60 2237 62 2269 61 418 2268 60 2237 62 40 41 59 2270 2025 61 40 2270 41 2040 46 2271 40 41 59 2245 2272 61 2273 40 2267 44 2025 41 59 2245 2274 61 424 59 2025 46 2275 61 424 59 324 2276 61 380 59 392 40 2025 46 2277 402 2278 41 123 2004 2279 61 2252 46 2271 40 2280 40 2025 46 2277 41 41 59 392 40 2279 631 424 41 123 2276 61 473 59 2025 46 2277 61 2281 40 2040 44 2279 41 59 2274 61 2281 40 2040 44 2279 41 59 125 125 392 40 2274 614 424 41 2274 61 2273 40 2267 44 2025 41 59 2282 2283 61 2040 46 2284 40 648 41 59 2282 2285 61 2040 46 2284 40 648 41 59 604 123 2245 2286 61 2287 40 2040 44 648 41 59 2269 46 2288 40 2267 46 2289 40 2267 46 2290 40 1500 41 44 2283 44 2286 44 2291 40 2040 44 2292 40 2267 44 2040 44 2293 46 2294 41 41 41 41 59 125 604 123 2295 2296 59 604 123 2268 60 2237 62 2297 61 418 2268 60 2237 62 40 41 59 604 123 2298 2299 61 2267 46 2300 40 2267 46 2301 40 2267 46 2302 40 2283 41 44 2303 40 2040 44 2304 40 2267 44 2040 44 2305 46 2306 41 41 41 41 59 2297 46 2307 40 2299 41 59 125 604 123 2268 60 2237 62 2308 61 418 2268 60 2237 62 40 41 59 604 123 2308 46 2309 40 2267 46 2310 40 2267 46 2311 40 2312 46 2313 41 44 2285 44 2272 44 2025 46 2314 41 41 59 125 604 123 392 40 2276 41 123 2237 2315 61 2267 46 2316 40 2267 46 2317 40 2267 46 2318 40 2283 41 44 2267 46 2318 40 2285 41 41 41 59 2308 46 2319 40 2315 41 59 125 125 604 123 392 40 33 2276 41 123 2245 2320 61 2267 46 2321 40 2322 44 2267 46 2323 40 2285 41 44 2267 46 2324 40 2325 44 424 41 41 59 2245 2326 61 2327 40 2267 44 2040 44 2328 46 2329 41 59 2245 2330 61 2267 46 2331 40 2320 44 2326 44 2267 46 2323 40 2285 41 41 59 2237 2332 61 2267 46 2333 40 2267 46 2334 40 2267 46 2323 40 2283 41 44 2330 41 41 59 2308 46 2335 40 2332 41 59 125 125 604 123 2237 2336 61 2337 40 2040 44 2338 40 2267 44 2040 44 2339 46 2340 41 44 2267 46 2341 40 2283 41 41 59 2308 46 2342 40 2336 41 59 125 2343 2344 61 2267 46 2345 40 2346 44 2267 46 2347 40 2283 41 44 2267 46 2348 40 2349 44 424 41 41 59 2350 2351 61 2267 46 2352 40 2344 44 2267 46 2353 40 1500 44 2308 46 2354 40 41 41 44 424 41 59 2297 46 2355 40 2351 41 59 125 2296 61 2267 46 2356 40 2357 40 2267 44 2040 44 2358 46 2359 41 44 2267 46 2360 40 1500 44 2297 46 2361 40 41 41 41 59 125 2362 2363 61 2267 46 2364 40 2365 44 2267 46 2366 40 2283 41 44 2267 46 2367 40 2368 44 424 41 41 59 2369 2370 61 2267 46 2371 40 2363 44 2267 46 2372 40 1500 44 2013 46 60 2237 62 2373 40 2296 41 41 44 424 41 59 2269 46 2374 40 2370 41 59 125 604 123 392 40 2276 41 123 2269 46 2375 40 2267 46 2376 40 2267 46 2377 40 2274 44 2267 46 2378 40 2283 41 41 41 41 59 125 125 604 123 392 40 33 2276 41 123 2245 2379 61 2267 46 2380 40 2381 44 2267 46 2382 40 2283 41 44 2383 40 2267 44 2040 44 2384 46 2385 41 41 59 2245 2386 61 2267 46 2387 40 2379 44 2267 46 2388 40 2389 44 424 41 44 2267 46 2382 40 2283 41 41 59 2245 2390 61 2267 46 2391 40 2274 44 2267 46 2392 40 2386 41 41 59 2269 46 2393 40 2267 46 2394 40 2390 41 41 59 125 125 621 604 123 2025 46 2277 61 2395 40 2267 46 2396 40 2397 40 2040 44 2244 41 44 2013 46 60 2245 62 2398 40 2399 40 2040 44 648 41 41 41 44 2080 41 59 2025 46 2400 61 2395 40 2267 46 2401 40 424 44 2246 44 2273 40 2267 44 2025 41 44 2246 44 424 41 44 2080 41 59 125 450 2269 46 2402 40 41 59 125 439 2403 2404 40 2007 2080 44 2245 2405 41 123 2124 2267 61 2080 46 2406 40 41 59 450 2267 46 2407 40 2246 44 2267 46 2408 40 2405 44 2080 46 2409 40 648 41 41 44 2246 41 59 125 439 2237 2410 40 2007 2080 44 2245 2405 44 2245 2411 41 123 2124 2267 61 2080 46 2412 40 41 59 450 2267 46 2413 40 2267 46 2414 40 2246 44 2267 46 2415 40 2405 44 2080 46 2416 40 648 41 41 44 2013 46 60 2245 62 2417 40 2411 41 41 41 59 125 439 2245 2418 40 2124 2125 44 2419 2040 41 123 450 2040 46 2420 631 424 63 2125 46 2421 40 2040 46 2420 41 58 2040 46 2422 59 125 125 
5508,Java,"@Slf4j
@Singleton
public final class ArbitrationManager extends DisputeManager<ArbitrationDisputeList> {

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public ArbitrationManager(P2PService p2PService,
                              TradeWalletService tradeWalletService,
                              BtcWalletService walletService,
                              WalletsSetup walletsSetup,
                              TradeManager tradeManager,
                              ClosedTradableManager closedTradableManager,
                              OpenOfferManager openOfferManager,
                              DaoFacade daoFacade,
                              KeyRing keyRing,
                              ArbitrationDisputeListService arbitrationDisputeListService,
                              Config config,
                              PriceFeedService priceFeedService) {
        super(p2PService, tradeWalletService, walletService, walletsSetup, tradeManager, closedTradableManager,
                openOfferManager, daoFacade, keyRing, arbitrationDisputeListService, config, priceFeedService);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Implement template methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public SupportType getSupportType() {
        return SupportType.ARBITRATION;
    }

    @Override
    public void onSupportMessage(SupportMessage message) {
        if (canProcessMessage(message)) {
            log.info(""Received {} with tradeId {} and uid {}"",
                    message.getClass().getSimpleName(), message.getTradeId(), message.getUid());

            if (message instanceof OpenNewDisputeMessage) {
                onOpenNewDisputeMessage((OpenNewDisputeMessage) message);
            } else if (message instanceof PeerOpenedDisputeMessage) {
                onPeerOpenedDisputeMessage((PeerOpenedDisputeMessage) message);
            } else if (message instanceof ChatMessage) {
                onChatMessage((ChatMessage) message);
            } else if (message instanceof DisputeResultMessage) {
                onDisputeResultMessage((DisputeResultMessage) message);
            } else if (message instanceof PeerPublishedDisputePayoutTxMessage) {
                onDisputedPayoutTxMessage((PeerPublishedDisputePayoutTxMessage) message);
            } else {
                log.warn(""Unsupported message at dispatchMessage. message={}"", message);
            }
        }
    }

    @Nullable
    @Override
    public NodeAddress getAgentNodeAddress(Dispute dispute) {
        return null;
    }

    @Override
    protected Trade.DisputeState getDisputeStateStartedByPeer() {
        return Trade.DisputeState.DISPUTE_STARTED_BY_PEER;
    }

    @Override
    protected AckMessageSourceType getAckMessageSourceType() {
        return AckMessageSourceType.ARBITRATION_MESSAGE;
    }

    @Override
    public void cleanupDisputes() {
        disputeListService.cleanupDisputes(tradeId -> tradeManager.closeDisputedTrade(tradeId, Trade.DisputeState.DISPUTE_CLOSED));
    }

    @Override
    protected String getDisputeInfo(Dispute dispute) {
        String role = Res.get(""shared.arbitrator"").toLowerCase();
        String link = ""https://bisq.wiki/Arbitrator#Arbitrator_versus_Legacy_Arbitrator"";
        return Res.get(""support.initialInfo"", role, """", role, link);        // Arbitration is not used anymore
    }

    @Override
    protected String getDisputeIntroForPeer(String disputeInfo) {
        return Res.get(""support.peerOpenedDispute"", disputeInfo, Version.VERSION);
    }

    @Override
    protected String getDisputeIntroForDisputeCreator(String disputeInfo) {
        return Res.get(""support.youOpenedDispute"", disputeInfo, Version.VERSION);
    }

    @Override
    protected void addPriceInfoMessage(Dispute dispute, int counter) {
        // Arbitrator is not used anymore.
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Message handler
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    // We get that message at both peers. The dispute object is in context of the trader
    public void onDisputeResultMessage(DisputeResultMessage disputeResultMessage) {
        DisputeResult disputeResult = disputeResultMessage.getDisputeResult();
        ChatMessage chatMessage = disputeResult.getChatMessage();
        checkNotNull(chatMessage, ""chatMessage must not be null"");
        if (Arrays.equals(disputeResult.getArbitratorPubKey(),
                btcWalletService.getArbitratorAddressEntry().getPubKey())) {
            log.error(""Arbitrator received disputeResultMessage. That must never happen."");
            return;
        }

        String tradeId = disputeResult.getTradeId();
        Optional<Dispute> disputeOptional = findDispute(disputeResult);
        String uid = disputeResultMessage.getUid();
        if (!disputeOptional.isPresent()) {
            log.warn(""We got a dispute result msg but we don't have a matching dispute. "" +
                    ""That might happen when we get the disputeResultMessage before the dispute was created. "" +
                    ""We try again after 2 sec. to apply the disputeResultMessage. TradeId = "" + tradeId);
            if (!delayMsgMap.containsKey(uid)) {
                // We delay 2 sec. to be sure the comm. msg gets added first
                Timer timer = UserThread.runAfter(() -> onDisputeResultMessage(disputeResultMessage), 2);
                delayMsgMap.put(uid, timer);
            } else {
                log.warn(""We got a dispute result msg after we already repeated to apply the message after a delay. "" +
                        ""That should never happen. TradeId = "" + tradeId);
            }
            return;
        }

        Dispute dispute = disputeOptional.get();
        cleanupRetryMap(uid);
        if (!dispute.getChatMessages().contains(chatMessage)) {
            dispute.addAndPersistChatMessage(chatMessage);
        } else {
            log.warn(""We got a dispute mail msg what we have already stored. TradeId = "" + chatMessage.getTradeId());
        }
        dispute.setIsClosed();

        if (dispute.disputeResultProperty().get() != null) {
            log.warn(""We already got a dispute result. That should only happen if a dispute needs to be closed "" +
                    ""again because the first close did not succeed. TradeId = "" + tradeId);
        }

        dispute.setDisputeResult(disputeResult);
        Optional<Trade> tradeOptional = tradeManager.getTradeById(tradeId);
        String errorMessage = null;
        boolean success = false;
        try {
            // We need to avoid publishing the tx from both traders as it would create problems with zero confirmation withdrawals
            // There would be different transactions if both sign and publish (signers: once buyer+arb, once seller+arb)
            // The tx publisher is the winner or in case both get 50% the buyer, as the buyer has more inventive to publish the tx as he receives
            // more BTC as he has deposited
            Contract contract = dispute.getContract();

            boolean isBuyer = pubKeyRing.equals(contract.getBuyerPubKeyRing());
            DisputeResult.Winner publisher = disputeResult.getWinner();

            // Sometimes the user who receives the trade amount is never online, so we might want to
            // let the loser publish the tx. When the winner comes online he gets his funds as it was published by the other peer.
            // Default isLoserPublisher is set to false
            if (disputeResult.isLoserPublisher()) {
                // we invert the logic
                if (publisher == DisputeResult.Winner.BUYER)
                    publisher = DisputeResult.Winner.SELLER;
                else if (publisher == DisputeResult.Winner.SELLER)
                    publisher = DisputeResult.Winner.BUYER;
            }

            if ((isBuyer && publisher == DisputeResult.Winner.BUYER)
                    || (!isBuyer && publisher == DisputeResult.Winner.SELLER)) {

                Transaction payoutTx = null;
                if (tradeOptional.isPresent()) {
                    payoutTx = tradeOptional.get().getPayoutTx();
                } else {
                    Optional<Tradable> tradableOptional = closedTradableManager.getTradableById(tradeId);
                    if (tradableOptional.isPresent() && tradableOptional.get() instanceof Trade) {
                        payoutTx = ((Trade) tradableOptional.get()).getPayoutTx();
                    }
                }

                if (payoutTx == null) {
                    if (dispute.getDepositTxSerialized() != null) {
                        byte[] multiSigPubKey = isBuyer ? contract.getBuyerMultiSigPubKey() : contract.getSellerMultiSigPubKey();
                        DeterministicKey multiSigKeyPair = btcWalletService.getMultiSigKeyPair(tradeId, multiSigPubKey);
                        Transaction signedDisputedPayoutTx = tradeWalletService.traderSignAndFinalizeDisputedPayoutTx(
                                dispute.getDepositTxSerialized(),
                                disputeResult.getArbitratorSignature(),
                                disputeResult.getBuyerPayoutAmount(),
                                disputeResult.getSellerPayoutAmount(),
                                contract.getBuyerPayoutAddressString(),
                                contract.getSellerPayoutAddressString(),
                                multiSigKeyPair,
                                contract.getBuyerMultiSigPubKey(),
                                contract.getSellerMultiSigPubKey(),
                                disputeResult.getArbitratorPubKey()
                        );
                        Transaction committedDisputedPayoutTx = WalletService.maybeAddSelfTxToWallet(signedDisputedPayoutTx, btcWalletService.getWallet());
                        tradeWalletService.broadcastTx(committedDisputedPayoutTx, new TxBroadcaster.Callback() {
                            @Override
                            public void onSuccess(Transaction transaction) {
                                // after successful publish we send peer the tx
                                dispute.setDisputePayoutTxId(transaction.getTxId().toString());
                                sendPeerPublishedPayoutTxMessage(transaction, dispute, contract);
                                updateTradeOrOpenOfferManager(tradeId);
                            }

                            @Override
                            public void onFailure(TxBroadcastException exception) {
                                log.error(exception.getMessage());
                            }
                        }, 15);

                        success = true;
                    } else {
                        errorMessage = ""DepositTx is null. TradeId = "" + tradeId;
                        log.warn(errorMessage);
                        success = false;
                    }
                } else {
                    log.warn(""We already got a payout tx. That might be the case if the other peer did not get the "" +
                            ""payout tx and opened a dispute. TradeId = "" + tradeId);
                    dispute.setDisputePayoutTxId(payoutTx.getTxId().toString());
                    sendPeerPublishedPayoutTxMessage(payoutTx, dispute, contract);

                    success = true;
                }
            } else {
                log.trace(""We don't publish the tx as we are not the winning party."");
                // Clean up tangling trades
                if (dispute.disputeResultProperty().get() != null && dispute.isClosed()) {
                    updateTradeOrOpenOfferManager(tradeId);
                }

                success = true;
            }
        } catch (TransactionVerificationException e) {
            errorMessage = ""Error at traderSignAndFinalizeDisputedPayoutTx "" + e.toString();
            log.error(errorMessage, e);
            success = false;

            // We prefer to close the dispute in that case. If there was no deposit tx and a random tx was used
            // we get a TransactionVerificationException. No reason to keep that dispute open...
            updateTradeOrOpenOfferManager(tradeId);

            throw new RuntimeException(errorMessage);
        } catch (AddressFormatException | WalletException | SignatureDecodeException e) {
            errorMessage = ""Error at traderSignAndFinalizeDisputedPayoutTx "" + e.toString();
            log.error(errorMessage, e);
            success = false;
            throw new RuntimeException(errorMessage);
        } finally {
            // We use the chatMessage as we only persist those not the disputeResultMessage.
            // If we would use the disputeResultMessage we could not lookup for the msg when we receive the AckMessage.
            sendAckMessage(chatMessage, dispute.getAgentPubKeyRing(), success, errorMessage);
        }

        requestPersistence();
    }

    // Losing trader or in case of 50/50 the seller gets the tx sent from the winner or buyer
    private void onDisputedPayoutTxMessage(PeerPublishedDisputePayoutTxMessage peerPublishedDisputePayoutTxMessage) {
        String uid = peerPublishedDisputePayoutTxMessage.getUid();
        String tradeId = peerPublishedDisputePayoutTxMessage.getTradeId();
        Optional<Dispute> disputeOptional = findOwnDispute(tradeId);
        if (!disputeOptional.isPresent()) {
            log.debug(""We got a peerPublishedPayoutTxMessage but we don't have a matching dispute. TradeId = "" + tradeId);
            if (!delayMsgMap.containsKey(uid)) {
                // We delay 3 sec. to be sure the close msg gets added first
                Timer timer = UserThread.runAfter(() -> onDisputedPayoutTxMessage(peerPublishedDisputePayoutTxMessage), 3);
                delayMsgMap.put(uid, timer);
            } else {
                log.warn(""We got a peerPublishedPayoutTxMessage after we already repeated to apply the message after a delay. "" +
                        ""That should never happen. TradeId = "" + tradeId);
            }
            return;
        }

        Dispute dispute = disputeOptional.get();
        Contract contract = dispute.getContract();
        boolean isBuyer = pubKeyRing.equals(contract.getBuyerPubKeyRing());
        PubKeyRing peersPubKeyRing = isBuyer ? contract.getSellerPubKeyRing() : contract.getBuyerPubKeyRing();

        cleanupRetryMap(uid);

        Transaction committedDisputePayoutTx = WalletService.maybeAddNetworkTxToWallet(peerPublishedDisputePayoutTxMessage.getTransaction(), btcWalletService.getWallet());

        dispute.setDisputePayoutTxId(committedDisputePayoutTx.getTxId().toString());
        BtcWalletService.printTx(""Disputed payoutTx received from peer"", committedDisputePayoutTx);

        // We can only send the ack msg if we have the peersPubKeyRing which requires the dispute
        sendAckMessage(peerPublishedDisputePayoutTxMessage, peersPubKeyRing, true, null);
        requestPersistence();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Send messages
    ///////////////////////////////////////////////////////////////////////////////////////////

    // winner (or buyer in case of 50/50) sends tx to other peer
    private void sendPeerPublishedPayoutTxMessage(Transaction transaction, Dispute dispute, Contract contract) {
        PubKeyRing peersPubKeyRing = dispute.isDisputeOpenerIsBuyer() ? contract.getSellerPubKeyRing() : contract.getBuyerPubKeyRing();
        NodeAddress peersNodeAddress = dispute.isDisputeOpenerIsBuyer() ? contract.getSellerNodeAddress() : contract.getBuyerNodeAddress();
        log.trace(""sendPeerPublishedPayoutTxMessage to peerAddress {}"", peersNodeAddress);
        PeerPublishedDisputePayoutTxMessage message = new PeerPublishedDisputePayoutTxMessage(transaction.bitcoinSerialize(),
                dispute.getTradeId(),
                p2PService.getAddress(),
                UUID.randomUUID().toString(),
                getSupportType());
        log.info(""Send {} to peer {}. tradeId={}, uid={}"",
                message.getClass().getSimpleName(), peersNodeAddress, message.getTradeId(), message.getUid());
        mailboxMessageService.sendEncryptedMailboxMessage(peersNodeAddress,
                peersPubKeyRing,
                message,
                new SendMailboxMessageListener() {
                    @Override
                    public void onArrived() {
                        log.info(""{} arrived at peer {}. tradeId={}, uid={}"",
                                message.getClass().getSimpleName(), peersNodeAddress, message.getTradeId(), message.getUid());
                    }

                    @Override
                    public void onStoredInMailbox() {
                        log.info(""{} stored in mailbox for peer {}. tradeId={}, uid={}"",
                                message.getClass().getSimpleName(), peersNodeAddress, message.getTradeId(), message.getUid());
                    }

                    @Override
                    public void onFault(String errorMessage) {
                        log.error(""{} failed: Peer {}. tradeId={}, uid={}, errorMessage={}"",
                                message.getClass().getSimpleName(), peersNodeAddress, message.getTradeId(), message.getUid(), errorMessage);
                    }
                }
        );
    }

    private void updateTradeOrOpenOfferManager(String tradeId) {
        // set state after payout as we call swapTradeEntryToAvailableEntry
        if (tradeManager.getTradeById(tradeId).isPresent()) {
            tradeManager.closeDisputedTrade(tradeId, Trade.DisputeState.DISPUTE_CLOSED);
        } else {
            Optional<OpenOffer> openOfferOptional = openOfferManager.getOpenOfferById(tradeId);
            openOfferOptional.ifPresent(openOffer -> openOfferManager.closeOpenOffer(openOffer.getOffer()));
        }
    }
}",1,64 2000 64 2001 439 381 334 2002 378 2003 60 2004 62 123 621 621 621 64 2005 439 2002 40 2006 2007 44 2008 2009 44 2010 2011 44 2012 2013 44 2014 2015 44 2016 2017 44 2018 2019 44 2020 2021 44 2022 2023 44 2024 2025 44 2026 2027 44 2028 2029 41 123 463 40 2007 44 2009 44 2011 44 2013 44 2015 44 2017 44 2019 44 2021 44 2023 44 2025 44 2027 44 2029 41 59 125 621 621 621 64 2030 439 2031 2032 40 41 123 450 2031 46 2033 59 125 64 2030 439 492 2034 40 2035 2036 41 123 392 40 2037 40 2036 41 41 123 2038 46 2039 40 648 44 2036 46 2040 40 41 46 2041 40 41 44 2036 46 2042 40 41 44 2036 46 2043 40 41 41 59 392 40 2036 402 2044 41 123 2045 40 40 2044 41 2036 41 59 125 360 392 40 2036 402 2046 41 123 2047 40 40 2046 41 2036 41 59 125 360 392 40 2036 402 2048 41 123 2049 40 40 2048 41 2036 41 59 125 360 392 40 2036 402 2050 41 123 2051 40 40 2050 41 2036 41 59 125 360 392 40 2036 402 2052 41 123 2053 40 40 2052 41 2036 41 59 125 360 123 2038 46 2054 40 648 44 2036 41 59 125 125 125 64 2055 64 2030 439 2056 2057 40 2058 2059 41 123 450 424 59 125 64 2030 438 2060 46 2061 2062 40 41 123 450 2060 46 2061 46 2063 59 125 64 2030 438 2064 2065 40 41 123 450 2064 46 2066 59 125 64 2030 439 492 2067 40 41 123 2068 46 2067 40 2069 45 62 2015 46 2070 40 2069 44 2060 46 2061 46 2071 41 41 59 125 64 2030 438 2072 2073 40 2058 2059 41 123 2072 2074 61 2075 46 2076 40 648 41 46 2077 40 41 59 2072 2078 61 648 59 450 2075 46 2076 40 648 44 2074 44 648 44 2074 44 2078 41 59 621 125 64 2030 438 2072 2079 40 2072 2080 41 123 450 2081 46 2082 40 648 44 2080 44 2083 46 2084 41 59 125 64 2030 438 2072 2085 40 2072 2080 41 123 450 2086 46 2087 40 648 44 2080 44 2088 46 2089 41 59 125 64 2030 438 492 2090 40 2058 2059 44 404 2091 41 123 621 125 621 621 621 64 2030 621 439 492 2092 40 2093 2094 41 123 2095 2096 61 2094 46 2097 40 41 59 2098 2099 61 2096 46 2100 40 41 59 2101 40 2099 44 648 41 59 392 40 2102 46 2103 40 2096 46 2104 40 41 44 2105 46 2106 40 41 46 2107 40 41 41 41 123 2108 46 371 40 648 41 59 450 59 125 2072 2109 61 2096 46 2110 40 41 59 2111 60 2058 62 2112 61 2113 40 2096 41 59 2072 2114 61 2094 46 2115 40 41 59 392 40 33 2112 46 2116 40 41 41 123 2117 46 2118 40 648 43 648 43 648 43 2109 41 59 392 40 33 2119 46 2120 40 2114 41 41 123 621 2121 2122 61 2123 46 2124 40 40 41 45 62 2092 40 2094 41 44 1502 41 59 2119 46 2125 40 2114 44 2122 41 59 125 360 123 2117 46 2118 40 648 43 648 43 2109 41 59 125 450 59 125 2058 2059 61 2112 46 2126 40 41 59 2127 40 2114 41 59 392 40 33 2059 46 2128 40 41 46 2129 40 2099 41 41 123 2059 46 2130 40 2099 41 59 125 360 123 2131 46 2132 40 648 43 2099 46 2110 40 41 41 59 125 2059 46 2133 40 41 59 392 40 2059 46 2134 40 41 46 2126 40 41 631 424 41 123 2135 46 2136 40 648 43 648 43 2109 41 59 125 2059 46 2137 40 2096 41 59 2111 60 2060 62 2138 61 2015 46 2139 40 2109 41 59 2072 2140 61 424 59 324 2141 61 380 59 474 123 621 621 621 621 2142 2143 61 2059 46 2144 40 41 59 324 2145 61 2146 46 2103 40 2143 46 2147 40 41 41 59 2095 46 2148 2149 61 2096 46 2150 40 41 59 621 621 621 392 40 2096 46 2151 40 41 41 123 621 392 40 2149 614 2095 46 2148 46 2152 41 2149 61 2095 46 2148 46 2153 59 360 392 40 2149 614 2095 46 2148 46 2153 41 2149 61 2095 46 2148 46 2152 59 125 392 40 40 2145 605 2149 614 2095 46 2148 46 2154 41 606 40 33 2145 605 2149 614 2095 46 2148 46 2155 41 41 123 2156 2157 61 424 59 392 40 2138 46 2116 40 41 41 123 2157 61 2138 46 2126 40 41 46 2158 40 41 59 125 360 123 2111 60 2159 62 2160 61 2017 46 2161 40 2109 41 59 392 40 2160 46 2116 40 41 605 2160 46 2126 40 41 402 2060 41 123 2157 61 40 40 2060 41 2160 46 2126 40 41 41 46 2162 40 41 59 125 125 392 40 2157 614 424 41 123 392 40 2059 46 2163 40 41 631 424 41 123 326 91 93 2164 61 2145 63 2143 46 2165 40 41 58 2143 46 2166 40 41 59 2167 2168 61 2105 46 2169 40 2109 44 2164 41 59 2156 2170 61 2009 46 2171 40 2059 46 2163 40 41 44 2096 46 2172 40 41 44 2096 46 2173 40 41 44 2096 46 2174 40 41 44 2143 46 2175 40 41 44 2143 46 2176 40 41 44 2168 44 2143 46 2165 40 41 44 2143 46 2166 40 41 44 2096 46 2104 40 41 41 59 2156 2177 61 2178 46 2179 40 2170 44 2105 46 2180 40 41 41 59 2009 46 2181 40 2177 44 418 2182 46 2183 40 41 123 64 2030 439 492 2184 40 2156 2185 41 123 621 2059 46 2186 40 2185 46 2187 40 41 46 2188 40 41 41 59 2189 40 2185 44 2059 44 2143 41 59 2190 40 2109 41 59 125 64 2030 439 492 2191 40 2192 2193 41 123 2194 46 371 40 2193 46 2195 40 41 41 59 125 125 44 1503 41 59 2141 61 473 59 125 360 123 2140 61 648 43 2109 59 2196 46 2197 40 2140 41 59 2141 61 380 59 125 125 360 123 2198 46 2199 40 648 43 648 43 2109 41 59 2059 46 2200 40 2157 46 2201 40 41 46 2202 40 41 41 59 2203 40 2157 44 2059 44 2143 41 59 2141 61 473 59 125 125 360 123 2204 46 2205 40 648 41 59 621 392 40 2059 46 2134 40 41 46 2126 40 41 631 424 605 2059 46 2206 40 41 41 123 2207 40 2109 41 59 125 2141 61 473 59 125 125 329 40 2208 2209 41 123 2140 61 648 43 2209 46 2210 40 41 59 2211 46 371 40 2140 44 2209 41 59 2141 61 380 59 621 621 2212 40 2109 41 59 469 418 2213 40 2140 41 59 125 329 40 2214 124 2215 124 2216 2209 41 123 2140 61 648 43 2209 46 2217 40 41 59 2218 46 371 40 2140 44 2209 41 59 2141 61 380 59 469 418 2219 40 2140 41 59 125 382 123 621 621 2220 40 2099 44 2059 46 2221 40 41 44 2141 44 2140 41 59 125 2222 40 41 59 125 621 437 492 2223 40 2224 2225 41 123 2072 2226 61 2225 46 2227 40 41 59 2072 2228 61 2225 46 2229 40 41 59 2230 60 2058 62 2231 61 2232 40 2228 41 59 392 40 33 2231 46 2233 40 41 41 123 2234 46 2235 40 648 43 2228 41 59 392 40 33 2236 46 2237 40 2226 41 41 123 621 2238 2239 61 2240 46 2241 40 40 41 45 62 2223 40 2225 41 44 1502 41 59 2236 46 2242 40 2226 44 2239 41 59 125 360 123 2234 46 2243 40 648 43 648 43 2228 41 59 125 450 59 125 2058 2059 61 2231 46 2244 40 41 59 2245 2246 61 2059 46 2247 40 41 59 324 2248 61 2249 46 2250 40 2246 46 2251 40 41 41 59 2252 2253 61 2248 63 2246 46 2254 40 41 58 2246 46 2251 40 41 59 2255 40 2226 41 59 2256 2257 61 2258 46 2259 40 2225 46 2260 40 41 44 2261 46 2262 40 41 41 59 2059 46 2263 40 2257 46 2264 40 41 46 2265 40 41 41 59 2010 46 2266 40 648 44 2257 41 59 621 2267 40 2225 44 2253 44 473 44 424 41 59 2268 40 41 59 125 621 621 621 621 437 492 2269 40 2270 2271 44 2058 2059 44 2272 2273 41 123 2274 2275 61 2059 46 2276 40 41 63 2273 46 2277 40 41 58 2273 46 2278 40 41 59 2056 2279 61 2059 46 2276 40 41 63 2273 46 2280 40 41 58 2273 46 2281 40 41 59 2282 46 2283 40 648 44 2279 41 59 2224 2036 61 418 2224 40 2271 46 2284 40 41 44 2059 46 2285 40 41 44 2007 46 2286 40 41 44 2287 46 2288 40 41 46 2289 40 41 44 2032 40 41 41 59 2282 46 2290 40 648 44 2036 46 2291 40 41 46 2292 40 41 44 2279 44 2036 46 2285 40 41 44 2036 46 2293 40 41 41 59 2294 46 2295 40 2279 44 2275 44 2036 44 418 2296 40 41 123 64 2030 439 492 2297 40 41 123 2282 46 2290 40 648 44 2036 46 2291 40 41 46 2292 40 41 44 2279 44 2036 46 2285 40 41 44 2036 46 2293 40 41 41 59 125 64 2030 439 492 2298 40 41 123 2282 46 2290 40 648 44 2036 46 2291 40 41 46 2292 40 41 44 2279 44 2036 46 2285 40 41 44 2036 46 2293 40 41 41 59 125 64 2030 439 492 2299 40 2072 2300 41 123 2282 46 371 40 648 44 2036 46 2291 40 41 46 2292 40 41 44 2279 44 2036 46 2285 40 41 44 2036 46 2293 40 41 44 2300 41 59 125 125 41 59 125 437 492 2301 40 2072 2302 41 123 621 392 40 2015 46 2303 40 2302 41 46 2304 40 41 41 123 2015 46 2305 40 2302 44 2060 46 2061 46 2306 41 59 125 360 123 2307 60 2308 62 2309 61 2019 46 2310 40 2302 41 59 2309 46 2311 40 2312 45 62 2019 46 2313 40 2312 46 2314 40 41 41 41 59 125 125 125 
17307,Java,"public class PlayerActivity extends AppCompatActivity
    implements OnClickListener, StyledPlayerControlView.VisibilityListener {

  // Saved instance state keys.

  private static final String KEY_TRACK_SELECTION_PARAMETERS = ""track_selection_parameters"";
  private static final String KEY_ITEM_INDEX = ""item_index"";
  private static final String KEY_POSITION = ""position"";
  private static final String KEY_AUTO_PLAY = ""auto_play"";

  protected StyledPlayerView playerView;
  protected LinearLayout debugRootView;
  protected TextView debugTextView;
  protected @Nullable ExoPlayer player;

  private boolean isShowingTrackSelectionDialog;
  private Button selectTracksButton;
  private DataSource.Factory dataSourceFactory;
  private List<MediaItem> mediaItems;
  private DefaultTrackSelector trackSelector;
  private DefaultTrackSelector.Parameters trackSelectionParameters;
  private DebugTextViewHelper debugViewHelper;
  private TracksInfo lastSeenTracksInfo;
  private boolean startAutoPlay;
  private int startItemIndex;
  private long startPosition;

  // For ad playback only.

  private AdsLoader adsLoader;

  // Activity lifecycle.

  @Override
  public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    dataSourceFactory = DemoUtil.getDataSourceFactory(/* context= */ this);

    setContentView();
    debugRootView = findViewById(R.id.controls_root);
    debugTextView = findViewById(R.id.debug_text_view);
    selectTracksButton = findViewById(R.id.select_tracks_button);
    selectTracksButton.setOnClickListener(this);

    playerView = findViewById(R.id.player_view);
    playerView.setControllerVisibilityListener(this);
    playerView.setErrorMessageProvider(new PlayerErrorMessageProvider());
    playerView.requestFocus();

    if (savedInstanceState != null) {
      // Restore as DefaultTrackSelector.Parameters in case ExoPlayer specific parameters were set.
      trackSelectionParameters =
          DefaultTrackSelector.Parameters.CREATOR.fromBundle(
              savedInstanceState.getBundle(KEY_TRACK_SELECTION_PARAMETERS));
      startAutoPlay = savedInstanceState.getBoolean(KEY_AUTO_PLAY);
      startItemIndex = savedInstanceState.getInt(KEY_ITEM_INDEX);
      startPosition = savedInstanceState.getLong(KEY_POSITION);
    } else {
      trackSelectionParameters =
          new DefaultTrackSelector.ParametersBuilder(/* context= */ this).build();
      clearStartPosition();
    }
  }

  @Override
  public void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    releasePlayer();
    releaseAdsLoader();
    clearStartPosition();
    setIntent(intent);
  }

  @Override
  public void onStart() {
    super.onStart();
    if (Util.SDK_INT > 23) {
      initializePlayer();
      if (playerView != null) {
        playerView.onResume();
      }
    }
  }

  @Override
  public void onResume() {
    super.onResume();
    if (Util.SDK_INT <= 23 || player == null) {
      initializePlayer();
      if (playerView != null) {
        playerView.onResume();
      }
    }
  }

  @Override
  public void onPause() {
    super.onPause();
    if (Util.SDK_INT <= 23) {
      if (playerView != null) {
        playerView.onPause();
      }
      releasePlayer();
    }
  }

  @Override
  public void onStop() {
    super.onStop();
    if (Util.SDK_INT > 23) {
      if (playerView != null) {
        playerView.onPause();
      }
      releasePlayer();
    }
  }

  @Override
  public void onDestroy() {
    super.onDestroy();
    releaseAdsLoader();
  }

  @Override
  public void onRequestPermissionsResult(
      int requestCode, String[] permissions, int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    if (grantResults.length == 0) {
      // Empty results are triggered if a permission is requested while another request was already
      // pending and can be safely ignored in this case.
      return;
    }
    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
      initializePlayer();
    } else {
      showToast(R.string.storage_permission_denied);
      finish();
    }
  }

  @Override
  public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    updateTrackSelectorParameters();
    updateStartPosition();
    outState.putBundle(KEY_TRACK_SELECTION_PARAMETERS, trackSelectionParameters.toBundle());
    outState.putBoolean(KEY_AUTO_PLAY, startAutoPlay);
    outState.putInt(KEY_ITEM_INDEX, startItemIndex);
    outState.putLong(KEY_POSITION, startPosition);
  }

  // Activity input

  @Override
  public boolean dispatchKeyEvent(KeyEvent event) {
    // See whether the player view wants to handle media or DPAD keys events.
    return playerView.dispatchKeyEvent(event) || super.dispatchKeyEvent(event);
  }

  // OnClickListener methods

  @Override
  public void onClick(View view) {
    if (view == selectTracksButton
        && !isShowingTrackSelectionDialog
        && TrackSelectionDialog.willHaveContent(trackSelector)) {
      isShowingTrackSelectionDialog = true;
      TrackSelectionDialog trackSelectionDialog =
          TrackSelectionDialog.createForTrackSelector(
              trackSelector,
              /* onDismissListener= */ dismissedDialog -> isShowingTrackSelectionDialog = false);
      trackSelectionDialog.show(getSupportFragmentManager(), /* tag= */ null);
    }
  }

  // PlayerControlView.VisibilityListener implementation

  @Override
  public void onVisibilityChange(int visibility) {
    debugRootView.setVisibility(visibility);
  }

  // Internal methods

  protected void setContentView() {
    setContentView(R.layout.player_activity);
  }

  /** @return Whether initialization was successful. */
  protected boolean initializePlayer() {
    if (player == null) {
      Intent intent = getIntent();

      mediaItems = createMediaItems(intent);
      if (mediaItems.isEmpty()) {
        return false;
      }

      boolean preferExtensionDecoders =
          intent.getBooleanExtra(IntentUtil.PREFER_EXTENSION_DECODERS_EXTRA, false);
      RenderersFactory renderersFactory =
          DemoUtil.buildRenderersFactory(/* context= */ this, preferExtensionDecoders);
      MediaSourceFactory mediaSourceFactory =
          new DefaultMediaSourceFactory(dataSourceFactory)
              .setAdsLoaderProvider(this::getAdsLoader)
              .setAdViewProvider(playerView);

      trackSelector = new DefaultTrackSelector(/* context= */ this);
      lastSeenTracksInfo = TracksInfo.EMPTY;
      player =
          new ExoPlayer.Builder(/* context= */ this)
              .setRenderersFactory(renderersFactory)
              .setMediaSourceFactory(mediaSourceFactory)
              .setTrackSelector(trackSelector)
              .build();
      player.setTrackSelectionParameters(trackSelectionParameters);
      player.addListener(new PlayerEventListener());
      player.addAnalyticsListener(new EventLogger(trackSelector));
      player.setAudioAttributes(AudioAttributes.DEFAULT, /* handleAudioFocus= */ true);
      player.setPlayWhenReady(startAutoPlay);
      playerView.setPlayer(player);
      debugViewHelper = new DebugTextViewHelper(player, debugTextView);
      debugViewHelper.start();
    }
    boolean haveStartPosition = startItemIndex != C.INDEX_UNSET;
    if (haveStartPosition) {
      player.seekTo(startItemIndex, startPosition);
    }
    player.setMediaItems(mediaItems, /* resetPosition= */ !haveStartPosition);
    player.prepare();
    updateButtonVisibility();
    return true;
  }

  private List<MediaItem> createMediaItems(Intent intent) {
    String action = intent.getAction();
    boolean actionIsListView = IntentUtil.ACTION_VIEW_LIST.equals(action);
    if (!actionIsListView && !IntentUtil.ACTION_VIEW.equals(action)) {
      showToast(getString(R.string.unexpected_intent_action, action));
      finish();
      return Collections.emptyList();
    }

    List<MediaItem> mediaItems =
        createMediaItems(intent, DemoUtil.getDownloadTracker(/* context= */ this));
    boolean hasAds = false;
    for (int i = 0; i < mediaItems.size(); i++) {
      MediaItem mediaItem = mediaItems.get(i);

      if (!Util.checkCleartextTrafficPermitted(mediaItem)) {
        showToast(R.string.error_cleartext_not_permitted);
        finish();
        return Collections.emptyList();
      }
      if (Util.maybeRequestReadExternalStoragePermission(/* activity= */ this, mediaItem)) {
        // The player will be reinitialized if the permission is granted.
        return Collections.emptyList();
      }

      MediaItem.DrmConfiguration drmConfiguration =
          checkNotNull(mediaItem.localConfiguration).drmConfiguration;
      if (drmConfiguration != null) {
        if (Util.SDK_INT < 18) {
          showToast(R.string.error_drm_unsupported_before_api_18);
          finish();
          return Collections.emptyList();
        } else if (!FrameworkMediaDrm.isCryptoSchemeSupported(drmConfiguration.scheme)) {
          showToast(R.string.error_drm_unsupported_scheme);
          finish();
          return Collections.emptyList();
        }
      }
      hasAds |= mediaItem.localConfiguration.adsConfiguration != null;
    }
    if (!hasAds) {
      releaseAdsLoader();
    }
    return mediaItems;
  }

  private AdsLoader getAdsLoader(MediaItem.AdsConfiguration adsConfiguration) {
    // The ads loader is reused for multiple playbacks, so that ad playback can resume.
    if (adsLoader == null) {
      adsLoader = new ImaAdsLoader.Builder(/* context= */ this).build();
    }
    adsLoader.setPlayer(player);
    return adsLoader;
  }

  protected void releasePlayer() {
    if (player != null) {
      updateTrackSelectorParameters();
      updateStartPosition();
      debugViewHelper.stop();
      debugViewHelper = null;
      player.release();
      player = null;
      mediaItems = Collections.emptyList();
    }
    if (adsLoader != null) {
      adsLoader.setPlayer(null);
    }
  }

  private void releaseAdsLoader() {
    if (adsLoader != null) {
      adsLoader.release();
      adsLoader = null;
      playerView.getOverlayFrameLayout().removeAllViews();
    }
  }

  private void updateTrackSelectorParameters() {
    if (player != null) {
      // Until the demo app is fully migrated to TrackSelectionParameters, rely on ExoPlayer to use
      // DefaultTrackSelector by default.
      trackSelectionParameters =
          (DefaultTrackSelector.Parameters) player.getTrackSelectionParameters();
    }
  }

  private void updateStartPosition() {
    if (player != null) {
      startAutoPlay = player.getPlayWhenReady();
      startItemIndex = player.getCurrentMediaItemIndex();
      startPosition = Math.max(0, player.getContentPosition());
    }
  }

  protected void clearStartPosition() {
    startAutoPlay = true;
    startItemIndex = C.INDEX_UNSET;
    startPosition = C.TIME_UNSET;
  }

  // User controls

  private void updateButtonVisibility() {
    selectTracksButton.setEnabled(
        player != null && TrackSelectionDialog.willHaveContent(trackSelector));
  }

  private void showControls() {
    debugRootView.setVisibility(View.VISIBLE);
  }

  private void showToast(int messageId) {
    showToast(getString(messageId));
  }

  private void showToast(String message) {
    Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
  }

  private class PlayerEventListener implements Player.Listener {

    @Override
    public void onPlaybackStateChanged(@Player.State int playbackState) {
      if (playbackState == Player.STATE_ENDED) {
        showControls();
      }
      updateButtonVisibility();
    }

    @Override
    public void onPlayerError(PlaybackException error) {
      if (error.errorCode == PlaybackException.ERROR_CODE_BEHIND_LIVE_WINDOW) {
        player.seekToDefaultPosition();
        player.prepare();
      } else {
        updateButtonVisibility();
        showControls();
      }
    }

    @Override
    @SuppressWarnings(""ReferenceEquality"")
    public void onTracksInfoChanged(TracksInfo tracksInfo) {
      updateButtonVisibility();
      if (tracksInfo == lastSeenTracksInfo) {
        return;
      }
      if (!tracksInfo.isTypeSupportedOrEmpty(C.TRACK_TYPE_VIDEO)) {
        showToast(R.string.error_unsupported_video);
      }
      if (!tracksInfo.isTypeSupportedOrEmpty(C.TRACK_TYPE_AUDIO)) {
        showToast(R.string.error_unsupported_audio);
      }
      lastSeenTracksInfo = tracksInfo;
    }
  }

  private class PlayerErrorMessageProvider implements ErrorMessageProvider<PlaybackException> {

    @Override
    public Pair<Integer, String> getErrorMessage(PlaybackException e) {
      String errorString = getString(R.string.error_generic);
      Throwable cause = e.getCause();
      if (cause instanceof DecoderInitializationException) {
        // Special case for decoder initialization failures.
        DecoderInitializationException decoderInitializationException =
            (DecoderInitializationException) cause;
        if (decoderInitializationException.codecInfo == null) {
          if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
            errorString = getString(R.string.error_querying_decoders);
          } else if (decoderInitializationException.secureDecoderRequired) {
            errorString =
                getString(
                    R.string.error_no_secure_decoder, decoderInitializationException.mimeType);
          } else {
            errorString =
                getString(R.string.error_no_decoder, decoderInitializationException.mimeType);
          }
        } else {
          errorString =
              getString(
                  R.string.error_instantiating_decoder,
                  decoderInitializationException.codecInfo.name);
        }
      }
      return Pair.create(0, errorString);
    }
  }

  private static List<MediaItem> createMediaItems(Intent intent, DownloadTracker downloadTracker) {
    List<MediaItem> mediaItems = new ArrayList<>();
    for (MediaItem item : IntentUtil.createMediaItemsFromIntent(intent)) {
      @Nullable
      DownloadRequest downloadRequest =
          downloadTracker.getDownloadRequest(checkNotNull(item.localConfiguration).uri);
      if (downloadRequest != null) {
        MediaItem.Builder builder = item.buildUpon();
        builder
            .setMediaId(downloadRequest.id)
            .setUri(downloadRequest.uri)
            .setCustomCacheKey(downloadRequest.customCacheKey)
            .setMimeType(downloadRequest.mimeType)
            .setStreamKeys(downloadRequest.streamKeys);
        @Nullable
        MediaItem.DrmConfiguration drmConfiguration = item.localConfiguration.drmConfiguration;
        if (drmConfiguration != null) {
          builder.setDrmConfiguration(
              drmConfiguration.buildUpon().setKeySetId(downloadRequest.keySetId).build());
        }

        mediaItems.add(builder.build());
      } else {
        mediaItems.add(item);
      }
    }
    return mediaItems;
  }
}",1,439 334 2000 378 2001 395 2002 44 2003 46 2004 123 621 437 457 381 2005 2006 61 648 59 437 457 381 2005 2007 61 648 59 437 457 381 2005 2008 61 648 59 437 457 381 2005 2009 61 648 59 438 2010 2011 59 438 2012 2013 59 438 2014 2015 59 438 64 2016 2017 2018 59 437 324 2019 59 437 2020 2021 59 437 2022 46 2023 2024 59 437 2025 60 2026 62 2027 59 437 2028 2029 59 437 2028 46 2030 2031 59 437 2032 2033 59 437 2034 2035 59 437 324 2036 59 437 404 2037 59 437 413 2038 59 621 437 2039 2040 59 621 64 2041 439 492 2042 40 64 2016 2043 2044 41 123 463 46 2042 40 2044 41 59 2024 61 2045 46 2046 40 604 467 41 59 2047 40 41 59 2013 61 2048 40 2049 46 2050 46 2051 41 59 2015 61 2048 40 2049 46 2050 46 2052 41 59 2021 61 2048 40 2049 46 2050 46 2053 41 59 2021 46 2054 40 467 41 59 2011 61 2048 40 2049 46 2050 46 2055 41 59 2011 46 2056 40 467 41 59 2011 46 2057 40 418 2058 40 41 41 59 2011 46 2059 40 41 59 392 40 2044 631 424 41 123 621 2031 61 2028 46 2030 46 2060 46 2061 40 2044 46 2062 40 2006 41 41 59 2036 61 2044 46 2063 40 2009 41 59 2037 61 2044 46 2064 40 2007 41 59 2038 61 2044 46 2065 40 2008 41 59 125 360 123 2031 61 418 2028 46 2066 40 604 467 41 46 2067 40 41 59 2068 40 41 59 125 125 64 2041 439 492 2069 40 2070 2071 41 123 463 46 2069 40 2071 41 59 2072 40 41 59 2073 40 41 59 2074 40 41 59 2075 40 2071 41 59 125 64 2041 439 492 2076 40 41 123 463 46 2076 40 41 59 392 40 2077 46 2078 62 1503 41 123 2079 40 41 59 392 40 2011 631 424 41 123 2011 46 2080 40 41 59 125 125 125 64 2041 439 492 2081 40 41 123 463 46 2081 40 41 59 392 40 2082 46 2083 620 1503 606 2018 614 424 41 123 2084 40 41 59 392 40 2011 631 424 41 123 2011 46 2081 40 41 59 125 125 125 64 2041 439 492 2085 40 41 123 463 46 2085 40 41 59 392 40 2086 46 2087 620 1503 41 123 392 40 2011 631 424 41 123 2011 46 2085 40 41 59 125 2088 40 41 59 125 125 64 2041 439 492 2089 40 41 123 463 46 2089 40 41 59 392 40 2090 46 2091 62 1503 41 123 392 40 2011 631 424 41 123 2011 46 2085 40 41 59 125 2092 40 41 59 125 125 64 2041 439 492 2093 40 41 123 463 46 2093 40 41 59 2094 40 41 59 125 64 2041 439 492 2095 40 404 2096 44 2005 91 93 2097 44 404 91 93 2098 41 123 463 46 2095 40 2096 44 2097 44 2098 41 59 392 40 2098 46 2099 614 1500 41 123 621 621 450 59 125 392 40 2098 91 1500 93 614 2100 46 2101 41 123 2102 40 41 59 125 360 123 2103 40 2104 46 461 46 2105 41 59 2106 40 41 59 125 125 64 2041 439 492 2107 40 2043 2108 41 123 463 46 2107 40 2108 41 59 2109 40 41 59 2110 40 41 59 2108 46 2111 40 2006 44 2031 46 2112 40 41 41 59 2108 46 2113 40 2009 44 2036 41 59 2108 46 2114 40 2007 44 2037 41 59 2108 46 2115 40 2008 44 2038 41 59 125 621 64 2041 439 324 2116 40 2117 373 41 123 621 450 2011 46 2116 40 373 41 606 463 46 2116 40 373 41 59 125 621 64 2041 439 492 2118 40 2119 2120 41 123 392 40 2120 614 2021 605 33 2019 605 2121 46 2122 40 2029 41 41 123 2019 61 473 59 2121 2123 61 2121 46 2124 40 2029 44 604 2125 45 62 2019 61 380 41 59 2123 46 2126 40 2127 40 41 44 604 424 41 59 125 125 621 64 2041 439 492 2128 40 404 2129 41 123 2013 46 2130 40 2129 41 59 125 621 438 492 2131 40 41 123 2131 40 2132 46 2133 46 2134 41 59 125 618 438 324 2135 40 41 123 392 40 2018 614 424 41 123 2070 2071 61 2136 40 41 59 2027 61 2137 40 2071 41 59 392 40 2027 46 2138 40 41 41 123 450 380 59 125 324 2139 61 2071 46 2140 40 2141 46 2142 44 380 41 59 2143 2144 61 2145 46 2146 40 604 467 44 2139 41 59 2147 2148 61 418 2149 40 2024 41 46 2150 40 467 58 58 2151 41 46 2152 40 2011 41 59 2029 61 418 2028 40 604 467 41 59 2035 61 2034 46 2153 59 2018 61 418 2017 46 2154 40 604 467 41 46 2155 40 2144 41 46 2156 40 2148 41 46 2157 40 2029 41 46 2158 40 41 59 2018 46 2159 40 2031 41 59 2018 46 2160 40 418 2161 40 41 41 59 2018 46 2162 40 418 2163 40 2029 41 41 59 2018 46 2164 40 2165 46 2166 44 604 473 41 59 2018 46 2167 40 2036 41 59 2011 46 2168 40 2018 41 59 2033 61 418 2032 40 2018 44 2015 41 59 2033 46 2169 40 41 59 125 324 2170 61 2037 631 2171 46 2172 59 392 40 2170 41 123 2018 46 2173 40 2037 44 2038 41 59 125 2018 46 2174 40 2027 44 604 33 2170 41 59 2018 46 2175 40 41 59 2176 40 41 59 450 473 59 125 437 2025 60 2026 62 2177 40 2070 2071 41 123 2005 2178 61 2071 46 2179 40 41 59 324 2180 61 2181 46 2182 46 2183 40 2178 41 59 392 40 33 2180 605 33 2181 46 2184 46 2183 40 2178 41 41 123 2185 40 2186 40 2187 46 461 46 2188 44 2178 41 41 59 2189 40 41 59 450 2190 46 2191 40 41 59 125 2025 60 2026 62 2027 61 2177 40 2071 44 2192 46 2193 40 604 467 41 41 59 324 2194 61 380 59 385 40 404 2195 61 1500 59 2195 60 2027 46 2196 40 41 59 2195 637 41 123 2026 2197 61 2027 46 2198 40 2195 41 59 392 40 33 2199 46 2200 40 2197 41 41 123 2201 40 2202 46 461 46 2203 41 59 2204 40 41 59 450 2205 46 2206 40 41 59 125 392 40 2199 46 2207 40 604 467 44 2197 41 41 123 621 450 2208 46 2209 40 41 59 125 2026 46 2210 2211 61 2212 40 2197 46 2213 41 46 2211 59 392 40 2211 631 424 41 123 392 40 2199 46 2214 60 1503 41 123 2215 40 2216 46 461 46 2217 41 59 2218 40 41 59 450 2219 46 2220 40 41 59 125 360 392 40 33 2221 46 2222 40 2211 46 2223 41 41 123 2224 40 2225 46 461 46 2226 41 59 2227 40 41 59 450 2228 46 2229 40 41 59 125 125 2194 635 2197 46 2213 46 2230 631 424 59 125 392 40 33 2194 41 123 2231 40 41 59 125 450 2027 59 125 437 2039 2232 40 2026 46 2233 2234 41 123 621 392 40 2040 614 424 41 123 2040 61 418 2235 46 2236 40 604 467 41 46 2237 40 41 59 125 2040 46 2238 40 2018 41 59 450 2040 59 125 438 492 2239 40 41 123 392 40 2018 631 424 41 123 2240 40 41 59 2241 40 41 59 2033 46 2242 40 41 59 2033 61 424 59 2018 46 2243 40 41 59 2018 61 424 59 2027 61 2244 46 2245 40 41 59 125 392 40 2040 631 424 41 123 2040 46 2246 40 424 41 59 125 125 437 492 2247 40 41 123 392 40 2040 631 424 41 123 2040 46 2248 40 41 59 2040 61 424 59 2011 46 2249 40 41 46 2250 40 41 59 125 125 437 492 2251 40 41 123 392 40 2018 631 424 41 123 621 621 2031 61 40 2028 46 2030 41 2018 46 2252 40 41 59 125 125 437 492 2253 40 41 123 392 40 2018 631 424 41 123 2036 61 2018 46 2254 40 41 59 2037 61 2018 46 2255 40 41 59 2038 61 2256 46 2257 40 1500 44 2018 46 2258 40 41 41 59 125 125 438 492 2259 40 41 123 2036 61 473 59 2037 61 2260 46 2261 59 2038 61 2260 46 2262 59 125 621 437 492 2263 40 41 123 2021 46 2264 40 2018 631 424 605 2265 46 2266 40 2029 41 41 59 125 437 492 2267 40 41 123 2013 46 2268 40 2119 46 2269 41 59 125 437 492 2270 40 404 2271 41 123 2270 40 2272 40 2271 41 41 59 125 437 492 2270 40 2005 2273 41 123 2274 46 2275 40 2276 40 41 44 2273 44 2274 46 2277 41 46 2278 40 41 59 125 437 334 2279 395 2280 46 2281 123 64 2041 439 492 2282 40 64 2280 46 2283 404 2284 41 123 392 40 2284 614 2280 46 2285 41 123 2267 40 41 59 125 2263 40 41 59 125 64 2041 439 492 2286 40 2287 371 41 123 392 40 371 46 2288 614 2287 46 2289 41 123 2018 46 2290 40 41 59 2018 46 2291 40 41 59 125 360 123 2263 40 41 59 2267 40 41 59 125 125 64 2041 64 2292 40 648 41 439 492 2293 40 2034 2294 41 123 2263 40 41 59 392 40 2294 614 2035 41 123 450 59 125 392 40 33 2294 46 2295 40 2296 46 2297 41 41 123 2270 40 2298 46 461 46 2299 41 59 125 392 40 33 2294 46 2295 40 2296 46 2300 41 41 123 2270 40 2301 46 461 46 2302 41 59 125 2035 61 2294 59 125 125 437 334 2303 395 2304 60 2305 62 123 64 2041 439 2306 60 2307 44 2005 62 2308 40 2305 2309 41 123 2005 2310 61 2311 40 2312 46 461 46 2313 41 59 2314 2315 61 2309 46 2316 40 41 59 392 40 2315 402 2317 41 123 621 2317 2318 61 40 2317 41 2315 59 392 40 2318 46 2319 614 424 41 123 392 40 2318 46 2316 40 41 402 2320 41 123 2310 61 2311 40 2312 46 461 46 2321 41 59 125 360 392 40 2318 46 2322 41 123 2310 61 2311 40 2312 46 461 46 2323 44 2318 46 2324 41 59 125 360 123 2310 61 2311 40 2312 46 461 46 2325 44 2318 46 2326 41 59 125 125 360 123 2310 61 2311 40 2312 46 461 46 2327 44 2318 46 2319 46 2328 41 59 125 125 450 2306 46 2329 40 1500 44 2310 41 59 125 125 437 457 2025 60 2026 62 2177 40 2070 2071 44 2330 2331 41 123 2025 60 2026 62 2027 61 418 2332 60 62 40 41 59 385 40 2026 2333 58 2334 46 2335 40 2071 41 41 123 64 2016 2336 2337 61 2331 46 2338 40 2339 40 2333 46 2340 41 46 2341 41 59 392 40 2337 631 424 41 123 2026 46 2342 2343 61 2333 46 2344 40 41 59 2343 46 2345 40 2337 46 2346 41 46 2347 40 2337 46 2341 41 46 2348 40 2337 46 2349 41 46 2350 40 2337 46 2351 41 46 2352 40 2337 46 2353 41 59 64 2016 2026 46 2354 2355 61 2333 46 2340 46 2355 59 392 40 2355 631 424 41 123 2343 46 2356 40 2355 46 2344 40 41 46 2357 40 2337 46 2358 41 46 2359 40 41 41 59 125 2027 46 2360 40 2343 46 2361 40 41 41 59 125 360 123 2027 46 2362 40 2333 41 59 125 125 450 2027 59 125 125 
29861,Java,"@Provides
public class HandleEqualsAndHashCode extends EclipseAnnotationHandler<EqualsAndHashCode> {
	
	private static final String HASH_CODE_CACHE_NAME = ""$hashCodeCache"";
	
	private final char[] HASH_CODE_CACHE_NAME_ARR = HASH_CODE_CACHE_NAME.toCharArray();
	private final char[] PRIME = ""PRIME"".toCharArray();
	private final char[] RESULT = ""result"".toCharArray();
	
	public static final Set<String> BUILT_IN_TYPES = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(
			""byte"", ""short"", ""int"", ""long"", ""char"", ""boolean"", ""double"", ""float"")));
	
	@Override public void handle(AnnotationValues<EqualsAndHashCode> annotation, Annotation ast, EclipseNode annotationNode) {
		handleFlagUsage(annotationNode, ConfigurationKeys.EQUALS_AND_HASH_CODE_FLAG_USAGE, ""@EqualsAndHashCode"");
		
		EqualsAndHashCode ann = annotation.getInstance();
		List<Included<EclipseNode, EqualsAndHashCode.Include>> members = InclusionExclusionUtils.handleEqualsAndHashCodeMarking(annotationNode.up(), annotation, annotationNode);
		if (members == null) return;
		
		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, ""onParam"", ""@EqualsAndHashCode(onParam"", annotationNode);
		
		Boolean callSuper = ann.callSuper();
		if (!annotation.isExplicit(""callSuper"")) callSuper = null;
		
		Boolean doNotUseGettersConfiguration = annotationNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_DO_NOT_USE_GETTERS);
		boolean doNotUseGetters = annotation.isExplicit(""doNotUseGetters"") || doNotUseGettersConfiguration == null ? ann.doNotUseGetters() : doNotUseGettersConfiguration;
		FieldAccess fieldAccess = doNotUseGetters ? FieldAccess.PREFER_FIELD : FieldAccess.GETTER;
		
		boolean cacheHashCode = ann.cacheStrategy() == CacheStrategy.LAZY;
		
		generateMethods(annotationNode.up(), annotationNode, members, callSuper, true, cacheHashCode, fieldAccess, onParam);
	}
	
	public void generateEqualsAndHashCodeForType(EclipseNode typeNode, EclipseNode errorNode) {
		if (hasAnnotation(EqualsAndHashCode.class, typeNode)) {
			//The annotation will make it happen, so we can skip it.
			return;
		}
		
		List<Included<EclipseNode, EqualsAndHashCode.Include>> members = InclusionExclusionUtils.handleEqualsAndHashCodeMarking(typeNode, null, null);
		
		Boolean doNotUseGettersConfiguration = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_DO_NOT_USE_GETTERS);
		FieldAccess access = doNotUseGettersConfiguration == null || !doNotUseGettersConfiguration ? FieldAccess.GETTER : FieldAccess.PREFER_FIELD;
		
		generateMethods(typeNode, errorNode, members, null, false, false, access, new ArrayList<Annotation>());
	}
	
	public void generateMethods(EclipseNode typeNode, EclipseNode errorNode, List<Included<EclipseNode, EqualsAndHashCode.Include>> members,
		Boolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<Annotation> onParam) {
		
		if (!isClass(typeNode)) {
			errorNode.addError(""@EqualsAndHashCode is only supported on a class."");
			return;
		}
		
		TypeDeclaration typeDecl = (TypeDeclaration) typeNode.get();
		boolean implicitCallSuper = callSuper == null;
		
		if (callSuper == null) {
			try {
				callSuper = ((Boolean) EqualsAndHashCode.class.getMethod(""callSuper"").getDefaultValue()).booleanValue();
			} catch (Exception ignore) {
				throw new InternalError(""Lombok bug - this cannot happen - can't find callSuper field in EqualsAndHashCode annotation."");
			}
		}
		
		boolean isDirectDescendantOfObject = isDirectDescendantOfObject(typeNode);
		
		boolean isFinal = (typeDecl.modifiers & ClassFileConstants.AccFinal) != 0;
		boolean needsCanEqual = !isFinal || !isDirectDescendantOfObject;
		MemberExistsResult equalsExists = methodExists(""equals"", typeNode, 1);
		MemberExistsResult hashCodeExists = methodExists(""hashCode"", typeNode, 0);
		MemberExistsResult canEqualExists = methodExists(""canEqual"", typeNode, 1);
		switch (Collections.max(Arrays.asList(equalsExists, hashCodeExists))) {
		case EXISTS_BY_LOMBOK:
			return;
		case EXISTS_BY_USER:
			if (whineIfExists) {
				String msg = ""Not generating equals and hashCode: A method with one of those names already exists. (Either both or none of these methods will be generated)."";
				errorNode.addWarning(msg);
			} else if (equalsExists == MemberExistsResult.NOT_EXISTS || hashCodeExists == MemberExistsResult.NOT_EXISTS) {
				// This means equals OR hashCode exists and not both.
				// Even though we should suppress the message about not generating these, this is such a weird and surprising situation we should ALWAYS generate a warning.
				// The user code couldn't possibly (barring really weird subclassing shenanigans) be in a shippable state anyway; the implementations of these 2 methods are
				// all inter-related and should be written by the same entity.
				String msg = String.format(""Not generating %s: One of equals or hashCode exists. "" +
						""You should either write both of these or none of these (in the latter case, lombok generates them)."",
						equalsExists == MemberExistsResult.NOT_EXISTS ? ""equals"" : ""hashCode"");
				errorNode.addWarning(msg);
			}
			return;
		case NOT_EXISTS:
		default:
			//fallthrough
		}
		
		if (isDirectDescendantOfObject && callSuper) {
			errorNode.addError(""Generating equals/hashCode with a supercall to java.lang.Object is pointless."");
			return;
		}
		
		if (implicitCallSuper && !isDirectDescendantOfObject) {
			CallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);
			if (cst == null) cst = CallSuperType.WARN;
			
			switch (cst) {
			default:
			case WARN:
				errorNode.addWarning(""Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this is intentional, add '@EqualsAndHashCode(callSuper=false)' to your type."");
				callSuper = false;
				break;
			case SKIP:
				callSuper = false;
				break;
			case CALL:
				callSuper = true;
				break;
			}
		}
		
		MethodDeclaration equalsMethod = createEquals(typeNode, members, callSuper, errorNode.get(), fieldAccess, needsCanEqual, onParam);
		equalsMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
		injectMethod(typeNode, equalsMethod);
		
		if (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {
			MethodDeclaration canEqualMethod = createCanEqual(typeNode, errorNode.get(), onParam);
			canEqualMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
			injectMethod(typeNode, canEqualMethod);
		}
		
		if (cacheHashCode){
			if (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {
				String msg = String.format(""Not caching the result of hashCode: A field named %s already exists."", HASH_CODE_CACHE_NAME);
				errorNode.addWarning(msg);
				cacheHashCode = false;
			} else {
				createHashCodeCacheField(typeNode, errorNode.get());
			}
		}
		
		MethodDeclaration hashCodeMethod = createHashCode(typeNode, members, callSuper, cacheHashCode, errorNode.get(), fieldAccess);
		hashCodeMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
		injectMethod(typeNode, hashCodeMethod);
	}

	private void createHashCodeCacheField(EclipseNode typeNode, ASTNode source) {
		FieldDeclaration hashCodeCacheDecl = new FieldDeclaration(HASH_CODE_CACHE_NAME_ARR, 0, 0);
		hashCodeCacheDecl.modifiers = ClassFileConstants.AccPrivate | ClassFileConstants.AccTransient;
		hashCodeCacheDecl.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;
		hashCodeCacheDecl.type = TypeReference.baseTypeReference(TypeIds.T_int, 0);
		hashCodeCacheDecl.declarationSourceEnd = -1;
		injectFieldAndMarkGenerated(typeNode, hashCodeCacheDecl);
		setGeneratedBy(hashCodeCacheDecl, source);
		setGeneratedBy(hashCodeCacheDecl.type, source);
	}
	
	private static final char[] HASH_CODE = ""hashCode"".toCharArray(), FLOAT_TO_INT_BITS = ""floatToIntBits"".toCharArray(), DOUBLE_TO_LONG_BITS = ""doubleToLongBits"".toCharArray();
	
	public MethodDeclaration createHashCode(EclipseNode type, Collection<Included<EclipseNode, EqualsAndHashCode.Include>> members, boolean callSuper, boolean cacheHashCode, ASTNode source, FieldAccess fieldAccess) {
		int pS = source.sourceStart, pE = source.sourceEnd;
		long p = (long) pS << 32 | pE;
		
		MethodDeclaration method = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);
		setGeneratedBy(method, source);
		
		method.modifiers = toEclipseModifier(AccessLevel.PUBLIC);
		method.returnType = TypeReference.baseTypeReference(TypeIds.T_int, 0);
		setGeneratedBy(method.returnType, source);
		Annotation overrideAnnotation = makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE, source);
		CheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(type);
		if (cacheHashCode && checkerFramework.generatePure()) {
			method.annotations = new Annotation[] { overrideAnnotation, generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__PURE) };
		} else if (checkerFramework.generateSideEffectFree()) {
			method.annotations = new Annotation[] { overrideAnnotation, generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE) };
		} else {
			method.annotations = new Annotation[] { overrideAnnotation };
		}
		method.selector = ""hashCode"".toCharArray();
		method.thrownExceptions = null;
		method.typeParameters = null;
		method.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;
		method.bodyStart = method.declarationSourceStart = method.sourceStart = source.sourceStart;
		method.bodyEnd = method.declarationSourceEnd = method.sourceEnd = source.sourceEnd;
		method.arguments = null;
		
		List<Statement> statements = new ArrayList<Statement>();
		
		boolean isEmpty = true;
		for (Included<EclipseNode, EqualsAndHashCode.Include> member : members) {
			TypeReference fType = getFieldType(member.getNode(), fieldAccess);
			if (fType.getLastToken() != null) {
				isEmpty = false;
				break;
			}
		}
		
		/* if (this.$hashCodeCache != 0) return this.$hashCodeCache; */ {
			if (cacheHashCode) {
				FieldReference hashCodeCacheRef = new FieldReference(HASH_CODE_CACHE_NAME_ARR, p);
				hashCodeCacheRef.receiver = new ThisReference(pS, pE);
				setGeneratedBy(hashCodeCacheRef, source);
				setGeneratedBy(hashCodeCacheRef.receiver, source);
				EqualExpression cacheNotZero = new EqualExpression(hashCodeCacheRef, makeIntLiteral(""0"".toCharArray(), source), OperatorIds.NOT_EQUAL);
				setGeneratedBy(cacheNotZero, source);
				ReturnStatement returnCache = new ReturnStatement(hashCodeCacheRef, pS, pE);
				setGeneratedBy(returnCache, source);
				IfStatement ifStatement = new IfStatement(cacheNotZero, returnCache, pS, pE);
				setGeneratedBy(ifStatement, source);
				statements.add(ifStatement);
			}
		}
		
		/* final int PRIME = X; */ {
			/* Without members, PRIME isn't used, as that would trigger a 'local variable not used' warning. */
			if (!isEmpty) {
				LocalDeclaration primeDecl = new LocalDeclaration(PRIME, pS, pE);
				setGeneratedBy(primeDecl, source);
				primeDecl.modifiers |= Modifier.FINAL;
				primeDecl.type = TypeReference.baseTypeReference(TypeIds.T_int, 0);
				primeDecl.type.sourceStart = pS; primeDecl.type.sourceEnd = pE;
				setGeneratedBy(primeDecl.type, source);
				primeDecl.initialization = makeIntLiteral(String.valueOf(HandlerUtil.primeForHashcode()).toCharArray(), source);
				statements.add(primeDecl);
			}
		}
		
		/* int result = ... */ {
		LocalDeclaration resultDecl = new LocalDeclaration(RESULT, pS, pE);
			setGeneratedBy(resultDecl, source);
			final Expression init;
			if (callSuper) {
				/* ... super.hashCode(); */
				MessageSend callToSuper = new MessageSend();
				setGeneratedBy(callToSuper, source);
				callToSuper.sourceStart = pS; callToSuper.sourceEnd = pE;
				callToSuper.receiver = new SuperReference(pS, pE);
				setGeneratedBy(callToSuper.receiver, source);
				callToSuper.selector = ""hashCode"".toCharArray();
				init = callToSuper;
			} else {
				/* ... 1; */
				init = makeIntLiteral(""1"".toCharArray(), source);
			}
			resultDecl.initialization = init;
			resultDecl.type = TypeReference.baseTypeReference(TypeIds.T_int, 0);
			resultDecl.type.sourceStart = pS; resultDecl.type.sourceEnd = pE;
			if (isEmpty && !cacheHashCode) resultDecl.modifiers |= Modifier.FINAL;
			setGeneratedBy(resultDecl.type, source);
			statements.add(resultDecl);
		}
		
		for (Included<EclipseNode, EqualsAndHashCode.Include> member : members) {
			EclipseNode memberNode = member.getNode();
			boolean isMethod = memberNode.getKind() == Kind.METHOD;
			
			TypeReference fType = getFieldType(memberNode, fieldAccess);
			char[] dollarFieldName = ((isMethod ? ""$$"" : ""$"") + memberNode.getName()).toCharArray();
			char[] token = fType.getLastToken();
			Expression fieldAccessor = isMethod ? createMethodAccessor(memberNode, source) : createFieldAccessor(memberNode, fieldAccess, source);
			if (fType.dimensions() == 0 && token != null) {
				if (Arrays.equals(TypeConstants.BOOLEAN, token)) {
					/* booleanField ? X : Y */
					IntLiteral intTrue = makeIntLiteral(String.valueOf(HandlerUtil.primeForTrue()).toCharArray(), source);
					IntLiteral intFalse = makeIntLiteral(String.valueOf(HandlerUtil.primeForFalse()).toCharArray(), source);
					ConditionalExpression intForBool = new ConditionalExpression(fieldAccessor, intTrue, intFalse);
					setGeneratedBy(intForBool, source);
					statements.add(createResultCalculation(source, intForBool));
				} else if (Arrays.equals(TypeConstants.LONG, token)) {
					/* (int)(ref >>> 32 ^ ref) */
					statements.add(createLocalDeclaration(source, dollarFieldName, TypeReference.baseTypeReference(TypeIds.T_long, 0), fieldAccessor));
					SingleNameReference copy1 = new SingleNameReference(dollarFieldName, p);
					setGeneratedBy(copy1, source);
					SingleNameReference copy2 = new SingleNameReference(dollarFieldName, p);
					setGeneratedBy(copy2, source);
					statements.add(createResultCalculation(source, longToIntForHashCode(copy1, copy2, source)));
				} else if (Arrays.equals(TypeConstants.FLOAT, token)) {
					/* Float.floatToIntBits(fieldName) */
					MessageSend floatToIntBits = new MessageSend();
					floatToIntBits.sourceStart = pS; floatToIntBits.sourceEnd = pE;
					setGeneratedBy(floatToIntBits, source);
					floatToIntBits.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA_LANG_FLOAT);
					floatToIntBits.selector = FLOAT_TO_INT_BITS;
					floatToIntBits.arguments = new Expression[] { fieldAccessor };
					statements.add(createResultCalculation(source, floatToIntBits));
				} else if (Arrays.equals(TypeConstants.DOUBLE, token)) {
					/* longToIntForHashCode(Double.doubleToLongBits(fieldName)) */
					MessageSend doubleToLongBits = new MessageSend();
					doubleToLongBits.sourceStart = pS; doubleToLongBits.sourceEnd = pE;
					setGeneratedBy(doubleToLongBits, source);
					doubleToLongBits.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA_LANG_DOUBLE);
					doubleToLongBits.selector = DOUBLE_TO_LONG_BITS;
					doubleToLongBits.arguments = new Expression[] { fieldAccessor };
					statements.add(createLocalDeclaration(source, dollarFieldName, TypeReference.baseTypeReference(TypeIds.T_long, 0), doubleToLongBits));
					SingleNameReference copy1 = new SingleNameReference(dollarFieldName, p);
					setGeneratedBy(copy1, source);
					SingleNameReference copy2 = new SingleNameReference(dollarFieldName, p);
					setGeneratedBy(copy2, source);
					statements.add(createResultCalculation(source, longToIntForHashCode(copy1, copy2, source)));
				} else if (BUILT_IN_TYPES.contains(new String(token))) {
					statements.add(createResultCalculation(source, fieldAccessor));
				} else /* objects */ {
					/* final java.lang.Object $fieldName = this.fieldName; */
					/* $fieldName == null ? NULL_PRIME : $fieldName.hashCode() */
					statements.add(createLocalDeclaration(source, dollarFieldName, generateQualifiedTypeRef(source, TypeConstants.JAVA_LANG_OBJECT), fieldAccessor));
					
					SingleNameReference copy1 = new SingleNameReference(dollarFieldName, p);
					setGeneratedBy(copy1, source);
					SingleNameReference copy2 = new SingleNameReference(dollarFieldName, p);
					setGeneratedBy(copy2, source);
					
					MessageSend hashCodeCall = new MessageSend();
					hashCodeCall.sourceStart = pS; hashCodeCall.sourceEnd = pE;
					setGeneratedBy(hashCodeCall, source);
					hashCodeCall.receiver = copy1;
					hashCodeCall.selector = HASH_CODE;
					NullLiteral nullLiteral = new NullLiteral(pS, pE);
					setGeneratedBy(nullLiteral, source);
					EqualExpression objIsNull = new EqualExpression(copy2, nullLiteral, OperatorIds.EQUAL_EQUAL);
					setGeneratedBy(objIsNull, source);
					IntLiteral intMagic = makeIntLiteral(String.valueOf(HandlerUtil.primeForNull()).toCharArray(), source);
					ConditionalExpression nullOrHashCode = new ConditionalExpression(objIsNull, intMagic, hashCodeCall);
					nullOrHashCode.sourceStart = pS; nullOrHashCode.sourceEnd = pE;
					setGeneratedBy(nullOrHashCode, source);
					statements.add(createResultCalculation(source, nullOrHashCode));
				}
			} else if (fType.dimensions() > 0 && token != null) {
				/* Arrays.deepHashCode(array)  //just hashCode for simple arrays */
				MessageSend arraysHashCodeCall = new MessageSend();
				arraysHashCodeCall.sourceStart = pS; arraysHashCodeCall.sourceEnd = pE;
				setGeneratedBy(arraysHashCodeCall, source);
				arraysHashCodeCall.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA, TypeConstants.UTIL, ""Arrays"".toCharArray());
				if (fType.dimensions() > 1 || !BUILT_IN_TYPES.contains(new String(token))) {
					arraysHashCodeCall.selector = ""deepHashCode"".toCharArray();
				} else {
					arraysHashCodeCall.selector = ""hashCode"".toCharArray();
				}
				arraysHashCodeCall.arguments = new Expression[] { fieldAccessor };
				statements.add(createResultCalculation(source, arraysHashCodeCall));
			}
		}
		
		/* 
		 * if (result == 0) result = Integer.MIN_VALUE;
		 * this.$hashCodeCache = result;
		 * 
		 */ {
			if (cacheHashCode) {
				SingleNameReference resultRef = new SingleNameReference(RESULT, p);
				setGeneratedBy(resultRef, source);
				
				EqualExpression resultIsZero = new EqualExpression(resultRef, makeIntLiteral(""0"".toCharArray(), source), OperatorIds.EQUAL_EQUAL);
				setGeneratedBy(resultIsZero, source);
				
				resultRef = new SingleNameReference(RESULT, p);
				setGeneratedBy(resultRef, source);
				
				FieldReference integerMinValue = new FieldReference(""MIN_VALUE"".toCharArray(), p);
				integerMinValue.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA_LANG_INTEGER);
				setGeneratedBy(integerMinValue, source);
				
				Assignment newResult = new Assignment(resultRef, integerMinValue, pE);
				newResult.sourceStart = pS; newResult.statementEnd = newResult.sourceEnd = pE;
				setGeneratedBy(newResult, source);
				
				IfStatement ifStatement = new IfStatement(resultIsZero, newResult, pS, pE);
				setGeneratedBy(ifStatement, source);
				statements.add(ifStatement);
				
				
				FieldReference hashCodeCacheRef = new FieldReference(HASH_CODE_CACHE_NAME_ARR, p);
				hashCodeCacheRef.receiver = new ThisReference(pS, pE);
				setGeneratedBy(hashCodeCacheRef, source);
				setGeneratedBy(hashCodeCacheRef.receiver, source);
				
				resultRef = new SingleNameReference(RESULT, p);
				setGeneratedBy(resultRef, source);
				
				Assignment cacheResult = new Assignment(hashCodeCacheRef, resultRef, pE);
				cacheResult.sourceStart = pS; cacheResult.statementEnd = cacheResult.sourceEnd = pE;
				setGeneratedBy(cacheResult, source);
				statements.add(cacheResult);
			}
		}
		
		/* return result; */ {
			SingleNameReference resultRef = new SingleNameReference(RESULT, p);
			setGeneratedBy(resultRef, source);
			ReturnStatement returnStatement = new ReturnStatement(resultRef, pS, pE);
			setGeneratedBy(returnStatement, source);
			statements.add(returnStatement);
		}
		method.statements = statements.toArray(new Statement[0]);
		return method;
	}

	public LocalDeclaration createLocalDeclaration(ASTNode source, char[] dollarFieldName, TypeReference type, Expression initializer) {
		int pS = source.sourceStart, pE = source.sourceEnd;
		LocalDeclaration tempVar = new LocalDeclaration(dollarFieldName, pS, pE);
		setGeneratedBy(tempVar, source);
		tempVar.initialization = initializer;
		tempVar.type = type;
		tempVar.type.sourceStart = pS; tempVar.type.sourceEnd = pE;
		setGeneratedBy(tempVar.type, source);
		tempVar.modifiers = Modifier.FINAL;
		return tempVar;
	}

	public Expression createResultCalculation(ASTNode source, Expression ex) {
		/* result = result * PRIME + (ex); */
		int pS = source.sourceStart, pE = source.sourceEnd;
		long p = (long)pS << 32 | pE;
		SingleNameReference resultRef = new SingleNameReference(RESULT, p);
		setGeneratedBy(resultRef, source);
		SingleNameReference primeRef = new SingleNameReference(PRIME, p);
		setGeneratedBy(primeRef, source);
		BinaryExpression multiplyByPrime = new BinaryExpression(resultRef, primeRef, OperatorIds.MULTIPLY);
		multiplyByPrime.sourceStart = pS; multiplyByPrime.sourceEnd = pE;
		setGeneratedBy(multiplyByPrime, source);
		BinaryExpression addItem = new BinaryExpression(multiplyByPrime, ex, OperatorIds.PLUS);
		addItem.sourceStart = pS; addItem.sourceEnd = pE;
		setGeneratedBy(addItem, source);
		resultRef = new SingleNameReference(RESULT, p);
		setGeneratedBy(resultRef, source);
		Assignment assignment = new Assignment(resultRef, addItem, pE);
		assignment.sourceStart = pS; assignment.sourceEnd = assignment.statementEnd = pE;
		setGeneratedBy(assignment, source);
		return assignment;
	}
	
	/**
	 * @param type Type to 'copy' into a typeref
	 * @param p position
	 * @param addWildcards If false, all generics are cut off. If true, replaces all genericparams with a ?.
	 * @return
	 */
	public TypeReference createTypeReference(EclipseNode type, long p, ASTNode source, boolean addWildcards) {
		int pS = source.sourceStart; int pE = source.sourceEnd;
		List<String> list = new ArrayList<String>();
		List<Integer> genericsCount = addWildcards ? new ArrayList<Integer>() : null;
		
		list.add(type.getName());
		if (addWildcards) genericsCount.add(arraySizeOf(((TypeDeclaration) type.get()).typeParameters));
		boolean staticContext = (((TypeDeclaration) type.get()).modifiers & ClassFileConstants.AccStatic) != 0;
		EclipseNode tNode = type.up();
		
		while (tNode != null && tNode.getKind() == Kind.TYPE) {
			TypeDeclaration td = (TypeDeclaration) tNode.get();
			if (td.name == null || td.name.length == 0) break;
			list.add(tNode.getName());
			if (!staticContext && tNode.getKind() == Kind.TYPE && (td.modifiers & ClassFileConstants.AccInterface) != 0) staticContext = true;
			if (addWildcards) genericsCount.add(staticContext ? 0 : arraySizeOf(td.typeParameters));
			if (!staticContext) staticContext = (td.modifiers & Modifier.STATIC) != 0;
			tNode = tNode.up();
		}
		Collections.reverse(list);
		if (addWildcards) Collections.reverse(genericsCount);
		
		if (list.size() == 1) {
			if (!addWildcards || genericsCount.get(0) == 0) {
				return new SingleTypeReference(list.get(0).toCharArray(), p);
			} else {
				return new ParameterizedSingleTypeReference(list.get(0).toCharArray(), wildcardify(pS, pE, source, genericsCount.get(0)), 0, p);
			}
		}
		
		if (addWildcards) {
			addWildcards = false;
			for (int i : genericsCount) if (i > 0) addWildcards = true;
		}
		
		long[] ps = new long[list.size()];
		char[][] tokens = new char[list.size()][];
		for (int i = 0; i < list.size(); i++) {
			ps[i] = p;
			tokens[i] = list.get(i).toCharArray();
		}
		
		if (!addWildcards) return new QualifiedTypeReference(tokens, ps);
		TypeReference[][] typeArgs2 = new TypeReference[tokens.length][];
		for (int i = 0; i < tokens.length; i++) typeArgs2[i] = wildcardify(pS, pE, source, genericsCount.get(i));
		return new ParameterizedQualifiedTypeReference(tokens, typeArgs2, 0, ps);
	}
	
	private TypeReference[] wildcardify(int pS, int pE, ASTNode source, int count) {
		if (count == 0) return null;
		TypeReference[] typeArgs = new TypeReference[count];
		for (int i = 0; i < count; i++) {
			typeArgs[i] = new Wildcard(Wildcard.UNBOUND);
			typeArgs[i].sourceStart = pS; typeArgs[i].sourceEnd = pE;
			setGeneratedBy(typeArgs[i], source);
		}
		
		return typeArgs;
	}
	
	private int arraySizeOf(Object[] arr) {
		return arr == null ? 0 : arr.length;
	}
	
	/*
	 * scan method, then class, then enclosing classes, then package for the first of:
	 * javax.annotation.ParametersAreNonnullByDefault or javax.annotation.ParametersAreNullableByDefault. If it's the NN variant, generate javax.annotation.Nullable _on the type_.
	 * org.eclipse.jdt.annotation.NonNullByDefault ->  org.eclipse.jdt.annotation.Nullable
	 */
	
	private static final char[][] JAVAX_ANNOTATION_NULLABLE = Eclipse.fromQualifiedName(""javax.annotation.Nullable"");
	private static final char[][] ORG_ECLIPSE_JDT_ANNOTATION_NULLABLE = Eclipse.fromQualifiedName(""org.eclipse.jdt.annotation.Nullable"");
	
	public MethodDeclaration createEquals(EclipseNode type, Collection<Included<EclipseNode, EqualsAndHashCode.Include>> members, boolean callSuper, ASTNode source, FieldAccess fieldAccess, boolean needsCanEqual, List<Annotation> onParam) {
		int pS = source.sourceStart; int pE = source.sourceEnd;
		long p = (long) pS << 32 | pE;
		
		Annotation[] onParamType = null;
		
		String nearest = scanForNearestAnnotation(type, ""javax.annotation.ParametersAreNullableByDefault"", ""javax.annotation.ParametersAreNonnullByDefault"");
		if (""javax.annotation.ParametersAreNonnullByDefault"".equals(nearest)) {
			onParamType = new Annotation[1];
			onParamType[0] = new MarkerAnnotation(generateQualifiedTypeRef(source, JAVAX_ANNOTATION_NULLABLE), 0);
		}
		
		nearest = scanForNearestAnnotation(type, ""org.eclipse.jdt.annotation.NonNullByDefault"");
		if (nearest != null) {
			Annotation a = new MarkerAnnotation(generateQualifiedTypeRef(source, ORG_ECLIPSE_JDT_ANNOTATION_NULLABLE), 0);
			if (onParamType != null) onParamType = new Annotation[] {onParamType[0], a};
			else onParamType = new Annotation[] {a};
		}
		
		MethodDeclaration method = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);
		setGeneratedBy(method, source);
		method.modifiers = toEclipseModifier(AccessLevel.PUBLIC);
		method.returnType = TypeReference.baseTypeReference(TypeIds.T_boolean, 0);
		method.returnType.sourceStart = pS; method.returnType.sourceEnd = pE;
		setGeneratedBy(method.returnType, source);
		Annotation overrideAnnotation = makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE, source);
		if (getCheckerFrameworkVersion(type).generateSideEffectFree()) {
			method.annotations = new Annotation[] { overrideAnnotation, generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE) };
		} else {
			method.annotations = new Annotation[] { overrideAnnotation };
		}
		method.selector = ""equals"".toCharArray();
		method.thrownExceptions = null;
		method.typeParameters = null;
		method.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;
		method.bodyStart = method.declarationSourceStart = method.sourceStart = source.sourceStart;
		method.bodyEnd = method.declarationSourceEnd = method.sourceEnd = source.sourceEnd;
		QualifiedTypeReference objectRef = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, new long[] { p, p, p });
		if (onParamType != null) objectRef.annotations = new Annotation[][] {null, null, onParamType};
		setGeneratedBy(objectRef, source);
		method.arguments = new Argument[] {new Argument(new char[] { 'o' }, 0, objectRef, Modifier.FINAL)};
		method.arguments[0].sourceStart = pS; method.arguments[0].sourceEnd = pE;
		if (!onParam.isEmpty()) method.arguments[0].annotations = onParam.toArray(new Annotation[0]);
		EclipseHandlerUtil.createRelevantNullableAnnotation(type, method.arguments[0]);
		setGeneratedBy(method.arguments[0], source);
		
		List<Statement> statements = new ArrayList<Statement>();
		
		/* if (o == this) return true; */ {
			SingleNameReference oRef = new SingleNameReference(new char[] { 'o' }, p);
			setGeneratedBy(oRef, source);
			ThisReference thisRef = new ThisReference(pS, pE);
			setGeneratedBy(thisRef, source);
			EqualExpression otherEqualsThis = new EqualExpression(oRef, thisRef, OperatorIds.EQUAL_EQUAL);
			setGeneratedBy(otherEqualsThis, source);
			
			TrueLiteral trueLiteral = new TrueLiteral(pS, pE);
			setGeneratedBy(trueLiteral, source);
			ReturnStatement returnTrue = new ReturnStatement(trueLiteral, pS, pE);
			setGeneratedBy(returnTrue, source);
			IfStatement ifOtherEqualsThis = new IfStatement(otherEqualsThis, returnTrue, pS, pE);
			setGeneratedBy(ifOtherEqualsThis, source);
			statements.add(ifOtherEqualsThis);
		}
		
		/* if (!(o instanceof Outer.Inner.MyType) return false; */ {
			SingleNameReference oRef = new SingleNameReference(new char[] { 'o' }, p);
			setGeneratedBy(oRef, source);
			
			TypeReference typeReference = createTypeReference(type, p, source, false);
			setGeneratedBy(typeReference, source);

			InstanceOfExpression instanceOf = new InstanceOfExpression(oRef, typeReference);
			instanceOf.sourceStart = pS; instanceOf.sourceEnd = pE;
			setGeneratedBy(instanceOf, source);
			
			Expression notInstanceOf = new UnaryExpression(instanceOf, OperatorIds.NOT);
			setGeneratedBy(notInstanceOf, source);
			
			FalseLiteral falseLiteral = new FalseLiteral(pS, pE);
			setGeneratedBy(falseLiteral, source);
			
			ReturnStatement returnFalse = new ReturnStatement(falseLiteral, pS, pE);
			setGeneratedBy(returnFalse, source);
			
			IfStatement ifNotInstanceOf = new IfStatement(notInstanceOf, returnFalse, pS, pE);
			setGeneratedBy(ifNotInstanceOf, source);
			statements.add(ifNotInstanceOf);
		}
		
		char[] otherName = ""other"".toCharArray();
		
		/* Outer.Inner.MyType<?> other = (Outer.Inner.MyType<?>) o; */ {
			if (!members.isEmpty() || needsCanEqual) {
				LocalDeclaration other = new LocalDeclaration(otherName, pS, pE);
				other.modifiers |= ClassFileConstants.AccFinal;
				setGeneratedBy(other, source);
				TypeReference targetType = createTypeReference(type, p, source, true);
				setGeneratedBy(targetType, source);
				other.type = createTypeReference(type, p, source, true);
				setGeneratedBy(other.type, source);
				NameReference oRef = new SingleNameReference(new char[] { 'o' }, p);
				setGeneratedBy(oRef, source);
				other.initialization = makeCastExpression(oRef, targetType, source);
				statements.add(other);
			}
		}
		
		/* if (!other.canEqual((java.lang.Object) this)) return false; */ {
			if (needsCanEqual) {
				MessageSend otherCanEqual = new MessageSend();
				otherCanEqual.sourceStart = pS; otherCanEqual.sourceEnd = pE;
				setGeneratedBy(otherCanEqual, source);
				otherCanEqual.receiver = new SingleNameReference(otherName, p);
				setGeneratedBy(otherCanEqual.receiver, source);
				otherCanEqual.selector = ""canEqual"".toCharArray();
				
				ThisReference thisReference = new ThisReference(pS, pE);
				setGeneratedBy(thisReference, source);
				CastExpression castThisRef = makeCastExpression(thisReference, generateQualifiedTypeRef(source, TypeConstants.JAVA_LANG_OBJECT), source);
				castThisRef.sourceStart = pS; castThisRef.sourceEnd = pE;
				
				otherCanEqual.arguments = new Expression[] {castThisRef};
				
				Expression notOtherCanEqual = new UnaryExpression(otherCanEqual, OperatorIds.NOT);
				setGeneratedBy(notOtherCanEqual, source);
				
				FalseLiteral falseLiteral = new FalseLiteral(pS, pE);
				setGeneratedBy(falseLiteral, source);
				
				ReturnStatement returnFalse = new ReturnStatement(falseLiteral, pS, pE);
				setGeneratedBy(returnFalse, source);
				
				IfStatement ifNotCanEqual = new IfStatement(notOtherCanEqual, returnFalse, pS, pE);
				setGeneratedBy(ifNotCanEqual, source);
				
				statements.add(ifNotCanEqual);
			}
		}
		
		/* if (!super.equals(o)) return false; */
		if (callSuper) {
			MessageSend callToSuper = new MessageSend();
			callToSuper.sourceStart = pS; callToSuper.sourceEnd = pE;
			setGeneratedBy(callToSuper, source);
			callToSuper.receiver = new SuperReference(pS, pE);
			setGeneratedBy(callToSuper.receiver, source);
			callToSuper.selector = ""equals"".toCharArray();
			SingleNameReference oRef = new SingleNameReference(new char[] { 'o' }, p);
			setGeneratedBy(oRef, source);
			callToSuper.arguments = new Expression[] {oRef};
			Expression superNotEqual = new UnaryExpression(callToSuper, OperatorIds.NOT);
			setGeneratedBy(superNotEqual, source);
			FalseLiteral falseLiteral = new FalseLiteral(pS, pE);
			setGeneratedBy(falseLiteral, source);
			ReturnStatement returnFalse = new ReturnStatement(falseLiteral, pS, pE);
			setGeneratedBy(returnFalse, source);
			IfStatement ifSuperEquals = new IfStatement(superNotEqual, returnFalse, pS, pE);
			setGeneratedBy(ifSuperEquals, source);
			statements.add(ifSuperEquals);
		}
		
		for (Included<EclipseNode, EqualsAndHashCode.Include> member : members) {
			EclipseNode memberNode = member.getNode();
			boolean isMethod = memberNode.getKind() == Kind.METHOD;
			
			TypeReference fType = getFieldType(memberNode, fieldAccess);
			char[] token = fType.getLastToken();
			Expression thisFieldAccessor = isMethod ? createMethodAccessor(memberNode, source) : createFieldAccessor(memberNode, fieldAccess, source);
			Expression otherFieldAccessor = isMethod ? createMethodAccessor(memberNode, source, otherName) : createFieldAccessor(memberNode, fieldAccess, source, otherName);
			
			if (fType.dimensions() == 0 && token != null) {
				if (Arrays.equals(TypeConstants.FLOAT, token)) {
					statements.add(generateCompareFloatOrDouble(thisFieldAccessor, otherFieldAccessor, ""Float"".toCharArray(), source));
				} else if (Arrays.equals(TypeConstants.DOUBLE, token)) {
					statements.add(generateCompareFloatOrDouble(thisFieldAccessor, otherFieldAccessor, ""Double"".toCharArray(), source));
				} else if (BUILT_IN_TYPES.contains(new String(token))) {
					EqualExpression fieldsNotEqual = new EqualExpression(thisFieldAccessor, otherFieldAccessor, OperatorIds.NOT_EQUAL);
					setGeneratedBy(fieldsNotEqual, source);
					FalseLiteral falseLiteral = new FalseLiteral(pS, pE);
					setGeneratedBy(falseLiteral, source);
					ReturnStatement returnStatement = new ReturnStatement(falseLiteral, pS, pE);
					setGeneratedBy(returnStatement, source);
					IfStatement ifStatement = new IfStatement(fieldsNotEqual, returnStatement, pS, pE);
					setGeneratedBy(ifStatement, source);
					statements.add(ifStatement);
				} else /* objects */ {
					/* final java.lang.Object this$fieldName = this.fieldName; */
					/* final java.lang.Object other$fieldName = other.fieldName; */
					/* if (this$fieldName == null ? other$fieldName != null : !this$fieldName.equals(other$fieldName)) return false; */
					char[] thisDollarFieldName = (""this"" + (isMethod ? ""$$"" : ""$"") + memberNode.getName()).toCharArray();
					char[] otherDollarFieldName = (""other"" + (isMethod ? ""$$"" : ""$"") + memberNode.getName()).toCharArray();
					
					statements.add(createLocalDeclaration(source, thisDollarFieldName, generateQualifiedTypeRef(source, TypeConstants.JAVA_LANG_OBJECT), thisFieldAccessor));
					statements.add(createLocalDeclaration(source, otherDollarFieldName, generateQualifiedTypeRef(source, TypeConstants.JAVA_LANG_OBJECT), otherFieldAccessor));
					
					SingleNameReference this1 = new SingleNameReference(thisDollarFieldName, p);
					setGeneratedBy(this1, source);
					SingleNameReference this2 = new SingleNameReference(thisDollarFieldName, p);
					setGeneratedBy(this2, source);
					SingleNameReference other1 = new SingleNameReference(otherDollarFieldName, p);
					setGeneratedBy(other1, source);
					SingleNameReference other2 = new SingleNameReference(otherDollarFieldName, p);
					setGeneratedBy(other2, source);
					
					NullLiteral nullLiteral = new NullLiteral(pS, pE);
					setGeneratedBy(nullLiteral, source);
					EqualExpression fieldIsNull = new EqualExpression(this1, nullLiteral, OperatorIds.EQUAL_EQUAL);
					nullLiteral = new NullLiteral(pS, pE);
					setGeneratedBy(nullLiteral, source);
					EqualExpression otherFieldIsntNull = new EqualExpression(other1, nullLiteral, OperatorIds.NOT_EQUAL);
					MessageSend equalsCall = new MessageSend();
					equalsCall.sourceStart = pS; equalsCall.sourceEnd = pE;
					setGeneratedBy(equalsCall, source);
					equalsCall.receiver = this2;
					equalsCall.selector = ""equals"".toCharArray();
					equalsCall.arguments = new Expression[] { other2 };
					UnaryExpression fieldsNotEqual = new UnaryExpression(equalsCall, OperatorIds.NOT);
					fieldsNotEqual.sourceStart = pS; fieldsNotEqual.sourceEnd = pE;
					setGeneratedBy(fieldsNotEqual, source);
					ConditionalExpression fullEquals = new ConditionalExpression(fieldIsNull, otherFieldIsntNull, fieldsNotEqual);
					fullEquals.sourceStart = pS; fullEquals.sourceEnd = pE;
					setGeneratedBy(fullEquals, source);
					FalseLiteral falseLiteral = new FalseLiteral(pS, pE);
					setGeneratedBy(falseLiteral, source);
					ReturnStatement returnStatement = new ReturnStatement(falseLiteral, pS, pE);
					setGeneratedBy(returnStatement, source);
					IfStatement ifStatement = new IfStatement(fullEquals, returnStatement, pS, pE);
					setGeneratedBy(ifStatement, source);
					statements.add(ifStatement);
				}
			} else if (fType.dimensions() > 0 && token != null) {
				MessageSend arraysEqualCall = new MessageSend();
				arraysEqualCall.sourceStart = pS; arraysEqualCall.sourceEnd = pE;
				setGeneratedBy(arraysEqualCall, source);
				arraysEqualCall.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA, TypeConstants.UTIL, ""Arrays"".toCharArray());
				if (fType.dimensions() > 1 || !BUILT_IN_TYPES.contains(new String(token))) {
					arraysEqualCall.selector = ""deepEquals"".toCharArray();
				} else {
					arraysEqualCall.selector = ""equals"".toCharArray();
				}
				arraysEqualCall.arguments = new Expression[] { thisFieldAccessor, otherFieldAccessor };
				UnaryExpression arraysNotEqual = new UnaryExpression(arraysEqualCall, OperatorIds.NOT);
				arraysNotEqual.sourceStart = pS; arraysNotEqual.sourceEnd = pE;
				setGeneratedBy(arraysNotEqual, source);
				FalseLiteral falseLiteral = new FalseLiteral(pS, pE);
				setGeneratedBy(falseLiteral, source);
				ReturnStatement returnStatement = new ReturnStatement(falseLiteral, pS, pE);
				setGeneratedBy(returnStatement, source);
				IfStatement ifStatement = new IfStatement(arraysNotEqual, returnStatement, pS, pE);
				setGeneratedBy(ifStatement, source);
				statements.add(ifStatement);
			}
		}
		
		/* return true; */ {
			TrueLiteral trueLiteral = new TrueLiteral(pS, pE);
			setGeneratedBy(trueLiteral, source);
			ReturnStatement returnStatement = new ReturnStatement(trueLiteral, pS, pE);
			setGeneratedBy(returnStatement, source);
			statements.add(returnStatement);
		}
		method.statements = statements.toArray(new Statement[0]);
		return method;
	}
	
	public MethodDeclaration createCanEqual(EclipseNode type, ASTNode source, List<Annotation> onParam) {
		/* protected boolean canEqual(final java.lang.Object other) {
		 *     return other instanceof Outer.Inner.MyType;
		 * }
		 */
		int pS = source.sourceStart; int pE = source.sourceEnd;
		long p = (long)pS << 32 | pE;
		
		char[] otherName = ""other"".toCharArray();
		
		MethodDeclaration method = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);
		setGeneratedBy(method, source);
		method.modifiers = toEclipseModifier(AccessLevel.PROTECTED);
		method.returnType = TypeReference.baseTypeReference(TypeIds.T_boolean, 0);
		method.returnType.sourceStart = pS; method.returnType.sourceEnd = pE;
		setGeneratedBy(method.returnType, source);
		method.selector = ""canEqual"".toCharArray();
		method.thrownExceptions = null;
		method.typeParameters = null;
		method.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;
		method.bodyStart = method.declarationSourceStart = method.sourceStart = source.sourceStart;
		method.bodyEnd = method.declarationSourceEnd = method.sourceEnd = source.sourceEnd;
		TypeReference objectRef = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, new long[] { p, p, p });
		setGeneratedBy(objectRef, source);
		method.arguments = new Argument[] {new Argument(otherName, 0, objectRef, Modifier.FINAL)};
		method.arguments[0].sourceStart = pS; method.arguments[0].sourceEnd = pE;
		if (!onParam.isEmpty()) method.arguments[0].annotations = onParam.toArray(new Annotation[0]);
		EclipseHandlerUtil.createRelevantNullableAnnotation(type, method.arguments[0]);
		setGeneratedBy(method.arguments[0], source);
		
		SingleNameReference otherRef = new SingleNameReference(otherName, p);
		setGeneratedBy(otherRef, source);
		
		TypeReference typeReference = createTypeReference(type, p, source, false);
		setGeneratedBy(typeReference, source);
		
		InstanceOfExpression instanceOf = new InstanceOfExpression(otherRef, typeReference);
		instanceOf.sourceStart = pS; instanceOf.sourceEnd = pE;
		setGeneratedBy(instanceOf, source);
		
		ReturnStatement returnStatement = new ReturnStatement(instanceOf, pS, pE);
		setGeneratedBy(returnStatement, source);
		
		method.statements = new Statement[] {returnStatement};
		if (getCheckerFrameworkVersion(type).generatePure()) method.annotations = new Annotation[] { generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__PURE) };
		return method;
	}

	
	public IfStatement generateCompareFloatOrDouble(Expression thisRef, Expression otherRef, char[] floatOrDouble, ASTNode source) {
		int pS = source.sourceStart, pE = source.sourceEnd;
		/* if (Float.compare(fieldName, other.fieldName) != 0) return false */
		MessageSend floatCompare = new MessageSend();
		floatCompare.sourceStart = pS; floatCompare.sourceEnd = pE;
		setGeneratedBy(floatCompare, source);
		floatCompare.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA, TypeConstants.LANG, floatOrDouble);
		floatCompare.selector = ""compare"".toCharArray();
		floatCompare.arguments = new Expression[] {thisRef, otherRef};
		IntLiteral int0 = makeIntLiteral(""0"".toCharArray(), source);
		EqualExpression ifFloatCompareIsNot0 = new EqualExpression(floatCompare, int0, OperatorIds.NOT_EQUAL);
		ifFloatCompareIsNot0.sourceStart = pS; ifFloatCompareIsNot0.sourceEnd = pE;
		setGeneratedBy(ifFloatCompareIsNot0, source);
		FalseLiteral falseLiteral = new FalseLiteral(pS, pE);
		setGeneratedBy(falseLiteral, source);
		ReturnStatement returnFalse = new ReturnStatement(falseLiteral, pS, pE);
		setGeneratedBy(returnFalse, source);
		IfStatement ifStatement = new IfStatement(ifFloatCompareIsNot0, returnFalse, pS, pE);
		setGeneratedBy(ifStatement, source);
		return ifStatement;
	}
	
	/** Give 2 clones! */
	public Expression longToIntForHashCode(Expression ref1, Expression ref2, ASTNode source) {
		int pS = source.sourceStart, pE = source.sourceEnd;
		/* (int)(ref >>> 32 ^ ref) */
		IntLiteral int32 = makeIntLiteral(""32"".toCharArray(), source);
		BinaryExpression higherBits = new BinaryExpression(ref1, int32, OperatorIds.UNSIGNED_RIGHT_SHIFT);
		setGeneratedBy(higherBits, source);
		BinaryExpression xorParts = new BinaryExpression(ref2, higherBits, OperatorIds.XOR);
		setGeneratedBy(xorParts, source);
		TypeReference intRef = TypeReference.baseTypeReference(TypeIds.T_int, 0);
		intRef.sourceStart = pS; intRef.sourceEnd = pE;
		setGeneratedBy(intRef, source);
		CastExpression expr = makeCastExpression(xorParts, intRef, source);
		expr.sourceStart = pS; expr.sourceEnd = pE;
		return expr;
	}
}",1,64 2000 439 334 2001 378 2002 60 2003 62 123 437 457 381 2004 2005 61 648 59 437 381 330 91 93 2006 61 2005 46 2007 40 41 59 437 381 330 91 93 2008 61 648 46 2007 40 41 59 437 381 330 91 93 2009 61 648 46 2007 40 41 59 439 457 381 2010 60 2004 62 2011 61 2012 46 2013 40 418 2014 60 2004 62 40 2015 46 2016 40 648 44 648 44 648 44 648 44 648 44 648 44 648 44 648 41 41 41 59 64 2017 439 492 2018 40 2019 60 2003 62 2020 44 2021 2022 44 2023 2024 41 123 2025 40 2024 44 2026 46 2027 44 648 41 59 2003 2028 61 2020 46 2029 40 41 59 2030 60 2031 60 2023 44 2003 46 2032 641 2033 61 2034 46 2035 40 2024 46 2036 40 41 44 2020 44 2024 41 59 392 40 2033 614 424 41 450 59 2030 60 2021 62 2037 61 2038 40 2022 44 648 44 648 44 2024 41 59 2039 2040 61 2028 46 2040 40 41 59 392 40 33 2020 46 2041 40 648 41 41 2040 61 424 59 2039 2042 61 2024 46 2043 40 41 46 2044 40 2026 46 2045 41 59 324 2046 61 2020 46 2041 40 648 41 606 2042 614 424 63 2028 46 2046 40 41 58 2042 59 2047 2048 61 2046 63 2047 46 2049 58 2047 46 2050 59 324 2051 61 2028 46 2052 40 41 614 2053 46 2054 59 2055 40 2024 46 2036 40 41 44 2024 44 2033 44 2040 44 473 44 2051 44 2048 44 2037 41 59 125 439 492 2056 40 2023 2057 44 2023 2058 41 123 392 40 2059 40 2003 46 334 44 2057 41 41 123 621 450 59 125 2060 60 2061 60 2023 44 2003 46 2062 641 2063 61 2064 46 2065 40 2057 44 424 44 424 41 59 2066 2067 61 2057 46 2068 40 41 46 2069 40 2070 46 2071 41 59 2072 2073 61 2067 614 424 606 33 2067 63 2072 46 2074 58 2072 46 2075 59 2076 40 2057 44 2058 44 2063 44 424 44 380 44 380 44 2073 44 418 2077 60 2021 62 40 41 41 59 125 439 492 2078 40 2023 2057 44 2023 2058 44 2079 60 2080 60 2023 44 2003 46 2081 641 2082 44 2083 2084 44 324 2085 44 324 2086 44 2087 2088 44 2079 60 2021 62 2089 41 123 392 40 33 2090 40 2057 41 41 123 2058 46 2091 40 648 41 59 450 59 125 2092 2093 61 40 2092 41 2057 46 2094 40 41 59 324 2095 61 2084 614 424 59 392 40 2084 614 424 41 123 474 123 2084 61 40 40 2083 41 2003 46 334 46 2096 40 648 41 46 2097 40 41 41 46 2098 40 41 59 125 329 40 2099 2100 41 123 469 418 2101 40 648 41 59 125 125 324 2102 61 2102 40 2057 41 59 324 2103 61 40 2093 46 2104 38 2105 46 2106 41 631 1500 59 324 2107 61 33 2103 606 33 2102 59 2108 2109 61 2110 40 648 44 2057 44 1501 41 59 2108 2111 61 2110 40 648 44 2057 44 1500 41 59 2108 2112 61 2110 40 648 44 2057 44 1501 41 59 464 40 2012 46 2113 40 2015 46 2016 40 2109 44 2111 41 41 41 123 328 2114 58 450 59 328 2115 58 392 40 2085 41 123 2004 2116 61 648 59 2058 46 2117 40 2116 41 59 125 360 392 40 2109 614 2108 46 2118 606 2111 614 2108 46 2118 41 123 621 621 621 621 2004 2119 61 2004 46 2120 40 648 43 648 44 2109 614 2108 46 2118 63 648 58 648 41 59 2058 46 2121 40 2119 41 59 125 450 59 328 2118 58 349 58 621 125 392 40 2102 605 2084 41 123 2058 46 2122 40 648 41 59 450 59 125 392 40 2095 605 33 2102 41 123 2123 2124 61 2057 46 2125 40 41 46 2126 40 2127 46 2128 41 59 392 40 2124 614 424 41 2124 61 2123 46 2129 59 464 40 2124 41 123 349 58 328 2129 58 2058 46 2130 40 648 41 59 2084 61 380 59 325 59 328 2131 58 2084 61 380 59 325 59 328 2132 58 2084 61 473 59 325 59 125 125 2133 2134 61 2135 40 2057 44 2082 44 2084 44 2058 46 2094 40 41 44 2088 44 2107 44 2089 41 59 2134 46 2136 40 418 2137 40 2058 46 2094 40 41 41 44 40 40 2092 41 2057 46 2094 40 41 41 46 2138 41 59 2139 40 2057 44 2134 41 59 392 40 2107 605 2112 614 2108 46 2140 41 123 2133 2141 61 2142 40 2057 44 2058 46 2094 40 41 44 2089 41 59 2141 46 2136 40 418 2137 40 2058 46 2094 40 41 41 44 40 40 2092 41 2057 46 2094 40 41 41 46 2138 41 59 2139 40 2057 44 2141 41 59 125 392 40 2086 41 123 392 40 2143 40 2005 44 2057 41 631 2108 46 2140 41 123 2004 2144 61 2004 46 2145 40 648 44 2005 41 59 2058 46 2146 40 2144 41 59 2086 61 380 59 125 360 123 2147 40 2057 44 2058 46 2094 40 41 41 59 125 125 2133 2148 61 2149 40 2057 44 2082 44 2084 44 2086 44 2058 46 2094 40 41 44 2088 41 59 2148 46 2136 40 418 2137 40 2058 46 2094 40 41 41 44 40 40 2092 41 2057 46 2094 40 41 41 46 2138 41 59 2139 40 2057 44 2148 41 59 125 437 492 2150 40 2023 2057 44 2151 2152 41 123 2153 2154 61 418 2153 40 2006 44 1500 44 1500 41 59 2154 46 2155 61 2156 46 2157 124 2156 46 2158 59 2154 46 2159 635 2160 46 2161 59 2154 46 2162 61 2163 46 2164 40 2165 46 2166 44 1500 41 59 2154 46 2167 61 45 1501 59 2168 40 2057 44 2154 41 59 2169 40 2154 44 2152 41 59 2169 40 2154 46 2162 44 2152 41 59 125 437 457 381 330 91 93 2170 61 648 46 2007 40 41 44 2171 61 648 46 2007 40 41 44 2172 61 648 46 2007 40 41 59 439 2173 2174 40 2023 2175 44 2176 60 2080 60 2023 44 2003 46 2081 641 2082 44 324 2084 44 324 2086 44 2151 2152 44 2087 2088 41 123 404 2177 61 2152 46 2178 44 2179 61 2152 46 2180 59 413 2181 61 40 413 41 2177 622 1503 124 2179 59 2173 2182 61 418 2173 40 40 40 2183 41 2175 46 2184 40 41 46 2185 40 41 41 46 2186 41 59 2187 40 2182 44 2152 41 59 2182 46 2188 61 2189 40 2190 46 2191 41 59 2182 46 2192 61 2193 46 2194 40 2195 46 2196 44 1500 41 59 2187 40 2182 46 2192 44 2152 41 59 2021 2197 61 2198 40 2199 46 2200 44 2152 41 59 2201 2202 61 2203 40 2175 41 59 392 40 2086 605 2202 46 2204 40 41 41 123 2182 46 2205 61 418 2021 91 93 123 2197 44 2206 40 2152 44 2201 46 2207 41 125 59 125 360 392 40 2202 46 2208 40 41 41 123 2182 46 2209 61 418 2021 91 93 123 2197 44 2210 40 2152 44 2201 46 2211 41 125 59 125 360 123 2182 46 2212 61 418 2021 91 93 123 2197 125 59 125 2182 46 2213 61 648 46 2007 40 41 59 2182 46 2214 61 424 59 2182 46 2215 61 424 59 2182 46 2216 635 2217 46 2218 59 2182 46 2219 61 2182 46 2220 61 2182 46 2178 61 2152 46 2178 59 2182 46 2221 61 2182 46 2222 61 2182 46 2180 61 2152 46 2180 59 2182 46 2223 61 424 59 2079 60 2224 62 2225 61 418 2226 60 2224 62 40 41 59 324 2227 61 473 59 385 40 2080 60 2023 44 2003 46 2081 62 2228 58 2082 41 123 2193 2229 61 2230 40 2228 46 2231 40 41 44 2088 41 59 392 40 2229 46 2232 40 41 631 424 41 123 2227 61 380 59 325 59 125 125 604 123 392 40 2086 41 123 2233 2234 61 418 2233 40 2006 44 2181 41 59 2234 46 2235 61 418 2236 40 2177 44 2179 41 59 2187 40 2234 44 2152 41 59 2187 40 2234 46 2235 44 2152 41 59 2237 2238 61 418 2237 40 2234 44 2239 40 648 46 2007 40 41 44 2152 41 44 2240 46 2241 41 59 2187 40 2238 44 2152 41 59 2242 2243 61 418 2242 40 2234 44 2177 44 2179 41 59 2187 40 2243 44 2152 41 59 2244 2245 61 418 2244 40 2238 44 2243 44 2177 44 2179 41 59 2187 40 2245 44 2152 41 59 2225 46 2246 40 2245 41 59 125 125 604 123 604 392 40 33 2227 41 123 2247 2248 61 418 2247 40 2008 44 2177 44 2179 41 59 2187 40 2248 44 2152 41 59 2248 46 2188 635 2249 46 2250 59 2248 46 2175 61 2193 46 2194 40 2195 46 2196 44 1500 41 59 2248 46 2175 46 2178 61 2177 59 2248 46 2175 46 2180 61 2179 59 2187 40 2248 46 2175 44 2152 41 59 2248 46 2251 61 2252 40 2004 46 2253 40 2254 46 2255 40 41 41 46 2007 40 41 44 2152 41 59 2225 46 2256 40 2248 41 59 125 125 604 123 2257 2258 61 418 2257 40 2009 44 2177 44 2179 41 59 2187 40 2258 44 2152 41 59 381 2259 2260 59 392 40 2084 41 123 604 2261 2262 61 418 2261 40 41 59 2187 40 2262 44 2152 41 59 2262 46 2178 61 2177 59 2262 46 2180 61 2179 59 2262 46 2263 61 418 2264 40 2177 44 2179 41 59 2187 40 2262 46 2263 44 2152 41 59 2262 46 2213 61 648 46 2007 40 41 59 2260 61 2262 59 125 360 123 604 2260 61 2265 40 648 46 2007 40 41 44 2152 41 59 125 2258 46 2266 61 2260 59 2258 46 2175 61 2193 46 2194 40 2195 46 2196 44 1500 41 59 2258 46 2175 46 2178 61 2177 59 2258 46 2175 46 2180 61 2179 59 392 40 2227 605 33 2086 41 2258 46 2188 635 2267 46 2268 59 2187 40 2258 46 2175 44 2152 41 59 2225 46 2269 40 2258 41 59 125 385 40 2080 60 2023 44 2003 46 2081 62 2228 58 2082 41 123 2023 2270 61 2228 46 2271 40 41 59 324 2272 61 2270 46 2273 40 41 614 2274 46 2275 59 2193 2276 61 2277 40 2270 44 2088 41 59 330 91 93 2278 61 40 40 2272 63 648 58 648 41 43 2270 46 2279 40 41 41 46 2007 40 41 59 330 91 93 2280 61 2276 46 2281 40 41 59 2282 2283 61 2272 63 2284 40 2270 44 2152 41 58 2285 40 2270 44 2088 44 2152 41 59 392 40 2276 46 2286 40 41 614 1500 605 2280 631 424 41 123 392 40 2015 46 2287 40 2199 46 2288 44 2280 41 41 123 604 2289 2290 61 2291 40 2004 46 2292 40 2293 46 2294 40 41 41 46 2007 40 41 44 2152 41 59 2289 2295 61 2291 40 2004 46 2292 40 2293 46 2296 40 41 41 46 2007 40 41 44 2152 41 59 2297 2298 61 418 2297 40 2283 44 2290 44 2295 41 59 2187 40 2298 44 2152 41 59 2225 46 2299 40 2300 40 2152 44 2298 41 41 59 125 360 392 40 2015 46 2287 40 2199 46 2301 44 2280 41 41 123 604 2225 46 2302 40 2303 40 2152 44 2278 44 2193 46 2194 40 2195 46 2304 44 1500 41 44 2283 41 41 59 2305 2306 61 418 2305 40 2278 44 2181 41 59 2187 40 2306 44 2152 41 59 2305 2307 61 418 2305 40 2278 44 2181 41 59 2187 40 2307 44 2152 41 59 2225 46 2302 40 2308 40 2152 44 2309 40 2306 44 2307 44 2152 41 41 41 59 125 360 392 40 2015 46 2287 40 2199 46 2310 44 2280 41 41 123 604 2311 2312 61 418 2311 40 41 59 2312 46 2178 61 2177 59 2312 46 2180 61 2179 59 2187 40 2312 44 2152 41 59 2312 46 2313 61 2314 40 2152 44 2199 46 2315 41 59 2312 46 2213 61 2171 59 2312 46 2223 61 418 2282 91 93 123 2283 125 59 2225 46 2316 40 2317 40 2152 44 2312 41 41 59 125 360 392 40 2015 46 2287 40 2199 46 2318 44 2280 41 41 123 604 2319 2320 61 418 2319 40 41 59 2320 46 2178 61 2177 59 2320 46 2180 61 2179 59 2187 40 2320 44 2152 41 59 2320 46 2321 61 2322 40 2152 44 2199 46 2323 41 59 2320 46 2213 61 2172 59 2320 46 2223 61 418 2282 91 93 123 2283 125 59 2225 46 2324 40 2325 40 2152 44 2278 44 2193 46 2194 40 2195 46 2326 44 1500 41 44 2320 41 41 59 2327 2328 61 418 2327 40 2278 44 2181 41 59 2187 40 2328 44 2152 41 59 2327 2329 61 418 2327 40 2278 44 2181 41 59 2187 40 2329 44 2152 41 59 2225 46 2324 40 2330 40 2152 44 2331 40 2328 44 2329 44 2152 41 41 41 59 125 360 392 40 2011 46 2332 40 418 2004 40 2280 41 41 41 123 2225 46 2333 40 2334 40 2152 44 2283 41 41 59 125 360 604 123 604 604 2225 46 2335 40 2336 40 2152 44 2278 44 2337 40 2152 44 2199 46 2338 41 44 2283 41 41 59 2339 2340 61 418 2339 40 2278 44 2181 41 59 2187 40 2340 44 2152 41 59 2339 2341 61 418 2339 40 2278 44 2181 41 59 2187 40 2341 44 2152 41 59 2342 2343 61 418 2342 40 41 59 2343 46 2178 61 2177 59 2343 46 2180 61 2179 59 2187 40 2343 44 2152 41 59 2343 46 2344 61 2340 59 2343 46 2213 61 2170 59 2345 2346 61 418 2345 40 2177 44 2179 41 59 2187 40 2346 44 2152 41 59 2347 2348 61 418 2347 40 2341 44 2346 44 2349 46 2350 41 59 2187 40 2348 44 2152 41 59 2351 2352 61 2353 40 2004 46 2354 40 2355 46 2356 40 41 41 46 2007 40 41 44 2152 41 59 2357 2358 61 418 2357 40 2348 44 2352 44 2343 41 59 2358 46 2178 61 2177 59 2358 46 2180 61 2179 59 2187 40 2358 44 2152 41 59 2225 46 2335 40 2359 40 2152 44 2358 41 41 59 125 125 360 392 40 2276 46 2286 40 41 62 1500 605 2280 631 424 41 123 604 2360 2361 61 418 2360 40 41 59 2361 46 2178 61 2177 59 2361 46 2180 61 2179 59 2187 40 2361 44 2152 41 59 2361 46 2362 61 2363 40 2152 44 2199 46 2364 44 2199 46 2365 44 648 46 2007 40 41 41 59 392 40 2276 46 2286 40 41 62 1501 606 33 2011 46 2366 40 418 2004 40 2280 41 41 41 123 2361 46 2213 61 648 46 2007 40 41 59 125 360 123 2361 46 2213 61 648 46 2007 40 41 59 125 2361 46 2223 61 418 2282 91 93 123 2283 125 59 2225 46 2367 40 2368 40 2152 44 2361 41 41 59 125 125 604 123 392 40 2086 41 123 2369 2370 61 418 2369 40 2009 44 2181 41 59 2187 40 2370 44 2152 41 59 2371 2372 61 418 2371 40 2370 44 2373 40 648 46 2007 40 41 44 2152 41 44 2374 46 2375 41 59 2187 40 2372 44 2152 41 59 2370 61 418 2369 40 2009 44 2181 41 59 2187 40 2370 44 2152 41 59 2376 2377 61 418 2376 40 648 46 2007 40 41 44 2181 41 59 2377 46 2378 61 2379 40 2152 44 2199 46 2380 41 59 2187 40 2377 44 2152 41 59 2381 2382 61 418 2381 40 2370 44 2377 44 2179 41 59 2382 46 2178 61 2177 59 2382 46 2383 61 2382 46 2180 61 2179 59 2187 40 2382 44 2152 41 59 2384 2385 61 418 2384 40 2372 44 2382 44 2177 44 2179 41 59 2187 40 2385 44 2152 41 59 2225 46 2386 40 2385 41 59 2376 2387 61 418 2376 40 2006 44 2181 41 59 2387 46 2378 61 418 2388 40 2177 44 2179 41 59 2187 40 2387 44 2152 41 59 2187 40 2387 46 2378 44 2152 41 59 2370 61 418 2369 40 2009 44 2181 41 59 2187 40 2370 44 2152 41 59 2381 2389 61 418 2381 40 2387 44 2370 44 2179 41 59 2389 46 2178 61 2177 59 2389 46 2383 61 2389 46 2180 61 2179 59 2187 40 2389 44 2152 41 59 2225 46 2386 40 2389 41 59 125 125 604 123 2390 2391 61 418 2390 40 2009 44 2181 41 59 2187 40 2391 44 2152 41 59 2392 2393 61 418 2392 40 2391 44 2177 44 2179 41 59 2187 40 2393 44 2152 41 59 2225 46 2394 40 2393 41 59 125 2182 46 2225 61 2225 46 2395 40 418 2224 91 1500 93 41 59 450 2182 59 125 439 2396 2397 40 2151 2152 44 330 91 93 2398 44 2399 2175 44 2400 2401 41 123 404 2402 61 2152 46 2403 44 2404 61 2152 46 2405 59 2396 2406 61 418 2396 40 2398 44 2402 44 2404 41 59 2407 40 2406 44 2152 41 59 2406 46 2408 61 2401 59 2406 46 2175 61 2175 59 2406 46 2175 46 2403 61 2402 59 2406 46 2175 46 2405 61 2404 59 2407 40 2406 46 2175 44 2152 41 59 2406 46 2409 61 2410 46 2411 59 450 2406 59 125 439 2400 2412 40 2151 2152 44 2400 2413 41 123 604 404 2414 61 2152 46 2415 44 2416 61 2152 46 2417 59 413 2418 61 40 413 41 2414 622 1503 124 2416 59 2419 2420 61 418 2419 40 2009 44 2418 41 59 2421 40 2420 44 2152 41 59 2419 2422 61 418 2419 40 2008 44 2418 41 59 2421 40 2422 44 2152 41 59 2423 2424 61 418 2423 40 2420 44 2422 44 2425 46 2426 41 59 2424 46 2415 61 2414 59 2424 46 2417 61 2416 59 2421 40 2424 44 2152 41 59 2423 2427 61 418 2423 40 2424 44 2413 44 2425 46 2428 41 59 2427 46 2415 61 2414 59 2427 46 2417 61 2416 59 2421 40 2427 44 2152 41 59 2420 61 418 2419 40 2009 44 2418 41 59 2421 40 2420 44 2152 41 59 2429 2430 61 418 2429 40 2420 44 2427 44 2416 41 59 2430 46 2415 61 2414 59 2430 46 2417 61 2430 46 2431 61 2416 59 2421 40 2430 44 2152 41 59 450 2430 59 125 618 439 2399 2432 40 2023 2175 44 413 2433 44 2151 2152 44 324 2434 41 123 404 2435 61 2152 46 2436 59 404 2437 61 2152 46 2438 59 2079 60 2004 62 411 61 418 2439 60 2004 62 40 41 59 2079 60 2440 62 2441 61 2434 63 418 2439 60 2440 62 40 41 58 424 59 411 46 2442 40 2175 46 2443 40 41 41 59 392 40 2434 41 2441 46 2442 40 2444 40 40 40 2445 41 2175 46 2446 40 41 41 46 2447 41 41 59 324 2448 61 40 40 40 2445 41 2175 46 2446 40 41 41 46 2449 38 2450 46 2451 41 631 1500 59 2023 2452 61 2175 46 2453 40 41 59 496 40 2452 631 424 605 2452 46 2454 40 41 614 2455 46 2456 41 123 2445 2457 61 40 2445 41 2452 46 2446 40 41 59 392 40 2457 46 2458 614 424 606 2457 46 2458 46 2459 614 1500 41 325 59 411 46 2442 40 2452 46 2443 40 41 41 59 392 40 33 2448 605 2452 46 2454 40 41 614 2455 46 2456 605 40 2457 46 2449 38 2450 46 2460 41 631 1500 41 2448 61 473 59 392 40 2434 41 2441 46 2442 40 2448 63 1500 58 2444 40 2457 46 2447 41 41 59 392 40 33 2448 41 2448 61 40 2457 46 2449 38 2461 46 2462 41 631 1500 59 2452 61 2452 46 2453 40 41 59 125 2012 46 2463 40 411 41 59 392 40 2434 41 2012 46 2463 40 2441 41 59 392 40 411 46 2464 40 41 614 1501 41 123 392 40 33 2434 606 2441 46 2446 40 1500 41 614 1500 41 123 450 418 2465 40 411 46 2446 40 1500 41 46 2007 40 41 44 2433 41 59 125 360 123 450 418 2466 40 411 46 2446 40 1500 41 46 2007 40 41 44 2467 40 2435 44 2437 44 2152 44 2441 46 2446 40 1500 41 41 44 1500 44 2433 41 59 125 125 392 40 2434 41 123 2434 61 380 59 385 40 404 2468 58 2441 41 392 40 2468 62 1500 41 2434 61 473 59 125 413 91 93 2469 61 418 413 91 411 46 2464 40 41 93 59 330 91 93 91 93 2470 61 418 330 91 411 46 2464 40 41 93 91 93 59 385 40 404 2471 61 1500 59 2471 60 411 46 2464 40 41 59 2471 637 41 123 2469 91 2471 93 61 2433 59 2470 91 2471 93 61 411 46 2446 40 2471 41 46 2007 40 41 59 125 392 40 33 2434 41 450 418 2472 40 2470 44 2469 41 59 2399 91 93 91 93 2473 61 418 2399 91 2470 46 2474 93 91 93 59 385 40 404 2471 61 1500 59 2471 60 2470 46 2474 59 2471 637 41 2473 91 2471 93 61 2475 40 2435 44 2437 44 2152 44 2441 46 2446 40 2471 41 41 59 450 418 2476 40 2470 44 2473 44 1500 44 2469 41 59 125 437 2399 91 93 2477 40 404 2478 44 404 2479 44 2151 2152 44 404 2480 41 123 392 40 2480 614 1500 41 450 424 59 2399 91 93 2481 61 418 2399 91 2480 93 59 385 40 404 2482 61 1500 59 2482 60 2480 59 2482 637 41 123 2481 91 2482 93 61 418 2483 40 2483 46 2484 41 59 2481 91 2482 93 46 2485 61 2478 59 2481 91 2482 93 46 2486 61 2479 59 2487 40 2481 91 2482 93 44 2152 41 59 125 450 2481 59 125 437 404 2488 40 2489 91 93 2490 41 123 450 2490 614 424 63 1500 58 2490 46 2491 59 125 604 437 457 381 330 91 93 91 93 2492 61 2493 46 2494 40 648 41 59 437 457 381 330 91 93 91 93 2495 61 2493 46 2494 40 648 41 59 439 2173 2496 40 2023 2175 44 2176 60 2080 60 2023 44 2003 46 2081 641 2082 44 324 2084 44 2151 2152 44 2087 2088 44 324 2497 44 2079 60 2021 62 2089 41 123 404 2478 61 2152 46 2498 59 404 2479 61 2152 46 2499 59 413 2433 61 40 413 41 2478 622 1503 124 2479 59 2021 91 93 2500 61 424 59 2004 2501 61 2502 40 2175 44 648 44 648 41 59 392 40 648 46 2503 40 2501 41 41 123 2500 61 418 2021 91 1501 93 59 2500 91 1500 93 61 418 2504 40 2505 40 2152 44 2492 41 44 1500 41 59 125 2501 61 2502 40 2175 44 648 41 59 392 40 2501 631 424 41 123 2021 2506 61 418 2507 40 2508 40 2152 44 2495 41 44 1500 41 59 392 40 2500 631 424 41 2500 61 418 2021 91 93 123 2500 91 1500 93 44 2506 125 59 360 2500 61 418 2021 91 93 123 2506 125 59 125 2173 2509 61 418 2173 40 40 40 2510 41 2175 46 2511 40 41 46 2512 40 41 41 46 2513 41 59 2514 40 2509 44 2152 41 59 2509 46 2515 61 2516 40 2517 46 2518 41 59 2509 46 2519 61 2399 46 2520 40 2521 46 2522 44 1500 41 59 2509 46 2519 46 2498 61 2478 59 2509 46 2519 46 2499 61 2479 59 2514 40 2509 46 2519 44 2152 41 59 2021 2523 61 2524 40 2525 46 2526 44 2152 41 59 392 40 2527 40 2175 41 46 2528 40 41 41 123 2509 46 2529 61 418 2021 91 93 123 2523 44 2530 40 2152 44 2531 46 2532 41 125 59 125 360 123 2509 46 2533 61 418 2021 91 93 123 2523 125 59 125 2509 46 2534 61 648 46 2007 40 41 59 2509 46 2535 61 424 59 2509 46 2536 61 424 59 2509 46 2537 635 2493 46 2538 59 2509 46 2539 61 2509 46 2540 61 2509 46 2498 61 2152 46 2498 59 2509 46 2541 61 2509 46 2542 61 2509 46 2499 61 2152 46 2499 59 2543 2544 61 418 2543 40 2525 46 2545 44 418 413 91 93 123 2433 44 2433 44 2433 125 41 59 392 40 2500 631 424 41 2544 46 2546 61 418 2021 91 93 91 93 123 424 44 424 44 2500 125 59 2514 40 2544 44 2152 41 59 2509 46 2547 61 418 2548 91 93 123 418 2548 40 418 330 91 93 123 607 125 44 1500 44 2544 44 2549 46 2550 41 125 59 2509 46 2547 91 1500 93 46 2498 61 2478 59 2509 46 2547 91 1500 93 46 2499 61 2479 59 392 40 33 2089 46 2551 40 41 41 2509 46 2547 91 1500 93 46 2546 61 2089 46 2552 40 418 2021 91 1500 93 41 59 2553 46 2554 40 2175 44 2509 46 2547 91 1500 93 41 59 2514 40 2509 46 2547 91 1500 93 44 2152 41 59 2079 60 2555 62 2556 61 418 2557 60 2555 62 40 41 59 604 123 2558 2559 61 418 2558 40 418 330 91 93 123 607 125 44 2433 41 59 2514 40 2559 44 2152 41 59 2560 2561 61 418 2560 40 2478 44 2479 41 59 2514 40 2561 44 2152 41 59 2562 2563 61 418 2562 40 2559 44 2561 44 2564 46 2565 41 59 2514 40 2563 44 2152 41 59 2566 2567 61 418 2566 40 2478 44 2479 41 59 2514 40 2567 44 2152 41 59 2568 2569 61 418 2568 40 2567 44 2478 44 2479 41 59 2514 40 2569 44 2152 41 59 2570 2571 61 418 2570 40 2563 44 2569 44 2478 44 2479 41 59 2514 40 2571 44 2152 41 59 2556 46 2572 40 2571 41 59 125 604 123 2573 2574 61 418 2573 40 418 330 91 93 123 607 125 44 2433 41 59 2514 40 2574 44 2152 41 59 2399 2575 61 2432 40 2175 44 2433 44 2152 44 380 41 59 2514 40 2575 44 2152 41 59 2576 2577 61 418 2576 40 2574 44 2575 41 59 2577 46 2498 61 2478 59 2577 46 2499 61 2479 59 2514 40 2577 44 2152 41 59 2400 2578 61 418 2579 40 2577 44 2580 46 2581 41 59 2514 40 2578 44 2152 41 59 2582 2583 61 418 2582 40 2478 44 2479 41 59 2514 40 2583 44 2152 41 59 2584 2585 61 418 2584 40 2583 44 2478 44 2479 41 59 2514 40 2585 44 2152 41 59 2586 2587 61 418 2586 40 2578 44 2585 44 2478 44 2479 41 59 2514 40 2587 44 2152 41 59 2556 46 2588 40 2587 41 59 125 330 91 93 2589 61 648 46 2007 40 41 59 604 123 392 40 33 2082 46 2551 40 41 606 2497 41 123 2396 2590 61 418 2396 40 2589 44 2478 44 2479 41 59 2590 46 2515 635 2591 46 2592 59 2514 40 2590 44 2152 41 59 2399 2593 61 2432 40 2175 44 2433 44 2152 44 473 41 59 2514 40 2593 44 2152 41 59 2590 46 2175 61 2432 40 2175 44 2433 44 2152 44 473 41 59 2514 40 2590 46 2175 44 2152 41 59 2594 2595 61 418 2596 40 418 330 91 93 123 607 125 44 2433 41 59 2514 40 2595 44 2152 41 59 2590 46 2597 61 2598 40 2595 44 2593 44 2152 41 59 2556 46 2599 40 2590 41 59 125 125 604 123 392 40 2497 41 123 2600 2601 61 418 2600 40 41 59 2601 46 2498 61 2478 59 2601 46 2499 61 2479 59 2514 40 2601 44 2152 41 59 2601 46 2602 61 418 2603 40 2589 44 2433 41 59 2514 40 2601 46 2602 44 2152 41 59 2601 46 2534 61 648 46 2007 40 41 59 2604 2605 61 418 2604 40 2478 44 2479 41 59 2514 40 2605 44 2152 41 59 2606 2607 61 2608 40 2605 44 2609 40 2152 44 2525 46 2545 41 44 2152 41 59 2607 46 2498 61 2478 59 2607 46 2499 61 2479 59 2601 46 2547 61 418 2400 91 93 123 2607 125 59 2400 2610 61 418 2611 40 2601 44 2612 46 2613 41 59 2514 40 2610 44 2152 41 59 2614 2615 61 418 2614 40 2478 44 2479 41 59 2514 40 2615 44 2152 41 59 2616 2617 61 418 2616 40 2615 44 2478 44 2479 41 59 2514 40 2617 44 2152 41 59 2618 2619 61 418 2618 40 2610 44 2617 44 2478 44 2479 41 59 2514 40 2619 44 2152 41 59 2556 46 2620 40 2619 41 59 125 125 604 392 40 2084 41 123 2621 2622 61 418 2621 40 41 59 2622 46 2498 61 2478 59 2622 46 2499 61 2479 59 2514 40 2622 44 2152 41 59 2622 46 2623 61 418 2624 40 2478 44 2479 41 59 2514 40 2622 46 2623 44 2152 41 59 2622 46 2534 61 648 46 2007 40 41 59 2625 2626 61 418 2625 40 418 330 91 93 123 607 125 44 2433 41 59 2514 40 2626 44 2152 41 59 2622 46 2547 61 418 2400 91 93 123 2626 125 59 2400 2627 61 418 2628 40 2622 44 2629 46 2630 41 59 2514 40 2627 44 2152 41 59 2631 2632 61 418 2631 40 2478 44 2479 41 59 2514 40 2632 44 2152 41 59 2633 2634 61 418 2633 40 2632 44 2478 44 2479 41 59 2514 40 2634 44 2152 41 59 2635 2636 61 418 2635 40 2627 44 2634 44 2478 44 2479 41 59 2514 40 2636 44 2152 41 59 2556 46 2637 40 2636 41 59 125 385 40 2080 60 2023 44 2003 46 2081 62 2638 58 2082 41 123 2023 2639 61 2638 46 2640 40 41 59 324 2641 61 2639 46 2642 40 41 614 2643 46 2644 59 2399 2645 61 2646 40 2639 44 2088 41 59 330 91 93 2647 61 2645 46 2648 40 41 59 2400 2649 61 2641 63 2650 40 2639 44 2152 41 58 2651 40 2639 44 2088 44 2152 41 59 2400 2652 61 2641 63 2650 40 2639 44 2152 44 2589 41 58 2651 40 2639 44 2088 44 2152 44 2589 41 59 392 40 2645 46 2653 40 41 614 1500 605 2647 631 424 41 123 392 40 2015 46 2503 40 2525 46 2654 44 2647 41 41 123 2556 46 2655 40 2656 40 2649 44 2652 44 648 46 2007 40 41 44 2152 41 41 59 125 360 392 40 2015 46 2503 40 2525 46 2657 44 2647 41 41 123 2556 46 2658 40 2659 40 2649 44 2652 44 648 46 2007 40 41 44 2152 41 41 59 125 360 392 40 2011 46 2660 40 418 2004 40 2647 41 41 41 123 2661 2662 61 418 2661 40 2649 44 2652 44 2663 46 2664 41 59 2514 40 2662 44 2152 41 59 2665 2666 61 418 2665 40 2478 44 2479 41 59 2514 40 2666 44 2152 41 59 2667 2668 61 418 2667 40 2666 44 2478 44 2479 41 59 2514 40 2668 44 2152 41 59 2669 2670 61 418 2669 40 2662 44 2668 44 2478 44 2479 41 59 2514 40 2670 44 2152 41 59 2556 46 2671 40 2670 41 59 125 360 604 123 604 604 604 330 91 93 2672 61 40 648 43 40 2641 63 648 58 648 41 43 2639 46 2673 40 41 41 46 2007 40 41 59 330 91 93 2674 61 40 648 43 40 2641 63 648 58 648 41 43 2639 46 2673 40 41 41 46 2007 40 41 59 2556 46 2675 40 2397 40 2152 44 2672 44 2676 40 2152 44 2525 46 2545 41 44 2649 41 41 59 2556 46 2675 40 2397 40 2152 44 2674 44 2676 40 2152 44 2525 46 2545 41 44 2652 41 41 59 2677 2678 61 418 2677 40 2672 44 2433 41 59 2514 40 2678 44 2152 41 59 2677 2679 61 418 2677 40 2672 44 2433 41 59 2514 40 2679 44 2152 41 59 2677 2680 61 418 2677 40 2674 44 2433 41 59 2514 40 2680 44 2152 41 59 2677 2681 61 418 2677 40 2674 44 2433 41 59 2514 40 2681 44 2152 41 59 2682 2683 61 418 2682 40 2478 44 2479 41 59 2514 40 2683 44 2152 41 59 2684 2685 61 418 2684 40 2678 44 2683 44 2686 46 2687 41 59 2683 61 418 2682 40 2478 44 2479 41 59 2514 40 2683 44 2152 41 59 2684 2688 61 418 2684 40 2680 44 2683 44 2686 46 2689 41 59 2690 2691 61 418 2690 40 41 59 2691 46 2498 61 2478 59 2691 46 2499 61 2479 59 2514 40 2691 44 2152 41 59 2691 46 2692 61 2679 59 2691 46 2534 61 648 46 2007 40 41 59 2691 46 2547 61 418 2400 91 93 123 2681 125 59 2693 2694 61 418 2693 40 2691 44 2686 46 2695 41 59 2694 46 2498 61 2478 59 2694 46 2499 61 2479 59 2514 40 2694 44 2152 41 59 2696 2697 61 418 2696 40 2685 44 2688 44 2694 41 59 2697 46 2498 61 2478 59 2697 46 2499 61 2479 59 2514 40 2697 44 2152 41 59 2698 2699 61 418 2698 40 2478 44 2479 41 59 2514 40 2699 44 2152 41 59 2700 2701 61 418 2700 40 2699 44 2478 44 2479 41 59 2514 40 2701 44 2152 41 59 2702 2703 61 418 2702 40 2697 44 2701 44 2478 44 2479 41 59 2514 40 2703 44 2152 41 59 2556 46 2675 40 2703 41 59 125 125 360 392 40 2645 46 2653 40 41 62 1500 605 2647 631 424 41 123 2704 2705 61 418 2704 40 41 59 2705 46 2498 61 2478 59 2705 46 2499 61 2479 59 2514 40 2705 44 2152 41 59 2705 46 2706 61 2707 40 2152 44 2525 46 2708 44 2525 46 2709 44 648 46 2007 40 41 41 59 392 40 2645 46 2653 40 41 62 1501 606 33 2011 46 2710 40 418 2004 40 2647 41 41 41 123 2705 46 2534 61 648 46 2007 40 41 59 125 360 123 2705 46 2534 61 648 46 2007 40 41 59 125 2705 46 2547 61 418 2400 91 93 123 2649 44 2652 125 59 2711 2712 61 418 2711 40 2705 44 2713 46 2714 41 59 2712 46 2498 61 2478 59 2712 46 2499 61 2479 59 2514 40 2712 44 2152 41 59 2715 2716 61 418 2715 40 2478 44 2479 41 59 2514 40 2716 44 2152 41 59 2717 2718 61 418 2717 40 2716 44 2478 44 2479 41 59 2514 40 2718 44 2152 41 59 2719 2720 61 418 2719 40 2712 44 2718 44 2478 44 2479 41 59 2514 40 2720 44 2152 41 59 2556 46 2721 40 2720 41 59 125 125 604 123 2722 2723 61 418 2722 40 2478 44 2479 41 59 2514 40 2723 44 2152 41 59 2724 2725 61 418 2724 40 2723 44 2478 44 2479 41 59 2514 40 2725 44 2152 41 59 2556 46 2726 40 2725 41 59 125 2509 46 2556 61 2556 46 2552 40 418 2555 91 1500 93 41 59 450 2509 59 125 439 2173 2727 40 2023 2175 44 2151 2152 44 2079 60 2021 62 2089 41 123 604 404 2478 61 2152 46 2728 59 404 2479 61 2152 46 2729 59 413 2433 61 40 413 41 2478 622 1503 124 2479 59 330 91 93 2730 61 648 46 2007 40 41 59 2173 2731 61 418 2173 40 40 40 2732 41 2175 46 2733 40 41 46 2734 40 41 41 46 2735 41 59 2736 40 2731 44 2152 41 59 2731 46 2737 61 2738 40 2739 46 2740 41 59 2731 46 2741 61 2399 46 2742 40 2743 46 2744 44 1500 41 59 2731 46 2741 46 2728 61 2478 59 2731 46 2741 46 2729 61 2479 59 2736 40 2731 46 2741 44 2152 41 59 2731 46 2745 61 648 46 2007 40 41 59 2731 46 2746 61 424 59 2731 46 2747 61 424 59 2731 46 2748 635 2493 46 2749 59 2731 46 2750 61 2731 46 2751 61 2731 46 2728 61 2152 46 2728 59 2731 46 2752 61 2731 46 2753 61 2731 46 2729 61 2152 46 2729 59 2399 2754 61 418 2755 40 2756 46 2757 44 418 413 91 93 123 2433 44 2433 44 2433 125 41 59 2736 40 2754 44 2152 41 59 2731 46 2758 61 418 2759 91 93 123 418 2759 40 2730 44 1500 44 2754 44 2760 46 2761 41 125 59 2731 46 2758 91 1500 93 46 2728 61 2478 59 2731 46 2758 91 1500 93 46 2729 61 2479 59 392 40 33 2089 46 2762 40 41 41 2731 46 2758 91 1500 93 46 2763 61 2089 46 2764 40 418 2021 91 1500 93 41 59 2765 46 2766 40 2175 44 2731 46 2758 91 1500 93 41 59 2736 40 2731 46 2758 91 1500 93 44 2152 41 59 2767 2768 61 418 2767 40 2730 44 2433 41 59 2736 40 2768 44 2152 41 59 2399 2769 61 2432 40 2175 44 2433 44 2152 44 380 41 59 2736 40 2769 44 2152 41 59 2770 2771 61 418 2770 40 2768 44 2769 41 59 2771 46 2728 61 2478 59 2771 46 2729 61 2479 59 2736 40 2771 44 2152 41 59 2772 2773 61 418 2772 40 2771 44 2478 44 2479 41 59 2736 40 2773 44 2152 41 59 2731 46 2774 61 418 2775 91 93 123 2773 125 59 392 40 2776 40 2175 41 46 2777 40 41 41 2731 46 2763 61 418 2021 91 93 123 2778 40 2152 44 2779 46 2780 41 125 59 450 2731 59 125 439 2781 2782 40 2400 2783 44 2400 2784 44 330 91 93 2785 44 2151 2152 41 123 404 2478 61 2152 46 2786 44 2479 61 2152 46 2787 59 604 2788 2789 61 418 2788 40 41 59 2789 46 2786 61 2478 59 2789 46 2787 61 2479 59 2790 40 2789 44 2152 41 59 2789 46 2791 61 2792 40 2152 44 2793 46 2794 44 2793 46 2795 44 2785 41 59 2789 46 2796 61 648 46 2007 40 41 59 2789 46 2797 61 418 2400 91 93 123 2783 44 2784 125 59 2798 2799 61 2800 40 648 46 2007 40 41 44 2152 41 59 2801 2802 61 418 2801 40 2789 44 2799 44 2803 46 2804 41 59 2802 46 2786 61 2478 59 2802 46 2787 61 2479 59 2790 40 2802 44 2152 41 59 2805 2806 61 418 2805 40 2478 44 2479 41 59 2790 40 2806 44 2152 41 59 2807 2808 61 418 2807 40 2806 44 2478 44 2479 41 59 2790 40 2808 44 2152 41 59 2781 2809 61 418 2781 40 2802 44 2808 44 2478 44 2479 41 59 2790 40 2809 44 2152 41 59 450 2809 59 125 618 439 2400 2810 40 2400 2811 44 2400 2812 44 2151 2152 41 123 404 2478 61 2152 46 2813 44 2479 61 2152 46 2814 59 604 2815 2816 61 2817 40 648 46 2007 40 41 44 2152 41 59 2818 2819 61 418 2818 40 2811 44 2816 44 2820 46 2821 41 59 2822 40 2819 44 2152 41 59 2818 2823 61 418 2818 40 2812 44 2819 44 2820 46 2824 41 59 2822 40 2823 44 2152 41 59 2399 2825 61 2399 46 2826 40 2827 46 2828 44 1500 41 59 2825 46 2813 61 2478 59 2825 46 2814 61 2479 59 2822 40 2825 44 2152 41 59 2829 2830 61 2831 40 2823 44 2825 44 2152 41 59 2830 46 2813 61 2478 59 2830 46 2814 61 2479 59 450 2830 59 125 125 
4756,Java,"@Slf4j
class TransactionAwareTrade implements TransactionAwareTradable {
    private final TradeModel tradeModel;
    private final ArbitrationManager arbitrationManager;
    private final RefundManager refundManager;
    private final BtcWalletService btcWalletService;
    private final PubKeyRing pubKeyRing;

    TransactionAwareTrade(TradeModel tradeModel,
                          ArbitrationManager arbitrationManager,
                          RefundManager refundManager,
                          BtcWalletService btcWalletService,
                          PubKeyRing pubKeyRing) {
        this.tradeModel = tradeModel;
        this.arbitrationManager = arbitrationManager;
        this.refundManager = refundManager;
        this.btcWalletService = btcWalletService;
        this.pubKeyRing = pubKeyRing;
    }

    @Override
    public boolean isRelatedToTransaction(Transaction transaction) {
        Sha256Hash hash = transaction.getTxId();
        String txId = hash.toString();

        boolean tradeRelated = false;
        if (tradeModel instanceof Trade) {
            Trade trade = (Trade) tradeModel;
            boolean isTakerOfferFeeTx = txId.equals(trade.getTakerFeeTxId());
            boolean isOfferFeeTx = isOfferFeeTx(txId);
            boolean isDepositTx = isDepositTx(hash);
            boolean isPayoutTx = isPayoutTx(hash);
            boolean isDisputedPayoutTx = isDisputedPayoutTx(txId);
            boolean isDelayedPayoutTx = transaction.getLockTime() != 0 && isDelayedPayoutTx(txId);
            boolean isRefundPayoutTx = isRefundPayoutTx(trade, txId);
            tradeRelated = isTakerOfferFeeTx ||
                    isOfferFeeTx ||
                    isDepositTx ||
                    isPayoutTx ||
                    isDisputedPayoutTx ||
                    isDelayedPayoutTx ||
                    isRefundPayoutTx;
        }
        boolean isBsqSwapTrade = isBsqSwapTrade(txId);

        return tradeRelated || isBsqSwapTrade;
    }

    private boolean isPayoutTx(Sha256Hash txId) {
        if (isBsqSwapTrade())
            return false;

        Trade trade = (Trade) tradeModel;
        return Optional.ofNullable(trade.getPayoutTx())
                .map(Transaction::getTxId)
                .map(hash -> hash.equals(txId))
                .orElse(false);
    }

    private boolean isDepositTx(Sha256Hash txId) {
        if (isBsqSwapTrade())
            return false;

        Trade trade = (Trade) tradeModel;
        return Optional.ofNullable(trade.getDepositTx())
                .map(Transaction::getTxId)
                .map(hash -> hash.equals(txId))
                .orElse(false);
    }

    private boolean isOfferFeeTx(String txId) {
        if (isBsqSwapTrade())
            return false;

        return Optional.ofNullable(tradeModel.getOffer())
                .map(Offer::getOfferFeePaymentTxId)
                .map(paymentTxId -> paymentTxId.equals(txId))
                .orElse(false);
    }

    private boolean isDisputedPayoutTx(String txId) {
        if (isBsqSwapTrade())
            return false;

        String delegateId = tradeModel.getId();
        ObservableList<Dispute> disputes = arbitrationManager.getDisputesAsObservableList();

        boolean isAnyDisputeRelatedToThis = arbitrationManager.getDisputedTradeIds().contains(tradeModel.getId());

        return isAnyDisputeRelatedToThis && disputes.stream()
                .anyMatch(dispute -> {
                    String disputePayoutTxId = dispute.getDisputePayoutTxId();
                    boolean isDisputePayoutTx = txId.equals(disputePayoutTxId);

                    String disputeTradeId = dispute.getTradeId();
                    boolean isDisputeRelatedToThis = delegateId.equals(disputeTradeId);

                    return isDisputePayoutTx && isDisputeRelatedToThis;
                });
    }

    boolean isDelayedPayoutTx(String txId) {
        if (isBsqSwapTrade())
            return false;

        Transaction transaction = btcWalletService.getTransaction(txId);
        if (transaction == null)
            return false;

        if (transaction.getLockTime() == 0)
            return false;

        if (transaction.getInputs() == null)
            return false;

        return transaction.getInputs().stream()
                .anyMatch(input -> {
                    TransactionOutput connectedOutput = input.getConnectedOutput();
                    if (connectedOutput == null) {
                        return false;
                    }
                    Transaction parentTransaction = connectedOutput.getParentTransaction();
                    if (parentTransaction == null) {
                        return false;
                    }
                    return isDepositTx(parentTransaction.getTxId());
                });
    }

    private boolean isRefundPayoutTx(Trade trade, String txId) {
        if (isBsqSwapTrade())
            return false;

        String tradeId = tradeModel.getId();
        ObservableList<Dispute> disputes = refundManager.getDisputesAsObservableList();

        boolean isAnyDisputeRelatedToThis = refundManager.getDisputedTradeIds().contains(tradeId);

        if (isAnyDisputeRelatedToThis) {
            Transaction tx = btcWalletService.getTransaction(txId);
            if (tx != null) {
                for (TransactionOutput txo : tx.getOutputs()) {
                    if (btcWalletService.isTransactionOutputMine(txo)) {
                        try {
                            Address receiverAddress = txo.getScriptPubKey().getToAddress(btcWalletService.getParams());
                            Contract contract = checkNotNull(trade.getContract());
                            String myPayoutAddressString = contract.isMyRoleBuyer(pubKeyRing) ?
                                    contract.getBuyerPayoutAddressString() :
                                    contract.getSellerPayoutAddressString();
                            if (receiverAddress != null && myPayoutAddressString.equals(receiverAddress.toString())) {
                                return true;
                            }
                        } catch (RuntimeException ignore) {
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean isBsqSwapTrade() {
        return tradeModel instanceof BsqSwapTrade;
    }

    private boolean isBsqSwapTrade(String txId) {
        if (isBsqSwapTrade()) {
            return (txId.equals(((BsqSwapTrade) tradeModel).getTxId()));
        }
        return false;
    }

    @Override
    public Tradable asTradable() {
        return tradeModel;
    }
}",1,64 2000 334 2001 395 2002 123 437 381 2003 2004 59 437 381 2005 2006 59 437 381 2007 2008 59 437 381 2009 2010 59 437 381 2011 2012 59 2001 40 2003 2004 44 2005 2006 44 2007 2008 44 2009 2010 44 2011 2012 41 123 467 46 2004 61 2004 59 467 46 2006 61 2006 59 467 46 2008 61 2008 59 467 46 2010 61 2010 59 467 46 2012 61 2012 59 125 64 2013 439 324 2014 40 2015 2016 41 123 2017 2018 61 2016 46 2019 40 41 59 2020 2021 61 2018 46 2022 40 41 59 324 2023 61 380 59 392 40 2004 402 2024 41 123 2024 2025 61 40 2024 41 2004 59 324 2026 61 2021 46 2027 40 2025 46 2028 40 41 41 59 324 2029 61 2029 40 2021 41 59 324 2030 61 2030 40 2018 41 59 324 2031 61 2031 40 2018 41 59 324 2032 61 2032 40 2021 41 59 324 2033 61 2016 46 2034 40 41 631 1500 605 2033 40 2021 41 59 324 2035 61 2035 40 2025 44 2021 41 59 2023 61 2026 606 2029 606 2030 606 2031 606 2032 606 2033 606 2035 59 125 324 2036 61 2036 40 2021 41 59 450 2023 606 2036 59 125 437 324 2037 40 2038 2039 41 123 392 40 2040 40 41 41 450 380 59 2041 2042 61 40 2041 41 2004 59 450 2043 46 2044 40 2042 46 2045 40 41 41 46 2046 40 2015 58 58 2047 41 46 2046 40 2048 45 62 2048 46 2049 40 2039 41 41 46 2050 40 380 41 59 125 437 324 2051 40 2038 2039 41 123 392 40 2052 40 41 41 450 380 59 2053 2054 61 40 2053 41 2004 59 450 2055 46 2056 40 2054 46 2057 40 41 41 46 2058 40 2015 58 58 2059 41 46 2058 40 2060 45 62 2060 46 2061 40 2039 41 41 46 2062 40 380 41 59 125 437 324 2063 40 2064 2039 41 123 392 40 2065 40 41 41 450 380 59 450 2066 46 2067 40 2004 46 2068 40 41 41 46 2069 40 2070 58 58 2071 41 46 2069 40 2072 45 62 2072 46 2073 40 2039 41 41 46 2074 40 380 41 59 125 437 324 2075 40 2064 2039 41 123 392 40 2076 40 41 41 450 380 59 2064 2077 61 2004 46 2078 40 41 59 2079 60 2080 62 2081 61 2006 46 2082 40 41 59 324 2083 61 2006 46 2084 40 41 46 2085 40 2004 46 2078 40 41 41 59 450 2083 605 2081 46 2086 40 41 46 2087 40 2088 45 62 123 2064 2089 61 2088 46 2090 40 41 59 324 2091 61 2039 46 2092 40 2089 41 59 2064 2093 61 2088 46 2094 40 41 59 324 2095 61 2077 46 2092 40 2093 41 59 450 2091 605 2095 59 125 41 59 125 324 2096 40 2064 2039 41 123 392 40 2097 40 41 41 450 380 59 2015 2016 61 2010 46 2098 40 2039 41 59 392 40 2016 614 424 41 450 380 59 392 40 2016 46 2099 40 41 614 1500 41 450 380 59 392 40 2016 46 2100 40 41 614 424 41 450 380 59 450 2016 46 2100 40 41 46 2101 40 41 46 2102 40 2103 45 62 123 2104 2105 61 2103 46 2106 40 41 59 392 40 2105 614 424 41 123 450 380 59 125 2015 2107 61 2105 46 2108 40 41 59 392 40 2107 614 424 41 123 450 380 59 125 450 2051 40 2107 46 2109 40 41 41 59 125 41 59 125 437 324 2110 40 2111 2112 44 2064 2039 41 123 392 40 2113 40 41 41 450 380 59 2064 2114 61 2004 46 2115 40 41 59 2116 60 2117 62 2118 61 2008 46 2119 40 41 59 324 2120 61 2008 46 2121 40 41 46 2122 40 2114 41 59 392 40 2120 41 123 2015 2123 61 2010 46 2124 40 2039 41 59 392 40 2123 631 424 41 123 385 40 2125 2126 58 2123 46 2127 40 41 41 123 392 40 2010 46 2128 40 2126 41 41 123 474 123 2129 2130 61 2126 46 2131 40 41 46 2132 40 2010 46 2133 40 41 41 59 2134 2135 61 2136 40 2112 46 2137 40 41 41 59 2064 2138 61 2135 46 2139 40 2012 41 63 2135 46 2140 40 41 58 2135 46 2141 40 41 59 392 40 2130 631 424 605 2138 46 2142 40 2130 46 2143 40 41 41 41 123 450 473 59 125 125 329 40 2144 2145 41 123 125 125 125 125 125 450 380 59 125 437 324 2146 40 41 123 450 2004 402 2147 59 125 437 324 2146 40 2064 2039 41 123 392 40 2146 40 41 41 123 450 40 2039 46 2148 40 40 40 2149 41 2004 41 46 2150 40 41 41 41 59 125 450 380 59 125 64 2013 439 2151 2152 40 41 123 450 2004 59 125 125 
3639,Java,"@FxmlView
public class ProofOfBurnView extends ActivatableView<GridPane, Void> implements BsqBalanceListener {
    private final ProofOfBurnService proofOfBurnService;
    private final MyProofOfBurnListService myProofOfBurnListService;
    private final Preferences preferences;
    private final CoinFormatter btcFormatter;
    private final BsqFormatter bsqFormatter;
    private final BsqWalletService bsqWalletService;
    private final BsqValidator bsqValidator;

    private InputTextField amountInputTextField, preImageTextField;
    private TextField hashTextField;
    private Button burnButton;
    private TableView<MyProofOfBurnListItem> myItemsTableView;
    private TableView<ProofOfBurnListItem> allTxsTableView;

    private final ObservableList<MyProofOfBurnListItem> myItemsObservableList = FXCollections.observableArrayList();
    private final SortedList<MyProofOfBurnListItem> myItemsSortedList = new SortedList<>(myItemsObservableList);

    private final ObservableList<ProofOfBurnListItem> allItemsObservableList = FXCollections.observableArrayList();
    private final SortedList<ProofOfBurnListItem> allItemsSortedList = new SortedList<>(allItemsObservableList);

    private int gridRow = 0;

    private ChangeListener<Boolean> amountFocusOutListener, preImageFocusOutListener;
    private ChangeListener<String> amountInputTextFieldListener, preImageInputTextFieldListener;
    private InvalidationListener updateListener;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    private ProofOfBurnView(BsqFormatter bsqFormatter,
                            BsqWalletService bsqWalletService,
                            BsqValidator bsqValidator,
                            ProofOfBurnService proofOfBurnService,
                            MyProofOfBurnListService myProofOfBurnListService,
                            Preferences preferences,
                            @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter btcFormatter) {
        this.bsqFormatter = bsqFormatter;
        this.bsqWalletService = bsqWalletService;
        this.bsqValidator = bsqValidator;
        this.proofOfBurnService = proofOfBurnService;
        this.myProofOfBurnListService = myProofOfBurnListService;
        this.preferences = preferences;
        this.btcFormatter = btcFormatter;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void initialize() {
        addTitledGroupBg(root, gridRow, 4, Res.get(""dao.proofOfBurn.header""));
        amountInputTextField = addInputTextField(root, ++gridRow, Res.get(""dao.proofOfBurn.amount""), Layout.FIRST_ROW_DISTANCE);
        preImageTextField = addInputTextField(root, ++gridRow, Res.get(""dao.proofOfBurn.preImage""));
        hashTextField = addTopLabelTextField(root, ++gridRow, Res.get(""dao.proofOfBurn.hash"")).second;
        burnButton = addButtonAfterGroup(root, ++gridRow, Res.get(""dao.proofOfBurn.burn""));

        myItemsTableView = FormBuilder.addTableViewWithHeader(root, ++gridRow, Res.get(""dao.proofOfBurn.myItems""), 30);
        createColumnsForMyItems();
        myItemsTableView.setItems(myItemsSortedList);

        allTxsTableView = FormBuilder.addTableViewWithHeader(root, ++gridRow, Res.get(""dao.proofOfBurn.allTxs""), 30, ""last"");
        createColumnsForAllTxs();
        allTxsTableView.setItems(allItemsSortedList);

        createListeners();
    }

    @Override
    protected void activate() {
        amountInputTextField.textProperty().addListener(amountInputTextFieldListener);
        amountInputTextField.focusedProperty().addListener(amountFocusOutListener);

        preImageTextField.textProperty().addListener(preImageInputTextFieldListener);
        preImageTextField.focusedProperty().addListener(preImageFocusOutListener);

        allItemsSortedList.comparatorProperty().bind(allTxsTableView.comparatorProperty());

        proofOfBurnService.getUpdateFlag().addListener(updateListener);
        bsqWalletService.addBsqBalanceListener(this);
        onUpdateAvailableBalance(bsqWalletService.getAvailableBalance());

        burnButton.setOnAction((event) -> {
            Coin amount = getAmountFee();
            try {
                String preImageAsString = preImageTextField.getText();
                Transaction transaction = proofOfBurnService.burn(preImageAsString, amount.value);
                Coin miningFee = transaction.getFee();
                int txVsize = transaction.getVsize();

                if (!DevEnv.isDevMode()) {
                    GUIUtil.showBsqFeeInfoPopup(amount, miningFee, txVsize, bsqFormatter, btcFormatter,
                            Res.get(""dao.proofOfBurn.header""), () -> doPublishFeeTx(transaction, preImageAsString));
                } else {
                    doPublishFeeTx(transaction, preImageAsString);
                }
            } catch (InsufficientMoneyException | TxException e) {
                e.printStackTrace();
                new Popup().error(e.toString()).show();
            }
        });

        amountInputTextField.setValidator(bsqValidator);
        preImageTextField.setValidator(new InputValidator());

        updateList();
        GUIUtil.setFitToRowsForTableView(myItemsTableView, 41, 28, 4, 6);
        GUIUtil.setFitToRowsForTableView(allTxsTableView, 41, 28, 2, 10);
        updateButtonState();
    }

    @Override
    protected void deactivate() {
        amountInputTextField.textProperty().removeListener(amountInputTextFieldListener);
        amountInputTextField.focusedProperty().removeListener(amountFocusOutListener);

        amountInputTextField.textProperty().removeListener(amountInputTextFieldListener);
        amountInputTextField.focusedProperty().removeListener(amountFocusOutListener);

        allItemsSortedList.comparatorProperty().unbind();

        proofOfBurnService.getUpdateFlag().removeListener(updateListener);
        bsqWalletService.removeBsqBalanceListener(this);

        burnButton.setOnAction(null);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // BsqBalanceListener
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onUpdateBalances(Coin availableBalance,
                                 Coin availableNonBsqBalance,
                                 Coin unverifiedBalance,
                                 Coin unconfirmedChangeBalance,
                                 Coin lockedForVotingBalance,
                                 Coin lockupBondsBalance,
                                 Coin unlockingBondsBalance) {
        onUpdateAvailableBalance(availableBalance);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void createListeners() {
        amountFocusOutListener = (observable, oldValue, newValue) -> {
            if (!newValue) {
                updateButtonState();
            }
        };

        amountInputTextFieldListener = (observable, oldValue, newValue) -> {
            updateButtonState();
        };
        preImageFocusOutListener = (observable, oldValue, newValue) -> {
            if (!newValue) {
                updateButtonState();
            }
        };

        preImageInputTextFieldListener = (observable, oldValue, newValue) -> {
            hashTextField.setText(proofOfBurnService.getHashAsString(newValue));
            updateButtonState();
        };

        updateListener = observable -> updateList();
    }

    private void onUpdateAvailableBalance(Coin availableBalance) {
        bsqValidator.setAvailableBalance(availableBalance);
        updateButtonState();
    }

    private void updateList() {
        myItemsObservableList.setAll(myProofOfBurnListService.getMyProofOfBurnList().stream()
                .map(myProofOfBurn -> new MyProofOfBurnListItem(myProofOfBurn, proofOfBurnService, bsqFormatter))
                .sorted(Comparator.comparing(MyProofOfBurnListItem::getDate).reversed())
                .collect(Collectors.toList()));
        GUIUtil.setFitToRowsForTableView(myItemsTableView, 41, 28, 4, 6);

        allItemsObservableList.setAll(proofOfBurnService.getProofOfBurnTxList().stream()
                .map(tx -> new ProofOfBurnListItem(tx, proofOfBurnService, bsqFormatter))
                .collect(Collectors.toList()));
        GUIUtil.setFitToRowsForTableView(allTxsTableView, 41, 28, 2, 10);
    }

    private void updateButtonState() {
        boolean isValid = bsqValidator.validate(amountInputTextField.getText()).isValid &&
                preImageTextField.validate();
        burnButton.setDisable(!isValid);
    }

    private Coin getAmountFee() {
        return ParsingUtils.parseToCoin(amountInputTextField.getText(), bsqFormatter);
    }

    private void doPublishFeeTx(Transaction transaction, String preImageAsString) {
        proofOfBurnService.publishTransaction(transaction, preImageAsString,
                () -> {
                    if (!DevEnv.isDevMode())
                        new Popup().confirmation(Res.get(""dao.tx.published.success"")).show();
                },
                errorMessage -> new Popup().warning(errorMessage).show());

        amountInputTextField.clear();
        preImageTextField.clear();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Table columns
    ///////////////////////////////////////////////////////////////////////////////////////////


    private void createColumnsForMyItems() {
        TableColumn<MyProofOfBurnListItem, MyProofOfBurnListItem> column;

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.amount""));
        column.setMinWidth(80);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.getStyleClass().add(""first-column"");
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmountAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });
        myItemsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(MyProofOfBurnListItem::getAmount));

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.date""));
        column.setMinWidth(120);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getDateAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });
        myItemsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(MyProofOfBurnListItem::getDate));

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.preImage""));
        column.setMinWidth(80);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPreImage());
                        } else
                            setText("""");
                    }
                };
            }
        });
        myItemsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(MyProofOfBurnListItem::getPreImage));

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.hash""));
        column.setMinWidth(80);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getHashAsHex());
                        } else
                            setText("""");
                    }
                };
            }
        });
        myItemsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(MyProofOfBurnListItem::getHashAsHex));

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.txs""));
        column.setCellValueFactory(item -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setMinWidth(80);
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                            MyProofOfBurnListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(item.getTxId(), preferences));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });
        myItemsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(MyProofOfBurnListItem::getTxId));

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.pubKey""));
        column.setMinWidth(80);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                    MyProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPubKey());
                        } else
                            setText("""");
                    }
                };
            }
        });
        myItemsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(MyProofOfBurnListItem::getPubKey));

        column = new AutoTooltipTableColumn<>("""");
        column.setCellValueFactory(item -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setMinWidth(60);
        column.getStyleClass().add(""last-column"");
        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<MyProofOfBurnListItem, MyProofOfBurnListItem> call(TableColumn<MyProofOfBurnListItem,
                            MyProofOfBurnListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final MyProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = new AutoTooltipButton(Res.get(""dao.proofOfBurn.sign""));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(e -> new ProofOfBurnSignatureWindow(proofOfBurnService, item.getTxId()).show());
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });
        myItemsTableView.getColumns().add(column);
        column.setSortable(false);
    }

    private void createColumnsForAllTxs() {
        TableColumn<ProofOfBurnListItem, ProofOfBurnListItem> column;

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.amount""));
        column.setMinWidth(80);
        column.getStyleClass().add(""first-column"");
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                    ProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getAmountAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });
        allTxsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(ProofOfBurnListItem::getAmount));

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.date""));
        column.setMinWidth(120);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                    ProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getDateAsString());
                        } else
                            setText("""");
                    }
                };
            }
        });
        allTxsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(ProofOfBurnListItem::getDate));


        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.hash""));
        column.setMinWidth(80);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                    ProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getHashAsHex());
                        } else
                            setText("""");
                    }
                };
            }
        });
        allTxsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(ProofOfBurnListItem::getHashAsHex));

        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.txs""));
        column.setCellValueFactory(item -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setMinWidth(80);
        column.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                            ProofOfBurnListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                //noinspection Duplicates
                                if (item != null && !empty) {
                                    String transactionId = item.getTxId();
                                    hyperlinkWithIcon = new ExternalHyperlink(transactionId);
                                    hyperlinkWithIcon.setOnAction(event -> GUIUtil.openTxInBsqBlockExplorer(item.getTxId(), preferences));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForTx"", transactionId)));
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });
        allTxsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(ProofOfBurnListItem::getTxId));


        column = new AutoTooltipTableColumn<>(Res.get(""dao.proofOfBurn.pubKey""));
        column.setMinWidth(80);
        column.setCellValueFactory((item) -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setCellFactory(new Callback<>() {
            @Override
            public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                    ProofOfBurnListItem> column) {
                return new TableCell<>() {
                    @Override
                    public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && !empty) {
                            setText(item.getPubKey());
                        } else
                            setText("""");
                    }
                };
            }
        });
        allTxsTableView.getColumns().add(column);
        column.setComparator(Comparator.comparing(ProofOfBurnListItem::getPubKey));


        column = new AutoTooltipTableColumn<>("""");
        column.setCellValueFactory(item -> new ReadOnlyObjectWrapper<>(item.getValue()));
        column.setMinWidth(80);
        column.getStyleClass().add(""last-column"");
        column.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<ProofOfBurnListItem, ProofOfBurnListItem> call(TableColumn<ProofOfBurnListItem,
                            ProofOfBurnListItem> column) {
                        return new TableCell<>() {
                            Button button;

                            @Override
                            public void updateItem(final ProofOfBurnListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    if (button == null) {
                                        button = new AutoTooltipButton(Res.get(""dao.proofOfBurn.verify""));
                                        setGraphic(button);
                                    }
                                    button.setOnAction(e -> new ProofOfBurnVerificationWindow(proofOfBurnService, item.getTxId()).show());
                                } else {
                                    setGraphic(null);
                                    if (button != null) {
                                        button.setOnAction(null);
                                        button = null;
                                    }
                                }
                            }
                        };
                    }
                });
        allTxsTableView.getColumns().add(column);
        column.setSortable(false);
    }
}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 395 2005 123 437 381 2006 2007 59 437 381 2008 2009 59 437 381 2010 2011 59 437 381 2012 2013 59 437 381 2014 2015 59 437 381 2016 2017 59 437 381 2018 2019 59 437 2020 2021 44 2022 59 437 2023 2024 59 437 2025 2026 59 437 2027 60 2028 62 2029 59 437 2027 60 2030 62 2031 59 437 381 2032 60 2028 62 2033 61 2034 46 2035 40 41 59 437 381 2036 60 2028 62 2037 61 418 2036 60 62 40 2033 41 59 437 381 2032 60 2030 62 2038 61 2034 46 2035 40 41 59 437 381 2036 60 2030 62 2039 61 418 2036 60 62 40 2038 41 59 437 404 2040 61 1500 59 437 2041 60 2042 62 2043 44 2044 59 437 2041 60 2045 62 2046 44 2047 59 437 2048 2049 59 621 621 621 64 2050 437 2001 40 2014 2015 44 2016 2017 44 2018 2019 44 2006 2007 44 2008 2009 44 2010 2011 44 64 2051 40 2052 46 2053 41 2012 2013 41 123 467 46 2015 61 2015 59 467 46 2017 61 2017 59 467 46 2019 61 2019 59 467 46 2007 61 2007 59 467 46 2009 61 2009 59 467 46 2011 61 2011 59 467 46 2013 61 2013 59 125 621 621 621 64 2054 439 492 2055 40 41 123 2056 40 2057 44 2040 44 1502 44 2058 46 2059 40 648 41 41 59 2021 61 2060 40 2057 44 637 2040 44 2058 46 2059 40 648 41 44 2061 46 2062 41 59 2022 61 2060 40 2057 44 637 2040 44 2058 46 2059 40 648 41 41 59 2024 61 2063 40 2057 44 637 2040 44 2058 46 2059 40 648 41 41 46 2064 59 2026 61 2065 40 2057 44 637 2040 44 2058 46 2059 40 648 41 41 59 2029 61 2066 46 2067 40 2057 44 637 2040 44 2058 46 2059 40 648 41 44 1503 41 59 2068 40 41 59 2029 46 2069 40 2037 41 59 2031 61 2066 46 2067 40 2057 44 637 2040 44 2058 46 2059 40 648 41 44 1503 44 648 41 59 2070 40 41 59 2031 46 2069 40 2039 41 59 2071 40 41 59 125 64 2054 438 492 2072 40 41 123 2021 46 2073 40 41 46 2074 40 2046 41 59 2021 46 2075 40 41 46 2074 40 2043 41 59 2022 46 2073 40 41 46 2074 40 2047 41 59 2022 46 2075 40 41 46 2074 40 2044 41 59 2039 46 2076 40 41 46 2077 40 2031 46 2076 40 41 41 59 2007 46 2078 40 41 46 2074 40 2049 41 59 2017 46 2079 40 467 41 59 2080 40 2017 46 2081 40 41 41 59 2026 46 2082 40 40 373 41 45 62 123 2083 2084 61 2085 40 41 59 474 123 2045 2086 61 2022 46 2087 40 41 59 2088 2089 61 2007 46 2090 40 2086 44 2084 46 2091 41 59 2083 2092 61 2089 46 2093 40 41 59 404 2094 61 2089 46 2095 40 41 59 392 40 33 2096 46 2097 40 41 41 123 2098 46 2099 40 2084 44 2092 44 2094 44 2015 44 2013 44 2100 46 2101 40 648 41 44 40 41 45 62 2102 40 2089 44 2086 41 41 59 125 360 123 2103 40 2089 44 2086 41 59 125 125 329 40 2104 124 2105 2106 41 123 2106 46 2107 40 41 59 418 2108 40 41 46 371 40 2106 46 2109 40 41 41 46 2110 40 41 59 125 125 41 59 2021 46 2111 40 2019 41 59 2022 46 2111 40 418 2112 40 41 41 59 2113 40 41 59 2114 46 2115 40 2029 44 1503 44 1503 44 1502 44 1502 41 59 2114 46 2115 40 2031 44 1503 44 1503 44 1502 44 1502 41 59 2116 40 41 59 125 64 2054 438 492 2117 40 41 123 2021 46 2118 40 41 46 2119 40 2046 41 59 2021 46 2120 40 41 46 2119 40 2043 41 59 2021 46 2118 40 41 46 2119 40 2046 41 59 2021 46 2120 40 41 46 2119 40 2043 41 59 2039 46 2121 40 41 46 2122 40 41 59 2007 46 2123 40 41 46 2119 40 2049 41 59 2017 46 2124 40 467 41 59 2026 46 2125 40 424 41 59 125 621 621 621 64 2054 439 492 2126 40 2127 2128 44 2127 2129 44 2127 2130 44 2127 2131 44 2127 2132 44 2127 2133 44 2127 2134 41 123 2135 40 2128 41 59 125 621 621 621 437 492 2136 40 41 123 2043 61 40 2137 44 2138 44 2139 41 45 62 123 392 40 33 2139 41 123 2140 40 41 59 125 125 59 2046 61 40 2137 44 2138 44 2139 41 45 62 123 2141 40 41 59 125 59 2044 61 40 2137 44 2138 44 2139 41 45 62 123 392 40 33 2139 41 123 2142 40 41 59 125 125 59 2047 61 40 2137 44 2138 44 2139 41 45 62 123 2024 46 2143 40 2007 46 2144 40 2139 41 41 59 2145 40 41 59 125 59 2049 61 2137 45 62 2146 40 41 59 125 437 492 2147 40 2127 2128 41 123 2019 46 2148 40 2128 41 59 2149 40 41 59 125 437 492 2150 40 41 123 2033 46 2151 40 2009 46 2152 40 41 46 2153 40 41 46 2154 40 2155 45 62 418 2028 40 2155 44 2007 44 2015 41 41 46 2156 40 2157 46 2158 40 2028 58 58 2159 41 46 2160 40 41 41 46 2161 40 2162 46 2163 40 41 41 41 59 2164 46 2165 40 2029 44 1503 44 1503 44 1502 44 1502 41 59 2038 46 2151 40 2007 46 2166 40 41 46 2153 40 41 46 2154 40 2167 45 62 418 2030 40 2167 44 2007 44 2015 41 41 46 2161 40 2162 46 2163 40 41 41 41 59 2164 46 2165 40 2031 44 1503 44 1503 44 1502 44 1502 41 59 125 437 492 2168 40 41 123 324 2169 61 2019 46 2170 40 2021 46 2171 40 41 41 46 2169 605 2022 46 2170 40 41 59 2026 46 2172 40 33 2169 41 59 125 437 2127 2173 40 41 123 450 2174 46 2175 40 2021 46 2176 40 41 44 2015 41 59 125 437 492 2177 40 2178 2179 44 2045 2180 41 123 2007 46 2181 40 2179 44 2180 44 40 41 45 62 123 392 40 33 2182 46 2183 40 41 41 418 2184 40 41 46 2185 40 2186 46 2187 40 648 41 41 46 2188 40 41 59 125 44 2189 45 62 418 2190 40 41 46 494 40 2189 41 46 2191 40 41 41 59 2021 46 2192 40 41 59 2022 46 2192 40 41 59 125 621 621 621 437 492 2193 40 41 123 2194 60 2028 44 2028 62 2195 59 2195 61 418 2196 60 62 40 2197 46 2198 40 648 41 41 59 2195 46 2199 40 1503 41 59 2195 46 2200 40 40 2201 41 45 62 418 2202 60 62 40 2201 46 2203 40 41 41 41 59 2195 46 2204 40 41 46 2205 40 648 41 59 2195 46 2206 40 418 2207 60 62 40 41 123 64 2054 439 2208 60 2028 44 2028 62 2209 40 2194 60 2028 44 2028 62 2195 41 123 450 418 2208 60 62 40 41 123 64 2054 439 492 2210 40 381 2028 2201 44 324 362 41 123 463 46 2210 40 2201 44 362 41 59 392 40 2201 631 424 605 33 362 41 123 2211 40 2201 46 2212 40 41 41 59 125 360 2213 40 648 41 59 125 125 59 125 125 41 59 2029 46 2214 40 41 46 2205 40 2195 41 59 2195 46 2215 40 2216 46 2217 40 2028 58 58 2218 41 41 59 2195 61 418 2196 60 62 40 2197 46 2198 40 648 41 41 59 2195 46 2199 40 1504 41 59 2195 46 2200 40 40 2201 41 45 62 418 2202 60 62 40 2201 46 2203 40 41 41 41 59 2195 46 2206 40 418 2207 60 62 40 41 123 64 2054 439 2219 60 2028 44 2028 62 2220 40 2194 60 2028 44 2028 62 2195 41 123 450 418 2219 60 62 40 41 123 64 2054 439 492 2221 40 381 2028 2201 44 324 362 41 123 463 46 2221 40 2201 44 362 41 59 392 40 2201 631 424 605 33 362 41 123 2222 40 2201 46 2223 40 41 41 59 125 360 2224 40 648 41 59 125 125 59 125 125 41 59 2029 46 2214 40 41 46 2205 40 2195 41 59 2195 46 2215 40 2216 46 2217 40 2028 58 58 2225 41 41 59 2195 61 418 2196 60 62 40 2197 46 2198 40 648 41 41 59 2195 46 2199 40 1503 41 59 2195 46 2200 40 40 2201 41 45 62 418 2202 60 62 40 2201 46 2203 40 41 41 41 59 2195 46 2206 40 418 2207 60 62 40 41 123 64 2054 439 2226 60 2028 44 2028 62 2227 40 2194 60 2028 44 2028 62 2195 41 123 450 418 2226 60 62 40 41 123 64 2054 439 492 2228 40 381 2028 2201 44 324 362 41 123 463 46 2228 40 2201 44 362 41 59 392 40 2201 631 424 605 33 362 41 123 2229 40 2201 46 2230 40 41 41 59 125 360 2231 40 648 41 59 125 125 59 125 125 41 59 2029 46 2214 40 41 46 2205 40 2195 41 59 2195 46 2215 40 2216 46 2217 40 2028 58 58 2232 41 41 59 2195 61 418 2196 60 62 40 2197 46 2198 40 648 41 41 59 2195 46 2199 40 1503 41 59 2195 46 2200 40 40 2201 41 45 62 418 2202 60 62 40 2201 46 2203 40 41 41 41 59 2195 46 2206 40 418 2207 60 62 40 41 123 64 2054 439 2233 60 2028 44 2028 62 2234 40 2194 60 2028 44 2028 62 2195 41 123 450 418 2233 60 62 40 41 123 64 2054 439 492 2235 40 381 2028 2201 44 324 362 41 123 463 46 2235 40 2201 44 362 41 59 392 40 2201 631 424 605 33 362 41 123 2236 40 2201 46 2237 40 41 41 59 125 360 2238 40 648 41 59 125 125 59 125 125 41 59 2029 46 2214 40 41 46 2205 40 2195 41 59 2195 46 2215 40 2216 46 2217 40 2028 58 58 2239 41 41 59 2195 61 418 2196 60 62 40 2197 46 2198 40 648 41 41 59 2195 46 2200 40 2201 45 62 418 2202 60 62 40 2201 46 2203 40 41 41 41 59 2195 46 2199 40 1503 41 59 2195 46 2206 40 418 2207 60 62 40 41 123 64 2054 439 2240 60 2028 44 2028 62 2241 40 2194 60 2028 44 2028 62 2195 41 123 450 418 2240 60 62 40 41 123 437 2242 2243 59 64 2054 439 492 2244 40 381 2028 2201 44 324 362 41 123 463 46 2244 40 2201 44 362 41 59 621 392 40 2201 631 424 605 33 362 41 123 2045 2245 61 2201 46 2246 40 41 59 2243 61 418 2247 40 2245 41 59 2243 46 2248 40 373 45 62 2249 46 2250 40 2201 46 2246 40 41 44 2011 41 41 59 2243 46 2251 40 418 2252 40 2197 46 2198 40 648 44 2245 41 41 41 59 2253 40 2243 41 59 125 360 123 2254 40 424 41 59 392 40 2243 631 424 41 2243 46 2255 40 424 41 59 125 125 125 59 125 125 41 59 2029 46 2214 40 41 46 2205 40 2195 41 59 2195 46 2215 40 2216 46 2217 40 2028 58 58 2256 41 41 59 2195 61 418 2196 60 62 40 2197 46 2198 40 648 41 41 59 2195 46 2199 40 1503 41 59 2195 46 2200 40 40 2201 41 45 62 418 2202 60 62 40 2201 46 2203 40 41 41 41 59 2195 46 2206 40 418 2207 60 62 40 41 123 64 2054 439 2257 60 2028 44 2028 62 2258 40 2194 60 2028 44 2028 62 2195 41 123 450 418 2257 60 62 40 41 123 64 2054 439 492 2259 40 381 2028 2201 44 324 362 41 123 463 46 2259 40 2201 44 362 41 59 392 40 2201 631 424 605 33 362 41 123 2260 40 2201 46 2261 40 41 41 59 125 360 2262 40 648 41 59 125 125 59 125 125 41 59 2029 46 2214 40 41 46 2205 40 2195 41 59 2195 46 2215 40 2216 46 2217 40 2028 58 58 2263 41 41 59 2195 61 418 2196 60 62 40 648 41 59 2195 46 2200 40 2201 45 62 418 2202 60 62 40 2201 46 2203 40 41 41 41 59 2195 46 2199 40 1503 41 59 2195 46 2204 40 41 46 2205 40 648 41 59 2195 46 2206 40 418 2207 60 62 40 41 123 64 2054 439 2264 60 2028 44 2028 62 2265 40 2194 60 2028 44 2028 62 2195 41 123 450 418 2264 60 62 40 41 123 2025 2266 59 64 2054 439 492 2267 40 381 2028 2201 44 324 362 41 123 463 46 2267 40 2201 44 362 41 59 392 40 2201 631 424 605 33 362 41 123 392 40 2266 614 424 41 123 2266 61 418 2268 40 2197 46 2198 40 648 41 41 59 2269 40 2266 41 59 125 2266 46 2270 40 2271 45 62 418 2272 40 2007 44 2201 46 2256 40 41 41 46 2273 40 41 41 59 125 360 123 2274 40 424 41 59 392 40 2266 631 424 41 123 2266 46 2275 40 424 41 59 2266 61 424 59 125 125 125 125 59 125 125 41 59 2029 46 2214 40 41 46 2205 40 2195 41 59 2195 46 2276 40 380 41 59 125 437 492 2277 40 41 123 2278 60 2030 44 2030 62 2279 59 2279 61 418 2280 60 62 40 2281 46 2282 40 648 41 41 59 2279 46 2283 40 1503 41 59 2279 46 2284 40 41 46 2285 40 648 41 59 2279 46 2286 40 40 2287 41 45 62 418 2288 60 62 40 2287 46 2289 40 41 41 41 59 2279 46 2290 40 418 2291 60 62 40 41 123 64 2054 439 2292 60 2030 44 2030 62 2293 40 2278 60 2030 44 2030 62 2279 41 123 450 418 2292 60 62 40 41 123 64 2054 439 492 2294 40 381 2030 2287 44 324 362 41 123 463 46 2294 40 2287 44 362 41 59 392 40 2287 631 424 605 33 362 41 123 2295 40 2287 46 2296 40 41 41 59 125 360 2297 40 648 41 59 125 125 59 125 125 41 59 2031 46 2298 40 41 46 2285 40 2279 41 59 2279 46 2299 40 2300 46 2301 40 2030 58 58 2302 41 41 59 2279 61 418 2280 60 62 40 2281 46 2282 40 648 41 41 59 2279 46 2283 40 1504 41 59 2279 46 2286 40 40 2287 41 45 62 418 2288 60 62 40 2287 46 2289 40 41 41 41 59 2279 46 2290 40 418 2291 60 62 40 41 123 64 2054 439 2303 60 2030 44 2030 62 2304 40 2278 60 2030 44 2030 62 2279 41 123 450 418 2303 60 62 40 41 123 64 2054 439 492 2305 40 381 2030 2287 44 324 362 41 123 463 46 2305 40 2287 44 362 41 59 392 40 2287 631 424 605 33 362 41 123 2306 40 2287 46 2307 40 41 41 59 125 360 2308 40 648 41 59 125 125 59 125 125 41 59 2031 46 2298 40 41 46 2285 40 2279 41 59 2279 46 2299 40 2300 46 2301 40 2030 58 58 2309 41 41 59 2279 61 418 2280 60 62 40 2281 46 2282 40 648 41 41 59 2279 46 2283 40 1503 41 59 2279 46 2286 40 40 2287 41 45 62 418 2288 60 62 40 2287 46 2289 40 41 41 41 59 2279 46 2290 40 418 2291 60 62 40 41 123 64 2054 439 2310 60 2030 44 2030 62 2311 40 2278 60 2030 44 2030 62 2279 41 123 450 418 2310 60 62 40 41 123 64 2054 439 492 2312 40 381 2030 2287 44 324 362 41 123 463 46 2312 40 2287 44 362 41 59 392 40 2287 631 424 605 33 362 41 123 2313 40 2287 46 2314 40 41 41 59 125 360 2315 40 648 41 59 125 125 59 125 125 41 59 2031 46 2298 40 41 46 2285 40 2279 41 59 2279 46 2299 40 2300 46 2301 40 2030 58 58 2316 41 41 59 2279 61 418 2280 60 62 40 2281 46 2282 40 648 41 41 59 2279 46 2286 40 2287 45 62 418 2288 60 62 40 2287 46 2289 40 41 41 41 59 2279 46 2283 40 1503 41 59 2279 46 2290 40 418 2291 60 62 40 41 123 64 2054 439 2317 60 2030 44 2030 62 2318 40 2278 60 2030 44 2030 62 2279 41 123 450 418 2317 60 62 40 41 123 437 2319 2320 59 64 2054 439 492 2321 40 381 2030 2287 44 324 362 41 123 463 46 2321 40 2287 44 362 41 59 621 392 40 2287 631 424 605 33 362 41 123 2045 2322 61 2287 46 2323 40 41 59 2320 61 418 2324 40 2322 41 59 2320 46 2325 40 373 45 62 2326 46 2327 40 2287 46 2323 40 41 44 2011 41 41 59 2320 46 2328 40 418 2329 40 2281 46 2282 40 648 44 2322 41 41 41 59 2330 40 2320 41 59 125 360 123 2331 40 424 41 59 392 40 2320 631 424 41 2320 46 2332 40 424 41 59 125 125 125 59 125 125 41 59 2031 46 2298 40 41 46 2285 40 2279 41 59 2279 46 2299 40 2300 46 2301 40 2030 58 58 2333 41 41 59 2279 61 418 2280 60 62 40 2281 46 2282 40 648 41 41 59 2279 46 2283 40 1503 41 59 2279 46 2286 40 40 2287 41 45 62 418 2288 60 62 40 2287 46 2289 40 41 41 41 59 2279 46 2290 40 418 2291 60 62 40 41 123 64 2054 439 2334 60 2030 44 2030 62 2335 40 2278 60 2030 44 2030 62 2279 41 123 450 418 2334 60 62 40 41 123 64 2054 439 492 2336 40 381 2030 2287 44 324 362 41 123 463 46 2336 40 2287 44 362 41 59 392 40 2287 631 424 605 33 362 41 123 2337 40 2287 46 2338 40 41 41 59 125 360 2339 40 648 41 59 125 125 59 125 125 41 59 2031 46 2298 40 41 46 2285 40 2279 41 59 2279 46 2299 40 2300 46 2301 40 2030 58 58 2340 41 41 59 2279 61 418 2280 60 62 40 648 41 59 2279 46 2286 40 2287 45 62 418 2288 60 62 40 2287 46 2289 40 41 41 41 59 2279 46 2283 40 1503 41 59 2279 46 2284 40 41 46 2285 40 648 41 59 2279 46 2290 40 418 2291 60 62 40 41 123 64 2054 439 2341 60 2030 44 2030 62 2342 40 2278 60 2030 44 2030 62 2279 41 123 450 418 2341 60 62 40 41 123 2025 2343 59 64 2054 439 492 2344 40 381 2030 2287 44 324 362 41 123 463 46 2344 40 2287 44 362 41 59 392 40 2287 631 424 605 33 362 41 123 392 40 2343 614 424 41 123 2343 61 418 2345 40 2281 46 2282 40 648 41 41 59 2346 40 2343 41 59 125 2343 46 2347 40 2348 45 62 418 2349 40 2007 44 2287 46 2333 40 41 41 46 2350 40 41 41 59 125 360 123 2351 40 424 41 59 392 40 2343 631 424 41 123 2343 46 2352 40 424 41 59 2343 61 424 59 125 125 125 125 59 125 125 41 59 2031 46 2298 40 41 46 2285 40 2279 41 59 2279 46 2353 40 380 41 59 125 125 
5120,Java,"@FxmlView
public class WithdrawalView extends ActivatableView<VBox, Void> {

    @FXML
    GridPane gridPane;
    @FXML
    TableView<WithdrawalListItem> tableView;
    @FXML
    TableColumn<WithdrawalListItem, WithdrawalListItem> addressColumn, balanceColumn, selectColumn;

    private RadioButton useAllInputsRadioButton, useCustomInputsRadioButton, feeExcludedRadioButton, feeIncludedRadioButton;
    private Label amountLabel;
    private TextField amountTextField, withdrawFromTextField, withdrawToTextField, withdrawMemoTextField, transactionFeeInputTextField;

    private final BtcWalletService btcWalletService;
    private final TradeManager tradeManager;
    private final P2PService p2PService;
    private final WalletsSetup walletsSetup;
    private final CoinFormatter formatter;
    private final Preferences preferences;
    private final BtcAddressValidator btcAddressValidator;
    private final WalletPasswordWindow walletPasswordWindow;
    private final ObservableList<WithdrawalListItem> observableList = FXCollections.observableArrayList();
    private final SortedList<WithdrawalListItem> sortedList = new SortedList<>(observableList);
    private final Set<WithdrawalListItem> selectedItems = new HashSet<>();
    private BalanceListener balanceListener;
    private Set<String> fromAddresses = new HashSet<>();
    private Coin totalAvailableAmountOfSelectedItems = Coin.ZERO;
    private Coin amountAsCoin = Coin.ZERO;
    private ChangeListener<String> amountListener;
    private ChangeListener<Boolean> amountFocusListener, useCustomFeeCheckboxListener, transactionFeeFocusedListener;
    private ChangeListener<Toggle> feeToggleGroupListener, inputsToggleGroupListener;
    private ChangeListener<Number> transactionFeeChangeListener;
    private ToggleGroup feeToggleGroup, inputsToggleGroup;
    private ToggleButton useCustomFee;
    private final BooleanProperty useAllInputs = new SimpleBooleanProperty(true);
    private boolean feeExcluded;
    private int rowIndex = 0;
    private final FeeService feeService;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    private WithdrawalView(BtcWalletService btcWalletService,
                           TradeManager tradeManager,
                           P2PService p2PService,
                           WalletsSetup walletsSetup,
                           @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter formatter,
                           Preferences preferences,
                           BtcAddressValidator btcAddressValidator,
                           WalletPasswordWindow walletPasswordWindow,
                           FeeService feeService) {
        this.btcWalletService = btcWalletService;
        this.tradeManager = tradeManager;
        this.p2PService = p2PService;
        this.walletsSetup = walletsSetup;
        this.formatter = formatter;
        this.preferences = preferences;
        this.btcAddressValidator = btcAddressValidator;
        this.walletPasswordWindow = walletPasswordWindow;
        this.feeService = feeService;
    }

    @Override
    public void initialize() {

        final TitledGroupBg titledGroupBg = addTitledGroupBg(gridPane, rowIndex, 4, Res.get(""funds.deposit.withdrawFromWallet""));
        titledGroupBg.getStyleClass().add(""last"");

        inputsToggleGroup = new ToggleGroup();
        inputsToggleGroupListener = (observable, oldValue, newValue) -> {
            useAllInputs.set(newValue == useAllInputsRadioButton);
            updateInputSelection();
        };

        final Tuple3<Label, RadioButton, RadioButton> labelRadioButtonRadioButtonTuple3 =
                addTopLabelRadioButtonRadioButton(gridPane, rowIndex, inputsToggleGroup,
                        Res.get(""funds.withdrawal.inputs""),
                        Res.get(""funds.withdrawal.useAllInputs""),
                        Res.get(""funds.withdrawal.useCustomInputs""),
                        Layout.FIRST_ROW_DISTANCE);

        useAllInputsRadioButton = labelRadioButtonRadioButtonTuple3.second;
        useCustomInputsRadioButton = labelRadioButtonRadioButtonTuple3.third;

        feeToggleGroup = new ToggleGroup();

        final Tuple4<Label, TextField, RadioButton, RadioButton> feeTuple3 = addTopLabelTextFieldRadioButtonRadioButton(gridPane, ++rowIndex, feeToggleGroup,
                Res.get(""funds.withdrawal.receiverAmount"", Res.getBaseCurrencyCode()),
                """",
                Res.get(""funds.withdrawal.feeExcluded""),
                Res.get(""funds.withdrawal.feeIncluded""),
                0);

        amountLabel = feeTuple3.first;
        amountTextField = feeTuple3.second;
        amountTextField.setMinWidth(180);
        feeExcludedRadioButton = feeTuple3.third;
        feeIncludedRadioButton = feeTuple3.fourth;

        withdrawFromTextField = addTopLabelTextField(gridPane, ++rowIndex,
                Res.get(""funds.withdrawal.fromLabel"", Res.getBaseCurrencyCode())).second;

        withdrawToTextField = addTopLabelInputTextField(gridPane, ++rowIndex,
                Res.get(""funds.withdrawal.toLabel"", Res.getBaseCurrencyCode())).second;

        withdrawMemoTextField = addTopLabelInputTextField(gridPane, ++rowIndex,
                Res.get(""funds.withdrawal.memoLabel"", Res.getBaseCurrencyCode())).second;

        Tuple3<Label, InputTextField, ToggleButton> customFeeTuple = addTopLabelInputTextFieldSlideToggleButtonRight(gridPane, ++rowIndex,
                Res.get(""funds.withdrawal.txFee""), Res.get(""funds.withdrawal.useCustomFeeValue""));
        transactionFeeInputTextField = customFeeTuple.second;
        useCustomFee = customFeeTuple.third;

        useCustomFeeCheckboxListener = (observable, oldValue, newValue) -> {
            transactionFeeInputTextField.setEditable(newValue);
            if (!newValue) {
                try {
                    transactionFeeInputTextField.setText(String.valueOf(feeService.getTxFeePerVbyte().value));
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        };

        transactionFeeFocusedListener = (o, oldValue, newValue) -> {
            if (oldValue && !newValue) {
                String estimatedFee = String.valueOf(feeService.getTxFeePerVbyte().value);
                try {
                    int withdrawalTxFeePerVbyte = Integer.parseInt(transactionFeeInputTextField.getText());
                    final long minFeePerVbyte = feeService.getMinFeePerVByte();
                    if (withdrawalTxFeePerVbyte < minFeePerVbyte) {
                        new Popup().warning(Res.get(""funds.withdrawal.txFeeMin"", minFeePerVbyte)).show();
                        transactionFeeInputTextField.setText(estimatedFee);
                    } else if (withdrawalTxFeePerVbyte > 5000) {
                        new Popup().warning(Res.get(""funds.withdrawal.txFeeTooLarge"")).show();
                        transactionFeeInputTextField.setText(estimatedFee);
                    } else {
                        preferences.setWithdrawalTxFeeInVbytes(withdrawalTxFeePerVbyte);
                    }
                } catch (NumberFormatException t) {
                    log.error(t.toString());
                    t.printStackTrace();
                    new Popup().warning(Res.get(""validation.integerOnly"")).show();
                    transactionFeeInputTextField.setText(estimatedFee);
                } catch (Throwable t) {
                    log.error(t.toString());
                    t.printStackTrace();
                    new Popup().warning(Res.get(""validation.inputError"", t.getMessage())).show();
                    transactionFeeInputTextField.setText(estimatedFee);
                }
            }
        };
        transactionFeeChangeListener = (observable, oldValue, newValue) -> {
            if (!useCustomFee.isSelected()) {
                transactionFeeInputTextField.setText(String.valueOf(feeService.getTxFeePerVbyte().value));
            }
        };

        final Button withdrawButton = addPrimaryActionButton(gridPane, rowIndex, Res.get(""funds.withdrawal.withdrawButton""), 15);
        GridPane.setHalignment(withdrawButton, HPos.RIGHT);

        withdrawButton.setOnAction(event -> onWithdraw());

        addressColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.address"")));
        balanceColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.balanceWithCur"", Res.getBaseCurrencyCode())));
        selectColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.select"")));

        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        tableView.setMaxHeight(Double.MAX_VALUE);
        tableView.setPlaceholder(new AutoTooltipLabel(Res.get(""funds.withdrawal.noFundsAvailable"")));
        tableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);

        setAddressColumnCellFactory();
        setBalanceColumnCellFactory();
        setSelectColumnCellFactory();

        addressColumn.setComparator(Comparator.comparing(WithdrawalListItem::getAddressString));
        balanceColumn.setComparator(Comparator.comparing(WithdrawalListItem::getBalance));
        balanceColumn.setSortType(TableColumn.SortType.DESCENDING);
        tableView.getSortOrder().add(balanceColumn);

        balanceListener = new BalanceListener() {
            @Override
            public void onBalanceChanged(Coin balance, Transaction tx) {
                updateList();
            }
        };
        amountListener = (observable, oldValue, newValue) -> {
            if (amountTextField.focusedProperty().get()) {
                try {
                    amountAsCoin = ParsingUtils.parseToCoin(amountTextField.getText(), formatter);
                } catch (Throwable t) {
                    log.error(""Error at amountTextField input. "" + t.toString());
                }
            }
        };
        amountFocusListener = (observable, oldValue, newValue) -> {
            if (oldValue && !newValue) {
                if (amountAsCoin.isPositive())
                    amountTextField.setText(formatter.formatCoin(amountAsCoin));
                else
                    amountTextField.setText("""");
            }
        };
        feeExcludedRadioButton.setToggleGroup(feeToggleGroup);
        feeIncludedRadioButton.setToggleGroup(feeToggleGroup);
        feeToggleGroupListener = (observable, oldValue, newValue) -> {
            feeExcluded = newValue == feeExcludedRadioButton;
            amountLabel.setText(feeExcluded ?
                    Res.get(""funds.withdrawal.receiverAmount"") :
                    Res.get(""funds.withdrawal.senderAmount""));
        };
    }

    private void updateInputSelection() {
        observableList.forEach(item -> {
            item.setSelected(useAllInputs.get());
            selectForWithdrawal(item);
        });
        tableView.refresh();
    }

    @Override
    protected void activate() {
        sortedList.comparatorProperty().bind(tableView.comparatorProperty());
        tableView.setItems(sortedList);
        updateList();

        reset();

        amountTextField.textProperty().addListener(amountListener);
        amountTextField.focusedProperty().addListener(amountFocusListener);
        btcWalletService.addBalanceListener(balanceListener);
        feeToggleGroup.selectedToggleProperty().addListener(feeToggleGroupListener);
        inputsToggleGroup.selectedToggleProperty().addListener(inputsToggleGroupListener);

        if (feeToggleGroup.getSelectedToggle() == null)
            feeToggleGroup.selectToggle(feeIncludedRadioButton);

        if (inputsToggleGroup.getSelectedToggle() == null)
            inputsToggleGroup.selectToggle(useAllInputsRadioButton);

        useCustomFee.setSelected(false);
        transactionFeeInputTextField.setEditable(false);
        transactionFeeInputTextField.setText(String.valueOf(feeService.getTxFeePerVbyte().value));
        feeService.feeUpdateCounterProperty().addListener(transactionFeeChangeListener);
        useCustomFee.selectedProperty().addListener(useCustomFeeCheckboxListener);
        transactionFeeInputTextField.focusedProperty().addListener(transactionFeeFocusedListener);

        updateInputSelection();
        GUIUtil.requestFocus(withdrawToTextField);
    }

    @Override
    protected void deactivate() {
        sortedList.comparatorProperty().unbind();
        observableList.forEach(WithdrawalListItem::cleanup);
        btcWalletService.removeBalanceListener(balanceListener);
        amountTextField.textProperty().removeListener(amountListener);
        amountTextField.focusedProperty().removeListener(amountFocusListener);
        feeToggleGroup.selectedToggleProperty().removeListener(feeToggleGroupListener);
        inputsToggleGroup.selectedToggleProperty().removeListener(inputsToggleGroupListener);
        transactionFeeInputTextField.focusedProperty().removeListener(transactionFeeFocusedListener);
        if (transactionFeeChangeListener != null)
            feeService.feeUpdateCounterProperty().removeListener(transactionFeeChangeListener);
        useCustomFee.selectedProperty().removeListener(useCustomFeeCheckboxListener);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // UI handlers
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onWithdraw() {
        if (GUIUtil.isReadyForTxBroadcastOrShowPopup(p2PService, walletsSetup)) {
            try {
                Coin feeRate = Coin.valueOf(Integer.parseInt(transactionFeeInputTextField.getText()));
                final String withdrawToAddress = withdrawToTextField.getText();
                final Coin sendersAmount;

                // We do not know sendersAmount if senderPaysFee is true. We repeat fee calculation after first attempt if senderPaysFee is true.
                Transaction feeEstimationTransaction = btcWalletService.getFeeEstimationTransactionForMultipleAddresses(fromAddresses, amountAsCoin, feeRate);
                if (feeExcluded && feeEstimationTransaction != null) {
                    feeEstimationTransaction = btcWalletService.getFeeEstimationTransactionForMultipleAddresses(fromAddresses, amountAsCoin.add(feeEstimationTransaction.getFee()), feeRate);
                }
                checkNotNull(feeEstimationTransaction, ""feeEstimationTransaction must not be null"");

                Coin dust = btcWalletService.getDust(feeEstimationTransaction);
                Coin fee = feeEstimationTransaction.getFee().add(dust);
                Coin receiverAmount;
                // amountAsCoin is what the user typed into the withdrawal field.
                // this can be interpreted as either the senders amount or receivers amount depending
                // on a radio button ""fee excluded / fee included"".
                // therefore we calculate the actual sendersAmount and receiverAmount as follows:
                if (feeExcluded) {
                    receiverAmount = amountAsCoin;
                    sendersAmount = receiverAmount.add(fee);
                } else {
                    sendersAmount = amountAsCoin.add(dust); // sendersAmount bumped up to UTXO size when dust is in play
                    receiverAmount = sendersAmount.subtract(fee);
                }
                if (dust.isPositive()) {
                    log.info(""Dust output ({} satoshi) was detected, the dust amount has been added to the fee (was {}, now {})"",
                            dust.value,
                            feeEstimationTransaction.getFee(),
                            fee.value);
                }

                if (areInputsValid(sendersAmount)) {
                    int txVsize = feeEstimationTransaction.getVsize();
                    log.info(""Fee for tx with size {}: {} "" + Res.getBaseCurrencyCode() + """", txVsize, fee.toPlainString());

                    if (receiverAmount.isPositive()) {
                        double vkb = txVsize / 1000d;

                        String messageText = Res.get(""shared.sendFundsDetailsWithFee"",
                                formatter.formatCoinWithCode(sendersAmount),
                                withdrawFromTextField.getText(),
                                withdrawToAddress,
                                formatter.formatCoinWithCode(fee),
                                (double) fee.longValue() / txVsize,    // no risk of div/0 since txVsize is always positive
                                vkb,
                                formatter.formatCoinWithCode(receiverAmount));
                        if (dust.isPositive()) {
                            messageText = Res.get(""shared.sendFundsDetailsDust"",
                                    dust.value, dust.value > 1 ? ""s"" : """")
                                    + messageText;
                        }

                        new Popup().headLine(Res.get(""funds.withdrawal.confirmWithdrawalRequest""))
                                .confirmation(messageText)
                                .actionButtonText(Res.get(""shared.yes""))
                                .onAction(() -> doWithdraw(sendersAmount, fee, new FutureCallback<>() {
                                    @Override
                                    public void onSuccess(@javax.annotation.Nullable Transaction transaction) {
                                        if (transaction != null) {
                                            String key = ""showTransactionSent"";
                                            if (DontShowAgainLookup.showAgain(key)) {
                                                new TxDetails(transaction.getTxId().toString(), withdrawToAddress, formatter.formatCoinWithCode(sendersAmount))
                                                        .dontShowAgainId(key)
                                                        .show();
                                            }
                                            log.debug(""onWithdraw onSuccess tx ID:{}"", transaction.getTxId().toString());
                                        } else {
                                            log.error(""onWithdraw transaction is null"");
                                        }

                                        List<Trade> trades = new ArrayList<>(tradeManager.getObservableList());
                                        trades.stream()
                                                .filter(Trade::isPayoutPublished)
                                                .forEach(trade -> btcWalletService.getAddressEntry(trade.getId(), AddressEntry.Context.TRADE_PAYOUT)
                                                        .ifPresent(addressEntry -> {
                                                            if (btcWalletService.getBalanceForAddress(addressEntry.getAddress()).isZero())
                                                                tradeManager.onTradeCompleted(trade);
                                                        }));
                                    }

                                    @Override
                                    public void onFailure(@NotNull Throwable t) {
                                        log.error(""onWithdraw onFailure"");
                                    }
                                }))
                                .closeButtonText(Res.get(""shared.cancel""))
                                .show();
                    } else {
                        new Popup().warning(Res.get(""portfolio.pending.step5_buyer.amountTooLow"")).show();
                    }
                }
            } catch (InsufficientFundsException e) {
                new Popup().warning(Res.get(""funds.withdrawal.warn.amountExceeds"") + ""\n\nError message:\n"" + e.getMessage()).show();
            } catch (Throwable e) {
                e.printStackTrace();
                log.error(e.toString());
                new Popup().warning(e.toString()).show();
            }
        }
    }

    private void selectForWithdrawal(WithdrawalListItem item) {
        if (item.isSelected())
            selectedItems.add(item);
        else
            selectedItems.remove(item);

        fromAddresses = selectedItems.stream()
                .map(WithdrawalListItem::getAddressString)
                .collect(Collectors.toSet());

        if (!selectedItems.isEmpty()) {
            totalAvailableAmountOfSelectedItems = Coin.valueOf(selectedItems.stream().mapToLong(e -> e.getBalance().getValue()).sum());
            if (totalAvailableAmountOfSelectedItems.isPositive()) {
                amountAsCoin = totalAvailableAmountOfSelectedItems;
                amountTextField.setText(formatter.formatCoin(amountAsCoin));
            } else {
                amountAsCoin = Coin.ZERO;
                totalAvailableAmountOfSelectedItems = Coin.ZERO;
                amountTextField.setText("""");
                withdrawFromTextField.setText("""");
            }

            if (selectedItems.size() == 1) {
                withdrawFromTextField.setText(selectedItems.stream().findAny().get().getAddressEntry().getAddressString());
                withdrawFromTextField.setTooltip(null);
            } else {
                int abbr = Math.max(10, 66 / selectedItems.size());
                String addressesShortened = selectedItems.stream()
                        .map(e -> StringUtils.abbreviate(e.getAddressString(), abbr))
                        .collect(Collectors.joining("", ""));
                String text = Res.get(""funds.withdrawal.withdrawMultipleAddresses"", addressesShortened);
                withdrawFromTextField.setText(text);

                String addresses = selectedItems.stream()
                        .map(WithdrawalListItem::getAddressString)
                        .collect(Collectors.joining("",\n""));
                String tooltipText = Res.get(""funds.withdrawal.withdrawMultipleAddresses.tooltip"", addresses);
                withdrawFromTextField.setTooltip(new Tooltip(tooltipText));
            }
        } else {
            reset();
        }
    }

    private void openBlockExplorer(WithdrawalListItem item) {
        if (item.getAddressString() != null)
            GUIUtil.openWebPage(preferences.getBlockChainExplorer().addressUrl + item.getAddressString(), false);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void updateList() {
        observableList.forEach(WithdrawalListItem::cleanup);
        observableList.setAll(btcWalletService.getAddressEntriesForAvailableBalanceStream()
                .map(addressEntry -> new WithdrawalListItem(addressEntry, btcWalletService, formatter))
                .collect(Collectors.toList()));

        updateInputSelection();
    }

    private void doWithdraw(Coin amount, Coin fee, FutureCallback<Transaction> callback) {
        if (btcWalletService.isEncrypted()) {
            UserThread.runAfter(() -> walletPasswordWindow.onAesKey(aesKey ->
                    sendFunds(amount, fee, aesKey, callback))
                    .show(), 300, TimeUnit.MILLISECONDS);
        } else {
            sendFunds(amount, fee, null, callback);
        }
    }

    private void sendFunds(Coin amount, Coin fee, KeyParameter aesKey, FutureCallback<Transaction> callback) {
        try {
            String memo = withdrawMemoTextField.getText();
            if (memo.isEmpty()) {
                memo = null;
            }
            Transaction transaction = btcWalletService.sendFundsForMultipleAddresses(fromAddresses,
                    withdrawToTextField.getText(),
                    amount,
                    fee,
                    null,
                    aesKey,
                    memo,
                    callback);

            reset();
            updateList();
        } catch (AddressFormatException e) {
            new Popup().warning(Res.get(""validation.btc.invalidAddress"")).show();
        } catch (Wallet.DustySendRequested e) {
            new Popup().warning(Res.get(""validation.amountBelowDust"",
                    formatter.formatCoinWithCode(Restrictions.getMinNonDustOutput()))).show();
        } catch (AddressEntryException e) {
            new Popup().error(e.getMessage()).show();
        } catch (InsufficientMoneyException e) {
            log.warn(e.getMessage());
            new Popup().warning(Res.get(""funds.withdrawal.notEnoughFunds"") + ""\n\nError message:\n"" + e.getMessage()).show();
        } catch (Throwable e) {
            log.warn(e.toString());
            new Popup().warning(e.toString()).show();
        }
    }

    private void reset() {
        withdrawFromTextField.setText("""");
        withdrawFromTextField.setPromptText(Res.get(""funds.withdrawal.selectAddress""));
        withdrawFromTextField.setTooltip(null);

        totalAvailableAmountOfSelectedItems = Coin.ZERO;
        amountAsCoin = Coin.ZERO;
        amountTextField.setText("""");
        amountTextField.setPromptText(Res.get(""funds.withdrawal.setAmount""));

        withdrawToTextField.setText("""");
        withdrawToTextField.setPromptText(Res.get(""funds.withdrawal.fillDestAddress""));

        withdrawMemoTextField.setText("""");
        withdrawMemoTextField.setPromptText(Res.get(""funds.withdrawal.memo""));

        selectedItems.clear();
        tableView.getSelectionModel().clearSelection();
    }

    private boolean areInputsValid(Coin sendersAmount) {
        if (!sendersAmount.isPositive()) {
            new Popup().warning(Res.get(""validation.negative"")).show();
            return false;
        }

        if (!btcAddressValidator.validate(withdrawToTextField.getText()).isValid) {
            new Popup().warning(Res.get(""validation.btc.invalidAddress"")).show();
            return false;
        }
        if (!totalAvailableAmountOfSelectedItems.isPositive()) {
            new Popup().warning(Res.get(""funds.withdrawal.warn.noSourceAddressSelected"")).show();
            return false;
        }

        if (sendersAmount.compareTo(totalAvailableAmountOfSelectedItems) > 0) {
            new Popup().warning(Res.get(""funds.withdrawal.warn.amountExceeds"")).show();
            return false;
        }

        return true;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // ColumnCellFactories
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void setAddressColumnCellFactory() {
        addressColumn.setCellValueFactory((addressListItem) -> new ReadOnlyObjectWrapper<>(addressListItem.getValue()));

        addressColumn.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<WithdrawalListItem, WithdrawalListItem> call(TableColumn<WithdrawalListItem,
                            WithdrawalListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon hyperlinkWithIcon;

                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    String address = item.getAddressString();
                                    hyperlinkWithIcon = new ExternalHyperlink(address);
                                    hyperlinkWithIcon.setOnAction(event -> openBlockExplorer(item));
                                    hyperlinkWithIcon.setTooltip(new Tooltip(Res.get(""tooltip.openBlockchainForAddress"", address)));
                                    setAlignment(Pos.CENTER);
                                    setGraphic(hyperlinkWithIcon);
                                } else {
                                    setGraphic(null);
                                    if (hyperlinkWithIcon != null)
                                        hyperlinkWithIcon.setOnAction(null);
                                }
                            }
                        };
                    }
                });
    }

    private void setBalanceColumnCellFactory() {
        balanceColumn.getStyleClass().add(""last-column"");
        balanceColumn.setCellValueFactory((addressListItem) -> new ReadOnlyObjectWrapper<>(addressListItem.getValue()));
        balanceColumn.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<WithdrawalListItem, WithdrawalListItem> call(TableColumn<WithdrawalListItem,
                            WithdrawalListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic((item != null && !empty) ? item.getBalanceLabel() : null);
                            }
                        };
                    }
                });
    }

    private void setSelectColumnCellFactory() {
        selectColumn.getStyleClass().add(""first-column"");
        selectColumn.setCellValueFactory((addressListItem) ->
                new ReadOnlyObjectWrapper<>(addressListItem.getValue()));
        selectColumn.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<WithdrawalListItem, WithdrawalListItem> call(TableColumn<WithdrawalListItem,
                            WithdrawalListItem> column) {
                        return new TableCell<>() {

                            CheckBox checkBox = new AutoTooltipCheckBox();

                            @Override
                            public void updateItem(final WithdrawalListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    checkBox.setOnAction(e -> {
                                        item.setSelected(checkBox.isSelected());
                                        selectForWithdrawal(item);

                                        // If all are selected we select useAllInputsRadioButton
                                        if (observableList.size() == selectedItems.size()) {
                                            inputsToggleGroup.selectToggle(useAllInputsRadioButton);
                                        } else {
                                            // We don't want to get deselected all when we activate the useCustomInputsRadioButton
                                            // so we temporarily disable the listener
                                            inputsToggleGroup.selectedToggleProperty().removeListener(inputsToggleGroupListener);
                                            inputsToggleGroup.selectToggle(useCustomInputsRadioButton);
                                            useAllInputs.set(false);
                                            inputsToggleGroup.selectedToggleProperty().addListener(inputsToggleGroupListener);
                                        }
                                    });
                                    setGraphic(checkBox);
                                    checkBox.setSelected(item.isSelected());
                                } else {
                                    checkBox.setOnAction(null);
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
    }
}",1,64 2000 439 334 2001 378 2002 60 2003 44 2004 62 123 64 2005 2006 2007 59 64 2005 2008 60 2009 62 2010 59 64 2005 2011 60 2009 44 2009 62 2012 44 2013 44 2014 59 437 2015 2016 44 2017 44 2018 44 2019 59 437 2020 2021 59 437 2022 2023 44 2024 44 2025 44 2026 44 2027 59 437 381 2028 2029 59 437 381 2030 2031 59 437 381 2032 2033 59 437 381 2034 2035 59 437 381 2036 2037 59 437 381 2038 2039 59 437 381 2040 2041 59 437 381 2042 2043 59 437 381 2044 60 2009 62 2045 61 2046 46 2047 40 41 59 437 381 2048 60 2009 62 2049 61 418 2048 60 62 40 2045 41 59 437 381 2050 60 2009 62 2051 61 418 2052 60 62 40 41 59 437 2053 2054 59 437 2050 60 2055 62 2056 61 418 2052 60 62 40 41 59 437 2057 2058 61 2057 46 2059 59 437 2057 2060 61 2057 46 2059 59 437 2061 60 2055 62 2062 59 437 2061 60 2063 62 2064 44 2065 44 2066 59 437 2061 60 2067 62 2068 44 2069 59 437 2061 60 2070 62 2071 59 437 2072 2073 44 2074 59 437 2075 2076 59 437 381 2077 2078 61 418 2079 40 473 41 59 437 324 2080 59 437 404 2081 61 1500 59 437 381 2082 2083 59 621 621 621 64 2084 437 2001 40 2028 2029 44 2030 2031 44 2032 2033 44 2034 2035 44 64 2085 40 2086 46 2087 41 2036 2037 44 2038 2039 44 2040 2041 44 2042 2043 44 2082 2083 41 123 467 46 2029 61 2029 59 467 46 2031 61 2031 59 467 46 2033 61 2033 59 467 46 2035 61 2035 59 467 46 2037 61 2037 59 467 46 2039 61 2039 59 467 46 2041 61 2041 59 467 46 2043 61 2043 59 467 46 2083 61 2083 59 125 64 2088 439 492 2089 40 41 123 381 2090 2091 61 2092 40 2007 44 2081 44 1502 44 2093 46 2094 40 648 41 41 59 2091 46 2095 40 41 46 2096 40 648 41 59 2074 61 418 2072 40 41 59 2069 61 40 2097 44 2098 44 2099 41 45 62 123 2078 46 2100 40 2099 614 2016 41 59 2101 40 41 59 125 59 381 2102 60 2020 44 2015 44 2015 62 2103 61 2104 40 2007 44 2081 44 2074 44 2093 46 2094 40 648 41 44 2093 46 2094 40 648 41 44 2093 46 2094 40 648 41 44 2105 46 2106 41 59 2016 61 2103 46 2107 59 2017 61 2103 46 2108 59 2073 61 418 2072 40 41 59 381 2109 60 2020 44 2022 44 2015 44 2015 62 2110 61 2111 40 2007 44 637 2081 44 2073 44 2093 46 2094 40 648 44 2093 46 2112 40 41 41 44 648 44 2093 46 2094 40 648 41 44 2093 46 2094 40 648 41 44 1500 41 59 2021 61 2110 46 2113 59 2023 61 2110 46 2107 59 2023 46 2114 40 1504 41 59 2018 61 2110 46 2108 59 2019 61 2110 46 2115 59 2024 61 2116 40 2007 44 637 2081 44 2093 46 2094 40 648 44 2093 46 2112 40 41 41 41 46 2107 59 2025 61 2117 40 2007 44 637 2081 44 2093 46 2094 40 648 44 2093 46 2112 40 41 41 41 46 2107 59 2026 61 2117 40 2007 44 637 2081 44 2093 46 2094 40 648 44 2093 46 2112 40 41 41 41 46 2107 59 2102 60 2020 44 2118 44 2075 62 2119 61 2120 40 2007 44 637 2081 44 2093 46 2094 40 648 41 44 2093 46 2094 40 648 41 41 59 2027 61 2119 46 2107 59 2076 61 2119 46 2108 59 2065 61 40 2097 44 2098 44 2099 41 45 62 123 2027 46 2121 40 2099 41 59 392 40 33 2099 41 123 474 123 2027 46 2122 40 2055 46 2123 40 2083 46 2124 40 41 46 2125 41 41 59 125 329 40 2126 2127 41 123 2127 46 2128 40 41 59 125 125 125 59 2066 61 40 2129 44 2098 44 2099 41 45 62 123 392 40 2098 605 33 2099 41 123 2055 2130 61 2055 46 2131 40 2083 46 2132 40 41 46 2133 41 59 474 123 404 2134 61 2135 46 2136 40 2027 46 2137 40 41 41 59 381 413 2138 61 2083 46 2139 40 41 59 392 40 2134 60 2138 41 123 418 2140 40 41 46 494 40 2093 46 2094 40 648 44 2138 41 41 46 2141 40 41 59 2027 46 2142 40 2130 41 59 125 360 392 40 2134 62 1505 41 123 418 2143 40 41 46 494 40 2093 46 2094 40 648 41 41 46 2144 40 41 59 2027 46 2145 40 2130 41 59 125 360 123 2039 46 2146 40 2134 41 59 125 125 329 40 2147 2148 41 123 2149 46 371 40 2148 46 2150 40 41 41 59 2148 46 2151 40 41 59 418 2152 40 41 46 494 40 2093 46 2094 40 648 41 41 46 2153 40 41 59 2027 46 2154 40 2130 41 59 125 329 40 2155 2148 41 123 2156 46 371 40 2148 46 2157 40 41 41 59 2148 46 2158 40 41 59 418 2159 40 41 46 494 40 2093 46 2094 40 648 44 2148 46 2160 40 41 41 41 46 2161 40 41 59 2027 46 2162 40 2130 41 59 125 125 125 59 2071 61 40 2097 44 2098 44 2099 41 45 62 123 392 40 33 2076 46 2163 40 41 41 123 2027 46 2164 40 2055 46 2165 40 2083 46 2166 40 41 46 2167 41 41 59 125 125 59 381 2168 2169 61 2170 40 2007 44 2081 44 2093 46 2094 40 648 41 44 1503 41 59 2006 46 2171 40 2169 44 2172 46 2173 41 59 2169 46 2174 40 373 45 62 2175 40 41 41 59 2012 46 2176 40 418 2177 40 2093 46 2094 40 648 41 41 41 59 2013 46 2176 40 418 2177 40 2093 46 2094 40 648 44 2093 46 2112 40 41 41 41 41 59 2014 46 2176 40 418 2177 40 2093 46 2094 40 648 41 41 41 59 2010 46 2178 40 2008 46 2179 41 59 2010 46 2180 40 2181 46 2182 41 59 2010 46 2183 40 418 2177 40 2093 46 2094 40 648 41 41 41 59 2010 46 2184 40 41 46 2185 40 2186 46 2187 41 59 2188 40 41 59 2189 40 41 59 2190 40 41 59 2012 46 2191 40 2192 46 2193 40 2009 58 58 2194 41 41 59 2013 46 2191 40 2192 46 2193 40 2009 58 58 2195 41 41 59 2013 46 2196 40 2011 46 2197 46 2198 41 59 2010 46 2199 40 41 46 2096 40 2013 41 59 2054 61 418 2053 40 41 123 64 2088 439 492 2200 40 2057 2201 44 2202 2203 41 123 2204 40 41 59 125 125 59 2062 61 40 2097 44 2098 44 2099 41 45 62 123 392 40 2023 46 2205 40 41 46 2094 40 41 41 123 474 123 2060 61 2206 46 2207 40 2023 46 2208 40 41 44 2037 41 59 125 329 40 2209 2210 41 123 2211 46 371 40 648 43 2210 46 2212 40 41 41 59 125 125 125 59 2064 61 40 2097 44 2098 44 2099 41 45 62 123 392 40 2098 605 33 2099 41 123 392 40 2060 46 2213 40 41 41 2023 46 2214 40 2037 46 2215 40 2060 41 41 59 360 2023 46 2214 40 648 41 59 125 125 59 2018 46 2216 40 2073 41 59 2019 46 2216 40 2073 41 59 2068 61 40 2097 44 2098 44 2099 41 45 62 123 2080 61 2099 614 2018 59 2021 46 2217 40 2080 63 2093 46 2094 40 648 41 58 2093 46 2094 40 648 41 41 59 125 59 125 437 492 2218 40 41 123 2045 46 2219 40 2220 45 62 123 2220 46 2221 40 2078 46 2222 40 41 41 59 2223 40 2220 41 59 125 41 59 2010 46 2224 40 41 59 125 64 2088 438 492 2225 40 41 123 2049 46 2226 40 41 46 2227 40 2010 46 2226 40 41 41 59 2010 46 2228 40 2049 41 59 2229 40 41 59 2230 40 41 59 2023 46 2231 40 41 46 2232 40 2062 41 59 2023 46 2233 40 41 46 2232 40 2064 41 59 2029 46 2234 40 2054 41 59 2073 46 2235 40 41 46 2232 40 2068 41 59 2074 46 2235 40 41 46 2232 40 2069 41 59 392 40 2073 46 2236 40 41 614 424 41 2073 46 2237 40 2019 41 59 392 40 2074 46 2236 40 41 614 424 41 2074 46 2237 40 2016 41 59 2076 46 2238 40 380 41 59 2027 46 2239 40 380 41 59 2027 46 2240 40 2055 46 2241 40 2083 46 2242 40 41 46 2243 41 41 59 2083 46 2244 40 41 46 2232 40 2071 41 59 2076 46 2245 40 41 46 2232 40 2065 41 59 2027 46 2233 40 41 46 2232 40 2066 41 59 2218 40 41 59 2246 46 2247 40 2025 41 59 125 64 2088 438 492 2248 40 41 123 2049 46 2249 40 41 46 2250 40 41 59 2045 46 2251 40 2009 58 58 2252 41 59 2029 46 2253 40 2054 41 59 2023 46 2254 40 41 46 2255 40 2062 41 59 2023 46 2256 40 41 46 2255 40 2064 41 59 2073 46 2257 40 41 46 2255 40 2068 41 59 2074 46 2257 40 41 46 2255 40 2069 41 59 2027 46 2256 40 41 46 2255 40 2066 41 59 392 40 2071 631 424 41 2083 46 2258 40 41 46 2255 40 2071 41 59 2076 46 2259 40 41 46 2255 40 2065 41 59 125 621 621 621 437 492 2260 40 41 123 392 40 2261 46 2262 40 2033 44 2035 41 41 123 474 123 2057 2263 61 2057 46 2264 40 2265 46 2266 40 2027 46 2267 40 41 41 41 59 381 2055 2268 61 2025 46 2267 40 41 59 381 2057 2269 59 621 2270 2271 61 2029 46 2272 40 2056 44 2060 44 2263 41 59 392 40 2080 605 2271 631 424 41 123 2271 61 2029 46 2272 40 2056 44 2060 46 2273 40 2271 46 2274 40 41 41 44 2263 41 59 125 2275 40 2271 44 648 41 59 2057 2276 61 2029 46 2277 40 2271 41 59 2057 2278 61 2271 46 2279 40 41 46 2280 40 2276 41 59 2057 2281 59 621 621 621 621 392 40 2080 41 123 2281 61 2060 59 2269 61 2281 46 2280 40 2278 41 59 125 360 123 2269 61 2060 46 2280 40 2276 41 59 621 2281 61 2269 46 2282 40 2278 41 59 125 392 40 2276 46 2283 40 41 41 123 2284 46 2285 40 648 44 2276 46 2286 44 2271 46 2279 40 41 44 2278 46 2286 41 59 125 392 40 2287 40 2269 41 41 123 404 2288 61 2271 46 2289 40 41 59 2290 46 2291 40 648 43 2292 46 2293 40 41 43 648 44 2288 44 2278 46 2294 40 41 41 59 392 40 2281 46 2283 40 41 41 123 356 2295 61 2288 47 1504 59 2055 2296 61 2292 46 2297 40 648 44 2037 46 2298 40 2269 41 44 2024 46 2267 40 41 44 2268 44 2037 46 2298 40 2278 41 44 40 356 41 2278 46 2299 40 41 47 2288 44 621 2295 44 2037 46 2298 40 2281 41 41 59 392 40 2276 46 2283 40 41 41 123 2296 61 2292 46 2297 40 648 44 2276 46 2300 44 2276 46 2300 62 1501 63 648 58 648 41 43 2296 59 125 418 2301 40 41 46 2302 40 2292 46 2297 40 648 41 41 46 2303 40 2296 41 46 2304 40 2292 46 2297 40 648 41 41 46 2305 40 40 41 45 62 2306 40 2269 44 2278 44 418 2307 60 62 40 41 123 64 2088 439 492 2308 40 64 2309 46 2310 46 2311 2270 2312 41 123 392 40 2312 631 424 41 123 2055 2313 61 648 59 392 40 2314 46 2315 40 2313 41 41 123 418 2316 40 2312 46 2317 40 41 46 2318 40 41 44 2268 44 2037 46 2298 40 2269 41 41 46 2319 40 2313 41 46 2320 40 41 59 125 2290 46 2321 40 648 44 2312 46 2322 40 41 46 2323 40 41 41 59 125 360 123 2290 46 371 40 648 41 59 125 2324 60 2325 62 2326 61 418 2327 60 62 40 2031 46 2328 40 41 41 59 2326 46 2329 40 41 46 2330 40 2325 58 58 2331 41 46 2332 40 2333 45 62 2029 46 2334 40 2333 46 2335 40 41 44 2336 46 2337 46 2338 41 46 2339 40 2340 45 62 123 392 40 2029 46 2341 40 2340 46 2342 40 41 41 46 2343 40 41 41 2031 46 2344 40 2333 41 59 125 41 41 59 125 64 2088 439 492 2345 40 64 2346 2347 2348 41 123 2290 46 371 40 648 41 59 125 125 41 41 46 2349 40 2292 46 2297 40 648 41 41 46 2350 40 41 59 125 360 123 418 2351 40 41 46 494 40 2292 46 2352 40 648 41 41 46 2353 40 41 59 125 125 125 329 40 2354 2355 41 123 418 2356 40 41 46 494 40 2357 46 2358 40 648 41 43 648 43 2355 46 2359 40 41 41 46 2360 40 41 59 125 329 40 2361 2355 41 123 2355 46 2362 40 41 59 2363 46 371 40 2355 46 2364 40 41 41 59 418 2365 40 41 46 494 40 2355 46 2364 40 41 41 46 2366 40 41 59 125 125 125 437 492 2367 40 2009 2368 41 123 392 40 2368 46 2369 40 41 41 2051 46 2370 40 2368 41 59 360 2051 46 2371 40 2368 41 59 2056 61 2051 46 2372 40 41 46 2373 40 2009 58 58 2374 41 46 2375 40 2376 46 2377 40 41 41 59 392 40 33 2051 46 2378 40 41 41 123 2058 61 2057 46 2379 40 2051 46 2372 40 41 46 2380 40 2381 45 62 2381 46 2382 40 41 46 2383 40 41 41 46 2384 40 41 41 59 392 40 2058 46 2385 40 41 41 123 2060 61 2058 59 2023 46 2386 40 2037 46 2387 40 2060 41 41 59 125 360 123 2060 61 2057 46 2059 59 2058 61 2057 46 2059 59 2023 46 2388 40 648 41 59 2024 46 2388 40 648 41 59 125 392 40 2051 46 2389 40 41 614 1501 41 123 2024 46 2390 40 2051 46 2372 40 41 46 2391 40 41 46 2392 40 41 46 2393 40 41 46 2374 40 41 41 59 2024 46 2394 40 424 41 59 125 360 123 404 2395 61 2396 46 2397 40 1502 44 1503 47 2051 46 2389 40 41 41 59 2055 2398 61 2051 46 2372 40 41 46 2373 40 2381 45 62 2399 46 2400 40 2381 46 2374 40 41 44 2395 41 41 46 2375 40 2376 46 2401 40 648 41 41 59 2055 2402 61 2403 46 2404 40 648 44 2398 41 59 2024 46 2405 40 2402 41 59 2055 2406 61 2051 46 2372 40 41 46 2373 40 2009 58 58 2374 41 46 2375 40 2376 46 2401 40 648 41 41 59 2055 2407 61 2403 46 2404 40 648 44 2406 41 59 2024 46 2408 40 418 2409 40 2407 41 41 59 125 125 360 123 2410 40 41 59 125 125 437 492 2411 40 2009 2368 41 123 392 40 2368 46 2412 40 41 631 424 41 2413 46 2414 40 2039 46 2415 40 41 46 2416 43 2368 46 2412 40 41 44 380 41 59 125 621 621 621 437 492 2417 40 41 123 2045 46 2418 40 2009 58 58 2419 41 59 2045 46 2420 40 2029 46 2421 40 41 46 2422 40 2423 45 62 418 2009 40 2423 44 2029 44 2037 41 41 46 2424 40 2425 46 2426 40 41 41 41 59 2218 40 41 59 125 437 492 2427 40 2057 2428 44 2057 2429 44 2430 60 2431 62 2432 41 123 392 40 2029 46 2433 40 41 41 123 2434 46 2435 40 40 41 45 62 2043 46 2436 40 2437 45 62 2438 40 2428 44 2429 44 2437 44 2432 41 41 46 2439 40 41 44 1504 44 2440 46 2441 41 59 125 360 123 2442 40 2428 44 2429 44 424 44 2432 41 59 125 125 437 492 2443 40 2057 2428 44 2057 2429 44 2444 2445 44 2430 60 2431 62 2432 41 123 474 123 2055 2446 61 2026 46 2447 40 41 59 392 40 2446 46 2448 40 41 41 123 2446 61 424 59 125 2431 2449 61 2029 46 2450 40 2056 44 2025 46 2447 40 41 44 2428 44 2429 44 424 44 2445 44 2446 44 2432 41 59 2451 40 41 59 2417 40 41 59 125 329 40 2452 2453 41 123 418 2454 40 41 46 494 40 2455 46 2456 40 648 41 41 46 2457 40 41 59 125 329 40 2458 46 2459 2453 41 123 418 2460 40 41 46 494 40 2461 46 2462 40 648 44 2037 46 2463 40 2464 46 2465 40 41 41 41 41 46 2466 40 41 59 125 329 40 2467 2453 41 123 418 2468 40 41 46 371 40 2453 46 2469 40 41 41 46 2470 40 41 59 125 329 40 2471 2453 41 123 2472 46 2473 40 2453 46 2474 40 41 41 59 418 2475 40 41 46 494 40 2476 46 2477 40 648 41 43 648 43 2453 46 2474 40 41 41 46 2478 40 41 59 125 329 40 2479 2453 41 123 2480 46 2481 40 2453 46 2482 40 41 41 59 418 2483 40 41 46 494 40 2453 46 2482 40 41 41 46 2484 40 41 59 125 125 437 492 2485 40 41 123 2024 46 2486 40 648 41 59 2024 46 2487 40 2488 46 2489 40 648 41 41 59 2024 46 2490 40 424 41 59 2058 61 2057 46 2059 59 2060 61 2057 46 2059 59 2023 46 2486 40 648 41 59 2023 46 2487 40 2488 46 2489 40 648 41 41 59 2025 46 2486 40 648 41 59 2025 46 2487 40 2488 46 2489 40 648 41 41 59 2026 46 2486 40 648 41 59 2026 46 2487 40 2488 46 2489 40 648 41 41 59 2051 46 2491 40 41 59 2010 46 2492 40 41 46 2493 40 41 59 125 437 324 2494 40 2057 2495 41 123 392 40 33 2495 46 2496 40 41 41 123 418 2497 40 41 46 494 40 2498 46 2499 40 648 41 41 46 2500 40 41 59 450 380 59 125 392 40 33 2041 46 2501 40 2025 46 2502 40 41 41 46 2503 41 123 418 2504 40 41 46 494 40 2505 46 2506 40 648 41 41 46 2507 40 41 59 450 380 59 125 392 40 33 2058 46 2496 40 41 41 123 418 2508 40 41 46 494 40 2509 46 2510 40 648 41 41 46 2511 40 41 59 450 380 59 125 392 40 2495 46 2512 40 2058 41 62 1500 41 123 418 2513 40 41 46 494 40 2514 46 2515 40 648 41 41 46 2516 40 41 59 450 380 59 125 450 473 59 125 621 621 621 437 492 2517 40 41 123 2012 46 2518 40 40 2519 41 45 62 418 2520 60 62 40 2519 46 2521 40 41 41 41 59 2012 46 2522 40 418 2523 60 62 40 41 123 64 2088 439 2524 60 2009 44 2009 62 2525 40 2011 60 2009 44 2009 62 2526 41 123 450 418 2524 60 62 40 41 123 437 2527 2528 59 64 2088 439 492 2529 40 381 2009 2368 44 324 362 41 123 463 46 2529 40 2368 44 362 41 59 392 40 2368 631 424 605 33 362 41 123 2055 2530 61 2368 46 2531 40 41 59 2528 61 418 2532 40 2530 41 59 2528 46 2533 40 373 45 62 2411 40 2368 41 41 59 2528 46 2534 40 418 2535 40 2536 46 2537 40 648 44 2530 41 41 41 59 2538 40 2539 46 2540 41 59 2541 40 2528 41 59 125 360 123 2542 40 424 41 59 392 40 2528 631 424 41 2528 46 2543 40 424 41 59 125 125 125 59 125 125 41 59 125 437 492 2544 40 41 123 2013 46 2545 40 41 46 2546 40 648 41 59 2013 46 2547 40 40 2548 41 45 62 418 2549 60 62 40 2548 46 2550 40 41 41 41 59 2013 46 2551 40 418 2552 60 62 40 41 123 64 2088 439 2553 60 2009 44 2009 62 2554 40 2011 60 2009 44 2009 62 2555 41 123 450 418 2553 60 62 40 41 123 64 2088 439 492 2556 40 381 2009 2368 44 324 362 41 123 463 46 2556 40 2368 44 362 41 59 2557 40 40 2368 631 424 605 33 362 41 63 2368 46 2558 40 41 58 424 41 59 125 125 59 125 125 41 59 125 437 492 2559 40 41 123 2014 46 2560 40 41 46 2561 40 648 41 59 2014 46 2562 40 40 2563 41 45 62 418 2564 60 62 40 2563 46 2565 40 41 41 41 59 2014 46 2566 40 418 2567 60 62 40 41 123 64 2088 439 2568 60 2009 44 2009 62 2569 40 2011 60 2009 44 2009 62 2570 41 123 450 418 2568 60 62 40 41 123 2571 2572 61 418 2573 40 41 59 64 2088 439 492 2574 40 381 2009 2368 44 324 362 41 123 463 46 2574 40 2368 44 362 41 59 392 40 2368 631 424 605 33 362 41 123 2572 46 2575 40 2576 45 62 123 2368 46 2577 40 2572 46 2578 40 41 41 59 2367 40 2368 41 59 621 392 40 2045 46 2579 40 41 614 2051 46 2579 40 41 41 123 2074 46 2580 40 2016 41 59 125 360 123 621 621 2074 46 2581 40 41 46 2582 40 2069 41 59 2074 46 2583 40 2017 41 59 2078 46 2584 40 380 41 59 2074 46 2581 40 41 46 2585 40 2069 41 59 125 125 41 59 2586 40 2572 41 59 2572 46 2587 40 2368 46 2588 40 41 41 59 125 360 123 2572 46 2589 40 424 41 59 2590 40 424 41 59 125 125 125 59 125 125 41 59 125 125 
29302,Java,"public class JavacNode extends lombok.core.LombokNode<JavacAST, JavacNode, JCTree> {
	private JavacAST ast;
	/**
	 * Passes through to the parent constructor.
	 */
	public JavacNode(JavacAST ast, JCTree node, List<JavacNode> children, Kind kind) {
		super(node, children, kind);
		this.ast = ast;
	}
	
	@Override 
	public JavacAST getAst() {
		return ast;
	}
	
	public Element getElement() {
		if (node instanceof JCClassDecl) return ((JCClassDecl) node).sym;
		if (node instanceof JCMethodDecl) return ((JCMethodDecl) node).sym;
		if (node instanceof JCVariableDecl) return ((JCVariableDecl) node).sym;
		return null;
	}
	
	public int getEndPosition(DiagnosticPosition pos) {
		JCCompilationUnit cu = (JCCompilationUnit) top().get();
		return Javac.getEndPosition(pos, cu);
	}
	
	public int getEndPosition() {
		return getEndPosition(node);
	}
	
	/**
	 * Visits this node and all child nodes depth-first, calling the provided visitor's visit methods.
	 */
	public void traverse(JavacASTVisitor visitor) {
		switch (this.getKind()) {
		case COMPILATION_UNIT:
			visitor.visitCompilationUnit(this, (JCCompilationUnit) get());
			ast.traverseChildren(visitor, this);
			visitor.endVisitCompilationUnit(this, (JCCompilationUnit) get());
			break;
		case TYPE:
			visitor.visitType(this, (JCClassDecl) get());
			ast.traverseChildren(visitor, this);
			visitor.endVisitType(this, (JCClassDecl) get());
			break;
		case FIELD:
			visitor.visitField(this, (JCVariableDecl) get());
			ast.traverseChildren(visitor, this);
			visitor.endVisitField(this, (JCVariableDecl) get());
			break;
		case METHOD:
			visitor.visitMethod(this, (JCMethodDecl) get());
			ast.traverseChildren(visitor, this);
			visitor.endVisitMethod(this, (JCMethodDecl) get());
			break;
		case INITIALIZER:
			visitor.visitInitializer(this, (JCBlock) get());
			ast.traverseChildren(visitor, this);
			visitor.endVisitInitializer(this, (JCBlock) get());
			break;
		case ARGUMENT:
			JCMethodDecl parentMethod = (JCMethodDecl) up().get();
			visitor.visitMethodArgument(this, (JCVariableDecl) get(), parentMethod);
			ast.traverseChildren(visitor, this);
			visitor.endVisitMethodArgument(this, (JCVariableDecl) get(), parentMethod);
			break;
		case LOCAL:
			visitor.visitLocal(this, (JCVariableDecl) get());
			ast.traverseChildren(visitor, this);
			visitor.endVisitLocal(this, (JCVariableDecl) get());
			break;
		case STATEMENT:
			visitor.visitStatement(this, get());
			ast.traverseChildren(visitor, this);
			visitor.endVisitStatement(this, get());
			break;
		case ANNOTATION:
			switch (up().getKind()) {
			case TYPE:
				visitor.visitAnnotationOnType((JCClassDecl) up().get(), this, (JCAnnotation) get());
				break;
			case FIELD:
				visitor.visitAnnotationOnField((JCVariableDecl) up().get(), this, (JCAnnotation) get());
				break;
			case METHOD:
				visitor.visitAnnotationOnMethod((JCMethodDecl) up().get(), this, (JCAnnotation) get());
				break;
			case ARGUMENT:
				JCVariableDecl argument = (JCVariableDecl) up().get();
				JCMethodDecl method = (JCMethodDecl) up().up().get();
				visitor.visitAnnotationOnMethodArgument(argument, method, this, (JCAnnotation) get());
				break;
			case LOCAL:
				visitor.visitAnnotationOnLocal((JCVariableDecl) up().get(), this, (JCAnnotation) get());
				break;
			case TYPE_USE:
				visitor.visitAnnotationOnTypeUse(up().get(), this, (JCAnnotation) get());
				break;
			default:
				throw new AssertionError(""Annotion not expected as child of a "" + up().getKind());
			}
			break;
		case TYPE_USE:
			visitor.visitTypeUse(this, get());
			ast.traverseChildren(visitor, this);
			visitor.endVisitTypeUse(this, get());
			break;
		default:
			throw new AssertionError(""Unexpected kind during node traversal: "" + getKind());
		}
	}
	
	/** {@inheritDoc} */
	@Override public String getName() {
		final Name n;
		
		if (node instanceof JCClassDecl) n = ((JCClassDecl) node).name;
		else if (node instanceof JCMethodDecl) n = ((JCMethodDecl) node).name;
		else if (node instanceof JCVariableDecl) n = ((JCVariableDecl) node).name;
		else n = null;
		
		return n == null ? null : n.toString();
	}
	
	/** {@inheritDoc} */
	@Override protected boolean calculateIsStructurallySignificant(JCTree parent) {
		if (node instanceof JCClassDecl) return true;
		if (node instanceof JCMethodDecl) return true;
		if (node instanceof JCVariableDecl) return true;
		if (node instanceof JCCompilationUnit) return true;
		//Static and instance initializers
		if (node instanceof JCBlock) return parent instanceof JCClassDecl;
		
		return false;
	}
	
	/**
	 * Convenient shortcut to the owning JavacAST object's getTreeMaker method.
	 * 
	 * @see JavacAST#getTreeMaker()
	 */
	public JavacTreeMaker getTreeMaker() {
		return ast.getTreeMaker();
	}
	
	/**
	 * Convenient shortcut to the owning JavacAST object's getSymbolTable method.
	 * 
	 * @see JavacAST#getSymbolTable()
	 */
	public Symtab getSymbolTable() {
		return ast.getSymbolTable();
	}
	
	/**
	 * Convenient shortcut to the owning JavacAST object's getTypesUtil method.
	 * 
	 * @see JavacAST#getTypesUtil()
	 */
	public JavacTypes getTypesUtil() {
		return ast.getTypesUtil();
	}
	
	/**
	 * Convenient shortcut to the owning JavacAST object's getContext method.
	 * 
	 * @see JavacAST#getContext()
	 */
	public Context getContext() {
		return ast.getContext();
	}
	
	public boolean shouldDeleteLombokAnnotations() {
		return LombokOptions.shouldDeleteLombokAnnotations(ast.getContext());
	}
	
	/**
	 * Convenient shortcut to the owning JavacAST object's toName method.
	 * 
	 * @see JavacAST#toName(String)
	 */
	public Name toName(String name) {
		return ast.toName(name);
	}
	
	public void removeDeferredErrors() {
		ast.removeDeferredErrors(this);
	}
	
	/**
	 * Generates an compiler error focused on the AST node represented by this node object.
	 */
	@Override public void addError(String message) {
		ast.printMessage(Diagnostic.Kind.ERROR, message, this, null, true);
	}
	
	/**
	 * Generates an compiler error focused on the AST node represented by this node object.
	 */
	public void addError(String message, DiagnosticPosition pos) {
		ast.printMessage(Diagnostic.Kind.ERROR, message, null, pos, true);
	}
	
	/**
	 * Generates a compiler warning focused on the AST node represented by this node object.
	 */
	@Override public void addWarning(String message) {
		ast.printMessage(Diagnostic.Kind.WARNING, message, this, null, false);
	}
	
	/**
	 * Generates a compiler warning focused on the AST node represented by this node object.
	 */
	public void addWarning(String message, DiagnosticPosition pos) {
		ast.printMessage(Diagnostic.Kind.WARNING, message, null, pos, false);
	}
	
	@Override public boolean hasAnnotation(Class<? extends Annotation> type) {
		return JavacHandlerUtil.hasAnnotationAndDeleteIfNeccessary(type, this);
	}
	
	@Override public <Z extends Annotation> AnnotationValues<Z> findAnnotation(Class<Z> type) {
		JavacNode annotation = JavacHandlerUtil.findAnnotation(type, this, true);
		if (annotation == null) return null;
		return JavacHandlerUtil.createAnnotation(type, annotation);
	}
	
	private JCModifiers getModifiers() {
		if (node instanceof JCClassDecl) return ((JCClassDecl) node).getModifiers();
		if (node instanceof JCMethodDecl) return ((JCMethodDecl) node).getModifiers();
		if (node instanceof JCVariableDecl) return ((JCVariableDecl) node).getModifiers();
		return null;
	}
	
	@Override public boolean isStatic() {
		if (node instanceof JCClassDecl) {
			JCClassDecl t = (JCClassDecl) node;
			long f = t.mods.flags;
			if (((Flags.INTERFACE | Flags.ENUM) & f) != 0) return true;
			JavacNode directUp = directUp();
			if (directUp == null || directUp.getKind() == Kind.COMPILATION_UNIT) return true;
			if (!(directUp.get() instanceof JCClassDecl)) return false;
			JCClassDecl p = (JCClassDecl) directUp.get();
			f = p.mods.flags;
			if (((Flags.INTERFACE | Flags.ENUM) & f) != 0) return true;
		}
		
		if (node instanceof JCVariableDecl) {
			JavacNode directUp = directUp();
			if (directUp != null && directUp.get() instanceof JCClassDecl) {
				JCClassDecl p = (JCClassDecl) directUp.get();
				long f = p.mods.flags;
				if ((Flags.INTERFACE & f) != 0) return true;
			}
		}
		
		JCModifiers mods = getModifiers();
		if (mods == null) return false;
		return (mods.flags & Flags.STATIC) != 0;
	}
	
	@Override public boolean isFinal() {
		if (node instanceof JCVariableDecl) {
			JavacNode directUp = directUp();
			if (directUp != null && directUp.get() instanceof JCClassDecl) {
				JCClassDecl p = (JCClassDecl) directUp.get();
				long f = p.mods.flags;
				if (((Flags.INTERFACE | Flags.ENUM) & f) != 0) return true;
			}
			
		}
		JCModifiers mods = getModifiers();
		return mods != null && (Flags.FINAL & mods.flags) != 0;
	}
	
	@Override public boolean isEnumMember() {
		if (getKind() != Kind.FIELD) return false;
		JCModifiers mods = getModifiers();
		return mods != null && (Flags.ENUM & mods.flags) != 0;
	}
	
	@Override public boolean isEnumType() {
		if (getKind() != Kind.TYPE) return false;
		JCModifiers mods = getModifiers();
		return mods != null && (Flags.ENUM & mods.flags) != 0;
	}
	
	@Override public boolean isPrimitive() {
		if (node instanceof JCVariableDecl && !isEnumMember()) {
			return Javac.isPrimitive(((JCVariableDecl) node).vartype);
		}
		if (node instanceof JCMethodDecl) {
			return Javac.isPrimitive(((JCMethodDecl) node).restype);
		}
		return false;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override public String fieldOrMethodBaseType() {
		if (node instanceof JCVariableDecl && !isEnumMember()) {
			return (((JCVariableDecl) node).vartype).toString();
		}
		if (node instanceof JCMethodDecl) {
			return (((JCMethodDecl) node).restype).toString();
		}
		return null;
	}
	
	@Override public boolean isTransient() {
		if (getKind() != Kind.FIELD) return false;
		JCModifiers mods = getModifiers();
		return mods != null && (Flags.TRANSIENT & mods.flags) != 0;
	}
	
	@Override public int countMethodParameters() {
		if (getKind() != Kind.METHOD) return 0;
		
		com.sun.tools.javac.util.List<JCVariableDecl> params = ((JCMethodDecl) node).params;
		if (params == null) return 0;
		return params.size();
	}
	
	@Override public int getStartPos() {
		return node.getPreferredPosition();
	}
}",1,439 334 2000 378 2001 46 2002 46 2003 60 2004 44 2000 44 2005 62 123 437 2004 2006 59 618 439 2000 40 2004 2006 44 2005 2007 44 2008 60 2000 62 2009 44 2010 2011 41 123 463 40 2007 44 2009 44 2011 41 59 467 46 2006 61 2006 59 125 64 2012 439 2004 2013 40 41 123 450 2006 59 125 439 2014 2015 40 41 123 392 40 2007 402 2016 41 450 40 40 2016 41 2007 41 46 2017 59 392 40 2007 402 2018 41 450 40 40 2018 41 2007 41 46 2017 59 392 40 2007 402 2019 41 450 40 40 2019 41 2007 41 46 2017 59 450 424 59 125 439 404 2020 40 2021 2022 41 123 2023 2024 61 40 2023 41 2025 40 41 46 2026 40 41 59 450 2027 46 2020 40 2022 44 2024 41 59 125 439 404 2020 40 41 123 450 2020 40 2007 41 59 125 618 439 492 2028 40 2029 2030 41 123 464 40 467 46 2031 40 41 41 123 328 2032 58 2030 46 2033 40 467 44 40 2034 41 2035 40 41 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2037 40 467 44 40 2034 41 2035 40 41 41 59 325 59 328 2038 58 2030 46 2039 40 467 44 40 2040 41 2035 40 41 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2041 40 467 44 40 2040 41 2035 40 41 41 59 325 59 328 2042 58 2030 46 2043 40 467 44 40 2044 41 2035 40 41 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2045 40 467 44 40 2044 41 2035 40 41 41 59 325 59 328 2046 58 2030 46 2047 40 467 44 40 2048 41 2035 40 41 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2049 40 467 44 40 2048 41 2035 40 41 41 59 325 59 328 2050 58 2030 46 2051 40 467 44 40 2052 41 2035 40 41 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2053 40 467 44 40 2052 41 2035 40 41 41 59 325 59 328 2054 58 2048 2055 61 40 2048 41 2056 40 41 46 2035 40 41 59 2030 46 2057 40 467 44 40 2044 41 2035 40 41 44 2055 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2058 40 467 44 40 2044 41 2035 40 41 44 2055 41 59 325 59 328 2059 58 2030 46 2060 40 467 44 40 2044 41 2035 40 41 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2061 40 467 44 40 2044 41 2035 40 41 41 59 325 59 328 2062 58 2030 46 2063 40 467 44 2035 40 41 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2064 40 467 44 2035 40 41 41 59 325 59 328 2065 58 464 40 2056 40 41 46 2031 40 41 41 123 328 2038 58 2030 46 2066 40 40 2040 41 2056 40 41 46 2035 40 41 44 467 44 40 2067 41 2035 40 41 41 59 325 59 328 2042 58 2030 46 2068 40 40 2044 41 2056 40 41 46 2035 40 41 44 467 44 40 2067 41 2035 40 41 41 59 325 59 328 2046 58 2030 46 2069 40 40 2048 41 2056 40 41 46 2035 40 41 44 467 44 40 2067 41 2035 40 41 41 59 325 59 328 2054 58 2044 2070 61 40 2044 41 2056 40 41 46 2035 40 41 59 2048 2071 61 40 2048 41 2056 40 41 46 2056 40 41 46 2035 40 41 59 2030 46 2072 40 2070 44 2071 44 467 44 40 2067 41 2035 40 41 41 59 325 59 328 2059 58 2030 46 2073 40 40 2044 41 2056 40 41 46 2035 40 41 44 467 44 40 2067 41 2035 40 41 41 59 325 59 328 2074 58 2030 46 2075 40 2056 40 41 46 2035 40 41 44 467 44 40 2067 41 2035 40 41 41 59 325 59 349 58 469 418 2076 40 648 43 2056 40 41 46 2031 40 41 41 59 125 325 59 328 2077 58 2030 46 2078 40 467 44 2035 40 41 41 59 2006 46 2036 40 2030 44 467 41 59 2030 46 2079 40 467 44 2035 40 41 41 59 325 59 349 58 469 418 2080 40 648 43 2031 40 41 41 59 125 125 618 64 2012 439 2081 2082 40 41 123 381 2083 2084 59 392 40 2007 402 2085 41 2084 61 40 40 2085 41 2007 41 46 2086 59 360 392 40 2007 402 2087 41 2084 61 40 40 2087 41 2007 41 46 2086 59 360 392 40 2007 402 2088 41 2084 61 40 40 2088 41 2007 41 46 2086 59 360 2084 61 424 59 450 2084 614 424 63 424 58 2084 46 2089 40 41 59 125 618 64 2012 438 324 2090 40 2005 2091 41 123 392 40 2007 402 2092 41 450 473 59 392 40 2007 402 2093 41 450 473 59 392 40 2007 402 2094 41 450 473 59 392 40 2007 402 2095 41 450 473 59 621 392 40 2007 402 2096 41 450 2091 402 2092 59 450 380 59 125 618 439 2097 2098 40 41 123 450 2006 46 2098 40 41 59 125 618 439 2099 2100 40 41 123 450 2006 46 2100 40 41 59 125 618 439 2101 2102 40 41 123 450 2006 46 2102 40 41 59 125 618 439 2103 2104 40 41 123 450 2006 46 2104 40 41 59 125 439 324 2105 40 41 123 450 2106 46 2105 40 2006 46 2104 40 41 41 59 125 618 439 2107 2108 40 2081 2109 41 123 450 2006 46 2108 40 2109 41 59 125 439 492 2110 40 41 123 2006 46 2110 40 467 41 59 125 618 64 2012 439 492 2111 40 2081 2112 41 123 2006 46 2113 40 2114 46 2010 46 2115 44 2112 44 467 44 424 44 473 41 59 125 618 439 492 2111 40 2081 2112 44 2021 2022 41 123 2006 46 2116 40 2117 46 2010 46 2118 44 2112 44 424 44 2022 44 473 41 59 125 618 64 2012 439 492 2119 40 2081 2112 41 123 2006 46 2120 40 2121 46 2010 46 2122 44 2112 44 467 44 424 44 380 41 59 125 618 439 492 2119 40 2081 2112 44 2021 2022 41 123 2006 46 2123 40 2124 46 2010 46 2125 44 2112 44 424 44 2022 44 380 41 59 125 64 2012 439 324 2126 40 2127 60 63 378 2128 62 2129 41 123 450 2130 46 2131 40 2129 44 467 41 59 125 64 2012 439 60 2132 378 2128 62 2133 60 2132 62 2134 40 2127 60 2132 62 2129 41 123 2000 2135 61 2136 46 2134 40 2129 44 467 44 473 41 59 392 40 2135 614 424 41 450 424 59 450 2136 46 2137 40 2129 44 2135 41 59 125 437 2138 2139 40 41 123 392 40 2007 402 2140 41 450 40 40 2140 41 2007 41 46 2139 40 41 59 392 40 2007 402 2141 41 450 40 40 2141 41 2007 41 46 2139 40 41 59 392 40 2007 402 2142 41 450 40 40 2142 41 2007 41 46 2139 40 41 59 450 424 59 125 64 2012 439 324 2143 40 41 123 392 40 2007 402 2144 41 123 2144 2145 61 40 2144 41 2007 59 413 2146 61 2145 46 2147 46 2148 59 392 40 40 40 2149 46 2150 124 2149 46 2151 41 38 2146 41 631 1500 41 450 473 59 2000 2152 61 2152 40 41 59 392 40 2152 614 424 606 2152 46 2153 40 41 614 2010 46 2154 41 450 473 59 392 40 33 40 2152 46 2155 40 41 402 2144 41 41 450 380 59 2144 2156 61 40 2144 41 2152 46 2155 40 41 59 2146 61 2156 46 2147 46 2148 59 392 40 40 40 2149 46 2150 124 2149 46 2151 41 38 2146 41 631 1500 41 450 473 59 125 392 40 2007 402 2157 41 123 2000 2158 61 2158 40 41 59 392 40 2158 631 424 605 2158 46 2159 40 41 402 2144 41 123 2144 2160 61 40 2144 41 2158 46 2159 40 41 59 413 2161 61 2160 46 2162 46 2163 59 392 40 40 2164 46 2165 38 2161 41 631 1500 41 450 473 59 125 125 2138 2166 61 2139 40 41 59 392 40 2166 614 424 41 450 380 59 450 40 2166 46 2167 38 2168 46 2169 41 631 1500 59 125 64 2012 439 324 2170 40 41 123 392 40 2007 402 2171 41 123 2000 2172 61 2172 40 41 59 392 40 2172 631 424 605 2172 46 2173 40 41 402 2174 41 123 2174 2175 61 40 2174 41 2172 46 2173 40 41 59 413 2176 61 2175 46 2177 46 2178 59 392 40 40 40 2179 46 2180 124 2179 46 2181 41 38 2176 41 631 1500 41 450 473 59 125 125 2138 2182 61 2139 40 41 59 450 2182 631 424 605 40 2183 46 2184 38 2182 46 2185 41 631 1500 59 125 64 2012 439 324 2186 40 41 123 392 40 2187 40 41 631 2010 46 2188 41 450 380 59 2138 2189 61 2139 40 41 59 450 2189 631 424 605 40 2190 46 2191 38 2189 46 2192 41 631 1500 59 125 64 2012 439 324 2193 40 41 123 392 40 2194 40 41 631 2010 46 2195 41 450 380 59 2138 2196 61 2139 40 41 59 450 2196 631 424 605 40 2197 46 2198 38 2196 46 2199 41 631 1500 59 125 64 2012 439 324 2200 40 41 123 392 40 2007 402 2201 605 33 2186 40 41 41 123 450 2202 46 2200 40 40 40 2201 41 2007 41 46 2203 41 59 125 392 40 2007 402 2204 41 123 450 2205 46 2200 40 40 40 2204 41 2007 41 46 2206 41 59 125 450 380 59 125 618 64 2012 439 2081 2207 40 41 123 392 40 2007 402 2208 605 33 2186 40 41 41 123 450 40 40 40 2208 41 2007 41 46 2209 41 46 2210 40 41 59 125 392 40 2007 402 2211 41 123 450 40 40 40 2211 41 2007 41 46 2212 41 46 2213 40 41 59 125 450 424 59 125 64 2012 439 324 2214 40 41 123 392 40 2215 40 41 631 2010 46 2216 41 450 380 59 2138 2217 61 2139 40 41 59 450 2217 631 424 605 40 2218 46 2219 38 2217 46 2220 41 631 1500 59 125 64 2012 439 404 2221 40 41 123 392 40 2222 40 41 631 2010 46 2223 41 450 1500 59 2224 46 2225 46 2226 46 2227 46 2228 46 2008 60 2229 62 433 61 40 40 2230 41 2007 41 46 433 59 392 40 433 614 424 41 450 1500 59 450 433 46 2231 40 41 59 125 64 2012 439 404 2232 40 41 123 450 2007 46 2233 40 41 59 125 125 
4357,Java,"@Slf4j
@Data
@AllArgsConstructor
public class UserPayload implements PersistableEnvelope {
    @Nullable
    private String accountId;
    @Nullable
    private Set<PaymentAccount> paymentAccounts = new HashSet<>();
    @Nullable
    private PaymentAccount currentPaymentAccount;
    @Nullable
    private List<String> acceptedLanguageLocaleCodes = new ArrayList<>();
    @Nullable
    private Alert developersAlert;
    @Nullable
    private Alert displayedAlert;
    @Nullable
    private Filter developersFilter;
    @Nullable
    private Arbitrator registeredArbitrator;
    @Nullable
    private Mediator registeredMediator;
    @Nullable
    private List<Arbitrator> acceptedArbitrators = new ArrayList<>();
    @Nullable
    private List<Mediator> acceptedMediators = new ArrayList<>();
    @Nullable
    private PriceAlertFilter priceAlertFilter;
    @Nullable
    private List<MarketAlertFilter> marketAlertFilters = new ArrayList<>();

    // Added v1.2.0
    @Nullable
    private RefundAgent registeredRefundAgent;
    @Nullable
    private List<RefundAgent> acceptedRefundAgents = new ArrayList<>();

    // Added at 1.5.3
    // Generic map for persisting various UI states. We keep values un-typed as string to
    // provide sufficient flexibility.
    private Cookie cookie = new Cookie();

    public UserPayload() {
    }

    @Override
    public protobuf.PersistableEnvelope toProtoMessage() {
        protobuf.UserPayload.Builder builder = protobuf.UserPayload.newBuilder();
        Optional.ofNullable(accountId).ifPresent(e -> builder.setAccountId(accountId));
        Optional.ofNullable(paymentAccounts)
                .ifPresent(e -> builder.addAllPaymentAccounts(ProtoUtil.collectionToProto(paymentAccounts, protobuf.PaymentAccount.class)));
        Optional.ofNullable(currentPaymentAccount)
                .ifPresent(e -> builder.setCurrentPaymentAccount(currentPaymentAccount.toProtoMessage()));
        Optional.ofNullable(acceptedLanguageLocaleCodes)
                .ifPresent(e -> builder.addAllAcceptedLanguageLocaleCodes(acceptedLanguageLocaleCodes));
        Optional.ofNullable(developersAlert)
                .ifPresent(developersAlert -> builder.setDevelopersAlert(developersAlert.toProtoMessage().getAlert()));
        Optional.ofNullable(displayedAlert)
                .ifPresent(displayedAlert -> builder.setDisplayedAlert(displayedAlert.toProtoMessage().getAlert()));
        Optional.ofNullable(developersFilter)
                .ifPresent(developersFilter -> builder.setDevelopersFilter(developersFilter.toProtoMessage().getFilter()));
        Optional.ofNullable(registeredArbitrator)
                .ifPresent(registeredArbitrator -> builder.setRegisteredArbitrator(registeredArbitrator.toProtoMessage().getArbitrator()));
        Optional.ofNullable(registeredMediator)
                .ifPresent(registeredMediator -> builder.setRegisteredMediator(registeredMediator.toProtoMessage().getMediator()));
        Optional.ofNullable(acceptedArbitrators)
                .ifPresent(e -> builder.addAllAcceptedArbitrators(ProtoUtil.collectionToProto(acceptedArbitrators,
                        message -> ((protobuf.StoragePayload) message).getArbitrator())));
        Optional.ofNullable(acceptedMediators)
                .ifPresent(e -> builder.addAllAcceptedMediators(ProtoUtil.collectionToProto(acceptedMediators,
                        message -> ((protobuf.StoragePayload) message).getMediator())));
        Optional.ofNullable(priceAlertFilter).ifPresent(priceAlertFilter -> builder.setPriceAlertFilter(priceAlertFilter.toProtoMessage()));
        Optional.ofNullable(marketAlertFilters)
                .ifPresent(e -> builder.addAllMarketAlertFilters(ProtoUtil.collectionToProto(marketAlertFilters, protobuf.MarketAlertFilter.class)));

        Optional.ofNullable(registeredRefundAgent)
                .ifPresent(registeredRefundAgent -> builder.setRegisteredRefundAgent(registeredRefundAgent.toProtoMessage().getRefundAgent()));
        Optional.ofNullable(acceptedRefundAgents)
                .ifPresent(e -> builder.addAllAcceptedRefundAgents(ProtoUtil.collectionToProto(acceptedRefundAgents,
                        message -> ((protobuf.StoragePayload) message).getRefundAgent())));
        Optional.ofNullable(cookie).ifPresent(e -> builder.putAllCookie(cookie.toProtoMessage()));
        return protobuf.PersistableEnvelope.newBuilder().setUserPayload(builder).build();
    }

    public static UserPayload fromProto(protobuf.UserPayload proto, CoreProtoResolver coreProtoResolver) {
        return new UserPayload(
                ProtoUtil.stringOrNullFromProto(proto.getAccountId()),
                proto.getPaymentAccountsList().isEmpty() ? new HashSet<>() : new HashSet<>(proto.getPaymentAccountsList().stream()
                        .map(e -> PaymentAccount.fromProto(e, coreProtoResolver))
                        .filter(Objects::nonNull)
                        .collect(Collectors.toSet())),
                proto.hasCurrentPaymentAccount() ? PaymentAccount.fromProto(proto.getCurrentPaymentAccount(), coreProtoResolver) : null,
                proto.getAcceptedLanguageLocaleCodesList().isEmpty() ? new ArrayList<>() : new ArrayList<>(proto.getAcceptedLanguageLocaleCodesList()),
                proto.hasDevelopersAlert() ? Alert.fromProto(proto.getDevelopersAlert()) : null,
                proto.hasDisplayedAlert() ? Alert.fromProto(proto.getDisplayedAlert()) : null,
                proto.hasDevelopersFilter() ? Filter.fromProto(proto.getDevelopersFilter()) : null,
                proto.hasRegisteredArbitrator() ? Arbitrator.fromProto(proto.getRegisteredArbitrator()) : null,
                proto.hasRegisteredMediator() ? Mediator.fromProto(proto.getRegisteredMediator()) : null,
                proto.getAcceptedArbitratorsList().isEmpty() ? new ArrayList<>() : new ArrayList<>(proto.getAcceptedArbitratorsList().stream()
                        .map(Arbitrator::fromProto)
                        .collect(Collectors.toList())),
                proto.getAcceptedMediatorsList().isEmpty() ? new ArrayList<>() : new ArrayList<>(proto.getAcceptedMediatorsList().stream()
                        .map(Mediator::fromProto)
                        .collect(Collectors.toList())),
                PriceAlertFilter.fromProto(proto.getPriceAlertFilter()),
                proto.getMarketAlertFiltersList().isEmpty() ? new ArrayList<>() : new ArrayList<>(proto.getMarketAlertFiltersList().stream()
                        .map(e -> MarketAlertFilter.fromProto(e, coreProtoResolver))
                        .collect(Collectors.toSet())),
                proto.hasRegisteredRefundAgent() ? RefundAgent.fromProto(proto.getRegisteredRefundAgent()) : null,
                proto.getAcceptedRefundAgentsList().isEmpty() ? new ArrayList<>() : new ArrayList<>(proto.getAcceptedRefundAgentsList().stream()
                        .map(RefundAgent::fromProto)
                        .collect(Collectors.toList())),
                Cookie.fromProto(proto.getCookieMap())
        );
    }
}",1,64 2000 64 2001 64 2002 439 334 2003 395 2004 123 64 2005 437 2006 2007 59 64 2005 437 2008 60 2009 62 2010 61 418 2011 60 62 40 41 59 64 2005 437 2009 2012 59 64 2005 437 2013 60 2006 62 2014 61 418 2015 60 62 40 41 59 64 2005 437 2016 2017 59 64 2005 437 2016 2018 59 64 2005 437 2019 2020 59 64 2005 437 2021 2022 59 64 2005 437 2023 2024 59 64 2005 437 2013 60 2021 62 2025 61 418 2015 60 62 40 41 59 64 2005 437 2013 60 2023 62 2026 61 418 2015 60 62 40 41 59 64 2005 437 2027 2028 59 64 2005 437 2013 60 2029 62 2030 61 418 2015 60 62 40 41 59 621 64 2005 437 2031 2032 59 64 2005 437 2013 60 2031 62 2033 61 418 2015 60 62 40 41 59 621 621 621 437 2034 2035 61 418 2034 40 41 59 439 2003 40 41 123 125 64 2036 439 2037 46 2004 2038 40 41 123 2037 46 2003 46 2039 2040 61 2037 46 2003 46 2041 40 41 59 2042 46 2043 40 2007 41 46 2044 40 2045 45 62 2040 46 2046 40 2007 41 41 59 2042 46 2043 40 2010 41 46 2044 40 2045 45 62 2040 46 2047 40 2048 46 2049 40 2010 44 2037 46 2009 46 334 41 41 41 59 2042 46 2043 40 2012 41 46 2044 40 2045 45 62 2040 46 2050 40 2012 46 2038 40 41 41 41 59 2042 46 2043 40 2014 41 46 2044 40 2045 45 62 2040 46 2051 40 2014 41 41 59 2042 46 2043 40 2017 41 46 2044 40 2017 45 62 2040 46 2052 40 2017 46 2038 40 41 46 2053 40 41 41 41 59 2042 46 2043 40 2018 41 46 2044 40 2018 45 62 2040 46 2054 40 2018 46 2038 40 41 46 2053 40 41 41 41 59 2042 46 2043 40 2020 41 46 2044 40 2020 45 62 2040 46 2055 40 2020 46 2038 40 41 46 2056 40 41 41 41 59 2042 46 2043 40 2022 41 46 2044 40 2022 45 62 2040 46 2057 40 2022 46 2038 40 41 46 2058 40 41 41 41 59 2042 46 2043 40 2024 41 46 2044 40 2024 45 62 2040 46 2059 40 2024 46 2038 40 41 46 2060 40 41 41 41 59 2042 46 2043 40 2025 41 46 2044 40 2045 45 62 2040 46 2061 40 2048 46 2049 40 2025 44 2062 45 62 40 40 2037 46 2063 41 2062 41 46 2058 40 41 41 41 41 59 2042 46 2043 40 2026 41 46 2044 40 2045 45 62 2040 46 2064 40 2048 46 2049 40 2026 44 2062 45 62 40 40 2037 46 2063 41 2062 41 46 2060 40 41 41 41 41 59 2042 46 2043 40 2028 41 46 2044 40 2028 45 62 2040 46 2065 40 2028 46 2038 40 41 41 41 59 2042 46 2043 40 2030 41 46 2044 40 2045 45 62 2040 46 2066 40 2048 46 2049 40 2030 44 2037 46 2029 46 334 41 41 41 59 2042 46 2043 40 2032 41 46 2044 40 2032 45 62 2040 46 2067 40 2032 46 2038 40 41 46 2068 40 41 41 41 59 2042 46 2043 40 2033 41 46 2044 40 2045 45 62 2040 46 2069 40 2048 46 2049 40 2033 44 2062 45 62 40 40 2037 46 2063 41 2062 41 46 2068 40 41 41 41 41 59 2042 46 2043 40 2035 41 46 2044 40 2045 45 62 2040 46 2070 40 2035 46 2038 40 41 41 41 59 450 2037 46 2004 46 2041 40 41 46 2071 40 2040 41 46 2072 40 41 59 125 439 457 2003 2073 40 2037 46 2003 2074 44 2075 2076 41 123 450 418 2003 40 2077 46 2078 40 2074 46 2079 40 41 41 44 2074 46 2080 40 41 46 2081 40 41 63 418 2011 60 62 40 41 58 418 2011 60 62 40 2074 46 2080 40 41 46 2082 40 41 46 2083 40 2084 45 62 2009 46 2073 40 2084 44 2076 41 41 46 2085 40 2086 58 58 2087 41 46 2088 40 2089 46 2090 40 41 41 41 44 2074 46 2091 40 41 63 2009 46 2073 40 2074 46 2092 40 41 44 2076 41 58 424 44 2074 46 2093 40 41 46 2081 40 41 63 418 2015 60 62 40 41 58 418 2015 60 62 40 2074 46 2093 40 41 41 44 2074 46 2094 40 41 63 2016 46 2073 40 2074 46 2095 40 41 41 58 424 44 2074 46 2096 40 41 63 2016 46 2073 40 2074 46 2097 40 41 41 58 424 44 2074 46 2098 40 41 63 2019 46 2073 40 2074 46 2099 40 41 41 58 424 44 2074 46 2100 40 41 63 2021 46 2073 40 2074 46 2101 40 41 41 58 424 44 2074 46 2102 40 41 63 2023 46 2073 40 2074 46 2103 40 41 41 58 424 44 2074 46 2104 40 41 46 2081 40 41 63 418 2015 60 62 40 41 58 418 2015 60 62 40 2074 46 2104 40 41 46 2082 40 41 46 2083 40 2021 58 58 2073 41 46 2088 40 2089 46 2105 40 41 41 41 44 2074 46 2106 40 41 46 2081 40 41 63 418 2015 60 62 40 41 58 418 2015 60 62 40 2074 46 2106 40 41 46 2082 40 41 46 2083 40 2023 58 58 2073 41 46 2088 40 2089 46 2105 40 41 41 41 44 2027 46 2073 40 2074 46 2107 40 41 41 44 2074 46 2108 40 41 46 2081 40 41 63 418 2015 60 62 40 41 58 418 2015 60 62 40 2074 46 2108 40 41 46 2082 40 41 46 2083 40 2084 45 62 2029 46 2073 40 2084 44 2076 41 41 46 2088 40 2089 46 2090 40 41 41 41 44 2074 46 2109 40 41 63 2031 46 2073 40 2074 46 2110 40 41 41 58 424 44 2074 46 2111 40 41 46 2081 40 41 63 418 2015 60 62 40 41 58 418 2015 60 62 40 2074 46 2111 40 41 46 2082 40 41 46 2083 40 2031 58 58 2073 41 46 2088 40 2089 46 2105 40 41 41 41 44 2034 46 2073 40 2074 46 2112 40 41 41 41 59 125 125 
29566,Java,"public class PatchVal {
	
	// This is half of the work for 'val' support - the other half is in PatchValEclipse. This half is enough for ecj.
	// Creates a copy of the 'initialization' field on a LocalDeclaration if the type of the LocalDeclaration is 'val', because the completion parser will null this out,
	// which in turn stops us from inferring the intended type for 'val x = 5;'. We look at the copy.
	// Also patches .resolve() on LocalDeclaration itself to just-in-time replace the 'val' vartype with the right one.
	
	public static boolean matches(String key, char[] array) {
		if (array == null || key.length() != array.length) return false;
		for (int i = 0; i < array.length; i++) {
			if (key.charAt(i) != array[i]) return false;
		}
		
		return true;
	}
	
	public static boolean couldBe(ImportBinding[] imports, String key, TypeReference ref) {
		String[] keyParts = key.split(""\\."");
		if (ref instanceof SingleTypeReference) {
			char[] token = ((SingleTypeReference)ref).token;
			if (!matches(keyParts[keyParts.length - 1], token)) return false;
			if (imports == null) return true;
			top:
			for (ImportBinding ib : imports) {
				ImportReference ir = ib.reference;
				if (ir == null) continue;
				if (ir.isStatic()) continue;
				boolean star = ((ir.bits & ASTNode.OnDemand) != 0);
				int len = keyParts.length - (star ? 1 : 0);
				char[][] t = ir.tokens;
				if (len != t.length) continue;
				for (int i = 0; i < len; i++) {
					if (keyParts[i].length() != t[i].length) continue top;
					for (int j = 0; j < t[i].length; j++) if (keyParts[i].charAt(j) != t[i][j]) continue top;
				}
				return true;
			}
			return false;
		}
		
		if (ref instanceof QualifiedTypeReference) {
			char[][] tokens = ((QualifiedTypeReference)ref).tokens;
			if (keyParts.length != tokens.length) return false;
			for(int i = 0; i < tokens.length; ++i) {
				String part = keyParts[i];
				char[] token = tokens[i];
				if (!matches(part, token)) return false;
			}
			return true;
		}
		
		return false;
	}
	
	public static boolean couldBe(ImportReference[] imports, String key, TypeReference ref) {
		String[] keyParts = key.split(""\\."");
		if (ref instanceof SingleTypeReference) {
			char[] token = ((SingleTypeReference) ref).token;
			if (!matches(keyParts[keyParts.length - 1], token)) return false;
			if (imports == null) return true;
			top:
			for (ImportReference ir : imports) {
				if (ir.isStatic()) continue;
				boolean star = ((ir.bits & ASTNode.OnDemand) != 0);
				int len = keyParts.length - (star ? 1 : 0);
				char[][] t = ir.tokens;
				if (len != t.length) continue;
				for (int i = 0; i < len; i++) {
					if (keyParts[i].length() != t[i].length) continue top;
					for (int j = 0; j < t[i].length; j++) if (keyParts[i].charAt(j) != t[i][j]) continue top;
				}
				return true;
			}
			return false;
		}
		
		if (ref instanceof QualifiedTypeReference) {
			char[][] tokens = ((QualifiedTypeReference) ref).tokens;
			if (keyParts.length != tokens.length) return false;
			for(int i = 0; i < tokens.length; ++i) {
				String part = keyParts[i];
				char[] token = tokens[i];
				if (!matches(part, token)) return false;
			}
			return true;
		}
		
		return false;
	}
	
	private static boolean is(TypeReference ref, BlockScope scope, String key) {
		Scope s = scope.parent;
		while (s != null && !(s instanceof CompilationUnitScope)) {
			Scope ns = s.parent;
			s = ns == s ? null : ns;
		}
		ImportBinding[] imports = null;
		if (s instanceof CompilationUnitScope) imports = ((CompilationUnitScope) s).imports;
		if (!couldBe(imports, key, ref)) return false;
		
		TypeBinding resolvedType = ref.resolvedType;
		if (resolvedType == null) resolvedType = ref.resolveType(scope, false);
		if (resolvedType == null) return false;
		
		char[] pkg = resolvedType.qualifiedPackageName();
		char[] nm = resolvedType.qualifiedSourceName();
		int pkgFullLength = pkg.length > 0 ? pkg.length + 1: 0;
		char[] fullName = new char[pkgFullLength + nm.length];
		if(pkg.length > 0) {
			System.arraycopy(pkg, 0, fullName, 0, pkg.length);
			fullName[pkg.length] = '.';
		}
		System.arraycopy(nm, 0, fullName, pkgFullLength, nm.length);
		return matches(key, fullName);
	}
	
	public static final class Reflection {
		private static final Field initCopyField, iterableCopyField;
		
		static {
			Field a = null, b = null;
			
			try {
				a = Permit.getField(LocalDeclaration.class, ""$initCopy"");
				b = Permit.getField(LocalDeclaration.class, ""$iterableCopy"");
			} catch (Throwable t) {
				//ignore - no $initCopy exists when running in ecj.
			}
			
			initCopyField = a;
			iterableCopyField = b;
		}
	}
	public static boolean handleValForLocalDeclaration(LocalDeclaration local, BlockScope scope) {
		if (local == null || !LocalDeclaration.class.equals(local.getClass())) return false;
		boolean decomponent = false;
		
		boolean val = isVal(local, scope);
		boolean var = isVar(local, scope);
		if (!(val || var)) return false;
		
		if (val) {
			StackTraceElement[] st = new Throwable().getStackTrace();
			for (int i = 0; i < st.length - 2 && i < 10; i++) {
				if (st[i].getClassName().equals(""lombok.launch.PatchFixesHider$Val"")) {
					boolean valInForStatement = 
						st[i + 1].getClassName().equals(""org.eclipse.jdt.internal.compiler.ast.LocalDeclaration"") &&
						st[i + 2].getClassName().equals(""org.eclipse.jdt.internal.compiler.ast.ForStatement"");
					if (valInForStatement) return false;
					break;
				}
			}
		}
		
		Expression init = local.initialization;
		if (init == null && Reflection.initCopyField != null) {
			try {
				init = (Expression) Reflection.initCopyField.get(local);
			} catch (Exception e) {
				// init remains null.
			}
		}
		
		if (init == null && Reflection.iterableCopyField != null) {
			try {
				init = (Expression) Reflection.iterableCopyField.get(local);
				decomponent = true;
			} catch (Exception e) {
				// init remains null.
			}
		}
		
		TypeReference replacement = null;
		
		// Java 10+: Lombok uses the native 'var' support and transforms 'val' to 'final var'.
		if (hasNativeVarSupport(scope) && val) {
			replacement = new SingleTypeReference(""var"".toCharArray(), pos(local.type));
			local.initialization = init;
			init = null;
		}
		
		if (init != null) {
			if (init.getClass().getName().equals(""org.eclipse.jdt.internal.compiler.ast.LambdaExpression"")) {
				return false;
			}
			
			TypeBinding resolved = null;
			try {
				resolved = decomponent ? getForEachComponentType(init, scope) : resolveForExpression(init, scope);
			} catch (NullPointerException e) {
				// This definitely occurs if as part of resolving the initializer expression, a
				// lambda expression in it must also be resolved (such as when lambdas are part of
				// a ternary expression). This can't result in a viable 'val' matching, so, we
				// just go with 'Object' and let the IDE print the appropriate errors.
				resolved = null;
			}
			
			if (resolved == null) {
				if (init instanceof ConditionalExpression) {
					ConditionalExpression cexp = (ConditionalExpression) init;
					Expression ifTrue = cexp.valueIfTrue;
					Expression ifFalse = cexp.valueIfFalse;
					TypeBinding ifTrueResolvedType = ifTrue.resolvedType;
					CompilationResult compilationResult = scope.referenceCompilationUnit().compilationResult;
					CategorizedProblem[] problems = compilationResult.problems;
					CategorizedProblem lastProblem = problems[compilationResult.problemCount - 1];
					if (ifTrueResolvedType != null && ifFalse.resolvedType == null && lastProblem.getCategoryID() == CAT_TYPE) {
						int problemCount = compilationResult.problemCount;
						for (int i = 0; i < problemCount; ++i) {
							if (problems[i] == lastProblem) {
								problems[i] = null;
								if (i + 1 < problemCount) {
									System.arraycopy(problems, i + 1, problems, i, problemCount - i + 1);
								}
								break;
							}
						}
						compilationResult.removeProblem(lastProblem);
						if (!compilationResult.hasErrors()) {
							clearIgnoreFurtherInvestigationField(scope.referenceContext());
							setValue(getField(CompilationResult.class, ""hasMandatoryErrors""), compilationResult, false);
						}
						
						if (ifFalse instanceof FunctionalExpression) {
							FunctionalExpression functionalExpression = (FunctionalExpression) ifFalse;
							functionalExpression.setExpectedType(ifTrueResolvedType);
						}
						if (ifFalse.resolvedType == null) {
							resolveForExpression(ifFalse, scope);
						}
						
						resolved = ifTrueResolvedType;
					}
				}
			}
			
			if (resolved != null) {
				try {
					replacement = makeType(resolved, local.type, false);
					if (!decomponent) init.resolvedType = replacement.resolveType(scope);
				} catch (Exception e) {
					// Some type thing failed.
				}
			}
		}
		
		if (val) local.modifiers |= ClassFileConstants.AccFinal;
		local.annotations = addValAnnotation(local.annotations, local.type, scope);
		local.type = replacement != null ? replacement : new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(local.type, 3));
		return false;
	}
	
	private static boolean isVar(LocalDeclaration local, BlockScope scope) {
		return is(local.type, scope, ""lombok.experimental.var"") || is(local.type, scope, ""lombok.var"");
	}
	
	private static boolean isVal(LocalDeclaration local, BlockScope scope) {
		return is(local.type, scope, ""lombok.val"");
	}
	
	private static boolean hasNativeVarSupport(Scope scope) {
		long sl = scope.problemReporter().options.sourceLevel >> 16;
		long cl = scope.problemReporter().options.complianceLevel >> 16;
		if (sl == 0) sl = cl;
		if (cl == 0) cl = sl;
		return Math.min((int)(sl - 44), (int)(cl - 44)) >= 10;
	}
	
	public static boolean handleValForForEach(ForeachStatement forEach, BlockScope scope) {
		if (forEach.elementVariable == null) return false;
		
		boolean val = isVal(forEach.elementVariable, scope);
		boolean var = isVar(forEach.elementVariable, scope);
		if (!(val || var)) return false;
		
		if (hasNativeVarSupport(scope)) return false;
		
		TypeBinding component = getForEachComponentType(forEach.collection, scope);
		if (component == null) return false;
		TypeReference replacement = makeType(component, forEach.elementVariable.type, false);
		
		if (val) forEach.elementVariable.modifiers |= ClassFileConstants.AccFinal;
		forEach.elementVariable.annotations = addValAnnotation(forEach.elementVariable.annotations, forEach.elementVariable.type, scope);
		forEach.elementVariable.type = replacement != null ? replacement :
			new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(forEach.elementVariable.type, 3));
		
		return false;
	}
	
	private static Annotation[] addValAnnotation(Annotation[] originals, TypeReference originalRef, BlockScope scope) {
		Annotation[] newAnn;
		if (originals != null) {
			newAnn = new Annotation[1 + originals.length];
			System.arraycopy(originals, 0, newAnn, 0, originals.length);
		} else {
			newAnn = new Annotation[1];
		}
		
		TypeReference qualifiedTypeRef = generateQualifiedTypeRef(originalRef, originalRef.getTypeName());
		newAnn[newAnn.length - 1] = new org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation(qualifiedTypeRef, qualifiedTypeRef.sourceStart);
		
		return newAnn;
	}
	
	private static TypeBinding getForEachComponentType(Expression collection, BlockScope scope) {
		if (collection != null) {
			TypeBinding resolved = collection.resolvedType;
			if (resolved == null) resolved = resolveForExpression(collection, scope);
			if (resolved == null) return null;
			if (resolved.isArrayType()) {
				resolved = ((ArrayBinding) resolved).elementsType();
				return resolved;
			} else if (resolved instanceof ReferenceBinding) {
				ReferenceBinding iterableType = ((ReferenceBinding) resolved).findSuperTypeOriginatingFrom(TypeIds.T_JavaLangIterable, false);
				
				TypeBinding[] arguments = null;
				if (iterableType != null) switch (iterableType.kind()) {
					case Binding.GENERIC_TYPE : // for (T t : Iterable<T>) - in case used inside Iterable itself
						arguments = iterableType.typeVariables();
						break;
					case Binding.PARAMETERIZED_TYPE : // for(E e : Iterable<E>)
						arguments = ((ParameterizedTypeBinding)iterableType).arguments;
						break;
					case Binding.RAW_TYPE : // for(Object e : Iterable)
						return null;
				}
				
				if (arguments != null && arguments.length == 1) {
					return arguments[0];
				}
			}
		}
		
		return null;
	}
	
	private static TypeBinding resolveForExpression(Expression collection, BlockScope scope) {
		try {
			return collection.resolveType(scope);
		} catch (ArrayIndexOutOfBoundsException e) {
			// Known cause of issues; for example: val e = mth(""X""), where mth takes 2 arguments.
			return null;
		} catch (AbortCompilation e) {
			return null;
		}
	}
	
	private static void clearIgnoreFurtherInvestigationField(ReferenceContext currentContext) {
		if (currentContext instanceof AbstractMethodDeclaration) {
			AbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) currentContext;
			methodDeclaration.ignoreFurtherInvestigation = false;
		} else if (currentContext instanceof LambdaExpression) {
			LambdaExpression lambdaExpression = (LambdaExpression) currentContext;
			setValue(getField(LambdaExpression.class, ""ignoreFurtherInvestigation""), lambdaExpression, false);
			
			Scope parent = lambdaExpression.enclosingScope.parent;
			while (parent != null) {
				switch(parent.kind) {
					case Scope.CLASS_SCOPE:
					case Scope.METHOD_SCOPE:
						ReferenceContext parentAST = parent.referenceContext();
						if (parentAST != lambdaExpression) {
							clearIgnoreFurtherInvestigationField(parentAST);
							return;
						}
					default:
						parent = parent.parent;
						break;
				}
			}
			
		} else if (currentContext instanceof TypeDeclaration) {
			TypeDeclaration typeDeclaration = (TypeDeclaration) currentContext;
			typeDeclaration.ignoreFurtherInvestigation = false;
		} else if (currentContext instanceof CompilationUnitDeclaration) {
			CompilationUnitDeclaration typeDeclaration = (CompilationUnitDeclaration) currentContext;
			typeDeclaration.ignoreFurtherInvestigation = false;
		} else {
			throw new UnsupportedOperationException(""clearIgnoreFurtherInvestigationField for "" + currentContext.getClass());
		}
	}
	
	private static void setValue(Field field, Object object, Object value) {
		try {
			field.set(object, value);
		} catch (IllegalAccessException e) {
			throw sneakyThrow(e);
		}
	}
	
	private static Field getField(Class<?> clazz, String name) {
		try {
			return Permit.getField(clazz, name);
		} catch (NoSuchFieldException e) {
			throw sneakyThrow(e);
		}
	}
}",1,439 334 2000 123 621 621 621 621 439 457 324 2001 40 2002 2003 44 330 91 93 310 41 123 392 40 310 614 424 606 2003 46 2004 40 41 631 310 46 2004 41 450 380 59 385 40 404 2005 61 1500 59 2005 60 310 46 2004 59 2005 637 41 123 392 40 2003 46 2006 40 2005 41 631 310 91 2005 93 41 450 380 59 125 450 473 59 125 439 457 324 2007 40 2008 91 93 2009 44 2002 2003 44 2010 442 41 123 2002 91 93 2011 61 2003 46 2012 40 648 41 59 392 40 442 402 2013 41 123 330 91 93 2014 61 40 40 2013 41 442 41 46 2014 59 392 40 33 2001 40 2011 91 2011 46 2015 45 1501 93 44 2014 41 41 450 380 59 392 40 2009 614 424 41 450 473 59 2016 58 385 40 2008 2017 58 2009 41 123 2018 2019 61 2017 46 2020 59 392 40 2019 614 424 41 344 59 392 40 2019 46 2021 40 41 41 344 59 324 2022 61 40 40 2019 46 2023 38 2024 46 2025 41 631 1500 41 59 404 2026 61 2011 46 2015 45 40 2022 63 1501 58 1500 41 59 330 91 93 91 93 2027 61 2019 46 2028 59 392 40 2026 631 2027 46 2015 41 344 59 385 40 404 2029 61 1500 59 2029 60 2026 59 2029 637 41 123 392 40 2011 91 2029 93 46 2015 40 41 631 2027 91 2029 93 46 2015 41 344 2016 59 385 40 404 2030 61 1500 59 2030 60 2027 91 2029 93 46 2015 59 2030 637 41 392 40 2011 91 2029 93 46 2031 40 2030 41 631 2027 91 2029 93 91 2030 93 41 344 2016 59 125 450 473 59 125 450 380 59 125 392 40 442 402 2032 41 123 330 91 93 91 93 2033 61 40 40 2032 41 442 41 46 2033 59 392 40 2011 46 2034 631 2033 46 2034 41 450 380 59 385 40 404 2035 61 1500 59 2035 60 2033 46 2034 59 637 2035 41 123 2002 2036 61 2011 91 2035 93 59 330 91 93 2037 61 2033 91 2035 93 59 392 40 33 2001 40 2036 44 2037 41 41 450 380 59 125 450 473 59 125 450 380 59 125 439 457 324 2007 40 2038 91 93 2009 44 2002 2003 44 2010 442 41 123 2002 91 93 2039 61 2003 46 2040 40 648 41 59 392 40 442 402 2041 41 123 330 91 93 2042 61 40 40 2041 41 442 41 46 2042 59 392 40 33 2001 40 2039 91 2039 46 2043 45 1501 93 44 2042 41 41 450 380 59 392 40 2009 614 424 41 450 473 59 2044 58 385 40 2038 2045 58 2009 41 123 392 40 2045 46 2046 40 41 41 344 59 324 2047 61 40 40 2045 46 2048 38 2049 46 2050 41 631 1500 41 59 404 2051 61 2039 46 2043 45 40 2047 63 1501 58 1500 41 59 330 91 93 91 93 2052 61 2045 46 2053 59 392 40 2051 631 2052 46 2043 41 344 59 385 40 404 2054 61 1500 59 2054 60 2051 59 2054 637 41 123 392 40 2039 91 2054 93 46 2043 40 41 631 2052 91 2054 93 46 2043 41 344 2044 59 385 40 404 2055 61 1500 59 2055 60 2052 91 2054 93 46 2043 59 2055 637 41 392 40 2039 91 2054 93 46 2056 40 2055 41 631 2052 91 2054 93 91 2055 93 41 344 2044 59 125 450 473 59 125 450 380 59 125 392 40 442 402 2057 41 123 330 91 93 91 93 2058 61 40 40 2057 41 442 41 46 2058 59 392 40 2039 46 2059 631 2058 46 2059 41 450 380 59 385 40 404 2060 61 1500 59 2060 60 2058 46 2059 59 637 2060 41 123 2002 2061 61 2039 91 2060 93 59 330 91 93 2062 61 2058 91 2060 93 59 392 40 33 2001 40 2061 44 2062 41 41 450 380 59 125 450 473 59 125 450 380 59 125 437 457 324 407 40 2010 442 44 2063 2064 44 2002 2003 41 123 2065 2066 61 2064 46 2067 59 496 40 2066 631 424 605 33 40 2066 402 2068 41 41 123 2065 2069 61 2066 46 2067 59 2066 61 2069 614 2066 63 424 58 2069 59 125 2008 91 93 2009 61 424 59 392 40 2066 402 2068 41 2009 61 40 40 2068 41 2066 41 46 2009 59 392 40 33 2007 40 2009 44 2003 44 442 41 41 450 380 59 2070 2071 61 442 46 2071 59 392 40 2071 614 424 41 2071 61 442 46 2072 40 2064 44 380 41 59 392 40 2071 614 424 41 450 380 59 330 91 93 2073 61 2071 46 2074 40 41 59 330 91 93 2075 61 2071 46 2076 40 41 59 404 2077 61 2073 46 2078 62 1500 63 2073 46 2078 43 1501 58 1500 59 330 91 93 2079 61 418 330 91 2077 43 2075 46 2078 93 59 392 40 2073 46 2078 62 1500 41 123 2080 46 2081 40 2073 44 1500 44 2079 44 1500 44 2073 46 2078 41 59 2079 91 2073 46 2078 93 61 607 59 125 2082 46 2083 40 2075 44 1500 44 2079 44 2077 44 2075 46 2078 41 59 450 2001 40 2003 44 2079 41 59 125 439 457 381 334 2084 123 437 457 381 2085 2086 44 2087 59 457 123 2085 2088 61 424 44 2089 61 424 59 474 123 2088 61 2090 46 2091 40 2092 46 334 44 648 41 59 2089 61 2090 46 2091 40 2092 46 334 44 648 41 59 125 329 40 2093 2094 41 123 621 125 2086 61 2088 59 2087 61 2089 59 125 125 439 457 324 2095 40 2096 2097 44 2063 2064 41 123 392 40 2097 614 424 606 33 2096 46 334 46 2098 40 2097 46 2099 40 41 41 41 450 380 59 324 2100 61 380 59 324 2101 61 2102 40 2097 44 2064 41 59 324 490 61 2103 40 2097 44 2064 41 59 392 40 33 40 2101 606 490 41 41 450 380 59 392 40 2101 41 123 2104 91 93 2105 61 418 2106 40 41 46 2107 40 41 59 385 40 404 2108 61 1500 59 2108 60 2105 46 2109 45 1502 605 2108 60 1502 59 2108 637 41 123 392 40 2105 91 2108 93 46 2110 40 41 46 2098 40 648 41 41 123 324 2111 61 2105 91 2108 43 1501 93 46 2110 40 41 46 2098 40 648 41 605 2105 91 2108 43 1502 93 46 2110 40 41 46 2098 40 648 41 59 392 40 2111 41 450 380 59 325 59 125 125 125 2112 2113 61 2097 46 2114 59 392 40 2113 614 424 605 2084 46 2115 631 424 41 123 474 123 2113 61 40 2112 41 2084 46 2115 46 2116 40 2097 41 59 125 329 40 2117 2118 41 123 621 125 125 392 40 2113 614 424 605 2084 46 2119 631 424 41 123 474 123 2113 61 40 2112 41 2084 46 2119 46 2120 40 2097 41 59 2100 61 473 59 125 329 40 2121 2122 41 123 621 125 125 2010 2123 61 424 59 621 392 40 2124 40 2064 41 605 2101 41 123 2123 61 418 2125 40 648 46 2126 40 41 44 2127 40 2097 46 2128 41 41 59 2097 46 2114 61 2113 59 2113 61 424 59 125 392 40 2113 631 424 41 123 392 40 2113 46 2099 40 41 46 2129 40 41 46 2098 40 648 41 41 123 450 380 59 125 2130 2131 61 424 59 474 123 2131 61 2100 63 2132 40 2113 44 2064 41 58 2133 40 2113 44 2064 41 59 125 329 40 2134 2135 41 123 621 621 621 621 2131 61 424 59 125 392 40 2131 614 424 41 123 392 40 2113 402 2136 41 123 2136 2137 61 40 2136 41 2113 59 2112 2138 61 2137 46 2139 59 2112 2140 61 2137 46 2141 59 2130 2142 61 2138 46 2143 59 2144 2145 61 2064 46 2146 40 41 46 2145 59 2147 91 93 2148 61 2145 46 2148 59 2147 2149 61 2148 91 2145 46 2150 45 1501 93 59 392 40 2142 631 424 605 2140 46 2143 614 424 605 2149 46 2151 40 41 614 2152 41 123 404 2150 61 2145 46 2150 59 385 40 404 2153 61 1500 59 2153 60 2150 59 637 2153 41 123 392 40 2148 91 2153 93 614 2149 41 123 2148 91 2153 93 61 424 59 392 40 2153 43 1501 60 2150 41 123 2154 46 2155 40 2148 44 2153 43 1501 44 2148 44 2153 44 2150 45 2153 43 1501 41 59 125 325 59 125 125 2145 46 2156 40 2149 41 59 392 40 33 2145 46 2157 40 41 41 123 2158 40 2064 46 2159 40 41 41 59 2160 40 2161 40 2144 46 334 44 648 41 44 2145 44 380 41 59 125 392 40 2140 402 2162 41 123 2162 2163 61 40 2162 41 2140 59 2163 46 2164 40 2142 41 59 125 392 40 2140 46 2143 614 424 41 123 2165 40 2140 44 2064 41 59 125 2131 61 2142 59 125 125 125 392 40 2131 631 424 41 123 474 123 2123 61 2166 40 2131 44 2097 46 2167 44 380 41 59 392 40 33 2100 41 2113 46 2168 61 2123 46 2169 40 2064 41 59 125 329 40 2170 2135 41 123 621 125 125 125 392 40 2101 41 2097 46 2171 635 2172 46 2173 59 2097 46 2174 61 2175 40 2097 46 2174 44 2097 46 2176 44 2064 41 59 2097 46 2176 61 2123 631 424 63 2123 58 418 2177 40 2178 46 2179 44 2180 40 2097 46 2176 44 1502 41 41 59 450 380 59 125 437 457 324 2181 40 2096 2097 44 2063 2064 41 123 450 407 40 2097 46 2182 44 2064 44 648 41 606 407 40 2097 46 2182 44 2064 44 648 41 59 125 437 457 324 2183 40 2096 2097 44 2063 2064 41 123 450 407 40 2097 46 2184 44 2064 44 648 41 59 125 437 457 324 2185 40 2186 2064 41 123 413 2187 61 2064 46 2188 40 41 46 2189 46 2190 641 1503 59 413 2191 61 2064 46 2188 40 41 46 2189 46 2192 641 1503 59 392 40 2187 614 1500 41 2187 61 2191 59 392 40 2191 614 1500 41 2191 61 2187 59 450 2193 46 2194 40 40 404 41 40 2187 45 1503 41 44 40 404 41 40 2191 45 1503 41 41 615 1502 59 125 439 457 324 2195 40 2196 2197 44 2063 2064 41 123 392 40 2197 46 2198 614 424 41 450 380 59 324 2199 61 2183 40 2197 46 2198 44 2064 41 59 324 490 61 2181 40 2197 46 2198 44 2064 41 59 392 40 33 40 2199 606 490 41 41 450 380 59 392 40 2185 40 2064 41 41 450 380 59 2200 2201 61 2202 40 2197 46 2203 44 2064 41 59 392 40 2201 614 424 41 450 380 59 2010 2204 61 2205 40 2201 44 2197 46 2198 46 2206 44 380 41 59 392 40 2199 41 2197 46 2198 46 2207 635 2208 46 2209 59 2197 46 2198 46 2210 61 2211 40 2197 46 2198 46 2210 44 2197 46 2198 46 2206 44 2064 41 59 2197 46 2198 46 2206 61 2204 631 424 63 2204 58 418 2212 40 2213 46 2214 44 2215 40 2197 46 2198 46 2206 44 1502 41 41 59 450 380 59 125 437 457 2216 91 93 2217 40 2216 91 93 2218 44 2010 2219 44 2063 2064 41 123 2216 91 93 2220 59 392 40 2218 631 424 41 123 2220 61 418 2216 91 1501 43 2218 46 2221 93 59 2222 46 2223 40 2218 44 1500 44 2220 44 1500 44 2218 46 2221 41 59 125 360 123 2220 61 418 2216 91 1501 93 59 125 2010 2224 61 2225 40 2219 44 2219 46 2226 40 41 41 59 2220 91 2220 46 2227 45 1501 93 61 418 2228 46 2229 46 2230 46 406 46 2231 46 2232 46 2233 40 2224 44 2224 46 2234 41 59 450 2220 59 125 437 457 2235 2236 40 2237 2238 44 2063 2064 41 123 392 40 2238 631 424 41 123 2235 2239 61 2238 46 2240 59 392 40 2239 614 424 41 2239 61 2241 40 2238 44 2064 41 59 392 40 2239 614 424 41 450 424 59 392 40 2239 46 2242 40 41 41 123 2239 61 40 40 2243 41 2239 41 46 2244 40 41 59 450 2239 59 125 360 392 40 2239 402 2245 41 123 2245 2246 61 40 40 2245 41 2239 41 46 2247 40 2248 46 2249 44 380 41 59 2235 91 93 2250 61 424 59 392 40 2246 631 424 41 464 40 2246 46 2251 40 41 41 123 328 2252 46 2253 58 621 2250 61 2246 46 2254 40 41 59 325 59 328 2252 46 2255 58 621 2250 61 40 40 2256 41 2246 41 46 2250 59 325 59 328 2252 46 2257 58 621 450 424 59 125 392 40 2250 631 424 605 2250 46 2258 614 1501 41 123 450 2250 91 1500 93 59 125 125 125 450 424 59 125 437 457 2235 2259 40 2237 2238 44 2063 2064 41 123 474 123 450 2238 46 2260 40 2064 41 59 125 329 40 2261 2262 41 123 621 450 424 59 125 329 40 2263 2262 41 123 450 424 59 125 125 437 457 492 2264 40 2265 2266 41 123 392 40 2266 402 2267 41 123 2267 2268 61 40 2267 41 2266 59 2268 46 2269 61 380 59 125 360 392 40 2266 402 2270 41 123 2270 2271 61 40 2270 41 2266 59 2272 40 2273 40 2270 46 334 44 648 41 44 2271 44 380 41 59 2186 2274 61 2271 46 2275 46 2274 59 496 40 2274 631 424 41 123 464 40 2274 46 2276 41 123 328 2186 46 2277 58 328 2186 46 2278 58 2265 2279 61 2274 46 2280 40 41 59 392 40 2279 631 2271 41 123 2264 40 2279 41 59 450 59 125 349 58 2274 61 2274 46 2274 59 325 59 125 125 125 360 392 40 2266 402 2281 41 123 2281 2282 61 40 2281 41 2266 59 2282 46 2283 61 380 59 125 360 392 40 2266 402 2284 41 123 2284 2285 61 40 2284 41 2266 59 2285 46 2286 61 380 59 125 360 123 469 418 2287 40 648 43 2266 46 2288 40 41 41 59 125 125 437 457 492 2289 40 2290 2291 44 2292 426 44 2292 2293 41 123 474 123 2291 46 2294 40 426 44 2293 41 59 125 329 40 2295 2296 41 123 469 2297 40 2296 41 59 125 125 437 457 2290 2298 40 2299 60 63 62 2300 44 2002 2301 41 123 474 123 450 2302 46 2298 40 2300 44 2301 41 59 125 329 40 2303 2304 41 123 469 2305 40 2304 41 59 125 125 125 
46967,Java,"public final class TerminalEmulator {

    /** Log unknown or unimplemented escape sequences received from the shell process. */
    private static final boolean LOG_ESCAPE_SEQUENCES = false;

    public static final int MOUSE_LEFT_BUTTON = 0;

    /** Mouse moving while having left mouse button pressed. */
    public static final int MOUSE_LEFT_BUTTON_MOVED = 32;
    public static final int MOUSE_WHEELUP_BUTTON = 64;
    public static final int MOUSE_WHEELDOWN_BUTTON = 65;

    /** Used for invalid data - http://en.wikipedia.org/wiki/Replacement_character#Replacement_character */
    public static final int UNICODE_REPLACEMENT_CHAR = 0xFFFD;

    /** Escape processing: Not currently in an escape sequence. */
    private static final int ESC_NONE = 0;
    /** Escape processing: Have seen an ESC character - proceed to {@link #doEsc(int)} */
    private static final int ESC = 1;
    /** Escape processing: Have seen ESC POUND */
    private static final int ESC_POUND = 2;
    /** Escape processing: Have seen ESC and a character-set-select ( char */
    private static final int ESC_SELECT_LEFT_PAREN = 3;
    /** Escape processing: Have seen ESC and a character-set-select ) char */
    private static final int ESC_SELECT_RIGHT_PAREN = 4;
    /** Escape processing: ""ESC ["" or CSI (Control Sequence Introducer). */
    private static final int ESC_CSI = 6;
    /** Escape processing: ESC [ ? */
    private static final int ESC_CSI_QUESTIONMARK = 7;
    /** Escape processing: ESC [ $ */
    private static final int ESC_CSI_DOLLAR = 8;
    /** Escape processing: ESC % */
    private static final int ESC_PERCENT = 9;
    /** Escape processing: ESC ] (AKA OSC - Operating System Controls) */
    private static final int ESC_OSC = 10;
    /** Escape processing: ESC ] (AKA OSC - Operating System Controls) ESC */
    private static final int ESC_OSC_ESC = 11;
    /** Escape processing: ESC [ > */
    private static final int ESC_CSI_BIGGERTHAN = 12;
    /** Escape procession: ""ESC P"" or Device Control String (DCS) */
    private static final int ESC_P = 13;
    /** Escape processing: CSI > */
    private static final int ESC_CSI_QUESTIONMARK_ARG_DOLLAR = 14;
    /** Escape processing: CSI $ARGS ' ' */
    private static final int ESC_CSI_ARGS_SPACE = 15;
    /** Escape processing: CSI $ARGS '*' */
    private static final int ESC_CSI_ARGS_ASTERIX = 16;
    /** Escape processing: CSI "" */
    private static final int ESC_CSI_DOUBLE_QUOTE = 17;
    /** Escape processing: CSI ' */
    private static final int ESC_CSI_SINGLE_QUOTE = 18;
    /** Escape processing: CSI ! */
    private static final int ESC_CSI_EXCLAMATION = 19;

    /** The number of parameter arguments. This name comes from the ANSI standard for terminal escape codes. */
    private static final int MAX_ESCAPE_PARAMETERS = 16;

    /** Needs to be large enough to contain reasonable OSC 52 pastes. */
    private static final int MAX_OSC_STRING_LENGTH = 8192;

    /** DECSET 1 - application cursor keys. */
    private static final int DECSET_BIT_APPLICATION_CURSOR_KEYS = 1;
    private static final int DECSET_BIT_REVERSE_VIDEO = 1 << 1;
    /**
     * http://www.vt100.net/docs/vt510-rm/DECOM: ""When DECOM is set, the home cursor position is at the upper-left
     * corner of the screen, within the margins. The starting point for line numbers depends on the current top margin
     * setting. The cursor cannot move outside of the margins. When DECOM is reset, the home cursor position is at the
     * upper-left corner of the screen. The starting point for line numbers is independent of the margins. The cursor
     * can move outside of the margins.""
     */
    private static final int DECSET_BIT_ORIGIN_MODE = 1 << 2;
    /**
     * http://www.vt100.net/docs/vt510-rm/DECAWM: ""If the DECAWM function is set, then graphic characters received when
     * the cursor is at the right border of the page appear at the beginning of the next line. Any text on the page
     * scrolls up if the cursor is at the end of the scrolling region. If the DECAWM function is reset, then graphic
     * characters received when the cursor is at the right border of the page replace characters already on the page.""
     */
    private static final int DECSET_BIT_AUTOWRAP = 1 << 3;
    /** DECSET 25 - if the cursor should be enabled, {@link #isCursorEnabled()}. */
    private static final int DECSET_BIT_CURSOR_ENABLED = 1 << 4;
    private static final int DECSET_BIT_APPLICATION_KEYPAD = 1 << 5;
    /** DECSET 1000 - if to report mouse press&release events. */
    private static final int DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE = 1 << 6;
    /** DECSET 1002 - like 1000, but report moving mouse while pressed. */
    private static final int DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT = 1 << 7;
    /** DECSET 1004 - NOT implemented. */
    private static final int DECSET_BIT_SEND_FOCUS_EVENTS = 1 << 8;
    /** DECSET 1006 - SGR-like mouse protocol (the modern sane choice). */
    private static final int DECSET_BIT_MOUSE_PROTOCOL_SGR = 1 << 9;
    /** DECSET 2004 - see {@link #paste(String)} */
    private static final int DECSET_BIT_BRACKETED_PASTE_MODE = 1 << 10;
    /** Toggled with DECLRMM - http://www.vt100.net/docs/vt510-rm/DECLRMM */
    private static final int DECSET_BIT_LEFTRIGHT_MARGIN_MODE = 1 << 11;
    /** Not really DECSET bit... - http://www.vt100.net/docs/vt510-rm/DECSACE */
    private static final int DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE = 1 << 12;


    private String mTitle;
    private final Stack<String> mTitleStack = new Stack<>();


    /** The cursor position. Between (0,0) and (mRows-1, mColumns-1). */
    private int mCursorRow, mCursorCol;

    /** The number of character rows and columns in the terminal screen. */
    public int mRows, mColumns;

    /** The number of terminal transcript rows that can be scrolled back to. */
    public static final int TERMINAL_TRANSCRIPT_ROWS_MIN = 100;
    public static final int TERMINAL_TRANSCRIPT_ROWS_MAX = 50000;
    public static final int DEFAULT_TERMINAL_TRANSCRIPT_ROWS = 2000;


    /* The supported terminal cursor styles. */

    public static final int TERMINAL_CURSOR_STYLE_BLOCK = 0;
    public static final int TERMINAL_CURSOR_STYLE_UNDERLINE = 1;
    public static final int TERMINAL_CURSOR_STYLE_BAR = 2;
    public static final int DEFAULT_TERMINAL_CURSOR_STYLE = TERMINAL_CURSOR_STYLE_BLOCK;
    public static final Integer[] TERMINAL_CURSOR_STYLES_LIST = new Integer[]{TERMINAL_CURSOR_STYLE_BLOCK, TERMINAL_CURSOR_STYLE_UNDERLINE, TERMINAL_CURSOR_STYLE_BAR};

    /** The terminal cursor styles. */
    private int mCursorStyle = DEFAULT_TERMINAL_CURSOR_STYLE;


    /** The normal screen buffer. Stores the characters that appear on the screen of the emulated terminal. */
    private final TerminalBuffer mMainBuffer;
    /**
     * The alternate screen buffer, exactly as large as the display and contains no additional saved lines (so that when
     * the alternate screen buffer is active, you cannot scroll back to view saved lines).
     * <p>
     * See http://www.xfree86.org/current/ctlseqs.html#The%20Alternate%20Screen%20Buffer
     */
    final TerminalBuffer mAltBuffer;
    /** The current screen buffer, pointing at either {@link #mMainBuffer} or {@link #mAltBuffer}. */
    private TerminalBuffer mScreen;

    /** The terminal session this emulator is bound to. */
    private final TerminalOutput mSession;

    TerminalSessionClient mClient;

    /** Keeps track of the current argument of the current escape sequence. Ranges from 0 to MAX_ESCAPE_PARAMETERS-1. */
    private int mArgIndex;
    /** Holds the arguments of the current escape sequence. */
    private final int[] mArgs = new int[MAX_ESCAPE_PARAMETERS];

    /** Holds OSC and device control arguments, which can be strings. */
    private final StringBuilder mOSCOrDeviceControlArgs = new StringBuilder();

    /**
     * True if the current escape sequence should continue, false if the current escape sequence should be terminated.
     * Used when parsing a single character.
     */
    private boolean mContinueSequence;

    /** The current state of the escape sequence state machine. One of the ESC_* constants. */
    private int mEscapeState;

    private final SavedScreenState mSavedStateMain = new SavedScreenState();
    private final SavedScreenState mSavedStateAlt = new SavedScreenState();

    /** http://www.vt100.net/docs/vt102-ug/table5-15.html */
    private boolean mUseLineDrawingG0, mUseLineDrawingG1, mUseLineDrawingUsesG0 = true;

    /**
     * @see TerminalEmulator#mapDecSetBitToInternalBit(int)
     */
    private int mCurrentDecSetFlags, mSavedDecSetFlags;

    /**
     * If insert mode (as opposed to replace mode) is active. In insert mode new characters are inserted, pushing
     * existing text to the right. Characters moved past the right margin are lost.
     */
    private boolean mInsertMode;

    /** An array of tab stops. mTabStop[i] is true if there is a tab stop set for column i. */
    private boolean[] mTabStop;

    /**
     * Top margin of screen for scrolling ranges from 0 to mRows-2. Bottom margin ranges from mTopMargin + 2 to mRows
     * (Defines the first row after the scrolling region). Left/right margin in [0, mColumns].
     */
    private int mTopMargin, mBottomMargin, mLeftMargin, mRightMargin;

    /**
     * If the next character to be emitted will be automatically wrapped to the next line. Used to disambiguate the case
     * where the cursor is positioned on the last column (mColumns-1). When standing there, a written character will be
     * output in the last column, the cursor not moving but this flag will be set. When outputting another character
     * this will move to the next line.
     */
    private boolean mAboutToAutoWrap;

    /**
     * If the cursor blinking is enabled. It requires cursor itself to be enabled, which is controlled
     * byt whether {@link #DECSET_BIT_CURSOR_ENABLED} bit is set or not.
     */
    private boolean mCursorBlinkingEnabled;

    /**
     * If currently cursor should be in a visible state or not if {@link #mCursorBlinkingEnabled}
     * is {@code true}.
     */
    private boolean mCursorBlinkState;

    /**
     * Current foreground and background colors. Can either be a color index in [0,259] or a truecolor (24-bit) value.
     * For a 24-bit value the top byte (0xff000000) is set.
     *
     * @see TextStyle
     */
    int mForeColor, mBackColor;

    /** Current {@link TextStyle} effect. */
    private int mEffect;

    /**
     * The number of scrolled lines since last calling {@link #clearScrollCounter()}. Used for moving selection up along
     * with the scrolling text.
     */
    private int mScrollCounter = 0;

    private byte mUtf8ToFollow, mUtf8Index;
    private final byte[] mUtf8InputBuffer = new byte[4];
    private int mLastEmittedCodePoint = -1;

    public final TerminalColors mColors = new TerminalColors();

    private static final String LOG_TAG = ""TerminalEmulator"";

    private boolean isDecsetInternalBitSet(int bit) {
        return (mCurrentDecSetFlags & bit) != 0;
    }

    private void setDecsetinternalBit(int internalBit, boolean set) {
        if (set) {
            // The mouse modes are mutually exclusive.
            if (internalBit == DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE) {
                setDecsetinternalBit(DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT, false);
            } else if (internalBit == DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT) {
                setDecsetinternalBit(DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE, false);
            }
        }
        if (set) {
            mCurrentDecSetFlags |= internalBit;
        } else {
            mCurrentDecSetFlags &= ~internalBit;
        }
    }

    static int mapDecSetBitToInternalBit(int decsetBit) {
        switch (decsetBit) {
            case 1:
                return DECSET_BIT_APPLICATION_CURSOR_KEYS;
            case 5:
                return DECSET_BIT_REVERSE_VIDEO;
            case 6:
                return DECSET_BIT_ORIGIN_MODE;
            case 7:
                return DECSET_BIT_AUTOWRAP;
            case 25:
                return DECSET_BIT_CURSOR_ENABLED;
            case 66:
                return DECSET_BIT_APPLICATION_KEYPAD;
            case 69:
                return DECSET_BIT_LEFTRIGHT_MARGIN_MODE;
            case 1000:
                return DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE;
            case 1002:
                return DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT;
            case 1004:
                return DECSET_BIT_SEND_FOCUS_EVENTS;
            case 1006:
                return DECSET_BIT_MOUSE_PROTOCOL_SGR;
            case 2004:
                return DECSET_BIT_BRACKETED_PASTE_MODE;
            default:
                return -1;
            // throw new IllegalArgumentException(""Unsupported decset: "" + decsetBit);
        }
    }

    public TerminalEmulator(TerminalOutput session, int columns, int rows, Integer transcriptRows, TerminalSessionClient client) {
        mSession = session;
        mScreen = mMainBuffer = new TerminalBuffer(columns, getTerminalTranscriptRows(transcriptRows), rows);
        mAltBuffer = new TerminalBuffer(columns, rows, rows);
        mClient = client;
        mRows = rows;
        mColumns = columns;
        mTabStop = new boolean[mColumns];
        reset();
    }

    public void updateTerminalSessionClient(TerminalSessionClient client) {
        mClient = client;
        setCursorStyle();
        setCursorBlinkState(true);
    }

    public TerminalBuffer getScreen() {
        return mScreen;
    }

    public boolean isAlternateBufferActive() {
        return mScreen == mAltBuffer;
    }

    private int getTerminalTranscriptRows(Integer transcriptRows) {
        if (transcriptRows == null || transcriptRows < TERMINAL_TRANSCRIPT_ROWS_MIN || transcriptRows > TERMINAL_TRANSCRIPT_ROWS_MAX)
            return DEFAULT_TERMINAL_TRANSCRIPT_ROWS;
        else
            return transcriptRows;
    }

    /**
     * @param mouseButton one of the MOUSE_* constants of this class.
     */
    public void sendMouseEvent(int mouseButton, int column, int row, boolean pressed) {
        if (column < 1) column = 1;
        if (column > mColumns) column = mColumns;
        if (row < 1) row = 1;
        if (row > mRows) row = mRows;

        if (mouseButton == MOUSE_LEFT_BUTTON_MOVED && !isDecsetInternalBitSet(DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT)) {
            // Do not send tracking.
        } else if (isDecsetInternalBitSet(DECSET_BIT_MOUSE_PROTOCOL_SGR)) {
            mSession.write(String.format(""\033[<%d;%d;%d"" + (pressed ? 'M' : 'm'), mouseButton, column, row));
        } else {
            mouseButton = pressed ? mouseButton : 3; // 3 for release of all buttons.
            // Clip to screen, and clip to the limits of 8-bit data.
            boolean out_of_bounds = column > 255 - 32 || row > 255 - 32;
            if (!out_of_bounds) {
                byte[] data = {'\033', '[', 'M', (byte) (32 + mouseButton), (byte) (32 + column), (byte) (32 + row)};
                mSession.write(data, 0, data.length);
            }
        }
    }

    public void resize(int columns, int rows) {
        if (mRows == rows && mColumns == columns) {
            return;
        } else if (columns < 2 || rows < 2) {
            throw new IllegalArgumentException(""rows="" + rows + "", columns="" + columns);
        }

        if (mRows != rows) {
            mRows = rows;
            mTopMargin = 0;
            mBottomMargin = mRows;
        }
        if (mColumns != columns) {
            int oldColumns = mColumns;
            mColumns = columns;
            boolean[] oldTabStop = mTabStop;
            mTabStop = new boolean[mColumns];
            setDefaultTabStops();
            int toTransfer = Math.min(oldColumns, columns);
            System.arraycopy(oldTabStop, 0, mTabStop, 0, toTransfer);
            mLeftMargin = 0;
            mRightMargin = mColumns;
        }

        resizeScreen();
    }

    private void resizeScreen() {
        final int[] cursor = {mCursorCol, mCursorRow};
        int newTotalRows = (mScreen == mAltBuffer) ? mRows : mMainBuffer.mTotalRows;
        mScreen.resize(mColumns, mRows, newTotalRows, cursor, getStyle(), isAlternateBufferActive());
        mCursorCol = cursor[0];
        mCursorRow = cursor[1];
    }

    public int getCursorRow() {
        return mCursorRow;
    }

    public int getCursorCol() {
        return mCursorCol;
    }

    /** Get the terminal cursor style. It will be one of {@link #TERMINAL_CURSOR_STYLES_LIST} */
    public int getCursorStyle() {
        return mCursorStyle;
    }

    /** Set the terminal cursor style. */
    public void setCursorStyle() {
        Integer cursorStyle = null;

        if (mClient != null)
            cursorStyle = mClient.getTerminalCursorStyle();

        if (cursorStyle == null || !Arrays.asList(TERMINAL_CURSOR_STYLES_LIST).contains(cursorStyle))
            mCursorStyle = DEFAULT_TERMINAL_CURSOR_STYLE;
        else
            mCursorStyle = cursorStyle;
    }

    public boolean isReverseVideo() {
        return isDecsetInternalBitSet(DECSET_BIT_REVERSE_VIDEO);
    }



    public boolean isCursorEnabled() {
        return isDecsetInternalBitSet(DECSET_BIT_CURSOR_ENABLED);
    }
    public boolean shouldCursorBeVisible() {
        if (!isCursorEnabled())
            return false;
        else
            return mCursorBlinkingEnabled ? mCursorBlinkState : true;
    }

    public void setCursorBlinkingEnabled(boolean cursorBlinkingEnabled) {
        this.mCursorBlinkingEnabled = cursorBlinkingEnabled;
    }

    public void setCursorBlinkState(boolean cursorBlinkState) {
        this.mCursorBlinkState = cursorBlinkState;
    }



    public boolean isKeypadApplicationMode() {
        return isDecsetInternalBitSet(DECSET_BIT_APPLICATION_KEYPAD);
    }

    public boolean isCursorKeysApplicationMode() {
        return isDecsetInternalBitSet(DECSET_BIT_APPLICATION_CURSOR_KEYS);
    }

    /** If mouse events are being sent as escape codes to the terminal. */
    public boolean isMouseTrackingActive() {
        return isDecsetInternalBitSet(DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE) || isDecsetInternalBitSet(DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT);
    }

    private void setDefaultTabStops() {
        for (int i = 0; i < mColumns; i++)
            mTabStop[i] = (i & 7) == 0 && i != 0;
    }

    /**
     * Accept bytes (typically from the pseudo-teletype) and process them.
     *
     * @param buffer a byte array containing the bytes to be processed
     * @param length the number of bytes in the array to process
     */
    public void append(byte[] buffer, int length) {
        for (int i = 0; i < length; i++)
            processByte(buffer[i]);
    }

    private void processByte(byte byteToProcess) {
        if (mUtf8ToFollow > 0) {
            if ((byteToProcess & 0b11000000) == 0b10000000) {
                // 10xxxxxx, a continuation byte.
                mUtf8InputBuffer[mUtf8Index++] = byteToProcess;
                if (--mUtf8ToFollow == 0) {
                    byte firstByteMask = (byte) (mUtf8Index == 2 ? 0b00011111 : (mUtf8Index == 3 ? 0b00001111 : 0b00000111));
                    int codePoint = (mUtf8InputBuffer[0] & firstByteMask);
                    for (int i = 1; i < mUtf8Index; i++)
                        codePoint = ((codePoint << 6) | (mUtf8InputBuffer[i] & 0b00111111));
                    if (((codePoint <= 0b1111111) && mUtf8Index > 1) || (codePoint < 0b11111111111 && mUtf8Index > 2)
                        || (codePoint < 0b1111111111111111 && mUtf8Index > 3)) {
                        // Overlong encoding.
                        codePoint = UNICODE_REPLACEMENT_CHAR;
                    }

                    mUtf8Index = mUtf8ToFollow = 0;

                    if (codePoint >= 0x80 && codePoint <= 0x9F) {
                        // Sequence decoded to a C1 control character which we ignore. They are
                        // not used nowadays and increases the risk of messing up the terminal state
                        // on binary input. XTerm does not allow them in utf-8:
                        // ""It is not possible to use a C1 control obtained from decoding the
                        // UTF-8 text"" - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
                    } else {
                        switch (Character.getType(codePoint)) {
                            case Character.UNASSIGNED:
                            case Character.SURROGATE:
                                codePoint = UNICODE_REPLACEMENT_CHAR;
                        }
                        processCodePoint(codePoint);
                    }
                }
            } else {
                // Not a UTF-8 continuation byte so replace the entire sequence up to now with the replacement char:
                mUtf8Index = mUtf8ToFollow = 0;
                emitCodePoint(UNICODE_REPLACEMENT_CHAR);
                // The Unicode Standard Version 6.2 – Core Specification
                // (http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf):
                // ""If the converter encounters an ill-formed UTF-8 code unit sequence which starts with a valid first
                // byte, but which does not continue with valid successor bytes (see Table 3-7), it must not consume the
                // successor bytes as part of the ill-formed subsequence
                // whenever those successor bytes themselves constitute part of a well-formed UTF-8 code unit
                // subsequence.""
                processByte(byteToProcess);
            }
        } else {
            if ((byteToProcess & 0b10000000) == 0) { // The leading bit is not set so it is a 7-bit ASCII character.
                processCodePoint(byteToProcess);
                return;
            } else if ((byteToProcess & 0b11100000) == 0b11000000) { // 110xxxxx, a two-byte sequence.
                mUtf8ToFollow = 1;
            } else if ((byteToProcess & 0b11110000) == 0b11100000) { // 1110xxxx, a three-byte sequence.
                mUtf8ToFollow = 2;
            } else if ((byteToProcess & 0b11111000) == 0b11110000) { // 11110xxx, a four-byte sequence.
                mUtf8ToFollow = 3;
            } else {
                // Not a valid UTF-8 sequence start, signal invalid data:
                processCodePoint(UNICODE_REPLACEMENT_CHAR);
                return;
            }
            mUtf8InputBuffer[mUtf8Index++] = byteToProcess;
        }
    }

    public void processCodePoint(int b) {
        switch (b) {
            case 0: // Null character (NUL, ^@). Do nothing.
                break;
            case 7: // Bell (BEL, ^G, \a). If in an OSC sequence, BEL may terminate a string; otherwise signal bell.
                if (mEscapeState == ESC_OSC)
                    doOsc(b);
                else
                    mSession.onBell();
                break;
            case 8: // Backspace (BS, ^H).
                if (mLeftMargin == mCursorCol) {
                    // Jump to previous line if it was auto-wrapped.
                    int previousRow = mCursorRow - 1;
                    if (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {
                        mScreen.clearLineWrap(previousRow);
                        setCursorRowCol(previousRow, mRightMargin - 1);
                    }
                } else {
                    setCursorCol(mCursorCol - 1);
                }
                break;
            case 9: // Horizontal tab (HT, \t) - move to next tab stop, but not past edge of screen
                // XXX: Should perhaps use color if writing to new cells. Try with
                //       printf ""\033[41m\tXX\033[0m\n""
                // The OSX Terminal.app colors the spaces from the tab red, but xterm does not.
                // Note that Terminal.app only colors on new cells, in e.g.
                //       printf ""\033[41m\t\r\033[42m\tXX\033[0m\n""
                // the first cells are created with a red background, but when tabbing over
                // them again with a green background they are not overwritten.
                mCursorCol = nextTabStop(1);
                break;
            case 10: // Line feed (LF, \n).
            case 11: // Vertical tab (VT, \v).
            case 12: // Form feed (FF, \f).
                doLinefeed();
                break;
            case 13: // Carriage return (CR, \r).
                setCursorCol(mLeftMargin);
                break;
            case 14: // Shift Out (Ctrl-N, SO) → Switch to Alternate Character Set. This invokes the G1 character set.
                mUseLineDrawingUsesG0 = false;
                break;
            case 15: // Shift In (Ctrl-O, SI) → Switch to Standard Character Set. This invokes the G0 character set.
                mUseLineDrawingUsesG0 = true;
                break;
            case 24: // CAN.
            case 26: // SUB.
                if (mEscapeState != ESC_NONE) {
                    // FIXME: What is this??
                    mEscapeState = ESC_NONE;
                    emitCodePoint(127);
                }
                break;
            case 27: // ESC
                // Starts an escape sequence unless we're parsing a string
                if (mEscapeState == ESC_P) {
                    // XXX: Ignore escape when reading device control sequence, since it may be part of string terminator.
                    return;
                } else if (mEscapeState != ESC_OSC) {
                    startEscapeSequence();
                } else {
                    doOsc(b);
                }
                break;
            default:
                mContinueSequence = false;
                switch (mEscapeState) {
                    case ESC_NONE:
                        if (b >= 32) emitCodePoint(b);
                        break;
                    case ESC:
                        doEsc(b);
                        break;
                    case ESC_POUND:
                        doEscPound(b);
                        break;
                    case ESC_SELECT_LEFT_PAREN: // Designate G0 Character Set (ISO 2022, VT100).
                        mUseLineDrawingG0 = (b == '0');
                        break;
                    case ESC_SELECT_RIGHT_PAREN: // Designate G1 Character Set (ISO 2022, VT100).
                        mUseLineDrawingG1 = (b == '0');
                        break;
                    case ESC_CSI:
                        doCsi(b);
                        break;
                    case ESC_CSI_EXCLAMATION:
                        if (b == 'p') { // Soft terminal reset (DECSTR, http://vt100.net/docs/vt510-rm/DECSTR).
                            reset();
                        } else {
                            unknownSequence(b);
                        }
                        break;
                    case ESC_CSI_QUESTIONMARK:
                        doCsiQuestionMark(b);
                        break;
                    case ESC_CSI_BIGGERTHAN:
                        doCsiBiggerThan(b);
                        break;
                    case ESC_CSI_DOLLAR:
                        boolean originMode = isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);
                        int effectiveTopMargin = originMode ? mTopMargin : 0;
                        int effectiveBottomMargin = originMode ? mBottomMargin : mRows;
                        int effectiveLeftMargin = originMode ? mLeftMargin : 0;
                        int effectiveRightMargin = originMode ? mRightMargin : mColumns;
                        switch (b) {
                            case 'v': // ${CSI}${SRC_TOP}${SRC_LEFT}${SRC_BOTTOM}${SRC_RIGHT}${SRC_PAGE}${DST_TOP}${DST_LEFT}${DST_PAGE}$v""
                                // Copy rectangular area (DECCRA - http://vt100.net/docs/vt510-rm/DECCRA):
                                // ""If Pbs is greater than Pts, or Pls is greater than Prs, the terminal ignores DECCRA.
                                // The coordinates of the rectangular area are affected by the setting of origin mode (DECOM).
                                // DECCRA is not affected by the page margins.
                                // The copied text takes on the line attributes of the destination area.
                                // If the value of Pt, Pl, Pb, or Pr exceeds the width or height of the active page, then the value
                                // is treated as the width or height of that page.
                                // If the destination area is partially off the page, then DECCRA clips the off-page data.
                                // DECCRA does not change the active cursor position.""
                                int topSource = Math.min(getArg(0, 1, true) - 1 + effectiveTopMargin, mRows);
                                int leftSource = Math.min(getArg(1, 1, true) - 1 + effectiveLeftMargin, mColumns);
                                // Inclusive, so do not subtract one:
                                int bottomSource = Math.min(Math.max(getArg(2, mRows, true) + effectiveTopMargin, topSource), mRows);
                                int rightSource = Math.min(Math.max(getArg(3, mColumns, true) + effectiveLeftMargin, leftSource), mColumns);
                                // int sourcePage = getArg(4, 1, true);
                                int destionationTop = Math.min(getArg(5, 1, true) - 1 + effectiveTopMargin, mRows);
                                int destinationLeft = Math.min(getArg(6, 1, true) - 1 + effectiveLeftMargin, mColumns);
                                // int destinationPage = getArg(7, 1, true);
                                int heightToCopy = Math.min(mRows - destionationTop, bottomSource - topSource);
                                int widthToCopy = Math.min(mColumns - destinationLeft, rightSource - leftSource);
                                mScreen.blockCopy(leftSource, topSource, widthToCopy, heightToCopy, destinationLeft, destionationTop);
                                break;
                            case '{': // ${CSI}${TOP}${LEFT}${BOTTOM}${RIGHT}${""
                                // Selective erase rectangular area (DECSERA - http://www.vt100.net/docs/vt510-rm/DECSERA).
                            case 'x': // ${CSI}${CHAR};${TOP}${LEFT}${BOTTOM}${RIGHT}$x""
                                // Fill rectangular area (DECFRA - http://www.vt100.net/docs/vt510-rm/DECFRA).
                            case 'z': // ${CSI}$${TOP}${LEFT}${BOTTOM}${RIGHT}$z""
                                // Erase rectangular area (DECERA - http://www.vt100.net/docs/vt510-rm/DECERA).
                                boolean erase = b != 'x';
                                boolean selective = b == '{';
                                // Only DECSERA keeps visual attributes, DECERA does not:
                                boolean keepVisualAttributes = erase && selective;
                                int argIndex = 0;
                                int fillChar = erase ? ' ' : getArg(argIndex++, -1, true);
                                // ""Pch can be any value from 32 to 126 or from 160 to 255. If Pch is not in this range, then the
                                // terminal ignores the DECFRA command"":
                                if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {
                                    // ""If the value of Pt, Pl, Pb, or Pr exceeds the width or height of the active page, the value
                                    // is treated as the width or height of that page.""
                                    int top = Math.min(getArg(argIndex++, 1, true) + effectiveTopMargin, effectiveBottomMargin + 1);
                                    int left = Math.min(getArg(argIndex++, 1, true) + effectiveLeftMargin, effectiveRightMargin + 1);
                                    int bottom = Math.min(getArg(argIndex++, mRows, true) + effectiveTopMargin, effectiveBottomMargin);
                                    int right = Math.min(getArg(argIndex, mColumns, true) + effectiveLeftMargin, effectiveRightMargin);
                                    long style = getStyle();
                                    for (int row = top - 1; row < bottom; row++)
                                        for (int col = left - 1; col < right; col++)
                                            if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row, col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)
                                                mScreen.setChar(col, row, fillChar, keepVisualAttributes ? mScreen.getStyleAt(row, col) : style);
                                }
                                break;
                            case 'r': // ""${CSI}${TOP}${LEFT}${BOTTOM}${RIGHT}${ATTRIBUTES}$r""
                                // Change attributes in rectangular area (DECCARA - http://vt100.net/docs/vt510-rm/DECCARA).
                            case 't': // ""${CSI}${TOP}${LEFT}${BOTTOM}${RIGHT}${ATTRIBUTES}$t""
                                // Reverse attributes in rectangular area (DECRARA - http://www.vt100.net/docs/vt510-rm/DECRARA).
                                boolean reverse = b == 't';
                                // FIXME: ""coordinates of the rectangular area are affected by the setting of origin mode (DECOM)"".
                                int top = Math.min(getArg(0, 1, true) - 1, effectiveBottomMargin) + effectiveTopMargin;
                                int left = Math.min(getArg(1, 1, true) - 1, effectiveRightMargin) + effectiveLeftMargin;
                                int bottom = Math.min(getArg(2, mRows, true) + 1, effectiveBottomMargin - 1) + effectiveTopMargin;
                                int right = Math.min(getArg(3, mColumns, true) + 1, effectiveRightMargin - 1) + effectiveLeftMargin;
                                if (mArgIndex >= 4) {
                                    if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
                                    for (int i = 4; i <= mArgIndex; i++) {
                                        int bits = 0;
                                        boolean setOrClear = true; // True if setting, false if clearing.
                                        switch (getArg(i, 0, false)) {
                                            case 0: // Attributes off (no bold, no underline, no blink, positive image).
                                                bits = (TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK
                                                    | TextStyle.CHARACTER_ATTRIBUTE_INVERSE);
                                                if (!reverse) setOrClear = false;
                                                break;
                                            case 1: // Bold.
                                                bits = TextStyle.CHARACTER_ATTRIBUTE_BOLD;
                                                break;
                                            case 4: // Underline.
                                                bits = TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;
                                                break;
                                            case 5: // Blink.
                                                bits = TextStyle.CHARACTER_ATTRIBUTE_BLINK;
                                                break;
                                            case 7: // Negative image.
                                                bits = TextStyle.CHARACTER_ATTRIBUTE_INVERSE;
                                                break;
                                            case 22: // No bold.
                                                bits = TextStyle.CHARACTER_ATTRIBUTE_BOLD;
                                                setOrClear = false;
                                                break;
                                            case 24: // No underline.
                                                bits = TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;
                                                setOrClear = false;
                                                break;
                                            case 25: // No blink.
                                                bits = TextStyle.CHARACTER_ATTRIBUTE_BLINK;
                                                setOrClear = false;
                                                break;
                                            case 27: // Positive image.
                                                bits = TextStyle.CHARACTER_ATTRIBUTE_INVERSE;
                                                setOrClear = false;
                                                break;
                                        }
                                        if (reverse && !setOrClear) {
                                            // Reverse attributes in rectangular area ignores non-(1,4,5,7) bits.
                                        } else {
                                            mScreen.setOrClearEffect(bits, setOrClear, reverse, isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),
                                                effectiveLeftMargin, effectiveRightMargin, top, left, bottom, right);
                                        }
                                    }
                                } else {
                                    // Do nothing.
                                }
                                break;
                            default:
                                unknownSequence(b);
                        }
                        break;
                    case ESC_CSI_DOUBLE_QUOTE:
                        if (b == 'q') {
                            // http://www.vt100.net/docs/vt510-rm/DECSCA
                            int arg = getArg0(0);
                            if (arg == 0 || arg == 2) {
                                // DECSED and DECSEL can erase characters.
                                mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;
                            } else if (arg == 1) {
                                // DECSED and DECSEL cannot erase characters.
                                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;
                            } else {
                                unknownSequence(b);
                            }
                        } else {
                            unknownSequence(b);
                        }
                        break;
                    case ESC_CSI_SINGLE_QUOTE:
                        if (b == '}') { // Insert Ps Column(s) (default = 1) (DECIC), VT420 and up.
                            int columnsAfterCursor = mRightMargin - mCursorCol;
                            int columnsToInsert = Math.min(getArg0(1), columnsAfterCursor);
                            int columnsToMove = columnsAfterCursor - columnsToInsert;
                            mScreen.blockCopy(mCursorCol, 0, columnsToMove, mRows, mCursorCol + columnsToInsert, 0);
                            blockClear(mCursorCol, 0, columnsToInsert, mRows);
                        } else if (b == '~') { // Delete Ps Column(s) (default = 1) (DECDC), VT420 and up.
                            int columnsAfterCursor = mRightMargin - mCursorCol;
                            int columnsToDelete = Math.min(getArg0(1), columnsAfterCursor);
                            int columnsToMove = columnsAfterCursor - columnsToDelete;
                            mScreen.blockCopy(mCursorCol + columnsToDelete, 0, columnsToMove, mRows, mCursorCol, 0);
                            blockClear(mCursorRow + columnsToMove, 0, columnsToDelete, mRows);
                        } else {
                            unknownSequence(b);
                        }
                        break;
                    case ESC_PERCENT:
                        break;
                    case ESC_OSC:
                        doOsc(b);
                        break;
                    case ESC_OSC_ESC:
                        doOscEsc(b);
                        break;
                    case ESC_P:
                        doDeviceControl(b);
                        break;
                    case ESC_CSI_QUESTIONMARK_ARG_DOLLAR:
                        if (b == 'p') {
                            // Request DEC private mode (DECRQM).
                            int mode = getArg0(0);
                            int value;
                            if (mode == 47 || mode == 1047 || mode == 1049) {
                                // This state is carried by mScreen pointer.
                                value = (mScreen == mAltBuffer) ? 1 : 2;
                            } else {
                                int internalBit = mapDecSetBitToInternalBit(mode);
                                if (internalBit != -1) {
                                    value = isDecsetInternalBitSet(internalBit) ? 1 : 2; // 1=set, 2=reset.
                                } else {
                                    mClient.logError(LOG_TAG, ""Got DECRQM for unrecognized private DEC mode="" + mode);
                                    value = 0; // 0=not recognized, 3=permanently set, 4=permanently reset
                                }
                            }
                            mSession.write(String.format(Locale.US, ""\033[?%d;%d$y"", mode, value));
                        } else {
                            unknownSequence(b);
                        }
                        break;
                    case ESC_CSI_ARGS_SPACE:
                        int arg = getArg0(0);
                        switch (b) {
                            case 'q': // ""${CSI}${STYLE} q"" - set cursor style (http://www.vt100.net/docs/vt510-rm/DECSCUSR).
                                switch (arg) {
                                    case 0: // Blinking block.
                                    case 1: // Blinking block.
                                    case 2: // Steady block.
                                        mCursorStyle = TERMINAL_CURSOR_STYLE_BLOCK;
                                        break;
                                    case 3: // Blinking underline.
                                    case 4: // Steady underline.
                                        mCursorStyle = TERMINAL_CURSOR_STYLE_UNDERLINE;
                                        break;
                                    case 5: // Blinking bar (xterm addition).
                                    case 6: // Steady bar (xterm addition).
                                        mCursorStyle = TERMINAL_CURSOR_STYLE_BAR;
                                        break;
                                }
                                break;
                            case 't':
                            case 'u':
                                // Set margin-bell volume - ignore.
                                break;
                            default:
                                unknownSequence(b);
                        }
                        break;
                    case ESC_CSI_ARGS_ASTERIX:
                        int attributeChangeExtent = getArg0(0);
                        if (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {
                            // Select attribute change extent (DECSACE - http://www.vt100.net/docs/vt510-rm/DECSACE).
                            setDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE, attributeChangeExtent == 2);
                        } else {
                            unknownSequence(b);
                        }
                        break;
                    default:
                        unknownSequence(b);
                        break;
                }
                if (!mContinueSequence) mEscapeState = ESC_NONE;
                break;
        }
    }

    /** When in {@link #ESC_P} (""device control"") sequence. */
    private void doDeviceControl(int b) {
        switch (b) {
            case (byte) '\\': // End of ESC \ string Terminator
            {
                String dcs = mOSCOrDeviceControlArgs.toString();
                // DCS $ q P t ST. Request Status String (DECRQSS)
                if (dcs.startsWith(""$q"")) {
                    if (dcs.equals(""$q\""p"")) {
                        // DECSCL, conformance level, http://www.vt100.net/docs/vt510-rm/DECSCL:
                        String csiString = ""64;1\""p"";
                        mSession.write(""\033P1$r"" + csiString + ""\033\\"");
                    } else {
                        finishSequenceAndLogError(""Unrecognized DECRQSS string: '"" + dcs + ""'"");
                    }
                } else if (dcs.startsWith(""+q"")) {
                    // Request Termcap/Terminfo String. The string following the ""q"" is a list of names encoded in
                    // hexadecimal (2 digits per character) separated by ; which correspond to termcap or terminfo key
                    // names.
                    // Two special features are also recognized, which are not key names: Co for termcap colors (or colors
                    // for terminfo colors), and TN for termcap name (or name for terminfo name).
                    // xterm responds with DCS 1 + r P t ST for valid requests, adding to P t an = , and the value of the
                    // corresponding string that xterm would send, or DCS 0 + r P t ST for invalid requests. The strings are
                    // encoded in hexadecimal (2 digits per character).
                    // Example:
                    // :kr=\EOC: ks=\E[?1h\E=: ku=\EOA: le=^H:mb=\E[5m:md=\E[1m:\
                    // where
                    // kd=down-arrow key
                    // kl=left-arrow key
                    // kr=right-arrow key
                    // ku=up-arrow key
                    // #2=key_shome, ""shifted home""
                    // #4=key_sleft, ""shift arrow left""
                    // %i=key_sright, ""shift arrow right""
                    // *7=key_send, ""shifted end""
                    // k1=F1 function key

                    // Example: Request for ku is ""ESC P + q 6 b 7 5 ESC \"", where 6b7d=ku in hexadecimal.
                    // Xterm response in normal cursor mode:
                    // ""<27> P 1 + r 6 b 7 5 = 1 B 5 B 4 1"" where 0x1B 0x5B 0x41 = 27 91 65 = ESC [ A
                    // Xterm response in application cursor mode:
                    // ""<27> P 1 + r 6 b 7 5 = 1 B 5 B 4 1"" where 0x1B 0x4F 0x41 = 27 91 65 = ESC 0 A

                    // #4 is ""shift arrow left"":
                    // *** Device Control (DCS) for '#4'- 'ESC P + q 23 34 ESC \'
                    // Response: <27> P 1 + r 2 3 3 4 = 1 B 5 B 3 1 3 B 3 2 4 4 <27> \
                    // where 0x1B 0x5B 0x31 0x3B 0x32 0x44 = ESC [ 1 ; 2 D
                    // which we find in: TermKeyListener.java: KEY_MAP.put(KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, ""\033[1;2D"");

                    // See http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V40G_HTML/MAN/MAN4/0178____.HTM for what to
                    // respond, as well as http://www.freebsd.org/cgi/man.cgi?query=termcap&sektion=5#CAPABILITIES for
                    // the meaning of e.g. ""ku"", ""kd"", ""kr"", ""kl""

                    for (String part : dcs.substring(2).split("";"")) {
                        if (part.length() % 2 == 0) {
                            StringBuilder transBuffer = new StringBuilder();
                            for (int i = 0; i < part.length(); i += 2) {
                                char c = (char) Long.decode(""0x"" + part.charAt(i) + """" + part.charAt(i + 1)).longValue();
                                transBuffer.append(c);
                            }
                            String trans = transBuffer.toString();
                            String responseValue;
                            switch (trans) {
                                case ""Co"":
                                case ""colors"":
                                    responseValue = ""256""; // Number of colors.
                                    break;
                                case ""TN"":
                                case ""name"":
                                    responseValue = ""xterm"";
                                    break;
                                default:
                                    responseValue = KeyHandler.getCodeFromTermcap(trans, isDecsetInternalBitSet(DECSET_BIT_APPLICATION_CURSOR_KEYS),
                                        isDecsetInternalBitSet(DECSET_BIT_APPLICATION_KEYPAD));
                                    break;
                            }
                            if (responseValue == null) {
                                switch (trans) {
                                    case ""%1"": // Help key - ignore
                                    case ""&8"": // Undo key - ignore.
                                        break;
                                    default:
                                        mClient.logWarn(LOG_TAG, ""Unhandled termcap/terminfo name: '"" + trans + ""'"");
                                }
                                // Respond with invalid request:
                                mSession.write(""\033P0+r"" + part + ""\033\\"");
                            } else {
                                StringBuilder hexEncoded = new StringBuilder();
                                for (int j = 0; j < responseValue.length(); j++) {
                                    hexEncoded.append(String.format(""%02X"", (int) responseValue.charAt(j)));
                                }
                                mSession.write(""\033P1+r"" + part + ""="" + hexEncoded + ""\033\\"");
                            }
                        } else {
                            mClient.logError(LOG_TAG, ""Invalid device termcap/terminfo name of odd length: "" + part);
                        }
                    }
                } else {
                    if (LOG_ESCAPE_SEQUENCES)
                        mClient.logError(LOG_TAG, ""Unrecognized device control string: "" + dcs);
                }
                finishSequence();
            }
            break;
            default:
                if (mOSCOrDeviceControlArgs.length() > MAX_OSC_STRING_LENGTH) {
                    // Too long.
                    mOSCOrDeviceControlArgs.setLength(0);
                    finishSequence();
                } else {
                    mOSCOrDeviceControlArgs.appendCodePoint(b);
                    continueSequence(mEscapeState);
                }
        }
    }

    private int nextTabStop(int numTabs) {
        for (int i = mCursorCol + 1; i < mColumns; i++)
            if (mTabStop[i] && --numTabs == 0) return Math.min(i, mRightMargin);
        return mRightMargin - 1;
    }

    /** Process byte while in the {@link #ESC_CSI_QUESTIONMARK} escape state. */
    private void doCsiQuestionMark(int b) {
        switch (b) {
            case 'J': // Selective erase in display (DECSED) - http://www.vt100.net/docs/vt510-rm/DECSED.
            case 'K': // Selective erase in line (DECSEL) - http://vt100.net/docs/vt510-rm/DECSEL.
                mAboutToAutoWrap = false;
                int fillChar = ' ';
                int startCol = -1;
                int startRow = -1;
                int endCol = -1;
                int endRow = -1;
                boolean justRow = (b == 'K');
                switch (getArg0(0)) {
                    case 0: // Erase from the active position to the end, inclusive (default).
                        startCol = mCursorCol;
                        startRow = mCursorRow;
                        endCol = mColumns;
                        endRow = justRow ? (mCursorRow + 1) : mRows;
                        break;
                    case 1: // Erase from start to the active position, inclusive.
                        startCol = 0;
                        startRow = justRow ? mCursorRow : 0;
                        endCol = mCursorCol + 1;
                        endRow = mCursorRow + 1;
                        break;
                    case 2: // Erase all of the display/line.
                        startCol = 0;
                        startRow = justRow ? mCursorRow : 0;
                        endCol = mColumns;
                        endRow = justRow ? (mCursorRow + 1) : mRows;
                        break;
                    default:
                        unknownSequence(b);
                        break;
                }
                long style = getStyle();
                for (int row = startRow; row < endRow; row++) {
                    for (int col = startCol; col < endCol; col++) {
                        if ((TextStyle.decodeEffect(mScreen.getStyleAt(row, col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)
                            mScreen.setChar(col, row, fillChar, style);
                    }
                }
                break;
            case 'h':
            case 'l':
                if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
                for (int i = 0; i <= mArgIndex; i++)
                    doDecSetOrReset(b == 'h', mArgs[i]);
                break;
            case 'n': // Device Status Report (DSR, DEC-specific).
                switch (getArg0(-1)) {
                    case 6:
                        // Extended Cursor Position (DECXCPR - http://www.vt100.net/docs/vt510-rm/DECXCPR). Page=1.
                        mSession.write(String.format(Locale.US, ""\033[?%d;%d;1R"", mCursorRow + 1, mCursorCol + 1));
                        break;
                    default:
                        finishSequence();
                        return;
                }
                break;
            case 'r':
            case 's':
                if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
                for (int i = 0; i <= mArgIndex; i++) {
                    int externalBit = mArgs[i];
                    int internalBit = mapDecSetBitToInternalBit(externalBit);
                    if (internalBit == -1) {
                        mClient.logWarn(LOG_TAG, ""Ignoring request to save/recall decset bit="" + externalBit);
                    } else {
                        if (b == 's') {
                            mSavedDecSetFlags |= internalBit;
                        } else {
                            doDecSetOrReset((mSavedDecSetFlags & internalBit) != 0, externalBit);
                        }
                    }
                }
                break;
            case '$':
                continueSequence(ESC_CSI_QUESTIONMARK_ARG_DOLLAR);
                return;
            default:
                parseArg(b);
        }
    }

    public void doDecSetOrReset(boolean setting, int externalBit) {
        int internalBit = mapDecSetBitToInternalBit(externalBit);
        if (internalBit != -1) {
            setDecsetinternalBit(internalBit, setting);
        }
        switch (externalBit) {
            case 1: // Application Cursor Keys (DECCKM).
                break;
            case 3: // Set: 132 column mode (. Reset: 80 column mode. ANSI name: DECCOLM.
                // We don't actually set/reset 132 cols, but we do want the side effects
                // (FIXME: Should only do this if the 95 DECSET bit (DECNCSM) is set, and if changing value?):
                // Sets the left, right, top and bottom scrolling margins to their default positions, which is important for
                // the ""reset"" utility to really reset the terminal:
                mLeftMargin = mTopMargin = 0;
                mBottomMargin = mRows;
                mRightMargin = mColumns;
                // ""DECCOLM resets vertical split screen mode (DECLRMM) to unavailable"":
                setDecsetinternalBit(DECSET_BIT_LEFTRIGHT_MARGIN_MODE, false);
                // ""Erases all data in page memory"":
                blockClear(0, 0, mColumns, mRows);
                setCursorRowCol(0, 0);
                break;
            case 4: // DECSCLM-Scrolling Mode. Ignore.
                break;
            case 5: // Reverse video. No action.
                break;
            case 6: // Set: Origin Mode. Reset: Normal Cursor Mode. Ansi name: DECOM.
                if (setting) setCursorPosition(0, 0);
                break;
            case 7: // Wrap-around bit, not specific action.
            case 8: // Auto-repeat Keys (DECARM). Do not implement.
            case 9: // X10 mouse reporting - outdated. Do not implement.
            case 12: // Control cursor blinking - ignore.
            case 25: // Hide/show cursor - no action needed, renderer will check with shouldCursorBeVisible().
                if (mClient != null)
                    mClient.onTerminalCursorStateChange(setting);
                break;
            case 40: // Allow 80 => 132 Mode, ignore.
            case 45: // TODO: Reverse wrap-around. Implement???
            case 66: // Application keypad (DECNKM).
                break;
            case 69: // Left and right margin mode (DECLRMM).
                if (!setting) {
                    mLeftMargin = 0;
                    mRightMargin = mColumns;
                }
                break;
            case 1000:
            case 1001:
            case 1002:
            case 1003:
            case 1004:
            case 1005: // UTF-8 mouse mode, ignore.
            case 1006: // SGR Mouse Mode
            case 1015:
            case 1034: // Interpret ""meta"" key, sets eighth bit.
                break;
            case 1048: // Set: Save cursor as in DECSC. Reset: Restore cursor as in DECRC.
                if (setting)
                    saveCursor();
                else
                    restoreCursor();
                break;
            case 47:
            case 1047:
            case 1049: {
                // Set: Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first.
                // Reset: Use Normal Screen Buffer and restore cursor as in DECRC.
                TerminalBuffer newScreen = setting ? mAltBuffer : mMainBuffer;
                if (newScreen != mScreen) {
                    boolean resized = !(newScreen.mColumns == mColumns && newScreen.mScreenRows == mRows);
                    if (setting) saveCursor();
                    mScreen = newScreen;
                    if (!setting) {
                        int col = mSavedStateMain.mSavedCursorCol;
                        int row = mSavedStateMain.mSavedCursorRow;
                        restoreCursor();
                        if (resized) {
                            // Restore cursor position _not_ clipped to current screen (let resizeScreen() handle that):
                            mCursorCol = col;
                            mCursorRow = row;
                        }
                    }
                    // Check if buffer size needs to be updated:
                    if (resized) resizeScreen();
                    // Clear new screen if alt buffer:
                    if (newScreen == mAltBuffer)
                        newScreen.blockSet(0, 0, mColumns, mRows, ' ', getStyle());
                }
                break;
            }
            case 2004:
                // Bracketed paste mode - setting bit is enough.
                break;
            default:
                unknownParameter(externalBit);
                break;
        }
    }

    private void doCsiBiggerThan(int b) {
        switch (b) {
            case 'c': // ""${CSI}>c"" or ""${CSI}>c"". Secondary Device Attributes (DA2).
                // Originally this was used for the terminal to respond with ""identification code, firmware version level,
                // and hardware options"" (http://vt100.net/docs/vt510-rm/DA2), with the first ""41"" meaning the VT420
                // terminal type. This is not used anymore, but the second version level field has been changed by xterm
                // to mean it's release number (""patch numbers"" listed at http://invisible-island.net/xterm/xterm.log.html),
                // and some applications use it as a feature check:
                // * tmux used to have a ""xterm won't reach version 500 for a while so set that as the upper limit"" check,
                // and then check ""xterm_version > 270"" if rectangular area operations such as DECCRA could be used.
                // * vim checks xterm version number >140 for ""Request termcap/terminfo string"" functionality >276 for SGR
                // mouse report.
                // The third number is a keyboard identifier not used nowadays.
                mSession.write(""\033[>41;320;0c"");
                break;
            case 'm':
                // https://bugs.launchpad.net/gnome-terminal/+bug/96676/comments/25
                // Depending on the first number parameter, this can set one of the xterm resources
                // modifyKeyboard, modifyCursorKeys, modifyFunctionKeys and modifyOtherKeys.
                // http://invisible-island.net/xterm/manpage/xterm.html#RESOURCES

                // * modifyKeyboard (parameter=1):
                // Normally xterm makes a special case regarding modifiers (shift, control, etc.) to handle special keyboard
                // layouts (legacy and vt220). This is done to provide compatible keyboards for DEC VT220 and related
                // terminals that implement user-defined keys (UDK).
                // The bits of the resource value selectively enable modification of the given category when these keyboards
                // are selected. The default is ""0"":
                // (0) The legacy/vt220 keyboards interpret only the Control-modifier when constructing numbered
                // function-keys. Other special keys are not modified.
                // (1) allows modification of the numeric keypad
                // (2) allows modification of the editing keypad
                // (4) allows modification of function-keys, overrides use of Shift-modifier for UDK.
                // (8) allows modification of other special keys

                // * modifyCursorKeys (parameter=2):
                // Tells how to handle the special case where Control-, Shift-, Alt- or Meta-modifiers are used to add a
                // parameter to the escape sequence returned by a cursor-key. The default is ""2"".
                // - Set it to -1 to disable it.
                // - Set it to 0 to use the old/obsolete behavior.
                // - Set it to 1 to prefix modified sequences with CSI.
                // - Set it to 2 to force the modifier to be the second parameter if it would otherwise be the first.
                // - Set it to 3 to mark the sequence with a "">"" to hint that it is private.

                // * modifyFunctionKeys (parameter=3):
                // Tells how to handle the special case where Control-, Shift-, Alt- or Meta-modifiers are used to add a
                // parameter to the escape sequence returned by a (numbered) function-
                // key. The default is ""2"". The resource values are similar to modifyCursorKeys:
                // Set it to -1 to permit the user to use shift- and control-modifiers to construct function-key strings
                // using the normal encoding scheme.
                // - Set it to 0 to use the old/obsolete behavior.
                // - Set it to 1 to prefix modified sequences with CSI.
                // - Set it to 2 to force the modifier to be the second parameter if it would otherwise be the first.
                // - Set it to 3 to mark the sequence with a "">"" to hint that it is private.
                // If modifyFunctionKeys is zero, xterm uses Control- and Shift-modifiers to allow the user to construct
                // numbered function-keys beyond the set provided by the keyboard:
                // (Control) adds the value given by the ctrlFKeys resource.
                // (Shift) adds twice the value given by the ctrlFKeys resource.
                // (Control/Shift) adds three times the value given by the ctrlFKeys resource.
                //
                // As a special case, legacy (when oldFunctionKeys is true) or vt220 (when sunKeyboard is true)
                // keyboards interpret only the Control-modifier when constructing numbered function-keys.
                // This is done to provide compatible keyboards for DEC VT220 and related terminals that
                // implement user-defined keys (UDK).

                // * modifyOtherKeys (parameter=4):
                // Like modifyCursorKeys, tells xterm to construct an escape sequence for other keys (such as ""2"") when
                // modified by Control-, Alt- or Meta-modifiers. This feature does not apply to function keys and
                // well-defined keys such as ESC or the control keys. The default is ""0"".
                // (0) disables this feature.
                // (1) enables this feature for keys except for those with well-known behavior, e.g., Tab, Backarrow and
                // some special control character cases, e.g., Control-Space to make a NUL.
                // (2) enables this feature for keys including the exceptions listed.
                mClient.logError(LOG_TAG, ""(ignored) CSI > MODIFY RESOURCE: "" + getArg0(-1) + "" to "" + getArg1(-1));
                break;
            default:
                parseArg(b);
                break;
        }
    }

    private void startEscapeSequence() {
        mEscapeState = ESC;
        mArgIndex = 0;
        Arrays.fill(mArgs, -1);
    }

    private void doLinefeed() {
        boolean belowScrollingRegion = mCursorRow >= mBottomMargin;
        int newCursorRow = mCursorRow + 1;
        if (belowScrollingRegion) {
            // Move down (but not scroll) as long as we are above the last row.
            if (mCursorRow != mRows - 1) {
                setCursorRow(newCursorRow);
            }
        } else {
            if (newCursorRow == mBottomMargin) {
                scrollDownOneLine();
                newCursorRow = mBottomMargin - 1;
            }
            setCursorRow(newCursorRow);
        }
    }

    private void continueSequence(int state) {
        mEscapeState = state;
        mContinueSequence = true;
    }

    private void doEscPound(int b) {
        switch (b) {
            case '8': // Esc # 8 - DEC screen alignment test - fill screen with E's.
                mScreen.blockSet(0, 0, mColumns, mRows, 'E', getStyle());
                break;
            default:
                unknownSequence(b);
                break;
        }
    }

    /** Encountering a character in the {@link #ESC} state. */
    private void doEsc(int b) {
        switch (b) {
            case '#':
                continueSequence(ESC_POUND);
                break;
            case '(':
                continueSequence(ESC_SELECT_LEFT_PAREN);
                break;
            case ')':
                continueSequence(ESC_SELECT_RIGHT_PAREN);
                break;
            case '6': // Back index (http://www.vt100.net/docs/vt510-rm/DECBI). Move left, insert blank column if start.
                if (mCursorCol > mLeftMargin) {
                    mCursorCol--;
                } else {
                    int rows = mBottomMargin - mTopMargin;
                    mScreen.blockCopy(mLeftMargin, mTopMargin, mRightMargin - mLeftMargin - 1, rows, mLeftMargin + 1, mTopMargin);
                    mScreen.blockSet(mLeftMargin, mTopMargin, 1, rows, ' ', TextStyle.encode(mForeColor, mBackColor, 0));
                }
                break;
            case '7': // DECSC save cursor - http://www.vt100.net/docs/vt510-rm/DECSC
                saveCursor();
                break;
            case '8': // DECRC restore cursor - http://www.vt100.net/docs/vt510-rm/DECRC
                restoreCursor();
                break;
            case '9': // Forward Index (http://www.vt100.net/docs/vt510-rm/DECFI). Move right, insert blank column if end.
                if (mCursorCol < mRightMargin - 1) {
                    mCursorCol++;
                } else {
                    int rows = mBottomMargin - mTopMargin;
                    mScreen.blockCopy(mLeftMargin + 1, mTopMargin, mRightMargin - mLeftMargin - 1, rows, mLeftMargin, mTopMargin);
                    mScreen.blockSet(mRightMargin - 1, mTopMargin, 1, rows, ' ', TextStyle.encode(mForeColor, mBackColor, 0));
                }
                break;
            case 'c': // RIS - Reset to Initial State (http://vt100.net/docs/vt510-rm/RIS).
                reset();
                mMainBuffer.clearTranscript();
                blockClear(0, 0, mColumns, mRows);
                setCursorPosition(0, 0);
                break;
            case 'D': // INDEX
                doLinefeed();
                break;
            case 'E': // Next line (http://www.vt100.net/docs/vt510-rm/NEL).
                setCursorCol(isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE) ? mLeftMargin : 0);
                doLinefeed();
                break;
            case 'F': // Cursor to lower-left corner of screen
                setCursorRowCol(0, mBottomMargin - 1);
                break;
            case 'H': // Tab set
                mTabStop[mCursorCol] = true;
                break;
            case 'M': // ""${ESC}M"" - reverse index (RI).
                // http://www.vt100.net/docs/vt100-ug/chapter3.html: ""Move the active position to the same horizontal
                // position on the preceding line. If the active position is at the top margin, a scroll down is performed"".
                if (mCursorRow <= mTopMargin) {
                    mScreen.blockCopy(0, mTopMargin, mColumns, mBottomMargin - (mTopMargin + 1), 0, mTopMargin + 1);
                    blockClear(0, mTopMargin, mColumns);
                } else {
                    mCursorRow--;
                }
                break;
            case 'N': // SS2, ignore.
            case '0': // SS3, ignore.
                break;
            case 'P': // Device control string
                mOSCOrDeviceControlArgs.setLength(0);
                continueSequence(ESC_P);
                break;
            case '[':
                continueSequence(ESC_CSI);
                break;
            case '=': // DECKPAM
                setDecsetinternalBit(DECSET_BIT_APPLICATION_KEYPAD, true);
                break;
            case ']': // OSC
                mOSCOrDeviceControlArgs.setLength(0);
                continueSequence(ESC_OSC);
                break;
            case '>': // DECKPNM
                setDecsetinternalBit(DECSET_BIT_APPLICATION_KEYPAD, false);
                break;
            default:
                unknownSequence(b);
                break;
        }
    }

    /** DECSC save cursor - http://www.vt100.net/docs/vt510-rm/DECSC . See {@link #restoreCursor()}. */
    private void saveCursor() {
        SavedScreenState state = (mScreen == mMainBuffer) ? mSavedStateMain : mSavedStateAlt;
        state.mSavedCursorRow = mCursorRow;
        state.mSavedCursorCol = mCursorCol;
        state.mSavedEffect = mEffect;
        state.mSavedForeColor = mForeColor;
        state.mSavedBackColor = mBackColor;
        state.mSavedDecFlags = mCurrentDecSetFlags;
        state.mUseLineDrawingG0 = mUseLineDrawingG0;
        state.mUseLineDrawingG1 = mUseLineDrawingG1;
        state.mUseLineDrawingUsesG0 = mUseLineDrawingUsesG0;
    }

    /** DECRS restore cursor - http://www.vt100.net/docs/vt510-rm/DECRC. See {@link #saveCursor()}. */
    private void restoreCursor() {
        SavedScreenState state = (mScreen == mMainBuffer) ? mSavedStateMain : mSavedStateAlt;
        setCursorRowCol(state.mSavedCursorRow, state.mSavedCursorCol);
        mEffect = state.mSavedEffect;
        mForeColor = state.mSavedForeColor;
        mBackColor = state.mSavedBackColor;
        int mask = (DECSET_BIT_AUTOWRAP | DECSET_BIT_ORIGIN_MODE);
        mCurrentDecSetFlags = (mCurrentDecSetFlags & ~mask) | (state.mSavedDecFlags & mask);
        mUseLineDrawingG0 = state.mUseLineDrawingG0;
        mUseLineDrawingG1 = state.mUseLineDrawingG1;
        mUseLineDrawingUsesG0 = state.mUseLineDrawingUsesG0;
    }

    /** Following a CSI - Control Sequence Introducer, ""\033["". {@link #ESC_CSI}. */
    private void doCsi(int b) {
        switch (b) {
            case '!':
                continueSequence(ESC_CSI_EXCLAMATION);
                break;
            case '""':
                continueSequence(ESC_CSI_DOUBLE_QUOTE);
                break;
            case '\'':
                continueSequence(ESC_CSI_SINGLE_QUOTE);
                break;
            case '$':
                continueSequence(ESC_CSI_DOLLAR);
                break;
            case '*':
                continueSequence(ESC_CSI_ARGS_ASTERIX);
                break;
            case '@': {
                // ""CSI{n}@"" - Insert ${n} space characters (ICH) - http://www.vt100.net/docs/vt510-rm/ICH.
                mAboutToAutoWrap = false;
                int columnsAfterCursor = mColumns - mCursorCol;
                int spacesToInsert = Math.min(getArg0(1), columnsAfterCursor);
                int charsToMove = columnsAfterCursor - spacesToInsert;
                mScreen.blockCopy(mCursorCol, mCursorRow, charsToMove, 1, mCursorCol + spacesToInsert, mCursorRow);
                blockClear(mCursorCol, mCursorRow, spacesToInsert);
            }
            break;
            case 'A': // ""CSI${n}A"" - Cursor up (CUU) ${n} rows.
                setCursorRow(Math.max(0, mCursorRow - getArg0(1)));
                break;
            case 'B': // ""CSI${n}B"" - Cursor down (CUD) ${n} rows.
                setCursorRow(Math.min(mRows - 1, mCursorRow + getArg0(1)));
                break;
            case 'C': // ""CSI${n}C"" - Cursor forward (CUF).
            case 'a': // ""CSI${n}a"" - Horizontal position relative (HPR). From ISO-6428/ECMA-48.
                setCursorCol(Math.min(mRightMargin - 1, mCursorCol + getArg0(1)));
                break;
            case 'D': // ""CSI${n}D"" - Cursor backward (CUB) ${n} columns.
                setCursorCol(Math.max(mLeftMargin, mCursorCol - getArg0(1)));
                break;
            case 'E': // ""CSI{n}E - Cursor Next Line (CNL). From ISO-6428/ECMA-48.
                setCursorPosition(0, mCursorRow + getArg0(1));
                break;
            case 'F': // ""CSI{n}F - Cursor Previous Line (CPL). From ISO-6428/ECMA-48.
                setCursorPosition(0, mCursorRow - getArg0(1));
                break;
            case 'G': // ""CSI${n}G"" - Cursor horizontal absolute (CHA) to column ${n}.
                setCursorCol(Math.min(Math.max(1, getArg0(1)), mColumns) - 1);
                break;
            case 'H': // ""${CSI}${ROW};${COLUMN}H"" - Cursor position (CUP).
            case 'f': // ""${CSI}${ROW};${COLUMN}f"" - Horizontal and Vertical Position (HVP).
                setCursorPosition(getArg1(1) - 1, getArg0(1) - 1);
                break;
            case 'I': // Cursor Horizontal Forward Tabulation (CHT). Move the active position n tabs forward.
                setCursorCol(nextTabStop(getArg0(1)));
                break;
            case 'J': // ""${CSI}${0,1,2,3}J"" - Erase in Display (ED)
                // ED ignores the scrolling margins.
                switch (getArg0(0)) {
                    case 0: // Erase from the active position to the end of the screen, inclusive (default).
                        blockClear(mCursorCol, mCursorRow, mColumns - mCursorCol);
                        blockClear(0, mCursorRow + 1, mColumns, mRows - (mCursorRow + 1));
                        break;
                    case 1: // Erase from start of the screen to the active position, inclusive.
                        blockClear(0, 0, mColumns, mCursorRow);
                        blockClear(0, mCursorRow, mCursorCol + 1);
                        break;
                    case 2: // Erase all of the display - all lines are erased, changed to single-width, and the cursor does not
                        // move..
                        blockClear(0, 0, mColumns, mRows);
                        break;
                    case 3: // Delete all lines saved in the scrollback buffer (xterm etc)
                        mMainBuffer.clearTranscript();
                        break;
                    default:
                        unknownSequence(b);
                        return;
                }
                mAboutToAutoWrap = false;
                break;
            case 'K': // ""CSI{n}K"" - Erase in line (EL).
                switch (getArg0(0)) {
                    case 0: // Erase from the cursor to the end of the line, inclusive (default)
                        blockClear(mCursorCol, mCursorRow, mColumns - mCursorCol);
                        break;
                    case 1: // Erase from the start of the screen to the cursor, inclusive.
                        blockClear(0, mCursorRow, mCursorCol + 1);
                        break;
                    case 2: // Erase all of the line.
                        blockClear(0, mCursorRow, mColumns);
                        break;
                    default:
                        unknownSequence(b);
                        return;
                }
                mAboutToAutoWrap = false;
                break;
            case 'L': // ""${CSI}{N}L"" - insert ${N} lines (IL).
            {
                int linesAfterCursor = mBottomMargin - mCursorRow;
                int linesToInsert = Math.min(getArg0(1), linesAfterCursor);
                int linesToMove = linesAfterCursor - linesToInsert;
                mScreen.blockCopy(0, mCursorRow, mColumns, linesToMove, 0, mCursorRow + linesToInsert);
                blockClear(0, mCursorRow, mColumns, linesToInsert);
            }
            break;
            case 'M': // ""${CSI}${N}M"" - delete N lines (DL).
            {
                mAboutToAutoWrap = false;
                int linesAfterCursor = mBottomMargin - mCursorRow;
                int linesToDelete = Math.min(getArg0(1), linesAfterCursor);
                int linesToMove = linesAfterCursor - linesToDelete;
                mScreen.blockCopy(0, mCursorRow + linesToDelete, mColumns, linesToMove, 0, mCursorRow);
                blockClear(0, mCursorRow + linesToMove, mColumns, linesToDelete);
            }
            break;
            case 'P': // ""${CSI}{N}P"" - delete ${N} characters (DCH).
            {
                // http://www.vt100.net/docs/vt510-rm/DCH: ""If ${N} is greater than the number of characters between the
                // cursor and the right margin, then DCH only deletes the remaining characters.
                // As characters are deleted, the remaining characters between the cursor and right margin move to the left.
                // Character attributes move with the characters. The terminal adds blank spaces with no visual character
                // attributes at the right margin. DCH has no effect outside the scrolling margins.""
                mAboutToAutoWrap = false;
                int cellsAfterCursor = mColumns - mCursorCol;
                int cellsToDelete = Math.min(getArg0(1), cellsAfterCursor);
                int cellsToMove = cellsAfterCursor - cellsToDelete;
                mScreen.blockCopy(mCursorCol + cellsToDelete, mCursorRow, cellsToMove, 1, mCursorCol, mCursorRow);
                blockClear(mCursorCol + cellsToMove, mCursorRow, cellsToDelete);
            }
            break;
            case 'S': { // ""${CSI}${N}S"" - scroll up ${N} lines (default = 1) (SU).
                final int linesToScroll = getArg0(1);
                for (int i = 0; i < linesToScroll; i++)
                    scrollDownOneLine();
                break;
            }
            case 'T':
                if (mArgIndex == 0) {
                    // ""${CSI}${N}T"" - Scroll down N lines (default = 1) (SD).
                    // http://vt100.net/docs/vt510-rm/SD: ""N is the number of lines to move the user window up in page
                    // memory. N new lines appear at the top of the display. N old lines disappear at the bottom of the
                    // display. You cannot pan past the top margin of the current page"".
                    final int linesToScrollArg = getArg0(1);
                    final int linesBetweenTopAndBottomMargins = mBottomMargin - mTopMargin;
                    final int linesToScroll = Math.min(linesBetweenTopAndBottomMargins, linesToScrollArg);
                    mScreen.blockCopy(0, mTopMargin, mColumns, linesBetweenTopAndBottomMargins - linesToScroll, 0, mTopMargin + linesToScroll);
                    blockClear(0, mTopMargin, mColumns, linesToScroll);
                } else {
                    // ""${CSI}${func};${startx};${starty};${firstrow};${lastrow}T"" - initiate highlight mouse tracking.
                    unimplementedSequence(b);
                }
                break;
            case 'X': // ""${CSI}${N}X"" - Erase ${N:=1} character(s) (ECH). FIXME: Clears character attributes?
                mAboutToAutoWrap = false;
                mScreen.blockSet(mCursorCol, mCursorRow, Math.min(getArg0(1), mColumns - mCursorCol), 1, ' ', getStyle());
                break;
            case 'Z': // Cursor Backward Tabulation (CBT). Move the active position n tabs backward.
                int numberOfTabs = getArg0(1);
                int newCol = mLeftMargin;
                for (int i = mCursorCol - 1; i >= 0; i--)
                    if (mTabStop[i]) {
                        if (--numberOfTabs == 0) {
                            newCol = Math.max(i, mLeftMargin);
                            break;
                        }
                    }
                mCursorCol = newCol;
                break;
            case '?': // Esc [ ? -- start of a private mode set
                continueSequence(ESC_CSI_QUESTIONMARK);
                break;
            case '>': // ""Esc [ >"" --
                continueSequence(ESC_CSI_BIGGERTHAN);
                break;
            case '`': // Horizontal position absolute (HPA - http://www.vt100.net/docs/vt510-rm/HPA).
                setCursorColRespectingOriginMode(getArg0(1) - 1);
                break;
            case 'b': // Repeat the preceding graphic character Ps times (REP).
                if (mLastEmittedCodePoint == -1) break;
                final int numRepeat = getArg0(1);
                for (int i = 0; i < numRepeat; i++) emitCodePoint(mLastEmittedCodePoint);
                break;
            case 'c': // Primary Device Attributes (http://www.vt100.net/docs/vt510-rm/DA1) if argument is missing or zero.
                // The important part that may still be used by some (tmux stores this value but does not currently use it)
                // is the first response parameter identifying the terminal service class, where we send 64 for ""vt420"".
                // This is followed by a list of attributes which is probably unused by applications. Send like xterm.
                if (getArg0(0) == 0) mSession.write(""\033[?64;1;2;6;9;15;18;21;22c"");
                break;
            case 'd': // ESC [ Pn d - Vert Position Absolute
                setCursorRow(Math.min(Math.max(1, getArg0(1)), mRows) - 1);
                break;
            case 'e': // Vertical Position Relative (VPR). From ISO-6429 (ECMA-48).
                setCursorPosition(mCursorCol, mCursorRow + getArg0(1));
                break;
            // case 'f': ""${CSI}${ROW};${COLUMN}f"" - Horizontal and Vertical Position (HVP). Grouped with case 'H'.
            case 'g': // Clear tab stop
                switch (getArg0(0)) {
                    case 0:
                        mTabStop[mCursorCol] = false;
                        break;
                    case 3:
                        for (int i = 0; i < mColumns; i++) {
                            mTabStop[i] = false;
                        }
                        break;
                    default:
                        // Specified to have no effect.
                        break;
                }
                break;
            case 'h': // Set Mode
                doSetMode(true);
                break;
            case 'l': // Reset Mode
                doSetMode(false);
                break;
            case 'm': // Esc [ Pn m - character attributes. (can have up to 16 numerical arguments)
                selectGraphicRendition();
                break;
            case 'n': // Esc [ Pn n - ECMA-48 Status Report Commands
                // sendDeviceAttributes()
                switch (getArg0(0)) {
                    case 5: // Device status report (DSR):
                        // Answer is ESC [ 0 n (Terminal OK).
                        byte[] dsr = {(byte) 27, (byte) '[', (byte) '0', (byte) 'n'};
                        mSession.write(dsr, 0, dsr.length);
                        break;
                    case 6: // Cursor position report (CPR):
                        // Answer is ESC [ y ; x R, where x,y is
                        // the cursor location.
                        mSession.write(String.format(Locale.US, ""\033[%d;%dR"", mCursorRow + 1, mCursorCol + 1));
                        break;
                    default:
                        break;
                }
                break;
            case 'r': // ""CSI${top};${bottom}r"" - set top and bottom Margins (DECSTBM).
            {
                // https://vt100.net/docs/vt510-rm/DECSTBM.html
                // The top margin defaults to 1, the bottom margin defaults to mRows.
                // The escape sequence numbers top 1..23, but we number top 0..22.
                // The escape sequence numbers bottom 2..24, and so do we (because we use a zero based numbering
                // scheme, but we store the first line below the bottom-most scrolling line.
                // As a result, we adjust the top line by -1, but we leave the bottom line alone.
                // Also require that top + 2 <= bottom.
                mTopMargin = Math.max(0, Math.min(getArg0(1) - 1, mRows - 2));
                mBottomMargin = Math.max(mTopMargin + 2, Math.min(getArg1(mRows), mRows));

                // DECSTBM moves the cursor to column 1, line 1 of the page respecting origin mode.
                setCursorPosition(0, 0);
            }
            break;
            case 's':
                if (isDecsetInternalBitSet(DECSET_BIT_LEFTRIGHT_MARGIN_MODE)) {
                    // Set left and right margins (DECSLRM - http://www.vt100.net/docs/vt510-rm/DECSLRM).
                    mLeftMargin = Math.min(getArg0(1) - 1, mColumns - 2);
                    mRightMargin = Math.max(mLeftMargin + 1, Math.min(getArg1(mColumns), mColumns));
                    // DECSLRM moves the cursor to column 1, line 1 of the page.
                    setCursorPosition(0, 0);
                } else {
                    // Save cursor (ANSI.SYS), available only when DECLRMM is disabled.
                    saveCursor();
                }
                break;
            case 't': // Window manipulation (from dtterm, as well as extensions)
                switch (getArg0(0)) {
                    case 11: // Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t .
                        mSession.write(""\033[1t"");
                        break;
                    case 13: // Report xterm window position. Result is CSI 3 ; x ; y t
                        mSession.write(""\033[3;0;0t"");
                        break;
                    case 14: // Report xterm window in pixels. Result is CSI 4 ; height ; width t
                        // We just report characters time 12 here.
                        mSession.write(String.format(Locale.US, ""\033[4;%d;%dt"", mRows * 12, mColumns * 12));
                        break;
                    case 18: // Report the size of the text area in characters. Result is CSI 8 ; height ; width t
                        mSession.write(String.format(Locale.US, ""\033[8;%d;%dt"", mRows, mColumns));
                        break;
                    case 19: // Report the size of the screen in characters. Result is CSI 9 ; height ; width t
                        // We report the same size as the view, since it's the view really isn't resizable from the shell.
                        mSession.write(String.format(Locale.US, ""\033[9;%d;%dt"", mRows, mColumns));
                        break;
                    case 20: // Report xterm windows icon label. Result is OSC L label ST. Disabled due to security concerns:
                        mSession.write(""\033]LIconLabel\033\\"");
                        break;
                    case 21: // Report xterm windows title. Result is OSC l label ST. Disabled due to security concerns:
                        mSession.write(""\033]l\033\\"");
                        break;
                    case 22:
                        // 22;0 -> Save xterm icon and window title on stack.
                        // 22;1 -> Save xterm icon title on stack.
                        // 22;2 -> Save xterm window title on stack.
                        mTitleStack.push(mTitle);
                        if (mTitleStack.size() > 20) {
                            // Limit size
                            mTitleStack.remove(0);
                        }
                        break;
                    case 23: // Like 22 above but restore from stack.
                        if (!mTitleStack.isEmpty()) setTitle(mTitleStack.pop());
                        break;
                    default:
                        // Ignore window manipulation.
                        break;
                }
                break;
            case 'u': // Restore cursor (ANSI.SYS).
                restoreCursor();
                break;
            case ' ':
                continueSequence(ESC_CSI_ARGS_SPACE);
                break;
            default:
                parseArg(b);
                break;
        }
    }

    /** Select Graphic Rendition (SGR) - see http://en.wikipedia.org/wiki/ANSI_escape_code#graphics. */
    private void selectGraphicRendition() {
        if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
        for (int i = 0; i <= mArgIndex; i++) {
            int code = mArgs[i];
            if (code < 0) {
                if (mArgIndex > 0) {
                    continue;
                } else {
                    code = 0;
                }
            }
            if (code == 0) { // reset
                mForeColor = TextStyle.COLOR_INDEX_FOREGROUND;
                mBackColor = TextStyle.COLOR_INDEX_BACKGROUND;
                mEffect = 0;
            } else if (code == 1) {
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_BOLD;
            } else if (code == 2) {
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_DIM;
            } else if (code == 3) {
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_ITALIC;
            } else if (code == 4) {
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;
            } else if (code == 5) {
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_BLINK;
            } else if (code == 7) {
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_INVERSE;
            } else if (code == 8) {
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_INVISIBLE;
            } else if (code == 9) {
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_STRIKETHROUGH;
            } else if (code == 10) {
                // Exit alt charset (TERM=linux) - ignore.
            } else if (code == 11) {
                // Enter alt charset (TERM=linux) - ignore.
            } else if (code == 22) { // Normal color or intensity, neither bright, bold nor faint.
                mEffect &= ~(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_DIM);
            } else if (code == 23) { // not italic, but rarely used as such; clears standout with TERM=screen
                mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_ITALIC;
            } else if (code == 24) { // underline: none
                mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;
            } else if (code == 25) { // blink: none
                mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_BLINK;
            } else if (code == 27) { // image: positive
                mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_INVERSE;
            } else if (code == 28) {
                mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_INVISIBLE;
            } else if (code == 29) {
                mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_STRIKETHROUGH;
            } else if (code >= 30 && code <= 37) {
                mForeColor = code - 30;
            } else if (code == 38 || code == 48) {
                // Extended set foreground(38)/background (48) color.
                // This is followed by either ""2;$R;$G;$B"" to set a 24-bit color or
                // ""5;$INDEX"" to set an indexed color.
                if (i + 2 > mArgIndex) continue;
                int firstArg = mArgs[i + 1];
                if (firstArg == 2) {
                    if (i + 4 > mArgIndex) {
                        mClient.logWarn(LOG_TAG, ""Too few CSI"" + code + "";2 RGB arguments"");
                    } else {
                        int red = mArgs[i + 2], green = mArgs[i + 3], blue = mArgs[i + 4];
                        if (red < 0 || green < 0 || blue < 0 || red > 255 || green > 255 || blue > 255) {
                            finishSequenceAndLogError(""Invalid RGB: "" + red + "","" + green + "","" + blue);
                        } else {
                            int argbColor = 0xff000000 | (red << 16) | (green << 8) | blue;
                            if (code == 38) {
                                mForeColor = argbColor;
                            } else {
                                mBackColor = argbColor;
                            }
                        }
                        i += 4; // ""2;P_r;P_g;P_r""
                    }
                } else if (firstArg == 5) {
                    int color = mArgs[i + 2];
                    i += 2; // ""5;P_s""
                    if (color >= 0 && color < TextStyle.NUM_INDEXED_COLORS) {
                        if (code == 38) {
                            mForeColor = color;
                        } else {
                            mBackColor = color;
                        }
                    } else {
                        if (LOG_ESCAPE_SEQUENCES) mClient.logWarn(LOG_TAG, ""Invalid color index: "" + color);
                    }
                } else {
                    finishSequenceAndLogError(""Invalid ISO-8613-3 SGR first argument: "" + firstArg);
                }
            } else if (code == 39) { // Set default foreground color.
                mForeColor = TextStyle.COLOR_INDEX_FOREGROUND;
            } else if (code >= 40 && code <= 47) { // Set background color.
                mBackColor = code - 40;
            } else if (code == 49) { // Set default background color.
                mBackColor = TextStyle.COLOR_INDEX_BACKGROUND;
            } else if (code >= 90 && code <= 97) { // Bright foreground colors (aixterm codes).
                mForeColor = code - 90 + 8;
            } else if (code >= 100 && code <= 107) { // Bright background color (aixterm codes).
                mBackColor = code - 100 + 8;
            } else {
                if (LOG_ESCAPE_SEQUENCES)
                    mClient.logWarn(LOG_TAG, String.format(""SGR unknown code %d"", code));
            }
        }
    }

    private void doOsc(int b) {
        switch (b) {
            case 7: // Bell.
                doOscSetTextParameters(""\007"");
                break;
            case 27: // Escape.
                continueSequence(ESC_OSC_ESC);
                break;
            default:
                collectOSCArgs(b);
                break;
        }
    }

    private void doOscEsc(int b) {
        switch (b) {
            case '\\':
                doOscSetTextParameters(""\033\\"");
                break;
            default:
                // The ESC character was not followed by a \, so insert the ESC and
                // the current character in arg buffer.
                collectOSCArgs(27);
                collectOSCArgs(b);
                continueSequence(ESC_OSC);
                break;
        }
    }

    /** An Operating System Controls (OSC) Set Text Parameters. May come here from BEL or ST. */
    private void doOscSetTextParameters(String bellOrStringTerminator) {
        int value = -1;
        String textParameter = """";
        // Extract initial $value from initial ""$value;..."" string.
        for (int mOSCArgTokenizerIndex = 0; mOSCArgTokenizerIndex < mOSCOrDeviceControlArgs.length(); mOSCArgTokenizerIndex++) {
            char b = mOSCOrDeviceControlArgs.charAt(mOSCArgTokenizerIndex);
            if (b == ';') {
                textParameter = mOSCOrDeviceControlArgs.substring(mOSCArgTokenizerIndex + 1);
                break;
            } else if (b >= '0' && b <= '9') {
                value = ((value < 0) ? 0 : value * 10) + (b - '0');
            } else {
                unknownSequence(b);
                return;
            }
        }

        switch (value) {
            case 0: // Change icon name and window title to T.
            case 1: // Change icon name to T.
            case 2: // Change window title to T.
                setTitle(textParameter);
                break;
            case 4:
                // P s = 4 ; c ; spec → Change Color Number c to the color specified by spec. This can be a name or RGB
                // specification as per XParseColor. Any number of c name pairs may be given. The color numbers correspond
                // to the ANSI colors 0-7, their bright versions 8-15, and if supported, the remainder of the 88-color or
                // 256-color table.
                // If a ""?"" is given rather than a name or RGB specification, xterm replies with a control sequence of the
                // same form which can be used to set the corresponding color. Because more than one pair of color number
                // and specification can be given in one control sequence, xterm can make more than one reply.
                int colorIndex = -1;
                int parsingPairStart = -1;
                for (int i = 0; ; i++) {
                    boolean endOfInput = i == textParameter.length();
                    char b = endOfInput ? ';' : textParameter.charAt(i);
                    if (b == ';') {
                        if (parsingPairStart < 0) {
                            parsingPairStart = i + 1;
                        } else {
                            if (colorIndex < 0 || colorIndex > 255) {
                                unknownSequence(b);
                                return;
                            } else {
                                mColors.tryParseColor(colorIndex, textParameter.substring(parsingPairStart, i));
                                mSession.onColorsChanged();
                                colorIndex = -1;
                                parsingPairStart = -1;
                            }
                        }
                    } else if (parsingPairStart >= 0) {
                        // We have passed a color index and are now going through color spec.
                    } else if (parsingPairStart < 0 && (b >= '0' && b <= '9')) {
                        colorIndex = ((colorIndex < 0) ? 0 : colorIndex * 10) + (b - '0');
                    } else {
                        unknownSequence(b);
                        return;
                    }
                    if (endOfInput) break;
                }
                break;
            case 10: // Set foreground color.
            case 11: // Set background color.
            case 12: // Set cursor color.
                int specialIndex = TextStyle.COLOR_INDEX_FOREGROUND + (value - 10);
                int lastSemiIndex = 0;
                for (int charIndex = 0; ; charIndex++) {
                    boolean endOfInput = charIndex == textParameter.length();
                    if (endOfInput || textParameter.charAt(charIndex) == ';') {
                        try {
                            String colorSpec = textParameter.substring(lastSemiIndex, charIndex);
                            if (""?"".equals(colorSpec)) {
                                // Report current color in the same format xterm and gnome-terminal does.
                                int rgb = mColors.mCurrentColors[specialIndex];
                                int r = (65535 * ((rgb & 0x00FF0000) >> 16)) / 255;
                                int g = (65535 * ((rgb & 0x0000FF00) >> 8)) / 255;
                                int b = (65535 * ((rgb & 0x000000FF))) / 255;
                                mSession.write(""\033]"" + value + "";rgb:"" + String.format(Locale.US, ""%04x"", r) + ""/"" + String.format(Locale.US, ""%04x"", g) + ""/""
                                    + String.format(Locale.US, ""%04x"", b) + bellOrStringTerminator);
                            } else {
                                mColors.tryParseColor(specialIndex, colorSpec);
                                mSession.onColorsChanged();
                            }
                            specialIndex++;
                            if (endOfInput || (specialIndex > TextStyle.COLOR_INDEX_CURSOR) || ++charIndex >= textParameter.length())
                                break;
                            lastSemiIndex = charIndex;
                        } catch (NumberFormatException e) {
                            // Ignore.
                        }
                    }
                }
                break;
            case 52: // Manipulate Selection Data. Skip the optional first selection parameter(s).
                int startIndex = textParameter.indexOf("";"") + 1;
                try {
                    String clipboardText = new String(Base64.decode(textParameter.substring(startIndex), 0), StandardCharsets.UTF_8);
                    mSession.onCopyTextToClipboard(clipboardText);
                } catch (Exception e) {
                    mClient.logError(LOG_TAG, ""OSC Manipulate selection, invalid string '"" + textParameter + """");
                }
                break;
            case 104:
                // ""104;$c"" → Reset Color Number $c. It is reset to the color specified by the corresponding X
                // resource. Any number of c parameters may be given. These parameters correspond to the ANSI colors 0-7,
                // their bright versions 8-15, and if supported, the remainder of the 88-color or 256-color table. If no
                // parameters are given, the entire table will be reset.
                if (textParameter.isEmpty()) {
                    mColors.reset();
                    mSession.onColorsChanged();
                } else {
                    int lastIndex = 0;
                    for (int charIndex = 0; ; charIndex++) {
                        boolean endOfInput = charIndex == textParameter.length();
                        if (endOfInput || textParameter.charAt(charIndex) == ';') {
                            try {
                                int colorToReset = Integer.parseInt(textParameter.substring(lastIndex, charIndex));
                                mColors.reset(colorToReset);
                                mSession.onColorsChanged();
                                if (endOfInput) break;
                                charIndex++;
                                lastIndex = charIndex;
                            } catch (NumberFormatException e) {
                                // Ignore.
                            }
                        }
                    }
                }
                break;
            case 110: // Reset foreground color.
            case 111: // Reset background color.
            case 112: // Reset cursor color.
                mColors.reset(TextStyle.COLOR_INDEX_FOREGROUND + (value - 110));
                mSession.onColorsChanged();
                break;
            case 119: // Reset highlight color.
                break;
            default:
                unknownParameter(value);
                break;
        }
        finishSequence();
    }

    private void blockClear(int sx, int sy, int w) {
        blockClear(sx, sy, w, 1);
    }

    private void blockClear(int sx, int sy, int w, int h) {
        mScreen.blockSet(sx, sy, w, h, ' ', getStyle());
    }

    private long getStyle() {
        return TextStyle.encode(mForeColor, mBackColor, mEffect);
    }

    /** ""CSI P_m h"" for set or ""CSI P_m l"" for reset ANSI mode. */
    private void doSetMode(boolean newValue) {
        int modeBit = getArg0(0);
        switch (modeBit) {
            case 4: // Set=""Insert Mode"". Reset=""Replace Mode"". (IRM).
                mInsertMode = newValue;
                break;
            case 20: // Normal Linefeed (LNM).
                unknownParameter(modeBit);
                // http://www.vt100.net/docs/vt510-rm/LNM
                break;
            case 34:
                // Normal cursor visibility - when using TERM=screen, see
                // http://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html
                break;
            default:
                unknownParameter(modeBit);
                break;
        }
    }

    /**
     * NOTE: The parameters of this function respect the {@link #DECSET_BIT_ORIGIN_MODE}. Use
     * {@link #setCursorRowCol(int, int)} for absolute pos.
     */
    private void setCursorPosition(int x, int y) {
        boolean originMode = isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);
        int effectiveTopMargin = originMode ? mTopMargin : 0;
        int effectiveBottomMargin = originMode ? mBottomMargin : mRows;
        int effectiveLeftMargin = originMode ? mLeftMargin : 0;
        int effectiveRightMargin = originMode ? mRightMargin : mColumns;
        int newRow = Math.max(effectiveTopMargin, Math.min(effectiveTopMargin + y, effectiveBottomMargin - 1));
        int newCol = Math.max(effectiveLeftMargin, Math.min(effectiveLeftMargin + x, effectiveRightMargin - 1));
        setCursorRowCol(newRow, newCol);
    }

    private void scrollDownOneLine() {
        mScrollCounter++;
        if (mLeftMargin != 0 || mRightMargin != mColumns) {
            // Horizontal margin: Do not put anything into scroll history, just non-margin part of screen up.
            mScreen.blockCopy(mLeftMargin, mTopMargin + 1, mRightMargin - mLeftMargin, mBottomMargin - mTopMargin - 1, mLeftMargin, mTopMargin);
            // .. and blank bottom row between margins:
            mScreen.blockSet(mLeftMargin, mBottomMargin - 1, mRightMargin - mLeftMargin, 1, ' ', mEffect);
        } else {
            mScreen.scrollDownOneLine(mTopMargin, mBottomMargin, getStyle());
        }
    }

    /** Process the next ASCII character of a parameter. */
    private void parseArg(int b) {
        if (b >= '0' && b <= '9') {
            if (mArgIndex < mArgs.length) {
                int oldValue = mArgs[mArgIndex];
                int thisDigit = b - '0';
                int value;
                if (oldValue >= 0) {
                    value = oldValue * 10 + thisDigit;
                } else {
                    value = thisDigit;
                }
                mArgs[mArgIndex] = value;
            }
            continueSequence(mEscapeState);
        } else if (b == ';') {
            if (mArgIndex < mArgs.length) {
                mArgIndex++;
            }
            continueSequence(mEscapeState);
        } else {
            unknownSequence(b);
        }
    }

    private int getArg0(int defaultValue) {
        return getArg(0, defaultValue, true);
    }

    private int getArg1(int defaultValue) {
        return getArg(1, defaultValue, true);
    }

    private int getArg(int index, int defaultValue, boolean treatZeroAsDefault) {
        int result = mArgs[index];
        if (result < 0 || (result == 0 && treatZeroAsDefault)) {
            result = defaultValue;
        }
        return result;
    }

    private void collectOSCArgs(int b) {
        if (mOSCOrDeviceControlArgs.length() < MAX_OSC_STRING_LENGTH) {
            mOSCOrDeviceControlArgs.appendCodePoint(b);
            continueSequence(mEscapeState);
        } else {
            unknownSequence(b);
        }
    }

    private void unimplementedSequence(int b) {
        logError(""Unimplemented sequence char '"" + (char) b + ""' (U+"" + String.format(""%04x"", b) + "")"");
        finishSequence();
    }

    private void unknownSequence(int b) {
        logError(""Unknown sequence char '"" + (char) b + ""' (numeric value="" + b + "")"");
        finishSequence();
    }

    private void unknownParameter(int parameter) {
        logError(""Unknown parameter: "" + parameter);
        finishSequence();
    }

    private void logError(String errorType) {
        if (LOG_ESCAPE_SEQUENCES) {
            StringBuilder buf = new StringBuilder();
            buf.append(errorType);
            buf.append("", escapeState="");
            buf.append(mEscapeState);
            boolean firstArg = true;
            if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
            for (int i = 0; i <= mArgIndex; i++) {
                int value = mArgs[i];
                if (value >= 0) {
                    if (firstArg) {
                        firstArg = false;
                        buf.append("", args={"");
                    } else {
                        buf.append(',');
                    }
                    buf.append(value);
                }
            }
            if (!firstArg) buf.append('}');
            finishSequenceAndLogError(buf.toString());
        }
    }

    private void finishSequenceAndLogError(String error) {
        if (LOG_ESCAPE_SEQUENCES) mClient.logWarn(LOG_TAG, error);
        finishSequence();
    }

    private void finishSequence() {
        mEscapeState = ESC_NONE;
    }

    /**
     * Send a Unicode code point to the screen.
     *
     * @param codePoint The code point of the character to display
     */
    private void emitCodePoint(int codePoint) {
        mLastEmittedCodePoint = codePoint;
        if (mUseLineDrawingUsesG0 ? mUseLineDrawingG0 : mUseLineDrawingG1) {
            // http://www.vt100.net/docs/vt102-ug/table5-15.html.
            switch (codePoint) {
                case '_':
                    codePoint = ' '; // Blank.
                    break;
                case '`':
                    codePoint = '◆'; // Diamond.
                    break;
                case '0':
                    codePoint = '█'; // Solid block;
                    break;
                case 'a':
                    codePoint = '▒'; // Checker board.
                    break;
                case 'b':
                    codePoint = '␉'; // Horizontal tab.
                    break;
                case 'c':
                    codePoint = '␌'; // Form feed.
                    break;
                case 'd':
                    codePoint = '\r'; // Carriage return.
                    break;
                case 'e':
                    codePoint = '␊'; // Linefeed.
                    break;
                case 'f':
                    codePoint = '°'; // Degree.
                    break;
                case 'g':
                    codePoint = '±'; // Plus-minus.
                    break;
                case 'h':
                    codePoint = '\n'; // Newline.
                    break;
                case 'i':
                    codePoint = '␋'; // Vertical tab.
                    break;
                case 'j':
                    codePoint = '┘'; // Lower right corner.
                    break;
                case 'k':
                    codePoint = '┐'; // Upper right corner.
                    break;
                case 'l':
                    codePoint = '┌'; // Upper left corner.
                    break;
                case 'm':
                    codePoint = '└'; // Left left corner.
                    break;
                case 'n':
                    codePoint = '┼'; // Crossing lines.
                    break;
                case 'o':
                    codePoint = '⎺'; // Horizontal line - scan 1.
                    break;
                case 'p':
                    codePoint = '⎻'; // Horizontal line - scan 3.
                    break;
                case 'q':
                    codePoint = '─'; // Horizontal line - scan 5.
                    break;
                case 'r':
                    codePoint = '⎼'; // Horizontal line - scan 7.
                    break;
                case 's':
                    codePoint = '⎽'; // Horizontal line - scan 9.
                    break;
                case 't':
                    codePoint = '├'; // T facing rightwards.
                    break;
                case 'u':
                    codePoint = '┤'; // T facing leftwards.
                    break;
                case 'v':
                    codePoint = '┴'; // T facing upwards.
                    break;
                case 'w':
                    codePoint = '┬'; // T facing downwards.
                    break;
                case 'x':
                    codePoint = '│'; // Vertical line.
                    break;
                case 'y':
                    codePoint = '≤'; // Less than or equal to.
                    break;
                case 'z':
                    codePoint = '≥'; // Greater than or equal to.
                    break;
                case '{':
                    codePoint = 'π'; // Pi.
                    break;
                case '|':
                    codePoint = '≠'; // Not equal to.
                    break;
                case '}':
                    codePoint = '£'; // UK pound.
                    break;
                case '~':
                    codePoint = '·'; // Centered dot.
                    break;
            }
        }

        final boolean autoWrap = isDecsetInternalBitSet(DECSET_BIT_AUTOWRAP);
        final int displayWidth = WcWidth.width(codePoint);
        final boolean cursorInLastColumn = mCursorCol == mRightMargin - 1;

        if (autoWrap) {
            if (cursorInLastColumn && ((mAboutToAutoWrap && displayWidth == 1) || displayWidth == 2)) {
                mScreen.setLineWrap(mCursorRow);
                mCursorCol = mLeftMargin;
                if (mCursorRow + 1 < mBottomMargin) {
                    mCursorRow++;
                } else {
                    scrollDownOneLine();
                }
            }
        } else if (cursorInLastColumn && displayWidth == 2) {
            // The behaviour when a wide character is output with cursor in the last column when
            // autowrap is disabled is not obvious - it's ignored here.
            return;
        }

        if (mInsertMode && displayWidth > 0) {
            // Move character to right one space.
            int destCol = mCursorCol + displayWidth;
            if (destCol < mRightMargin)
                mScreen.blockCopy(mCursorCol, mCursorRow, mRightMargin - destCol, 1, destCol, mCursorRow);
        }

        int offsetDueToCombiningChar = ((displayWidth <= 0 && mCursorCol > 0 && !mAboutToAutoWrap) ? 1 : 0);
        mScreen.setChar(mCursorCol - offsetDueToCombiningChar, mCursorRow, codePoint, getStyle());

        if (autoWrap && displayWidth > 0)
            mAboutToAutoWrap = (mCursorCol == mRightMargin - displayWidth);

        mCursorCol = Math.min(mCursorCol + displayWidth, mRightMargin - 1);
    }

    private void setCursorRow(int row) {
        mCursorRow = row;
        mAboutToAutoWrap = false;
    }

    private void setCursorCol(int col) {
        mCursorCol = col;
        mAboutToAutoWrap = false;
    }

    /** Set the cursor mode, but limit it to margins if {@link #DECSET_BIT_ORIGIN_MODE} is enabled. */
    private void setCursorColRespectingOriginMode(int col) {
        setCursorPosition(col, mCursorRow);
    }

    /** TODO: Better name, distinguished from {@link #setCursorPosition(int, int)} by not regarding origin mode. */
    private void setCursorRowCol(int row, int col) {
        mCursorRow = Math.max(0, Math.min(row, mRows - 1));
        mCursorCol = Math.max(0, Math.min(col, mColumns - 1));
        mAboutToAutoWrap = false;
    }

    public int getScrollCounter() {
        return mScrollCounter;
    }

    public void clearScrollCounter() {
        mScrollCounter = 0;
    }

    /** Reset terminal state so user can interact with it regardless of present state. */
    public void reset() {
        setCursorStyle();
        mArgIndex = 0;
        mContinueSequence = false;
        mEscapeState = ESC_NONE;
        mInsertMode = false;
        mTopMargin = mLeftMargin = 0;
        mBottomMargin = mRows;
        mRightMargin = mColumns;
        mAboutToAutoWrap = false;
        mForeColor = mSavedStateMain.mSavedForeColor = mSavedStateAlt.mSavedForeColor = TextStyle.COLOR_INDEX_FOREGROUND;
        mBackColor = mSavedStateMain.mSavedBackColor = mSavedStateAlt.mSavedBackColor = TextStyle.COLOR_INDEX_BACKGROUND;
        setDefaultTabStops();

        mUseLineDrawingG0 = mUseLineDrawingG1 = false;
        mUseLineDrawingUsesG0 = true;

        mSavedStateMain.mSavedCursorRow = mSavedStateMain.mSavedCursorCol = mSavedStateMain.mSavedEffect = mSavedStateMain.mSavedDecFlags = 0;
        mSavedStateAlt.mSavedCursorRow = mSavedStateAlt.mSavedCursorCol = mSavedStateAlt.mSavedEffect = mSavedStateAlt.mSavedDecFlags = 0;
        mCurrentDecSetFlags = 0;
        // Initial wrap-around is not accurate but makes terminal more useful, especially on a small screen:
        setDecsetinternalBit(DECSET_BIT_AUTOWRAP, true);
        setDecsetinternalBit(DECSET_BIT_CURSOR_ENABLED, true);
        mSavedDecSetFlags = mSavedStateMain.mSavedDecFlags = mSavedStateAlt.mSavedDecFlags = mCurrentDecSetFlags;

        // XXX: Should we set terminal driver back to IUTF8 with termios?
        mUtf8Index = mUtf8ToFollow = 0;

        mColors.reset();
        mSession.onColorsChanged();
    }

    public String getSelectedText(int x1, int y1, int x2, int y2) {
        return mScreen.getSelectedText(x1, y1, x2, y2);
    }

    /** Get the terminal session's title (null if not set). */
    public String getTitle() {
        return mTitle;
    }

    /** Change the terminal session's title. */
    private void setTitle(String newTitle) {
        String oldTitle = mTitle;
        mTitle = newTitle;
        if (!Objects.equals(oldTitle, newTitle)) {
            mSession.titleChanged(oldTitle, newTitle);
        }
    }

    /** If DECSET 2004 is set, prefix paste with ""\033[200~"" and suffix with ""\033[201~"". */
    public void paste(String text) {
        // First: Always remove escape key and C1 control characters [0x80,0x9F]:
        text = text.replaceAll(""(\u001B|[\u0080-\u009F])"", """");
        // Second: Replace all newlines (\n) or CRLF (\r\n) with carriage returns (\r).
        text = text.replaceAll(""\r?\n"", ""\r"");

        // Then: Implement bracketed paste mode if enabled:
        boolean bracketed = isDecsetInternalBitSet(DECSET_BIT_BRACKETED_PASTE_MODE);
        if (bracketed) mSession.write(""\033[200~"");
        mSession.write(text);
        if (bracketed) mSession.write(""\033[201~"");
    }

    /** http://www.vt100.net/docs/vt510-rm/DECSC */
    static final class SavedScreenState {
        /** Saved state of the cursor position, Used to implement the save/restore cursor position escape sequences. */
        int mSavedCursorRow, mSavedCursorCol;
        int mSavedEffect, mSavedForeColor, mSavedBackColor;
        int mSavedDecFlags;
        boolean mUseLineDrawingG0, mUseLineDrawingG1, mUseLineDrawingUsesG0 = true;
    }

    @Override
    public String toString() {
        return ""TerminalEmulator[size="" + mScreen.mColumns + ""x"" + mScreen.mScreenRows + "", margins={"" + mTopMargin + "","" + mRightMargin + "","" + mBottomMargin
            + "","" + mLeftMargin + ""}]"";
    }

}",1,439 381 334 2000 123 618 437 457 381 324 2001 61 380 59 439 457 381 404 2002 61 1500 59 618 439 457 381 404 2003 61 1503 59 439 457 381 404 2004 61 1503 59 439 457 381 404 2005 61 1503 59 618 439 457 381 404 2006 61 1506 59 618 437 457 381 404 2007 61 1500 59 618 437 457 381 404 2008 61 1501 59 618 437 457 381 404 2009 61 1502 59 618 437 457 381 404 2010 61 1502 59 618 437 457 381 404 2011 61 1502 59 618 437 457 381 404 2012 61 1502 59 618 437 457 381 404 2013 61 1502 59 618 437 457 381 404 2014 61 1502 59 618 437 457 381 404 2015 61 1502 59 618 437 457 381 404 2016 61 1502 59 618 437 457 381 404 2017 61 1503 59 618 437 457 381 404 2018 61 1503 59 618 437 457 381 404 2019 61 1503 59 618 437 457 381 404 2020 61 1503 59 618 437 457 381 404 2021 61 1503 59 618 437 457 381 404 2022 61 1503 59 618 437 457 381 404 2023 61 1503 59 618 437 457 381 404 2024 61 1503 59 618 437 457 381 404 2025 61 1503 59 618 437 457 381 404 2026 61 1503 59 618 437 457 381 404 2027 61 1505 59 618 437 457 381 404 2028 61 1501 59 437 457 381 404 2029 61 1501 622 1501 59 618 437 457 381 404 2030 61 1501 622 1502 59 618 437 457 381 404 2031 61 1501 622 1502 59 618 437 457 381 404 2032 61 1501 622 1502 59 437 457 381 404 2033 61 1501 622 1502 59 618 437 457 381 404 2034 61 1501 622 1502 59 618 437 457 381 404 2035 61 1501 622 1502 59 618 437 457 381 404 2036 61 1501 622 1502 59 618 437 457 381 404 2037 61 1501 622 1502 59 618 437 457 381 404 2038 61 1501 622 1502 59 618 437 457 381 404 2039 61 1501 622 1503 59 618 437 457 381 404 2040 61 1501 622 1503 59 437 2041 2042 59 437 381 2043 60 2041 62 2044 61 418 2043 60 62 40 41 59 618 437 404 2045 44 2046 59 618 439 404 2047 44 2048 59 618 439 457 381 404 2049 61 1503 59 439 457 381 404 2050 61 1506 59 439 457 381 404 2051 61 1505 59 604 439 457 381 404 2052 61 1500 59 439 457 381 404 2053 61 1501 59 439 457 381 404 2054 61 1502 59 439 457 381 404 2055 61 2052 59 439 457 381 2056 91 93 2057 61 418 2056 91 93 123 2052 44 2053 44 2054 125 59 618 437 404 2058 61 2055 59 618 437 381 2059 2060 59 618 381 2059 2061 59 618 437 2059 2062 59 618 437 381 2063 2064 59 2065 2066 59 618 437 404 2067 59 618 437 381 404 91 93 2068 61 418 404 91 2026 93 59 618 437 381 2069 2070 61 418 2069 40 41 59 618 437 324 2071 59 618 437 404 2072 59 437 381 2073 2074 61 418 2073 40 41 59 437 381 2073 2075 61 418 2073 40 41 59 618 437 324 2076 44 2077 44 2078 61 473 59 618 437 404 2079 44 2080 59 618 437 324 2081 59 618 437 324 91 93 2082 59 618 437 404 2083 44 2084 44 2085 44 2086 59 618 437 324 2087 59 618 437 324 2088 59 618 437 324 2089 59 618 404 2090 44 2091 59 618 437 404 2092 59 618 437 404 2093 61 1500 59 437 326 2094 44 2095 59 437 381 326 91 93 2096 61 418 326 91 1502 93 59 437 404 2097 61 45 1501 59 439 381 2098 2099 61 418 2098 40 41 59 437 457 381 2041 2100 61 648 59 437 324 2101 40 404 2102 41 123 450 40 2079 38 2102 41 631 1500 59 125 437 492 2103 40 404 2104 44 324 2105 41 123 392 40 2105 41 123 621 392 40 2104 614 2034 41 123 2103 40 2035 44 380 41 59 125 360 392 40 2104 614 2035 41 123 2103 40 2034 44 380 41 59 125 125 392 40 2105 41 123 2079 635 2104 59 125 360 123 2079 601 126 2104 59 125 125 457 404 2106 40 404 2107 41 123 464 40 2107 41 123 328 1501 58 450 2028 59 328 1502 58 450 2029 59 328 1502 58 450 2030 59 328 1502 58 450 2031 59 328 1503 58 450 2032 59 328 1503 58 450 2033 59 328 1503 58 450 2039 59 328 1504 58 450 2034 59 328 1505 58 450 2035 59 328 1505 58 450 2036 59 328 1505 58 450 2037 59 328 1505 58 450 2038 59 349 58 450 45 1501 59 621 125 125 439 2000 40 2063 2108 44 404 2109 44 404 2110 44 2056 2111 44 2065 2112 41 123 2064 61 2108 59 2062 61 2060 61 418 2059 40 2109 44 2113 40 2111 41 44 2110 41 59 2061 61 418 2059 40 2109 44 2110 44 2110 41 59 2066 61 2112 59 2047 61 2110 59 2048 61 2109 59 2082 61 418 324 91 2048 93 59 2114 40 41 59 125 439 492 2115 40 2065 2112 41 123 2066 61 2112 59 2116 40 41 59 2117 40 473 41 59 125 439 2059 2118 40 41 123 450 2062 59 125 439 324 2119 40 41 123 450 2062 614 2061 59 125 437 404 2120 40 2056 2111 41 123 392 40 2111 614 424 606 2111 60 2049 606 2111 62 2050 41 450 2051 59 360 450 2111 59 125 618 439 492 2121 40 404 2122 44 404 2123 44 404 2124 44 324 2125 41 123 392 40 2123 60 1501 41 2123 61 1501 59 392 40 2123 62 2048 41 2123 61 2048 59 392 40 2124 60 1501 41 2124 61 1501 59 392 40 2124 62 2047 41 2124 61 2047 59 392 40 2122 614 2003 605 33 2101 40 2035 41 41 123 621 125 360 392 40 2101 40 2037 41 41 123 2064 46 2126 40 2041 46 2127 40 648 43 40 2125 63 607 58 607 41 44 2122 44 2123 44 2124 41 41 59 125 360 123 2122 61 2125 63 2122 58 1502 59 621 621 324 2128 61 2123 62 1504 45 1503 606 2124 62 1504 45 1503 59 392 40 33 2128 41 123 326 91 93 2129 61 123 607 44 607 44 607 44 40 326 41 40 1503 43 2122 41 44 40 326 41 40 1503 43 2123 41 44 40 326 41 40 1503 43 2124 41 125 59 2064 46 2130 40 2129 44 1500 44 2129 46 2131 41 59 125 125 125 439 492 2132 40 404 2109 44 404 2110 41 123 392 40 2047 614 2110 605 2048 614 2109 41 123 450 59 125 360 392 40 2109 60 1502 606 2110 60 1502 41 123 469 418 2133 40 648 43 2110 43 648 43 2109 41 59 125 392 40 2047 631 2110 41 123 2047 61 2110 59 2083 61 1500 59 2084 61 2047 59 125 392 40 2048 631 2109 41 123 404 2134 61 2048 59 2048 61 2109 59 324 91 93 2135 61 2082 59 2082 61 418 324 91 2048 93 59 2136 40 41 59 404 2137 61 2138 46 2139 40 2134 44 2109 41 59 2140 46 2141 40 2135 44 1500 44 2082 44 1500 44 2137 41 59 2085 61 1500 59 2086 61 2048 59 125 2142 40 41 59 125 437 492 2143 40 41 123 381 404 91 93 2144 61 123 2046 44 2045 125 59 404 2145 61 40 2062 614 2061 41 63 2047 58 2060 46 2146 59 2062 46 2132 40 2048 44 2047 44 2145 44 2144 44 2147 40 41 44 2119 40 41 41 59 2046 61 2144 91 1500 93 59 2045 61 2144 91 1501 93 59 125 439 404 2148 40 41 123 450 2045 59 125 439 404 2149 40 41 123 450 2046 59 125 618 439 404 2150 40 41 123 450 2058 59 125 618 439 492 2151 40 41 123 2056 2152 61 424 59 392 40 2066 631 424 41 2152 61 2066 46 2153 40 41 59 392 40 2152 614 424 606 33 2154 46 2155 40 2057 41 46 2156 40 2152 41 41 2058 61 2055 59 360 2058 61 2152 59 125 439 324 2157 40 41 123 450 2101 40 2029 41 59 125 439 324 2158 40 41 123 450 2101 40 2032 41 59 125 439 324 2159 40 41 123 392 40 33 2158 40 41 41 450 380 59 360 450 2088 63 2089 58 473 59 125 439 492 2160 40 324 2161 41 123 467 46 2088 61 2161 59 125 439 492 2162 40 324 2163 41 123 467 46 2089 61 2163 59 125 439 324 2164 40 41 123 450 2101 40 2033 41 59 125 439 324 2165 40 41 123 450 2101 40 2028 41 59 125 618 439 324 2166 40 41 123 450 2101 40 2034 41 606 2101 40 2035 41 59 125 437 492 2167 40 41 123 385 40 404 2168 61 1500 59 2168 60 2048 59 2168 637 41 2082 91 2168 93 61 40 2168 38 1502 41 614 1500 605 2168 631 1500 59 125 618 439 492 2169 40 326 91 93 2170 44 404 2171 41 123 385 40 404 2172 61 1500 59 2172 60 2171 59 2172 637 41 2173 40 2170 91 2172 93 41 59 125 437 492 2174 40 326 2175 41 123 392 40 2094 62 1500 41 123 392 40 40 2175 38 1500 41 614 1500 41 123 621 2096 91 2095 637 93 61 2175 59 392 40 629 2094 614 1500 41 123 326 2176 61 40 326 41 40 2095 614 1502 63 1500 58 40 2095 614 1502 63 1500 58 1500 41 41 59 404 2177 61 40 2096 91 1500 93 38 2176 41 59 385 40 404 2178 61 1501 59 2178 60 2095 59 2178 637 41 2177 61 40 40 2177 622 1502 41 124 40 2096 91 2178 93 38 1500 41 41 59 392 40 40 40 2177 620 1500 41 605 2095 62 1501 41 606 40 2177 60 1500 605 2095 62 1502 41 606 40 2177 60 1500 605 2095 62 1502 41 41 123 621 2177 61 2006 59 125 2095 61 2094 61 1500 59 392 40 2177 615 1504 605 2177 620 1504 41 123 621 621 621 621 621 125 360 123 464 40 2179 46 2180 40 2177 41 41 123 328 2179 46 2181 58 328 2179 46 2182 58 2177 61 2006 59 125 2183 40 2177 41 59 125 125 125 360 123 621 2095 61 2094 61 1500 59 2184 40 2006 41 59 621 621 621 621 621 621 621 2174 40 2175 41 59 125 125 360 123 392 40 40 2175 38 1500 41 614 1500 41 123 621 2185 40 2175 41 59 450 59 125 360 392 40 40 2175 38 1500 41 614 1500 41 123 621 2094 61 1501 59 125 360 392 40 40 2175 38 1500 41 614 1500 41 123 621 2094 61 1502 59 125 360 392 40 40 2175 38 1500 41 614 1500 41 123 621 2094 61 1502 59 125 360 123 621 2186 40 2006 41 59 450 59 125 2096 91 2095 637 93 61 2175 59 125 125 439 492 2187 40 404 2188 41 123 464 40 2188 41 123 328 1500 58 621 325 59 328 1502 58 621 392 40 2072 614 2016 41 2189 40 2188 41 59 360 2064 46 2190 40 41 59 325 59 328 1502 58 621 392 40 2085 614 2046 41 123 621 404 2191 61 2045 45 1501 59 392 40 2191 615 1500 605 2062 46 2192 40 2191 41 41 123 2062 46 2193 40 2191 41 59 2194 40 2191 44 2086 45 1501 41 59 125 125 360 123 2195 40 2046 45 1501 41 59 125 325 59 328 1502 58 621 621 621 621 621 621 621 621 2046 61 2196 40 1501 41 59 325 59 328 1502 58 621 328 1503 58 621 328 1503 58 621 2197 40 41 59 325 59 328 1503 58 621 2198 40 2085 41 59 325 59 328 1503 58 621 2078 61 380 59 325 59 328 1503 58 621 2078 61 473 59 325 59 328 1503 58 621 328 1503 58 621 392 40 2072 631 2007 41 123 621 2072 61 2007 59 2199 40 1504 41 59 125 325 59 328 1503 58 621 621 392 40 2072 614 2019 41 123 621 450 59 125 360 392 40 2072 631 2016 41 123 2200 40 41 59 125 360 123 2189 40 2188 41 59 125 325 59 349 58 2071 61 380 59 464 40 2072 41 123 328 2007 58 392 40 2188 615 1503 41 2201 40 2188 41 59 325 59 328 2008 58 2202 40 2188 41 59 325 59 328 2009 58 2203 40 2188 41 59 325 59 328 2010 58 621 2076 61 40 2188 614 607 41 59 325 59 328 2011 58 621 2077 61 40 2188 614 607 41 59 325 59 328 2012 58 2204 40 2188 41 59 325 59 328 2025 58 392 40 2188 614 607 41 123 621 2205 40 41 59 125 360 123 2206 40 2188 41 59 125 325 59 328 2013 58 2207 40 2188 41 59 325 59 328 2018 58 2208 40 2188 41 59 325 59 328 2014 58 324 2209 61 2101 40 2030 41 59 404 2210 61 2209 63 2083 58 1500 59 404 2211 61 2209 63 2084 58 2047 59 404 2212 61 2209 63 2085 58 1500 59 404 2213 61 2209 63 2086 58 2048 59 464 40 2188 41 123 328 607 58 621 621 621 621 621 621 621 621 621 621 404 2214 61 2215 46 2216 40 2217 40 1500 44 1501 44 473 41 45 1501 43 2210 44 2047 41 59 404 2218 61 2215 46 2216 40 2217 40 1501 44 1501 44 473 41 45 1501 43 2212 44 2048 41 59 621 404 2219 61 2215 46 2216 40 2215 46 2220 40 2217 40 1502 44 2047 44 473 41 43 2210 44 2214 41 44 2047 41 59 404 2221 61 2215 46 2216 40 2215 46 2220 40 2217 40 1502 44 2048 44 473 41 43 2212 44 2218 41 44 2048 41 59 621 404 2222 61 2215 46 2216 40 2217 40 1502 44 1501 44 473 41 45 1501 43 2210 44 2047 41 59 404 2223 61 2215 46 2216 40 2217 40 1502 44 1501 44 473 41 45 1501 43 2212 44 2048 41 59 621 404 2224 61 2215 46 2216 40 2047 45 2222 44 2219 45 2214 41 59 404 2225 61 2215 46 2216 40 2048 45 2223 44 2221 45 2218 41 59 2062 46 2226 40 2218 44 2214 44 2225 44 2224 44 2223 44 2222 41 59 325 59 328 607 58 621 621 328 607 58 621 621 328 607 58 621 621 324 2227 61 2188 631 607 59 324 2228 61 2188 614 607 59 621 324 2229 61 2227 605 2228 59 404 2230 61 1500 59 404 2231 61 2227 63 607 58 2217 40 2230 637 44 45 1501 44 473 41 59 621 621 392 40 40 2231 615 1503 605 2231 620 1504 41 606 40 2231 615 1504 605 2231 620 1504 41 41 123 621 621 404 2232 61 2215 46 2216 40 2217 40 2230 637 44 1501 44 473 41 43 2210 44 2211 43 1501 41 59 404 2233 61 2215 46 2216 40 2217 40 2230 637 44 1501 44 473 41 43 2212 44 2213 43 1501 41 59 404 2234 61 2215 46 2216 40 2217 40 2230 637 44 2047 44 473 41 43 2210 44 2211 41 59 404 2235 61 2215 46 2216 40 2217 40 2230 44 2048 44 473 41 43 2212 44 2213 41 59 413 2236 61 2237 40 41 59 385 40 404 2124 61 2232 45 1501 59 2124 60 2234 59 2124 637 41 385 40 404 2238 61 2233 45 1501 59 2238 60 2235 59 2238 637 41 392 40 33 2228 606 40 2239 46 2240 40 2062 46 2241 40 2124 44 2238 41 41 38 2239 46 2242 41 614 1500 41 2062 46 2243 40 2238 44 2124 44 2231 44 2229 63 2062 46 2241 40 2124 44 2238 41 58 2236 41 59 125 325 59 328 607 58 621 621 328 607 58 621 621 324 2244 61 2188 614 607 59 621 404 2245 61 2215 46 2216 40 2217 40 1500 44 1501 44 473 41 45 1501 44 2211 41 43 2210 59 404 2246 61 2215 46 2216 40 2217 40 1501 44 1501 44 473 41 45 1501 44 2213 41 43 2212 59 404 2247 61 2215 46 2216 40 2217 40 1502 44 2047 44 473 41 43 1501 44 2211 45 1501 41 43 2210 59 404 2248 61 2215 46 2216 40 2217 40 1502 44 2048 44 473 41 43 1501 44 2213 45 1501 41 43 2212 59 392 40 2067 615 1502 41 123 392 40 2067 615 2068 46 2171 41 2067 61 2068 46 2171 45 1501 59 385 40 404 2249 61 1502 59 2249 620 2067 59 2249 637 41 123 404 2250 61 1500 59 324 2251 61 473 59 621 464 40 2217 40 2249 44 1500 44 380 41 41 123 328 1500 58 621 2250 61 40 2252 46 2253 124 2252 46 2254 124 2252 46 2255 124 2252 46 2256 41 59 392 40 33 2244 41 2251 61 380 59 325 59 328 1501 58 621 2250 61 2252 46 2253 59 325 59 328 1502 58 621 2250 61 2252 46 2254 59 325 59 328 1502 58 621 2250 61 2252 46 2255 59 325 59 328 1502 58 621 2250 61 2252 46 2256 59 325 59 328 1503 58 621 2250 61 2252 46 2253 59 2251 61 380 59 325 59 328 1503 58 621 2250 61 2252 46 2254 59 2251 61 380 59 325 59 328 1503 58 621 2250 61 2252 46 2255 59 2251 61 380 59 325 59 328 1503 58 621 2250 61 2252 46 2256 59 2251 61 380 59 325 59 125 392 40 2244 605 33 2251 41 123 621 125 360 123 2062 46 2257 40 2250 44 2251 44 2244 44 2101 40 2040 41 44 2212 44 2213 44 2245 44 2246 44 2247 44 2248 41 59 125 125 125 360 123 621 125 325 59 349 58 2258 40 2188 41 59 125 325 59 328 2023 58 392 40 2188 614 607 41 123 621 404 2259 61 2260 40 1500 41 59 392 40 2259 614 1500 606 2259 614 1502 41 123 621 2092 601 126 2261 46 2262 59 125 360 392 40 2259 614 1501 41 123 621 2092 635 2263 46 2264 59 125 360 123 2265 40 2188 41 59 125 125 360 123 2266 40 2188 41 59 125 325 59 328 2024 58 392 40 2188 614 607 41 123 621 404 2267 61 2086 45 2046 59 404 2268 61 2269 46 2270 40 2271 40 1501 41 44 2267 41 59 404 2272 61 2267 45 2268 59 2062 46 2273 40 2046 44 1500 44 2272 44 2047 44 2046 43 2268 44 1500 41 59 2274 40 2046 44 1500 44 2268 44 2047 41 59 125 360 392 40 2188 614 607 41 123 621 404 2275 61 2086 45 2046 59 404 2276 61 2277 46 2278 40 2279 40 1501 41 44 2275 41 59 404 2280 61 2275 45 2276 59 2062 46 2281 40 2046 43 2276 44 1500 44 2280 44 2047 44 2046 44 1500 41 59 2282 40 2045 43 2280 44 1500 44 2276 44 2047 41 59 125 360 123 2283 40 2188 41 59 125 325 59 328 2015 58 325 59 328 2016 58 2189 40 2188 41 59 325 59 328 2017 58 2284 40 2188 41 59 325 59 328 2019 58 2285 40 2188 41 59 325 59 328 2020 58 392 40 2188 614 607 41 123 621 404 2286 61 2287 40 1500 41 59 404 2288 59 392 40 2286 614 1503 606 2286 614 1505 606 2286 614 1505 41 123 621 2288 61 40 2062 614 2061 41 63 1501 58 1502 59 125 360 123 404 2104 61 2106 40 2286 41 59 392 40 2104 631 45 1501 41 123 2288 61 2101 40 2104 41 63 1501 58 1502 59 621 125 360 123 2066 46 2289 40 2100 44 648 43 2286 41 59 2288 61 1500 59 621 125 125 2064 46 2290 40 2041 46 2291 40 2292 46 2293 44 648 44 2286 44 2288 41 41 59 125 360 123 2294 40 2188 41 59 125 325 59 328 2021 58 404 2295 61 2296 40 1500 41 59 464 40 2188 41 123 328 607 58 621 464 40 2295 41 123 328 1500 58 621 328 1501 58 621 328 1502 58 621 2058 61 2052 59 325 59 328 1502 58 621 328 1502 58 621 2058 61 2053 59 325 59 328 1502 58 621 328 1502 58 621 2058 61 2054 59 325 59 125 325 59 328 607 58 328 607 58 621 325 59 349 58 2297 40 2188 41 59 125 325 59 328 2022 58 404 2298 61 2296 40 1500 41 59 392 40 2188 614 607 605 40 2298 615 1500 605 2298 620 1502 41 41 123 621 2103 40 2040 44 2298 614 1502 41 59 125 360 123 2299 40 2188 41 59 125 325 59 349 58 2300 40 2188 41 59 325 59 125 392 40 33 2071 41 2072 61 2007 59 325 59 125 125 618 437 492 2301 40 404 2188 41 123 464 40 2188 41 123 328 40 326 41 607 58 621 123 2041 2302 61 2070 46 2303 40 41 59 621 392 40 2302 46 2304 40 648 41 41 123 392 40 2302 46 2305 40 648 41 41 123 621 2041 2306 61 648 59 2064 46 2307 40 648 43 2306 43 648 41 59 125 360 123 2308 40 648 43 2302 43 648 41 59 125 125 360 392 40 2302 46 2304 40 648 41 41 123 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 385 40 2041 2309 58 2302 46 2310 40 1502 41 46 2311 40 648 41 41 123 392 40 2309 46 2171 40 41 37 1502 614 1500 41 123 2069 2312 61 418 2069 40 41 59 385 40 404 2313 61 1500 59 2313 60 2309 46 2171 40 41 59 2313 636 1502 41 123 330 2314 61 40 330 41 2315 46 2316 40 648 43 2309 46 2317 40 2313 41 43 648 43 2309 46 2317 40 2313 43 1501 41 41 46 2318 40 41 59 2312 46 2169 40 2314 41 59 125 2041 2319 61 2312 46 2303 40 41 59 2041 2320 59 464 40 2319 41 123 328 648 58 328 648 58 2320 61 648 59 621 325 59 328 648 58 328 648 58 2320 61 648 59 325 59 349 58 2320 61 2321 46 2322 40 2319 44 2101 40 2028 41 44 2101 40 2033 41 41 59 325 59 125 392 40 2320 614 424 41 123 464 40 2319 41 123 328 648 58 621 328 648 58 621 325 59 349 58 2066 46 2323 40 2100 44 648 43 2319 43 648 41 59 125 621 2064 46 2324 40 648 43 2309 43 648 41 59 125 360 123 2069 2325 61 418 2069 40 41 59 385 40 404 2326 61 1500 59 2326 60 2320 46 2171 40 41 59 2326 637 41 123 2325 46 2169 40 2041 46 2327 40 648 44 40 404 41 2320 46 2328 40 2326 41 41 41 59 125 2064 46 2329 40 648 43 2309 43 648 43 2325 43 648 41 59 125 125 360 123 2066 46 2330 40 2100 44 648 43 2309 41 59 125 125 125 360 123 392 40 2001 41 2066 46 2331 40 2100 44 648 43 2302 41 59 125 2332 40 41 59 125 325 59 349 58 392 40 2070 46 2171 40 41 62 2027 41 123 621 2070 46 2333 40 1500 41 59 2334 40 41 59 125 360 123 2070 46 2335 40 2188 41 59 2336 40 2072 41 59 125 125 125 437 404 2337 40 404 2338 41 123 385 40 404 2339 61 2046 43 1501 59 2339 60 2048 59 2339 637 41 392 40 2082 91 2339 93 605 629 2338 614 1500 41 450 2340 46 2341 40 2339 44 2086 41 59 450 2086 45 1501 59 125 618 437 492 2342 40 404 2188 41 123 464 40 2188 41 123 328 607 58 621 328 607 58 621 2087 61 380 59 404 2343 61 607 59 404 2344 61 45 1501 59 404 2345 61 45 1501 59 404 2346 61 45 1501 59 404 2347 61 45 1501 59 324 2348 61 40 2188 614 607 41 59 464 40 2349 40 1500 41 41 123 328 1500 58 621 2344 61 2046 59 2345 61 2045 59 2346 61 2048 59 2347 61 2348 63 40 2045 43 1501 41 58 2047 59 325 59 328 1501 58 621 2344 61 1500 59 2345 61 2348 63 2045 58 1500 59 2346 61 2046 43 1501 59 2347 61 2045 43 1501 59 325 59 328 1502 58 621 2344 61 1500 59 2345 61 2348 63 2045 58 1500 59 2346 61 2048 59 2347 61 2348 63 40 2045 43 1501 41 58 2047 59 325 59 349 58 2350 40 2188 41 59 325 59 125 413 2351 61 2352 40 41 59 385 40 404 2124 61 2345 59 2124 60 2347 59 2124 637 41 123 385 40 404 2353 61 2344 59 2353 60 2346 59 2353 637 41 123 392 40 40 2354 46 2355 40 2062 46 2356 40 2124 44 2353 41 41 38 2354 46 2357 41 614 1500 41 2062 46 2358 40 2353 44 2124 44 2343 44 2351 41 59 125 125 325 59 328 607 58 328 607 58 392 40 2067 615 2068 46 2171 41 2067 61 2068 46 2171 45 1501 59 385 40 404 2359 61 1500 59 2359 620 2067 59 2359 637 41 2360 40 2188 614 607 44 2068 91 2359 93 41 59 325 59 328 607 58 621 464 40 2349 40 45 1501 41 41 123 328 1502 58 621 2064 46 2361 40 2041 46 2362 40 2363 46 2364 44 648 44 2045 43 1501 44 2046 43 1501 41 41 59 325 59 349 58 2365 40 41 59 450 59 125 325 59 328 607 58 328 607 58 392 40 2067 615 2068 46 2171 41 2067 61 2068 46 2171 45 1501 59 385 40 404 2359 61 1500 59 2359 620 2067 59 2359 637 41 123 404 2366 61 2068 91 2359 93 59 404 2104 61 2106 40 2366 41 59 392 40 2104 614 45 1501 41 123 2066 46 2367 40 2100 44 648 43 2366 41 59 125 360 123 392 40 2188 614 607 41 123 2080 635 2104 59 125 360 123 2360 40 40 2080 38 2104 41 631 1500 44 2366 41 59 125 125 125 325 59 328 607 58 2368 40 2020 41 59 450 59 349 58 2369 40 2188 41 59 125 125 439 492 2370 40 324 2371 44 404 2372 41 123 404 2104 61 2106 40 2372 41 59 392 40 2104 631 45 1501 41 123 2103 40 2104 44 2371 41 59 125 464 40 2372 41 123 328 1501 58 621 325 59 328 1502 58 621 621 621 621 621 2085 61 2083 61 1500 59 2084 61 2047 59 2086 61 2048 59 621 2103 40 2039 44 380 41 59 621 2373 40 1500 44 1500 44 2048 44 2047 41 59 2374 40 1500 44 1500 41 59 325 59 328 1502 58 621 325 59 328 1502 58 621 325 59 328 1502 58 621 392 40 2371 41 2375 40 1500 44 1500 41 59 325 59 328 1502 58 621 328 1502 58 621 328 1502 58 621 328 1503 58 621 328 1503 58 621 392 40 2066 631 424 41 2066 46 2376 40 2371 41 59 325 59 328 1503 58 621 328 1503 58 621 328 1503 58 621 325 59 328 1503 58 621 392 40 33 2371 41 123 2085 61 1500 59 2086 61 2048 59 125 325 59 328 1504 58 328 1505 58 328 1505 58 328 1505 58 328 1505 58 328 1505 58 621 328 1505 58 621 328 1505 58 328 1505 58 621 325 59 328 1505 58 621 392 40 2371 41 2377 40 41 59 360 2378 40 41 59 325 59 328 1503 58 328 1505 58 328 1505 58 123 621 621 2059 2379 61 2371 63 2061 58 2060 59 392 40 2379 631 2062 41 123 324 2380 61 33 40 2379 46 2048 614 2048 605 2379 46 2381 614 2047 41 59 392 40 2371 41 2377 40 41 59 2062 61 2379 59 392 40 33 2371 41 123 404 2382 61 2074 46 2383 59 404 2124 61 2074 46 2384 59 2378 40 41 59 392 40 2380 41 123 621 2046 61 2382 59 2045 61 2124 59 125 125 621 392 40 2380 41 2143 40 41 59 621 392 40 2379 614 2061 41 2379 46 2385 40 1500 44 1500 44 2048 44 2047 44 607 44 2386 40 41 41 59 125 325 59 125 328 1505 58 621 325 59 349 58 2387 40 2372 41 59 325 59 125 125 437 492 2388 40 404 2188 41 123 464 40 2188 41 123 328 607 58 621 621 621 621 621 621 621 621 621 621 621 2064 46 2389 40 648 41 59 325 59 328 607 58 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 621 2066 46 2390 40 2100 44 648 43 2391 40 45 1501 41 43 648 43 2392 40 45 1501 41 41 59 325 59 349 58 2393 40 2188 41 59 325 59 125 125 437 492 2394 40 41 123 2072 61 2008 59 2067 61 1500 59 2395 46 2396 40 2068 44 45 1501 41 59 125 437 492 2397 40 41 123 324 2398 61 2045 615 2084 59 404 2399 61 2045 43 1501 59 392 40 2398 41 123 621 392 40 2045 631 2047 45 1501 41 123 2400 40 2399 41 59 125 125 360 123 392 40 2399 614 2084 41 123 2401 40 41 59 2399 61 2084 45 1501 59 125 2402 40 2399 41 59 125 125 437 492 2403 40 404 2404 41 123 2072 61 2404 59 2071 61 473 59 125 437 492 2405 40 404 2188 41 123 464 40 2188 41 123 328 607 58 621 2062 46 2406 40 1500 44 1500 44 2048 44 2047 44 607 44 2407 40 41 41 59 325 59 349 58 2408 40 2188 41 59 325 59 125 125 618 437 492 2409 40 404 2188 41 123 464 40 2188 41 123 328 607 58 2403 40 2009 41 59 325 59 328 607 58 2403 40 2010 41 59 325 59 328 607 58 2403 40 2011 41 59 325 59 328 607 58 621 392 40 2046 62 2085 41 123 2046 629 59 125 360 123 404 2110 61 2084 45 2083 59 2062 46 2410 40 2085 44 2083 44 2086 45 2085 45 1501 44 2110 44 2085 43 1501 44 2083 41 59 2062 46 2411 40 2085 44 2083 44 1501 44 2110 44 607 44 2412 46 2413 40 2090 44 2091 44 1500 41 41 59 125 325 59 328 607 58 621 2414 40 41 59 325 59 328 607 58 621 2415 40 41 59 325 59 328 607 58 621 392 40 2046 60 2086 45 1501 41 123 2046 637 59 125 360 123 404 2110 61 2084 45 2083 59 2062 46 2416 40 2085 43 1501 44 2083 44 2086 45 2085 45 1501 44 2110 44 2085 44 2083 41 59 2062 46 2417 40 2086 45 1501 44 2083 44 1501 44 2110 44 607 44 2418 46 2419 40 2090 44 2091 44 1500 41 41 59 125 325 59 328 607 58 621 2420 40 41 59 2060 46 2421 40 41 59 2422 40 1500 44 1500 44 2048 44 2047 41 59 2423 40 1500 44 1500 41 59 325 59 328 607 58 621 2397 40 41 59 325 59 328 607 58 621 2424 40 2101 40 2030 41 63 2085 58 1500 41 59 2397 40 41 59 325 59 328 607 58 621 2425 40 1500 44 2084 45 1501 41 59 325 59 328 607 58 621 2082 91 2046 93 61 473 59 325 59 328 607 58 621 621 621 392 40 2045 620 2083 41 123 2062 46 2426 40 1500 44 2083 44 2048 44 2084 45 40 2083 43 1501 41 44 1500 44 2083 43 1501 41 59 2422 40 1500 44 2083 44 2048 41 59 125 360 123 2045 629 59 125 325 59 328 607 58 621 328 607 58 621 325 59 328 607 58 621 2070 46 2427 40 1500 41 59 2403 40 2019 41 59 325 59 328 607 58 2403 40 2012 41 59 325 59 328 607 58 621 2103 40 2033 44 473 41 59 325 59 328 607 58 621 2070 46 2427 40 1500 41 59 2403 40 2016 41 59 325 59 328 607 58 621 2103 40 2033 44 380 41 59 325 59 349 58 2428 40 2188 41 59 325 59 125 125 618 437 492 2429 40 41 123 2073 2404 61 40 2062 614 2060 41 63 2074 58 2075 59 2404 46 2430 61 2045 59 2404 46 2431 61 2046 59 2404 46 2432 61 2092 59 2404 46 2433 61 2090 59 2404 46 2434 61 2091 59 2404 46 2435 61 2079 59 2404 46 2076 61 2076 59 2404 46 2077 61 2077 59 2404 46 2078 61 2078 59 125 618 437 492 2436 40 41 123 2073 2404 61 40 2062 614 2060 41 63 2074 58 2075 59 2437 40 2404 46 2438 44 2404 46 2439 41 59 2092 61 2404 46 2440 59 2090 61 2404 46 2441 59 2091 61 2404 46 2442 59 404 2443 61 40 2031 124 2030 41 59 2079 61 40 2079 38 126 2443 41 124 40 2404 46 2444 38 2443 41 59 2076 61 2404 46 2076 59 2077 61 2404 46 2077 59 2078 61 2404 46 2078 59 125 618 437 492 2445 40 404 2188 41 123 464 40 2188 41 123 328 607 58 2403 40 2025 41 59 325 59 328 607 58 2403 40 2023 41 59 325 59 328 607 58 2403 40 2024 41 59 325 59 328 607 58 2403 40 2014 41 59 325 59 328 607 58 2403 40 2022 41 59 325 59 328 607 58 123 621 2087 61 380 59 404 2446 61 2048 45 2046 59 404 2447 61 2448 46 2449 40 2450 40 1501 41 44 2446 41 59 404 2451 61 2446 45 2447 59 2062 46 2452 40 2046 44 2045 44 2451 44 1501 44 2046 43 2447 44 2045 41 59 2453 40 2046 44 2045 44 2447 41 59 125 325 59 328 607 58 621 2454 40 2455 46 2456 40 1500 44 2045 45 2457 40 1501 41 41 41 59 325 59 328 607 58 621 2454 40 2455 46 2458 40 2047 45 1501 44 2045 43 2457 40 1501 41 41 41 59 325 59 328 607 58 621 328 607 58 621 2459 40 2455 46 2458 40 2086 45 1501 44 2046 43 2457 40 1501 41 41 41 59 325 59 328 607 58 621 2459 40 2455 46 2456 40 2085 44 2046 45 2457 40 1501 41 41 41 59 325 59 328 607 58 621 2460 40 1500 44 2045 43 2457 40 1501 41 41 59 325 59 328 607 58 621 2460 40 1500 44 2045 45 2457 40 1501 41 41 59 325 59 328 607 58 621 2459 40 2455 46 2458 40 2455 46 2456 40 1501 44 2457 40 1501 41 41 44 2048 41 45 1501 41 59 325 59 328 607 58 621 328 607 58 621 2460 40 2461 40 1501 41 45 1501 44 2457 40 1501 41 45 1501 41 59 325 59 328 607 58 621 2459 40 2337 40 2457 40 1501 41 41 41 59 325 59 328 607 58 621 621 464 40 2457 40 1500 41 41 123 328 1500 58 621 2462 40 2046 44 2045 44 2048 45 2046 41 59 2462 40 1500 44 2045 43 1501 44 2048 44 2047 45 40 2045 43 1501 41 41 59 325 59 328 1501 58 621 2462 40 1500 44 1500 44 2048 44 2045 41 59 2462 40 1500 44 2045 44 2046 43 1501 41 59 325 59 328 1502 58 621 621 2462 40 1500 44 1500 44 2048 44 2047 41 59 325 59 328 1502 58 621 2060 46 2463 40 41 59 325 59 349 58 2464 40 2188 41 59 450 59 125 2087 61 380 59 325 59 328 607 58 621 464 40 2457 40 1500 41 41 123 328 1500 58 621 2465 40 2046 44 2045 44 2048 45 2046 41 59 325 59 328 1501 58 621 2465 40 1500 44 2045 44 2046 43 1501 41 59 325 59 328 1502 58 621 2465 40 1500 44 2045 44 2048 41 59 325 59 349 58 2466 40 2188 41 59 450 59 125 2087 61 380 59 325 59 328 607 58 621 123 404 2467 61 2084 45 2045 59 404 2468 61 2455 46 2458 40 2457 40 1501 41 44 2467 41 59 404 2469 61 2467 45 2468 59 2062 46 2470 40 1500 44 2045 44 2048 44 2469 44 1500 44 2045 43 2468 41 59 2471 40 1500 44 2045 44 2048 44 2468 41 59 125 325 59 328 607 58 621 123 2087 61 380 59 404 2472 61 2084 45 2045 59 404 2473 61 2455 46 2458 40 2457 40 1501 41 44 2472 41 59 404 2474 61 2472 45 2473 59 2062 46 2475 40 1500 44 2045 43 2473 44 2048 44 2474 44 1500 44 2045 41 59 2476 40 1500 44 2045 43 2474 44 2048 44 2473 41 59 125 325 59 328 607 58 621 123 621 621 621 621 621 2087 61 380 59 404 2477 61 2048 45 2046 59 404 2478 61 2455 46 2458 40 2457 40 1501 41 44 2477 41 59 404 2479 61 2477 45 2478 59 2062 46 2480 40 2046 43 2478 44 2045 44 2479 44 1501 44 2046 44 2045 41 59 2481 40 2046 43 2479 44 2045 44 2478 41 59 125 325 59 328 607 58 123 621 381 404 2482 61 2457 40 1501 41 59 385 40 404 2483 61 1500 59 2483 60 2482 59 2483 637 41 2484 40 41 59 325 59 125 328 607 58 392 40 2067 614 1500 41 123 621 621 621 621 381 404 2485 61 2457 40 1501 41 59 381 404 2486 61 2084 45 2083 59 381 404 2487 61 2455 46 2458 40 2486 44 2485 41 59 2062 46 2488 40 1500 44 2083 44 2048 44 2486 45 2487 44 1500 44 2083 43 2487 41 59 2489 40 1500 44 2083 44 2048 44 2487 41 59 125 360 123 621 2490 40 2188 41 59 125 325 59 328 607 58 621 2087 61 380 59 2062 46 2491 40 2046 44 2045 44 2455 46 2458 40 2457 40 1501 41 44 2048 45 2046 41 44 1501 44 607 44 2492 40 41 41 59 325 59 328 607 58 621 404 2493 61 2457 40 1501 41 59 404 2494 61 2085 59 385 40 404 2495 61 2046 45 1501 59 2495 615 1500 59 2495 629 41 392 40 2082 91 2495 93 41 123 392 40 629 2493 614 1500 41 123 2494 61 2455 46 2456 40 2495 44 2085 41 59 325 59 125 125 2046 61 2494 59 325 59 328 607 58 621 2403 40 2013 41 59 325 59 328 607 58 621 2403 40 2018 41 59 325 59 328 607 58 621 2496 40 2457 40 1501 41 45 1501 41 59 325 59 328 607 58 621 392 40 2097 614 45 1501 41 325 59 381 404 2497 61 2457 40 1501 41 59 385 40 404 2495 61 1500 59 2495 60 2497 59 2495 637 41 2498 40 2097 41 59 325 59 328 607 58 621 621 621 621 392 40 2457 40 1500 41 614 1500 41 2064 46 2499 40 648 41 59 325 59 328 607 58 621 2454 40 2455 46 2458 40 2455 46 2456 40 1501 44 2457 40 1501 41 41 44 2047 41 45 1501 41 59 325 59 328 607 58 621 2460 40 2046 44 2045 43 2457 40 1501 41 41 59 325 59 621 328 607 58 621 464 40 2457 40 1500 41 41 123 328 1500 58 2082 91 2046 93 61 380 59 325 59 328 1502 58 385 40 404 2495 61 1500 59 2495 60 2048 59 2495 637 41 123 2082 91 2495 93 61 380 59 125 325 59 349 58 621 325 59 125 325 59 328 607 58 621 2500 40 473 41 59 325 59 328 607 58 621 2500 40 380 41 59 325 59 328 607 58 621 2501 40 41 59 325 59 328 607 58 621 621 464 40 2457 40 1500 41 41 123 328 1502 58 621 621 326 91 93 2502 61 123 40 326 41 1503 44 40 326 41 607 44 40 326 41 607 44 40 326 41 607 125 59 2064 46 2499 40 2502 44 1500 44 2502 46 2171 41 59 325 59 328 1502 58 621 621 621 2064 46 2499 40 2041 46 2503 40 2504 46 2505 44 648 44 2045 43 1501 44 2046 43 1501 41 41 59 325 59 349 58 325 59 125 325 59 328 607 58 621 123 621 621 621 621 621 621 621 2083 61 2455 46 2456 40 1500 44 2455 46 2458 40 2457 40 1501 41 45 1501 44 2047 45 1502 41 41 59 2084 61 2455 46 2456 40 2083 43 1502 44 2455 46 2458 40 2461 40 2047 41 44 2047 41 41 59 621 2460 40 1500 44 1500 41 59 125 325 59 328 607 58 392 40 2101 40 2039 41 41 123 621 2085 61 2455 46 2458 40 2457 40 1501 41 45 1501 44 2048 45 1502 41 59 2086 61 2455 46 2456 40 2085 43 1501 44 2455 46 2458 40 2461 40 2048 41 44 2048 41 41 59 621 2460 40 1500 44 1500 41 59 125 360 123 621 2429 40 41 59 125 325 59 328 607 58 621 464 40 2457 40 1500 41 41 123 328 1503 58 621 2064 46 2499 40 648 41 59 325 59 328 1503 58 621 2064 46 2499 40 648 41 59 325 59 328 1503 58 621 621 2064 46 2499 40 2041 46 2506 40 2507 46 2508 44 648 44 2047 42 1503 44 2048 42 1503 41 41 59 325 59 328 1503 58 621 2064 46 2499 40 2041 46 2506 40 2507 46 2508 44 648 44 2047 44 2048 41 41 59 325 59 328 1503 58 621 621 2064 46 2499 40 2041 46 2506 40 2507 46 2508 44 648 44 2047 44 2048 41 41 59 325 59 328 1503 58 621 2064 46 2499 40 648 41 59 325 59 328 1503 58 621 2064 46 2499 40 648 41 59 325 59 328 1503 58 621 621 621 2044 46 2509 40 2042 41 59 392 40 2044 46 2510 40 41 62 1503 41 123 621 2044 46 2511 40 1500 41 59 125 325 59 328 1503 58 621 392 40 33 2044 46 2512 40 41 41 2513 40 2044 46 2514 40 41 41 59 325 59 349 58 621 325 59 125 325 59 328 607 58 621 2436 40 41 59 325 59 328 607 58 2403 40 2021 41 59 325 59 349 58 2515 40 2188 41 59 325 59 125 125 618 437 492 2516 40 41 123 392 40 2067 615 2068 46 2171 41 2067 61 2068 46 2171 45 1501 59 385 40 404 2517 61 1500 59 2517 620 2067 59 2517 637 41 123 404 2518 61 2068 91 2517 93 59 392 40 2518 60 1500 41 123 392 40 2067 62 1500 41 123 344 59 125 360 123 2518 61 1500 59 125 125 392 40 2518 614 1500 41 123 621 2090 61 2519 46 2520 59 2091 61 2519 46 2521 59 2092 61 1500 59 125 360 392 40 2518 614 1501 41 123 2092 635 2522 46 2523 59 125 360 392 40 2518 614 1502 41 123 2092 635 2524 46 2525 59 125 360 392 40 2518 614 1502 41 123 2092 635 2526 46 2527 59 125 360 392 40 2518 614 1502 41 123 2092 635 2528 46 2529 59 125 360 392 40 2518 614 1502 41 123 2092 635 2530 46 2531 59 125 360 392 40 2518 614 1502 41 123 2092 635 2532 46 2533 59 125 360 392 40 2518 614 1502 41 123 2092 635 2534 46 2535 59 125 360 392 40 2518 614 1502 41 123 2092 635 2536 46 2537 59 125 360 392 40 2518 614 1502 41 123 621 125 360 392 40 2518 614 1503 41 123 621 125 360 392 40 2518 614 1503 41 123 621 2092 601 126 40 2538 46 2539 124 2538 46 2540 41 59 125 360 392 40 2518 614 1503 41 123 621 2092 601 126 2541 46 2542 59 125 360 392 40 2518 614 1503 41 123 621 2092 601 126 2543 46 2544 59 125 360 392 40 2518 614 1503 41 123 621 2092 601 126 2545 46 2546 59 125 360 392 40 2518 614 1503 41 123 621 2092 601 126 2547 46 2548 59 125 360 392 40 2518 614 1503 41 123 2092 601 126 2549 46 2550 59 125 360 392 40 2518 614 1503 41 123 2092 601 126 2551 46 2552 59 125 360 392 40 2518 615 1503 605 2518 620 1503 41 123 2090 61 2518 45 1503 59 125 360 392 40 2518 614 1503 606 2518 614 1503 41 123 621 621 621 392 40 2517 43 1502 62 2067 41 344 59 404 2553 61 2068 91 2517 43 1501 93 59 392 40 2553 614 1502 41 123 392 40 2517 43 1502 62 2067 41 123 2066 46 2554 40 2100 44 648 43 2518 43 648 41 59 125 360 123 404 2555 61 2068 91 2517 43 1502 93 44 2556 61 2068 91 2517 43 1502 93 44 2557 61 2068 91 2517 43 1502 93 59 392 40 2555 60 1500 606 2556 60 1500 606 2557 60 1500 606 2555 62 1504 606 2556 62 1504 606 2557 62 1504 41 123 2558 40 648 43 2555 43 648 43 2556 43 648 43 2557 41 59 125 360 123 404 2559 61 1511 124 40 2555 622 1503 41 124 40 2556 622 1502 41 124 2557 59 392 40 2518 614 1503 41 123 2090 61 2559 59 125 360 123 2091 61 2559 59 125 125 2517 636 1502 59 621 125 125 360 392 40 2553 614 1502 41 123 404 2560 61 2068 91 2517 43 1502 93 59 2517 636 1502 59 621 392 40 2560 615 1500 605 2560 60 2561 46 2562 41 123 392 40 2518 614 1503 41 123 2090 61 2560 59 125 360 123 2091 61 2560 59 125 125 360 123 392 40 2001 41 2066 46 2563 40 2100 44 648 43 2560 41 59 125 125 360 123 2564 40 648 43 2553 41 59 125 125 360 392 40 2518 614 1503 41 123 621 2090 61 2565 46 2566 59 125 360 392 40 2518 615 1503 605 2518 620 1503 41 123 621 2091 61 2518 45 1503 59 125 360 392 40 2518 614 1503 41 123 621 2091 61 2567 46 2568 59 125 360 392 40 2518 615 1503 605 2518 620 1503 41 123 621 2090 61 2518 45 1503 43 1502 59 125 360 392 40 2518 615 1503 605 2518 620 1504 41 123 621 2091 61 2518 45 1503 43 1502 59 125 360 123 392 40 2001 41 2066 46 2569 40 2100 44 2041 46 2570 40 648 44 2518 41 41 59 125 125 125 437 492 2571 40 404 2188 41 123 464 40 2188 41 123 328 1502 58 621 2572 40 648 41 59 325 59 328 1503 58 621 2403 40 2017 41 59 325 59 349 58 2573 40 2188 41 59 325 59 125 125 437 492 2574 40 404 2188 41 123 464 40 2188 41 123 328 607 58 2575 40 648 41 59 325 59 349 58 621 621 2576 40 1503 41 59 2576 40 2188 41 59 2403 40 2016 41 59 325 59 125 125 618 437 492 2577 40 2041 2578 41 123 404 2579 61 45 1501 59 2041 2580 61 648 59 621 385 40 404 2581 61 1500 59 2581 60 2070 46 2171 40 41 59 2581 637 41 123 330 2188 61 2070 46 2582 40 2581 41 59 392 40 2188 614 607 41 123 2580 61 2070 46 2583 40 2581 43 1501 41 59 325 59 125 360 392 40 2188 615 607 605 2188 620 607 41 123 2579 61 40 40 2579 60 1500 41 63 1500 58 2579 42 1502 41 43 40 2188 45 607 41 59 125 360 123 2584 40 2188 41 59 450 59 125 125 464 40 2579 41 123 328 1500 58 621 328 1501 58 621 328 1502 58 621 2585 40 2580 41 59 325 59 328 1502 58 621 621 621 621 621 621 621 404 2586 61 45 1501 59 404 2587 61 45 1501 59 385 40 404 2588 61 1500 59 59 2588 637 41 123 324 2589 61 2588 614 2580 46 2171 40 41 59 330 2188 61 2589 63 607 58 2580 46 2590 40 2588 41 59 392 40 2188 614 607 41 123 392 40 2587 60 1500 41 123 2587 61 2588 43 1501 59 125 360 123 392 40 2586 60 1500 606 2586 62 1504 41 123 2591 40 2188 41 59 450 59 125 360 123 2099 46 2592 40 2586 44 2580 46 2593 40 2587 44 2588 41 41 59 2064 46 2594 40 41 59 2586 61 45 1501 59 2587 61 45 1501 59 125 125 125 360 392 40 2587 615 1500 41 123 621 125 360 392 40 2587 60 1500 605 40 2188 615 607 605 2188 620 607 41 41 123 2586 61 40 40 2586 60 1500 41 63 1500 58 2586 42 1502 41 43 40 2188 45 607 41 59 125 360 123 2595 40 2188 41 59 450 59 125 392 40 2589 41 325 59 125 325 59 328 1502 58 621 328 1503 58 621 328 1503 58 621 404 2596 61 2597 46 2598 43 40 2579 45 1502 41 59 404 2599 61 1500 59 385 40 404 2600 61 1500 59 59 2600 637 41 123 324 2601 61 2600 614 2580 46 2171 40 41 59 392 40 2601 606 2580 46 2602 40 2600 41 614 607 41 123 474 123 2041 2603 61 2580 46 2604 40 2599 44 2600 41 59 392 40 648 46 2605 40 2603 41 41 123 621 404 2606 61 2099 46 2607 91 2596 93 59 404 2608 61 40 1506 42 40 40 2606 38 1509 41 641 1503 41 41 47 1504 59 404 2609 61 40 1506 42 40 40 2606 38 1506 41 641 1502 41 41 47 1504 59 404 2188 61 40 1506 42 40 40 2606 38 1504 41 41 41 47 1504 59 2064 46 2610 40 648 43 2579 43 648 43 2041 46 2611 40 2612 46 2613 44 648 44 2608 41 43 648 43 2041 46 2611 40 2612 46 2613 44 648 44 2609 41 43 648 43 2041 46 2611 40 2612 46 2613 44 648 44 2188 41 43 2578 41 59 125 360 123 2099 46 2614 40 2596 44 2603 41 59 2064 46 2615 40 41 59 125 2596 637 59 392 40 2601 606 40 2596 62 2597 46 2616 41 606 637 2600 615 2580 46 2171 40 41 41 325 59 2599 61 2600 59 125 329 40 2617 2618 41 123 621 125 125 125 325 59 328 1503 58 621 404 2619 61 2580 46 2620 40 648 41 43 1501 59 474 123 2041 2621 61 418 2041 40 2622 46 2623 40 2580 46 2624 40 2619 41 44 1500 41 44 2625 46 2626 41 59 2064 46 2627 40 2621 41 59 125 329 40 2628 2629 41 123 2066 46 2630 40 2100 44 648 43 2580 43 648 41 59 125 325 59 328 1504 58 621 621 621 621 392 40 2580 46 2631 40 41 41 123 2099 46 2632 40 41 59 2064 46 2633 40 41 59 125 360 123 404 2634 61 1500 59 385 40 404 2600 61 1500 59 59 2600 637 41 123 324 2635 61 2600 614 2580 46 2171 40 41 59 392 40 2635 606 2580 46 2636 40 2600 41 614 607 41 123 474 123 404 2637 61 2056 46 2638 40 2580 46 2639 40 2634 44 2600 41 41 59 2099 46 2640 40 2637 41 59 2064 46 2641 40 41 59 392 40 2635 41 325 59 2600 637 59 2634 61 2600 59 125 329 40 2642 2629 41 123 621 125 125 125 125 325 59 328 1504 58 621 328 1504 58 621 328 1504 58 621 2099 46 2643 40 2597 46 2598 43 40 2579 45 1504 41 41 59 2064 46 2644 40 41 59 325 59 328 1504 58 621 325 59 349 58 2645 40 2579 41 59 325 59 125 2646 40 41 59 125 437 492 2647 40 404 2648 44 404 2649 44 404 2650 41 123 2647 40 2648 44 2649 44 2650 44 1501 41 59 125 437 492 2647 40 404 2648 44 404 2649 44 404 2650 44 404 2651 41 123 2062 46 2652 40 2648 44 2649 44 2650 44 2651 44 607 44 2653 40 41 41 59 125 437 413 2654 40 41 123 450 2655 46 2656 40 2090 44 2091 44 2092 41 59 125 618 437 492 2657 40 324 2658 41 123 404 2659 61 2660 40 1500 41 59 464 40 2659 41 123 328 1502 58 621 2081 61 2658 59 325 59 328 1503 58 621 2661 40 2659 41 59 621 325 59 328 1503 58 621 621 325 59 349 58 2661 40 2659 41 59 325 59 125 125 618 437 492 2662 40 404 2663 44 404 2664 41 123 324 2665 61 2101 40 2030 41 59 404 2666 61 2665 63 2083 58 1500 59 404 2667 61 2665 63 2084 58 2047 59 404 2668 61 2665 63 2085 58 1500 59 404 2669 61 2665 63 2086 58 2048 59 404 2670 61 2671 46 2672 40 2666 44 2671 46 2673 40 2666 43 2664 44 2667 45 1501 41 41 59 404 2674 61 2671 46 2672 40 2668 44 2671 46 2673 40 2668 43 2663 44 2669 45 1501 41 41 59 2675 40 2670 44 2674 41 59 125 437 492 2676 40 41 123 2093 637 59 392 40 2085 631 1500 606 2086 631 2048 41 123 621 2062 46 2677 40 2085 44 2083 43 1501 44 2086 45 2085 44 2084 45 2083 45 1501 44 2085 44 2083 41 59 621 2062 46 2678 40 2085 44 2084 45 1501 44 2086 45 2085 44 1501 44 607 44 2092 41 59 125 360 123 2062 46 2676 40 2083 44 2084 44 2654 40 41 41 59 125 125 618 437 492 2679 40 404 2188 41 123 392 40 2188 615 607 605 2188 620 607 41 123 392 40 2067 60 2068 46 2171 41 123 404 2680 61 2068 91 2067 93 59 404 2681 61 2188 45 607 59 404 2682 59 392 40 2680 615 1500 41 123 2682 61 2680 42 1502 43 2681 59 125 360 123 2682 61 2681 59 125 2068 91 2067 93 61 2682 59 125 2403 40 2072 41 59 125 360 392 40 2188 614 607 41 123 392 40 2067 60 2068 46 2171 41 123 2067 637 59 125 2403 40 2072 41 59 125 360 123 2683 40 2188 41 59 125 125 437 404 2684 40 404 2685 41 123 450 2686 40 1500 44 2685 44 473 41 59 125 437 404 2687 40 404 2685 41 123 450 2688 40 1501 44 2685 44 473 41 59 125 437 404 2689 40 404 2690 44 404 2685 44 324 2691 41 123 404 2692 61 2068 91 2690 93 59 392 40 2692 60 1500 606 40 2692 614 1500 605 2691 41 41 123 2692 61 2685 59 125 450 2692 59 125 437 492 2693 40 404 2188 41 123 392 40 2070 46 2171 40 41 60 2027 41 123 2070 46 2694 40 2188 41 59 2403 40 2072 41 59 125 360 123 2695 40 2188 41 59 125 125 437 492 2696 40 404 2188 41 123 2697 40 648 43 40 330 41 2188 43 648 43 2041 46 2698 40 648 44 2188 41 43 648 41 59 2699 40 41 59 125 437 492 2700 40 404 2188 41 123 2701 40 648 43 40 330 41 2188 43 648 43 2188 43 648 41 59 2702 40 41 59 125 437 492 2703 40 404 2704 41 123 2705 40 648 43 2704 41 59 2706 40 41 59 125 437 492 2707 40 2041 2708 41 123 392 40 2001 41 123 2069 2709 61 418 2069 40 41 59 2709 46 2169 40 2708 41 59 2709 46 2169 40 648 41 59 2709 46 2169 40 2072 41 59 324 2710 61 473 59 392 40 2067 615 2068 46 2171 41 2067 61 2068 46 2171 45 1501 59 385 40 404 2711 61 1500 59 2711 620 2067 59 2711 637 41 123 404 2712 61 2068 91 2711 93 59 392 40 2712 615 1500 41 123 392 40 2710 41 123 2710 61 380 59 2709 46 2169 40 648 41 59 125 360 123 2709 46 2169 40 607 41 59 125 2709 46 2169 40 2712 41 59 125 125 392 40 33 2710 41 2709 46 2169 40 607 41 59 2713 40 2709 46 2714 40 41 41 59 125 125 437 492 2715 40 2041 371 41 123 392 40 2001 41 2066 46 2716 40 2100 44 371 41 59 2717 40 41 59 125 437 492 2718 40 41 123 2072 61 2007 59 125 618 437 492 2719 40 404 2720 41 123 2097 61 2720 59 392 40 2078 63 2076 58 2077 41 123 621 464 40 2720 41 123 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 328 607 58 2720 61 607 59 621 325 59 125 125 381 324 2721 61 2101 40 2031 41 59 381 404 2722 61 2723 46 2724 40 2720 41 59 381 324 2725 61 2046 614 2086 45 1501 59 392 40 2721 41 123 392 40 2725 605 40 40 2087 605 2722 614 1501 41 606 2722 614 1502 41 41 123 2062 46 2726 40 2045 41 59 2046 61 2085 59 392 40 2045 43 1501 60 2084 41 123 2045 637 59 125 360 123 2676 40 41 59 125 125 125 360 392 40 2725 605 2722 614 1502 41 123 621 621 450 59 125 392 40 2081 605 2722 62 1500 41 123 621 404 2727 61 2046 43 2722 59 392 40 2727 60 2086 41 2062 46 2728 40 2046 44 2045 44 2086 45 2727 44 1501 44 2727 44 2045 41 59 125 404 2729 61 40 40 2722 620 1500 605 2046 62 1500 605 33 2087 41 63 1501 58 1500 41 59 2062 46 2730 40 2046 45 2729 44 2045 44 2720 44 2654 40 41 41 59 392 40 2721 605 2722 62 1500 41 2087 61 40 2046 614 2086 45 2722 41 59 2046 61 2731 46 2732 40 2046 43 2722 44 2086 45 1501 41 59 125 437 492 2733 40 404 2124 41 123 2045 61 2124 59 2087 61 380 59 125 437 492 2734 40 404 2735 41 123 2046 61 2735 59 2087 61 380 59 125 618 437 492 2736 40 404 2735 41 123 2662 40 2735 44 2045 41 59 125 618 437 492 2737 40 404 2124 44 404 2735 41 123 2045 61 2738 46 2739 40 1500 44 2738 46 2740 40 2124 44 2047 45 1501 41 41 59 2046 61 2738 46 2739 40 1500 44 2738 46 2740 40 2735 44 2048 45 1501 41 41 59 2087 61 380 59 125 439 404 2741 40 41 123 450 2093 59 125 439 492 2742 40 41 123 2093 61 1500 59 125 618 439 492 2743 40 41 123 2151 40 41 59 2067 61 1500 59 2071 61 380 59 2072 61 2007 59 2081 61 380 59 2083 61 2085 61 1500 59 2084 61 2047 59 2086 61 2048 59 2087 61 380 59 2090 61 2074 46 2744 61 2075 46 2744 61 2745 46 2746 59 2091 61 2074 46 2747 61 2075 46 2747 61 2745 46 2748 59 2167 40 41 59 2076 61 2077 61 380 59 2078 61 473 59 2074 46 2749 61 2074 46 2750 61 2074 46 2751 61 2074 46 2752 61 1500 59 2075 46 2749 61 2075 46 2750 61 2075 46 2751 61 2075 46 2752 61 1500 59 2079 61 1500 59 621 2103 40 2031 44 473 41 59 2103 40 2032 44 473 41 59 2080 61 2074 46 2752 61 2075 46 2752 61 2079 59 621 2095 61 2094 61 1500 59 2099 46 2743 40 41 59 2064 46 2753 40 41 59 125 439 2041 2754 40 404 2755 44 404 2756 44 404 2757 44 404 2758 41 123 450 2062 46 2754 40 2755 44 2756 44 2757 44 2758 41 59 125 618 439 2041 2759 40 41 123 450 2042 59 125 618 437 492 2760 40 2041 2761 41 123 2041 2762 61 2042 59 2042 61 2761 59 392 40 33 2763 46 2764 40 2762 44 2761 41 41 123 2064 46 2765 40 2762 44 2761 41 59 125 125 618 439 492 2766 40 2041 2767 41 123 621 2767 61 2767 46 2768 40 648 44 648 41 59 621 2767 61 2767 46 2768 40 648 44 648 41 59 621 324 2769 61 2101 40 2038 41 59 392 40 2769 41 2064 46 2770 40 648 41 59 2064 46 2770 40 2767 41 59 392 40 2769 41 2064 46 2770 40 648 41 59 125 618 457 381 334 2073 123 618 404 2771 44 2772 59 404 2773 44 2774 44 2775 59 404 2776 59 324 2076 44 2077 44 2078 61 473 59 125 64 2777 439 2041 2778 40 41 123 450 648 43 2062 46 2048 43 648 43 2062 46 2779 43 648 43 2083 43 648 43 2086 43 648 43 2084 43 648 43 2085 43 648 59 125 125 
26325,Java,"public final class InstanceManager extends GameXmlReader {

    private static final Logger LOGGER = LoggerFactory.getLogger(InstanceManager.class);
    private static final InstanceTemplate DEFAULT_TEMPLATE = new InstanceTemplate();

    private final IntMap<InstanceTemplate> instanceTemplates = new HashIntMap<>();
    private final IntMap<Instance> instanceWorlds = new CHashIntMap<>();
    private final IntMap<IntLongMap> playerInstanceTimes = new CHashIntMap<>();

    private InstanceManager() {
    }

    @Override
    protected Path getSchemaFilePath() {
         return ServerSettings.dataPackDirectory().resolve(""data/instances/instance.xsd"");
    }

    @Override
    public void load() {
        instanceTemplates.clear();
        parseDatapackDirectory(""data/instances"", true);
        LOGGER.info(""Loaded {} instance templates."", instanceTemplates.size());

        playerInstanceTimes.clear();
        restoreInstanceTimes();
        LOGGER.info(""Loaded instance reenter times for {} players."", playerInstanceTimes.size());
        releaseResources();
    }

    @Override
    public void parseDocument(Document doc, File f) {
        for(var node = doc.getFirstChild(); nonNull(node); node = node.getNextSibling()) {
            if (""instance"".equals(node.getNodeName())) {
                parseInstanceTemplate(node, f);
            }
        }
    }

    /**
     * Parse instance template from XML file.
     *
     * @param instanceNode start XML tag
     * @param file         currently parsed file
     */
    private void parseInstanceTemplate(Node instanceNode, File file) {
        var attrs = instanceNode.getAttributes();
        final int id = parseInt(attrs, ""id"");
        if (instanceTemplates.containsKey(id)) {
            LOGGER.warn(""Instance template with ID {} already exists"", id);
            return;
        }
        final InstanceTemplate template = new InstanceTemplate(id, parseString(attrs, ""name""), parseInt(attrs, ""maxWorlds"", -1));

        for(var innerNode = instanceNode.getFirstChild(); nonNull(innerNode); innerNode = innerNode.getNextSibling()) {
            switch (innerNode.getNodeName()) {
                case ""time"" -> parseTimes(template, innerNode);
                case ""misc"" -> parseMisc(template, innerNode);
                case ""rates"" -> parseRates(template, innerNode);
                case ""locations"" -> parseLocations(template, innerNode);
                case ""spawnlist"" -> parseSpawns(file, template, innerNode);
                case ""doorlist"" -> parseDoors(template, innerNode);
                case ""removeBuffs"" -> parseRemoveBuffs(template, innerNode);
                case ""reenter"" -> parseReenter(template, innerNode);
                case ""conditions"" -> parseConditions(id, template, innerNode);
            }
        }
        instanceTemplates.put(id, template);
    }

    private void parseConditions(int id, InstanceTemplate template, Node innerNode) {
        org.w3c.dom.NamedNodeMap attrs;
        final List<Condition> conditions = new ArrayList<>();
        for (Node conditionNode = innerNode.getFirstChild(); conditionNode != null; conditionNode = conditionNode.getNextSibling()) {

            if (conditionNode.getNodeName().equals(""condition"")) {
                attrs = conditionNode.getAttributes();
                final String type = parseString(attrs, ""type"");
                final boolean onlyLeader = parseBoolean(attrs, ""onlyLeader"", false);
                final boolean showMessageAndHtml = parseBoolean(attrs, ""showMessageAndHtml"", false);

                StatsSet params = null;
                for (Node f = conditionNode.getFirstChild(); f != null; f = f.getNextSibling()) {
                    if (f.getNodeName().equals(""param"")) {
                        if (params == null) {
                            params = new StatsSet();
                        }

                        params.set(parseString(f.getAttributes(), ""name""), parseString(f.getAttributes(), ""value""));
                    }
                }

                // If none parameters found then set empty StatSet
                if (params == null) {
                    params = StatsSet.EMPTY_STATSET;
                }

                // Now when everything is loaded register condition to template
                try {
                    final Class<?> clazz = Class.forName(""org.l2j.gameserver.model.instancezone.conditions.Condition"" + type);
                    final Constructor<?> constructor = clazz.getConstructor(InstanceTemplate.class, StatsSet.class, boolean.class, boolean.class);
                    conditions.add((Condition) constructor.newInstance(template, params, onlyLeader, showMessageAndHtml));
                } catch (Exception ex) {
                    LOGGER.warn(""Unknown condition type "" + type + "" for instance "" + template.getName() + "" ("" + id + "")!"");
                }
            }
        }
        template.setConditions(conditions);
    }

    private void parseReenter(InstanceTemplate template, Node innerNode) {
        org.w3c.dom.NamedNodeMap attrs;
        final InstanceReenterType type = parseEnum(innerNode.getAttributes(), InstanceReenterType.class, ""apply"", InstanceReenterType.NONE);
        final List<InstanceReenterTimeHolder> data = new ArrayList<>();
        for (Node e = innerNode.getFirstChild(); e != null; e = e.getNextSibling()) {
            if (e.getNodeName().equals(""reset"")) {
                attrs = e.getAttributes();
                final int time = parseInt(attrs, ""time"", -1);
                if (time > 0) {
                    data.add(new InstanceReenterTimeHolder(time));
                } else {
                    final DayOfWeek day = parseEnum(attrs, DayOfWeek.class, ""day"");
                    final int hour = parseInt(attrs, ""hour"", -1);
                    final int minute = parseInt(attrs, ""minute"", -1);
                    data.add(new InstanceReenterTimeHolder(day, hour, minute));
                }
            }
        }
        template.setReenterData(type, data);
    }

    private void parseRemoveBuffs(InstanceTemplate template, Node innerNode) {
        final InstanceRemoveBuffType removeBuffType = parseEnum(innerNode.getAttributes(), InstanceRemoveBuffType.class, ""type"");
        final IntSet exceptionBuffList = new HashIntSet();
        for (Node e = innerNode.getFirstChild(); e != null; e = e.getNextSibling()) {
            if (e.getNodeName().equals(""skill"")) {
                exceptionBuffList.add(parseInt(e.getAttributes(), ""id""));
            }
        }
        template.setRemoveBuff(removeBuffType, exceptionBuffList);
    }

    private void parseSpawns(File file, InstanceTemplate template, Node innerNode) {
        final List<SpawnTemplate> spawns = new ArrayList<>();
        SpawnsData.getInstance().parseSpawn(innerNode, file, spawns);
        template.addSpawns(spawns);
    }

    private void parseRates(InstanceTemplate template, Node innerNode) {
        org.w3c.dom.NamedNodeMap attrs;
        attrs = innerNode.getAttributes();
        template.setExpRate(parseFloat(attrs, ""exp"", RateSettings.xp()));
        template.setSPRate(parseFloat(attrs, ""sp"", RateSettings.sp()));
        template.setExpPartyRate(parseFloat(attrs, ""partyExp"", RateSettings.partyXp()));
        template.setSPPartyRate(parseFloat(attrs, ""partySp"", RateSettings.partySp()));
    }

    private void parseMisc(InstanceTemplate template, Node innerNode) {
        org.w3c.dom.NamedNodeMap attrs;
        attrs = innerNode.getAttributes();
        template.allowPlayerSummon(parseBoolean(attrs, ""allowPlayerSummon""));
        template.setIsPvP(parseBoolean(attrs, ""isPvP""));
    }

    private void parseTimes(InstanceTemplate template, Node innerNode) {
        org.w3c.dom.NamedNodeMap attrs;
        attrs = innerNode.getAttributes();
        template.setDuration(parseInt(attrs, ""duration"", -1));
        template.setEmptyDestroyTime(parseInt(attrs, ""empty"", -1));
        template.setEjectTime(parseInt(attrs, ""eject"", -1));
    }

    private void parseDoors(InstanceTemplate template, Node innerNode) {
        for (Node doorNode = innerNode.getFirstChild(); doorNode != null; doorNode = doorNode.getNextSibling()) {
            if (doorNode.getNodeName().equals(""door"")) {
                final StatsSet parsedSet = DoorDataManager.getInstance().parseDoor(doorNode);
                final StatsSet mergedSet = new StatsSet();
                final int doorId = parsedSet.getInt(""id"");
                final StatsSet templateSet = DoorDataManager.getInstance().getDoorTemplate(doorId);
                if (templateSet != null) {
                    mergedSet.merge(templateSet);
                } else {
                    LOGGER.warn(""Cannot find template for door: "" + doorId + "", instance: "" + template.getName() + "" ("" + template.getId() + "")"");
                }
                mergedSet.merge(parsedSet);

                try {
                    template.addDoor(doorId, new DoorTemplate(mergedSet));
                } catch (Exception e) {
                    LOGGER.warn(""Cannot initialize template for door: {}, instance: {}"", doorId, template, e);
                }
            }
        }
    }

    private void parseLocations(InstanceTemplate template, Node innerNode) {
        for(var locationsNode = innerNode.getFirstChild(); nonNull(locationsNode); locationsNode = locationsNode.getNextSibling()) {
            final InstanceTeleportType type = parseEnum(locationsNode.getAttributes(), InstanceTeleportType.class, ""type"");
            switch (locationsNode.getNodeName()) {
                case ""enter"" -> template.setEnterLocation(type, parseLocations(locationsNode));
                case ""exit"" -> {
                    if (type.equals(InstanceTeleportType.ORIGIN)) {
                        template.setExitLocation(type, null);
                    } else {
                        final List<Location> locations = parseLocations(locationsNode);
                        if (locations.isEmpty()) {
                            LOGGER.warn(""Missing exit location data for instance {}!"", template);
                        } else {
                            template.setExitLocation(type, locations);
                        }
                    }
                }
            }
        }
    }

    private List<Location> parseLocations(Node locationsNode) {
        final List<Location> locations = new ArrayList<>();
        for(var locationNode = locationsNode.getFirstChild(); nonNull(locationNode); locationNode = locationNode.getNextSibling()) {
            locations.add(parseLocation(locationNode));
        }
        return locations;
    }

    public Instance createInstance(int templateId) {
        return createInstance(templateId, null);
    }

    public Instance createInstance(int templateId, Player player) {
        var template= instanceTemplates.get(templateId);

        if(isNull(template)) {
            LOGGER.warn(""Missing template for instance with id {}!"", templateId);
            template = DEFAULT_TEMPLATE;
        }

        var id= IdFactory.getInstance().getNextId();
        var instance = new Instance(id, template);
        instanceWorlds.put(id, instance);
        instance.init(player);
        return instance;
    }

    /**
     * Get instance world with given ID.
     *
     * @param instanceId ID of instance
     * @return instance itself if found, otherwise {@code null}
     */
    public Instance getInstance(int instanceId) {
        return instanceWorlds.get(instanceId);
    }

    /**
     * Get all active instances.
     *
     * @return Collection of all instances
     */
    public Collection<Instance> getInstances() {
        return instanceWorlds.values();
    }

    /**
     * Get instance world for player.
     *
     * @param player   player who wants to get instance world
     * @param isInside when {@code true} find world where player is currently located, otherwise find world where player can enter
     * @return instance if found, otherwise {@code null}
     */
    public Instance getPlayerInstance(Player player, boolean isInside) {
        return instanceWorlds.values().stream().filter(i -> (isInside) ? i.containsPlayer(player) : i.isAllowed(player)).findFirst().orElse(null);
    }

    /**
     * Unregister instance world.<br>
     * <b><font color=red>To remove instance world properly use {@link Instance#destroy()}.</font></b>
     *
     * @param instanceId ID of instance to unregister
     */
    public void unregister(int instanceId) {
        if (instanceWorlds.containsKey(instanceId)) {
            instanceWorlds.remove(instanceId);
            IdFactory.getInstance().releaseId(instanceId);
        }
    }

    /**
     * Get instance name from file ""InstanceNames.xml""
     *
     * @param templateId template ID of instance
     * @return name of instance if found, otherwise {@code null}
     */
    public String getInstanceName(int templateId) {
        return  instanceTemplates.get(templateId).getName();
    }

    /**
     * Restore instance reenter data for all players.
     */
    private void restoreInstanceTimes() {
        getDAO(InstanceDAO.class).findAllInstancesTime(this::addInstancesTime);
    }

    private void addInstancesTime(ResultSet rs) {
        try {
            var currentTime = System.currentTimeMillis();
            while (rs.next()) {

                final long time = rs.getLong(""time"");
                if (time > currentTime) {
                    final int charId = rs.getInt(""charId"");
                    final int instanceId = rs.getInt(""instanceId"");
                    setReenterPenalty(charId, instanceId, time);
                }
            }
        } catch (Exception e) {
            LOGGER.warn(e.getMessage(), e);
        }
    }

    /**
     * Get all instance re-enter times for specified player.<br>
     * This method also removes the penalties that have already expired.
     *
     * @param player instance of player who wants to get re-enter data
     * @return map in form templateId, penaltyEndTime
     */
    public IntLongMap getAllInstanceTimes(Player player) {
        // When player don't have any instance penalty
        final var instanceTimes = playerInstanceTimes.get(player.getObjectId());
        if ((instanceTimes == null) || instanceTimes.isEmpty()) {
            return Containers.EMPTY_INT_LONG_MAP;
        }

        final IntSet invalidPenalty = new HashIntSet(instanceTimes.size());
        for (var entry : instanceTimes.entrySet()) {
            if (entry.getValue() <= System.currentTimeMillis()) {
                invalidPenalty.add(entry.getKey());
            }
        }

        if (!invalidPenalty.isEmpty()) {
            getDAO(InstanceDAO.class).deleteInstanceTime(player.getObjectId(), invalidPenalty);
        }
        return instanceTimes;
    }

    /**
     * Set re-enter penalty for specified player.<br>
     * <font color=red><b>This method store penalty into memory only. Use {@link Instance#setReenterTime} to set instance penalty properly.</b></font>
     *
     * @param objectId object ID of player
     * @param id       instance template id
     * @param time     penalty time
     */
    public void setReenterPenalty(int objectId, int id, long time) {
        playerInstanceTimes.computeIfAbsent(objectId, k -> new CHashIntLongMap()).put(id, time);
    }

    /**
     * Get re-enter time to instance (by template ID) for player.<br>
     * This method also removes penalty if expired.
     *
     * @param player player who wants to get re-enter time
     * @param id     template ID of instance
     * @return penalty end time if penalty is found, otherwise -1
     */
    public long getInstanceTime(Player player, int id) {
        // Check if exists reenter data for player
        final var playerData = playerInstanceTimes.get(player.getObjectId());
        if ((playerData == null) || !playerData.containsKey(id)) {
            return -1;
        }

        // If reenter time is higher then current, delete it
        final long time = playerData.get(id);
        if (time <= System.currentTimeMillis()) {
            deleteInstanceTime(player, id);
            return -1;
        }
        return time;
    }

    /**
     * Remove re-enter penalty for specified instance from player.
     *
     * @param player player who wants to delete penalty
     * @param id     template id of instance world
     */
    public void deleteInstanceTime(Player player, int id) {
        getDAO(PlayerDAO.class).deleteInstanceTime(player.getObjectId(), id);
        playerInstanceTimes.get(player.getObjectId()).remove(id);
    }

    /**
     * Get instance template by template ID.
     *
     * @param id template id of instance
     * @return instance template if found, otherwise {@code null}
     */
    public InstanceTemplate getInstanceTemplate(int id) {
        return instanceTemplates.get(id);
    }

    public boolean hasInstanceTemplate(int templateId) {
        return instanceTemplates.containsKey(templateId);
    }

    /**
     * Get all instances template.
     *
     * @return Collection of all instance templates
     */
    public Collection<InstanceTemplate> getInstanceTemplates() {
        return instanceTemplates.values();
    }

    /**
     * Get count of created instance worlds with same template ID.
     *
     * @param templateId template id of instance
     * @return count of created instances
     */
    public long getWorldCount(int templateId) {
        return instanceWorlds.values().stream().filter(i -> i.getTemplateId() == templateId).count();
    }

    public List<Instance> getInstances(int templateId) {
        List<Instance> instances = new ArrayList<>();
        for (Instance instance : instanceWorlds.values()) {
            if(instance.getTemplateId() == templateId) {
                instances.add(instance);
            }
        }
        return instances;
    }

    public static void init() {
        getInstance().load();
    }

    public static InstanceManager getInstance() {
        return Singleton.INSTANCE;
    }

    private static class Singleton {
        private static final InstanceManager INSTANCE = new InstanceManager();
    }
}",1,439 381 334 2000 378 2001 123 437 457 381 2002 2003 61 2004 46 2005 40 2000 46 334 41 59 437 457 381 2006 2007 61 418 2006 40 41 59 437 381 2008 60 2006 62 2009 61 418 2010 60 62 40 41 59 437 381 2008 60 2011 62 2012 61 418 2013 60 62 40 41 59 437 381 2008 60 2014 62 2015 61 418 2013 60 62 40 41 59 437 2000 40 41 123 125 64 2016 438 2017 2018 40 41 123 450 2019 46 2020 40 41 46 2021 40 648 41 59 125 64 2016 439 492 2022 40 41 123 2009 46 2023 40 41 59 2024 40 648 44 473 41 59 2003 46 2025 40 648 44 2009 46 2026 40 41 41 59 2015 46 2023 40 41 59 2027 40 41 59 2003 46 2025 40 648 44 2015 46 2026 40 41 41 59 2028 40 41 59 125 64 2016 439 492 2029 40 2030 2031 44 2032 2033 41 123 385 40 490 2034 61 2031 46 2035 40 41 59 2036 40 2034 41 59 2034 61 2034 46 2037 40 41 41 123 392 40 648 46 2038 40 2034 46 2039 40 41 41 41 123 2040 40 2034 44 2033 41 59 125 125 125 618 437 492 2041 40 2042 2043 44 2032 2044 41 123 490 2045 61 2043 46 2046 40 41 59 381 404 2047 61 2048 40 2045 44 648 41 59 392 40 2009 46 2049 40 2047 41 41 123 2003 46 2050 40 648 44 2047 41 59 450 59 125 381 2006 466 61 418 2006 40 2047 44 2051 40 2045 44 648 41 44 2048 40 2045 44 648 44 45 1501 41 41 59 385 40 490 2052 61 2043 46 2053 40 41 59 2054 40 2052 41 59 2052 61 2052 46 2055 40 41 41 123 464 40 2052 46 2056 40 41 41 123 328 648 45 62 2057 40 466 44 2052 41 59 328 648 45 62 2058 40 466 44 2052 41 59 328 648 45 62 2059 40 466 44 2052 41 59 328 648 45 62 2060 40 466 44 2052 41 59 328 648 45 62 2061 40 2044 44 466 44 2052 41 59 328 648 45 62 2062 40 466 44 2052 41 59 328 648 45 62 2063 40 466 44 2052 41 59 328 648 45 62 2064 40 466 44 2052 41 59 328 648 45 62 2065 40 2047 44 466 44 2052 41 59 125 125 2009 46 2066 40 2047 44 466 41 59 125 437 492 2067 40 404 2068 44 2006 466 44 2042 2069 41 123 2070 46 2071 46 2072 46 2073 2074 59 381 2075 60 2076 62 2077 61 418 2078 60 62 40 41 59 385 40 2042 2079 61 2069 46 2080 40 41 59 2079 631 424 59 2079 61 2079 46 2081 40 41 41 123 392 40 2079 46 2082 40 41 46 2083 40 648 41 41 123 2074 61 2079 46 2084 40 41 59 381 2085 2086 61 2087 40 2074 44 648 41 59 381 324 2088 61 2089 40 2074 44 648 44 380 41 59 381 324 2090 61 2089 40 2074 44 648 44 380 41 59 2091 433 61 424 59 385 40 2042 2033 61 2079 46 2080 40 41 59 2033 631 424 59 2033 61 2033 46 2081 40 41 41 123 392 40 2033 46 2082 40 41 46 2083 40 648 41 41 123 392 40 433 614 424 41 123 433 61 418 2091 40 41 59 125 433 46 2092 40 2087 40 2033 46 2084 40 41 44 648 41 44 2087 40 2033 46 2084 40 41 44 648 41 41 59 125 125 621 392 40 433 614 424 41 123 433 61 2091 46 2093 59 125 621 474 123 381 2094 60 63 62 2095 61 2094 46 2096 40 648 43 2086 41 59 381 2097 60 63 62 2098 61 2095 46 2099 40 2006 46 334 44 2091 46 334 44 324 46 334 44 324 46 334 41 59 2077 46 2100 40 40 2076 41 2098 46 2101 40 466 44 433 44 2088 44 2090 41 41 59 125 329 40 2102 2103 41 123 2003 46 2104 40 648 43 2086 43 648 43 466 46 2105 40 41 43 648 43 2068 43 648 41 59 125 125 125 466 46 2106 40 2077 41 59 125 437 492 2107 40 2006 466 44 2042 2069 41 123 2108 46 2109 46 2110 46 2111 2112 59 381 2113 2114 61 2115 40 2069 46 2116 40 41 44 2113 46 334 44 648 44 2113 46 2117 41 59 381 2118 60 2119 62 2120 61 418 2121 60 62 40 41 59 385 40 2042 2122 61 2069 46 2123 40 41 59 2122 631 424 59 2122 61 2122 46 2124 40 41 41 123 392 40 2122 46 2125 40 41 46 2126 40 648 41 41 123 2112 61 2122 46 2116 40 41 59 381 404 2127 61 2128 40 2112 44 648 44 45 1501 41 59 392 40 2127 62 1500 41 123 2120 46 2129 40 418 2119 40 2127 41 41 59 125 360 123 381 2130 2131 61 2115 40 2112 44 2130 46 334 44 648 41 59 381 404 2132 61 2128 40 2112 44 648 44 45 1501 41 59 381 404 2133 61 2128 40 2112 44 648 44 45 1501 41 59 2120 46 2134 40 418 2119 40 2131 44 2132 44 2133 41 41 59 125 125 125 466 46 2135 40 2114 44 2120 41 59 125 437 492 2136 40 2006 466 44 2042 2069 41 123 381 2137 2138 61 2139 40 2069 46 2140 40 41 44 2137 46 334 44 648 41 59 381 2141 2142 61 418 2143 40 41 59 385 40 2042 2144 61 2069 46 2145 40 41 59 2144 631 424 59 2144 61 2144 46 2146 40 41 41 123 392 40 2144 46 2147 40 41 46 2148 40 648 41 41 123 2142 46 2149 40 2150 40 2144 46 2140 40 41 44 648 41 41 59 125 125 466 46 2151 40 2138 44 2142 41 59 125 437 492 2152 40 2032 2044 44 2006 466 44 2042 2069 41 123 381 2153 60 2154 62 2155 61 418 2156 60 62 40 41 59 2157 46 2158 40 41 46 2159 40 2069 44 2044 44 2155 41 59 466 46 2160 40 2155 41 59 125 437 492 2161 40 2006 466 44 2042 2069 41 123 2162 46 2163 46 2164 46 2165 2166 59 2166 61 2069 46 2167 40 41 59 466 46 2168 40 2169 40 2166 44 648 44 2170 46 2171 40 41 41 41 59 466 46 2172 40 2169 40 2166 44 648 44 2170 46 2173 40 41 41 41 59 466 46 2174 40 2169 40 2166 44 648 44 2170 46 2175 40 41 41 41 59 466 46 2176 40 2169 40 2166 44 648 44 2170 46 2177 40 41 41 41 59 125 437 492 2178 40 2006 466 44 2042 2069 41 123 2179 46 2180 46 2181 46 2182 2183 59 2183 61 2069 46 2184 40 41 59 466 46 2185 40 2186 40 2183 44 648 41 41 59 466 46 2187 40 2186 40 2183 44 648 41 41 59 125 437 492 2188 40 2006 466 44 2042 2069 41 123 2189 46 2190 46 2191 46 2192 2193 59 2193 61 2069 46 2194 40 41 59 466 46 2195 40 2196 40 2193 44 648 44 45 1501 41 41 59 466 46 2197 40 2196 40 2193 44 648 44 45 1501 41 41 59 466 46 2198 40 2196 40 2193 44 648 44 45 1501 41 41 59 125 437 492 2199 40 2006 466 44 2042 2069 41 123 385 40 2042 2200 61 2069 46 2201 40 41 59 2200 631 424 59 2200 61 2200 46 2202 40 41 41 123 392 40 2200 46 2203 40 41 46 2204 40 648 41 41 123 381 2205 2206 61 2207 46 2208 40 41 46 2209 40 2200 41 59 381 2205 2210 61 418 2205 40 41 59 381 404 2211 61 2206 46 2212 40 648 41 59 381 2205 2213 61 2207 46 2208 40 41 46 2214 40 2211 41 59 392 40 2213 631 424 41 123 2210 46 2215 40 2213 41 59 125 360 123 2003 46 2216 40 648 43 2211 43 648 43 466 46 2217 40 41 43 648 43 466 46 2218 40 41 43 648 41 59 125 2210 46 2219 40 2206 41 59 474 123 466 46 2220 40 2211 44 418 2221 40 2210 41 41 59 125 329 40 2222 2223 41 123 2003 46 2224 40 648 44 2211 44 466 44 2223 41 59 125 125 125 125 437 492 2225 40 2006 466 44 2042 2069 41 123 385 40 490 2226 61 2069 46 2227 40 41 59 2228 40 2226 41 59 2226 61 2226 46 2229 40 41 41 123 381 2230 2231 61 2232 40 2226 46 2233 40 41 44 2230 46 334 44 648 41 59 464 40 2226 46 2234 40 41 41 123 328 648 45 62 466 46 2235 40 2231 44 2225 40 2226 41 41 59 328 648 45 62 123 392 40 2231 46 2236 40 2230 46 2237 41 41 123 466 46 2238 40 2231 44 424 41 59 125 360 123 381 2239 60 2240 62 2241 61 2225 40 2226 41 59 392 40 2241 46 2242 40 41 41 123 2003 46 2243 40 648 44 466 41 59 125 360 123 466 46 2244 40 2231 44 2241 41 59 125 125 125 125 125 125 437 2245 60 2246 62 2225 40 2042 2247 41 123 381 2245 60 2246 62 2248 61 418 2249 60 62 40 41 59 385 40 490 2250 61 2247 46 2251 40 41 59 2252 40 2250 41 59 2250 61 2250 46 2253 40 41 41 123 2248 46 2254 40 2255 40 2250 41 41 59 125 450 2248 59 125 439 2011 2256 40 404 2257 41 123 450 2256 40 2257 44 424 41 59 125 439 2011 2256 40 404 2257 44 2258 2259 41 123 490 466 61 2009 46 2260 40 2257 41 59 392 40 2261 40 466 41 41 123 2003 46 2262 40 648 44 2257 41 59 466 61 2007 59 125 490 2068 61 2263 46 2264 40 41 46 2265 40 41 59 490 2266 61 418 2011 40 2068 44 466 41 59 2012 46 2267 40 2068 44 2266 41 59 2266 46 2268 40 2259 41 59 450 2266 59 125 618 439 2011 2269 40 404 2270 41 123 450 2012 46 2271 40 2270 41 59 125 618 439 2272 60 2011 62 2273 40 41 123 450 2012 46 2274 40 41 59 125 618 439 2011 2275 40 2258 2259 44 324 2276 41 123 450 2012 46 2277 40 41 46 2278 40 41 46 2279 40 2280 45 62 40 2276 41 63 2280 46 2281 40 2259 41 58 2280 46 2282 40 2259 41 41 46 2283 40 41 46 2284 40 424 41 59 125 618 439 492 2285 40 404 2270 41 123 392 40 2012 46 2286 40 2270 41 41 123 2012 46 2287 40 2270 41 59 2288 46 2269 40 41 46 2289 40 2270 41 59 125 125 618 439 2290 2291 40 404 2257 41 123 450 2009 46 2292 40 2257 41 46 2293 40 41 59 125 618 437 492 2294 40 41 123 2295 40 2296 46 334 41 46 2297 40 467 58 58 2298 41 59 125 437 492 2299 40 2300 2301 41 123 474 123 490 2302 61 2303 46 2304 40 41 59 496 40 2301 46 2305 40 41 41 123 381 413 2306 61 2301 46 2307 40 648 41 59 392 40 2306 62 2302 41 123 381 404 2308 61 2301 46 2309 40 648 41 59 381 404 2270 61 2301 46 2309 40 648 41 59 2310 40 2308 44 2270 44 2306 41 59 125 125 125 329 40 2311 2312 41 123 2003 46 2313 40 2312 46 2314 40 41 44 2312 41 59 125 125 618 439 2014 2315 40 2258 2259 41 123 621 381 490 2316 61 2015 46 2317 40 2259 46 2318 40 41 41 59 392 40 40 2316 614 424 41 606 2316 46 2319 40 41 41 123 450 2320 46 2321 59 125 381 2322 2323 61 418 2324 40 2316 46 2325 40 41 41 59 385 40 490 2326 58 2316 46 2327 40 41 41 123 392 40 2326 46 2328 40 41 620 2329 46 2330 40 41 41 123 2323 46 2331 40 2326 46 2332 40 41 41 59 125 125 392 40 33 2323 46 2319 40 41 41 123 2333 40 2334 46 334 41 46 2335 40 2259 46 2318 40 41 44 2323 41 59 125 450 2316 59 125 618 439 492 2336 40 404 2337 44 404 2068 44 413 2338 41 123 2015 46 2339 40 2337 44 2340 45 62 418 2341 40 41 41 46 2342 40 2068 44 2338 41 59 125 618 439 413 2343 40 2258 2259 44 404 2068 41 123 621 381 490 2344 61 2015 46 2345 40 2259 46 2346 40 41 41 59 392 40 40 2344 614 424 41 606 33 2344 46 2347 40 2068 41 41 123 450 45 1501 59 125 621 381 413 2338 61 2344 46 2345 40 2068 41 59 392 40 2338 620 2348 46 2349 40 41 41 123 2350 40 2259 44 2068 41 59 450 45 1501 59 125 450 2338 59 125 618 439 492 2351 40 2258 2259 44 404 2068 41 123 2352 40 2353 46 334 41 46 2351 40 2259 46 2354 40 41 44 2068 41 59 2015 46 2355 40 2259 46 2354 40 41 41 46 2356 40 2068 41 59 125 618 439 2006 2357 40 404 2068 41 123 450 2009 46 2358 40 2068 41 59 125 439 324 2359 40 404 2257 41 123 450 2009 46 2360 40 2257 41 59 125 618 439 2272 60 2006 62 2361 40 41 123 450 2009 46 2362 40 41 59 125 618 439 413 2363 40 404 2257 41 123 450 2012 46 2364 40 41 46 2365 40 41 46 2366 40 2367 45 62 2367 46 2368 40 41 614 2257 41 46 2369 40 41 59 125 439 2245 60 2011 62 2273 40 404 2257 41 123 2245 60 2011 62 2370 61 418 2371 60 62 40 41 59 385 40 2011 2372 58 2012 46 2373 40 41 41 123 392 40 2372 46 2374 40 41 614 2257 41 123 2370 46 2375 40 2372 41 59 125 125 450 2370 59 125 439 457 492 2376 40 41 123 2269 40 41 46 2022 40 41 59 125 439 457 2000 2269 40 41 123 450 2377 46 2378 59 125 437 457 334 2379 123 437 457 381 2000 2380 61 418 2000 40 41 59 125 125 
2983,Java,"@Slf4j
@Singleton
public class NotificationCenter {

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Static
    ///////////////////////////////////////////////////////////////////////////////////////////

    @SuppressWarnings(""MismatchedQueryAndUpdateOfCollection"")
    private final static List<Notification> notifications = new ArrayList<>();
    private Consumer<String> selectItemByTradeIdConsumer;

    static void add(Notification notification) {
        notifications.add(notification);
    }

    static boolean useAnimations;

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Instance fields
    ///////////////////////////////////////////////////////////////////////////////////////////

    private final TradeManager tradeManager;
    private final MediationManager mediationManager;
    private final RefundManager refundManager;
    private final Navigation navigation;

    private final Map<String, Subscription> disputeStateSubscriptionsMap = new HashMap<>();
    private final Map<String, Subscription> tradePhaseSubscriptionsMap = new HashMap<>();
    @Nullable
    private String selectedTradeId;

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, initialisation
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public NotificationCenter(TradeManager tradeManager,
                              MediationManager mediationManager,
                              RefundManager refundManager,
                              Preferences preferences,
                              Navigation navigation) {
        this.tradeManager = tradeManager;
        this.mediationManager = mediationManager;
        this.refundManager = refundManager;
        this.navigation = navigation;

        EasyBind.subscribe(preferences.getUseAnimationsProperty(), useAnimations -> NotificationCenter.useAnimations = useAnimations);
    }

    public void onAllServicesAndViewsInitialized() {
        tradeManager.getObservableList().addListener((ListChangeListener<Trade>) change -> {
            change.next();
            if (change.wasRemoved()) {
                change.getRemoved().forEach(trade -> {
                    String tradeId = trade.getId();
                    if (disputeStateSubscriptionsMap.containsKey(tradeId)) {
                        disputeStateSubscriptionsMap.get(tradeId).unsubscribe();
                        disputeStateSubscriptionsMap.remove(tradeId);
                    }

                    if (tradePhaseSubscriptionsMap.containsKey(tradeId)) {
                        tradePhaseSubscriptionsMap.get(tradeId).unsubscribe();
                        tradePhaseSubscriptionsMap.remove(tradeId);
                    }
                });
            }
            if (change.wasAdded()) {
                change.getAddedSubList().forEach(trade -> {
                    String tradeId = trade.getId();
                    if (disputeStateSubscriptionsMap.containsKey(tradeId)) {
                        log.debug(""We have already an entry in disputeStateSubscriptionsMap."");
                    } else {
                        Subscription disputeStateSubscription = EasyBind.subscribe(trade.disputeStateProperty(),
                                disputeState -> onDisputeStateChanged(trade, disputeState));
                        disputeStateSubscriptionsMap.put(tradeId, disputeStateSubscription);
                    }

                    if (tradePhaseSubscriptionsMap.containsKey(tradeId)) {
                        log.debug(""We have already an entry in tradePhaseSubscriptionsMap."");
                    } else {
                        Subscription tradePhaseSubscription = EasyBind.subscribe(trade.statePhaseProperty(),
                                phase -> onTradePhaseChanged(trade, phase));
                        tradePhaseSubscriptionsMap.put(tradeId, tradePhaseSubscription);
                    }
                });
            }
        });

        tradeManager.getObservableList().forEach(trade -> {
                    String tradeId = trade.getId();
                    Subscription disputeStateSubscription = EasyBind.subscribe(trade.disputeStateProperty(),
                            disputeState -> onDisputeStateChanged(trade, disputeState));
                    disputeStateSubscriptionsMap.put(tradeId, disputeStateSubscription);

                    Subscription tradePhaseSubscription = EasyBind.subscribe(trade.statePhaseProperty(),
                            phase -> onTradePhaseChanged(trade, phase));
                    tradePhaseSubscriptionsMap.put(tradeId, tradePhaseSubscription);
                }
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Setter/Getter
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Nullable
    public String getSelectedTradeId() {
        return selectedTradeId;
    }

    public void setSelectedTradeId(@Nullable String selectedTradeId) {
        this.selectedTradeId = selectedTradeId;
    }

    public void setSelectItemByTradeIdConsumer(Consumer<String> selectItemByTradeIdConsumer) {
        this.selectItemByTradeIdConsumer = selectItemByTradeIdConsumer;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onTradePhaseChanged(Trade trade, Trade.Phase phase) {
        String message = null;
        if (trade.isPayoutPublished() && !trade.isWithdrawn()) {
            message = Res.get(""notification.trade.completed"");
        } else {
            if (trade instanceof MakerTrade &&
                    phase.ordinal() == Trade.Phase.DEPOSIT_PUBLISHED.ordinal()) {
                final String role = trade instanceof BuyerTrade ? Res.get(""shared.seller"") : Res.get(""shared.buyer"");
                message = Res.get(""notification.trade.accepted"", role);
            }

            if (trade instanceof BuyerTrade && phase.ordinal() == Trade.Phase.DEPOSIT_CONFIRMED.ordinal())
                message = Res.get(""notification.trade.confirmed"");
            else if (trade instanceof SellerTrade && phase.ordinal() == Trade.Phase.FIAT_SENT.ordinal())
                message = Res.get(""notification.trade.paymentStarted"");
        }

        if (message != null) {
            String key = ""NotificationCenter_"" + phase.name() + trade.getId();
            if (DontShowAgainLookup.showAgain(key)) {
                Notification notification = new Notification().tradeHeadLine(trade.getShortId()).message(message);
                if (navigation.getCurrentPath() != null && !navigation.getCurrentPath().contains(PendingTradesView.class)) {
                    notification.actionButtonTextWithGoTo(""navigation.portfolio.pending"")
                            .onAction(() -> {
                                DontShowAgainLookup.dontShowAgain(key, true);
                                navigation.navigateTo(MainView.class, PortfolioView.class, PendingTradesView.class);
                                if (selectItemByTradeIdConsumer != null)
                                    UserThread.runAfter(() -> selectItemByTradeIdConsumer.accept(trade.getId()), 1);
                            })
                            .onClose(() -> DontShowAgainLookup.dontShowAgain(key, true))
                            .show();
                } else if (selectedTradeId != null && !trade.getId().equals(selectedTradeId)) {
                    notification.actionButtonText(Res.get(""notification.trade.selectTrade""))
                            .onAction(() -> {
                                DontShowAgainLookup.dontShowAgain(key, true);
                                if (selectItemByTradeIdConsumer != null)
                                    selectItemByTradeIdConsumer.accept(trade.getId());
                            })
                            .onClose(() -> DontShowAgainLookup.dontShowAgain(key, true))
                            .show();
                }
            }
        }
    }

    private void onDisputeStateChanged(Trade trade, Trade.DisputeState disputeState) {
        String message = null;
        if (refundManager.findOwnDispute(trade.getId()).isPresent()) {
            String disputeOrTicket = refundManager.findOwnDispute(trade.getId()).get().isSupportTicket() ?
                    Res.get(""shared.supportTicket"") :
                    Res.get(""shared.dispute"");
            switch (disputeState) {
                case NO_DISPUTE:
                    break;
                case REFUND_REQUESTED:
                    break;
                case REFUND_REQUEST_STARTED_BY_PEER:
                    message = Res.get(""notification.trade.peerOpenedDispute"", disputeOrTicket);
                    break;
                case REFUND_REQUEST_CLOSED:
                    message = Res.get(""notification.trade.disputeClosed"", disputeOrTicket);
                    break;
                default:
//                    if (DevEnv.isDevMode()) {
//                        log.error(""refundManager must not contain mediation or arbitration disputes. disputeState={}"", disputeState);
//                        throw new RuntimeException(""arbitrationDisputeManager must not contain mediation disputes"");
//                    }
                    break;
            }
            if (message != null) {
                goToSupport(trade, message, false);
            }
        } else if (mediationManager.findOwnDispute(trade.getId()).isPresent()) {
            String disputeOrTicket = mediationManager.findOwnDispute(trade.getId()).get().isSupportTicket() ?
                    Res.get(""shared.supportTicket"") :
                    Res.get(""shared.mediationCase"");
            switch (disputeState) {
                // TODO
                case MEDIATION_REQUESTED:
                    break;
                case MEDIATION_STARTED_BY_PEER:
                    message = Res.get(""notification.trade.peerOpenedDispute"", disputeOrTicket);
                    break;
                case MEDIATION_CLOSED:
                    message = Res.get(""notification.trade.disputeClosed"", disputeOrTicket);
                    break;
                default:
//                    if (DevEnv.isDevMode()) {
//                        log.error(""mediationDisputeManager must not contain arbitration or refund disputes. disputeState={}"", disputeState);
//                        throw new RuntimeException(""mediationDisputeManager must not contain arbitration disputes"");
//                    }
                    break;
            }
            if (message != null) {
                goToSupport(trade, message, true);
            }
        }
    }

    private void goToSupport(Trade trade, String message, boolean isMediation) {
        Notification notification = new Notification().disputeHeadLine(trade.getShortId()).message(message);
        Class<? extends DisputeClientView> viewClass = isMediation ?
                MediationClientView.class :
                RefundClientView.class;
        if (navigation.getCurrentPath() != null && !navigation.getCurrentPath().contains(viewClass)) {
            notification.actionButtonTextWithGoTo(""navigation.support"")
                    .onAction(() -> navigation.navigateTo(MainView.class, SupportView.class, viewClass))
                    .show();
        } else {
            notification.show();
        }
    }

}",1,64 2000 64 2001 439 334 2002 123 621 621 621 64 2003 40 648 41 437 381 457 2004 60 2005 62 2006 61 418 2007 60 62 40 41 59 437 2008 60 2009 62 2010 59 457 492 2011 40 2005 2012 41 123 2006 46 2011 40 2012 41 59 125 457 324 2013 59 621 621 621 437 381 2014 2015 59 437 381 2016 2017 59 437 381 2018 2019 59 437 381 2020 2021 59 437 381 2022 60 2009 44 2023 62 2024 61 418 2025 60 62 40 41 59 437 381 2022 60 2009 44 2023 62 2026 61 418 2025 60 62 40 41 59 64 2027 437 2009 2028 59 621 621 621 64 2029 439 2002 40 2014 2015 44 2016 2017 44 2018 2019 44 2030 2031 44 2020 2021 41 123 467 46 2015 61 2015 59 467 46 2017 61 2017 59 467 46 2019 61 2019 59 467 46 2021 61 2021 59 2032 46 2033 40 2031 46 2034 40 41 44 2013 45 62 2002 46 2013 61 2013 41 59 125 439 492 2035 40 41 123 2015 46 2036 40 41 46 2037 40 40 2038 60 2039 62 41 2040 45 62 123 2040 46 2041 40 41 59 392 40 2040 46 2042 40 41 41 123 2040 46 2043 40 41 46 2044 40 2045 45 62 123 2009 2046 61 2045 46 2047 40 41 59 392 40 2024 46 2048 40 2046 41 41 123 2024 46 2049 40 2046 41 46 2050 40 41 59 2024 46 2051 40 2046 41 59 125 392 40 2026 46 2048 40 2046 41 41 123 2026 46 2052 40 2046 41 46 2053 40 41 59 2026 46 2054 40 2046 41 59 125 125 41 59 125 392 40 2040 46 2055 40 41 41 123 2040 46 2056 40 41 46 2057 40 2058 45 62 123 2009 2059 61 2058 46 2060 40 41 59 392 40 2024 46 2061 40 2059 41 41 123 2062 46 2063 40 648 41 59 125 360 123 2023 2064 61 2065 46 2066 40 2058 46 2067 40 41 44 2068 45 62 2069 40 2058 44 2068 41 41 59 2024 46 2070 40 2059 44 2064 41 59 125 392 40 2026 46 2061 40 2059 41 41 123 2071 46 2072 40 648 41 59 125 360 123 2023 2073 61 2074 46 2075 40 2058 46 2076 40 41 44 2077 45 62 2078 40 2058 44 2077 41 41 59 2026 46 2079 40 2059 44 2073 41 59 125 125 41 59 125 125 41 59 2015 46 2036 40 41 46 2080 40 2081 45 62 123 2009 2082 61 2081 46 2083 40 41 59 2023 2084 61 2085 46 2086 40 2081 46 2087 40 41 44 2088 45 62 2089 40 2081 44 2088 41 41 59 2024 46 2090 40 2082 44 2084 41 59 2023 2091 61 2085 46 2086 40 2081 46 2092 40 41 44 2093 45 62 2094 40 2081 44 2093 41 41 59 2026 46 2090 40 2082 44 2091 41 59 125 41 59 125 621 621 621 64 2027 439 2009 2095 40 41 123 450 2028 59 125 439 492 2096 40 64 2027 2009 2028 41 123 467 46 2028 61 2028 59 125 439 492 2097 40 2008 60 2009 62 2010 41 123 467 46 2010 61 2010 59 125 621 621 621 437 492 2098 40 2099 2100 44 2099 46 2101 2102 41 123 2009 2103 61 424 59 392 40 2100 46 2104 40 41 605 33 2100 46 2105 40 41 41 123 2103 61 2106 46 2107 40 648 41 59 125 360 123 392 40 2100 402 2108 605 2102 46 2109 40 41 614 2099 46 2101 46 2110 46 2109 40 41 41 123 381 2009 2111 61 2100 402 2112 63 2113 46 2114 40 648 41 58 2113 46 2114 40 648 41 59 2103 61 2113 46 2114 40 648 44 2111 41 59 125 392 40 2100 402 2115 605 2102 46 2109 40 41 614 2099 46 2101 46 2116 46 2109 40 41 41 2103 61 2117 46 2118 40 648 41 59 360 392 40 2100 402 2119 605 2102 46 2109 40 41 614 2099 46 2101 46 2120 46 2109 40 41 41 2103 61 2117 46 2118 40 648 41 59 125 392 40 2103 631 424 41 123 2009 2121 61 648 43 2102 46 2122 40 41 43 2100 46 2123 40 41 59 392 40 2124 46 2125 40 2121 41 41 123 2005 2012 61 418 2005 40 41 46 2126 40 2100 46 2127 40 41 41 46 2103 40 2103 41 59 392 40 2021 46 2128 40 41 631 424 605 33 2021 46 2128 40 41 46 2129 40 2130 46 334 41 41 123 2012 46 2131 40 648 41 46 2132 40 40 41 45 62 123 2124 46 2133 40 2121 44 473 41 59 2021 46 2134 40 2135 46 334 44 2136 46 334 44 2130 46 334 41 59 392 40 2010 631 424 41 2137 46 2138 40 40 41 45 62 2010 46 2139 40 2100 46 2123 40 41 41 44 1501 41 59 125 41 46 2140 40 40 41 45 62 2124 46 2141 40 2121 44 473 41 41 46 2142 40 41 59 125 360 392 40 2028 631 424 605 33 2100 46 2123 40 41 46 2143 40 2028 41 41 123 2012 46 2144 40 2145 46 2146 40 648 41 41 46 2147 40 40 41 45 62 123 2124 46 2148 40 2121 44 473 41 59 392 40 2010 631 424 41 2010 46 2149 40 2100 46 2123 40 41 41 59 125 41 46 2150 40 40 41 45 62 2124 46 2151 40 2121 44 473 41 41 46 2152 40 41 59 125 125 125 125 437 492 2153 40 2099 2100 44 2099 46 2154 2155 41 123 2009 2156 61 424 59 392 40 2019 46 2157 40 2100 46 2158 40 41 41 46 2159 40 41 41 123 2009 2160 61 2019 46 2157 40 2100 46 2158 40 41 41 46 2161 40 41 46 2162 40 41 63 2163 46 2161 40 648 41 58 2163 46 2161 40 648 41 59 464 40 2155 41 123 328 2164 58 325 59 328 2165 58 325 59 328 2166 58 2156 61 2163 46 2161 40 648 44 2160 41 59 325 59 328 2167 58 2156 61 2163 46 2161 40 648 44 2160 41 59 325 59 349 58 621 621 621 621 325 59 125 392 40 2156 631 424 41 123 2168 40 2100 44 2156 44 380 41 59 125 125 360 392 40 2017 46 2157 40 2100 46 2158 40 41 41 46 2159 40 41 41 123 2009 2169 61 2017 46 2157 40 2100 46 2158 40 41 41 46 2170 40 41 46 2171 40 41 63 2172 46 2170 40 648 41 58 2172 46 2170 40 648 41 59 464 40 2155 41 123 621 328 2173 58 325 59 328 2174 58 2156 61 2172 46 2170 40 648 44 2169 41 59 325 59 328 2175 58 2156 61 2172 46 2170 40 648 44 2169 41 59 325 59 349 58 621 621 621 621 325 59 125 392 40 2156 631 424 41 123 2176 40 2100 44 2156 44 473 41 59 125 125 125 437 492 2177 40 2099 2100 44 2009 2178 44 324 2179 41 123 2005 2012 61 418 2005 40 41 46 2180 40 2100 46 2181 40 41 41 46 2178 40 2178 41 59 2182 60 63 378 2183 62 2184 61 2179 63 2185 46 334 58 2186 46 334 59 392 40 2021 46 2187 40 41 631 424 605 33 2021 46 2187 40 41 46 2188 40 2184 41 41 123 2012 46 2189 40 648 41 46 2190 40 40 41 45 62 2021 46 2191 40 2192 46 334 44 2193 46 334 44 2184 41 41 46 2194 40 41 59 125 360 123 2012 46 2195 40 41 59 125 125 125 
2523,Java,"public class PathExecutor implements IPathExecutor, Helper {

    private static final double MAX_MAX_DIST_FROM_PATH = 3;
    private static final double MAX_DIST_FROM_PATH = 2;

    /**
     * Default value is equal to 10 seconds. It's find to decrease it, but it must be at least 5.5s (110 ticks).
     * For more information, see issue #102.
     *
     * @see <a href=""https://github.com/cabaletta/baritone/issues/102"">Issue #102</a>
     * @see <a href=""https://i.imgur.com/5s5GLnI.png"">Anime</a>
     */
    private static final double MAX_TICKS_AWAY = 200;

    private final IPath path;
    private int pathPosition;
    private int ticksAway;
    private int ticksOnCurrent;
    private Double currentMovementOriginalCostEstimate;
    private Integer costEstimateIndex;
    private boolean failed;
    private boolean recalcBP = true;
    private HashSet<BlockPos> toBreak = new HashSet<>();
    private HashSet<BlockPos> toPlace = new HashSet<>();
    private HashSet<BlockPos> toWalkInto = new HashSet<>();

    private PathingBehavior behavior;
    private IPlayerContext ctx;

    private boolean sprintNextTick;

    public PathExecutor(PathingBehavior behavior, IPath path) {
        this.behavior = behavior;
        this.ctx = behavior.ctx;
        this.path = path;
        this.pathPosition = 0;
    }

    /**
     * Tick this executor
     *
     * @return True if a movement just finished (and the player is therefore in a ""stable"" state, like,
     * not sneaking out over lava), false otherwise
     */
    public boolean onTick() {
        if (pathPosition == path.length() - 1) {
            pathPosition++;
        }
        if (pathPosition >= path.length()) {
            return true; // stop bugging me, I'm done
        }
        Movement movement = (Movement) path.movements().get(pathPosition);
        BetterBlockPos whereAmI = ctx.playerFeet();
        if (!movement.getValidPositions().contains(whereAmI)) {
            for (int i = 0; i < pathPosition && i < path.length(); i++) {//this happens for example when you lag out and get teleported back a couple blocks
                if (((Movement) path.movements().get(i)).getValidPositions().contains(whereAmI)) {
                    int previousPos = pathPosition;
                    pathPosition = i;
                    for (int j = pathPosition; j <= previousPos; j++) {
                        path.movements().get(j).reset();
                    }
                    onChangeInPathPosition();
                    onTick();
                    return false;
                }
            }
            for (int i = pathPosition + 3; i < path.length() - 1; i++) { //dont check pathPosition+1. the movement tells us when it's done (e.g. sneak placing)
                // also don't check pathPosition+2 because reasons
                if (((Movement) path.movements().get(i)).getValidPositions().contains(whereAmI)) {
                    if (i - pathPosition > 2) {
                        logDebug(""Skipping forward "" + (i - pathPosition) + "" steps, to "" + i);
                    }
                    //System.out.println(""Double skip sundae"");
                    pathPosition = i - 1;
                    onChangeInPathPosition();
                    onTick();
                    return false;
                }
            }
        }
        Tuple<Double, BlockPos> status = closestPathPos(path);
        if (possiblyOffPath(status, MAX_DIST_FROM_PATH)) {
            ticksAway++;
            System.out.println(""FAR AWAY FROM PATH FOR "" + ticksAway + "" TICKS. Current distance: "" + status.getFirst() + "". Threshold: "" + MAX_DIST_FROM_PATH);
            if (ticksAway > MAX_TICKS_AWAY) {
                logDebug(""Too far away from path for too long, cancelling path"");
                cancel();
                return false;
            }
        } else {
            ticksAway = 0;
        }
        if (possiblyOffPath(status, MAX_MAX_DIST_FROM_PATH)) { // ok, stop right away, we're way too far.
            logDebug(""too far from path"");
            cancel();
            return false;
        }
        //long start = System.nanoTime() / 1000000L;
        BlockStateInterface bsi = new BlockStateInterface(ctx);
        for (int i = pathPosition - 10; i < pathPosition + 10; i++) {
            if (i < 0 || i >= path.movements().size()) {
                continue;
            }
            Movement m = (Movement) path.movements().get(i);
            List<BlockPos> prevBreak = m.toBreak(bsi);
            List<BlockPos> prevPlace = m.toPlace(bsi);
            List<BlockPos> prevWalkInto = m.toWalkInto(bsi);
            m.resetBlockCache();
            if (!prevBreak.equals(m.toBreak(bsi))) {
                recalcBP = true;
            }
            if (!prevPlace.equals(m.toPlace(bsi))) {
                recalcBP = true;
            }
            if (!prevWalkInto.equals(m.toWalkInto(bsi))) {
                recalcBP = true;
            }
        }
        if (recalcBP) {
            HashSet<BlockPos> newBreak = new HashSet<>();
            HashSet<BlockPos> newPlace = new HashSet<>();
            HashSet<BlockPos> newWalkInto = new HashSet<>();
            for (int i = pathPosition; i < path.movements().size(); i++) {
                Movement m = (Movement) path.movements().get(i);
                newBreak.addAll(m.toBreak(bsi));
                newPlace.addAll(m.toPlace(bsi));
                newWalkInto.addAll(m.toWalkInto(bsi));
            }
            toBreak = newBreak;
            toPlace = newPlace;
            toWalkInto = newWalkInto;
            recalcBP = false;
        }
        /*long end = System.nanoTime() / 1000000L;
        if (end - start > 0) {
            System.out.println(""Recalculating break and place took "" + (end - start) + ""ms"");
        }*/
        if (pathPosition < path.movements().size() - 1) {
            IMovement next = path.movements().get(pathPosition + 1);
            if (!behavior.baritone.bsi.worldContainsLoadedChunk(next.getDest().x, next.getDest().z)) {
                logDebug(""Pausing since destination is at edge of loaded chunks"");
                clearKeys();
                return true;
            }
        }
        boolean canCancel = movement.safeToCancel();
        if (costEstimateIndex == null || costEstimateIndex != pathPosition) {
            costEstimateIndex = pathPosition;
            // do this only once, when the movement starts, and deliberately get the cost as cached when this path was calculated, not the cost as it is right now
            currentMovementOriginalCostEstimate = movement.getCost();
            for (int i = 1; i < Baritone.settings().costVerificationLookahead.value && pathPosition + i < path.length() - 1; i++) {
                if (((Movement) path.movements().get(pathPosition + i)).calculateCost(behavior.secretInternalGetCalculationContext()) >= ActionCosts.COST_INF && canCancel) {
                    logDebug(""Something has changed in the world and a future movement has become impossible. Cancelling."");
                    cancel();
                    return true;
                }
            }
        }
        double currentCost = movement.recalculateCost(behavior.secretInternalGetCalculationContext());
        if (currentCost >= ActionCosts.COST_INF && canCancel) {
            logDebug(""Something has changed in the world and this movement has become impossible. Cancelling."");
            cancel();
            return true;
        }
        if (!movement.calculatedWhileLoaded() && currentCost - currentMovementOriginalCostEstimate > Baritone.settings().maxCostIncrease.value && canCancel) {
            // don't do this if the movement was calculated while loaded
            // that means that this isn't a cache error, it's just part of the path interfering with a later part
            logDebug(""Original cost "" + currentMovementOriginalCostEstimate + "" current cost "" + currentCost + "". Cancelling."");
            cancel();
            return true;
        }
        if (shouldPause()) {
            logDebug(""Pausing since current best path is a backtrack"");
            clearKeys();
            return true;
        }
        MovementStatus movementStatus = movement.update();
        if (movementStatus == UNREACHABLE || movementStatus == FAILED) {
            logDebug(""Movement returns status "" + movementStatus);
            cancel();
            return true;
        }
        if (movementStatus == SUCCESS) {
            //System.out.println(""Movement done, next path"");
            pathPosition++;
            onChangeInPathPosition();
            onTick();
            return true;
        } else {
            sprintNextTick = shouldSprintNextTick();
            if (!sprintNextTick) {
                ctx.player().setSprinting(false); // letting go of control doesn't make you stop sprinting actually
            }
            ticksOnCurrent++;
            if (ticksOnCurrent > currentMovementOriginalCostEstimate + Baritone.settings().movementTimeoutTicks.value) {
                // only cancel if the total time has exceeded the initial estimate
                // as you break the blocks required, the remaining cost goes down, to the point where
                // ticksOnCurrent is greater than recalculateCost + 100
                // this is why we cache cost at the beginning, and don't recalculate for this comparison every tick
                logDebug(""This movement has taken too long ("" + ticksOnCurrent + "" ticks, expected "" + currentMovementOriginalCostEstimate + ""). Cancelling."");
                cancel();
                return true;
            }
        }
        return canCancel; // movement is in progress, but if it reports cancellable, PathingBehavior is good to cut onto the next path
    }

    private Tuple<Double, BlockPos> closestPathPos(IPath path) {
        double best = -1;
        BlockPos bestPos = null;
        for (IMovement movement : path.movements()) {
            for (BlockPos pos : ((Movement) movement).getValidPositions()) {
                double dist = VecUtils.entityDistanceToCenter(ctx.player(), pos);
                if (dist < best || best == -1) {
                    best = dist;
                    bestPos = pos;
                }
            }
        }
        return new Tuple<>(best, bestPos);
    }

    private boolean shouldPause() {
        Optional<AbstractNodeCostSearch> current = behavior.getInProgress();
        if (!current.isPresent()) {
            return false;
        }
        if (!ctx.player().onGround) {
            return false;
        }
        if (!MovementHelper.canWalkOn(ctx, ctx.playerFeet().down())) {
            // we're in some kind of sketchy situation, maybe parkouring
            return false;
        }
        if (!MovementHelper.canWalkThrough(ctx, ctx.playerFeet()) || !MovementHelper.canWalkThrough(ctx, ctx.playerFeet().up())) {
            // suffocating?
            return false;
        }
        if (!path.movements().get(pathPosition).safeToCancel()) {
            return false;
        }
        Optional<IPath> currentBest = current.get().bestPathSoFar();
        if (!currentBest.isPresent()) {
            return false;
        }
        List<BetterBlockPos> positions = currentBest.get().positions();
        if (positions.size() < 3) {
            return false; // not long enough yet to justify pausing, its far from certain we'll actually take this route
        }
        // the first block of the next path will always overlap
        // no need to pause our very last movement when it would have otherwise cleanly exited with MovementStatus SUCCESS
        positions = positions.subList(1, positions.size());
        return positions.contains(ctx.playerFeet());
    }

    private boolean possiblyOffPath(Tuple<Double, BlockPos> status, double leniency) {
        double distanceFromPath = status.getFirst();
        if (distanceFromPath > leniency) {
            // when we're midair in the middle of a fall, we're very far from both the beginning and the end, but we aren't actually off path
            if (path.movements().get(pathPosition) instanceof MovementFall) {
                BlockPos fallDest = path.positions().get(pathPosition + 1); // .get(pathPosition) is the block we fell off of
                return VecUtils.entityFlatDistanceToCenter(ctx.player(), fallDest) >= leniency; // ignore Y by using flat distance
            } else {
                return true;
            }
        } else {
            return false;
        }
    }

    /**
     * Regardless of current path position, snap to the current player feet if possible
     *
     * @return Whether or not it was possible to snap to the current player feet
     */
    public boolean snipsnapifpossible() {
        if (!ctx.player().onGround && !(ctx.world().getBlockState(ctx.playerFeet()).getBlock() instanceof BlockLiquid)) {
            // if we're falling in the air, and not in water, don't splice
            return false;
        } else {
            // we are either onGround or in liquid
            if (ctx.player().motionY < -0.1) {
                // if we are strictly moving downwards (not stationary)
                // we could be falling through water, which could be unsafe to splice
                return false; // so don't
            }
        }
        int index = path.positions().indexOf(ctx.playerFeet());
        if (index == -1) {
            return false;
        }
        pathPosition = index; // jump directly to current position
        clearKeys();
        return true;
    }

    private boolean shouldSprintNextTick() {
        boolean requested = behavior.baritone.getInputOverrideHandler().isInputForcedDown(Input.SPRINT);

        // we'll take it from here, no need for minecraft to see we're holding down control and sprint for us
        behavior.baritone.getInputOverrideHandler().setInputForceState(Input.SPRINT, false);

        // first and foremost, if allowSprint is off, or if we don't have enough hunger, don't try and sprint
        if (!new CalculationContext(behavior.baritone).canSprint) {
            return false;
        }
        IMovement current = path.movements().get(pathPosition);

        // traverse requests sprinting, so we need to do this check first
        if (current instanceof MovementTraverse && pathPosition < path.length() - 3) {
            IMovement next = path.movements().get(pathPosition + 1);
            if (next instanceof MovementAscend && sprintableAscend(ctx, (MovementTraverse) current, (MovementAscend) next, path.movements().get(pathPosition + 2))) {
                if (skipNow(ctx, current)) {
                    logDebug(""Skipping traverse to straight ascend"");
                    pathPosition++;
                    onChangeInPathPosition();
                    onTick();
                    behavior.baritone.getInputOverrideHandler().setInputForceState(Input.JUMP, true);
                    return true;
                } else {
                    logDebug(""Too far to the side to safely sprint ascend"");
                }
            }
        }

        // if the movement requested sprinting, then we're done
        if (requested) {
            return true;
        }

        // however, descend and ascend don't request sprinting, because they don't know the context of what movement comes after it
        if (current instanceof MovementDescend) {

            if (((MovementDescend) current).safeMode() && !((MovementDescend) current).skipToAscend()) {
                logDebug(""Sprinting would be unsafe"");
                return false;
            }

            if (pathPosition < path.length() - 2) {
                IMovement next = path.movements().get(pathPosition + 1);
                if (next instanceof MovementAscend && current.getDirection().up().equals(next.getDirection().down())) {
                    // a descend then an ascend in the same direction
                    pathPosition++;
                    onChangeInPathPosition();
                    onTick();
                    // okay to skip clearKeys and / or onChangeInPathPosition here since this isn't possible to repeat, since it's asymmetric
                    logDebug(""Skipping descend to straight ascend"");
                    return true;
                }
                if (canSprintFromDescendInto(ctx, current, next)) {
                    if (ctx.playerFeet().equals(current.getDest())) {
                        pathPosition++;
                        onChangeInPathPosition();
                        onTick();
                    }
                    return true;
                }
                //logDebug(""Turning off sprinting "" + movement + "" "" + next + "" "" + movement.getDirection() + "" "" + next.getDirection().down() + "" "" + next.getDirection().down().equals(movement.getDirection()));
            }
        }
        if (current instanceof MovementAscend && pathPosition != 0) {
            IMovement prev = path.movements().get(pathPosition - 1);
            if (prev instanceof MovementDescend && prev.getDirection().up().equals(current.getDirection().down())) {
                BlockPos center = current.getSrc().up();
                // playerFeet adds 0.1251 to account for soul sand
                // farmland is 0.9375
                // 0.07 is to account for farmland
                if (ctx.player().posY >= center.getY() - 0.07) {
                    behavior.baritone.getInputOverrideHandler().setInputForceState(Input.JUMP, false);
                    return true;
                }
            }
            if (pathPosition < path.length() - 2 && prev instanceof MovementTraverse && sprintableAscend(ctx, (MovementTraverse) prev, (MovementAscend) current, path.movements().get(pathPosition + 1))) {
                return true;
            }
        }
        if (current instanceof MovementFall) {
            Tuple<Vec3d, BlockPos> data = overrideFall((MovementFall) current);
            if (data != null) {
                BetterBlockPos fallDest = new BetterBlockPos(data.getSecond());
                if (!path.positions().contains(fallDest)) {
                    throw new IllegalStateException();
                }
                if (ctx.playerFeet().equals(fallDest)) {
                    pathPosition = path.positions().indexOf(fallDest);
                    onChangeInPathPosition();
                    onTick();
                    return true;
                }
                clearKeys();
                behavior.baritone.getLookBehavior().updateTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), data.getFirst(), ctx.playerRotations()), false);
                behavior.baritone.getInputOverrideHandler().setInputForceState(Input.MOVE_FORWARD, true);
                return true;
            }
        }
        return false;
    }

    private Tuple<Vec3d, BlockPos> overrideFall(MovementFall movement) {
        Vec3i dir = movement.getDirection();
        if (dir.getY() < -3) {
            return null;
        }
        if (!movement.toBreakCached.isEmpty()) {
            return null; // it's breaking
        }
        Vec3i flatDir = new Vec3i(dir.getX(), 0, dir.getZ());
        int i;
        outer:
        for (i = pathPosition + 1; i < path.length() - 1 && i < pathPosition + 3; i++) {
            IMovement next = path.movements().get(i);
            if (!(next instanceof MovementTraverse)) {
                break;
            }
            if (!flatDir.equals(next.getDirection())) {
                break;
            }
            for (int y = next.getDest().y; y <= movement.getSrc().y + 1; y++) {
                BlockPos chk = new BlockPos(next.getDest().x, y, next.getDest().z);
                if (!MovementHelper.fullyPassable(ctx, chk)) {
                    break outer;
                }
            }
            if (!MovementHelper.canWalkOn(ctx, next.getDest().down())) {
                break;
            }
        }
        i--;
        if (i == pathPosition) {
            return null; // no valid extension exists
        }
        double len = i - pathPosition - 0.4;
        return new Tuple<>(
                new Vec3d(flatDir.getX() * len + movement.getDest().x + 0.5, movement.getDest().y, flatDir.getZ() * len + movement.getDest().z + 0.5),
                movement.getDest().add(flatDir.getX() * (i - pathPosition), 0, flatDir.getZ() * (i - pathPosition)));
    }

    private static boolean skipNow(IPlayerContext ctx, IMovement current) {
        double offTarget = Math.abs(current.getDirection().getX() * (current.getSrc().z + 0.5D - ctx.player().posZ)) + Math.abs(current.getDirection().getZ() * (current.getSrc().x + 0.5D - ctx.player().posX));
        if (offTarget > 0.1) {
            return false;
        }
        // we are centered
        BlockPos headBonk = current.getSrc().subtract(current.getDirection()).up(2);
        if (MovementHelper.fullyPassable(ctx, headBonk)) {
            return true;
        }
        // wait 0.3
        double flatDist = Math.abs(current.getDirection().getX() * (headBonk.getX() + 0.5D - ctx.player().posX)) + Math.abs(current.getDirection().getZ() * (headBonk.getZ() + 0.5 - ctx.player().posZ));
        return flatDist > 0.8;
    }

    private static boolean sprintableAscend(IPlayerContext ctx, MovementTraverse current, MovementAscend next, IMovement nextnext) {
        if (!Baritone.settings().sprintAscends.value) {
            return false;
        }
        if (!current.getDirection().equals(next.getDirection().down())) {
            return false;
        }
        if (nextnext.getDirection().getX() != next.getDirection().getX() || nextnext.getDirection().getZ() != next.getDirection().getZ()) {
            return false;
        }
        if (!MovementHelper.canWalkOn(ctx, current.getDest().down())) {
            return false;
        }
        if (!MovementHelper.canWalkOn(ctx, next.getDest().down())) {
            return false;
        }
        if (!next.toBreakCached.isEmpty()) {
            return false; // it's breaking
        }
        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 3; y++) {
                BlockPos chk = current.getSrc().up(y);
                if (x == 1) {
                    chk = chk.add(current.getDirection());
                }
                if (!MovementHelper.fullyPassable(ctx, chk)) {
                    return false;
                }
            }
        }
        if (MovementHelper.avoidWalkingInto(ctx.world().getBlockState(current.getSrc().up(3)).getBlock())) {
            return false;
        }
        return !MovementHelper.avoidWalkingInto(ctx.world().getBlockState(next.getDest().up(2)).getBlock()); // codacy smh my head
    }

    private static boolean canSprintFromDescendInto(IPlayerContext ctx, IMovement current, IMovement next) {
        if (next instanceof MovementDescend && next.getDirection().equals(current.getDirection())) {
            return true;
        }
        if (!MovementHelper.canWalkOn(ctx, current.getDest().add(current.getDirection()))) {
            return false;
        }
        if (next instanceof MovementTraverse && next.getDirection().down().equals(current.getDirection())) {
            return true;
        }
        return next instanceof MovementDiagonal && Baritone.settings().allowOvershootDiagonalDescend.value;
    }

    private void onChangeInPathPosition() {
        clearKeys();
        ticksOnCurrent = 0;
    }

    private void clearKeys() {
        // i'm just sick and tired of this snippet being everywhere lol
        behavior.baritone.getInputOverrideHandler().clearAllKeys();
    }

    private void cancel() {
        clearKeys();
        behavior.baritone.getInputOverrideHandler().getBlockBreakHelper().stopBreakingBlock();
        pathPosition = path.length() + 3;
        failed = true;
    }

    @Override
    public int getPosition() {
        return pathPosition;
    }

    public PathExecutor trySplice(PathExecutor next) {
        if (next == null) {
            return cutIfTooLong();
        }
        return SplicedPath.trySplice(path, next.path, false).map(path -> {
            if (!path.getDest().equals(next.getPath().getDest())) {
                throw new IllegalStateException();
            }
            PathExecutor ret = new PathExecutor(behavior, path);
            ret.pathPosition = pathPosition;
            ret.currentMovementOriginalCostEstimate = currentMovementOriginalCostEstimate;
            ret.costEstimateIndex = costEstimateIndex;
            ret.ticksOnCurrent = ticksOnCurrent;
            return ret;
        }).orElseGet(this::cutIfTooLong); // dont actually call cutIfTooLong every tick if we won't actually use it, use a method reference
    }

    private PathExecutor cutIfTooLong() {
        if (pathPosition > Baritone.settings().maxPathHistoryLength.value) {
            int cutoffAmt = Baritone.settings().pathHistoryCutoffAmount.value;
            CutoffPath newPath = new CutoffPath(path, cutoffAmt, path.length() - 1);
            if (!newPath.getDest().equals(path.getDest())) {
                throw new IllegalStateException();
            }
            logDebug(""Discarding earliest segment movements, length cut from "" + path.length() + "" to "" + newPath.length());
            PathExecutor ret = new PathExecutor(behavior, newPath);
            ret.pathPosition = pathPosition - cutoffAmt;
            ret.currentMovementOriginalCostEstimate = currentMovementOriginalCostEstimate;
            if (costEstimateIndex != null) {
                ret.costEstimateIndex = costEstimateIndex - cutoffAmt;
            }
            ret.ticksOnCurrent = ticksOnCurrent;
            return ret;
        }
        return this;
    }

    @Override
    public IPath getPath() {
        return path;
    }

    public boolean failed() {
        return failed;
    }

    public boolean finished() {
        return pathPosition >= path.length();
    }

    public Set<BlockPos> toBreak() {
        return Collections.unmodifiableSet(toBreak);
    }

    public Set<BlockPos> toPlace() {
        return Collections.unmodifiableSet(toPlace);
    }

    public Set<BlockPos> toWalkInto() {
        return Collections.unmodifiableSet(toWalkInto);
    }

    public boolean isSprinting() {
        return sprintNextTick;
    }
}",1,439 334 2000 395 2001 44 2002 123 437 457 381 356 2003 61 1502 59 437 457 381 356 2004 61 1502 59 618 437 457 381 356 2005 61 1504 59 437 381 2006 2007 59 437 404 2008 59 437 404 2009 59 437 404 2010 59 437 2011 2012 59 437 2013 2014 59 437 324 2015 59 437 324 2016 61 473 59 437 2017 60 2018 62 2019 61 418 2017 60 62 40 41 59 437 2017 60 2018 62 2020 61 418 2017 60 62 40 41 59 437 2017 60 2018 62 2021 61 418 2017 60 62 40 41 59 437 2022 2023 59 437 2024 2025 59 437 324 2026 59 439 2000 40 2022 2023 44 2006 2007 41 123 467 46 2023 61 2023 59 467 46 2025 61 2023 46 2025 59 467 46 2007 61 2007 59 467 46 2008 61 1500 59 125 618 439 324 2027 40 41 123 392 40 2008 614 2007 46 2028 40 41 45 1501 41 123 2008 637 59 125 392 40 2008 615 2007 46 2028 40 41 41 123 450 473 59 621 125 2029 2030 61 40 2029 41 2007 46 2031 40 41 46 2032 40 2008 41 59 2033 2034 61 2025 46 2035 40 41 59 392 40 33 2030 46 2036 40 41 46 2037 40 2034 41 41 123 385 40 404 2038 61 1500 59 2038 60 2008 605 2038 60 2007 46 2028 40 41 59 2038 637 41 123 621 392 40 40 40 2029 41 2007 46 2031 40 41 46 2032 40 2038 41 41 46 2036 40 41 46 2037 40 2034 41 41 123 404 2039 61 2008 59 2008 61 2038 59 385 40 404 2040 61 2008 59 2040 620 2039 59 2040 637 41 123 2007 46 2031 40 41 46 2032 40 2040 41 46 2041 40 41 59 125 2042 40 41 59 2027 40 41 59 450 380 59 125 125 385 40 404 2038 61 2008 43 1502 59 2038 60 2007 46 2028 40 41 45 1501 59 2038 637 41 123 621 621 392 40 40 40 2029 41 2007 46 2031 40 41 46 2032 40 2038 41 41 46 2036 40 41 46 2037 40 2034 41 41 123 392 40 2038 45 2008 62 1502 41 123 2043 40 648 43 40 2038 45 2008 41 43 648 43 2038 41 59 125 621 2008 61 2038 45 1501 59 2044 40 41 59 2027 40 41 59 450 380 59 125 125 125 2045 60 2011 44 2018 62 2046 61 2047 40 2007 41 59 392 40 2048 40 2046 44 2004 41 41 123 2009 637 59 2049 46 430 46 2050 40 648 43 2009 43 648 43 2046 46 2051 40 41 43 648 43 2004 41 59 392 40 2009 62 2005 41 123 2052 40 648 41 59 2053 40 41 59 450 380 59 125 125 360 123 2009 61 1500 59 125 392 40 2048 40 2046 44 2003 41 41 123 621 2054 40 648 41 59 2055 40 41 59 450 380 59 125 621 2056 2057 61 418 2056 40 2025 41 59 385 40 404 2058 61 2008 45 1502 59 2058 60 2008 43 1502 59 2058 637 41 123 392 40 2058 60 1500 606 2058 615 2007 46 2031 40 41 46 2059 40 41 41 123 344 59 125 2029 2060 61 40 2029 41 2007 46 2031 40 41 46 2032 40 2058 41 59 2061 60 2018 62 2062 61 2060 46 2019 40 2057 41 59 2061 60 2018 62 2063 61 2060 46 2020 40 2057 41 59 2061 60 2018 62 2064 61 2060 46 2021 40 2057 41 59 2060 46 2065 40 41 59 392 40 33 2062 46 2066 40 2060 46 2019 40 2057 41 41 41 123 2016 61 473 59 125 392 40 33 2063 46 2066 40 2060 46 2020 40 2057 41 41 41 123 2016 61 473 59 125 392 40 33 2064 46 2066 40 2060 46 2021 40 2057 41 41 41 123 2016 61 473 59 125 125 392 40 2016 41 123 2017 60 2018 62 2067 61 418 2017 60 62 40 41 59 2017 60 2018 62 2068 61 418 2017 60 62 40 41 59 2017 60 2018 62 2069 61 418 2017 60 62 40 41 59 385 40 404 2058 61 2008 59 2058 60 2007 46 2031 40 41 46 2070 40 41 59 2058 637 41 123 2029 2071 61 40 2029 41 2007 46 2031 40 41 46 2032 40 2058 41 59 2067 46 2072 40 2071 46 2019 40 2057 41 41 59 2068 46 2072 40 2071 46 2020 40 2057 41 41 59 2069 46 2072 40 2071 46 2021 40 2057 41 41 59 125 2019 61 2067 59 2020 61 2068 59 2021 61 2069 59 2016 61 380 59 125 604 392 40 2008 60 2007 46 2031 40 41 46 2073 40 41 45 1501 41 123 2074 2075 61 2007 46 2031 40 41 46 2032 40 2008 43 1501 41 59 392 40 33 2023 46 2076 46 2057 46 2077 40 2075 46 2078 40 41 46 2079 44 2075 46 2078 40 41 46 2080 41 41 123 2081 40 648 41 59 2082 40 41 59 450 473 59 125 125 324 2083 61 2030 46 2084 40 41 59 392 40 2014 614 424 606 2014 631 2008 41 123 2014 61 2008 59 621 2012 61 2030 46 2085 40 41 59 385 40 404 2058 61 1501 59 2058 60 2086 46 2087 40 41 46 2088 46 2089 605 2008 43 2058 60 2007 46 2028 40 41 45 1501 59 2058 637 41 123 392 40 40 40 2029 41 2007 46 2031 40 41 46 2032 40 2008 43 2058 41 41 46 2090 40 2023 46 2091 40 41 41 615 2092 46 2093 605 2083 41 123 2094 40 648 41 59 2095 40 41 59 450 473 59 125 125 125 356 2096 61 2030 46 2097 40 2023 46 2098 40 41 41 59 392 40 2096 615 2099 46 2100 605 2083 41 123 2101 40 648 41 59 2102 40 41 59 450 473 59 125 392 40 33 2030 46 2103 40 41 605 2096 45 2012 62 2104 46 2105 40 41 46 2106 46 2107 605 2083 41 123 621 621 2108 40 648 43 2012 43 648 43 2096 43 648 41 59 2109 40 41 59 450 473 59 125 392 40 2110 40 41 41 123 2111 40 648 41 59 2112 40 41 59 450 473 59 125 2113 2114 61 2030 46 2115 40 41 59 392 40 2114 614 2116 606 2114 614 2117 41 123 2118 40 648 43 2114 41 59 2119 40 41 59 450 473 59 125 392 40 2114 614 2120 41 123 621 2008 637 59 2121 40 41 59 2027 40 41 59 450 473 59 125 360 123 2026 61 2122 40 41 59 392 40 33 2026 41 123 2025 46 2123 40 41 46 2124 40 380 41 59 621 125 2010 637 59 392 40 2010 62 2012 43 2104 46 2105 40 41 46 2125 46 2107 41 123 621 621 621 621 2126 40 648 43 2010 43 648 43 2012 43 648 41 59 2127 40 41 59 450 473 59 125 125 450 2083 59 621 125 437 2128 60 2011 44 2018 62 2129 40 2006 2007 41 123 356 2130 61 45 1501 59 2018 2131 61 424 59 385 40 2132 2133 58 2007 46 2134 40 41 41 123 385 40 2018 2135 58 40 40 2136 41 2133 41 46 2137 40 41 41 123 356 2138 61 2139 46 2140 40 2025 46 2141 40 41 44 2135 41 59 392 40 2138 60 2130 606 2130 614 45 1501 41 123 2130 61 2138 59 2131 61 2135 59 125 125 125 450 418 2128 60 62 40 2130 44 2131 41 59 125 437 324 2142 40 41 123 2143 60 2144 62 2145 61 2023 46 2146 40 41 59 392 40 33 2145 46 2147 40 41 41 123 450 380 59 125 392 40 33 2025 46 2148 40 41 46 2149 41 123 450 380 59 125 392 40 33 2150 46 2151 40 2025 44 2025 46 2152 40 41 46 2153 40 41 41 41 123 621 450 380 59 125 392 40 33 2150 46 2154 40 2025 44 2025 46 2152 40 41 41 606 33 2150 46 2154 40 2025 44 2025 46 2152 40 41 46 2155 40 41 41 41 123 621 450 380 59 125 392 40 33 2007 46 2156 40 41 46 2157 40 2008 41 46 2158 40 41 41 123 450 380 59 125 2143 60 2006 62 2159 61 2145 46 2157 40 41 46 2160 40 41 59 392 40 33 2159 46 2147 40 41 41 123 450 380 59 125 2161 60 2162 62 2163 61 2159 46 2157 40 41 46 2163 40 41 59 392 40 2163 46 2164 40 41 60 1502 41 123 450 380 59 621 125 621 621 2163 61 2163 46 2165 40 1501 44 2163 46 2164 40 41 41 59 450 2163 46 2166 40 2025 46 2152 40 41 41 59 125 437 324 2167 40 2128 60 2011 44 2018 62 2168 44 356 2169 41 123 356 2170 61 2168 46 2171 40 41 59 392 40 2170 62 2169 41 123 621 392 40 2007 46 2172 40 41 46 2173 40 2008 41 402 2174 41 123 2018 2175 61 2007 46 2176 40 41 46 2173 40 2008 43 1501 41 59 621 450 2177 46 2178 40 2025 46 2179 40 41 44 2175 41 615 2169 59 621 125 360 123 450 473 59 125 125 360 123 450 380 59 125 125 618 439 324 2180 40 41 123 392 40 33 2025 46 2181 40 41 46 2182 605 33 40 2025 46 2183 40 41 46 2184 40 2025 46 2185 40 41 41 46 2186 40 41 402 2187 41 41 123 621 450 380 59 125 360 123 621 392 40 2025 46 2181 40 41 46 2188 60 45 1499 41 123 621 621 450 380 59 621 125 125 404 2189 61 2007 46 2190 40 41 46 2191 40 2025 46 2185 40 41 41 59 392 40 2189 614 45 1501 41 123 450 380 59 125 2008 61 2189 59 621 2192 40 41 59 450 473 59 125 437 324 2193 40 41 123 324 2194 61 2023 46 2195 46 2196 40 41 46 2197 40 2198 46 2199 41 59 621 2023 46 2195 46 2196 40 41 46 2200 40 2198 46 2199 44 380 41 59 621 392 40 33 418 2201 40 2023 46 2195 41 46 2202 41 123 450 380 59 125 2203 2204 61 2007 46 2205 40 41 46 2206 40 2008 41 59 621 392 40 2204 402 2207 605 2008 60 2007 46 2208 40 41 45 1502 41 123 2203 2209 61 2007 46 2205 40 41 46 2206 40 2008 43 1501 41 59 392 40 2209 402 2210 605 2211 40 2025 44 40 2207 41 2204 44 40 2210 41 2209 44 2007 46 2205 40 41 46 2206 40 2008 43 1502 41 41 41 123 392 40 2212 40 2025 44 2204 41 41 123 2213 40 648 41 59 2008 637 59 2214 40 41 59 2027 40 41 59 2023 46 2195 46 2196 40 41 46 2200 40 2198 46 2215 44 473 41 59 450 473 59 125 360 123 2216 40 648 41 59 125 125 125 621 392 40 2194 41 123 450 473 59 125 621 392 40 2204 402 2217 41 123 392 40 40 40 2217 41 2204 41 46 2218 40 41 605 33 40 40 2217 41 2204 41 46 2219 40 41 41 123 2220 40 648 41 59 450 380 59 125 392 40 2008 60 2007 46 2208 40 41 45 1502 41 123 2203 2221 61 2007 46 2205 40 41 46 2206 40 2008 43 1501 41 59 392 40 2221 402 2222 605 2204 46 2223 40 41 46 2224 40 41 46 2225 40 2221 46 2223 40 41 46 2226 40 41 41 41 123 621 2008 637 59 2227 40 41 59 2027 40 41 59 621 2228 40 648 41 59 450 473 59 125 392 40 2229 40 2025 44 2204 44 2221 41 41 123 392 40 2025 46 2230 40 41 46 2225 40 2204 46 2231 40 41 41 41 123 2008 637 59 2232 40 41 59 2027 40 41 59 125 450 473 59 125 621 125 125 392 40 2204 402 2233 605 2008 631 1500 41 123 2203 2234 61 2007 46 2205 40 41 46 2206 40 2008 45 1501 41 59 392 40 2234 402 2217 605 2234 46 2235 40 41 46 2236 40 41 46 2237 40 2204 46 2235 40 41 46 2238 40 41 41 41 123 2018 2239 61 2204 46 2240 40 41 46 2236 40 41 59 621 621 621 392 40 2025 46 2241 40 41 46 2242 615 2239 46 2243 40 41 45 1498 41 123 2023 46 2195 46 2196 40 41 46 2200 40 2198 46 2244 44 380 41 59 450 473 59 125 125 392 40 2008 60 2007 46 2208 40 41 45 1502 605 2234 402 2207 605 2245 40 2025 44 40 2207 41 2234 44 40 2233 41 2204 44 2007 46 2205 40 41 46 2206 40 2008 43 1501 41 41 41 123 450 473 59 125 125 392 40 2204 402 2246 41 123 2128 60 2247 44 2018 62 2248 61 2249 40 40 2246 41 2204 41 59 392 40 2248 631 424 41 123 2250 2251 61 418 2250 40 2248 46 2252 40 41 41 59 392 40 33 2007 46 2253 40 41 46 2254 40 2251 41 41 123 469 418 2255 40 41 59 125 392 40 2025 46 2256 40 41 46 2257 40 2251 41 41 123 2008 61 2007 46 2253 40 41 46 2258 40 2251 41 59 2259 40 41 59 2027 40 41 59 450 473 59 125 2260 40 41 59 2023 46 2195 46 2261 40 41 46 2262 40 2263 46 2264 40 2025 46 2265 40 41 44 2248 46 2266 40 41 44 2025 46 2267 40 41 41 44 380 41 59 2023 46 2195 46 2196 40 41 46 2200 40 2198 46 2268 44 473 41 59 450 473 59 125 125 450 380 59 125 437 2128 60 2269 44 2018 62 2270 40 2271 2272 41 123 2273 2274 61 2272 46 2275 40 41 59 392 40 2274 46 2276 40 41 60 45 1502 41 123 450 424 59 125 392 40 33 2272 46 2277 46 2278 40 41 41 123 450 424 59 621 125 2273 2279 61 418 2273 40 2274 46 2280 40 41 44 1500 44 2274 46 2281 40 41 41 59 404 2282 59 2283 58 385 40 2282 61 2008 43 1501 59 2282 60 2007 46 2284 40 41 45 1501 605 2282 60 2008 43 1502 59 2282 637 41 123 2285 2286 61 2007 46 2287 40 41 46 2288 40 2282 41 59 392 40 33 40 2286 402 2289 41 41 123 325 59 125 392 40 33 2279 46 2290 40 2286 46 2275 40 41 41 41 123 325 59 125 385 40 404 2291 61 2286 46 2292 40 41 46 2291 59 2291 620 2272 46 2293 40 41 46 2291 43 1501 59 2291 637 41 123 2018 2294 61 418 2018 40 2286 46 2292 40 41 46 2295 44 2291 44 2286 46 2292 40 41 46 2296 41 59 392 40 33 2297 46 2298 40 2025 44 2294 41 41 123 325 2283 59 125 125 392 40 33 2299 46 2300 40 2025 44 2286 46 2292 40 41 46 2301 40 41 41 41 123 325 59 125 125 2282 629 59 392 40 2282 614 2008 41 123 450 424 59 621 125 356 2302 61 2282 45 2008 45 1499 59 450 418 2128 60 62 40 418 2269 40 2279 46 2280 40 41 42 2302 43 2272 46 2303 40 41 46 2304 43 1499 44 2272 46 2303 40 41 46 2305 44 2279 46 2281 40 41 42 2302 43 2272 46 2303 40 41 46 2306 43 1499 41 44 2272 46 2303 40 41 46 2307 40 2279 46 2280 40 41 42 40 2282 45 2008 41 44 1500 44 2279 46 2281 40 41 42 40 2282 45 2008 41 41 41 59 125 437 457 324 2308 40 2024 2025 44 2309 2310 41 123 356 2311 61 2312 46 2313 40 2310 46 2314 40 41 46 2315 40 41 42 40 2310 46 2316 40 41 46 2317 43 1499 45 2025 46 2318 40 41 46 2319 41 41 43 2312 46 2313 40 2310 46 2314 40 41 46 2320 40 41 42 40 2310 46 2316 40 41 46 2321 43 1499 45 2025 46 2318 40 41 46 2322 41 41 59 392 40 2311 62 1499 41 123 450 380 59 125 621 2018 2323 61 2310 46 2316 40 41 46 2324 40 2310 46 2314 40 41 41 46 2325 40 1502 41 59 392 40 2326 46 2327 40 2025 44 2323 41 41 123 450 473 59 125 621 356 2328 61 2312 46 2313 40 2310 46 2314 40 41 46 2315 40 41 42 40 2323 46 2315 40 41 43 1499 45 2025 46 2318 40 41 46 2322 41 41 43 2312 46 2313 40 2310 46 2314 40 41 46 2320 40 41 42 40 2323 46 2320 40 41 43 1499 45 2025 46 2318 40 41 46 2319 41 41 59 450 2328 62 1499 59 125 437 457 324 2329 40 2024 2025 44 2330 2310 44 2331 2332 44 2309 2333 41 123 392 40 33 2334 46 2335 40 41 46 2336 46 2337 41 123 450 380 59 125 392 40 33 2310 46 2338 40 41 46 2339 40 2332 46 2338 40 41 46 2340 40 41 41 41 123 450 380 59 125 392 40 2333 46 2338 40 41 46 2341 40 41 631 2332 46 2338 40 41 46 2341 40 41 606 2333 46 2338 40 41 46 2342 40 41 631 2332 46 2338 40 41 46 2342 40 41 41 123 450 380 59 125 392 40 33 2343 46 2344 40 2025 44 2310 46 2345 40 41 46 2340 40 41 41 41 123 450 380 59 125 392 40 33 2343 46 2344 40 2025 44 2332 46 2345 40 41 46 2340 40 41 41 41 123 450 380 59 125 392 40 33 2332 46 2346 46 2347 40 41 41 123 450 380 59 621 125 385 40 404 2348 61 1500 59 2348 60 1502 59 2348 637 41 123 385 40 404 2349 61 1500 59 2349 60 1502 59 2349 637 41 123 2018 2350 61 2310 46 2351 40 41 46 2352 40 2349 41 59 392 40 2348 614 1501 41 123 2350 61 2350 46 2353 40 2310 46 2338 40 41 41 59 125 392 40 33 2343 46 2354 40 2025 44 2350 41 41 123 450 380 59 125 125 125 392 40 2343 46 2355 40 2025 46 2356 40 41 46 2357 40 2310 46 2358 40 41 46 2359 40 1502 41 41 46 2360 40 41 41 41 123 450 380 59 125 450 33 2343 46 2355 40 2025 46 2356 40 41 46 2357 40 2332 46 2345 40 41 46 2359 40 1502 41 41 46 2360 40 41 41 59 621 125 437 457 324 2361 40 2024 2025 44 2309 2310 44 2309 2332 41 123 392 40 2332 402 2362 605 2332 46 2363 40 41 46 2364 40 2310 46 2363 40 41 41 41 123 450 473 59 125 392 40 33 2365 46 2366 40 2025 44 2310 46 2367 40 41 46 2368 40 2310 46 2363 40 41 41 41 41 123 450 380 59 125 392 40 2332 402 2330 605 2332 46 2363 40 41 46 2369 40 41 46 2364 40 2310 46 2363 40 41 41 41 123 450 473 59 125 450 2332 402 2370 605 2371 46 2372 40 41 46 2373 46 2374 59 125 437 492 2375 40 41 123 2376 40 41 59 2010 61 1500 59 125 437 492 2377 40 41 123 621 2023 46 2378 46 2379 40 41 46 2380 40 41 59 125 437 492 2381 40 41 123 2377 40 41 59 2023 46 2382 46 2383 40 41 46 2384 40 41 46 2385 40 41 59 2008 61 2007 46 2386 40 41 43 1502 59 2015 61 473 59 125 64 2387 439 404 2388 40 41 123 450 2008 59 125 439 2000 2389 40 2000 2332 41 123 392 40 2332 614 424 41 123 450 2390 40 41 59 125 450 2391 46 2389 40 2007 44 2332 46 2007 44 380 41 46 2392 40 2007 45 62 123 392 40 33 2007 46 2393 40 41 46 2394 40 2332 46 2395 40 41 46 2393 40 41 41 41 123 469 418 2396 40 41 59 125 2000 2397 61 418 2000 40 2023 44 2007 41 59 2397 46 2008 61 2008 59 2397 46 2012 61 2012 59 2397 46 2014 61 2014 59 2397 46 2010 61 2010 59 450 2397 59 125 41 46 2398 40 467 58 58 2399 41 59 621 125 437 2000 2400 40 41 123 392 40 2008 62 2401 46 2402 40 41 46 2403 46 2404 41 123 404 2405 61 2401 46 2402 40 41 46 2406 46 2404 59 2407 2408 61 418 2407 40 2007 44 2405 44 2007 46 2409 40 41 45 1501 41 59 392 40 33 2408 46 2410 40 41 46 2411 40 2007 46 2410 40 41 41 41 123 469 418 2412 40 41 59 125 2413 40 648 43 2007 46 2409 40 41 43 648 43 2408 46 2409 40 41 41 59 2000 2414 61 418 2000 40 2023 44 2408 41 59 2414 46 2008 61 2008 45 2405 59 2414 46 2012 61 2012 59 392 40 2014 631 424 41 123 2414 46 2014 61 2014 45 2405 59 125 2414 46 2010 61 2010 59 450 2414 59 125 450 467 59 125 64 2387 439 2006 2415 40 41 123 450 2007 59 125 439 324 2015 40 41 123 450 2015 59 125 439 324 2416 40 41 123 450 2008 615 2007 46 2417 40 41 59 125 439 2418 60 2018 62 2019 40 41 123 450 2419 46 2420 40 2019 41 59 125 439 2418 60 2018 62 2020 40 41 123 450 2421 46 2422 40 2020 41 59 125 439 2418 60 2018 62 2021 40 41 123 450 2423 46 2424 40 2021 41 59 125 439 324 2425 40 41 123 450 2026 59 125 125 
29403,Java,"	public static final class PatchFixes {
		public static boolean isGenerated(org.eclipse.jdt.core.dom.ASTNode node) {
			boolean result = false;
			try {
				result = ((Boolean)node.getClass().getField(""$isGenerated"").get(node)).booleanValue();
				if (!result && node.getParent() != null && node.getParent() instanceof org.eclipse.jdt.core.dom.QualifiedName) {
					result = isGenerated(node.getParent());
				}
			} catch (Exception e) {
				// better to assume it isn't generated
			}
			return result;
		}

		public static boolean isGenerated(org.eclipse.jdt.internal.compiler.ast.ASTNode node) {
			boolean result = false;
			try {
				result = node.getClass().getField(""$generatedBy"").get(node) != null;
			} catch (Exception e) {
				// better to assume it isn't generated
			}
			return result;
		}

		public static boolean isGenerated(org.eclipse.jdt.core.IMember member) {
			boolean result = false;
			try {
				result = member.getNameRange().getLength() <= 0 || member.getNameRange().equals(member.getSourceRange());
			} catch (JavaModelException e) {
				// better to assume it isn't generated
			}
			return result;
		}
		
		public static boolean isBlockedVisitorAndGenerated(org.eclipse.jdt.core.dom.ASTNode node, org.eclipse.jdt.core.dom.ASTVisitor visitor) {
			if (visitor == null) return false;
			
			String className = visitor.getClass().getName();
			if (!(className.startsWith(""org.eclipse.jdt.internal.corext.fix"") || className.startsWith(""org.eclipse.jdt.internal.ui.fix"") || className.startsWith(""org.eclipse.jdt.ls.core.internal.semantictokens.SemanticTokensVisitor""))) return false;
			if (className.equals(""org.eclipse.jdt.internal.corext.fix.VariableDeclarationFixCore$WrittenNamesFinder"")) return false;
			
			return isGenerated(node);
		}
		
		public static boolean isListRewriteOnGeneratedNode(org.eclipse.jdt.core.dom.rewrite.ListRewrite rewrite) {
			return isGenerated(rewrite.getParent());
		}
		
		public static boolean returnFalse(java.lang.Object object) {
			return false;
		}
		
		public static boolean returnTrue(java.lang.Object object) {
			return true;
		}
		
		@java.lang.SuppressWarnings({""unchecked"", ""rawtypes""}) public static java.util.List removeGeneratedNodes(java.util.List list) {
			try {
				java.util.List realNodes = new java.util.ArrayList(list.size());
				for (java.lang.Object node : list) {
					if(!isGenerated(((org.eclipse.jdt.core.dom.ASTNode)node))) {
						realNodes.add(node);
					}
				}
				return realNodes;
			} catch (Exception e) {
			}
			return list;
		}
		
		public static java.lang.String getRealMethodDeclarationSource(java.lang.String original, Object processor, org.eclipse.jdt.core.dom.MethodDeclaration declaration) throws Exception {
			if (!isGenerated(declaration)) return original;
			
			List<org.eclipse.jdt.core.dom.Annotation> annotations = new ArrayList<org.eclipse.jdt.core.dom.Annotation>();
			for (Object modifier : declaration.modifiers()) {
				if (modifier instanceof org.eclipse.jdt.core.dom.Annotation) {
					org.eclipse.jdt.core.dom.Annotation annotation = (org.eclipse.jdt.core.dom.Annotation)modifier;
					String qualifiedAnnotationName = annotation.resolveTypeBinding().getQualifiedName();
					if (!""java.lang.Override"".equals(qualifiedAnnotationName) && !""java.lang.SuppressWarnings"".equals(qualifiedAnnotationName)) annotations.add(annotation);
				}
			}
			
			StringBuilder signature = new StringBuilder();
			addAnnotations(annotations, signature);
			
			try {
				if ((Boolean)processor.getClass().getDeclaredField(""fPublic"").get(processor)) signature.append(""public "");
				if ((Boolean)processor.getClass().getDeclaredField(""fAbstract"").get(processor)) signature.append(""abstract "");
			} catch (Throwable t) { }
			
			signature
				.append(declaration.getReturnType2().toString())
				.append("" "").append(declaration.getName().getFullyQualifiedName())
				.append(""("");
			
			boolean first = true;
			for (Object parameter : declaration.parameters()) {
				if (!first) signature.append("", "");
				first = false;
				// We should also add the annotations of the parameters
				signature.append(parameter);
			}
			
			signature.append("");"");
			return signature.toString();
		}
		
		// part of getRealMethodDeclarationSource(...)
		public static void addAnnotations(List<org.eclipse.jdt.core.dom.Annotation> annotations, StringBuilder signature) {
			/*
			 * We SHOULD be able to handle the following cases:
			 * @Override
			 * @Override()
			 * @SuppressWarnings(""all"")
			 * @SuppressWarnings({""all"", ""unused""})
			 * @SuppressWarnings(value = ""all"")
			 * @SuppressWarnings(value = {""all"", ""unused""})
			 * @EqualsAndHashCode(callSuper=true, of=""id"")
			 * 
			 * Currently, we only seem to correctly support:
			 * @Override
			 * @Override() N.B. We lose the parentheses here, since there are no values. No big deal.
			 * @SuppressWarnings(""all"")
			 */
			for (org.eclipse.jdt.core.dom.Annotation annotation : annotations) {
				List<String> values = new ArrayList<String>();
				if (annotation.isSingleMemberAnnotation()) {
					org.eclipse.jdt.core.dom.SingleMemberAnnotation smAnn = (org.eclipse.jdt.core.dom.SingleMemberAnnotation) annotation;
					values.add(smAnn.getValue().toString());
				} else if (annotation.isNormalAnnotation()) {
					org.eclipse.jdt.core.dom.NormalAnnotation normalAnn = (org.eclipse.jdt.core.dom.NormalAnnotation) annotation;
					for (Object value : normalAnn.values()) values.add(value.toString());
				}
				
				signature.append(""@"").append(annotation.getTypeName().getFullyQualifiedName());
				if (!values.isEmpty()) {
					signature.append(""("");
					boolean first = true;
					for (String string : values) {
						if (!first) signature.append("", "");
						first = false;
						signature.append('""').append(string).append('""');
					}
					signature.append("")"");
				}
				signature.append("" "");
			}
		}
		
		public static org.eclipse.jdt.core.dom.MethodDeclaration getRealMethodDeclarationNode(org.eclipse.jdt.core.dom.MethodDeclaration original, org.eclipse.jdt.core.IMethod sourceMethod, org.eclipse.jdt.core.dom.CompilationUnit cuUnit) throws JavaModelException {
			if (!isGenerated(original)) return original;
			
			IType declaringType = sourceMethod.getDeclaringType();
			Stack<IType> typeStack = new Stack<IType>();
			while (declaringType != null) {
				typeStack.push(declaringType);
				declaringType = declaringType.getDeclaringType();
			}
			
			IType rootType = typeStack.pop();
			org.eclipse.jdt.core.dom.AbstractTypeDeclaration typeDeclaration = findTypeDeclaration(rootType, cuUnit.types());
			while (!typeStack.isEmpty() && typeDeclaration != null) {
				typeDeclaration = findTypeDeclaration(typeStack.pop(), typeDeclaration.bodyDeclarations());
			}
			
			String targetMethodName = sourceMethod.getElementName();
			List<String> targetMethodParameterTypes = new ArrayList<String>();
			for (String parameterType : sourceMethod.getParameterTypes()) {
				targetMethodParameterTypes.add(org.eclipse.jdt.core.Signature.toString(parameterType));
			}
			
			if (typeStack.isEmpty() && typeDeclaration != null) {
				for (Object declaration : typeDeclaration.bodyDeclarations()) {
					if (declaration instanceof org.eclipse.jdt.core.dom.MethodDeclaration) {
						org.eclipse.jdt.core.dom.MethodDeclaration methodDeclaration = (org.eclipse.jdt.core.dom.MethodDeclaration) declaration;
						
						if (!methodDeclaration.getName().toString().equals(targetMethodName)) continue;
						if (methodDeclaration.parameters().size() != targetMethodParameterTypes.size()) continue;
						if (!isGenerated(methodDeclaration)) continue;
						
						boolean parameterTypesEquals = true;
						for (int i = 0; i < methodDeclaration.parameters().size(); i++) {
							SingleVariableDeclaration variableDeclaration = (SingleVariableDeclaration) methodDeclaration.parameters().get(i);
							if (!variableDeclaration.getType().toString().equals(targetMethodParameterTypes.get(i))) {
								parameterTypesEquals = false;
								break;
							}
						}
						if (parameterTypesEquals) {
							return methodDeclaration;
						}
					}
				}
			}
			return original;
		}
		
		// part of getRealMethodDeclarationNode
		public static org.eclipse.jdt.core.dom.AbstractTypeDeclaration findTypeDeclaration(IType searchType, List<?> nodes) {
			for (Object object : nodes) {
				if (object instanceof org.eclipse.jdt.core.dom.AbstractTypeDeclaration) {
					org.eclipse.jdt.core.dom.AbstractTypeDeclaration typeDeclaration = (org.eclipse.jdt.core.dom.AbstractTypeDeclaration) object;
					if (typeDeclaration.getName().toString().equals(searchType.getElementName()))
						return typeDeclaration;
				}
			}
			return null;
		}
		
		public static int getSourceEndFixed(int sourceEnd, org.eclipse.jdt.internal.compiler.ast.ASTNode node) throws Exception {
			if (sourceEnd == -1) {
				org.eclipse.jdt.internal.compiler.ast.ASTNode object = (org.eclipse.jdt.internal.compiler.ast.ASTNode)node.getClass().getField(""$generatedBy"").get(node);
				if (object != null) {
					return object.sourceEnd;
				}
			}
			return sourceEnd;
		}
		
		public static int fixRetrieveStartingCatchPosition(int original, int start) {
			return original == -1 ? start : original;
		}
		
		public static int fixRetrieveIdentifierEndPosition(int original, int start, int end) {
			if (original == -1) return end;
			if (original < start) return end;
			return original;
		}
		
		public static int fixRetrieveEllipsisStartPosition(int original, int end) {
			return original == -1 ? end : original;
		}
		
		public static int fixRetrieveStartBlockPosition(int original, int start) {
			return original == -1 ? start : original;
		}
		
		public static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {
//			if (original == -1) {
//				Thread.dumpStack();
//			}
			 return original == -1 ? end : original;
		}
		
		public static int fixRetrieveRightBraceOrSemiColonPosition(int retVal, AbstractMethodDeclaration amd) {
			if (retVal != -1 || amd == null) return retVal;
			boolean isGenerated = ASTNode_generatedBy.get(amd) != null;
			if (isGenerated) return amd.declarationSourceEnd;
			return -1;
		}
		
		public static int fixRetrieveRightBraceOrSemiColonPosition(int retVal, FieldDeclaration fd) {
			if (retVal != -1 || fd == null) return retVal;
			boolean isGenerated = ASTNode_generatedBy.get(fd) != null;
			if (isGenerated) return fd.declarationSourceEnd;
			return -1;
		}
		
		public static int fixRetrieveProperRightBracketPosition(int retVal, Type type) {
			if (retVal != -1 || type == null) return retVal;
			if (isGenerated(type)) return type.getStartPosition() + type.getLength() - 1;
			return -1;
		}
		
		public static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24
		
		public static boolean checkBit24(Object node) throws Exception {
			int bits = (Integer)(node.getClass().getField(""bits"").get(node));
			return (bits & ALREADY_PROCESSED_FLAG) != 0;
		}
		
		public static boolean skipRewritingGeneratedNodes(org.eclipse.jdt.core.dom.ASTNode node) throws Exception {
			return ((Boolean) node.getClass().getField(""$isGenerated"").get(node)).booleanValue();
		}
		
		public static void setIsGeneratedFlag(org.eclipse.jdt.core.dom.ASTNode domNode,
				org.eclipse.jdt.internal.compiler.ast.ASTNode internalNode) throws Exception {
			
			if (internalNode == null || domNode == null) return;
			boolean isGenerated = ASTNode_generatedBy.get(internalNode) != null;
			if (isGenerated) domNode.getClass().getField(""$isGenerated"").set(domNode, true);
		}
		
		public static void setIsGeneratedFlagForName(org.eclipse.jdt.core.dom.Name name, Object internalNode) throws Exception {
			if (internalNode instanceof org.eclipse.jdt.internal.compiler.ast.ASTNode) {
				boolean isGenerated = ASTNode_generatedBy.get((org.eclipse.jdt.internal.compiler.ast.ASTNode) internalNode) != null;
				if (isGenerated) name.getClass().getField(""$isGenerated"").set(name, true);
			}
		}
		
		public static RewriteEvent[] listRewriteHandleGeneratedMethods(RewriteEvent parent) {
			RewriteEvent[] children = parent.getChildren();
			List<RewriteEvent> newChildren = new ArrayList<RewriteEvent>();
			List<RewriteEvent> modifiedChildren = new ArrayList<RewriteEvent>();
			for (int i = 0; i < children.length; i++) {
				RewriteEvent child = children[i];
				boolean isGenerated = isGenerated((org.eclipse.jdt.core.dom.ASTNode) child.getOriginalValue());
				if (isGenerated) {
					boolean isReplacedOrRemoved = child.getChangeKind() == RewriteEvent.REPLACED || child.getChangeKind() == RewriteEvent.REMOVED;
					boolean convertingFromMethod = child.getOriginalValue() instanceof org.eclipse.jdt.core.dom.MethodDeclaration;
					if (isReplacedOrRemoved && convertingFromMethod && child.getNewValue() != null) {
						modifiedChildren.add(new NodeRewriteEvent(null, child.getNewValue()));
					}
				} else {
					newChildren.add(child);
				}
			}
			// Since Eclipse doesn't honor the ""insert at specified location"" for already existing members,
			// we'll just add them last
			newChildren.addAll(modifiedChildren);
			return newChildren.toArray(new RewriteEvent[0]);
		}
		
		public static int getTokenEndOffsetFixed(TokenScanner scanner, int token, int startOffset, Object domNode) throws CoreException {
			boolean isGenerated = false;
			try {
				isGenerated = (Boolean) domNode.getClass().getField(""$isGenerated"").get(domNode);
			} catch (Exception e) {
				// If this fails, better to break some refactor scripts than to crash eclipse.
			}
			if (isGenerated) return -1;
			return scanner.getTokenEndOffset(token, startOffset);
		}
		
		public static IMethod[] removeGeneratedMethods(IMethod[] methods) throws Exception {
			List<IMethod> result = new ArrayList<IMethod>();
			for (IMethod m : methods) {
				if (!isGenerated(m)) result.add(m);
			}
			return result.size() == methods.length ? methods : result.toArray(new IMethod[0]);
		}
		
		public static SearchMatch[] removeGenerated(SearchMatch[] returnValue) {
			List<SearchMatch> result = new ArrayList<SearchMatch>();
			for (int j = 0; j < returnValue.length; j++) {
				SearchMatch searchResult = returnValue[j];
				if (searchResult.getElement() instanceof IField) {
					IField field = (IField) searchResult.getElement();
					
					// can not check for value=lombok because annotation is
					// not fully resolved
					IAnnotation annotation = field.getAnnotation(""Generated"");
					if (annotation != null) {
						// Method generated at field location, skip
						continue;
					}
					
				}
				result.add(searchResult);
			}
			return result.toArray(new SearchMatch[0]);
		}
		
		public static SearchResultGroup[] createFakeSearchResult(SearchResultGroup[] returnValue,
				Object/*
						 * org.eclipse.jdt.internal.corext.refactoring.rename.
						 * RenameFieldProcessor
						 */ processor) throws Exception {
			if (returnValue == null || returnValue.length == 0) {
				// if no matches were found, check if Data annotation is present on the class
				Field declaredField = processor.getClass().getDeclaredField(""fField"");
				if (declaredField != null) {
					declaredField.setAccessible(true);
					SourceField fField = (SourceField) declaredField.get(processor);
					IAnnotation dataAnnotation = fField.getDeclaringType().getAnnotation(""Data"");
					if (dataAnnotation != null) {
						// add fake item, to make refactoring checks pass
						return new SearchResultGroup[] {new SearchResultGroup(null, new SearchMatch[1])};
					}
				}
			}
			return returnValue;
		}
		
		public static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Exception {
			Field f = SimpleName.class.getField(""$isGenerated"");
			
			int count = 0;
			for (int i = 0; i < in.length; i++) {
				if (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) count++;
			}
			if (count == in.length) return in;
			SimpleName[] newSimpleNames = new SimpleName[count];
			count = 0;
			for (int i = 0; i < in.length; i++) {
				if (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) newSimpleNames[count++] = in[i];
			}
			return newSimpleNames;
		}
		
		public static Annotation[] convertAnnotations(Annotation[] out, IAnnotatable annotatable) {
			IAnnotation[] in;
			
			try {
				in = annotatable.getAnnotations();
			} catch (Exception e) {
				return out;
			}
			
			if (out == null) return null;
			int toWrite = 0;
			
			for (int idx = 0; idx < out.length; idx++) {
				String oName = new String(out[idx].type.getLastToken());
				boolean found = false;
				for (IAnnotation i : in) {
					String name = i.getElementName();
					int li = name.lastIndexOf('.');
					if (li > -1) name = name.substring(li + 1);
					if (name.equals(oName)) {
						found = true;
						break;
					}
				}
				if (!found) out[idx] = null;
				else toWrite++;
			}
			
			Annotation[] replace = out;
			if (toWrite < out.length) {
				replace = new Annotation[toWrite];
				int idx = 0;
				for (int i = 0; i < out.length; i++) {
					if (out[i] == null) continue;
					replace[idx++] = out[i];
				}
			}
			
			return replace;
		}
		
		public static String getRealNodeSource(String original, org.eclipse.jdt.internal.compiler.ast.ASTNode node) {
			if (!isGenerated(node)) return original;
			
			return node.toString();
		}
		
		public static java.lang.String getRealNodeSource(java.lang.String original, org.eclipse.jdt.core.dom.ASTNode node) throws Exception {
			if (!isGenerated(node)) return original;
			
			return node.toString();
		}
		
		public static boolean skipRewriteVisibility(IncomingMemberVisibilityAdjustment adjustment) {
			return isGenerated(adjustment.getMember());
		}
	}",1,439 457 381 334 2000 123 439 457 324 2001 40 2002 46 2003 46 2004 46 2005 46 2006 46 2007 2008 41 123 324 2009 61 380 59 474 123 2009 61 40 40 2010 41 2008 46 2011 40 41 46 2012 40 648 41 46 2013 40 2008 41 41 46 2014 40 41 59 392 40 33 2009 605 2008 46 2015 40 41 631 424 605 2008 46 2015 40 41 402 2002 46 2003 46 2004 46 2005 46 2006 46 2016 41 123 2009 61 2001 40 2008 46 2015 40 41 41 59 125 125 329 40 2017 2018 41 123 621 125 450 2009 59 125 439 457 324 2001 40 2002 46 2003 46 2004 46 406 46 2019 46 2020 46 2007 2008 41 123 324 2021 61 380 59 474 123 2021 61 2008 46 2022 40 41 46 2023 40 648 41 46 2024 40 2008 41 631 424 59 125 329 40 2025 2026 41 123 621 125 450 2021 59 125 439 457 324 2001 40 2002 46 2003 46 2004 46 2005 46 2027 2028 41 123 324 2029 61 380 59 474 123 2029 61 2028 46 2030 40 41 46 2031 40 41 620 1500 606 2028 46 2030 40 41 46 2032 40 2028 46 2033 40 41 41 59 125 329 40 2034 2035 41 123 621 125 450 2029 59 125 439 457 324 2036 40 2002 46 2003 46 2004 46 2005 46 2006 46 2007 2008 44 2002 46 2003 46 2004 46 2005 46 2006 46 2037 2038 41 123 392 40 2038 614 424 41 450 380 59 2039 2040 61 2038 46 2041 40 41 46 2042 40 41 59 392 40 33 40 2040 46 2043 40 648 41 606 2040 46 2043 40 648 41 606 2040 46 2043 40 648 41 41 41 450 380 59 392 40 2040 46 2044 40 648 41 41 450 380 59 450 2001 40 2008 41 59 125 439 457 324 2045 40 2002 46 2003 46 2004 46 2005 46 2006 46 2046 46 2047 2046 41 123 450 2001 40 2046 46 2048 40 41 41 59 125 439 457 324 2049 40 2050 46 2051 46 2052 426 41 123 450 380 59 125 439 457 324 2053 40 2050 46 2051 46 2052 426 41 123 450 473 59 125 64 2050 46 2051 46 2054 40 123 648 44 648 125 41 439 457 2050 46 2055 46 2056 2057 40 2050 46 2055 46 2056 411 41 123 474 123 2050 46 2055 46 2056 2058 61 418 2050 46 2055 46 2059 40 411 46 2060 40 41 41 59 385 40 2050 46 2051 46 2052 2008 58 411 41 123 392 40 33 2001 40 40 40 2002 46 2003 46 2004 46 2005 46 2006 46 2007 41 2008 41 41 41 123 2058 46 2061 40 2008 41 59 125 125 450 2058 59 125 329 40 2062 2063 41 123 125 450 411 59 125 439 457 2050 46 2051 46 2064 2065 40 2050 46 2051 46 2064 2066 44 2052 2067 44 2002 46 2003 46 2004 46 2005 46 2006 46 2068 2069 41 470 2070 123 392 40 33 2001 40 2069 41 41 450 2066 59 2056 60 2002 46 2003 46 2004 46 2005 46 2006 46 2071 62 2072 61 418 2073 60 2002 46 2003 46 2004 46 2005 46 2006 46 2071 62 40 41 59 385 40 2052 2074 58 2069 46 2075 40 41 41 123 392 40 2074 402 2002 46 2003 46 2004 46 2005 46 2006 46 2071 41 123 2002 46 2003 46 2004 46 2005 46 2006 46 2071 2076 61 40 2002 46 2003 46 2004 46 2005 46 2006 46 2071 41 2074 59 2064 2077 61 2076 46 2078 40 41 46 2079 40 41 59 392 40 33 648 46 2080 40 2077 41 605 33 648 46 2080 40 2077 41 41 2072 46 2081 40 2076 41 59 125 125 2082 2083 61 418 2082 40 41 59 2084 40 2072 44 2083 41 59 474 123 392 40 40 2085 41 2067 46 2086 40 41 46 2087 40 648 41 46 2088 40 2067 41 41 2083 46 2089 40 648 41 59 392 40 40 2085 41 2067 46 2086 40 41 46 2087 40 648 41 46 2088 40 2067 41 41 2083 46 2089 40 648 41 59 125 329 40 2090 2091 41 123 125 2083 46 2092 40 2069 46 2093 40 41 46 2094 40 41 41 46 2092 40 648 41 46 2092 40 2069 46 2095 40 41 46 2096 40 41 41 46 2092 40 648 41 59 324 2097 61 473 59 385 40 2052 2098 58 2069 46 2099 40 41 41 123 392 40 33 2097 41 2083 46 2092 40 648 41 59 2097 61 380 59 621 2083 46 2092 40 2098 41 59 125 2083 46 2092 40 648 41 59 450 2083 46 2094 40 41 59 125 621 439 457 492 2100 40 2056 60 2002 46 2003 46 2004 46 2005 46 2006 46 2101 62 2102 44 2103 2104 41 123 604 385 40 2002 46 2003 46 2004 46 2005 46 2006 46 2101 2105 58 2102 41 123 2056 60 2064 62 2106 61 418 2107 60 2064 62 40 41 59 392 40 2105 46 2108 40 41 41 123 2002 46 2003 46 2004 46 2005 46 2006 46 2109 2110 61 40 2002 46 2003 46 2004 46 2005 46 2006 46 2109 41 2105 59 2106 46 2111 40 2110 46 2112 40 41 46 2113 40 41 41 59 125 360 392 40 2105 46 2114 40 41 41 123 2002 46 2003 46 2004 46 2005 46 2006 46 2115 2116 61 40 2002 46 2003 46 2004 46 2005 46 2006 46 2115 41 2105 59 385 40 2052 2117 58 2116 46 2106 40 41 41 2106 46 2118 40 2117 46 2119 40 41 41 59 125 2104 46 2120 40 648 41 46 2120 40 2105 46 2121 40 41 46 2122 40 41 41 59 392 40 33 2106 46 2123 40 41 41 123 2104 46 2120 40 648 41 59 324 2124 61 473 59 385 40 2064 461 58 2106 41 123 392 40 33 2124 41 2104 46 2120 40 648 41 59 2124 61 380 59 2104 46 2120 40 607 41 46 2120 40 461 41 46 2120 40 607 41 59 125 2104 46 2120 40 648 41 59 125 2104 46 2120 40 648 41 59 125 125 439 457 2002 46 2003 46 2004 46 2005 46 2006 46 2068 2125 40 2002 46 2003 46 2004 46 2005 46 2006 46 2068 2066 44 2002 46 2003 46 2004 46 2005 46 2126 2127 44 2002 46 2003 46 2004 46 2005 46 2006 46 2128 2129 41 470 2130 123 392 40 33 2001 40 2066 41 41 450 2066 59 2131 2132 61 2127 46 2133 40 41 59 2134 60 2131 62 2135 61 418 2134 60 2131 62 40 41 59 496 40 2132 631 424 41 123 2135 46 2136 40 2132 41 59 2132 61 2132 46 2133 40 41 59 125 2131 2137 61 2135 46 2138 40 41 59 2002 46 2003 46 2004 46 2005 46 2006 46 2139 2140 61 2141 40 2137 44 2129 46 2142 40 41 41 59 496 40 33 2135 46 2143 40 41 605 2140 631 424 41 123 2140 61 2141 40 2135 46 2138 40 41 44 2140 46 2144 40 41 41 59 125 2064 2145 61 2127 46 2146 40 41 59 2056 60 2064 62 2147 61 418 2148 60 2064 62 40 41 59 385 40 2064 2149 58 2127 46 2150 40 41 41 123 2147 46 2151 40 2002 46 2003 46 2004 46 2005 46 2152 46 2153 40 2149 41 41 59 125 392 40 2135 46 2143 40 41 605 2140 631 424 41 123 385 40 2052 2069 58 2140 46 2154 40 41 41 123 392 40 2069 402 2002 46 2003 46 2004 46 2005 46 2006 46 2068 41 123 2002 46 2003 46 2004 46 2005 46 2006 46 2068 2155 61 40 2002 46 2003 46 2004 46 2005 46 2006 46 2068 41 2069 59 392 40 33 2155 46 2156 40 41 46 2157 40 41 46 2158 40 2145 41 41 344 59 392 40 2155 46 2159 40 41 46 2160 40 41 631 2147 46 2160 40 41 41 344 59 392 40 33 2001 40 2155 41 41 344 59 324 2161 61 473 59 385 40 404 2162 61 1500 59 2162 60 2155 46 2159 40 41 46 2160 40 41 59 2162 637 41 123 2163 2164 61 40 2163 41 2155 46 2159 40 41 46 2165 40 2162 41 59 392 40 33 2164 46 2166 40 41 46 2157 40 41 46 2158 40 2147 46 2165 40 2162 41 41 41 123 2161 61 380 59 325 59 125 125 392 40 2161 41 123 450 2155 59 125 125 125 125 450 2066 59 125 621 439 457 2002 46 2003 46 2004 46 2005 46 2006 46 2167 2168 40 2169 2170 44 2056 60 63 62 2171 41 123 385 40 2052 426 58 2171 41 123 392 40 426 402 2002 46 2003 46 2004 46 2005 46 2006 46 2167 41 123 2002 46 2003 46 2004 46 2005 46 2006 46 2167 2172 61 40 2002 46 2003 46 2004 46 2005 46 2006 46 2167 41 426 59 392 40 2172 46 2173 40 41 46 2174 40 41 46 2175 40 2170 46 2176 40 41 41 41 450 2172 59 125 125 450 424 59 125 439 457 404 2177 40 404 2178 44 2002 46 2003 46 2004 46 406 46 2019 46 2020 46 2007 2008 41 470 2070 123 392 40 2178 614 45 1501 41 123 2002 46 2003 46 2004 46 406 46 2019 46 2020 46 2007 426 61 40 2002 46 2003 46 2004 46 406 46 2019 46 2020 46 2007 41 2008 46 2179 40 41 46 2180 40 648 41 46 2181 40 2008 41 59 392 40 426 631 424 41 123 450 426 46 2178 59 125 125 450 2178 59 125 439 457 404 2182 40 404 2066 44 404 2183 41 123 450 2066 614 45 1501 63 2183 58 2066 59 125 439 457 404 2184 40 404 2066 44 404 2183 44 404 2185 41 123 392 40 2066 614 45 1501 41 450 2185 59 392 40 2066 60 2183 41 450 2185 59 450 2066 59 125 439 457 404 2186 40 404 2066 44 404 2185 41 123 450 2066 614 45 1501 63 2185 58 2066 59 125 439 457 404 2187 40 404 2066 44 404 2183 41 123 450 2066 614 45 1501 63 2183 58 2066 59 125 439 457 404 2188 40 404 2066 44 404 2185 41 123 621 621 621 450 2066 614 45 1501 63 2185 58 2066 59 125 439 457 404 2188 40 404 2189 44 2190 2191 41 123 392 40 2189 631 45 1501 606 2191 614 424 41 450 2189 59 324 2001 61 2192 46 2193 40 2191 41 631 424 59 392 40 2001 41 450 2191 46 2194 59 450 45 1501 59 125 439 457 404 2188 40 404 2189 44 2195 2196 41 123 392 40 2189 631 45 1501 606 2196 614 424 41 450 2189 59 324 2001 61 2197 46 2198 40 2196 41 631 424 59 392 40 2001 41 450 2196 46 2199 59 450 45 1501 59 125 439 457 404 2200 40 404 2189 44 2201 2202 41 123 392 40 2189 631 45 1501 606 2202 614 424 41 450 2189 59 392 40 2001 40 2202 41 41 450 2202 46 2203 40 41 43 2202 46 2204 40 41 45 1501 59 450 45 1501 59 125 439 457 381 404 2205 61 1508 59 621 439 457 324 2206 40 2052 2008 41 470 2070 123 404 2207 61 40 2208 41 40 2008 46 2209 40 41 46 2210 40 648 41 46 2211 40 2008 41 41 59 450 40 2207 38 2205 41 631 1500 59 125 439 457 324 2212 40 2002 46 2003 46 2004 46 2005 46 2006 46 2007 2008 41 470 2070 123 450 40 40 2213 41 2008 46 2214 40 41 46 2215 40 648 41 46 2216 40 2008 41 41 46 2217 40 41 59 125 439 457 492 2218 40 2002 46 2003 46 2004 46 2005 46 2006 46 2007 2219 44 2002 46 2003 46 2004 46 406 46 2019 46 2020 46 2007 2220 41 470 2070 123 392 40 2220 614 424 606 2219 614 424 41 450 59 324 2001 61 2221 46 2222 40 2220 41 631 424 59 392 40 2001 41 2219 46 2223 40 41 46 2224 40 648 41 46 2225 40 2219 44 473 41 59 125 439 457 492 2226 40 2002 46 2003 46 2004 46 2005 46 2006 46 2227 2228 44 2052 2220 41 470 2070 123 392 40 2220 402 2002 46 2003 46 2004 46 406 46 2019 46 2020 46 2007 41 123 324 2001 61 2229 46 2230 40 40 2002 46 2003 46 2004 46 406 46 2019 46 2020 46 2007 41 2220 41 631 424 59 392 40 2001 41 2228 46 2231 40 41 46 2232 40 648 41 46 2233 40 2228 44 473 41 59 125 125 439 457 2234 91 93 2235 40 2234 2236 41 123 2234 91 93 2237 61 2236 46 2238 40 41 59 2056 60 2234 62 2239 61 418 2240 60 2234 62 40 41 59 2056 60 2234 62 2241 61 418 2240 60 2234 62 40 41 59 385 40 404 2242 61 1500 59 2242 60 2237 46 2243 59 2242 637 41 123 2234 2244 61 2237 91 2242 93 59 324 2001 61 2001 40 40 2002 46 2003 46 2004 46 2005 46 2006 46 2007 41 2244 46 2245 40 41 41 59 392 40 2001 41 123 324 2246 61 2244 46 2247 40 41 614 2234 46 2248 606 2244 46 2247 40 41 614 2234 46 2249 59 324 2250 61 2244 46 2245 40 41 402 2002 46 2003 46 2004 46 2005 46 2006 46 2068 59 392 40 2246 605 2250 605 2244 46 2251 40 41 631 424 41 123 2241 46 2252 40 418 2253 40 424 44 2244 46 2251 40 41 41 41 59 125 125 360 123 2239 46 2254 40 2244 41 59 125 125 621 621 2239 46 2255 40 2241 41 59 450 2239 46 2256 40 418 2234 91 1500 93 41 59 125 439 457 404 2257 40 2258 2259 44 404 2260 44 404 2261 44 2052 2219 41 470 2262 123 324 2001 61 380 59 474 123 2001 61 40 2263 41 2219 46 2264 40 41 46 2265 40 648 41 46 2266 40 2219 41 59 125 329 40 2070 2267 41 123 621 125 392 40 2001 41 450 45 1501 59 450 2259 46 2268 40 2260 44 2261 41 59 125 439 457 2126 91 93 2269 40 2126 91 93 2270 41 470 2070 123 2056 60 2126 62 2271 61 418 2272 60 2126 62 40 41 59 385 40 2126 2273 58 2270 41 123 392 40 33 2001 40 2273 41 41 2271 46 2274 40 2273 41 59 125 450 2271 46 2275 40 41 614 2270 46 2276 63 2270 58 2271 46 2277 40 418 2126 91 1500 93 41 59 125 439 457 2278 91 93 2279 40 2278 91 93 2280 41 123 2056 60 2278 62 2281 61 418 2282 60 2278 62 40 41 59 385 40 404 2283 61 1500 59 2283 60 2280 46 2284 59 2283 637 41 123 2278 2285 61 2280 91 2283 93 59 392 40 2285 46 2286 40 41 402 2287 41 123 2287 2288 61 40 2287 41 2285 46 2286 40 41 59 621 621 2289 2290 61 2288 46 2291 40 648 41 59 392 40 2290 631 424 41 123 621 344 59 125 125 2281 46 2292 40 2285 41 59 125 450 2281 46 2293 40 418 2278 91 1500 93 41 59 125 439 457 2294 91 93 2295 40 2294 91 93 2280 44 2052 604 2067 41 470 2070 123 392 40 2280 614 424 606 2280 46 2296 614 1500 41 123 621 2297 2298 61 2067 46 2299 40 41 46 2300 40 648 41 59 392 40 2298 631 424 41 123 2298 46 2301 40 473 41 59 2302 2303 61 40 2302 41 2298 46 2304 40 2067 41 59 2305 2306 61 2303 46 2307 40 41 46 2308 40 648 41 59 392 40 2306 631 424 41 123 621 450 418 2294 91 93 123 418 2294 40 424 44 418 2278 91 1501 93 41 125 59 125 125 125 450 2280 59 125 439 457 2309 91 93 2310 40 2309 91 93 398 41 470 2070 123 2311 2312 61 2309 46 334 46 2313 40 648 41 59 404 2314 61 1500 59 385 40 404 2315 61 1500 59 2315 60 398 46 2316 59 2315 637 41 123 392 40 398 91 2315 93 614 424 606 33 40 40 2317 41 2312 46 2318 40 398 91 2315 93 41 41 46 2319 40 41 41 2314 637 59 125 392 40 2314 614 398 46 2316 41 450 398 59 2309 91 93 2320 61 418 2309 91 2314 93 59 2314 61 1500 59 385 40 404 2315 61 1500 59 2315 60 398 46 2316 59 2315 637 41 123 392 40 398 91 2315 93 614 424 606 33 40 40 2321 41 2312 46 2322 40 398 91 2315 93 41 41 46 2323 40 41 41 2320 91 2314 637 93 61 398 91 2315 93 59 125 450 2320 59 125 439 457 2101 91 93 2324 40 2101 91 93 430 44 2325 2326 41 123 2327 91 93 398 59 474 123 398 61 2326 46 2328 40 41 59 125 329 40 2070 2329 41 123 450 430 59 125 392 40 430 614 424 41 450 424 59 404 2330 61 1500 59 385 40 404 2331 61 1500 59 2331 60 430 46 2332 59 2331 637 41 123 2064 2333 61 418 2064 40 430 91 2331 93 46 2202 46 2334 40 41 41 59 324 2335 61 380 59 385 40 2327 2336 58 398 41 123 2064 2228 61 2336 46 2337 40 41 59 404 2338 61 2228 46 2339 40 607 41 59 392 40 2338 62 45 1501 41 2228 61 2228 46 2340 40 2338 43 1501 41 59 392 40 2228 46 2341 40 2333 41 41 123 2335 61 473 59 325 59 125 125 392 40 33 2335 41 430 91 2331 93 61 424 59 360 2330 637 59 125 2101 91 93 2342 61 430 59 392 40 2330 60 430 46 2332 41 123 2342 61 418 2101 91 2330 93 59 404 2331 61 1500 59 385 40 404 2343 61 1500 59 2343 60 430 46 2332 59 2343 637 41 123 392 40 430 91 2343 93 614 424 41 344 59 2342 91 2331 637 93 61 430 91 2343 93 59 125 125 450 2342 59 125 439 457 2064 2344 40 2064 2066 44 2002 46 2003 46 2004 46 406 46 2019 46 2020 46 2007 2008 41 123 392 40 33 2001 40 2008 41 41 450 2066 59 450 2008 46 2345 40 41 59 125 439 457 2050 46 2051 46 2064 2344 40 2050 46 2051 46 2064 2066 44 2002 46 2003 46 2004 46 2005 46 2006 46 2007 2008 41 470 2070 123 392 40 33 2001 40 2008 41 41 450 2066 59 450 2008 46 2346 40 41 59 125 439 457 324 2347 40 2348 2349 41 123 450 2001 40 2349 46 2350 40 41 41 59 125 125 
29961,Java,"@Provides
@HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
public class HandleBuilder extends JavacAnnotationHandler<Builder> {
	private HandleConstructor handleConstructor = new HandleConstructor();
	
	static final String CLEAN_FIELD_NAME = ""$lombokUnclean"";
	static final String CLEAN_METHOD_NAME = ""$lombokClean"";
	static final String TO_BUILDER_METHOD_NAME = ""toBuilder"";
	static final String DEFAULT_PREFIX = ""$default$"";
	static final String SET_PREFIX = ""$set"";
	static final String VALUE_PREFIX = ""$value"";
	static final String BUILDER_TEMP_VAR = ""builder"";
	static final String TO_BUILDER_NOT_SUPPORTED = ""@Builder(toBuilder=true) is only supported if you return your own type."";
	
	private static final boolean toBoolean(Object expr, boolean defaultValue) {
		if (expr == null) return defaultValue;
		if (expr instanceof JCLiteral) return ((Integer) ((JCLiteral) expr).value) != 0;
		return ((Boolean) expr).booleanValue();
	}
	
	static class BuilderJob {
		CheckerFrameworkVersion checkerFramework;
		JavacNode parentType;
		String builderMethodName, buildMethodName;
		boolean isStatic;
		List<JCTypeParameter> typeParams;
		List<JCTypeParameter> builderTypeParams;
		JavacNode sourceNode;
		java.util.List<BuilderFieldData> builderFields;
		AccessLevel accessInners, accessOuters;
		boolean oldFluent, oldChain, toBuilder;
		
		JavacNode builderType;
		String builderClassName;
		
		void init(AnnotationValues<Builder> annValues, Builder ann, JavacNode node) {
			accessOuters = ann.access();
			if (accessOuters == null) accessOuters = AccessLevel.PUBLIC;
			if (accessOuters == AccessLevel.NONE) {
				sourceNode.addError(""AccessLevel.NONE is not valid here"");
				accessOuters = AccessLevel.PUBLIC;
			}
			accessInners = accessOuters == AccessLevel.PROTECTED ? AccessLevel.PUBLIC : accessOuters;
			
			oldFluent = toBoolean(annValues.getActualExpression(""fluent""), true);
			oldChain = toBoolean(annValues.getActualExpression(""chain""), true);
			
			builderMethodName = ann.builderMethodName();
			buildMethodName = ann.buildMethodName();
			builderClassName = getBuilderClassNameTemplate(node, ann.builderClassName());
			toBuilder = ann.toBuilder();
			
			if (builderMethodName == null) builderMethodName = ""builder"";
			if (buildMethodName == null) buildMethodName = ""build"";
			if (builderClassName == null) builderClassName = """";
		}
		
		static String getBuilderClassNameTemplate(JavacNode node, String override) {
			if (override != null && !override.isEmpty()) return override;
			override = node.getAst().readConfiguration(ConfigurationKeys.BUILDER_CLASS_NAME);
			if (override != null && !override.isEmpty()) return override;
			return ""*Builder"";
		}
		
		String replaceBuilderClassName(Name name) {
			return replaceBuilderClassName(name.toString(), builderClassName);
		}
		
		String replaceBuilderClassName(String name, String template) {
			if (template.indexOf('*') == -1) return template;
			return template.replace(""*"", name);
		}
		
		JCExpression createBuilderParentTypeReference() {
			return namePlusTypeParamsToTypeReference(parentType.getTreeMaker(), parentType, typeParams);
		}
		
		Name getBuilderClassName() {
			return parentType.toName(builderClassName);
		}
		
		List<JCTypeParameter> copyTypeParams() {
			return JavacHandlerUtil.copyTypeParams(sourceNode, typeParams);
		}
		
		Name toName(String name) {
			return parentType.toName(name);
		}
		
		Context getContext() {
			return parentType.getContext();
		}
		
		JavacTreeMaker getTreeMaker() {
			return parentType.getTreeMaker();
		}
	}
	
	static class BuilderFieldData {
		List<JCAnnotation> annotations;
		JCExpression type;
		Name rawName;
		Name name;
		Name builderFieldName;
		Name nameOfDefaultProvider;
		Name nameOfSetFlag;
		SingularData singularData;
		ObtainVia obtainVia;
		JavacNode obtainViaNode;
		JavacNode originalFieldNode;
		
		java.util.List<JavacNode> createdFields = new ArrayList<JavacNode>();
	}
	
	@Override public void handle(AnnotationValues<Builder> annotation, JCAnnotation ast, JavacNode annotationNode) {
		final String BUILDER_NODE_NOT_SUPPORTED_ERR = ""@Builder is only supported on classes, records, constructors, and methods."";
		
		handleFlagUsage(annotationNode, ConfigurationKeys.BUILDER_FLAG_USAGE, ""@Builder"");
		BuilderJob job = new BuilderJob();
		job.sourceNode = annotationNode;
		job.checkerFramework = getCheckerFrameworkVersion(annotationNode);
		job.isStatic = true;
		
		Builder annInstance = annotation.getInstance();
		job.init(annotation, annInstance, annotationNode);
		java.util.List<Name> typeArgsForToBuilder = null;
		
		boolean generateBuilderMethod;
		if (job.builderMethodName.isEmpty()) {
			generateBuilderMethod = false;
		} else if (!checkName(""builderMethodName"", job.builderMethodName, annotationNode)) {
			return;
		} else {
			generateBuilderMethod = true;
		}
		
		if (!checkName(""buildMethodName"", job.buildMethodName, annotationNode)) return;
		
		// Do not delete the Builder annotation yet, we need it for @Jacksonized.
		
		JavacNode parent = annotationNode.up();
		
		job.builderFields = new ArrayList<BuilderFieldData>();
		JCExpression buildMethodReturnType;
		job.typeParams = List.nil();
		List<JCExpression> buildMethodThrownExceptions;
		Name nameOfBuilderMethod;
		
		JavacNode fillParametersFrom = parent.get() instanceof JCMethodDecl ? parent : null;
		boolean addCleaning = false;
		
		ArrayList<JavacNode> nonFinalNonDefaultedFields = null;
		
		if (!isStaticAllowed(upToTypeNode(parent))) {
			annotationNode.addError(""@Builder is not supported on non-static nested classes."");
			return;
		}
		
		if (parent.get() instanceof JCClassDecl) {
			if (!isClass(parent) && !isRecord(parent)) {
				annotationNode.addError(BUILDER_NODE_NOT_SUPPORTED_ERR);
				return;
			}
			
			job.parentType = parent;
			JCClassDecl td = (JCClassDecl) parent.get();
			
			ListBuffer<JavacNode> allFields = new ListBuffer<JavacNode>();
			boolean valuePresent = (hasAnnotation(lombok.Value.class, parent) || hasAnnotation(""lombok.experimental.Value"", parent));
			for (JavacNode fieldNode : HandleConstructor.findAllFields(parent, true)) {
				JCVariableDecl fd = (JCVariableDecl) fieldNode.get();
				JavacNode isDefault = findAnnotation(Builder.Default.class, fieldNode, false);
				boolean isFinal = (fd.mods.flags & Flags.FINAL) != 0 || (valuePresent && !hasAnnotation(NonFinal.class, fieldNode));
				
				BuilderFieldData bfd = new BuilderFieldData();
				bfd.rawName = fd.name;
				bfd.name = removePrefixFromField(fieldNode);
				bfd.builderFieldName = bfd.name;
				bfd.annotations = findCopyableAnnotations(fieldNode);
				bfd.type = fd.vartype;
				bfd.singularData = getSingularData(fieldNode, annInstance.setterPrefix());
				bfd.originalFieldNode = fieldNode;
				
				if (bfd.singularData != null && isDefault != null) {
					isDefault.addError(""@Builder.Default and @Singular cannot be mixed."");
					findAnnotation(Builder.Default.class, fieldNode, true);
					isDefault = null;
				}
				
				if (fd.init == null && isDefault != null) {
					isDefault.addWarning(""@Builder.Default requires an initializing expression (' = something;')."");
					findAnnotation(Builder.Default.class, fieldNode, true);
					isDefault = null;
				}
				
				if (fd.init != null && isDefault == null) {
					if (isFinal) continue;
					if (nonFinalNonDefaultedFields == null) nonFinalNonDefaultedFields = new ArrayList<JavacNode>();
					nonFinalNonDefaultedFields.add(fieldNode);
				}
				
				if (isDefault != null) {
					bfd.nameOfDefaultProvider = parent.toName(DEFAULT_PREFIX + bfd.name);
					bfd.nameOfSetFlag = parent.toName(bfd.name + SET_PREFIX);
					bfd.builderFieldName = parent.toName(bfd.name + VALUE_PREFIX);
					JCMethodDecl md = generateDefaultProvider(bfd.nameOfDefaultProvider, fieldNode, td.typarams, job);
					if (md != null) injectMethod(parent, md);
				}
				addObtainVia(bfd, fieldNode);
				job.builderFields.add(bfd);
				allFields.append(fieldNode);
			}
			
			if (!isRecord(parent)) {
				// Records ship with a canonical constructor that acts as @AllArgsConstructor - just use that one.
				
				handleConstructor.generateConstructor(parent, AccessLevel.PACKAGE, List.<JCAnnotation>nil(), allFields.toList(), false, null, SkipIfConstructorExists.I_AM_BUILDER, annotationNode);
			}
			
			buildMethodReturnType = namePlusTypeParamsToTypeReference(parent.getTreeMaker(), parent, td.typarams);
			job.typeParams = job.builderTypeParams = td.typarams;
			buildMethodThrownExceptions = List.nil();
			nameOfBuilderMethod = null;
			job.builderClassName = job.replaceBuilderClassName(td.name);
			if (!checkName(""builderClassName"", job.builderClassName, annotationNode)) return;
		} else if (fillParametersFrom != null && fillParametersFrom.getName().toString().equals(""<init>"")) {
			JCMethodDecl jmd = (JCMethodDecl) fillParametersFrom.get();
			if (!jmd.typarams.isEmpty()) {
				annotationNode.addError(""@Builder is not supported on constructors with constructor type parameters."");
				return;
			}
			
			job.parentType = parent.up();
			JCClassDecl td = (JCClassDecl) job.parentType.get();
			job.typeParams = job.builderTypeParams = td.typarams;
			buildMethodReturnType = job.createBuilderParentTypeReference();
			buildMethodThrownExceptions = jmd.thrown;
			nameOfBuilderMethod = null;
			job.builderClassName = job.replaceBuilderClassName(td.name);
			if (!checkName(""builderClassName"", job.builderClassName, annotationNode)) return;
		} else if (fillParametersFrom != null) {
			job.parentType = parent.up();
			JCClassDecl td = (JCClassDecl) job.parentType.get();
			JCMethodDecl jmd = (JCMethodDecl) fillParametersFrom.get();
			job.isStatic = (jmd.mods.flags & Flags.STATIC) != 0;
			
			JCExpression fullReturnType = jmd.restype;
			buildMethodReturnType = fullReturnType;
			job.typeParams = job.builderTypeParams = jmd.typarams;
			buildMethodThrownExceptions = jmd.thrown;
			nameOfBuilderMethod = jmd.name;
			if (buildMethodReturnType instanceof JCTypeApply) {
				buildMethodReturnType = cloneType(job.getTreeMaker(), buildMethodReturnType, annotationNode);
			}
			if (job.builderClassName.indexOf('*') > -1) {
				String replStr = returnTypeToBuilderClassName(annotationNode, td, buildMethodReturnType, job.typeParams);
				if (replStr == null) return; // shuold not happen
				job.builderClassName = job.builderClassName.replace(""*"", replStr);
			}
			if (job.toBuilder) {
				if (fullReturnType instanceof JCArrayTypeTree) {
					annotationNode.addError(TO_BUILDER_NOT_SUPPORTED);
					return;
				}
				
				Name simpleName;
				String pkg;
				List<JCExpression> tpOnRet = List.nil();
				
				if (fullReturnType instanceof JCTypeApply) {
					tpOnRet = ((JCTypeApply) fullReturnType).arguments;
				}
				
				JCExpression namingType = fullReturnType;
				if (buildMethodReturnType instanceof JCTypeApply) namingType = ((JCTypeApply) buildMethodReturnType).clazz;
				
				if (namingType instanceof JCIdent) {
					simpleName = ((JCIdent) namingType).name;
					pkg = null;
				} else if (namingType instanceof JCFieldAccess) {
					JCFieldAccess jcfa = (JCFieldAccess) namingType;
					simpleName = jcfa.name;
					pkg = unpack(jcfa.selected);
					if (pkg.startsWith(""ERR:"")) {
						String err = pkg.substring(4, pkg.indexOf(""__ERR__""));
						annotationNode.addError(err);
						return;
					}
				} else {
					annotationNode.addError(""Expected a (parameterized) type here instead of a "" + namingType.getClass().getName());
					return;
				}
				
				if (pkg != null && !parent.getPackageDeclaration().equals(pkg)) {
					annotationNode.addError(TO_BUILDER_NOT_SUPPORTED);
					return;
				}
				
				if (!job.parentType.getName().contentEquals(simpleName)) {
					annotationNode.addError(TO_BUILDER_NOT_SUPPORTED);
					return;
				}
				
				List<JCTypeParameter> tpOnMethod = jmd.typarams;
				List<JCTypeParameter> tpOnType = ((JCClassDecl) job.parentType.get()).typarams;
				typeArgsForToBuilder = new ArrayList<Name>();
				
				for (JCTypeParameter tp : tpOnMethod) {
					int pos = -1;
					int idx = -1;
					for (JCExpression tOnRet : tpOnRet) {
						idx++;
						if (!(tOnRet instanceof JCIdent)) continue;
						if (((JCIdent) tOnRet).name != tp.name) continue;
						pos = idx;
					}
					
					if (pos == -1 || tpOnType.size() <= pos) {
						annotationNode.addError(""@Builder(toBuilder=true) requires that each type parameter on the static method is part of the typeargs of the return value. Type parameter "" + tp.name + "" is not part of the return type."");
						return;
					}
					typeArgsForToBuilder.add(tpOnType.get(pos).name);
				}
			}
		} else {
			annotationNode.addError(BUILDER_NODE_NOT_SUPPORTED_ERR);
			return;
		}
		
		if (fillParametersFrom != null) {
			for (JavacNode param : fillParametersFrom.down()) {
				if (param.getKind() != Kind.ARGUMENT) continue;
				BuilderFieldData bfd = new BuilderFieldData();
				
				JCVariableDecl raw = (JCVariableDecl) param.get();
				bfd.name = raw.name;
				bfd.builderFieldName = bfd.name;
				bfd.rawName = raw.name;
				bfd.annotations = findCopyableAnnotations(param);
				bfd.type = raw.vartype;
				bfd.singularData = getSingularData(param, annInstance.setterPrefix());
				bfd.originalFieldNode = param;
				addObtainVia(bfd, param);
				job.builderFields.add(bfd);
			}
		}
		
		job.builderType = findInnerClass(job.parentType, job.builderClassName);
		if (job.builderType == null) {
			job.builderType = makeBuilderClass(job);
			recursiveSetGeneratedBy(job.builderType.get(), annotationNode);
		} else {
			JCClassDecl builderTypeDeclaration = (JCClassDecl) job.builderType.get();
			if (job.isStatic && !builderTypeDeclaration.getModifiers().getFlags().contains(Modifier.STATIC)) {
				annotationNode.addError(""Existing Builder must be a static inner class."");
				return;
			} else if (!job.isStatic && builderTypeDeclaration.getModifiers().getFlags().contains(Modifier.STATIC)) {
				annotationNode.addError(""Existing Builder must be a non-static inner class."");
				return;
			}
			sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(job.builderType, annotationNode);
			/* generate errors for @Singular BFDs that have one already defined node. */ {
				for (BuilderFieldData bfd : job.builderFields) {
					SingularData sd = bfd.singularData;
					if (sd == null) continue;
					JavacSingularizer singularizer = sd.getSingularizer();
					if (singularizer == null) continue;
					if (singularizer.checkForAlreadyExistingNodesAndGenerateError(job.builderType, sd)) {
						bfd.singularData = null;
					}
				}
			}
		}
		
		for (BuilderFieldData bfd : job.builderFields) {
			if (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {
				if (bfd.singularData.getSingularizer().requiresCleaning()) {
					addCleaning = true;
					break;
				}
			}
			if (bfd.obtainVia != null) {
				if (bfd.obtainVia.field().isEmpty() == bfd.obtainVia.method().isEmpty()) {
					bfd.obtainViaNode.addError(""The syntax is either @ObtainVia(field = \""fieldName\"") or @ObtainVia(method = \""methodName\"")."");
					return;
				}
				if (bfd.obtainVia.method().isEmpty() && bfd.obtainVia.isStatic()) {
					bfd.obtainViaNode.addError(""@ObtainVia(isStatic = true) is not valid unless 'method' has been set."");
					return;
				}
			}
		}
		
		generateBuilderFields(job);
		if (addCleaning) {
			JavacTreeMaker maker = job.getTreeMaker();
			JCVariableDecl uncleanField = maker.VarDef(maker.Modifiers(Flags.PRIVATE), job.builderType.toName(CLEAN_FIELD_NAME), maker.TypeIdent(CTC_BOOLEAN), null);
			injectFieldAndMarkGenerated(job.builderType, uncleanField);
			recursiveSetGeneratedBy(uncleanField, annotationNode);
		}
		
		if (constructorExists(job.builderType) == MemberExistsResult.NOT_EXISTS) {
			JCMethodDecl cd = HandleConstructor.createConstructor(AccessLevel.PACKAGE, List.<JCAnnotation>nil(), job.builderType, List.<JavacNode>nil(), false, annotationNode);
			if (cd != null) injectMethod(job.builderType, cd);
		}
		
		for (BuilderFieldData bfd : job.builderFields) {
			makePrefixedSetterMethodsForBuilder(job, bfd, annInstance.setterPrefix());
		}
		
		{
			MemberExistsResult methodExists = methodExists(job.buildMethodName, job.builderType, -1);
			if (methodExists == MemberExistsResult.EXISTS_BY_LOMBOK) methodExists = methodExists(job.buildMethodName, job.builderType, 0);
			if (methodExists == MemberExistsResult.NOT_EXISTS) {
				JCMethodDecl md = generateBuildMethod(job, nameOfBuilderMethod, buildMethodReturnType, buildMethodThrownExceptions, addCleaning);
				if (md != null) {
					recursiveSetGeneratedBy(md, annotationNode);
					injectMethod(job.builderType, md);
				}
			}
		}
		
		if (methodExists(""toString"", job.builderType, 0) == MemberExistsResult.NOT_EXISTS) {
			java.util.List<Included<JavacNode, ToString.Include>> fieldNodes = new ArrayList<Included<JavacNode, ToString.Include>>();
			for (BuilderFieldData bfd : job.builderFields) {
				for (JavacNode f : bfd.createdFields) {
					fieldNodes.add(new Included<JavacNode, ToString.Include>(f, null, true, false));
				}
			}
			
			JCMethodDecl md = HandleToString.createToString(job.builderType, fieldNodes, true, false, FieldAccess.ALWAYS_FIELD, job.sourceNode);
			if (md != null) injectMethod(job.builderType, md);
		}
		
		if (addCleaning) injectMethod(job.builderType, generateCleanMethod(job));
		
		if (generateBuilderMethod && methodExists(job.builderMethodName, job.parentType, -1) != MemberExistsResult.NOT_EXISTS) generateBuilderMethod = false;
		if (generateBuilderMethod) {
			JCMethodDecl md = generateBuilderMethod(job);
			recursiveSetGeneratedBy(md, annotationNode);
			if (md != null) injectMethod(job.parentType, md);
		}
		
		if (job.toBuilder) {
			switch (methodExists(TO_BUILDER_METHOD_NAME, job.parentType, 0)) {
			case EXISTS_BY_USER:
				annotationNode.addWarning(""Not generating toBuilder() as it already exists."");
				return;
			case NOT_EXISTS:
				List<JCTypeParameter> tps = job.typeParams;
				if (typeArgsForToBuilder != null) {
					ListBuffer<JCTypeParameter> lb = new ListBuffer<JCTypeParameter>();
					JavacTreeMaker maker = job.getTreeMaker();
					for (Name n : typeArgsForToBuilder) {
						lb.append(maker.TypeParameter(n, List.<JCExpression>nil()));
					}
					tps = lb.toList();
				}
				JCMethodDecl md = generateToBuilderMethod(job, tps, annInstance.setterPrefix());
				if (md != null) {
					recursiveSetGeneratedBy(md, annotationNode);
					injectMethod(job.parentType, md);
				}
			}
		}
		
		if (nonFinalNonDefaultedFields != null && generateBuilderMethod) {
			for (JavacNode fieldNode : nonFinalNonDefaultedFields) {
				fieldNode.addWarning(""@Builder will ignore the initializing expression entirely. If you want the initializing expression to serve as default, add @Builder.Default. If it is not supposed to be settable during building, make the field final."");
			}
		}
	}

	static String returnTypeToBuilderClassName(JavacNode annotationNode, JCClassDecl td, JCExpression returnType, List<JCTypeParameter> typeParams) {
		String replStr = null;
		if (returnType instanceof JCFieldAccess) {
			replStr = ((JCFieldAccess) returnType).name.toString();
		} else if (returnType instanceof JCIdent) {
			Name n = ((JCIdent) returnType).name;
			
			for (JCTypeParameter tp : typeParams) {
				if (tp.name.equals(n)) {
					annotationNode.addError(""@Builder requires specifying 'builderClassName' if used on methods with a type parameter as return type."");
					return null;
				}
			}
			replStr = n.toString();
		} else if (returnType instanceof JCPrimitiveTypeTree) {
			replStr = returnType.toString();
			if (Character.isLowerCase(replStr.charAt(0))) {
				replStr = Character.toTitleCase(replStr.charAt(0)) + replStr.substring(1);
			}
		} else if (returnType instanceof JCTypeApply) {
			JCExpression clazz = ((JCTypeApply) returnType).clazz;
			if (clazz instanceof JCFieldAccess) {
				replStr = ((JCFieldAccess) clazz).name.toString();
			} else if (clazz instanceof JCIdent) {
				replStr = ((JCIdent) clazz).name.toString();
			}
		}
		
		if (replStr == null || replStr.isEmpty()) {
			// This shouldn't happen.
			System.err.println(""Lombok bug ID#20140614-1651: javac HandleBuilder: return type to name conversion failed: "" + returnType.getClass());
			replStr = td.name.toString();
		}
		return replStr;
	}
	
	private static String unpack(JCExpression expr) {
		StringBuilder sb = new StringBuilder();
		unpack(sb, expr);
		return sb.toString();
	}
	
	private static void unpack(StringBuilder sb, JCExpression expr) {
		if (expr instanceof JCIdent) {
			sb.append(((JCIdent) expr).name.toString());
			return;
		}
		
		if (expr instanceof JCFieldAccess) {
			JCFieldAccess jcfa = (JCFieldAccess) expr;
			unpack(sb, jcfa.selected);
			sb.append(""."").append(jcfa.name.toString());
			return;
		}
		
		if (expr instanceof JCTypeApply) {
			sb.setLength(0);
			sb.append(""ERR:"");
			sb.append(""@Builder(toBuilder=true) is not supported if returning a type with generics applied to an intermediate."");
			sb.append(""__ERR__"");
			return;
		}
		
		sb.setLength(0);
		sb.append(""ERR:"");
		sb.append(""Expected a type of some sort, not a "" + expr.getClass().getName());
		sb.append(""__ERR__"");
	}
	
	private JCMethodDecl generateToBuilderMethod(BuilderJob job, List<JCTypeParameter> typeParameters, String prefix) {
		// return new ThingieBuilder<A, B>().setA(this.a).setB(this.b);
		JavacTreeMaker maker = job.getTreeMaker();
		
		JCExpression call = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, job.parentType, job.toName(job.builderClassName), !job.isStatic, job.builderTypeParams), List.<JCExpression>nil(), null);
		JCExpression invoke = call;
		ListBuffer<JCStatement> preStatements = null;
		ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();
		
		for (BuilderFieldData bfd : job.builderFields) {
			String setterPrefix = !prefix.isEmpty() ? prefix : job.oldFluent ? """" : ""set"";
			String prefixedSetterName = bfd.name.toString();
			if (!setterPrefix.isEmpty()) prefixedSetterName = HandlerUtil.buildAccessorName(job.sourceNode, setterPrefix, prefixedSetterName);
			
			Name setterName = job.toName(prefixedSetterName);
			JCExpression[] tgt = new JCExpression[bfd.singularData == null ? 1 : 2];
			if (bfd.obtainVia == null || !bfd.obtainVia.field().isEmpty()) {
				for (int i = 0; i < tgt.length; i++) {
					tgt[i] = maker.Select(maker.Ident(job.toName(""this"")), bfd.obtainVia == null ? bfd.rawName : job.toName(bfd.obtainVia.field()));
				}
			} else {
				String name = bfd.obtainVia.method();
				JCMethodInvocation inv;
				if (bfd.obtainVia.isStatic()) {
					JCExpression c = maker.Select(maker.Ident(job.toName(job.parentType.getName())), job.toName(name));
					inv = maker.Apply(typeParameterNames(maker, typeParameters), c, List.<JCExpression>of(maker.Ident(job.toName(""this""))));
				} else {
					JCExpression c = maker.Select(maker.Ident(job.toName(""this"")), job.toName(name));
					inv = maker.Apply(List.<JCExpression>nil(), c, List.<JCExpression>nil());
				}
				for (int i = 0; i < tgt.length; i++) tgt[i] = maker.Ident(bfd.name);
				
				// javac appears to cache the type of JCMethodInvocation expressions based on position, meaning, if you have 2 ObtainVia-based method invokes on different types, you get bizarre type mismatch errors.
				// going via a local variable declaration solves the problem.
				JCExpression varType = JavacHandlerUtil.cloneType(maker, bfd.type, job.sourceNode);
				if (preStatements == null) preStatements = new ListBuffer<JCStatement>();
				preStatements.append(maker.VarDef(maker.Modifiers(Flags.FINAL), bfd.name, varType, inv));
			}
			
			JCExpression arg;
			if (bfd.singularData == null) {
				arg = tgt[0];
				invoke = maker.Apply(List.<JCExpression>nil(), maker.Select(invoke, setterName), List.of(arg));
			} else {
				JCExpression isNotNull = maker.Binary(CTC_NOT_EQUAL, tgt[0], maker.Literal(CTC_BOT, null));
				JCExpression invokeBuilder = maker.Apply(List.<JCExpression>nil(), maker.Select(maker.Ident(job.toName(BUILDER_TEMP_VAR)), setterName), List.<JCExpression>of(tgt[1]));
				statements.append(maker.If(isNotNull, maker.Exec(invokeBuilder), null));
			}
		}
		
		if (!statements.isEmpty()) {
			JCExpression tempVarType = namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, typeParameters);
			statements.prepend(maker.VarDef(maker.Modifiers(Flags.FINAL), job.toName(BUILDER_TEMP_VAR), tempVarType, invoke));
			statements.append(maker.Return(maker.Ident(job.toName(BUILDER_TEMP_VAR))));
		} else {
			statements.append(maker.Return(invoke));
		}
		
		if (preStatements != null) {
			preStatements.appendList(statements);
			statements = preStatements;
		}
		JCBlock body = maker.Block(0, statements.toList());
		List<JCAnnotation> annsOnParamType = List.nil();
		if (job.checkerFramework.generateUnique()) annsOnParamType = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));
		JCMethodDecl methodDef = maker.MethodDef(maker.Modifiers(toJavacModifier(job.accessOuters)), job.toName(TO_BUILDER_METHOD_NAME), namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, typeParameters, annsOnParamType), List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);
		createRelevantNonNullAnnotation(job.parentType, methodDef);
		return methodDef;
	}
	
	private JCMethodDecl generateCleanMethod(BuilderJob job) {
		JavacTreeMaker maker = job.getTreeMaker();
		ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();
		
		for (BuilderFieldData bfd : job.builderFields) {
			if (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {
				bfd.singularData.getSingularizer().appendCleaningCode(bfd.singularData, job.builderType, job.sourceNode, statements);
			}
		}
		
		statements.append(maker.Exec(maker.Assign(maker.Select(maker.Ident(job.toName(""this"")), job.toName(CLEAN_FIELD_NAME)), maker.Literal(CTC_BOOLEAN, 0))));
		JCBlock body = maker.Block(0, statements.toList());
		JCMethodDecl method = maker.MethodDef(maker.Modifiers(toJavacModifier(AccessLevel.PRIVATE)), job.toName(CLEAN_METHOD_NAME), maker.Type(Javac.createVoidType(job.builderType.getSymbolTable(), CTC_VOID)), List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);
		recursiveSetGeneratedBy(method, job.sourceNode);
		return method;
	}
	
	static JCVariableDecl generateReceiver(BuilderJob job) {
		if (!job.checkerFramework.generateCalledMethods()) return null;
		
		ArrayList<String> mandatories = new ArrayList<String>();
		for (BuilderFieldData bfd : job.builderFields) {
			if (bfd.singularData == null && bfd.nameOfSetFlag == null) mandatories.add(bfd.name.toString());
		}
		
		JCExpression arg;
		JavacTreeMaker maker = job.getTreeMaker();
		if (mandatories.size() == 0) return null;
		if (mandatories.size() == 1) arg = maker.Literal(mandatories.get(0));
		else {
			List<JCExpression> elems = List.nil();
			for (int i = mandatories.size() - 1; i >= 0; i--) elems = elems.prepend(maker.Literal(mandatories.get(i)));
			arg = maker.NewArray(null, List.<JCExpression>nil(), elems);
		}
		JCAnnotation recvAnno = maker.Annotation(genTypeRef(job.builderType, CheckerFrameworkVersion.NAME__CALLED), List.of(arg));
		JCClassDecl builderTypeNode = (JCClassDecl) job.builderType.get();
		JCVariableDecl recv = maker.VarDef(maker.Modifiers(Flags.PARAMETER, List.<JCAnnotation>nil()), job.toName(""this""), namePlusTypeParamsToTypeReference(maker, job.builderType, builderTypeNode.typarams, List.<JCAnnotation>of(recvAnno)), null);
		return recv;
	}
	
	private JCMethodDecl generateBuildMethod(BuilderJob job, Name staticName, JCExpression returnType, List<JCExpression> thrownExceptions, boolean addCleaning) {
		JavacTreeMaker maker = job.getTreeMaker();
		
		JCExpression call;
		ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();
		
		if (addCleaning) {
			JCExpression notClean = maker.Unary(CTC_NOT, maker.Select(maker.Ident(job.toName(""this"")), job.toName(CLEAN_FIELD_NAME)));
			JCStatement invokeClean = maker.Exec(maker.Apply(List.<JCExpression>nil(), maker.Ident(job.toName(CLEAN_METHOD_NAME)), List.<JCExpression>nil()));
			JCIf ifUnclean = maker.If(notClean, invokeClean, null);
			statements.append(ifUnclean);
		}
		
		for (BuilderFieldData bfd : job.builderFields) {
			if (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {
				bfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, job.builderType, job.sourceNode, statements, bfd.builderFieldName, ""this"");
			}
		}
		
		ListBuffer<JCExpression> args = new ListBuffer<JCExpression>();
		Name thisName = job.toName(""this"");
		for (BuilderFieldData bfd : job.builderFields) {
			if (bfd.nameOfSetFlag != null) {
				statements.append(maker.VarDef(maker.Modifiers(0L), bfd.builderFieldName, cloneType(maker, bfd.type, job.sourceNode), maker.Select(maker.Ident(thisName), bfd.builderFieldName)));
				statements.append(maker.If(maker.Unary(CTC_NOT, maker.Select(maker.Ident(thisName), bfd.nameOfSetFlag)), maker.Exec(maker.Assign(maker.Ident(bfd.builderFieldName), maker.Apply(typeParameterNames(maker, ((JCClassDecl) job.parentType.get()).typarams), maker.Select(maker.Ident(((JCClassDecl) job.parentType.get()).name), bfd.nameOfDefaultProvider), List.<JCExpression>nil()))), null));
			}
			if (bfd.nameOfSetFlag != null || (bfd.singularData != null && bfd.singularData.getSingularizer().shadowedDuringBuild())) {
				args.append(maker.Ident(bfd.builderFieldName));
			} else {
				args.append(maker.Select(maker.Ident(thisName), bfd.builderFieldName));
			}
		}
		
		if (addCleaning) {
			statements.append(maker.Exec(maker.Assign(maker.Select(maker.Ident(job.toName(""this"")), job.toName(CLEAN_FIELD_NAME)), maker.Literal(CTC_BOOLEAN, 1))));
		}
		
		if (staticName == null) {
			call = maker.NewClass(null, List.<JCExpression>nil(), returnType, args.toList(), null);
			statements.append(maker.Return(call));
		} else {
			ListBuffer<JCExpression> typeParams = new ListBuffer<JCExpression>();
			for (JCTypeParameter tp : ((JCClassDecl) job.builderType.get()).typarams) {
				typeParams.append(maker.Ident(tp.name));
			}
			JCExpression callee = maker.Ident(((JCClassDecl) job.parentType.get()).name);
			if (!job.isStatic) callee = maker.Select(callee, job.toName(""this""));
			JCExpression fn = maker.Select(callee, staticName);
			call = maker.Apply(typeParams.toList(), fn, args.toList());
			if (returnType instanceof JCPrimitiveTypeTree && CTC_VOID.equals(typeTag(returnType))) {
				statements.append(maker.Exec(call));
			} else {
				statements.append(maker.Return(call));
			}
		}
		
		JCBlock body = maker.Block(0, statements.toList());
		
		List<JCAnnotation> annsOnMethod = job.checkerFramework.generateSideEffectFree() ? List.of(maker.Annotation(genTypeRef(job.builderType, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil())) : List.<JCAnnotation>nil();
		JCVariableDecl recv = generateReceiver(job);
		JCMethodDecl methodDef;
		if (recv != null && maker.hasMethodDefWithRecvParam()) {
			methodDef = maker.MethodDefWithRecvParam(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnType, List.<JCTypeParameter>nil(), recv, List.<JCVariableDecl>nil(), thrownExceptions, body, null);
		} else {
			methodDef = maker.MethodDef(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnType, List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), thrownExceptions, body, null);
		}
		if (staticName == null) createRelevantNonNullAnnotation(job.builderType, methodDef);
		return methodDef;
	}
	
	public static JCMethodDecl generateDefaultProvider(Name methodName, JavacNode fieldNode, List<JCTypeParameter> params, BuilderJob job) {
		JavacTreeMaker maker = fieldNode.getTreeMaker();
		JCVariableDecl field = (JCVariableDecl) fieldNode.get();
		
		// Lombok tries to keep the position of the original initializer. First we save the expression ...
		JCExpression init = field.init;
		field.init = null;
		
		// ... then we generate an empty return statement ...
		JCReturn statement = maker.Return(null);
		JCBlock body = maker.Block(0, List.<JCStatement>of(statement));
		int modifiers = Flags.PRIVATE | Flags.STATIC;
		JCMethodDecl defaultProvider = maker.MethodDef(maker.Modifiers(modifiers), methodName, cloneType(maker, field.vartype, fieldNode), copyTypeParams(fieldNode, params), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);
		// ... then we set positions for everything else ...
		recursiveSetGeneratedBy(defaultProvider, job.sourceNode);
		// ... and finally add back the original expression
		statement.expr = init;
		return defaultProvider;
	}
	
	public JCMethodDecl generateBuilderMethod(BuilderJob job) {
		//String builderClassName, JavacNode source, JavacNode type, List<JCTypeParameter> typeParams, AccessLevel access) {
		//builderClassName, annotationNode, tdParent, typeParams, accessForOuters);
		
		JavacTreeMaker maker = job.getTreeMaker();
		
		JCExpression call;
		if (job.isStatic) {
			call = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, job.parentType, job.toName(job.builderClassName), false, job.typeParams), List.<JCExpression>nil(), null);
		} else {
			call = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, null, job.toName(job.builderClassName), false, job.typeParams), List.<JCExpression>nil(), null);
			((JCNewClass) call).encl = maker.Ident(job.toName(""this""));
			
		}
		JCStatement statement = maker.Return(call);
		
		JCBlock body = maker.Block(0, List.<JCStatement>of(statement));
		int modifiers = toJavacModifier(job.accessOuters);
		if (job.isStatic) modifiers |= Flags.STATIC;
		List<JCAnnotation> annsOnMethod = List.nil();
		if (job.checkerFramework.generateSideEffectFree()) annsOnMethod = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));
		List<JCAnnotation> annsOnParamType = List.nil();
		if (job.checkerFramework.generateUnique()) annsOnParamType = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));
		
		JCExpression returnType = namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, job.builderTypeParams, annsOnParamType);
		JCMethodDecl methodDef = maker.MethodDef(maker.Modifiers(modifiers, annsOnMethod), job.toName(job.builderMethodName), returnType, job.copyTypeParams(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);
		createRelevantNonNullAnnotation(job.parentType, methodDef);
		return methodDef;
	}
	
	public void generateBuilderFields(BuilderJob job) {
		int len = job.builderFields.size();
		java.util.List<JavacNode> existing = new ArrayList<JavacNode>();
		for (JavacNode child : job.builderType.down()) {
			if (child.getKind() == Kind.FIELD) existing.add(child);
		}
		
		java.util.List<JCVariableDecl> generated = new ArrayList<JCVariableDecl>();
		
		for (int i = len - 1; i >= 0; i--) {
			BuilderFieldData bfd = job.builderFields.get(i);
			if (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {
				java.util.List<JavacNode> generateSingularFields = bfd.singularData.getSingularizer().generateFields(bfd.singularData, job.builderType, job.sourceNode);
				for (JavacNode field : generateSingularFields) {
					generated.add((JCVariableDecl) field.get());
				}
				bfd.createdFields.addAll(generateSingularFields);
			} else {
				JavacNode field = null, setFlag = null;
				for (JavacNode exists : existing) {
					Name n = ((JCVariableDecl) exists.get()).name;
					if (n.equals(bfd.builderFieldName)) field = exists;
					if (n.equals(bfd.nameOfSetFlag)) setFlag = exists;
				}
				JavacTreeMaker maker = job.getTreeMaker();
				if (field == null) {
					JCModifiers mods = maker.Modifiers(Flags.PRIVATE);
					JCVariableDecl newField = maker.VarDef(mods, bfd.builderFieldName, cloneType(maker, bfd.type, job.sourceNode), null);
					field = injectFieldAndMarkGenerated(job.builderType, newField);
					generated.add(newField);
				}
				if (setFlag == null && bfd.nameOfSetFlag != null) {
					JCModifiers mods = maker.Modifiers(Flags.PRIVATE);
					JCVariableDecl newField = maker.VarDef(mods, bfd.nameOfSetFlag, maker.TypeIdent(CTC_BOOLEAN), null);
					injectFieldAndMarkGenerated(job.builderType, newField);
					generated.add(newField);
				}
				bfd.createdFields.add(field);
			}
		}
		for (JCVariableDecl gen : generated) recursiveSetGeneratedBy(gen, job.sourceNode);
	}
	
	public void makePrefixedSetterMethodsForBuilder(BuilderJob job, BuilderFieldData bfd, String prefix) {
		boolean deprecate = isFieldDeprecated(bfd.originalFieldNode);
		if (bfd.singularData == null || bfd.singularData.getSingularizer() == null) {
			makePrefixedSetterMethodForBuilder(job, bfd, deprecate, prefix);
		} else {
			bfd.singularData.getSingularizer().generateMethods(job, bfd.singularData, deprecate);
		}
	}
	
	private void makePrefixedSetterMethodForBuilder(BuilderJob job, BuilderFieldData bfd, boolean deprecate, String prefix) {
		JavacNode fieldNode = bfd.createdFields.get(0);
		String setterPrefix = !prefix.isEmpty() ? prefix : job.oldFluent ? """" : ""set"";
		String setterName = HandlerUtil.buildAccessorName(job.sourceNode, setterPrefix, bfd.name.toString());
		Name setterName_ = job.builderType.toName(setterName);
		
		for (JavacNode child : job.builderType.down()) {
			if (child.getKind() != Kind.METHOD) continue;
			JCMethodDecl methodDecl = (JCMethodDecl) child.get();
			Name existingName = methodDecl.name;
			if (existingName.equals(setterName_) && !isTolerate(fieldNode, methodDecl)) return;
		}
		
		JavacTreeMaker maker = fieldNode.getTreeMaker();
		
		List<JCAnnotation> methodAnns = JavacHandlerUtil.findCopyableToSetterAnnotations(bfd.originalFieldNode);
		JCMethodDecl newMethod = null;
		if (job.checkerFramework.generateCalledMethods() && maker.hasMethodDefWithRecvParam()) {
			JCAnnotation ncAnno = maker.Annotation(genTypeRef(job.sourceNode, CheckerFrameworkVersion.NAME__NOT_CALLED), List.<JCExpression>of(maker.Literal(setterName.toString())));
			JCClassDecl builderTypeNode = (JCClassDecl) job.builderType.get();
			JCExpression selfType = namePlusTypeParamsToTypeReference(maker, job.builderType, builderTypeNode.typarams, List.<JCAnnotation>of(ncAnno));
			JCVariableDecl recv = maker.VarDef(maker.Modifiers(Flags.PARAMETER, List.<JCAnnotation>nil()), job.builderType.toName(""this""), selfType, null);
			newMethod = HandleSetter.createSetterWithRecv(toJavacModifier(job.accessInners), deprecate, fieldNode, maker, setterName, bfd.name, bfd.nameOfSetFlag, job.oldChain, job.sourceNode, methodAnns, bfd.annotations, recv);
		}
		if (newMethod == null) newMethod = HandleSetter.createSetter(toJavacModifier(job.accessInners), deprecate, fieldNode, maker, setterName, bfd.name, bfd.nameOfSetFlag, job.oldChain, job.sourceNode, methodAnns, bfd.annotations);
		recursiveSetGeneratedBy(newMethod, job.sourceNode);
		if (job.sourceNode.up().getKind() == Kind.METHOD) {
			copyJavadocFromParam(bfd.originalFieldNode.up(), newMethod, bfd.name.toString());
		} else {
			copyJavadoc(bfd.originalFieldNode, newMethod, CopyJavadoc.SETTER, true);
		}
		
		injectMethod(job.builderType, newMethod);
	}
	
	private void copyJavadocFromParam(JavacNode from, JCMethodDecl to, String param) {
		try {
			JCCompilationUnit cu = ((JCCompilationUnit) from.top().get());
			String methodComment = Javac.getDocComment(cu, from.get());
			String newJavadoc = addReturnsThisIfNeeded(getParamJavadoc(methodComment, param));
			Javac.setDocComment(cu, to, newJavadoc);
		} catch (Exception ignore) {}
	}	
	
	public JavacNode makeBuilderClass(BuilderJob job) {
		//boolean isStatic, JavacNode source, JavacNode tdParent, String builderClassName, List<JCTypeParameter> typeParams, JCAnnotation ast, AccessLevel access) {
		//isStatic, annotationNode, tdParent, builderClassName, typeParams, ast, accessForOuters
		JavacTreeMaker maker = job.getTreeMaker();
		int modifiers = toJavacModifier(job.accessOuters);
		if (job.isStatic) modifiers |= Flags.STATIC;
		JCModifiers mods = maker.Modifiers(modifiers);
		JCClassDecl builder = maker.ClassDef(mods, job.getBuilderClassName(), job.copyTypeParams(), null, List.<JCExpression>nil(), List.<JCTree>nil());
		recursiveSetGeneratedBy(builder, job.sourceNode);
		return injectType(job.parentType, builder);
	}
	
	private void addObtainVia(BuilderFieldData bfd, JavacNode node) {
		for (JavacNode child : node.down()) {
			if (!annotationTypeMatches(ObtainVia.class, child)) continue;
			AnnotationValues<ObtainVia> ann = createAnnotation(ObtainVia.class, child);
			bfd.obtainVia = ann.getInstance();
			bfd.obtainViaNode = child;
			deleteAnnotationIfNeccessary(child, ObtainVia.class);
			return;
		}
	}
	
	/**
	 * Returns the explicitly requested singular annotation on this node (field
	 * or parameter), or null if there's no {@code @Singular} annotation on it.
	 * 
	 * @param node The node (field or method param) to inspect for its name and potential {@code @Singular} annotation.
	 * @param setterPrefix Explicitly requested setter prefix.
	 */
	private SingularData getSingularData(JavacNode node, String setterPrefix) {
		for (JavacNode child : node.down()) {
			if (!annotationTypeMatches(Singular.class, child)) continue;
			Name pluralName = node.getKind() == Kind.FIELD ? removePrefixFromField(node) : ((JCVariableDecl) node.get()).name;
			AnnotationValues<Singular> ann = createAnnotation(Singular.class, child);
			Singular singularInstance = ann.getInstance();
			deleteAnnotationIfNeccessary(child, Singular.class);
			String explicitSingular = singularInstance.value();
			if (explicitSingular.isEmpty()) {
				if (Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.SINGULAR_AUTO))) {
					node.addError(""The singular must be specified explicitly (e.g. @Singular(\""task\"")) because auto singularization is disabled."");
					explicitSingular = pluralName.toString();
				} else {
					explicitSingular = autoSingularize(pluralName.toString());
					if (explicitSingular == null) {
						node.addError(""Can't singularize this name; please specify the singular explicitly (i.e. @Singular(\""sheep\""))"");
						explicitSingular = pluralName.toString();
					}
				}
			}
			Name singularName = node.toName(explicitSingular);
			
			JCExpression type = null;
			if (node.get() instanceof JCVariableDecl) {
				type = ((JCVariableDecl) node.get()).vartype;
			}
			
			String name = null;
			List<JCExpression> typeArgs = List.nil();
			if (type instanceof JCTypeApply) {
				typeArgs = ((JCTypeApply) type).arguments;
				type = ((JCTypeApply) type).clazz;
			}
			
			name = type.toString();
			
			String targetFqn = JavacSingularsRecipes.get().toQualified(name);
			JavacSingularizer singularizer = JavacSingularsRecipes.get().getSingularizer(targetFqn, node);
			if (singularizer == null) {
				node.addError(""Lombok does not know how to create the singular-form builder methods for type '"" + name + ""'; they won't be generated."");
				return null;
			}
			
			return new SingularData(child, singularName, pluralName, typeArgs, targetFqn, singularizer, singularInstance.ignoreNullCollections(), setterPrefix);
		}
		
		return null;
	}
}",1,64 2000 64 2001 40 45 1505 41 621 439 334 2002 378 2003 60 2004 62 123 437 2005 2006 61 418 2005 40 41 59 457 381 2007 2008 61 648 59 457 381 2007 2009 61 648 59 457 381 2007 2010 61 648 59 457 381 2007 2011 61 648 59 457 381 2007 2012 61 648 59 457 381 2007 2013 61 648 59 457 381 2007 2014 61 648 59 457 381 2007 2015 61 648 59 437 457 381 324 2016 40 2017 2018 44 324 2019 41 123 392 40 2018 614 424 41 450 2019 59 392 40 2018 402 2020 41 450 40 40 2021 41 40 40 2020 41 2018 41 46 2022 41 631 1500 59 450 40 40 2023 41 2018 41 46 2024 40 41 59 125 457 334 2025 123 2026 2027 59 2028 2029 59 2007 2030 44 2031 59 324 2032 59 2033 60 2034 62 2035 59 2033 60 2034 62 2036 59 2028 2037 59 2038 46 2039 46 2033 60 2040 62 2041 59 2042 2043 44 2044 59 324 2045 44 2046 44 2047 59 2028 2048 59 2007 2049 59 492 2050 40 2051 60 2004 62 2052 44 2004 2053 44 2028 2054 41 123 2044 61 2053 46 2055 40 41 59 392 40 2044 614 424 41 2044 61 2042 46 2056 59 392 40 2044 614 2042 46 2057 41 123 2037 46 2058 40 648 41 59 2044 61 2042 46 2056 59 125 2043 61 2044 614 2042 46 2059 63 2042 46 2056 58 2044 59 2045 61 2016 40 2052 46 2060 40 648 41 44 473 41 59 2046 61 2016 40 2052 46 2060 40 648 41 44 473 41 59 2030 61 2053 46 2030 40 41 59 2031 61 2053 46 2031 40 41 59 2049 61 2061 40 2054 44 2053 46 2049 40 41 41 59 2047 61 2053 46 2047 40 41 59 392 40 2030 614 424 41 2030 61 648 59 392 40 2031 614 424 41 2031 61 648 59 392 40 2049 614 424 41 2049 61 648 59 125 457 2007 2062 40 2028 2054 44 2007 431 41 123 392 40 431 631 424 605 33 431 46 2063 40 41 41 450 431 59 431 61 2054 46 2064 40 41 46 2065 40 2066 46 2067 41 59 392 40 431 631 424 605 33 431 46 2063 40 41 41 450 431 59 450 648 59 125 2007 2068 40 2069 2070 41 123 450 2068 40 2070 46 2071 40 41 44 2049 41 59 125 2007 2068 40 2007 2070 44 2007 466 41 123 392 40 466 46 2072 40 607 41 614 45 1501 41 450 466 59 450 466 46 2073 40 648 44 2070 41 59 125 2074 2075 40 41 123 450 2076 40 2029 46 2077 40 41 44 2029 44 2035 41 59 125 2069 2078 40 41 123 450 2029 46 2079 40 2049 41 59 125 2033 60 2034 62 2080 40 41 123 450 2081 46 2080 40 2037 44 2035 41 59 125 2069 2082 40 2007 2070 41 123 450 2029 46 2082 40 2070 41 59 125 2083 2084 40 41 123 450 2029 46 2084 40 41 59 125 2085 2086 40 41 123 450 2029 46 2086 40 41 59 125 125 457 334 2087 123 2088 60 2089 62 2090 59 2091 2092 59 2093 2094 59 2093 2095 59 2093 2096 59 2093 2097 59 2093 2098 59 2099 2100 59 2101 2102 59 2103 2104 59 2103 2105 59 2106 46 2107 46 2088 60 2103 62 2108 61 418 2109 60 2103 62 40 41 59 125 64 2110 439 492 2111 40 2112 60 2004 62 2113 44 2114 2115 44 2116 2117 41 123 381 2007 2118 61 648 59 2119 40 2117 44 2120 46 2121 44 648 41 59 2025 2122 61 418 2025 40 41 59 2122 46 2123 61 2117 59 2122 46 2124 61 2125 40 2117 41 59 2122 46 2126 61 473 59 2004 2127 61 2113 46 2128 40 41 59 2122 46 2129 40 2113 44 2127 44 2117 41 59 2130 46 2131 46 2132 60 2133 62 2134 61 424 59 324 2135 59 392 40 2122 46 2136 46 2137 40 41 41 123 2135 61 380 59 125 360 392 40 33 2138 40 648 44 2122 46 2136 44 2117 41 41 123 450 59 125 360 123 2135 61 473 59 125 392 40 33 2138 40 648 44 2122 46 2139 44 2117 41 41 450 59 621 2116 2140 61 2117 46 2141 40 41 59 2122 46 2142 61 418 2143 60 2087 62 40 41 59 2144 2145 59 2122 46 2146 61 2132 46 2147 40 41 59 2132 60 2144 62 2148 59 2133 2149 59 2116 2150 61 2140 46 2151 40 41 402 2152 63 2140 58 424 59 324 2153 61 380 59 2143 60 2116 62 2154 61 424 59 392 40 33 2155 40 2156 40 2140 41 41 41 123 2117 46 2157 40 648 41 59 450 59 125 392 40 2140 46 2151 40 41 402 2158 41 123 392 40 33 2159 40 2140 41 605 33 2160 40 2140 41 41 123 2117 46 2161 40 2118 41 59 450 59 125 2122 46 2162 61 2140 59 2158 2163 61 40 2158 41 2140 46 2151 40 41 59 2164 60 2116 62 2165 61 418 2164 60 2116 62 40 41 59 324 2166 61 40 2167 40 2168 46 2169 46 334 44 2140 41 606 2167 40 648 44 2140 41 41 59 385 40 2116 2170 58 2005 46 2171 40 2140 44 473 41 41 123 2172 2173 61 40 2172 41 2170 46 2151 40 41 59 2116 2174 61 2175 40 2004 46 2176 46 334 44 2170 44 380 41 59 324 2177 61 40 2173 46 2178 46 2179 38 2180 46 2181 41 631 1500 606 40 2166 605 33 2167 40 2182 46 334 44 2170 41 41 59 2087 2183 61 418 2087 40 41 59 2183 46 2184 61 2173 46 2185 59 2183 46 2185 61 2186 40 2170 41 59 2183 46 2187 61 2183 46 2185 59 2183 46 2188 61 2189 40 2170 41 59 2183 46 2190 61 2173 46 2191 59 2183 46 2192 61 2193 40 2170 44 2127 46 2194 40 41 41 59 2183 46 2195 61 2170 59 392 40 2183 46 2192 631 424 605 2174 631 424 41 123 2174 46 2196 40 648 41 59 2175 40 2004 46 2176 46 334 44 2170 44 473 41 59 2174 61 424 59 125 392 40 2173 46 2129 614 424 605 2174 631 424 41 123 2174 46 2197 40 648 41 59 2175 40 2004 46 2176 46 334 44 2170 44 473 41 59 2174 61 424 59 125 392 40 2173 46 2129 631 424 605 2174 614 424 41 123 392 40 2177 41 344 59 392 40 2154 614 424 41 2154 61 418 2143 60 2116 62 40 41 59 2154 46 2198 40 2170 41 59 125 392 40 2174 631 424 41 123 2183 46 2199 61 2140 46 2200 40 2011 43 2183 46 2185 41 59 2183 46 2201 61 2140 46 2200 40 2183 46 2185 43 2012 41 59 2183 46 2187 61 2140 46 2200 40 2183 46 2185 43 2013 41 59 2152 2202 61 2203 40 2183 46 2199 44 2170 44 2163 46 2204 44 2122 41 59 392 40 2202 631 424 41 2205 40 2140 44 2202 41 59 125 2206 40 2183 44 2170 41 59 2122 46 2142 46 2207 40 2183 41 59 2165 46 2208 40 2170 41 59 125 392 40 33 2160 40 2140 41 41 123 621 2006 46 2209 40 2140 44 2210 46 2211 44 2132 46 60 2114 62 2147 40 41 44 2165 46 2212 40 41 44 380 44 424 44 2213 46 2214 44 2117 41 59 125 2145 61 2215 40 2140 46 2216 40 41 44 2140 44 2163 46 2217 41 59 2122 46 2146 61 2122 46 2218 61 2163 46 2217 59 2148 61 2132 46 2147 40 41 59 2149 61 424 59 2122 46 2219 61 2122 46 2220 40 2163 46 2221 41 59 392 40 33 2138 40 648 44 2122 46 2219 44 2117 41 41 450 59 125 360 392 40 2150 631 424 605 2150 46 2222 40 41 46 2223 40 41 46 2224 40 648 41 41 123 2152 2225 61 40 2152 41 2150 46 2151 40 41 59 392 40 33 2225 46 2226 46 2137 40 41 41 123 2117 46 2227 40 648 41 59 450 59 125 2122 46 2228 61 2140 46 2141 40 41 59 2158 2229 61 40 2158 41 2122 46 2228 46 2151 40 41 59 2122 46 2146 61 2122 46 2230 61 2229 46 2226 59 2145 61 2122 46 2231 40 41 59 2148 61 2225 46 2232 59 2149 61 424 59 2122 46 2233 61 2122 46 2234 40 2229 46 2235 41 59 392 40 33 2138 40 648 44 2122 46 2233 44 2117 41 41 450 59 125 360 392 40 2150 631 424 41 123 2122 46 2236 61 2140 46 2141 40 41 59 2158 2237 61 40 2158 41 2122 46 2236 46 2151 40 41 59 2152 2238 61 40 2152 41 2150 46 2151 40 41 59 2122 46 2126 61 40 2238 46 2239 46 2240 38 2241 46 2242 41 631 1500 59 2144 2243 61 2238 46 2244 59 2145 61 2243 59 2122 46 2146 61 2122 46 2245 61 2238 46 2246 59 2148 61 2238 46 2247 59 2149 61 2238 46 2248 59 392 40 2145 402 2249 41 123 2145 61 2250 40 2122 46 2251 40 41 44 2145 44 2117 41 59 125 392 40 2122 46 2252 46 2253 40 607 41 62 45 1501 41 123 2007 2254 61 2255 40 2117 44 2237 44 2145 44 2122 46 2146 41 59 392 40 2254 614 424 41 450 59 621 2122 46 2252 61 2122 46 2252 46 2256 40 648 44 2254 41 59 125 392 40 2122 46 2257 41 123 392 40 2243 402 2258 41 123 2117 46 2259 40 2015 41 59 450 59 125 2133 2260 59 2007 2261 59 2132 60 2144 62 2262 61 2132 46 2147 40 41 59 392 40 2243 402 2249 41 123 2262 61 40 40 2249 41 2243 41 46 2263 59 125 2144 2264 61 2243 59 392 40 2145 402 2249 41 2264 61 40 40 2249 41 2145 41 46 2265 59 392 40 2264 402 2266 41 123 2260 61 40 40 2266 41 2264 41 46 2248 59 2261 61 424 59 125 360 392 40 2264 402 2267 41 123 2267 2268 61 40 2267 41 2264 59 2260 61 2268 46 2248 59 2261 61 2269 40 2268 46 2270 41 59 392 40 2261 46 2271 40 648 41 41 123 2007 2272 61 2261 46 2273 40 1502 44 2261 46 2253 40 648 41 41 59 2117 46 2274 40 2272 41 59 450 59 125 125 360 123 2117 46 2275 40 648 43 2264 46 2276 40 41 46 2222 40 41 41 59 450 59 125 392 40 2261 631 424 605 33 2140 46 2277 40 41 46 2224 40 2261 41 41 123 2117 46 2278 40 2015 41 59 450 59 125 392 40 33 2122 46 2236 46 2222 40 41 46 2279 40 2260 41 41 123 2117 46 2280 40 2015 41 59 450 59 125 2132 60 2281 62 2282 61 2238 46 2246 59 2132 60 2281 62 2283 61 40 40 2158 41 2122 46 2236 46 2151 40 41 41 46 2246 59 2134 61 418 2143 60 2133 62 40 41 59 385 40 2281 2284 58 2282 41 123 404 2285 61 45 1501 59 404 2286 61 45 1501 59 385 40 2144 2287 58 2262 41 123 2286 637 59 392 40 33 40 2287 402 2266 41 41 344 59 392 40 40 40 2266 41 2287 41 46 2248 631 2284 46 2248 41 344 59 2285 61 2286 59 125 392 40 2285 614 45 1501 606 2283 46 2288 40 41 620 2285 41 123 2117 46 2289 40 648 43 2284 46 2248 43 648 41 59 450 59 125 2134 46 2290 40 2283 46 2151 40 2285 41 46 2248 41 59 125 125 125 360 123 2117 46 2291 40 2118 41 59 450 59 125 392 40 2150 631 424 41 123 385 40 2116 2292 58 2150 46 2293 40 41 41 123 392 40 2292 46 2294 40 41 631 2295 46 2296 41 344 59 2087 2297 61 418 2087 40 41 59 2298 2299 61 40 2298 41 2292 46 2151 40 41 59 2297 46 2300 61 2299 46 2300 59 2297 46 2301 61 2297 46 2300 59 2297 46 2302 61 2299 46 2300 59 2297 46 2303 61 2304 40 2292 41 59 2297 46 2305 61 2299 46 2306 59 2297 46 2307 61 2308 40 2292 44 2127 46 2309 40 41 41 59 2297 46 2310 61 2292 59 2311 40 2297 44 2292 41 59 2122 46 2142 46 2312 40 2297 41 59 125 125 2122 46 2313 61 2314 40 2122 46 2315 44 2122 46 2316 41 59 392 40 2122 46 2313 614 424 41 123 2122 46 2313 61 2317 40 2122 41 59 2318 40 2122 46 2313 46 2151 40 41 44 2117 41 59 125 360 123 2158 2319 61 40 2158 41 2122 46 2313 46 2151 40 41 59 392 40 2122 46 2126 605 33 2319 46 2320 40 41 46 2321 40 41 46 2322 40 2323 46 2324 41 41 123 2117 46 2325 40 648 41 59 450 59 125 360 392 40 33 2122 46 2126 605 2319 46 2320 40 41 46 2321 40 41 46 2322 40 2323 46 2324 41 41 123 2117 46 2326 40 648 41 59 450 59 125 2327 40 2122 46 2313 44 2117 41 59 604 123 385 40 2087 2328 58 2122 46 2142 41 123 2329 2330 61 2328 46 2331 59 392 40 2330 614 424 41 344 59 2332 2333 61 2330 46 2334 40 41 59 392 40 2333 614 424 41 344 59 392 40 2333 46 2335 40 2122 46 2313 44 2330 41 41 123 2328 46 2331 61 424 59 125 125 125 125 385 40 2087 2336 58 2122 46 2142 41 123 392 40 2336 46 2337 631 424 605 2336 46 2337 46 2338 40 41 631 424 41 123 392 40 2336 46 2337 46 2338 40 41 46 2339 40 41 41 123 2153 61 473 59 325 59 125 125 392 40 2336 46 2340 631 424 41 123 392 40 2336 46 2340 46 2341 40 41 46 2137 40 41 614 2336 46 2340 46 2342 40 41 46 2137 40 41 41 123 2336 46 2343 46 2344 40 648 41 59 450 59 125 392 40 2336 46 2340 46 2342 40 41 46 2137 40 41 605 2336 46 2340 46 2126 40 41 41 123 2336 46 2345 46 2346 40 648 41 59 450 59 125 125 125 2347 40 2122 41 59 392 40 2153 41 123 2348 2349 61 2122 46 2350 40 41 59 2351 2352 61 2349 46 2353 40 2349 46 2354 40 2355 46 2356 41 44 2122 46 2313 46 2357 40 2008 41 44 2349 46 2358 40 2359 41 44 424 41 59 2360 40 2122 46 2313 44 2352 41 59 2361 40 2352 44 2117 41 59 125 392 40 2362 40 2122 46 2313 41 614 2363 46 2364 41 123 2152 2365 61 2005 46 2366 40 2367 46 2368 44 2132 46 60 2114 62 2147 40 41 44 2122 46 2313 44 2132 46 60 2116 62 2147 40 41 44 380 44 2117 41 59 392 40 2365 631 424 41 2369 40 2122 46 2313 44 2365 41 59 125 385 40 2087 2336 58 2122 46 2142 41 123 2370 40 2122 44 2336 44 2127 46 2371 40 41 41 59 125 123 2363 2372 61 2372 40 2122 46 2139 44 2122 46 2313 44 45 1501 41 59 392 40 2372 614 2363 46 2373 41 2372 61 2372 40 2122 46 2139 44 2122 46 2313 44 1500 41 59 392 40 2372 614 2363 46 2364 41 123 2152 2374 61 2375 40 2122 44 2149 44 2145 44 2148 44 2153 41 59 392 40 2374 631 424 41 123 2376 40 2374 44 2117 41 59 2377 40 2122 46 2313 44 2374 41 59 125 125 125 392 40 2378 40 648 44 2122 46 2313 44 1500 41 614 2363 46 2364 41 123 2130 46 2131 46 2132 60 2379 60 2116 44 2380 46 2381 641 2382 61 418 2143 60 2379 60 2116 44 2380 46 2381 641 40 41 59 385 40 2087 2336 58 2122 46 2142 41 123 385 40 2116 2383 58 2336 46 2384 41 123 2382 46 2385 40 418 2379 60 2116 44 2380 46 2381 62 40 2383 44 424 44 473 44 380 41 41 59 125 125 2152 2386 61 2387 46 2388 40 2122 46 2313 44 2382 44 473 44 380 44 2389 46 2390 44 2122 46 2123 41 59 392 40 2386 631 424 41 2391 40 2122 46 2313 44 2386 41 59 125 392 40 2153 41 2392 40 2122 46 2313 44 2393 40 2122 41 41 59 392 40 2135 605 2378 40 2122 46 2136 44 2122 46 2315 44 45 1501 41 631 2363 46 2364 41 2135 61 380 59 392 40 2135 41 123 2152 2394 61 2135 40 2122 41 59 2395 40 2394 44 2117 41 59 392 40 2394 631 424 41 2392 40 2122 46 2315 44 2394 41 59 125 392 40 2122 46 2396 41 123 464 40 2378 40 2010 44 2122 46 2315 44 1500 41 41 123 328 2397 58 2117 46 2398 40 648 41 59 450 59 328 2364 58 2132 60 2399 62 2400 61 2122 46 2146 59 392 40 2134 631 424 41 123 2401 60 2399 62 2402 61 418 2401 60 2399 62 40 41 59 2403 2404 61 2122 46 2405 40 41 59 385 40 2133 2406 58 2134 41 123 2402 46 2407 40 2404 46 2408 40 2406 44 2132 46 60 2144 62 2147 40 41 41 41 59 125 2400 61 2402 46 2409 40 41 59 125 2152 2410 61 2411 40 2122 44 2400 44 2127 46 2412 40 41 41 59 392 40 2410 631 424 41 123 2413 40 2410 44 2117 41 59 2392 40 2122 46 2315 44 2410 41 59 125 125 125 392 40 2154 631 424 605 2135 41 123 385 40 2116 2414 58 2154 41 123 2414 46 2415 40 648 41 59 125 125 125 457 2007 2416 40 2116 2117 44 2417 2418 44 2419 2420 44 2421 60 2422 62 2423 41 123 2007 2424 61 424 59 392 40 2420 402 2425 41 123 2424 61 40 40 2425 41 2420 41 46 2426 46 2427 40 41 59 125 360 392 40 2420 402 2428 41 123 2429 2430 61 40 40 2428 41 2420 41 46 2431 59 385 40 2422 2432 58 2423 41 123 392 40 2432 46 2431 46 2433 40 2430 41 41 123 2117 46 2434 40 648 41 59 450 424 59 125 125 2424 61 2430 46 2435 40 41 59 125 360 392 40 2420 402 2436 41 123 2424 61 2420 46 2437 40 41 59 392 40 2438 46 2439 40 2424 46 2440 40 1500 41 41 41 123 2424 61 2438 46 2441 40 2424 46 2440 40 1500 41 41 43 2424 46 2442 40 1501 41 59 125 125 360 392 40 2420 402 2443 41 123 2419 2444 61 40 40 2443 41 2420 41 46 2444 59 392 40 2444 402 2425 41 123 2424 61 40 40 2425 41 2444 41 46 2445 46 2446 40 41 59 125 360 392 40 2444 402 2428 41 123 2424 61 40 40 2428 41 2444 41 46 2447 46 2448 40 41 59 125 125 392 40 2424 614 424 606 2424 46 2449 40 41 41 123 621 2450 46 2451 46 2452 40 648 43 2420 46 2453 40 41 41 59 2424 61 2418 46 2454 46 2455 40 41 59 125 450 2424 59 125 437 457 2007 2456 40 2419 2018 41 123 2457 2458 61 418 2457 40 41 59 2456 40 2458 44 2018 41 59 450 2458 46 2459 40 41 59 125 437 457 492 2456 40 2460 2461 44 2419 2018 41 123 392 40 2018 402 2462 41 123 2461 46 2463 40 40 40 2462 41 2018 41 46 2464 46 2465 40 41 41 59 450 59 125 392 40 2018 402 2466 41 123 2466 2467 61 40 2466 41 2018 59 2456 40 2461 44 2467 46 2468 41 59 2461 46 2469 40 648 41 46 2469 40 2467 46 2470 46 2471 40 41 41 59 450 59 125 392 40 2018 402 2472 41 123 2461 46 2473 40 1500 41 59 2461 46 2474 40 648 41 59 2461 46 2474 40 648 41 59 2461 46 2474 40 648 41 59 450 59 125 2461 46 2475 40 1500 41 59 2461 46 2476 40 648 41 59 2461 46 2476 40 648 43 2018 46 2477 40 41 46 2478 40 41 41 59 2461 46 2476 40 648 41 59 125 437 2479 2480 40 2025 2481 44 2421 60 2422 62 2482 44 2007 2483 41 123 621 2484 2485 61 2481 46 2486 40 41 59 2419 2487 61 2485 46 2488 40 424 44 2421 46 60 2419 62 2489 40 41 44 2490 40 2485 44 2481 46 2491 44 2481 46 2492 40 2481 46 2493 41 44 33 2481 46 2494 44 2481 46 2495 41 44 2421 46 60 2419 62 2489 40 41 44 424 41 59 2419 2496 61 2487 59 2497 60 2498 62 2499 61 424 59 2497 60 2498 62 2500 61 418 2497 60 2498 62 40 41 59 385 40 2087 2501 58 2481 46 2502 41 123 2007 2503 61 33 2483 46 2504 40 41 63 2483 58 2481 46 2505 63 648 58 648 59 2007 2506 61 2501 46 2507 46 2508 40 41 59 392 40 33 2503 46 2504 40 41 41 2506 61 2509 46 2510 40 2481 46 2511 44 2503 44 2506 41 59 2512 2513 61 2481 46 2492 40 2506 41 59 2419 91 93 2514 61 418 2419 91 2501 46 2515 614 424 63 1501 58 1502 93 59 392 40 2501 46 2516 614 424 606 33 2501 46 2516 46 2517 40 41 46 2504 40 41 41 123 385 40 404 2518 61 1500 59 2518 60 2514 46 2519 59 2518 637 41 123 2514 91 2518 93 61 2485 46 2520 40 2485 46 2521 40 2481 46 2492 40 648 41 41 44 2501 46 2516 614 424 63 2501 46 2522 58 2481 46 2492 40 2501 46 2516 46 2517 40 41 41 41 59 125 125 360 123 2007 2507 61 2501 46 2516 46 2523 40 41 59 2524 2525 59 392 40 2501 46 2516 46 2494 40 41 41 123 2419 2526 61 2485 46 2527 40 2485 46 2528 40 2481 46 2492 40 2481 46 2491 46 2529 40 41 41 41 44 2481 46 2492 40 2507 41 41 59 2525 61 2485 46 2530 40 2531 40 2485 44 2482 41 44 2526 44 2421 46 60 2419 62 2532 40 2485 46 2528 40 2481 46 2492 40 648 41 41 41 41 59 125 360 123 2419 2533 61 2485 46 2534 40 2485 46 2535 40 2481 46 2492 40 648 41 41 44 2481 46 2492 40 2507 41 41 59 2525 61 2485 46 2536 40 2421 46 60 2419 62 2489 40 41 44 2533 44 2421 46 60 2419 62 2489 40 41 41 59 125 385 40 404 2537 61 1500 59 2537 60 2514 46 2538 59 2537 637 41 2514 91 2537 93 61 2485 46 2539 40 2501 46 2507 41 59 621 621 2419 2540 61 2541 46 2542 40 2485 44 2501 46 2543 44 2481 46 2511 41 59 392 40 2499 614 424 41 2499 61 418 2497 60 2498 62 40 41 59 2499 46 2544 40 2485 46 2545 40 2485 46 2546 40 2547 46 2548 41 44 2501 46 2507 44 2540 44 2525 41 41 59 125 2419 2549 59 392 40 2501 46 2515 614 424 41 123 2549 61 2514 91 1500 93 59 2496 61 2485 46 2550 40 2421 46 60 2419 62 2489 40 41 44 2485 46 2551 40 2496 44 2513 41 44 2421 46 2552 40 2549 41 41 59 125 360 123 2419 2553 61 2485 46 2554 40 2555 44 2514 91 1500 93 44 2485 46 2556 40 2557 44 424 41 41 59 2419 2558 61 2485 46 2559 40 2421 46 60 2419 62 2489 40 41 44 2485 46 2560 40 2485 46 2561 40 2481 46 2492 40 2014 41 41 44 2513 41 44 2421 46 60 2419 62 2562 40 2514 91 1501 93 41 41 59 2500 46 2563 40 2485 46 2564 40 2553 44 2485 46 2565 40 2558 41 44 424 41 41 59 125 125 392 40 33 2500 46 2566 40 41 41 123 2419 2567 61 2490 40 2485 44 2481 46 2491 44 2481 46 2568 40 41 44 33 2481 46 2494 44 2482 41 59 2500 46 2569 40 2485 46 2570 40 2485 46 2571 40 2572 46 2573 41 44 2481 46 2492 40 2014 41 44 2567 44 2496 41 41 59 2500 46 2574 40 2485 46 2575 40 2485 46 2576 40 2481 46 2492 40 2014 41 41 41 41 59 125 360 123 2500 46 2577 40 2485 46 2578 40 2496 41 41 59 125 392 40 2499 631 424 41 123 2499 46 2579 40 2500 41 59 2500 61 2499 59 125 2580 2581 61 2485 46 2582 40 1500 44 2500 46 2583 40 41 41 59 2421 60 2114 62 2584 61 2421 46 2489 40 41 59 392 40 2481 46 2585 46 2586 40 41 41 2584 61 2421 46 2587 40 2485 46 2588 40 2589 40 2481 46 2491 44 2590 46 2591 41 44 2421 46 60 2419 62 2489 40 41 41 41 59 2479 2592 61 2485 46 2593 40 2485 46 2594 40 2595 40 2481 46 2596 41 41 44 2481 46 2492 40 2010 41 44 2490 40 2485 44 2481 46 2491 44 2481 46 2597 40 41 44 33 2481 46 2494 44 2482 44 2584 41 44 2421 46 60 2422 62 2489 40 41 44 2421 46 60 2598 62 2489 40 41 44 2421 46 60 2419 62 2489 40 41 44 2581 44 424 41 59 2599 40 2481 46 2491 44 2592 41 59 450 2592 59 125 437 2479 2600 40 2025 2481 41 123 2601 2602 61 2481 46 2603 40 41 59 2604 60 2605 62 2606 61 418 2604 60 2605 62 40 41 59 385 40 2087 2607 58 2481 46 2608 41 123 392 40 2607 46 2609 631 424 605 2607 46 2609 46 2610 40 41 631 424 41 123 2607 46 2609 46 2610 40 41 46 2611 40 2607 46 2609 44 2481 46 2612 44 2481 46 2613 44 2606 41 59 125 125 2606 46 2614 40 2602 46 2615 40 2602 46 2616 40 2602 46 2617 40 2602 46 2618 40 2481 46 2619 40 648 41 41 44 2481 46 2619 40 2008 41 41 44 2602 46 2620 40 2621 44 1500 41 41 41 41 59 2622 2623 61 2602 46 2624 40 1500 44 2606 46 2625 40 41 41 59 2479 2626 61 2602 46 2627 40 2602 46 2628 40 2629 40 2630 46 2631 41 41 44 2481 46 2619 40 2009 41 44 2602 46 2632 40 2633 46 2634 40 2481 46 2635 46 2636 40 41 44 2637 41 41 44 2421 46 60 2422 62 2638 40 41 44 2421 46 60 2639 62 2638 40 41 44 2421 46 60 2419 62 2638 40 41 44 2623 44 424 41 59 2640 40 2626 44 2481 46 2641 41 59 450 2626 59 125 457 2642 2643 40 2025 2481 41 123 392 40 33 2481 46 2644 46 2645 40 41 41 450 424 59 2646 60 2007 62 2647 61 418 2646 60 2007 62 40 41 59 385 40 2087 2648 58 2481 46 2649 41 123 392 40 2648 46 2650 614 424 605 2648 46 2651 614 424 41 2647 46 2652 40 2648 46 2653 46 2654 40 41 41 59 125 2419 2655 59 2656 2657 61 2481 46 2658 40 41 59 392 40 2647 46 2659 40 41 614 1500 41 450 424 59 392 40 2647 46 2659 40 41 614 1501 41 2655 61 2657 46 2660 40 2647 46 2661 40 1500 41 41 59 360 123 2421 60 2419 62 2662 61 2421 46 2663 40 41 59 385 40 404 2664 61 2647 46 2659 40 41 45 1501 59 2664 615 1500 59 2664 629 41 2662 61 2662 46 2665 40 2657 46 2660 40 2647 46 2661 40 2664 41 41 41 59 2655 61 2657 46 2666 40 424 44 2421 46 60 2419 62 2663 40 41 44 2662 41 59 125 2114 2667 61 2657 46 2668 40 2669 40 2481 46 2670 44 2671 46 2672 41 44 2421 46 2673 40 2655 41 41 59 2417 2674 61 40 2417 41 2481 46 2670 46 2661 40 41 59 2642 2675 61 2657 46 2676 40 2657 46 2677 40 2678 46 2679 44 2421 46 60 2114 62 2680 40 41 41 44 2481 46 2681 40 648 41 44 2682 40 2657 44 2481 46 2670 44 2674 46 2683 44 2421 46 60 2114 62 2673 40 2667 41 41 44 424 41 59 450 2675 59 125 437 2479 2684 40 2025 2481 44 2685 2686 44 2419 2420 44 2421 60 2419 62 2687 44 324 2688 41 123 2689 2690 61 2481 46 2691 40 41 59 2419 2692 59 2693 60 2694 62 2695 61 418 2693 60 2694 62 40 41 59 392 40 2688 41 123 2419 2696 61 2690 46 2697 40 2698 44 2690 46 2699 40 2690 46 2700 40 2481 46 2701 40 648 41 41 44 2481 46 2701 40 2008 41 41 41 59 2694 2702 61 2690 46 2703 40 2690 46 2704 40 2421 46 60 2419 62 2705 40 41 44 2690 46 2700 40 2481 46 2701 40 2009 41 41 44 2421 46 60 2419 62 2705 40 41 41 41 59 2706 2707 61 2690 46 2708 40 2696 44 2702 44 424 41 59 2695 46 2709 40 2707 41 59 125 385 40 2087 2710 58 2481 46 2711 41 123 392 40 2710 46 2712 631 424 605 2710 46 2712 46 2713 40 41 631 424 41 123 2710 46 2712 46 2713 40 41 46 2714 40 2710 46 2712 44 2481 46 2715 44 2481 46 2716 44 2695 44 2710 46 2717 44 648 41 59 125 125 2693 60 2419 62 2718 61 418 2693 60 2419 62 40 41 59 2685 2719 61 2481 46 2720 40 648 41 59 385 40 2087 2710 58 2481 46 2711 41 123 392 40 2710 46 2721 631 424 41 123 2695 46 2722 40 2690 46 2723 40 2690 46 2724 40 1500 41 44 2710 46 2725 44 2726 40 2690 44 2710 46 2727 44 2481 46 2728 41 44 2690 46 2729 40 2690 46 2730 40 2719 41 44 2710 46 2725 41 41 41 59 2695 46 2722 40 2690 46 2731 40 2690 46 2732 40 2733 44 2690 46 2729 40 2690 46 2730 40 2719 41 44 2710 46 2721 41 41 44 2690 46 2734 40 2690 46 2735 40 2690 46 2730 40 2710 46 2725 41 44 2690 46 2736 40 2737 40 2690 44 40 40 2417 41 2481 46 2738 46 2739 40 41 41 46 2740 41 44 2690 46 2729 40 2690 46 2730 40 40 40 2417 41 2481 46 2738 46 2739 40 41 41 46 2741 41 44 2710 46 2742 41 44 2421 46 60 2419 62 2743 40 41 41 41 41 44 424 41 41 59 125 392 40 2710 46 2721 631 424 606 40 2710 46 2744 631 424 605 2710 46 2744 46 2745 40 41 46 2746 40 41 41 41 123 2718 46 2747 40 2690 46 2748 40 2710 46 2749 41 41 59 125 360 123 2718 46 2750 40 2690 46 2751 40 2690 46 2752 40 2719 41 44 2710 46 2753 41 41 59 125 125 392 40 2688 41 123 2695 46 2754 40 2690 46 2755 40 2690 46 2756 40 2690 46 2757 40 2690 46 2758 40 2481 46 2720 40 648 41 41 44 2481 46 2720 40 2008 41 41 44 2690 46 2759 40 2760 44 1501 41 41 41 41 59 125 392 40 2686 614 424 41 123 2692 61 2690 46 2761 40 424 44 2421 46 60 2419 62 2762 40 41 44 2420 44 2718 46 2763 40 41 44 424 41 59 2695 46 2764 40 2690 46 2765 40 2692 41 41 59 125 360 123 2693 60 2419 62 2423 61 418 2693 60 2419 62 40 41 59 385 40 2422 2766 58 40 40 2417 41 2481 46 2767 46 2768 40 41 41 46 2769 41 123 2423 46 2770 40 2690 46 2771 40 2766 46 2772 41 41 59 125 2419 2773 61 2690 46 2774 40 40 40 2417 41 2481 46 2775 46 2768 40 41 41 46 2776 41 59 392 40 33 2481 46 2777 41 2773 61 2690 46 2778 40 2773 44 2481 46 2720 40 648 41 41 59 2419 2779 61 2690 46 2778 40 2773 44 2686 41 59 2692 61 2690 46 2780 40 2423 46 2781 40 41 44 2779 44 2718 46 2781 40 41 41 59 392 40 2420 402 2782 605 2783 46 2784 40 2785 40 2420 41 41 41 123 2695 46 2786 40 2690 46 2787 40 2692 41 41 59 125 360 123 2695 46 2788 40 2690 46 2789 40 2692 41 41 59 125 125 2790 2791 61 2690 46 2792 40 1500 44 2695 46 2793 40 41 41 59 2421 60 2114 62 2794 61 2481 46 2795 46 2796 40 41 63 2421 46 2797 40 2690 46 2798 40 2799 40 2481 46 2800 44 2801 46 2802 41 44 2421 46 60 2419 62 2803 40 41 41 41 58 2421 46 60 2114 62 2803 40 41 59 2642 2804 61 2643 40 2481 41 59 2479 2805 59 392 40 2804 631 424 605 2690 46 2806 40 41 41 123 2805 61 2690 46 2807 40 2690 46 2808 40 2809 40 2481 46 2810 41 44 2794 41 44 2481 46 2720 40 2481 46 2811 41 44 2420 44 2421 46 60 2422 62 2803 40 41 44 2804 44 2421 46 60 2642 62 2803 40 41 44 2687 44 2791 44 424 41 59 125 360 123 2805 61 2690 46 2812 40 2690 46 2813 40 2814 40 2481 46 2815 41 44 2794 41 44 2481 46 2720 40 2481 46 2816 41 44 2420 44 2421 46 60 2422 62 2803 40 41 44 2421 46 60 2642 62 2803 40 41 44 2687 44 2791 44 424 41 59 125 392 40 2686 614 424 41 2817 40 2481 46 2800 44 2805 41 59 450 2805 59 125 439 457 2479 2818 40 2685 2819 44 2116 2820 44 2421 60 2422 62 433 44 2025 2481 41 123 2821 2822 61 2820 46 2823 40 41 59 2642 2824 61 40 2642 41 2820 46 2825 40 41 59 621 2419 2826 61 2824 46 2826 59 2824 46 2826 61 424 59 621 2827 2828 61 2822 46 2829 40 424 41 59 2830 2831 61 2822 46 2832 40 1500 44 2421 46 60 2833 62 2834 40 2828 41 41 59 404 2835 61 2836 46 2837 124 2836 46 2838 59 2479 2839 61 2822 46 2840 40 2822 46 2841 40 2835 41 44 2819 44 2842 40 2822 44 2824 46 2843 44 2820 41 44 2844 40 2820 44 433 41 44 2421 46 60 2642 62 2845 40 41 44 2421 46 60 2419 62 2845 40 41 44 2831 44 424 41 59 621 2846 40 2839 44 2481 46 2847 41 59 621 2828 46 2018 61 2826 59 450 2839 59 125 439 2479 2848 40 2025 2481 41 123 621 621 2849 2850 61 2481 46 2851 40 41 59 2419 2852 59 392 40 2481 46 2853 41 123 2852 61 2850 46 2854 40 424 44 2421 46 60 2419 62 2855 40 41 44 2856 40 2850 44 2481 46 2857 44 2481 46 2858 40 2481 46 2859 41 44 380 44 2481 46 2423 41 44 2421 46 60 2419 62 2855 40 41 44 424 41 59 125 360 123 2852 61 2850 46 2860 40 424 44 2421 46 60 2419 62 2861 40 41 44 2862 40 2850 44 424 44 2481 46 2863 40 2481 46 2864 41 44 380 44 2481 46 2423 41 44 2421 46 60 2419 62 2861 40 41 44 424 41 59 40 40 2865 41 2852 41 46 2866 61 2850 46 2867 40 2481 46 2863 40 648 41 41 59 125 2868 2869 61 2850 46 2870 40 2852 41 59 2871 2872 61 2850 46 2873 40 1500 44 2421 46 60 2868 62 2874 40 2869 41 41 59 404 2875 61 2876 40 2481 46 2877 41 59 392 40 2481 46 2853 41 2875 635 2878 46 2879 59 2421 60 2114 62 2880 61 2421 46 2881 40 41 59 392 40 2481 46 2882 46 2883 40 41 41 2880 61 2421 46 2874 40 2850 46 2884 40 2885 40 2481 46 2886 44 2887 46 2888 41 44 2421 46 60 2419 62 2881 40 41 41 41 59 2421 60 2114 62 2889 61 2421 46 2881 40 41 59 392 40 2481 46 2882 46 2890 40 41 41 2889 61 2421 46 2874 40 2850 46 2884 40 2885 40 2481 46 2886 44 2887 46 2891 41 44 2421 46 60 2419 62 2881 40 41 41 41 59 2419 2420 61 2892 40 2850 44 2481 46 2886 44 2481 46 2893 40 41 44 33 2481 46 2853 44 2481 46 2894 44 2889 41 59 2479 2895 61 2850 46 2896 40 2850 46 2897 40 2875 44 2880 41 44 2481 46 2898 40 2481 46 2899 41 44 2420 44 2481 46 2900 40 41 44 2421 46 60 2642 62 2881 40 41 44 2421 46 60 2419 62 2881 40 41 44 2872 44 424 41 59 2901 40 2481 46 2886 44 2895 41 59 450 2895 59 125 439 492 2902 40 2025 2481 41 123 404 2903 61 2481 46 2904 46 2905 40 41 59 2906 46 2907 46 2421 60 2116 62 2908 61 418 2909 60 2116 62 40 41 59 385 40 2116 2910 58 2481 46 2911 46 2912 40 41 41 123 392 40 2910 46 2913 40 41 614 2914 46 2915 41 2908 46 2916 40 2910 41 59 125 2906 46 2907 46 2421 60 2642 62 2917 61 418 2909 60 2642 62 40 41 59 385 40 404 2918 61 2903 45 1501 59 2918 615 1500 59 2918 629 41 123 2087 2919 61 2481 46 2904 46 2920 40 2918 41 59 392 40 2919 46 2921 631 424 605 2919 46 2921 46 2922 40 41 631 424 41 123 2906 46 2907 46 2421 60 2116 62 2923 61 2919 46 2921 46 2922 40 41 46 2924 40 2919 46 2921 44 2481 46 2911 44 2481 46 2925 41 59 385 40 2116 2926 58 2923 41 123 2917 46 2927 40 40 2642 41 2926 46 2920 40 41 41 59 125 2919 46 2928 46 2929 40 2923 41 59 125 360 123 2116 2930 61 424 44 2931 61 424 59 385 40 2116 2932 58 2908 41 123 2685 2933 61 40 40 2642 41 2932 46 2920 40 41 41 46 2934 59 392 40 2933 46 2935 40 2919 46 2936 41 41 2930 61 2932 59 392 40 2933 46 2935 40 2919 46 2937 41 41 2931 61 2932 59 125 2938 2939 61 2481 46 2940 40 41 59 392 40 2930 614 424 41 123 2941 2942 61 2939 46 2943 40 2944 46 2945 41 59 2642 2946 61 2939 46 2947 40 2942 44 2919 46 2948 44 2949 40 2939 44 2919 46 2950 44 2481 46 2951 41 44 424 41 59 2930 61 2952 40 2481 46 2911 44 2946 41 59 2917 46 2953 40 2946 41 59 125 392 40 2931 614 424 605 2919 46 2954 631 424 41 123 2955 2956 61 2939 46 2957 40 2958 46 2959 41 59 2642 2960 61 2939 46 2961 40 2956 44 2919 46 2954 44 2939 46 2962 40 2963 41 44 424 41 59 2964 40 2481 46 2911 44 2960 41 59 2917 46 2965 40 2960 41 59 125 2919 46 2966 46 2967 40 2930 41 59 125 125 385 40 2642 2968 58 2917 41 2969 40 2968 44 2481 46 2970 41 59 125 439 492 2971 40 2025 2481 44 2087 2972 44 2007 2483 41 123 324 2973 61 2974 40 2972 46 2975 41 59 392 40 2972 46 2976 614 424 606 2972 46 2976 46 2977 40 41 614 424 41 123 2978 40 2481 44 2972 44 2973 44 2483 41 59 125 360 123 2972 46 2976 46 2977 40 41 46 2979 40 2481 44 2972 46 2976 44 2973 41 59 125 125 437 492 2980 40 2025 2481 44 2087 2972 44 324 2981 44 2007 2483 41 123 2116 2820 61 2972 46 2982 46 2983 40 1500 41 59 2007 2984 61 33 2483 46 2985 40 41 63 2483 58 2481 46 2986 63 648 58 648 59 2007 2987 61 2988 46 2989 40 2481 46 2990 44 2984 44 2972 46 2991 46 2992 40 41 41 59 2685 2993 61 2481 46 2994 46 2995 40 2987 41 59 385 40 2116 2996 58 2481 46 2994 46 2997 40 41 41 123 392 40 2996 46 2998 40 41 631 2999 46 3000 41 344 59 2479 3001 61 40 2479 41 2996 46 2983 40 41 59 2685 3002 61 3001 46 2991 59 392 40 3002 46 3003 40 2993 41 605 33 3004 40 2820 44 3001 41 41 450 59 125 3005 3006 61 2820 46 3007 40 41 59 2421 60 2114 62 3008 61 3009 46 3010 40 2972 46 3011 41 59 2479 3012 61 424 59 392 40 2481 46 3013 46 3014 40 41 605 3006 46 3015 40 41 41 123 2114 3016 61 3006 46 3017 40 3018 40 2481 46 2990 44 3019 46 3020 41 44 2421 46 60 2419 62 3021 40 3006 46 3022 40 2987 46 2992 40 41 41 41 41 59 2417 3023 61 40 2417 41 2481 46 2994 46 2983 40 41 59 2419 3024 61 3025 40 3006 44 2481 46 2994 44 3023 46 3026 44 2421 46 60 2114 62 3021 40 3016 41 41 59 2642 3027 61 3006 46 3028 40 3006 46 3029 40 3030 46 3031 44 2421 46 60 2114 62 3032 40 41 41 44 2481 46 2994 46 2995 40 648 41 44 3024 44 424 41 59 3012 61 3033 46 3034 40 3035 40 2481 46 3036 41 44 2981 44 2820 44 3006 44 2987 44 2972 46 2991 44 2972 46 3037 44 2481 46 3038 44 2481 46 2990 44 3008 44 2972 46 3039 44 3027 41 59 125 392 40 3012 614 424 41 3012 61 3040 46 3041 40 3042 40 2481 46 3043 41 44 2981 44 2820 44 3006 44 2987 44 2972 46 2991 44 2972 46 3044 44 2481 46 3045 44 2481 46 2990 44 3008 44 2972 46 3046 41 59 3047 40 3012 44 2481 46 2990 41 59 392 40 2481 46 2990 46 3048 40 41 46 3049 40 41 614 3050 46 3051 41 123 3052 40 2972 46 3011 46 3048 40 41 44 3012 44 2972 46 2991 46 2992 40 41 41 59 125 360 123 3053 40 2972 46 3011 44 3012 44 3054 46 3055 44 473 41 59 125 3056 40 2481 46 2994 44 3012 41 59 125 437 492 3057 40 2116 388 44 2479 3058 44 2007 3059 41 123 474 123 3060 3061 61 40 40 3060 41 388 46 3062 40 41 46 3063 40 41 41 59 2007 3064 61 3065 46 3066 40 3061 44 388 46 3063 40 41 41 59 2007 3067 61 3068 40 3069 40 3064 44 3059 41 41 59 3065 46 3070 40 3061 44 3058 44 3067 41 59 125 329 40 3071 3072 41 123 125 125 439 2116 3073 40 2025 2481 41 123 621 621 3074 3075 61 2481 46 3076 40 41 59 404 3077 61 3078 40 2481 46 3079 41 59 392 40 2481 46 3080 41 3077 635 3081 46 3082 59 3083 3084 61 3075 46 3085 40 3077 41 59 2417 3086 61 3075 46 3087 40 3084 44 2481 46 3088 40 41 44 2481 46 3089 40 41 44 424 44 2421 46 60 2419 62 3090 40 41 44 2421 46 60 3091 62 3090 40 41 41 59 3092 40 3086 44 2481 46 3093 41 59 450 3094 40 2481 46 3095 44 3086 41 59 125 437 492 3096 40 2087 2972 44 2116 3097 41 123 385 40 2116 3098 58 3097 46 3099 40 41 41 123 392 40 33 3100 40 3101 46 334 44 3098 41 41 344 59 2112 60 3101 62 3102 61 3103 40 3101 46 334 44 3098 41 59 2972 46 3104 61 3102 46 3105 40 41 59 2972 46 3106 61 3098 59 3107 40 3098 44 3101 46 334 41 59 450 59 125 125 618 437 3108 3109 40 2116 3097 44 2007 3110 41 123 385 40 2116 3111 58 3097 46 3112 40 41 41 123 392 40 33 3113 40 3114 46 334 44 3111 41 41 344 59 2685 3115 61 3097 46 3116 40 41 614 3117 46 3118 63 3119 40 3097 41 58 40 40 2642 41 3097 46 3120 40 41 41 46 3121 59 2112 60 3114 62 3122 61 3123 40 3114 46 334 44 3111 41 59 3114 3124 61 3122 46 3125 40 41 59 3126 40 3111 44 3114 46 334 41 59 2007 3127 61 3124 46 3128 40 41 59 392 40 3127 46 3129 40 41 41 123 392 40 3130 46 3131 46 3132 40 3097 46 3133 40 41 46 3134 40 3135 46 3136 41 41 41 123 3097 46 3137 40 648 41 59 3127 61 3115 46 3138 40 41 59 125 360 123 3127 61 3139 40 3115 46 3140 40 41 41 59 392 40 3127 614 424 41 123 3097 46 3141 40 648 41 59 3127 61 3115 46 3140 40 41 59 125 125 125 2685 3142 61 3097 46 3143 40 3127 41 59 2419 3144 61 424 59 392 40 3097 46 3120 40 41 402 2642 41 123 3144 61 40 40 2642 41 3097 46 3120 40 41 41 46 3145 59 125 2007 3121 61 424 59 2421 60 2419 62 3146 61 2421 46 3147 40 41 59 392 40 3144 402 3148 41 123 3146 61 40 40 3148 41 3144 41 46 3149 59 3144 61 40 40 3148 41 3144 41 46 3150 59 125 3121 61 3144 46 3151 40 41 59 2007 3152 61 3153 46 3120 40 41 46 3154 40 3121 41 59 3155 3156 61 3153 46 3120 40 41 46 3157 40 3152 44 3097 41 59 392 40 3156 614 424 41 123 3097 46 3158 40 648 43 3121 43 648 41 59 450 424 59 125 450 418 3108 40 3111 44 3142 44 3115 44 3146 44 3152 44 3156 44 3124 46 3159 40 41 44 3110 41 59 125 450 424 59 125 125 
29303,Java,"public class JavacTreeMaker {
	private final TreeMaker tm;
	
	public JavacTreeMaker(TreeMaker tm) {
		this.tm = tm;
	}
	
	public TreeMaker getUnderlyingTreeMaker() {
		return tm;
	}
	
	public JavacTreeMaker at(int pos) {
		tm.at(pos);
		return this;
	}
	
	private static final class FieldId<J> {
		private final Class<?> owner;
		private final String name;
		private final Class<J> fieldType;
		
		FieldId(Class<?> owner, String name, Class<J> fieldType) {
			this.owner = owner;
			this.name = name;
			this.fieldType = fieldType;
		}
	}
	
	private static final class MethodId<J> {
		private final Class<?> owner;
		private final String name;
		private final Class<J> returnType;
		private final Class<?>[] paramTypes;
		
		MethodId(Class<?> owner, String name, Class<J> returnType, Class<?>... types) {
			this.owner = owner;
			this.name = name;
			this.paramTypes = types;
			this.returnType = returnType;
		}
		
		@Override public String toString() {
			StringBuilder out = new StringBuilder();
			out.append(returnType.getName()).append("" "").append(owner.getName()).append(""."").append(name).append(""("");
			boolean f = true;
			for (Class<?> p : paramTypes) {
				if (f) f = false;
				else out.append("", "");
				out.append(p.getName());
			}
			return out.append("")"").toString();
		}
	}
	
	private static class SchroedingerType {
		final Object value;
		
		private SchroedingerType(Object value) {
			this.value = value;
		}
		
		@Override public int hashCode() {
			return value == null ? -1 : value.hashCode();
		}
		
		@Override public boolean equals(Object obj) {
			if (obj instanceof SchroedingerType) {
				Object other = ((SchroedingerType) obj).value;
				return value == null ? other == null : value.equals(other);
			}
			return false;
		}
		
		static Object getFieldCached(ConcurrentMap<String, Object> cache, String className, String fieldName) {
			Object value = cache.get(fieldName);
			if (value != null) return value;
			try {
				value = Permit.getField(Class.forName(className), fieldName).get(null);
			} catch (NoSuchFieldException e) {
				throw Javac.sneakyThrow(e);
			} catch (IllegalAccessException e) {
				throw Javac.sneakyThrow(e);
			} catch (ClassNotFoundException e) {
				throw Javac.sneakyThrow(e);
			}
			
			cache.putIfAbsent(fieldName, value);
			return value;
		}
		
		private static Field NOSUCHFIELDEX_MARKER;
		static {
			try {
				NOSUCHFIELDEX_MARKER = Permit.getField(SchroedingerType.class, ""NOSUCHFIELDEX_MARKER"");
			} catch (NoSuchFieldException e) {
				throw Javac.sneakyThrow(e);
			}
		}
		
		static Object getFieldCached(ConcurrentMap<Class<?>, Field> cache, Object ref, String fieldName) throws NoSuchFieldException {
			Class<?> c = ref.getClass();
			Field field = cache.get(c);
			if (field == null) {
				try {
					field = Permit.getField(c, fieldName);
				} catch (NoSuchFieldException e) {
					cache.putIfAbsent(c, NOSUCHFIELDEX_MARKER);
					throw Javac.sneakyThrow(e);
				}
				Permit.setAccessible(field);
				Field old = cache.putIfAbsent(c, field);
				if (old != null) field = old;
			}
			
			if (field == NOSUCHFIELDEX_MARKER) throw new NoSuchFieldException(fieldName);
			try {
				return field.get(ref);
			} catch (IllegalAccessException e) {
				throw Javac.sneakyThrow(e);
			}
		}
	}
	
	public static class TypeTag extends SchroedingerType {
		private static final ConcurrentMap<String, Object> TYPE_TAG_CACHE = new ConcurrentHashMap<String, Object>();
		private static final ConcurrentMap<Class<?>, Field> FIELD_CACHE = new ConcurrentHashMap<Class<?>, Field>();
		private static final Method TYPE_TYPETAG_METHOD;
		
		static {
			Method m = null;
			try {
				m = Permit.getMethod(Type.class, ""getTag"");
			} catch (NoSuchMethodException e) {}
			TYPE_TYPETAG_METHOD = m;
		}
		
		private TypeTag(Object value) {
			super(value);
		}
		
		public static TypeTag typeTag(JCTree o) {
			try {
				return new TypeTag(getFieldCached(FIELD_CACHE, o, ""typetag""));
			} catch (NoSuchFieldException e) {
				throw Javac.sneakyThrow(e);
			}
		}
		
		public static TypeTag typeTag(Type t) {
			if (t == null) return Javac.CTC_VOID;
			try {
				return new TypeTag(getFieldCached(FIELD_CACHE, t, ""tag""));
			} catch (NoSuchFieldException e) {
				if (TYPE_TYPETAG_METHOD == null) throw new IllegalStateException(""Type "" + t.getClass() + "" has neither 'tag' nor getTag()"");
				try {
					return new TypeTag(TYPE_TYPETAG_METHOD.invoke(t));
				} catch (IllegalAccessException ex) {
					throw Javac.sneakyThrow(ex);
				} catch (InvocationTargetException ex) {
					throw Javac.sneakyThrow(ex.getCause());
				}
			}
		}
		
		public static TypeTag typeTag(String identifier) {
			return new TypeTag(getFieldCached(TYPE_TAG_CACHE, Javac.getJavaCompilerVersion() < 8 ? ""com.sun.tools.javac.code.TypeTags"" : ""com.sun.tools.javac.code.TypeTag"", identifier));
		}
	}
	
	public static class TreeTag extends SchroedingerType {
		private static final ConcurrentMap<String, Object> TREE_TAG_CACHE = new ConcurrentHashMap<String, Object>();
		private static final Field TAG_FIELD;
		private static final Method TAG_METHOD;
		private static final MethodId<Integer> OP_PREC = MethodId(TreeInfo.class, ""opPrec"", int.class, TreeTag.class);
		
		static {
			Method m = null;
			try {
				m = Permit.getMethod(JCTree.class, ""getTag"");
			} catch (NoSuchMethodException e) {}
			
			if (m != null) {
				TAG_FIELD = null;
				TAG_METHOD = m;
			} else {
				Field f = null;
				try {
					f = Permit.getField(JCTree.class, ""tag"");
				} catch (NoSuchFieldException e) {}
				TAG_FIELD = f;
				TAG_METHOD = null;
			}
		}
		
		private TreeTag(Object value) {
			super(value);
		}
		
		public static TreeTag treeTag(JCTree o) {
			try {
				if (TAG_METHOD != null) return new TreeTag(TAG_METHOD.invoke(o));
				else return new TreeTag(TAG_FIELD.get(o));
			} catch (InvocationTargetException e) {
				throw Javac.sneakyThrow(e.getCause());
			} catch (IllegalAccessException e) {
				throw Javac.sneakyThrow(e);
			}
		}
		
		public static TreeTag treeTag(String identifier) {
			return new TreeTag(getFieldCached(TREE_TAG_CACHE, Javac.getJavaCompilerVersion() < 8 ? ""com.sun.tools.javac.tree.JCTree"" : ""com.sun.tools.javac.tree.JCTree$Tag"", identifier));
		}
		
		public int getOperatorPrecedenceLevel() {
			return invokeAny(null, OP_PREC, value);
		}
		
		public boolean isPrefixUnaryOp() {
			return Javac.CTC_NEG.equals(this) || Javac.CTC_POS.equals(this) || Javac.CTC_NOT.equals(this) || Javac.CTC_COMPL.equals(this) || Javac.CTC_PREDEC.equals(this) || Javac.CTC_PREINC.equals(this);
		}
	}
	
	static <J> MethodId<J> MethodId(Class<?> owner, String name, Class<J> returnType, Class<?>... types) {
		return new MethodId<J>(owner, name, returnType, types);
	}
	
	/**
	 * Creates a new method ID based on the name of the method to invoke, the return type of that method, and the types of the parameters.
	 * 
	 * A method matches if the return type matches, and for each parameter the following holds:
	 * 
	 * Either (A) the type listed here is the same as, or a subtype of, the type of the method in javac's TreeMaker, or
	 *  (B) the type listed here is a subtype of SchroedingerType.
	 */
	static <J> MethodId<J> MethodId(String name, Class<J> returnType, Class<?>... types) {
		return new MethodId<J>(TreeMaker.class, name, returnType, types);
	}
	
	/**
	 * Creates a new method ID based on the name of a method in this class, assuming the name of the method to invoke in TreeMaker has the same name,
	 * the same return type, and the same parameters (under the same rules as the other MethodId method).
	 */
	static <J> MethodId<J> MethodId(String name) {
		for (Method m : JavacTreeMaker.class.getDeclaredMethods()) {
			if (m.getName().equals(name)) {
				@SuppressWarnings(""unchecked"") Class<J> r = (Class<J>) m.getReturnType();
				Class<?>[] p = m.getParameterTypes();
				return new MethodId<J>(TreeMaker.class, name, r, p);
			}
		}
		
		throw new InternalError(""Not found: "" + name);
	}
	
	static <J> FieldId<J> FieldId(Class<?> owner, String name, Class<J> fieldType) {
		return new FieldId<J>(owner, name, fieldType);
	}
	
	private static final ConcurrentHashMap<FieldId<?>, Object> FIELD_CACHE = new ConcurrentHashMap<FieldId<?>, Object>();
	
	private static boolean has(FieldId<?> f) {
		Object field = FIELD_CACHE.get(f);
		if (field == REFLECTIVE_ITEM_NOT_FOUND) return false;
		if (field instanceof Field) return true;
		
		try {
			return getFromCache(f) != REFLECTIVE_ITEM_NOT_FOUND;
		} catch (IllegalStateException e) {
			return false;
		}
	}
	
	private static <J> J get(Object owner, FieldId<J> f) {
		Field field = getFromCache(f);
		try {
			return f.fieldType.cast(field.get(owner));
		} catch (IllegalAccessException e) {
			throw Javac.sneakyThrow(e);
		}
	}
	
	private static <J> void set(Object owner, FieldId<J> f, J val) {
		Field field = getFromCache(f);
		try {
			field.set(owner, val);
		} catch (IllegalAccessException e) {
			throw Javac.sneakyThrow(e);
		} catch (IllegalArgumentException e) {
			System.err.println(""Type mismatch for: "" + field);
			throw e;
		}
	}
	
	private static Field getFromCache(FieldId<?> f) {
		Object s = FIELD_CACHE.get(f);
		if (s == null) s = addToCache(f);
		if (s == REFLECTIVE_ITEM_NOT_FOUND) throw new IllegalStateException(""Lombok TreeMaker frontend issue: no match when looking for field: "" +  f);
		return (Field) s;
	}
	
	private static Object addToCache(FieldId<?> f) {
		for (Field field : f.owner.getDeclaredFields()) {
			if (f.name.equals(field.getName())) {
				if (!Modifier.isPublic(field.getModifiers())) field.setAccessible(true);
				return FIELD_CACHE.putIfAbsent(f, field);
			}
		}
		
		return FIELD_CACHE.putIfAbsent(f, REFLECTIVE_ITEM_NOT_FOUND);
	}
	
	private static final Object REFLECTIVE_ITEM_NOT_FOUND = new Object[0];
	private static final Object REFLECTIVE_ITEM_MULTIPLE_FOUND = new Object[0];
	private static final ConcurrentHashMap<MethodId<?>, Object> METHOD_CACHE = new ConcurrentHashMap<MethodId<?>, Object>();
	
	private boolean has(MethodId<?> m) {
		Object method = METHOD_CACHE.get(m);
		if (method == REFLECTIVE_ITEM_NOT_FOUND) return false;
		if (method instanceof Method) return true;
		
		try {
			return getFromCache(m) != REFLECTIVE_ITEM_NOT_FOUND;
		} catch (IllegalStateException e) {
			return false;
		}
	}
	
	private <J> J invoke(MethodId<J> m, Object... args) {
		return invokeAny(tm, m, args);
	}
	
	@SuppressWarnings(""unchecked"") private static <J> J invokeAny(Object owner, MethodId<J> m, Object... args) {
		Method method = getFromCache(m);
		try {
			if (m.returnType.isPrimitive()) {
				return (J) method.invoke(owner, args);
			}
			return m.returnType.cast(method.invoke(owner, args));
		} catch (InvocationTargetException e) {
			throw Javac.sneakyThrow(e.getCause());
		} catch (IllegalAccessException e) {
			throw Javac.sneakyThrow(e);
		} catch (IllegalArgumentException e) {
			System.err.println(""Type mismatch for: "" + method);
			throw e;
		}
	}
	
	private static boolean tryResolve(MethodId<?> m) {
		Object s = METHOD_CACHE.get(m);
		if (s == null) s = addToCache(m);
		if (s instanceof Method) return true;
		return false;
	}
	
	private static Method getFromCache(MethodId<?> m) {
		Object s = METHOD_CACHE.get(m);
		if (s == null) s = addToCache(m);
		if (s == REFLECTIVE_ITEM_MULTIPLE_FOUND) throw new IllegalStateException(""Lombok TreeMaker frontend issue: multiple matches when looking for method: "" + m);
		if (s == REFLECTIVE_ITEM_NOT_FOUND) throw new IllegalStateException(""Lombok TreeMaker frontend issue: no match when looking for method: "" + m);
		return (Method) s;
	}
	
	private static Object addToCache(MethodId<?> m) {
		Method found = null;
		
		outer:
		for (Method method : m.owner.getDeclaredMethods()) {
			if (!m.name.equals(method.getName())) continue;
			Class<?>[] t = method.getParameterTypes();
			if (t.length != m.paramTypes.length) continue;
			for (int i = 0; i < t.length; i++) {
				if (Symbol.class.isAssignableFrom(t[i])) continue outer;
				if (!SchroedingerType.class.isAssignableFrom(m.paramTypes[i])) {
					if (t[i].isPrimitive()) {
						if (t[i] != m.paramTypes[i]) continue outer;
					} else {
						if (!t[i].isAssignableFrom(m.paramTypes[i])) continue outer;
					}
				}
			}
			if (found == null) found = method;
			else {
				METHOD_CACHE.putIfAbsent(m, REFLECTIVE_ITEM_MULTIPLE_FOUND);
				return REFLECTIVE_ITEM_MULTIPLE_FOUND;
			}
		}
		if (found == null) {
			METHOD_CACHE.putIfAbsent(m, REFLECTIVE_ITEM_NOT_FOUND);
			return REFLECTIVE_ITEM_NOT_FOUND;
		}
		Permit.setAccessible(found);
		Object marker = METHOD_CACHE.putIfAbsent(m, found);
		if (marker == null) return found;
		return marker;
	}
	
	//javac versions: 6-8
	private static final MethodId<JCCompilationUnit> TopLevel = MethodId(""TopLevel"");
	public JCCompilationUnit TopLevel(List<JCAnnotation> packageAnnotations, JCExpression pid, List<JCTree> defs) {
		return invoke(TopLevel, packageAnnotations, pid, defs);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCImport> Import = MethodId(""Import"");
	public JCImport Import(JCTree qualid, boolean staticImport) {
		return invoke(Import, qualid, staticImport);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCClassDecl> ClassDef = MethodId(""ClassDef"");
	public JCClassDecl ClassDef(JCModifiers mods, Name name, List<JCTypeParameter> typarams, JCExpression extending, List<JCExpression> implementing, List<JCTree> defs) {
		return invoke(ClassDef, mods, name, typarams, extending, implementing, defs);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCMethodDecl> MethodDef = MethodId(""MethodDef"", JCMethodDecl.class, JCModifiers.class, Name.class, JCExpression.class, List.class, List.class, List.class, JCBlock.class, JCExpression.class);
	public JCMethodDecl MethodDef(JCModifiers mods, Name name, JCExpression resType, List<JCTypeParameter> typarams, List<JCVariableDecl> params, List<JCExpression> thrown, JCBlock body, JCExpression defaultValue) {
		return invoke(MethodDef, mods, name, resType, typarams, params, thrown, body, defaultValue);
	}
	
	//javac versions: 8
	private static final MethodId<JCMethodDecl> MethodDefWithRecvParam = MethodId(""MethodDef"", JCMethodDecl.class, JCModifiers.class, Name.class, JCExpression.class, List.class, JCVariableDecl.class, List.class, List.class, JCBlock.class, JCExpression.class);
	public boolean hasMethodDefWithRecvParam() {
		return has(MethodDefWithRecvParam);
	}
	
	public JCMethodDecl MethodDefWithRecvParam(JCModifiers mods, Name name, JCExpression resType, List<JCTypeParameter> typarams, JCVariableDecl recvparam, List<JCVariableDecl> params, List<JCExpression> thrown, JCBlock body, JCExpression defaultValue) {
		return invoke(MethodDefWithRecvParam, mods, name, resType, typarams, recvparam, params, thrown, body, defaultValue);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCVariableDecl> VarDef = MethodId(""VarDef"");
	public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init) {
		JCVariableDecl varDef = invoke(VarDef, mods, name, vartype, init);
		// We use 'position of the type is -1' as indicator in delombok that the original node was written using JDK10's 'var' feature, because javac desugars 'var' to the real type and doesn't leave any markers other than the
		// node position to indicate that it did so. Unfortunately, that means vardecls we generate look like 'var' to delombok. Adjust the position to avoid this.
		if (varDef.vartype != null && varDef.vartype.pos == -1) varDef.vartype.pos = 0;
		return varDef;
	}
	
	//javac versions: 8
	private static final MethodId<JCVariableDecl> ReceiverVarDef = MethodId(""ReceiverVarDef"");
	public JCVariableDecl ReceiverVarDef(JCModifiers mods, JCExpression name, JCExpression vartype) {
		return invoke(ReceiverVarDef, mods, name, vartype);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCSkip> Skip = MethodId(""Skip"");
	public JCSkip Skip() {
		return invoke(Skip);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCBlock> Block = MethodId(""Block"");
	public JCBlock Block(long flags, List<JCStatement> stats) {
		return invoke(Block, flags, stats);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCDoWhileLoop> DoLoop = MethodId(""DoLoop"");
	public JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond) {
		return invoke(DoLoop, body, cond);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCWhileLoop> WhileLoop = MethodId(""WhileLoop"");
	public JCWhileLoop WhileLoop(JCExpression cond, JCStatement body) {
		return invoke(WhileLoop, cond, body);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCForLoop> ForLoop = MethodId(""ForLoop"");
	public JCForLoop ForLoop(List<JCStatement> init, JCExpression cond, List<JCExpressionStatement> step, JCStatement body) {
		return invoke(ForLoop, init, cond, step, body);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCEnhancedForLoop> ForeachLoop = MethodId(""ForeachLoop"");
	public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
		return invoke(ForeachLoop, var, expr, body);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCLabeledStatement> Labelled = MethodId(""Labelled"");
	public JCLabeledStatement Labelled(Name label, JCStatement body) {
		return invoke(Labelled, label, body);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCSwitch> Switch = MethodId(""Switch"");
	public JCSwitch Switch(JCExpression selector, List<JCCase> cases) {
		return invoke(Switch, selector, cases);
	}
	
	//javac versions: 6-11
	private static final MethodId<JCCase> Case11 = MethodId(""Case"", JCCase.class, JCExpression.class, com.sun.tools.javac.util.List.class);
	//javac version: 12+
	public static class Case12 {
		private static final Class<?> CASE_KIND_CLASS = classForName(TreeMaker.class, ""com.sun.source.tree.CaseTree$CaseKind"");
		static final MethodId<JCCase> Case12 = MethodId(""Case"", JCCase.class, CASE_KIND_CLASS, com.sun.tools.javac.util.List.class, com.sun.tools.javac.util.List.class, JCTree.class);
		static final Object CASE_KIND_STATEMENT = CASE_KIND_CLASS.getEnumConstants()[0];
	}
	
	static Class<?> classForName(Class<?> context, String name) {
		try {
			return context.getClassLoader().loadClass(name);
		} catch (ClassNotFoundException e) {
			Error x = new NoClassDefFoundError(e.getMessage());
			x.setStackTrace(e.getStackTrace());
			throw x;
		}
	}
	
	public JCCase Case(JCExpression pat, List<JCStatement> stats) {
		if (tryResolve(Case11)) return invoke(Case11, pat, stats);
		List<JCTree> labels;
		if (pat == null) {
			labels = tryResolve(DefaultCaseLabel) ? List.of(DefaultCaseLabel()) : List.<JCTree>nil();
		} else {
			labels = List.<JCTree>of(pat);
		}
		return invoke(Case12.Case12, Case12.CASE_KIND_STATEMENT, labels, stats, null);
	}
	
	//javac versions: 17
	private static final MethodId<JCTree> DefaultCaseLabel = MethodId(""DefaultCaseLabel"", JCTree.class);
	public JCTree DefaultCaseLabel() {
		return invoke(DefaultCaseLabel);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCSynchronized> Synchronized = MethodId(""Synchronized"");
	public JCSynchronized Synchronized(JCExpression lock, JCBlock body) {
		return invoke(Synchronized, lock, body);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCTry> Try = MethodId(""Try"", JCTry.class, JCBlock.class, List.class, JCBlock.class);
	public JCTry Try(JCBlock body, List<JCCatch> catchers, JCBlock finalizer) {
		return invoke(Try, body, catchers, finalizer);
	}
	
	//javac versions: 7-8
	private static final MethodId<JCTry> TryWithResources = MethodId(""Try"", JCTry.class, List.class, JCBlock.class, List.class, JCBlock.class);
	public JCTry Try(List<JCTree> resources, JCBlock body, List<JCCatch> catchers, JCBlock finalizer) {
		return invoke(TryWithResources, resources, body, catchers, finalizer);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCCatch> Catch = MethodId(""Catch"");
	public JCCatch Catch(JCVariableDecl param, JCBlock body) {
		return invoke(Catch, param, body);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCConditional> Conditional = MethodId(""Conditional"");
	public JCConditional Conditional(JCExpression cond, JCExpression thenpart, JCExpression elsepart) {
		return invoke(Conditional, cond, thenpart, elsepart);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCIf> If = MethodId(""If"");
	public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart) {
		return invoke(If, cond, thenpart, elsepart);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCExpressionStatement> Exec = MethodId(""Exec"");
	public JCExpressionStatement Exec(JCExpression expr) {
		return invoke(Exec, expr);
	}
	
	//javac version: 6-11
	private static final MethodId<JCBreak> Break11 = MethodId(""Break"", JCBreak.class, Name.class);
	//javac version: 12+
	private static final MethodId<JCBreak> Break12 = MethodId(""Break"", JCBreak.class, JCExpression.class);
	
	public JCBreak Break(Name label) {
		if (tryResolve(Break11)) return invoke(Break11, label);
		return invoke(Break12, label != null ? Ident(label) : null);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCContinue> Continue = MethodId(""Continue"");
	public JCContinue Continue(Name label) {
		return invoke(Continue, label);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCReturn> Return = MethodId(""Return"");
	public JCReturn Return(JCExpression expr) {
		return invoke(Return, expr);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCThrow> Throw = MethodId(""Throw"");
	public JCThrow Throw(JCExpression expr) {
		return invoke(Throw, expr);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCAssert> Assert = MethodId(""Assert"");
	public JCAssert Assert(JCExpression cond, JCExpression detail) {
		return invoke(Assert, cond, detail);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCMethodInvocation> Apply = MethodId(""Apply"");
	public JCMethodInvocation Apply(List<JCExpression> typeargs, JCExpression fn, List<JCExpression> args) {
		return invoke(Apply, typeargs, fn, args);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCNewClass> NewClass = MethodId(""NewClass"");
	public JCNewClass NewClass(JCExpression encl, List<JCExpression> typeargs, JCExpression clazz, List<JCExpression> args, JCClassDecl def) {
		return invoke(NewClass, encl, typeargs, clazz, args, def);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCNewArray> NewArray = MethodId(""NewArray"");
	public JCNewArray NewArray(JCExpression elemtype, List<JCExpression> dims, List<JCExpression> elems) {
		return invoke(NewArray, elemtype, dims, elems);
	}
	
	//javac versions: 8
//	private static final MethodId<JCLambda> Lambda = MethodId(""Lambda"");
//	public JCLambda Lambda(List<JCVariableDecl> params, JCTree body) {
//		return invoke(Lambda, params, body);
//	}
	
	//javac versions: 6-8
	private static final MethodId<JCParens> Parens = MethodId(""Parens"");
	public JCParens Parens(JCExpression expr) {
		return invoke(Parens, expr);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCAssign> Assign = MethodId(""Assign"");
	public JCAssign Assign(JCExpression lhs, JCExpression rhs) {
		return invoke(Assign, lhs, rhs);
	}
	
	//javac versions: 6-8
	//opcode = [6-7] int  [8] JCTree.Tag
	private static final MethodId<JCAssignOp> Assignop = MethodId(""Assignop"");
	public JCAssignOp Assignop(TreeTag opcode, JCTree lhs, JCTree rhs) {
		return invoke(Assignop, opcode.value, lhs, rhs);
	}
	
	//javac versions: 6-8
	//opcode = [6-7] int  [8] JCTree.Tag
	private static final MethodId<JCUnary> Unary = MethodId(""Unary"");
	public JCUnary Unary(TreeTag opcode, JCExpression arg) {
		return invoke(Unary, opcode.value, arg);
	}
	
	//javac versions: 6-8
	//opcode = [6-7] int  [8] JCTree.Tag
	private static final MethodId<JCBinary> Binary = MethodId(""Binary"");
	public JCBinary Binary(TreeTag opcode, JCExpression lhs, JCExpression rhs) {
		return invoke(Binary, opcode.value, lhs, rhs);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCTypeCast> TypeCast = MethodId(""TypeCast"");
	public JCTypeCast TypeCast(JCTree expr, JCExpression type) {
		return invoke(TypeCast, expr, type);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCInstanceOf> TypeTest = MethodId(""TypeTest"");
	public JCInstanceOf TypeTest(JCExpression expr, JCTree clazz) {
		return invoke(TypeTest, expr, clazz);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCArrayAccess> Indexed = MethodId(""Indexed"");
	public JCArrayAccess Indexed(JCExpression indexed, JCExpression index) {
		return invoke(Indexed, indexed, index);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCFieldAccess> Select = MethodId(""Select"");
	public JCFieldAccess Select(JCExpression selected, Name selector) {
		return invoke(Select, selected, selector);
	}
	
	//javac versions: 8
//	private static final MethodId<JCMemberReference> Reference = MethodId(""Reference"");
//	public JCMemberReference Reference(JCMemberReference.ReferenceMode mode, Name name, JCExpression expr, List<JCExpression> typeargs) {
//		return invoke(Reference, mode, name, expr, typeargs);
//	}
	
	//javac versions: 6-8
	private static final MethodId<JCIdent> Ident = MethodId(""Ident"", JCIdent.class, Name.class);
	public JCIdent Ident(Name idname) {
		return invoke(Ident, idname);
	}
	
	//javac versions: 6-8
	//tag = [6-7] int  [8] TypeTag
	private static final MethodId<JCLiteral> Literal = MethodId(""Literal"", JCLiteral.class, TypeTag.class, Object.class);
	public JCLiteral Literal(TypeTag tag, Object value) {
		return invoke(Literal, tag.value, value);
	}
	
	//javac versions: 6-8
	//typetag = [6-7] int  [8] TypeTag
	private static final MethodId<JCPrimitiveTypeTree> TypeIdent = MethodId(""TypeIdent"");
	public JCPrimitiveTypeTree TypeIdent(TypeTag typetag) {
		return invoke(TypeIdent, typetag.value);
	}
	//javac versions: 6-8
	private static final MethodId<JCArrayTypeTree> TypeArray = MethodId(""TypeArray"");
	public JCArrayTypeTree TypeArray(JCExpression elemtype) {
		return invoke(TypeArray, elemtype);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCTypeApply> TypeApply = MethodId(""TypeApply"");
	public JCTypeApply TypeApply(JCExpression clazz, List<JCExpression> arguments) {
		return invoke(TypeApply, clazz, arguments);
	}
	
	//javac versions: 7-8
//	private static final MethodId<JCTypeUnion> TypeUnion = MethodId(""TypeUnion"");
//	public JCTypeUnion TypeUnion(List<JCExpression> components) {
//		return invoke(TypeUnion, compoonents);
//	}

	//javac versions: 8
//	private static final MethodId<JCTypeIntersection> TypeIntersection = MethodId(""TypeIntersection"");
//	public JCTypeIntersection TypeIntersection(List<JCExpression> components) {
//		return invoke(TypeIntersection, components);
//	}
	
	//javac versions: 6-8
	private static final MethodId<JCTypeParameter> TypeParameter = MethodId(""TypeParameter"", JCTypeParameter.class, Name.class, List.class);
	public JCTypeParameter TypeParameter(Name name, List<JCExpression> bounds) {
		return invoke(TypeParameter, name, bounds);
	}
	
	//javac versions: 8
	private static final MethodId<JCTypeParameter> TypeParameterWithAnnos = MethodId(""TypeParameter"", JCTypeParameter.class, Name.class, List.class, List.class);
	public JCTypeParameter TypeParameter(Name name, List<JCExpression> bounds, List<JCAnnotation> annos) {
		return invoke(TypeParameterWithAnnos, name, bounds, annos);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCWildcard> Wildcard = MethodId(""Wildcard"");
	public JCWildcard Wildcard(TypeBoundKind kind, JCTree type) {
		return invoke(Wildcard, kind, type);
	}
	
	//javac versions: 6-8
	private static final MethodId<TypeBoundKind> TypeBoundKind = MethodId(""TypeBoundKind"");
	public TypeBoundKind TypeBoundKind(BoundKind kind) {
		return invoke(TypeBoundKind, kind);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCAnnotation> Annotation = MethodId(""Annotation"", JCAnnotation.class, JCTree.class, List.class);
	public JCAnnotation Annotation(JCTree annotationType, List<JCExpression> args) {
		return invoke(Annotation, annotationType, args);
	}
	
	//javac versions: 8
	private static final MethodId<JCAnnotation> TypeAnnotation = MethodId(""TypeAnnotation"", JCAnnotation.class, JCTree.class, List.class);
	public JCAnnotation TypeAnnotation(JCTree annotationType, List<JCExpression> args) {
		return invoke(TypeAnnotation, annotationType, args);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCModifiers> ModifiersWithAnnotations = MethodId(""Modifiers"", JCModifiers.class, long.class, List.class);
	public JCModifiers Modifiers(long flags, List<JCAnnotation> annotations) {
		return invoke(ModifiersWithAnnotations, flags, annotations);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCModifiers> Modifiers = MethodId(""Modifiers"", JCModifiers.class, long.class);
	public JCModifiers Modifiers(long flags) {
		return invoke(Modifiers, flags);
	}
	
	//javac versions: 8
//	private static final MethodId<JCAnnotatedType> AnnotatedType = MethodId(""AnnotatedType"");
//	public JCAnnotatedType AnnotatedType(List<JCAnnotation> annotations, JCExpression underlyingType) {
//		return invoke(AnnotatedType, annotations, underlyingType);
//	}
	
	//javac versions: 6-8
	private static final MethodId<JCErroneous> Erroneous = MethodId(""Erroneous"", JCErroneous.class);
	public JCErroneous Erroneous() {
		return invoke(Erroneous);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCErroneous> ErroneousWithErrs = MethodId(""Erroneous"", JCErroneous.class, List.class);
	public JCErroneous Erroneous(List<? extends JCTree> errs) {
		return invoke(ErroneousWithErrs, errs);
	}
	
	//javac versions: 6-8
	private static final MethodId<LetExpr> LetExpr = MethodId(""LetExpr"", LetExpr.class, List.class, JCTree.class);
	public LetExpr LetExpr(List<JCVariableDecl> defs, JCTree expr) {
		return invoke(LetExpr, defs, expr);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCClassDecl> AnonymousClassDef = MethodId(""AnonymousClassDef"");
	public JCClassDecl AnonymousClassDef(JCModifiers mods, List<JCTree> defs) {
		return invoke(AnonymousClassDef, mods, defs);
	}
	
	//javac versions: 6-8
	private static final MethodId<LetExpr> LetExprSingle = MethodId(""LetExpr"", LetExpr.class, JCVariableDecl.class, JCTree.class);
	public LetExpr LetExpr(JCVariableDecl def, JCTree expr) {
		return invoke(LetExprSingle, def, expr);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCIdent> IdentVarDecl = MethodId(""Ident"", JCIdent.class, JCVariableDecl.class);
	public JCExpression Ident(JCVariableDecl param) {
		return invoke(IdentVarDecl, param);
	}
	
	//javac versions: 6-8
	private static final MethodId<List<JCExpression>> Idents = MethodId(""Idents"");
	public List<JCExpression> Idents(List<JCVariableDecl> params) {
		return invoke(Idents, params);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCMethodInvocation> App2 = MethodId(""App"", JCMethodInvocation.class, JCExpression.class, List.class);
	public JCMethodInvocation App(JCExpression meth, List<JCExpression> args) {
		return invoke(App2, meth, args);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCMethodInvocation> App1 = MethodId(""App"", JCMethodInvocation.class, JCExpression.class);
	public JCMethodInvocation App(JCExpression meth) {
		return invoke(App1, meth);
	}
	
	//javac versions: 6-8
	private static final MethodId<List<JCAnnotation>> Annotations = MethodId(""Annotations"");
	public List<JCAnnotation> Annotations(List<Attribute.Compound> attributes) {
		return invoke(Annotations, attributes);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCLiteral> LiteralWithValue = MethodId(""Literal"", JCLiteral.class, Object.class);
	public JCLiteral Literal(Object value) {
		return invoke(LiteralWithValue, value);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCAnnotation> AnnotationWithAttributeOnly = MethodId(""Annotation"", JCAnnotation.class, Attribute.class);
	public JCAnnotation Annotation(Attribute a) {
		return invoke(AnnotationWithAttributeOnly, a);
	}
	
	//javac versions: 8
	private static final MethodId<JCAnnotation> TypeAnnotationWithAttributeOnly = MethodId(""TypeAnnotation"", JCAnnotation.class, Attribute.class);
	public JCAnnotation TypeAnnotation(Attribute a) {
		return invoke(TypeAnnotationWithAttributeOnly, a);
	}
	
	//javac versions: 8
	private static final MethodId<JCExpression> AnnotatedType = MethodId(""AnnotatedType"", JCExpression.class, List.class, JCExpression.class);
	public JCExpression AnnotatedType(List<JCAnnotation> annotations, JCExpression underlyingType) {
		return invoke(AnnotatedType, annotations, underlyingType);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCStatement> Call = MethodId(""Call"");
	public JCStatement Call(JCExpression apply) {
		return invoke(Call, apply);
	}
	
	//javac versions: 6-8
	private static final MethodId<JCExpression> Type = MethodId(""Type"");
	public JCExpression Type(Type type) {
		return invoke(Type, type);
	}
	
	private static final FieldId<JCVariableDecl> MethodDecl_recvParam = FieldId(JCMethodDecl.class, ""recvparam"", JCVariableDecl.class);
	//javac versions: 8+
	public boolean hasReceiverParameter() {
		return has(MethodDecl_recvParam);
	}
	
	public JCVariableDecl getReceiverParameter(JCMethodDecl method) {
		return get(method, MethodDecl_recvParam);
	}
	
	public void setReceiverParameter(JCMethodDecl method, JCVariableDecl param) {
		set(method, MethodDecl_recvParam, param);
	}
}",1,439 334 2000 123 437 381 2001 2002 59 439 2000 40 2001 2002 41 123 467 46 2002 61 2002 59 125 439 2001 2003 40 41 123 450 2002 59 125 439 2000 2004 40 404 2005 41 123 2002 46 2004 40 2005 41 59 450 467 59 125 437 457 381 334 2006 60 2007 62 123 437 381 2008 60 63 62 2009 59 437 381 2010 2011 59 437 381 2008 60 2007 62 2012 59 2006 40 2008 60 63 62 2009 44 2010 2011 44 2008 60 2007 62 2012 41 123 467 46 2009 61 2009 59 467 46 2011 61 2011 59 467 46 2012 61 2012 59 125 125 437 457 381 334 2013 60 2007 62 123 437 381 2014 60 63 62 2015 59 437 381 2016 2017 59 437 381 2014 60 2007 62 2018 59 437 381 2014 60 63 62 91 93 2019 59 2013 40 2014 60 63 62 2015 44 2016 2017 44 2014 60 2007 62 2018 44 2014 60 63 62 613 2020 41 123 467 46 2015 61 2015 59 467 46 2017 61 2017 59 467 46 2019 61 2020 59 467 46 2018 61 2018 59 125 64 2021 439 2016 2022 40 41 123 2023 430 61 418 2023 40 41 59 430 46 2024 40 2018 46 2025 40 41 41 46 2024 40 648 41 46 2024 40 2015 46 2025 40 41 41 46 2024 40 648 41 46 2024 40 2017 41 46 2024 40 648 41 59 324 2026 61 473 59 385 40 2014 60 63 62 2027 58 2019 41 123 392 40 2026 41 2026 61 380 59 360 430 46 2024 40 648 41 59 430 46 2024 40 2027 46 2025 40 41 41 59 125 450 430 46 2024 40 648 41 46 2022 40 41 59 125 125 437 457 334 2028 123 381 2029 2030 59 437 2028 40 2029 2030 41 123 467 46 2030 61 2030 59 125 64 2031 439 404 2032 40 41 123 450 2030 614 424 63 45 1501 58 2030 46 2032 40 41 59 125 64 2031 439 324 2033 40 2029 2034 41 123 392 40 2034 402 2028 41 123 2029 2035 61 40 40 2028 41 2034 41 46 2030 59 450 2030 614 424 63 2035 614 424 58 2030 46 2033 40 2035 41 59 125 450 380 59 125 457 2029 2036 40 2037 60 2038 44 2029 62 2039 44 2038 2040 44 2038 2041 41 123 2029 2030 61 2039 46 2042 40 2041 41 59 392 40 2030 631 424 41 450 2030 59 474 123 2030 61 2043 46 2044 40 2045 46 2046 40 2040 41 44 2041 41 46 2042 40 424 41 59 125 329 40 2047 2048 41 123 469 2049 46 2050 40 2048 41 59 125 329 40 2051 2048 41 123 469 2052 46 2053 40 2048 41 59 125 329 40 2054 2048 41 123 469 2055 46 2056 40 2048 41 59 125 2039 46 2057 40 2041 44 2030 41 59 450 2030 59 125 437 457 2058 2059 59 457 123 474 123 2059 61 2060 46 2061 40 2028 46 334 44 648 41 59 125 329 40 2062 2063 41 123 469 2064 46 2065 40 2063 41 59 125 125 457 2029 2036 40 2037 60 2066 60 63 62 44 2058 62 2039 44 2029 442 44 2038 2041 41 470 2067 123 2066 60 63 62 2068 61 442 46 2069 40 41 59 2058 2070 61 2039 46 2071 40 2068 41 59 392 40 2070 614 424 41 123 474 123 2070 61 2072 46 2073 40 2068 44 2041 41 59 125 329 40 2067 2074 41 123 2039 46 2075 40 2068 44 2059 41 59 469 2076 46 2077 40 2074 41 59 125 2078 46 2079 40 2070 41 59 2058 2080 61 2039 46 2081 40 2068 44 2070 41 59 392 40 2080 631 424 41 2070 61 2080 59 125 392 40 2070 614 2059 41 469 418 2067 40 2041 41 59 474 123 450 2070 46 2071 40 442 41 59 125 329 40 2082 2083 41 123 469 2084 46 2085 40 2083 41 59 125 125 125 439 457 334 2086 378 2028 123 437 457 381 2087 60 2088 44 2089 62 2090 61 418 2091 60 2088 44 2089 62 40 41 59 437 457 381 2087 60 2092 60 63 62 44 2093 62 2094 61 418 2091 60 2092 60 63 62 44 2093 62 40 41 59 437 457 381 2095 2096 59 457 123 2095 2097 61 424 59 474 123 2097 61 2098 46 2099 40 2100 46 334 44 648 41 59 125 329 40 2101 2102 41 123 125 2096 61 2097 59 125 437 2086 40 2089 2103 41 123 463 40 2103 41 59 125 439 457 2086 2104 40 2105 2106 41 123 474 123 450 418 2086 40 2107 40 2094 44 2106 44 648 41 41 59 125 329 40 2108 2109 41 123 469 2110 46 2111 40 2109 41 59 125 125 439 457 2086 2104 40 2112 2113 41 123 392 40 2113 614 424 41 450 2114 46 2115 59 474 123 450 418 2086 40 2116 40 2094 44 2113 44 648 41 41 59 125 329 40 2117 2118 41 123 392 40 2096 614 424 41 469 418 2119 40 648 43 2113 46 2120 40 41 43 648 41 59 474 123 450 418 2086 40 2096 46 2121 40 2113 41 41 59 125 329 40 2122 2123 41 123 469 2114 46 2124 40 2123 41 59 125 329 40 2125 2123 41 123 469 2114 46 2126 40 2123 46 2127 40 41 41 59 125 125 125 439 457 2086 2104 40 2088 2128 41 123 450 418 2086 40 2129 40 2090 44 2130 46 2131 40 41 60 1502 63 648 58 648 44 2128 41 41 59 125 125 439 457 334 2132 378 2028 123 437 457 381 2133 60 2134 44 2135 62 2136 61 418 2137 60 2134 44 2135 62 40 41 59 437 457 381 2138 2139 59 437 457 381 2140 2141 59 437 457 381 2013 60 2142 62 2143 61 2013 40 2144 46 334 44 648 44 404 46 334 44 2132 46 334 41 59 457 123 2140 2145 61 424 59 474 123 2145 61 2146 46 2147 40 2148 46 334 44 648 41 59 125 329 40 2149 2150 41 123 125 392 40 2145 631 424 41 123 2139 61 424 59 2141 61 2145 59 125 360 123 2138 2151 61 424 59 474 123 2151 61 2152 46 2153 40 2154 46 334 44 648 41 59 125 329 40 2155 2150 41 123 125 2139 61 2151 59 2141 61 424 59 125 125 437 2132 40 2135 2156 41 123 463 40 2156 41 59 125 439 457 2132 2157 40 2158 2159 41 123 474 123 392 40 2141 631 424 41 450 418 2132 40 2141 46 2160 40 2159 41 41 59 360 450 418 2132 40 2139 46 2161 40 2159 41 41 59 125 329 40 2162 2163 41 123 469 2164 46 2165 40 2163 46 2166 40 41 41 59 125 329 40 2167 2163 41 123 469 2168 46 2169 40 2163 41 59 125 125 439 457 2132 2157 40 2134 2170 41 123 450 418 2132 40 2171 40 2136 44 2172 46 2173 40 41 60 1502 63 648 58 648 44 2170 41 41 59 125 439 404 2174 40 41 123 450 2175 40 424 44 2143 44 2156 41 59 125 439 324 2176 40 41 123 450 2177 46 2178 46 2179 40 467 41 606 2177 46 2180 46 2179 40 467 41 606 2177 46 2181 46 2179 40 467 41 606 2177 46 2182 46 2179 40 467 41 606 2177 46 2183 46 2179 40 467 41 606 2177 46 2184 46 2179 40 467 41 59 125 125 457 60 2007 62 2013 60 2007 62 2013 40 2185 60 63 62 2186 44 2187 2188 44 2185 60 2007 62 2189 44 2185 60 63 62 613 2190 41 123 450 418 2013 60 2007 62 40 2186 44 2188 44 2189 44 2190 41 59 125 618 457 60 2007 62 2013 60 2007 62 2013 40 2187 2188 44 2185 60 2007 62 2189 44 2185 60 63 62 613 2190 41 123 450 418 2013 60 2007 62 40 2001 46 334 44 2188 44 2189 44 2190 41 59 125 618 457 60 2007 62 2013 60 2007 62 2013 40 2187 2188 41 123 385 40 2191 2192 58 2000 46 334 46 2193 40 41 41 123 392 40 2192 46 2194 40 41 46 2195 40 2188 41 41 123 64 2196 40 648 41 2185 60 2007 62 2197 61 40 2185 60 2007 62 41 2192 46 2198 40 41 59 2185 60 63 62 91 93 2199 61 2192 46 2200 40 41 59 450 418 2013 60 2007 62 40 2001 46 334 44 2188 44 2197 44 2199 41 59 125 125 469 418 2201 40 648 43 2188 41 59 125 457 60 2007 62 2006 60 2007 62 2006 40 2185 60 63 62 2186 44 2187 2188 44 2185 60 2007 62 2202 41 123 450 418 2006 60 2007 62 40 2186 44 2188 44 2202 41 59 125 437 457 381 2203 60 2006 60 63 62 44 2204 62 2205 61 418 2203 60 2006 60 63 62 44 2204 62 40 41 59 437 457 324 2206 40 2006 60 63 62 2207 41 123 2204 2208 61 2205 46 2209 40 2207 41 59 392 40 2208 614 2210 41 450 380 59 392 40 2208 402 2211 41 450 473 59 474 123 450 2212 40 2207 41 631 2210 59 125 329 40 2213 2214 41 123 450 380 59 125 125 437 457 60 2007 62 2007 2215 40 2204 2186 44 2006 60 2007 62 2207 41 123 2216 2217 61 2218 40 2207 41 59 474 123 450 2207 46 2202 46 2219 40 2217 46 2215 40 2186 41 41 59 125 329 40 2220 2221 41 123 469 2222 46 2223 40 2221 41 59 125 125 437 457 60 2007 62 492 2224 40 2204 2186 44 2006 60 2007 62 2207 44 2007 2225 41 123 2226 2227 61 2228 40 2207 41 59 474 123 2227 46 2224 40 2186 44 2225 41 59 125 329 40 2229 2230 41 123 469 2231 46 2232 40 2230 41 59 125 329 40 2233 2230 41 123 2234 46 2235 46 2236 40 648 43 2227 41 59 469 2230 59 125 125 437 457 2237 2238 40 2006 60 63 62 2207 41 123 2204 2239 61 2205 46 2215 40 2207 41 59 392 40 2239 614 424 41 2239 61 2240 40 2207 41 59 392 40 2239 614 2241 41 469 418 2242 40 648 43 2207 41 59 450 40 2237 41 2239 59 125 437 457 2204 2243 40 2006 60 63 62 2207 41 123 385 40 2237 2244 58 2207 46 2186 46 2245 40 41 41 123 392 40 2207 46 2188 46 2246 40 2244 46 2247 40 41 41 41 123 392 40 33 2248 46 2249 40 2244 46 2250 40 41 41 41 2244 46 2251 40 473 41 59 450 2205 46 2252 40 2207 44 2244 41 59 125 125 450 2205 46 2253 40 2207 44 2254 41 59 125 437 457 381 2204 2255 61 418 2204 91 1500 93 59 437 457 381 2204 2256 61 418 2204 91 1500 93 59 437 457 381 2203 60 2013 60 63 62 44 2204 62 2257 61 418 2203 60 2013 60 63 62 44 2204 62 40 41 59 437 324 2206 40 2013 60 63 62 2258 41 123 2204 2259 61 2257 46 2215 40 2258 41 59 392 40 2259 614 2255 41 450 380 59 392 40 2259 402 2260 41 450 473 59 474 123 450 2238 40 2258 41 631 2255 59 125 329 40 2261 2262 41 123 450 380 59 125 125 437 60 2007 62 2007 2263 40 2013 60 2007 62 2258 44 2204 613 2264 41 123 450 2265 40 2002 44 2258 44 2264 41 59 125 64 2266 40 648 41 437 457 60 2007 62 2007 2267 40 2204 2186 44 2013 60 2007 62 2258 44 2204 613 2264 41 123 2268 2269 61 2238 40 2258 41 59 474 123 392 40 2258 46 2189 46 2270 40 41 41 123 450 40 2007 41 2269 46 2263 40 2186 44 2264 41 59 125 450 2258 46 2189 46 2271 40 2269 46 2263 40 2186 44 2264 41 41 59 125 329 40 2272 2273 41 123 469 2274 46 2275 40 2273 46 2276 40 41 41 59 125 329 40 2277 2273 41 123 469 2278 46 2279 40 2273 41 59 125 329 40 2280 2273 41 123 2281 46 2282 46 2283 40 648 43 2269 41 59 469 2273 59 125 125 437 457 324 2284 40 2013 60 63 62 2258 41 123 2204 2285 61 2257 46 2215 40 2258 41 59 392 40 2285 614 424 41 2285 61 2243 40 2258 41 59 392 40 2285 402 2286 41 450 473 59 450 380 59 125 437 457 2287 2238 40 2013 60 63 62 2258 41 123 2204 2288 61 2257 46 2215 40 2258 41 59 392 40 2288 614 424 41 2288 61 2243 40 2258 41 59 392 40 2288 614 2256 41 469 418 2289 40 648 43 2258 41 59 392 40 2288 614 2255 41 469 418 2289 40 648 43 2258 41 59 450 40 2287 41 2288 59 125 437 457 2204 2243 40 2013 60 63 62 2258 41 123 2287 2290 61 424 59 2291 58 385 40 2287 2292 58 2258 46 2186 46 2293 40 41 41 123 392 40 33 2258 46 2188 46 2294 40 2292 46 2295 40 41 41 41 344 59 2185 60 63 62 91 93 2296 61 2292 46 2297 40 41 59 392 40 2296 46 2298 631 2258 46 2299 46 2298 41 344 59 385 40 404 2300 61 1500 59 2300 60 2296 46 2298 59 2300 637 41 123 392 40 2301 46 334 46 2302 40 2296 91 2300 93 41 41 344 2291 59 392 40 33 2028 46 334 46 2302 40 2258 46 2299 91 2300 93 41 41 123 392 40 2296 91 2300 93 46 2303 40 41 41 123 392 40 2296 91 2300 93 631 2258 46 2299 91 2300 93 41 344 2291 59 125 360 123 392 40 33 2296 91 2300 93 46 2302 40 2258 46 2299 91 2300 93 41 41 344 2291 59 125 125 125 392 40 2290 614 424 41 2290 61 2292 59 360 123 2257 46 2304 40 2258 44 2256 41 59 450 2256 59 125 125 392 40 2290 614 424 41 123 2257 46 2305 40 2258 44 2255 41 59 450 2255 59 125 2306 46 2307 40 2290 41 59 2204 2308 61 2257 46 2309 40 2258 44 2290 41 59 392 40 2308 614 424 41 450 2290 59 450 2308 59 125 621 437 457 381 2013 60 2310 62 2311 61 2013 40 648 41 59 439 2310 2311 40 2312 60 2313 62 2314 44 2315 2316 44 2312 60 2317 62 2318 41 123 450 2263 40 2311 44 2314 44 2316 44 2318 41 59 125 621 437 457 381 2013 60 2319 62 2320 61 2013 40 648 41 59 439 2319 2320 40 2317 2321 44 324 2322 41 123 450 2263 40 2320 44 2321 44 2322 41 59 125 621 437 457 381 2013 60 2323 62 2324 61 2013 40 648 41 59 439 2323 2324 40 2325 2326 44 2327 2188 44 2312 60 2328 62 2329 44 2315 2330 44 2312 60 2315 62 2331 44 2312 60 2317 62 2318 41 123 450 2263 40 2324 44 2326 44 2188 44 2329 44 2330 44 2331 44 2318 41 59 125 621 437 457 381 2013 60 2332 62 2333 61 2013 40 648 44 2332 46 334 44 2325 46 334 44 2327 46 334 44 2315 46 334 44 2312 46 334 44 2312 46 334 44 2312 46 334 44 2334 46 334 44 2315 46 334 41 59 439 2332 2333 40 2325 2326 44 2327 2188 44 2315 2335 44 2312 60 2328 62 2329 44 2312 60 2336 62 433 44 2312 60 2315 62 2337 44 2334 2338 44 2315 2339 41 123 450 2263 40 2333 44 2326 44 2188 44 2335 44 2329 44 433 44 2337 44 2338 44 2339 41 59 125 621 437 457 381 2013 60 2332 62 2340 61 2013 40 648 44 2332 46 334 44 2325 46 334 44 2327 46 334 44 2315 46 334 44 2312 46 334 44 2336 46 334 44 2312 46 334 44 2312 46 334 44 2334 46 334 44 2315 46 334 41 59 439 324 2341 40 41 123 450 2206 40 2340 41 59 125 439 2332 2340 40 2325 2326 44 2327 2188 44 2315 2335 44 2312 60 2328 62 2329 44 2336 2342 44 2312 60 2336 62 433 44 2312 60 2315 62 2337 44 2334 2338 44 2315 2339 41 123 450 2263 40 2340 44 2326 44 2188 44 2335 44 2329 44 2342 44 433 44 2337 44 2338 44 2339 41 59 125 621 437 457 381 2013 60 2336 62 2343 61 2013 40 648 41 59 439 2336 2343 40 2325 2326 44 2327 2188 44 2315 2344 44 2315 2345 41 123 2336 2346 61 2263 40 2343 44 2326 44 2188 44 2344 44 2345 41 59 621 621 392 40 2346 46 2344 631 424 605 2346 46 2344 46 2005 614 45 1501 41 2346 46 2344 46 2005 61 1500 59 450 2346 59 125 621 437 457 381 2013 60 2336 62 2347 61 2013 40 648 41 59 439 2336 2347 40 2325 2326 44 2315 2188 44 2315 2344 41 123 450 2263 40 2347 44 2326 44 2188 44 2344 41 59 125 621 437 457 381 2013 60 2348 62 2349 61 2013 40 648 41 59 439 2348 2349 40 41 123 450 2263 40 2349 41 59 125 621 437 457 381 2013 60 2334 62 2350 61 2013 40 648 41 59 439 2334 2350 40 413 2351 44 2312 60 2352 62 2353 41 123 450 2263 40 2350 44 2351 44 2353 41 59 125 621 437 457 381 2013 60 2354 62 2355 61 2013 40 648 41 59 439 2354 2355 40 2352 2338 44 2315 2356 41 123 450 2263 40 2355 44 2338 44 2356 41 59 125 621 437 457 381 2013 60 2357 62 2358 61 2013 40 648 41 59 439 2357 2358 40 2315 2356 44 2352 2338 41 123 450 2263 40 2358 44 2356 44 2338 41 59 125 621 437 457 381 2013 60 2359 62 2360 61 2013 40 648 41 59 439 2359 2360 40 2312 60 2352 62 2345 44 2315 2356 44 2312 60 2361 62 2362 44 2352 2338 41 123 450 2263 40 2360 44 2345 44 2356 44 2362 44 2338 41 59 125 621 437 457 381 2013 60 2363 62 2364 61 2013 40 648 41 59 439 2363 2364 40 2336 490 44 2315 2365 44 2352 2338 41 123 450 2263 40 2364 44 490 44 2365 44 2338 41 59 125 621 437 457 381 2013 60 2366 62 2367 61 2013 40 648 41 59 439 2366 2367 40 2327 2368 44 2352 2338 41 123 450 2263 40 2367 44 2368 44 2338 41 59 125 621 437 457 381 2013 60 2369 62 2370 61 2013 40 648 41 59 439 2369 2370 40 2315 2371 44 2312 60 2372 62 2373 41 123 450 2263 40 2370 44 2371 44 2373 41 59 125 621 437 457 381 2013 60 2372 62 2374 61 2013 40 648 44 2372 46 334 44 2315 46 334 44 2375 46 2376 46 2377 46 2378 46 2379 46 2312 46 334 41 59 621 439 457 334 2380 123 437 457 381 2185 60 63 62 2381 61 2382 40 2001 46 334 44 648 41 59 457 381 2013 60 2372 62 2380 61 2013 40 648 44 2372 46 334 44 2381 44 2375 46 2376 46 2377 46 2378 46 2379 46 2312 46 334 44 2375 46 2376 46 2377 46 2378 46 2379 46 2312 46 334 44 2317 46 334 41 59 457 381 2204 2383 61 2381 46 2384 40 41 91 1500 93 59 125 457 2185 60 63 62 2385 40 2185 60 63 62 2386 44 2187 2188 41 123 474 123 450 2386 46 2387 40 41 46 2388 40 2188 41 59 125 329 40 2389 2390 41 123 2391 2392 61 418 2393 40 2390 46 2394 40 41 41 59 2392 46 2395 40 2390 46 2396 40 41 41 59 469 2392 59 125 125 439 2372 2397 40 2315 2398 44 2312 60 2352 62 2353 41 123 392 40 2284 40 2374 41 41 450 2263 40 2374 44 2398 44 2353 41 59 2312 60 2317 62 2399 59 392 40 2398 614 424 41 123 2399 61 2284 40 2400 41 63 2312 46 2401 40 2400 40 41 41 58 2312 46 60 2317 62 2402 40 41 59 125 360 123 2399 61 2312 46 60 2317 62 2403 40 2398 41 59 125 450 2263 40 2380 46 2380 44 2380 46 2404 44 2399 44 2353 44 424 41 59 125 621 437 457 381 2013 60 2317 62 2405 61 2013 40 648 44 2317 46 334 41 59 439 2317 2405 40 41 123 450 2263 40 2405 41 59 125 621 437 457 381 2013 60 2406 62 2407 61 2013 40 648 41 59 439 2406 2407 40 2315 412 44 2334 2338 41 123 450 2263 40 2407 44 412 44 2338 41 59 125 621 437 457 381 2013 60 2408 62 2409 61 2013 40 648 44 2408 46 334 44 2334 46 334 44 2312 46 334 44 2334 46 334 41 59 439 2408 2409 40 2334 2338 44 2312 60 2410 62 2411 44 2334 2412 41 123 450 2263 40 2409 44 2338 44 2411 44 2412 41 59 125 621 437 457 381 2013 60 2408 62 2413 61 2013 40 648 44 2408 46 334 44 2312 46 334 44 2334 46 334 44 2312 46 334 44 2334 46 334 41 59 439 2408 2409 40 2312 60 2317 62 2414 44 2334 2338 44 2312 60 2410 62 2411 44 2334 2412 41 123 450 2263 40 2413 44 2414 44 2338 44 2411 44 2412 41 59 125 621 437 457 381 2013 60 2410 62 2415 61 2013 40 648 41 59 439 2410 2415 40 2336 2416 44 2334 2338 41 123 450 2263 40 2415 44 2416 44 2338 41 59 125 621 437 457 381 2013 60 2417 62 2418 61 2013 40 648 41 59 439 2417 2418 40 2315 2356 44 2315 2419 44 2315 2420 41 123 450 2263 40 2418 44 2356 44 2419 44 2420 41 59 125 621 437 457 381 2013 60 2421 62 2422 61 2013 40 648 41 59 439 2421 2422 40 2315 2356 44 2352 2419 44 2352 2420 41 123 450 2263 40 2422 44 2356 44 2419 44 2420 41 59 125 621 437 457 381 2013 60 2361 62 2423 61 2013 40 648 41 59 439 2361 2423 40 2315 2365 41 123 450 2263 40 2423 44 2365 41 59 125 621 437 457 381 2013 60 2424 62 2425 61 2013 40 648 44 2424 46 334 44 2327 46 334 41 59 621 437 457 381 2013 60 2424 62 2426 61 2013 40 648 44 2424 46 334 44 2315 46 334 41 59 439 2424 2427 40 2327 2368 41 123 392 40 2284 40 2425 41 41 450 2263 40 2425 44 2368 41 59 450 2263 40 2426 44 2368 631 424 63 2428 40 2368 41 58 424 41 59 125 621 437 457 381 2013 60 2429 62 2430 61 2013 40 648 41 59 439 2429 2430 40 2327 2368 41 123 450 2263 40 2430 44 2368 41 59 125 621 437 457 381 2013 60 2431 62 2432 61 2013 40 648 41 59 439 2431 2432 40 2315 2365 41 123 450 2263 40 2432 44 2365 41 59 125 621 437 457 381 2013 60 2433 62 2434 61 2013 40 648 41 59 439 2433 2434 40 2315 2365 41 123 450 2263 40 2434 44 2365 41 59 125 621 437 457 381 2013 60 2435 62 2436 61 2013 40 648 41 59 439 2435 2436 40 2315 2356 44 2315 2437 41 123 450 2263 40 2436 44 2356 44 2437 41 59 125 621 437 457 381 2013 60 2438 62 2439 61 2013 40 648 41 59 439 2438 2439 40 2312 60 2315 62 2440 44 2315 2441 44 2312 60 2315 62 2264 41 123 450 2263 40 2439 44 2440 44 2441 44 2264 41 59 125 621 437 457 381 2013 60 2442 62 2443 61 2013 40 648 41 59 439 2442 2443 40 2315 2444 44 2312 60 2315 62 2440 44 2315 2445 44 2312 60 2315 62 2264 44 2323 348 41 123 450 2263 40 2443 44 2444 44 2440 44 2445 44 2264 44 348 41 59 125 621 437 457 381 2013 60 2446 62 2447 61 2013 40 648 41 59 439 2446 2447 40 2315 2448 44 2312 60 2315 62 2449 44 2312 60 2315 62 2450 41 123 450 2263 40 2447 44 2448 44 2449 44 2450 41 59 125 621 621 621 621 621 621 437 457 381 2013 60 2451 62 2452 61 2013 40 648 41 59 439 2451 2452 40 2315 2365 41 123 450 2263 40 2452 44 2365 41 59 125 621 437 457 381 2013 60 2453 62 2454 61 2013 40 648 41 59 439 2453 2454 40 2315 2455 44 2315 2456 41 123 450 2263 40 2454 44 2455 44 2456 41 59 125 621 621 437 457 381 2013 60 2457 62 2458 61 2013 40 648 41 59 439 2457 2458 40 2132 2459 44 2317 2455 44 2317 2456 41 123 450 2263 40 2458 44 2459 46 2460 44 2455 44 2456 41 59 125 621 621 437 457 381 2013 60 2461 62 2462 61 2013 40 648 41 59 439 2461 2462 40 2132 2459 44 2315 2463 41 123 450 2263 40 2462 44 2459 46 2464 44 2463 41 59 125 621 621 437 457 381 2013 60 2465 62 2466 61 2013 40 648 41 59 439 2465 2466 40 2132 2459 44 2315 2455 44 2315 2456 41 123 450 2263 40 2466 44 2459 46 2467 44 2455 44 2456 41 59 125 621 437 457 381 2013 60 2468 62 2469 61 2013 40 648 41 59 439 2468 2469 40 2317 2365 44 2315 2470 41 123 450 2263 40 2469 44 2365 44 2470 41 59 125 621 437 457 381 2013 60 2471 62 2472 61 2013 40 648 41 59 439 2471 2472 40 2315 2365 44 2317 2445 41 123 450 2263 40 2472 44 2365 44 2445 41 59 125 621 437 457 381 2013 60 2473 62 2474 61 2013 40 648 41 59 439 2473 2474 40 2315 2475 44 2315 2476 41 123 450 2263 40 2474 44 2475 44 2476 41 59 125 621 437 457 381 2013 60 2477 62 2478 61 2013 40 648 41 59 439 2477 2478 40 2315 2479 44 2327 2371 41 123 450 2263 40 2478 44 2479 44 2371 41 59 125 621 621 621 621 621 621 437 457 381 2013 60 2480 62 2481 61 2013 40 648 44 2480 46 334 44 2327 46 334 41 59 439 2480 2481 40 2327 2482 41 123 450 2263 40 2481 44 2482 41 59 125 621 621 437 457 381 2013 60 2483 62 2484 61 2013 40 648 44 2483 46 334 44 2086 46 334 44 2204 46 334 41 59 439 2483 2484 40 2086 2485 44 2204 2486 41 123 450 2263 40 2484 44 2485 46 2486 44 2486 41 59 125 621 621 437 457 381 2013 60 2487 62 2488 61 2013 40 648 41 59 439 2487 2488 40 2086 2489 41 123 450 2263 40 2488 44 2489 46 2486 41 59 125 621 437 457 381 2013 60 2490 62 2491 61 2013 40 648 41 59 439 2490 2491 40 2315 2448 41 123 450 2263 40 2491 44 2448 41 59 125 621 437 457 381 2013 60 2492 62 2493 61 2013 40 648 41 59 439 2492 2493 40 2315 2445 44 2312 60 2315 62 2494 41 123 450 2263 40 2493 44 2445 44 2494 41 59 125 621 621 621 621 621 621 621 621 621 621 621 437 457 381 2013 60 2328 62 2495 61 2013 40 648 44 2328 46 334 44 2327 46 334 44 2312 46 334 41 59 439 2328 2495 40 2327 2188 44 2312 60 2315 62 2496 41 123 450 2263 40 2495 44 2188 44 2496 41 59 125 621 437 457 381 2013 60 2328 62 2497 61 2013 40 648 44 2328 46 334 44 2327 46 334 44 2312 46 334 44 2312 46 334 41 59 439 2328 2495 40 2327 2188 44 2312 60 2315 62 2496 44 2312 60 2313 62 2498 41 123 450 2263 40 2497 44 2188 44 2496 44 2498 41 59 125 621 437 457 381 2013 60 2499 62 2500 61 2013 40 648 41 59 439 2499 2500 40 2501 2502 44 2317 2470 41 123 450 2263 40 2500 44 2502 44 2470 41 59 125 621 437 457 381 2013 60 2501 62 2501 61 2013 40 648 41 59 439 2501 2501 40 2503 2502 41 123 450 2263 40 2501 44 2502 41 59 125 621 437 457 381 2013 60 2313 62 2504 61 2013 40 648 44 2313 46 334 44 2317 46 334 44 2312 46 334 41 59 439 2313 2504 40 2317 2505 44 2312 60 2315 62 2264 41 123 450 2263 40 2504 44 2505 44 2264 41 59 125 621 437 457 381 2013 60 2313 62 2506 61 2013 40 648 44 2313 46 334 44 2317 46 334 44 2312 46 334 41 59 439 2313 2506 40 2317 2505 44 2312 60 2315 62 2264 41 123 450 2263 40 2506 44 2505 44 2264 41 59 125 621 437 457 381 2013 60 2325 62 2507 61 2013 40 648 44 2325 46 334 44 413 46 334 44 2312 46 334 41 59 439 2325 2508 40 413 2351 44 2312 60 2313 62 2509 41 123 450 2263 40 2507 44 2351 44 2509 41 59 125 621 437 457 381 2013 60 2325 62 2508 61 2013 40 648 44 2325 46 334 44 413 46 334 41 59 439 2325 2508 40 413 2351 41 123 450 2263 40 2508 44 2351 41 59 125 621 621 621 621 621 621 437 457 381 2013 60 2510 62 2511 61 2013 40 648 44 2510 46 334 41 59 439 2510 2511 40 41 123 450 2263 40 2511 41 59 125 621 437 457 381 2013 60 2510 62 2512 61 2013 40 648 44 2510 46 334 44 2312 46 334 41 59 439 2510 2511 40 2312 60 63 378 2317 62 2513 41 123 450 2263 40 2512 44 2513 41 59 125 621 437 457 381 2013 60 2514 62 2514 61 2013 40 648 44 2514 46 334 44 2312 46 334 44 2317 46 334 41 59 439 2514 2514 40 2312 60 2336 62 2318 44 2317 2365 41 123 450 2263 40 2514 44 2318 44 2365 41 59 125 621 437 457 381 2013 60 2323 62 2515 61 2013 40 648 41 59 439 2323 2515 40 2325 2326 44 2312 60 2317 62 2318 41 123 450 2263 40 2515 44 2326 44 2318 41 59 125 621 437 457 381 2013 60 2514 62 2516 61 2013 40 648 44 2514 46 334 44 2336 46 334 44 2317 46 334 41 59 439 2514 2514 40 2336 348 44 2317 2365 41 123 450 2263 40 2516 44 348 44 2365 41 59 125 621 437 457 381 2013 60 2480 62 2517 61 2013 40 648 44 2480 46 334 44 2336 46 334 41 59 439 2315 2481 40 2336 2416 41 123 450 2263 40 2517 44 2416 41 59 125 621 437 457 381 2013 60 2312 60 2315 641 2518 61 2013 40 648 41 59 439 2312 60 2315 62 2518 40 2312 60 2336 62 433 41 123 450 2263 40 2518 44 433 41 59 125 621 437 457 381 2013 60 2438 62 2519 61 2013 40 648 44 2438 46 334 44 2315 46 334 44 2312 46 334 41 59 439 2438 2520 40 2315 2521 44 2312 60 2315 62 2264 41 123 450 2263 40 2519 44 2521 44 2264 41 59 125 621 437 457 381 2013 60 2438 62 2522 61 2013 40 648 44 2438 46 334 44 2315 46 334 41 59 439 2438 2520 40 2315 2521 41 123 450 2263 40 2522 44 2521 41 59 125 621 437 457 381 2013 60 2312 60 2313 641 2523 61 2013 40 648 41 59 439 2312 60 2313 62 2523 40 2312 60 2524 46 2525 62 2526 41 123 450 2263 40 2523 44 2526 41 59 125 621 437 457 381 2013 60 2483 62 2527 61 2013 40 648 44 2483 46 334 44 2204 46 334 41 59 439 2483 2484 40 2204 2486 41 123 450 2263 40 2527 44 2486 41 59 125 621 437 457 381 2013 60 2313 62 2528 61 2013 40 648 44 2313 46 334 44 2524 46 334 41 59 439 2313 2504 40 2524 2529 41 123 450 2263 40 2528 44 2529 41 59 125 621 437 457 381 2013 60 2313 62 2530 61 2013 40 648 44 2313 46 334 44 2524 46 334 41 59 439 2313 2506 40 2524 2529 41 123 450 2263 40 2530 44 2529 41 59 125 621 437 457 381 2013 60 2315 62 2531 61 2013 40 648 44 2315 46 334 44 2312 46 334 44 2315 46 334 41 59 439 2315 2531 40 2312 60 2313 62 2509 44 2315 2532 41 123 450 2263 40 2531 44 2509 44 2532 41 59 125 621 437 457 381 2013 60 2352 62 2533 61 2013 40 648 41 59 439 2352 2533 40 2315 2534 41 123 450 2263 40 2533 44 2534 41 59 125 621 437 457 381 2013 60 2315 62 2535 61 2013 40 648 41 59 439 2315 2535 40 2535 2470 41 123 450 2263 40 2535 44 2470 41 59 125 437 457 381 2006 60 2336 62 2536 61 2006 40 2332 46 334 44 648 44 2336 46 334 41 59 621 439 324 2537 40 41 123 450 2206 40 2536 41 59 125 439 2336 2538 40 2332 2539 41 123 450 2215 40 2539 44 2536 41 59 125 439 492 2540 40 2332 2539 44 2336 2416 41 123 2224 40 2539 44 2536 44 2416 41 59 125 125 
3081,Java,"@Slf4j
public abstract class TradeProtocol implements DecryptedDirectMessageListener, DecryptedMailboxListener {

    @Getter
    protected final ProtocolModel<? extends TradePeer> protocolModel;
    protected final TradeModel tradeModel;
    private Timer timeoutTimer;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    public TradeProtocol(TradeModel tradeModel) {
        this.tradeModel = tradeModel;
        this.protocolModel = tradeModel.getTradeProtocolModel();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void initialize(Provider serviceProvider, TradeManager tradeManager, Offer offer) {
        protocolModel.applyTransient(serviceProvider, tradeManager, offer);
        onInitialized();
    }

    protected void onInitialized() {
        if (!tradeModel.isCompleted()) {
            protocolModel.getP2PService().addDecryptedDirectMessageListener(this);
        }

        MailboxMessageService mailboxMessageService = protocolModel.getP2PService().getMailboxMessageService();
        // We delay a bit here as the tradeModel gets updated from the wallet to update the tradeModel
        // state (deposit confirmed) and that happens after our method is called.
        // TODO To fix that in a better way we would need to change the order of some routines
        // from the TradeManager, but as we are close to a release I dont want to risk a bigger
        // change and leave that for a later PR
        UserThread.runAfter(() -> {
            mailboxMessageService.addDecryptedMailboxListener(this);
            handleMailboxCollection(mailboxMessageService.getMyDecryptedMailboxMessages());
        }, 100, TimeUnit.MILLISECONDS);
    }

    public void onWithdrawCompleted() {
        cleanup();
    }

    protected void onMailboxMessage(TradeMessage message, NodeAddress peerNodeAddress) {
        log.info(""Received {} as MailboxMessage from {} with tradeId {} and uid {}"",
                message.getClass().getSimpleName(), peerNodeAddress, message.getTradeId(), message.getUid());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // DecryptedDirectMessageListener
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onDirectMessage(DecryptedMessageWithPubKey decryptedMessageWithPubKey, NodeAddress peer) {
        NetworkEnvelope networkEnvelope = decryptedMessageWithPubKey.getNetworkEnvelope();
        if (!isMyMessage(networkEnvelope)) {
            return;
        }

        if (!isPubKeyValid(decryptedMessageWithPubKey)) {
            return;
        }

        if (networkEnvelope instanceof TradeMessage) {
            onTradeMessage((TradeMessage) networkEnvelope, peer);
        } else if (networkEnvelope instanceof AckMessage) {
            onAckMessage((AckMessage) networkEnvelope, peer);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // DecryptedMailboxListener
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onMailboxMessageAdded(DecryptedMessageWithPubKey decryptedMessageWithPubKey, NodeAddress peer) {
        handleMailboxCollection(Collections.singletonList(decryptedMessageWithPubKey));
    }

    private void handleMailboxCollection(Collection<DecryptedMessageWithPubKey> collection) {
        collection.stream()
                .filter(this::isPubKeyValid)
                .map(DecryptedMessageWithPubKey::getNetworkEnvelope)
                .filter(this::isMyMessage)
                .filter(e -> e instanceof MailboxMessage)
                .map(e -> (MailboxMessage) e)
                .forEach(this::handleMailboxMessage);
    }

    private void handleMailboxMessage(MailboxMessage mailboxMessage) {
        ProtocolModel<? extends TradePeer> protocolModel = tradeModel.getTradeProtocolModel();
        if (mailboxMessage instanceof TradeMessage) {
            TradeMessage tradeMessage = (TradeMessage) mailboxMessage;
            // We only remove here if we have already completed the tradeModel.
            // Otherwise removal is done after successfully applied the task runner.
            if (tradeModel.isCompleted()) {
                protocolModel.getP2PService().getMailboxMessageService().removeMailboxMsg(mailboxMessage);
                log.info(""Remove {} from the P2P network as tradeModel is already completed."",
                        tradeMessage.getClass().getSimpleName());
                return;
            }
            onMailboxMessage(tradeMessage, mailboxMessage.getSenderNodeAddress());
        } else if (mailboxMessage instanceof AckMessage) {
            AckMessage ackMessage = (AckMessage) mailboxMessage;
            if (!tradeModel.isCompleted()) {
                // We only apply the msg if we have not already completed the tradeModel
                onAckMessage(ackMessage, mailboxMessage.getSenderNodeAddress());
            }
            // In any case we remove the msg
            protocolModel.getP2PService().getMailboxMessageService().removeMailboxMsg(ackMessage);
            log.info(""Remove {} from the P2P network."", ackMessage.getClass().getSimpleName());
        }
    }

    public void removeMailboxMessageAfterProcessing(TradeMessage tradeMessage) {
        if (tradeMessage instanceof MailboxMessage) {
            protocolModel.getP2PService().getMailboxMessageService().removeMailboxMsg((MailboxMessage) tradeMessage);
            log.info(""Remove {} from the P2P network."", tradeMessage.getClass().getSimpleName());
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Abstract
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected abstract void onTradeMessage(TradeMessage message, NodeAddress peer);


    ///////////////////////////////////////////////////////////////////////////////////////////
    // FluentProtocol
    ///////////////////////////////////////////////////////////////////////////////////////////

    // We log an error if condition is not met and call the protocol error handler
    protected FluentProtocol expect(FluentProtocol.Condition condition) {
        return new FluentProtocol(this)
                .condition(condition)
                .resultHandler(result -> {
                    if (!result.isValid()) {
                        log.warn(result.getInfo());
                        handleTaskRunnerFault(null,
                                result.name(),
                                result.getInfo());
                    }
                });
    }

    // We execute only if condition is met but do not log an error.
    protected FluentProtocol given(FluentProtocol.Condition condition) {
        return new FluentProtocol(this)
                .condition(condition);
    }

    protected FluentProtocol.Condition phase(Trade.Phase expectedPhase) {
        return new FluentProtocol.Condition(tradeModel).phase(expectedPhase);
    }

    protected FluentProtocol.Condition anyPhase(Trade.Phase... expectedPhases) {
        return new FluentProtocol.Condition(tradeModel).anyPhase(expectedPhases);
    }

    protected FluentProtocol.Condition preCondition(boolean preCondition) {
        return new FluentProtocol.Condition(tradeModel).preCondition(preCondition);
    }

    @SafeVarargs
    public final FluentProtocol.Setup tasks(Class<? extends Task<TradeModel>>... tasks) {
        return new FluentProtocol.Setup(this, tradeModel).tasks(tasks);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // ACK msg
    ///////////////////////////////////////////////////////////////////////////////////////////

    abstract protected void onAckMessage(AckMessage ackMessage, NodeAddress peer);

    protected void sendAckMessage(TradeMessage message, boolean result, @Nullable String errorMessage) {
        PubKeyRing peersPubKeyRing = protocolModel.getTradePeer().getPubKeyRing();
        if (peersPubKeyRing == null) {
            log.error(""We cannot send the ACK message as peersPubKeyRing is null"");
            return;
        }

        String tradeId = message.getTradeId();
        String sourceUid = message.getUid();
        AckMessage ackMessage = new AckMessage(protocolModel.getMyNodeAddress(),
                AckMessageSourceType.TRADE_MESSAGE,
                message.getClass().getSimpleName(),
                sourceUid,
                tradeId,
                result,
                errorMessage);
        // If there was an error during offer verification, the tradingPeerNodeAddress of the tradeModel might not be set yet.
        // We can find the peer's node address in the protocolModel's tempTradingPeerNodeAddress in that case.
        NodeAddress peer = tradeModel.getTradingPeerNodeAddress() != null ?
                tradeModel.getTradingPeerNodeAddress() :
                protocolModel.getTempTradingPeerNodeAddress();
        log.info(""Send AckMessage for {} to peer {}. tradeId={}, sourceUid={}"",
                ackMessage.getSourceMsgClassName(), peer, tradeId, sourceUid);
        protocolModel.getP2PService().getMailboxMessageService().sendEncryptedMailboxMessage(
                peer,
                peersPubKeyRing,
                ackMessage,
                new SendMailboxMessageListener() {
                    @Override
                    public void onArrived() {
                        log.info(""AckMessage for {} arrived at peer {}. tradeId={}, sourceUid={}"",
                                ackMessage.getSourceMsgClassName(), peer, tradeId, sourceUid);
                    }

                    @Override
                    public void onStoredInMailbox() {
                        log.info(""AckMessage for {} stored in mailbox for peer {}. tradeId={}, sourceUid={}"",
                                ackMessage.getSourceMsgClassName(), peer, tradeId, sourceUid);
                    }

                    @Override
                    public void onFault(String errorMessage) {
                        log.error(""AckMessage for {} failed. Peer {}. tradeId={}, sourceUid={}, errorMessage={}"",
                                ackMessage.getSourceMsgClassName(), peer, tradeId, sourceUid, errorMessage);
                    }
                }
        );
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Timeout
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected void startTimeout(long timeoutSec) {
        stopTimeout();

        timeoutTimer = UserThread.runAfter(() -> {
            log.error(""Timeout reached. TradeID={}, state={}, timeoutSec={}"",
                    tradeModel.getId(), tradeModel.getTradeState(), timeoutSec);
            tradeModel.setErrorMessage(""Timeout reached. Protocol did not complete in "" + timeoutSec + "" sec."");

            protocolModel.getTradeManager().requestPersistence();
            cleanup();
        }, timeoutSec);
    }

    protected void stopTimeout() {
        if (timeoutTimer != null) {
            timeoutTimer.stop();
            timeoutTimer = null;
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Task runner
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected void handleTaskRunnerSuccess(TradeMessage message) {
        handleTaskRunnerSuccess(message, message.getClass().getSimpleName());
    }

    protected void handleTaskRunnerSuccess(FluentProtocol.Event event) {
        handleTaskRunnerSuccess(null, event.name());
    }

    protected void handleTaskRunnerFault(TradeMessage message, String errorMessage) {
        handleTaskRunnerFault(message, message.getClass().getSimpleName(), errorMessage);
    }

    protected void handleTaskRunnerFault(FluentProtocol.Event event, String errorMessage) {
        handleTaskRunnerFault(null, event.name(), errorMessage);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Validation
    ///////////////////////////////////////////////////////////////////////////////////////////

    private boolean isPubKeyValid(DecryptedMessageWithPubKey message) {
        // We can only validate the peers pubKey if we have it already. If we are the taker we get it from the offer
        // Otherwise it depends on the state of the tradeModel protocol if we have received the peers pubKeyRing already.
        PubKeyRing peersPubKeyRing = protocolModel.getTradePeer().getPubKeyRing();
        boolean isValid = true;
        if (peersPubKeyRing != null &&
                !message.getSignaturePubKey().equals(peersPubKeyRing.getSignaturePubKey())) {
            isValid = false;
            log.error(""SignaturePubKey in message does not match the SignaturePubKey we have set for our trading peer."");
        }
        return isValid;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void handleTaskRunnerSuccess(@Nullable TradeMessage message, String source) {
        log.info(""TaskRunner successfully completed. Triggered from {}, tradeId={}"", source, tradeModel.getId());
        if (message != null) {
            sendAckMessage(message, true, null);

            // Once a taskRunner is completed we remove the mailbox message. To not remove it directly at the task
            // adds some resilience in case of minor errors, so after a restart the mailbox message can be applied
            // again.
            removeMailboxMessageAfterProcessing(message);
        }
    }

    void handleTaskRunnerFault(@Nullable TradeMessage message, String source, String errorMessage) {
        log.error(""Task runner failed with error {}. Triggered from {}"", errorMessage, source);

        if (message != null) {
            sendAckMessage(message, false, errorMessage);
        }
        cleanup();
    }

    private boolean isMyMessage(NetworkEnvelope message) {
        if (message instanceof TradeMessage) {
            TradeMessage tradeMessage = (TradeMessage) message;
            return tradeMessage.getTradeId().equals(tradeModel.getId());
        } else if (message instanceof AckMessage) {
            AckMessage ackMessage = (AckMessage) message;
            return ackMessage.getSourceType() == AckMessageSourceType.TRADE_MESSAGE &&
                    ackMessage.getSourceId().equals(tradeModel.getId());
        } else {
            return false;
        }
    }

    private void cleanup() {
        stopTimeout();
        // We do not remove the decryptedDirectMessageListener as in case of not critical failures we want allow to receive
        // follow-up messages still
    }
}",1,64 2000 439 305 334 2001 395 2002 44 2003 123 64 2004 438 381 2005 60 63 378 2006 62 2007 59 438 381 2008 2009 59 437 2010 2011 59 621 621 621 439 2001 40 2008 2009 41 123 467 46 2009 61 2009 59 467 46 2007 61 2009 46 2012 40 41 59 125 621 621 621 439 492 2013 40 2014 2015 44 2016 2017 44 2018 2019 41 123 2007 46 2020 40 2015 44 2017 44 2019 41 59 2021 40 41 59 125 438 492 2022 40 41 123 392 40 33 2009 46 2023 40 41 41 123 2007 46 2024 40 41 46 2025 40 467 41 59 125 2026 2027 61 2007 46 2028 40 41 46 2029 40 41 59 621 621 621 621 621 2030 46 2031 40 40 41 45 62 123 2027 46 2032 40 467 41 59 2033 40 2027 46 2034 40 41 41 59 125 44 1503 44 2035 46 2036 41 59 125 439 492 2037 40 41 123 2038 40 41 59 125 438 492 2039 40 2040 2041 44 2042 2043 41 123 2044 46 2045 40 648 44 2041 46 2046 40 41 46 2047 40 41 44 2043 44 2041 46 2048 40 41 44 2041 46 2049 40 41 41 59 125 621 621 621 64 2050 439 492 2051 40 2052 2053 44 2042 2054 41 123 2055 2056 61 2053 46 2057 40 41 59 392 40 33 2058 40 2056 41 41 123 450 59 125 392 40 33 2059 40 2053 41 41 123 450 59 125 392 40 2056 402 2040 41 123 2060 40 40 2040 41 2056 44 2054 41 59 125 360 392 40 2056 402 2061 41 123 2062 40 40 2061 41 2056 44 2054 41 59 125 125 621 621 621 64 2050 439 492 2063 40 2052 2053 44 2042 2054 41 123 2064 40 2065 46 2066 40 2053 41 41 59 125 437 492 2067 40 2068 60 2052 62 2069 41 123 2069 46 2070 40 41 46 2071 40 467 58 58 2072 41 46 2073 40 2052 58 58 2074 41 46 2071 40 467 58 58 2075 41 46 2071 40 2076 45 62 2076 402 2077 41 46 2073 40 2076 45 62 40 2077 41 2076 41 46 2078 40 467 58 58 2079 41 59 125 437 492 2080 40 2081 2082 41 123 2005 60 63 378 2006 62 2007 61 2009 46 2083 40 41 59 392 40 2082 402 2040 41 123 2040 2084 61 40 2040 41 2082 59 621 621 392 40 2009 46 2085 40 41 41 123 2007 46 2086 40 41 46 2087 40 41 46 2088 40 2082 41 59 2089 46 2090 40 648 44 2084 46 2091 40 41 46 2092 40 41 41 59 450 59 125 2039 40 2084 44 2082 46 2093 40 41 41 59 125 360 392 40 2082 402 2094 41 123 2094 2095 61 40 2094 41 2082 59 392 40 33 2009 46 2096 40 41 41 123 621 2097 40 2095 44 2082 46 2098 40 41 41 59 125 621 2007 46 2099 40 41 46 2100 40 41 46 2101 40 2095 41 59 2102 46 2103 40 648 44 2095 46 2104 40 41 46 2105 40 41 41 59 125 125 439 492 2106 40 2040 2107 41 123 392 40 2107 402 2081 41 123 2007 46 2108 40 41 46 2109 40 41 46 2110 40 40 2081 41 2107 41 59 2111 46 2112 40 648 44 2107 46 2113 40 41 46 2114 40 41 41 59 125 125 621 621 621 438 305 492 2115 40 2040 2041 44 2042 2054 41 59 621 621 621 621 438 2116 2117 40 2116 46 2118 2119 41 123 450 418 2116 40 467 41 46 2119 40 2119 41 46 2120 40 2121 45 62 123 392 40 33 2121 46 2122 40 41 41 123 2123 46 2124 40 2121 46 2125 40 41 41 59 2126 40 424 44 2121 46 2127 40 41 44 2121 46 2125 40 41 41 59 125 125 41 59 125 621 438 2116 2128 40 2116 46 2118 2119 41 123 450 418 2116 40 467 41 46 2119 40 2119 41 59 125 438 2116 46 2118 2129 40 2130 46 2131 2132 41 123 450 418 2116 46 2118 40 2009 41 46 2129 40 2132 41 59 125 438 2116 46 2118 2133 40 2130 46 2131 613 2134 41 123 450 418 2116 46 2118 40 2009 41 46 2133 40 2134 41 59 125 438 2116 46 2118 2135 40 324 2135 41 123 450 418 2116 46 2118 40 2009 41 46 2135 40 2135 41 59 125 64 2136 439 381 2116 46 2137 2138 40 2139 60 63 378 2140 60 2008 641 613 2138 41 123 450 418 2116 46 2137 40 467 44 2009 41 46 2138 40 2138 41 59 125 621 621 621 305 438 492 2141 40 2142 2143 44 2042 2054 41 59 438 492 2144 40 2040 2041 44 324 2145 44 64 2146 2147 2148 41 123 2149 2150 61 2007 46 2151 40 41 46 2152 40 41 59 392 40 2150 614 424 41 123 2153 46 371 40 648 41 59 450 59 125 2147 2154 61 2041 46 2155 40 41 59 2147 2156 61 2041 46 2157 40 41 59 2142 2143 61 418 2142 40 2007 46 2158 40 41 44 2159 46 2160 44 2041 46 2161 40 41 46 2162 40 41 44 2156 44 2154 44 2145 44 2148 41 59 621 621 2042 2054 61 2009 46 2163 40 41 631 424 63 2009 46 2163 40 41 58 2007 46 2164 40 41 59 2165 46 2166 40 648 44 2143 46 2167 40 41 44 2054 44 2154 44 2156 41 59 2007 46 2168 40 41 46 2169 40 41 46 2170 40 2054 44 2150 44 2143 44 418 2171 40 41 123 64 2050 439 492 2172 40 41 123 2165 46 2166 40 648 44 2143 46 2167 40 41 44 2054 44 2154 44 2156 41 59 125 64 2050 439 492 2173 40 41 123 2165 46 2166 40 648 44 2143 46 2167 40 41 44 2054 44 2154 44 2156 41 59 125 64 2050 439 492 2174 40 2147 2148 41 123 2165 46 371 40 648 44 2143 46 2167 40 41 44 2054 44 2154 44 2156 44 2148 41 59 125 125 41 59 125 621 621 621 438 492 2175 40 413 2176 41 123 2177 40 41 59 2011 61 2178 46 2179 40 40 41 45 62 123 2180 46 371 40 648 44 2009 46 2181 40 41 44 2009 46 2182 40 41 44 2176 41 59 2009 46 2183 40 648 43 2176 43 648 41 59 2007 46 2184 40 41 46 2185 40 41 59 2186 40 41 59 125 44 2176 41 59 125 438 492 2187 40 41 123 392 40 2011 631 424 41 123 2011 46 2188 40 41 59 2011 61 424 59 125 125 621 621 621 438 492 2189 40 2040 2041 41 123 2189 40 2041 44 2041 46 2190 40 41 46 2191 40 41 41 59 125 438 492 2189 40 2116 46 2192 373 41 123 2189 40 424 44 373 46 2193 40 41 41 59 125 438 492 2194 40 2040 2041 44 2147 2148 41 123 2194 40 2041 44 2041 46 2195 40 41 46 2196 40 41 44 2148 41 59 125 438 492 2194 40 2116 46 2192 373 44 2147 2148 41 123 2194 40 424 44 373 46 2197 40 41 44 2148 41 59 125 621 621 621 437 324 2198 40 2052 2041 41 123 621 621 2199 2200 61 2007 46 2201 40 41 46 2202 40 41 59 324 2203 61 473 59 392 40 2200 631 424 605 33 2041 46 2204 40 41 46 2205 40 2200 46 2204 40 41 41 41 123 2203 61 380 59 2206 46 371 40 648 41 59 125 450 2203 59 125 621 621 621 437 492 2189 40 64 2146 2040 2041 44 2147 2207 41 123 2208 46 2209 40 648 44 2207 44 2009 46 2210 40 41 41 59 392 40 2041 631 424 41 123 2144 40 2041 44 473 44 424 41 59 621 621 621 2106 40 2041 41 59 125 125 492 2194 40 64 2146 2040 2041 44 2147 2207 44 2147 2148 41 123 2211 46 371 40 648 44 2148 44 2207 41 59 392 40 2041 631 424 41 123 2144 40 2041 44 380 44 2148 41 59 125 2212 40 41 59 125 437 324 2213 40 2214 2041 41 123 392 40 2041 402 2040 41 123 2040 2107 61 40 2040 41 2041 59 450 2107 46 2215 40 41 46 2216 40 2009 46 2217 40 41 41 59 125 360 392 40 2041 402 2142 41 123 2142 2143 61 40 2142 41 2041 59 450 2143 46 2218 40 41 614 2219 46 2220 605 2143 46 2221 40 41 46 2222 40 2009 46 2223 40 41 41 59 125 360 123 450 380 59 125 125 437 492 2224 40 41 123 2187 40 41 59 621 621 125 125 
2584,Java,"public final class GetToBlockProcess extends BaritoneProcessHelper implements IGetToBlockProcess {

    private BlockOptionalMeta gettingTo;
    private List<BlockPos> knownLocations;
    private List<BlockPos> blacklist; // locations we failed to calc to
    private BlockPos start;

    private int tickCount = 0;
    private int arrivalTickCount = 0;

    public GetToBlockProcess(Baritone baritone) {
        super(baritone);
    }

    @Override
    public void getToBlock(BlockOptionalMeta block) {
        onLostControl();
        gettingTo = block;
        start = ctx.playerFeet();
        blacklist = new ArrayList<>();
        arrivalTickCount = 0;
        rescan(new ArrayList<>(), new GetToBlockCalculationContext(false));
    }

    @Override
    public boolean isActive() {
        return gettingTo != null;
    }

    @Override
    public synchronized PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
        if (knownLocations == null) {
            rescan(new ArrayList<>(), new GetToBlockCalculationContext(false));
        }
        if (knownLocations.isEmpty()) {
            if (Baritone.settings().exploreForBlocks.value && !calcFailed) {
                return new PathingCommand(new GoalRunAway(1, start) {
                    @Override
                    public boolean isInGoal(int x, int y, int z) {
                        return false;
                    }

                    @Override
                    public double heuristic() {
                        return Double.NEGATIVE_INFINITY;
                    }
                }, PathingCommandType.FORCE_REVALIDATE_GOAL_AND_PATH);
            }
            logDirect(""No known locations of "" + gettingTo + "", canceling GetToBlock"");
            if (isSafeToCancel) {
                onLostControl();
            }
            return new PathingCommand(null, PathingCommandType.CANCEL_AND_SET_GOAL);
        }
        Goal goal = new GoalComposite(knownLocations.stream().map(this::createGoal).toArray(Goal[]::new));
        if (calcFailed) {
            if (Baritone.settings().blacklistClosestOnFailure.value) {
                logDirect(""Unable to find any path to "" + gettingTo + "", blacklisting presumably unreachable closest instances..."");
                blacklistClosest();
                return onTick(false, isSafeToCancel); // gamer moment
            } else {
                logDirect(""Unable to find any path to "" + gettingTo + "", canceling GetToBlock"");
                if (isSafeToCancel) {
                    onLostControl();
                }
                return new PathingCommand(goal, PathingCommandType.CANCEL_AND_SET_GOAL);
            }
        }
        int mineGoalUpdateInterval = Baritone.settings().mineGoalUpdateInterval.value;
        if (mineGoalUpdateInterval != 0 && tickCount++ % mineGoalUpdateInterval == 0) { // big brain
            List<BlockPos> current = new ArrayList<>(knownLocations);
            CalculationContext context = new GetToBlockCalculationContext(true);
            Baritone.getExecutor().execute(() -> rescan(current, context));
        }
        if (goal.isInGoal(ctx.playerFeet()) && goal.isInGoal(baritone.getPathingBehavior().pathStart()) && isSafeToCancel) {
            // we're there
            if (rightClickOnArrival(gettingTo.getBlock())) {
                if (rightClick()) {
                    onLostControl();
                    return new PathingCommand(null, PathingCommandType.CANCEL_AND_SET_GOAL);
                }
            } else {
                onLostControl();
                return new PathingCommand(null, PathingCommandType.CANCEL_AND_SET_GOAL);
            }
        }
        return new PathingCommand(goal, PathingCommandType.REVALIDATE_GOAL_AND_PATH);
    }

    // blacklist the closest block and its adjacent blocks
    public synchronized boolean blacklistClosest() {
        List<BlockPos> newBlacklist = new ArrayList<>();
        knownLocations.stream().min(Comparator.comparingDouble(ctx.player()::getDistanceSq)).ifPresent(newBlacklist::add);
        outer:
        while (true) {
            for (BlockPos known : knownLocations) {
                for (BlockPos blacklist : newBlacklist) {
                    if (areAdjacent(known, blacklist)) { // directly adjacent
                        newBlacklist.add(known);
                        knownLocations.remove(known);
                        continue outer;
                    }
                }
            }
            // i can't do break; (codacy gets mad), and i can't do if(true){break}; (codacy gets mad)
            // so i will do this
            switch (newBlacklist.size()) {
                default:
                    break outer;
            }
        }
        logDebug(""Blacklisting unreachable locations "" + newBlacklist);
        blacklist.addAll(newBlacklist);
        return !newBlacklist.isEmpty();
    }

    // this is to signal to MineProcess that we don't care about the allowBreak setting
    // it is NOT to be used to actually calculate a path
    public class GetToBlockCalculationContext extends CalculationContext {

        public GetToBlockCalculationContext(boolean forUseOnAnotherThread) {
            super(GetToBlockProcess.super.baritone, forUseOnAnotherThread);
        }

        @Override
        public double breakCostMultiplierAt(int x, int y, int z, IBlockState current) {
            return 1;
        }
    }

    // safer than direct double comparison from distanceSq
    private boolean areAdjacent(BlockPos posA, BlockPos posB) {
        int diffX = Math.abs(posA.getX() - posB.getX());
        int diffY = Math.abs(posA.getY() - posB.getY());
        int diffZ = Math.abs(posA.getZ() - posB.getZ());
        return (diffX + diffY + diffZ) == 1;
    }

    @Override
    public synchronized void onLostControl() {
        gettingTo = null;
        knownLocations = null;
        start = null;
        blacklist = null;
        baritone.getInputOverrideHandler().clearAllKeys();
    }

    @Override
    public String displayName0() {
        if (knownLocations.isEmpty()) {
            return ""Exploring randomly to find "" + gettingTo + "", no known locations"";
        }
        return ""Get To "" + gettingTo + "", "" + knownLocations.size() + "" known locations"";
    }

    private synchronized void rescan(List<BlockPos> known, CalculationContext context) {
        List<BlockPos> positions = MineProcess.searchWorld(context, new BlockOptionalMetaLookup(gettingTo), 64, known, blacklist, Collections.emptyList());
        positions.removeIf(blacklist::contains);
        knownLocations = positions;
    }

    private Goal createGoal(BlockPos pos) {
        if (walkIntoInsteadOfAdjacent(gettingTo.getBlock())) {
            return new GoalTwoBlocks(pos);
        }
        if (blockOnTopMustBeRemoved(gettingTo.getBlock()) && baritone.bsi.get0(pos.up()).isBlockNormalCube()) {
            return new GoalBlock(pos.up());
        }
        return new GoalGetToBlock(pos);
    }

    private boolean rightClick() {
        for (BlockPos pos : knownLocations) {
            Optional<Rotation> reachable = RotationUtils.reachable(ctx.player(), pos, ctx.playerController().getBlockReachDistance());
            if (reachable.isPresent()) {
                baritone.getLookBehavior().updateTarget(reachable.get(), true);
                if (knownLocations.contains(ctx.getSelectedBlock().orElse(null))) {
                    baritone.getInputOverrideHandler().setInputForceState(Input.CLICK_RIGHT, true); // TODO find some way to right click even if we're in an ESC menu
                    System.out.println(ctx.player().openContainer);
                    if (!(ctx.player().openContainer instanceof ContainerPlayer)) {
                        return true;
                    }
                }
                if (arrivalTickCount++ > 20) {
                    logDirect(""Right click timed out"");
                    return true;
                }
                return false; // trying to right click, will do it next tick or so
            }
        }
        logDirect(""Arrived but failed to right click open"");
        return true;
    }

    private boolean walkIntoInsteadOfAdjacent(Block block) {
        if (!Baritone.settings().enterPortal.value) {
            return false;
        }
        return block == Blocks.PORTAL;
    }

    private boolean rightClickOnArrival(Block block) {
        if (!Baritone.settings().rightClickContainerOnArrival.value) {
            return false;
        }
        return block == Blocks.CRAFTING_TABLE || block == Blocks.FURNACE || block == Blocks.LIT_FURNACE || block == Blocks.ENDER_CHEST || block == Blocks.CHEST || block == Blocks.TRAPPED_CHEST;
    }

    private boolean blockOnTopMustBeRemoved(Block block) {
        if (!rightClickOnArrival(block)) { // only if we plan to actually open it on arrival
            return false;
        }
        // only these chests; you can open a crafting table or furnace even with a block on top
        return block == Blocks.ENDER_CHEST || block == Blocks.CHEST || block == Blocks.TRAPPED_CHEST;
    }
}",1,439 381 334 2000 378 2001 395 2002 123 437 2003 2004 59 437 2005 60 2006 62 2007 59 437 2005 60 2006 62 2008 59 621 437 2006 2009 59 437 404 2010 61 1500 59 437 404 2011 61 1500 59 439 2000 40 2012 2013 41 123 463 40 2013 41 59 125 64 2014 439 492 2015 40 2003 2016 41 123 2017 40 41 59 2004 61 2016 59 2009 61 2018 46 2019 40 41 59 2008 61 418 2020 60 62 40 41 59 2011 61 1500 59 2021 40 418 2020 60 62 40 41 44 418 2022 40 380 41 41 59 125 64 2014 439 324 2023 40 41 123 450 2004 631 424 59 125 64 2014 439 465 2024 2025 40 324 2026 44 324 2027 41 123 392 40 2007 614 424 41 123 2028 40 418 2029 60 62 40 41 44 418 2030 40 380 41 41 59 125 392 40 2007 46 2031 40 41 41 123 392 40 2012 46 2032 40 41 46 2033 46 2034 605 33 2026 41 123 450 418 2024 40 418 2035 40 1501 44 2009 41 123 64 2014 439 324 2036 40 404 2037 44 404 2038 44 404 2039 41 123 450 380 59 125 64 2014 439 356 2040 40 41 123 450 2041 46 2042 59 125 125 44 2043 46 2044 41 59 125 2045 40 648 43 2004 43 648 41 59 392 40 2027 41 123 2046 40 41 59 125 450 418 2024 40 424 44 2047 46 2048 41 59 125 2049 2050 61 418 2051 40 2007 46 2052 40 41 46 2053 40 467 58 58 2054 41 46 2055 40 2049 91 93 58 58 418 41 41 59 392 40 2026 41 123 392 40 2012 46 2056 40 41 46 2057 46 2058 41 123 2059 40 648 43 2004 43 648 41 59 2060 40 41 59 450 2025 40 380 44 2027 41 59 621 125 360 123 2061 40 648 43 2004 43 648 41 59 392 40 2027 41 123 2062 40 41 59 125 450 418 2024 40 2050 44 2063 46 2064 41 59 125 125 404 2065 61 2012 46 2066 40 41 46 2065 46 2067 59 392 40 2065 631 1500 605 2010 637 37 2065 614 1500 41 123 621 2005 60 2006 62 2068 61 418 2069 60 62 40 2007 41 59 2070 2071 61 418 2072 40 473 41 59 2012 46 2073 40 41 46 2074 40 40 41 45 62 2075 40 2068 44 2071 41 41 59 125 392 40 2050 46 2076 40 2077 46 2078 40 41 41 605 2050 46 2076 40 2013 46 2079 40 41 46 2080 40 41 41 605 2027 41 123 621 392 40 2081 40 2004 46 2082 40 41 41 41 123 392 40 2083 40 41 41 123 2084 40 41 59 450 418 2024 40 424 44 2085 46 2086 41 59 125 125 360 123 2087 40 41 59 450 418 2024 40 424 44 2088 46 2089 41 59 125 125 450 418 2024 40 2050 44 2090 46 2091 41 59 125 621 439 465 324 2092 40 41 123 2005 60 2006 62 2093 61 418 2094 60 62 40 41 59 2007 46 2095 40 41 46 2096 40 2097 46 2098 40 2099 46 2100 40 41 58 58 2101 41 41 46 2102 40 2093 58 58 2103 41 59 2104 58 496 40 473 41 123 385 40 2006 2105 58 2007 41 123 385 40 2006 2008 58 2093 41 123 392 40 2106 40 2105 44 2008 41 41 123 621 2093 46 2103 40 2105 41 59 2007 46 2107 40 2105 41 59 344 2104 59 125 125 125 621 621 464 40 2093 46 2108 40 41 41 123 349 58 325 2104 59 125 125 2109 40 648 43 2093 41 59 2008 46 2110 40 2093 41 59 450 33 2093 46 2111 40 41 59 125 621 621 439 334 2112 378 2113 123 439 2112 40 324 2114 41 123 463 40 2000 46 463 46 2013 44 2114 41 59 125 64 2014 439 356 2115 40 404 2116 44 404 2117 44 404 2118 44 2119 2120 41 123 450 1501 59 125 125 621 437 324 2121 40 2006 2122 44 2006 2123 41 123 404 2124 61 2125 46 2126 40 2122 46 2127 40 41 45 2123 46 2127 40 41 41 59 404 2128 61 2125 46 2126 40 2122 46 2129 40 41 45 2123 46 2129 40 41 41 59 404 2130 61 2125 46 2126 40 2122 46 2131 40 41 45 2123 46 2131 40 41 41 59 450 40 2124 43 2128 43 2130 41 614 1501 59 125 64 2014 439 465 492 2132 40 41 123 2004 61 424 59 2007 61 424 59 2009 61 424 59 2008 61 424 59 2013 46 2133 40 41 46 2134 40 41 59 125 64 2014 439 2135 2136 40 41 123 392 40 2007 46 2137 40 41 41 123 450 648 43 2004 43 648 59 125 450 648 43 2004 43 648 43 2007 46 2138 40 41 43 648 59 125 437 465 492 2139 40 2005 60 2006 62 2140 44 2113 2141 41 123 2005 60 2006 62 2142 61 2143 46 2144 40 2141 44 418 2145 40 2004 41 44 1503 44 2140 44 2008 44 2146 46 2147 40 41 41 59 2142 46 2148 40 2008 58 58 2149 41 59 2007 61 2142 59 125 437 2150 2151 40 2006 2152 41 123 392 40 2153 40 2004 46 2154 40 41 41 41 123 450 418 2155 40 2152 41 59 125 392 40 2156 40 2004 46 2154 40 41 41 605 2013 46 2157 46 2158 40 2152 46 2159 40 41 41 46 2160 40 41 41 123 450 418 2161 40 2152 46 2159 40 41 41 59 125 450 418 2162 40 2152 41 59 125 437 324 2163 40 41 123 385 40 2006 2152 58 2007 41 123 2164 60 2165 62 2166 61 2167 46 2166 40 2168 46 2169 40 41 44 2152 44 2168 46 2170 40 41 46 2171 40 41 41 59 392 40 2166 46 2172 40 41 41 123 2013 46 2173 40 41 46 2174 40 2166 46 2175 40 41 44 473 41 59 392 40 2007 46 2176 40 2168 46 2177 40 41 46 2178 40 424 41 41 41 123 2013 46 2179 40 41 46 2180 40 2181 46 2182 44 473 41 59 621 2183 46 430 46 2184 40 2168 46 2169 40 41 46 2185 41 59 392 40 33 40 2168 46 2169 40 41 46 2185 402 2186 41 41 123 450 473 59 125 125 392 40 2011 637 62 1503 41 123 2187 40 648 41 59 450 473 59 125 450 380 59 621 125 125 2188 40 648 41 59 450 473 59 125 437 324 2189 40 2190 2016 41 123 392 40 33 2012 46 2191 40 41 46 2192 46 2193 41 123 450 380 59 125 450 2016 614 2194 46 2195 59 125 437 324 2196 40 2190 2016 41 123 392 40 33 2012 46 2197 40 41 46 2198 46 2199 41 123 450 380 59 125 450 2016 614 2200 46 2201 606 2016 614 2200 46 2202 606 2016 614 2200 46 2203 606 2016 614 2200 46 2204 606 2016 614 2200 46 2205 606 2016 614 2200 46 2206 59 125 437 324 2207 40 2190 2016 41 123 392 40 33 2196 40 2016 41 41 123 621 450 380 59 125 621 450 2016 614 2208 46 2209 606 2016 614 2208 46 2210 606 2016 614 2208 46 2211 59 125 125 
2934,Java,"public class PendingTradesViewModel extends ActivatableWithDataModel<PendingTradesDataModel> implements ViewModel {

    @Getter
    @Nullable
    private Trade trade;

    interface State {
    }

    enum BuyerState implements State {
        UNDEFINED,
        STEP1,
        STEP2,
        STEP3,
        STEP4
    }

    enum SellerState implements State {
        UNDEFINED,
        STEP1,
        STEP2,
        STEP3,
        STEP4
    }

    public final CoinFormatter btcFormatter;
    private final BsqFormatter bsqFormatter;
    public final BtcAddressValidator btcAddressValidator;
    final AccountAgeWitnessService accountAgeWitnessService;
    public final P2PService p2PService;
    private final MempoolService mempoolService;
    private final ClosedTradableManager closedTradableManager;
    private final OfferUtil offerUtil;
    private final TradeUtil tradeUtil;
    public final ClockWatcher clockWatcher;
    @Getter
    private final Navigation navigation;
    @Getter
    private final User user;

    private final ObjectProperty<BuyerState> buyerState = new SimpleObjectProperty<>();
    private final ObjectProperty<SellerState> sellerState = new SimpleObjectProperty<>();
    @Getter
    private final ObjectProperty<MessageState> messageStateProperty = new SimpleObjectProperty<>(MessageState.UNDEFINED);
    private Subscription tradeStateSubscription;
    private Subscription messageStateSubscription;
    @Getter
    protected final IntegerProperty mempoolStatus = new SimpleIntegerProperty();


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, initialization
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public PendingTradesViewModel(PendingTradesDataModel dataModel,
                                  @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter btcFormatter,
                                  BsqFormatter bsqFormatter,
                                  BtcAddressValidator btcAddressValidator,
                                  P2PService p2PService,
                                  MempoolService mempoolService,
                                  ClosedTradableManager closedTradableManager,
                                  OfferUtil offerUtil,
                                  TradeUtil tradeUtil,
                                  AccountAgeWitnessService accountAgeWitnessService,
                                  ClockWatcher clockWatcher,
                                  Navigation navigation,
                                  User user) {
        super(dataModel);

        this.btcFormatter = btcFormatter;
        this.bsqFormatter = bsqFormatter;
        this.btcAddressValidator = btcAddressValidator;
        this.p2PService = p2PService;
        this.mempoolService = mempoolService;
        this.closedTradableManager = closedTradableManager;
        this.offerUtil = offerUtil;
        this.tradeUtil = tradeUtil;
        this.accountAgeWitnessService = accountAgeWitnessService;
        this.clockWatcher = clockWatcher;
        this.navigation = navigation;
        this.user = user;
    }


    @Override
    protected void deactivate() {
        if (tradeStateSubscription != null) {
            tradeStateSubscription.unsubscribe();
            tradeStateSubscription = null;
        }

        if (messageStateSubscription != null) {
            messageStateSubscription.unsubscribe();
            messageStateSubscription = null;
        }
    }

    // Don't set own listener as we need to control the order of the calls
    public void onSelectedItemChanged(PendingTradesListItem selectedItem) {
        if (tradeStateSubscription != null) {
            tradeStateSubscription.unsubscribe();
            sellerState.set(SellerState.UNDEFINED);
            buyerState.set(BuyerState.UNDEFINED);
        }

        if (messageStateSubscription != null) {
            messageStateSubscription.unsubscribe();
            messageStateProperty.set(MessageState.UNDEFINED);
        }

        if (selectedItem != null) {
            this.trade = selectedItem.getTrade();
            tradeStateSubscription = EasyBind.subscribe(trade.stateProperty(), this::onTradeStateChanged);

            messageStateSubscription = EasyBind.subscribe(trade.getProcessModel().getPaymentStartedMessageStateProperty(), this::onMessageStateChanged);
        }
    }

    public void setMessageStateProperty(MessageState messageState) {
        if (messageStateProperty.get() == MessageState.ACKNOWLEDGED) {
            log.warn(""We have already an ACKNOWLEDGED message received. "" +
                    ""We would not expect any other message after that. Received messageState={}"", messageState);
            return;
        }

        if (trade != null)
            trade.getProcessModel().setPaymentStartedMessageState(messageState);
    }

    private void onMessageStateChanged(MessageState messageState) {
        messageStateProperty.set(messageState);
    }

    public void checkTakerFeeTx(Trade trade) {
        mempoolStatus.setValue(-1);
        mempoolService.validateOfferTakerTx(trade, (txValidator -> {
            mempoolStatus.setValue(txValidator.isFail() ? 0 : 1);
            if (txValidator.isFail()) {
                String errorMessage = ""Validation of Taker Tx returned: "" + txValidator.toString();
                log.warn(errorMessage);
                // prompt user to open mediation
                if (trade.getDisputeState() == Trade.DisputeState.NO_DISPUTE) {
                    UserThread.runAfter(() -> {
                        Popup popup = new Popup();
                        popup.headLine(Res.get(""portfolio.pending.openSupportTicket.headline""))
                                .message(Res.get(""portfolio.pending.invalidTx"", errorMessage))
                                .actionButtonText(Res.get(""portfolio.pending.openSupportTicket.headline""))
                                .onAction(dataModel::onOpenSupportTicket)
                                .closeButtonText(Res.get(""shared.cancel""))
                                .onClose(popup::hide)
                                .show();
                    }, 100, TimeUnit.MILLISECONDS);
                }
            }
        }));
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    ///////////////////////////////////////////////////////////////////////////////////////////

    ReadOnlyObjectProperty<BuyerState> getBuyerState() {
        return buyerState;
    }

    ReadOnlyObjectProperty<SellerState> getSellerState() {
        return sellerState;
    }

    public String getPayoutAmount() {
        return dataModel.getTrade() != null
                ? btcFormatter.formatCoinWithCode(dataModel.getTrade().getPayoutAmount())
                : """";
    }

    String getMarketLabel(PendingTradesListItem item) {
        return item == null ? """" : tradeUtil.getMarketDescription(item.getTrade());
    }

    public String getRemainingTradeDurationAsWords() {
        checkNotNull(dataModel.getTrade(), ""model's trade must not be null"");
        return tradeUtil.getRemainingTradeDurationAsWords(dataModel.getTrade());
    }

    public double getRemainingTradeDurationAsPercentage() {
        checkNotNull(dataModel.getTrade(), ""model's trade must not be null"");
        return tradeUtil.getRemainingTradeDurationAsPercentage(dataModel.getTrade());
    }

    public String getDateForOpenDispute() {
        checkNotNull(dataModel.getTrade(), ""model's trade must not be null"");
        return DisplayUtils.formatDateTime(tradeUtil.getDateForOpenDispute(dataModel.getTrade()));
    }

    public boolean showWarning() {
        checkNotNull(dataModel.getTrade(), ""model's trade must not be null"");
        Date halfTradePeriodDate = tradeUtil.getHalfTradePeriodDate(dataModel.getTrade());
        return halfTradePeriodDate != null && new Date().after(halfTradePeriodDate);
    }

    public boolean showDispute() {
        return getMaxTradePeriodDate() != null && new Date().after(getMaxTradePeriodDate());
    }

    //

    String getMyRole(PendingTradesListItem item) {
        Trade trade = item.getTrade();
        Contract contract = trade.getContract();
        if (contract != null) {
            Offer offer = trade.getOffer();
            checkNotNull(offer);
            checkNotNull(offer.getCurrencyCode());
            return tradeUtil.getRole(contract.isBuyerMakerAndSellerTaker(),
                    dataModel.isMaker(offer),
                    offer.getCurrencyCode());
        } else {
            return """";
        }
    }

    String getPaymentMethod(PendingTradesListItem item) {
        return item == null ? """" : tradeUtil.getPaymentMethodNameWithCountryCode(item.getTrade());
    }

    // summary
    public String getTradeVolume() {
        return dataModel.getTrade() != null
                ? btcFormatter.formatCoinWithCode(dataModel.getTrade().getAmount())
                : """";
    }

    public String getFiatVolume() {
        return dataModel.getTrade() != null
                ? VolumeUtil.formatVolumeWithCode(dataModel.getTrade().getVolume())
                : """";
    }

    public String getTxFee() {
        if (trade != null && trade.getAmount() != null) {
            Coin txFee = dataModel.getTxFee();
            String percentage = GUIUtil.getPercentageOfTradeAmount(txFee,
                    trade.getAmount(),
                    Coin.ZERO);
            return btcFormatter.formatCoinWithCode(txFee) + percentage;
        } else {
            return """";
        }
    }

    public String getTradeFee() {
        if (trade != null && dataModel.getOffer() != null && trade.getAmount() != null) {
            checkNotNull(dataModel.getTrade());
            if (dataModel.isMaker() && dataModel.getOffer().isCurrencyForMakerFeeBtc() ||
                    !dataModel.isMaker() && dataModel.getTrade().isCurrencyForTakerFeeBtc()) {
                Coin tradeFeeInBTC = dataModel.getTradeFeeInBTC();

                Coin minTradeFee = dataModel.isMaker() ?
                        FeeService.getMinMakerFee(true) :
                        FeeService.getMinTakerFee(true);

                String percentage = GUIUtil.getPercentageOfTradeAmount(tradeFeeInBTC, trade.getAmount(),
                        minTradeFee);
                return btcFormatter.formatCoinWithCode(tradeFeeInBTC) + percentage;
            } else {
                return bsqFormatter.formatCoinWithCode(dataModel.getTradeFeeAsBsq());
            }
        } else {
            return """";
        }
    }

    public String getSecurityDeposit() {
        Offer offer = dataModel.getOffer();
        Trade trade = dataModel.getTrade();
        if (offer != null && trade != null && trade.getAmount() != null) {
            Coin securityDeposit = dataModel.isBuyer() ?
                    offer.getBuyerSecurityDeposit()
                    : offer.getSellerSecurityDeposit();

            Coin minSecurityDeposit = dataModel.isBuyer() ?
                    Restrictions.getMinBuyerSecurityDepositAsCoin() :
                    Restrictions.getMinSellerSecurityDepositAsCoin();

            String percentage = GUIUtil.getPercentageOfTradeAmount(securityDeposit,
                    trade.getAmount(),
                    minSecurityDeposit);
            return btcFormatter.formatCoinWithCode(securityDeposit) + percentage;
        } else {
            return """";
        }
    }

    public boolean isBlockChainMethod() {
        return offerUtil.isBlockChainPaymentMethod(dataModel.getOffer());
    }

    public int getNumPastTrades(Trade trade) {
        return closedTradableManager.getObservableList().stream()
                .filter(e -> {
                    if (e instanceof Trade) {
                        Trade t = (Trade) e;
                        return t.getTradingPeerNodeAddress() != null &&
                                trade.getTradingPeerNodeAddress() != null &&
                                t.getTradingPeerNodeAddress().getFullAddress().equals(trade.getTradingPeerNodeAddress().getFullAddress());
                    } else
                        return false;

                })
                .collect(Collectors.toSet())
                .size();
    }

    @Nullable
    private Date getMaxTradePeriodDate() {
        return dataModel.getTrade() != null
                ? dataModel.getTrade().getMaxTradePeriodDate()
                : null;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // States
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onTradeStateChanged(Trade.State tradeState) {
        log.info(""UI tradeState={}, id={}"",
                tradeState,
                trade != null ? trade.getShortId() : ""trade is null"");

        switch (tradeState) {
            // #################### Phase PREPARATION
            case PREPARATION:
                sellerState.set(UNDEFINED);
                buyerState.set(BuyerState.UNDEFINED);
                break;

            // At first part maker/taker have different roles
            // taker perspective
            // #################### Phase TAKER_FEE_PAID
            case TAKER_PUBLISHED_TAKER_FEE_TX:

                // PUBLISH_DEPOSIT_TX_REQUEST
                // maker perspective
            case MAKER_SENT_PUBLISH_DEPOSIT_TX_REQUEST:
            case MAKER_SAW_ARRIVED_PUBLISH_DEPOSIT_TX_REQUEST:
            case MAKER_STORED_IN_MAILBOX_PUBLISH_DEPOSIT_TX_REQUEST:
            case MAKER_SEND_FAILED_PUBLISH_DEPOSIT_TX_REQUEST:

                // taker perspective
            case TAKER_RECEIVED_PUBLISH_DEPOSIT_TX_REQUEST:
                // We don't have a UI state for that, we still have not a ready initiated trade
                sellerState.set(UNDEFINED);
                buyerState.set(BuyerState.UNDEFINED);
                break;


            // #################### Phase DEPOSIT_PAID
            // DEPOSIT_TX_PUBLISHED_MSG
            // seller perspective
            case SELLER_PUBLISHED_DEPOSIT_TX:
                // buyer perspective
            case BUYER_RECEIVED_DEPOSIT_TX_PUBLISHED_MSG:

                // Alternatively the maker could have seen the deposit tx earlier before he received the DEPOSIT_TX_PUBLISHED_MSG
            case BUYER_SAW_DEPOSIT_TX_IN_NETWORK:
                buyerState.set(BuyerState.STEP1);
                sellerState.set(SellerState.STEP1);
                break;


            // buyer and seller step 2
            // #################### Phase DEPOSIT_CONFIRMED
            case DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN:
                sellerState.set(SellerState.STEP2);
                buyerState.set(BuyerState.STEP2);
                break;

            // buyer step 3
            case BUYER_CONFIRMED_IN_UI_FIAT_PAYMENT_INITIATED: // UI action
            case BUYER_SENT_FIAT_PAYMENT_INITIATED_MSG:  // FIAT_PAYMENT_INITIATED_MSG sent
                // We don't switch the UI before we got the feedback of the msg delivery
                buyerState.set(BuyerState.STEP2);
                break;
            case BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG:  // FIAT_PAYMENT_INITIATED_MSG arrived
            case BUYER_STORED_IN_MAILBOX_FIAT_PAYMENT_INITIATED_MSG:  // FIAT_PAYMENT_INITIATED_MSG in mailbox
                buyerState.set(BuyerState.STEP3);
                break;
            case BUYER_SEND_FAILED_FIAT_PAYMENT_INITIATED_MSG:  // FIAT_PAYMENT_INITIATED_MSG failed
                // if failed we need to repeat sending so back to step 2
                buyerState.set(BuyerState.STEP2);
                break;

            // seller step 3
            case SELLER_RECEIVED_FIAT_PAYMENT_INITIATED_MSG: // FIAT_PAYMENT_INITIATED_MSG received
                sellerState.set(SellerState.STEP3);
                break;

            // seller step 4
            case SELLER_CONFIRMED_IN_UI_FIAT_PAYMENT_RECEIPT:   // UI action
            case SELLER_PUBLISHED_PAYOUT_TX: // payout tx broad casted
            case SELLER_SENT_PAYOUT_TX_PUBLISHED_MSG: // PAYOUT_TX_PUBLISHED_MSG sent
                sellerState.set(SellerState.STEP3);
                break;
            case SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG: // PAYOUT_TX_PUBLISHED_MSG arrived
            case SELLER_STORED_IN_MAILBOX_PAYOUT_TX_PUBLISHED_MSG: // PAYOUT_TX_PUBLISHED_MSG mailbox
            case SELLER_SEND_FAILED_PAYOUT_TX_PUBLISHED_MSG: // PAYOUT_TX_PUBLISHED_MSG failed -  payout tx is published, peer will see it in network so we ignore failure and complete
                sellerState.set(SellerState.STEP4);
                break;

            // buyer step 4
            case BUYER_RECEIVED_PAYOUT_TX_PUBLISHED_MSG:
                // Alternatively the maker could have seen the payout tx earlier before he received the PAYOUT_TX_PUBLISHED_MSG:
            case BUYER_SAW_PAYOUT_TX_IN_NETWORK:
                buyerState.set(BuyerState.STEP4);
                break;

            case WITHDRAW_COMPLETED:
                sellerState.set(UNDEFINED);
                buyerState.set(BuyerState.UNDEFINED);
                break;

            default:
                sellerState.set(UNDEFINED);
                buyerState.set(BuyerState.UNDEFINED);
                log.warn(""unhandled processState "" + tradeState);
                DevEnv.logErrorAndThrowIfDevMode(""unhandled processState "" + tradeState);
                break;
        }
    }
}",1,439 334 2000 378 2001 60 2002 62 395 2003 123 64 2004 64 2005 437 2006 2007 59 405 2008 123 125 370 2009 395 2008 123 2010 44 2011 44 2012 44 2013 44 2014 125 370 2015 395 2008 123 2016 44 2017 44 2018 44 2019 44 2020 125 439 381 2021 2022 59 437 381 2023 2024 59 439 381 2025 2026 59 381 2027 2028 59 439 381 2029 2030 59 437 381 2031 2032 59 437 381 2033 2034 59 437 381 2035 2036 59 437 381 2037 2038 59 439 381 2039 2040 59 64 2004 437 381 2041 2042 59 64 2004 437 381 2043 2044 59 437 381 2045 60 2009 62 2046 61 418 2047 60 62 40 41 59 437 381 2045 60 2015 62 2048 61 418 2047 60 62 40 41 59 64 2004 437 381 2045 60 2049 62 2050 61 418 2047 60 62 40 2049 46 2051 41 59 437 2052 2053 59 437 2052 2054 59 64 2004 438 381 2055 2056 61 418 2057 40 41 59 621 621 621 64 2058 439 2000 40 2002 2059 44 64 2060 40 2061 46 2062 41 2021 2022 44 2023 2024 44 2025 2026 44 2029 2030 44 2031 2032 44 2033 2034 44 2035 2036 44 2037 2038 44 2027 2028 44 2039 2040 44 2041 2042 44 2043 2044 41 123 463 40 2059 41 59 467 46 2022 61 2022 59 467 46 2024 61 2024 59 467 46 2026 61 2026 59 467 46 2030 61 2030 59 467 46 2032 61 2032 59 467 46 2034 61 2034 59 467 46 2036 61 2036 59 467 46 2038 61 2038 59 467 46 2028 61 2028 59 467 46 2040 61 2040 59 467 46 2042 61 2042 59 467 46 2044 61 2044 59 125 64 2063 438 492 2064 40 41 123 392 40 2053 631 424 41 123 2053 46 2065 40 41 59 2053 61 424 59 125 392 40 2054 631 424 41 123 2054 46 2066 40 41 59 2054 61 424 59 125 125 621 439 492 2067 40 2068 2069 41 123 392 40 2053 631 424 41 123 2053 46 2070 40 41 59 2048 46 2071 40 2015 46 2051 41 59 2046 46 2071 40 2009 46 2051 41 59 125 392 40 2054 631 424 41 123 2054 46 2072 40 41 59 2050 46 2073 40 2049 46 2051 41 59 125 392 40 2069 631 424 41 123 467 46 2007 61 2069 46 2074 40 41 59 2053 61 2075 46 2076 40 2007 46 2077 40 41 44 467 58 58 2078 41 59 2054 61 2075 46 2076 40 2007 46 2079 40 41 46 2080 40 41 44 467 58 58 2081 41 59 125 125 439 492 2082 40 2049 2083 41 123 392 40 2050 46 2084 40 41 614 2049 46 2085 41 123 2086 46 2087 40 648 43 648 44 2083 41 59 450 59 125 392 40 2007 631 424 41 2007 46 2088 40 41 46 2089 40 2083 41 59 125 437 492 2090 40 2049 2083 41 123 2050 46 2091 40 2083 41 59 125 439 492 2092 40 2006 2007 41 123 2056 46 2093 40 45 1501 41 59 2032 46 2094 40 2007 44 40 2095 45 62 123 2056 46 2093 40 2095 46 2096 40 41 63 1500 58 1501 41 59 392 40 2095 46 2096 40 41 41 123 2097 2098 61 648 43 2095 46 2099 40 41 59 2100 46 2101 40 2098 41 59 621 392 40 2007 46 2102 40 41 614 2006 46 2103 46 2104 41 123 2105 46 2106 40 40 41 45 62 123 2107 2108 61 418 2107 40 41 59 2108 46 2109 40 2110 46 2111 40 648 41 41 46 2112 40 2110 46 2111 40 648 44 2098 41 41 46 2113 40 2110 46 2111 40 648 41 41 46 2114 40 2059 58 58 2115 41 46 2116 40 2110 46 2111 40 648 41 41 46 2117 40 2108 58 58 2118 41 46 2119 40 41 59 125 44 1503 44 2120 46 2121 41 59 125 125 125 41 41 59 125 621 621 621 2122 60 2009 62 2123 40 41 123 450 2046 59 125 2122 60 2015 62 2124 40 41 123 450 2048 59 125 439 2125 2126 40 41 123 450 2059 46 2127 40 41 631 424 63 2022 46 2128 40 2059 46 2127 40 41 46 2126 40 41 41 58 648 59 125 2125 2129 40 2068 2130 41 123 450 2130 614 424 63 648 58 2038 46 2131 40 2130 46 2132 40 41 41 59 125 439 2125 2133 40 41 123 2134 40 2059 46 2135 40 41 44 648 41 59 450 2038 46 2133 40 2059 46 2135 40 41 41 59 125 439 356 2136 40 41 123 2137 40 2059 46 2138 40 41 44 648 41 59 450 2038 46 2136 40 2059 46 2138 40 41 41 59 125 439 2125 2139 40 41 123 2140 40 2059 46 2141 40 41 44 648 41 59 450 2142 46 2143 40 2038 46 2139 40 2059 46 2141 40 41 41 41 59 125 439 324 2144 40 41 123 2145 40 2059 46 2146 40 41 44 648 41 59 2147 2148 61 2038 46 2149 40 2059 46 2146 40 41 41 59 450 2148 631 424 605 418 2147 40 41 46 2150 40 2148 41 59 125 439 324 2151 40 41 123 450 2152 40 41 631 424 605 418 2153 40 41 46 2154 40 2152 40 41 41 59 125 621 2125 2155 40 2068 2130 41 123 2006 2007 61 2130 46 2156 40 41 59 2157 2158 61 2007 46 2159 40 41 59 392 40 2158 631 424 41 123 2160 2161 61 2007 46 2162 40 41 59 2163 40 2161 41 59 2163 40 2161 46 2164 40 41 41 59 450 2038 46 2165 40 2158 46 2166 40 41 44 2059 46 2167 40 2161 41 44 2161 46 2164 40 41 41 59 125 360 123 450 648 59 125 125 2125 2168 40 2068 2130 41 123 450 2130 614 424 63 648 58 2038 46 2169 40 2130 46 2170 40 41 41 59 125 621 439 2125 2171 40 41 123 450 2059 46 2172 40 41 631 424 63 2022 46 2173 40 2059 46 2172 40 41 46 2174 40 41 41 58 648 59 125 439 2125 2175 40 41 123 450 2059 46 2176 40 41 631 424 63 2177 46 2178 40 2059 46 2176 40 41 46 2179 40 41 41 58 648 59 125 439 2125 2180 40 41 123 392 40 2007 631 424 605 2007 46 2181 40 41 631 424 41 123 2182 2183 61 2059 46 2180 40 41 59 2125 2184 61 2185 46 2186 40 2183 44 2007 46 2181 40 41 44 2182 46 2187 41 59 450 2022 46 2188 40 2183 41 43 2184 59 125 360 123 450 648 59 125 125 439 2125 2189 40 41 123 392 40 2007 631 424 605 2059 46 2190 40 41 631 424 605 2007 46 2191 40 41 631 424 41 123 2192 40 2059 46 2193 40 41 41 59 392 40 2059 46 2194 40 41 605 2059 46 2190 40 41 46 2195 40 41 606 33 2059 46 2194 40 41 605 2059 46 2193 40 41 46 2196 40 41 41 123 2197 2198 61 2059 46 2199 40 41 59 2197 2200 61 2059 46 2194 40 41 63 2201 46 2202 40 473 41 58 2201 46 2203 40 473 41 59 2125 2204 61 2205 46 2206 40 2198 44 2007 46 2191 40 41 44 2200 41 59 450 2022 46 2207 40 2198 41 43 2204 59 125 360 123 450 2024 46 2208 40 2059 46 2209 40 41 41 59 125 125 360 123 450 648 59 125 125 439 2125 2210 40 41 123 2211 2212 61 2059 46 2213 40 41 59 2006 2007 61 2059 46 2214 40 41 59 392 40 2212 631 424 605 2007 631 424 605 2007 46 2215 40 41 631 424 41 123 2216 2217 61 2059 46 2218 40 41 63 2212 46 2219 40 41 58 2212 46 2220 40 41 59 2216 2221 61 2059 46 2218 40 41 63 2222 46 2223 40 41 58 2222 46 2224 40 41 59 2125 2225 61 2226 46 2227 40 2217 44 2007 46 2215 40 41 44 2221 41 59 450 2022 46 2228 40 2217 41 43 2225 59 125 360 123 450 648 59 125 125 439 324 2229 40 41 123 450 2036 46 2230 40 2059 46 2231 40 41 41 59 125 439 404 2232 40 2006 2007 41 123 450 2034 46 2233 40 41 46 2234 40 41 46 2235 40 2236 45 62 123 392 40 2236 402 2006 41 123 2006 2237 61 40 2006 41 2236 59 450 2237 46 2238 40 41 631 424 605 2007 46 2238 40 41 631 424 605 2237 46 2238 40 41 46 2239 40 41 46 2240 40 2007 46 2238 40 41 46 2239 40 41 41 59 125 360 450 380 59 125 41 46 2241 40 2242 46 2243 40 41 41 46 2244 40 41 59 125 64 2005 437 2245 2246 40 41 123 450 2059 46 2247 40 41 631 424 63 2059 46 2247 40 41 46 2246 40 41 58 424 59 125 621 621 621 437 492 2248 40 2006 46 2008 2249 41 123 2250 46 2251 40 648 44 2249 44 2007 631 424 63 2007 46 2252 40 41 58 648 41 59 464 40 2249 41 123 621 328 2253 58 2048 46 2254 40 2051 41 59 2046 46 2254 40 2009 46 2051 41 59 325 59 621 621 621 328 2255 58 621 621 328 2256 58 328 2257 58 328 2258 58 328 2259 58 621 328 2260 58 621 2048 46 2254 40 2051 41 59 2046 46 2254 40 2009 46 2051 41 59 325 59 621 621 621 328 2261 58 621 328 2262 58 621 328 2263 58 2046 46 2254 40 2009 46 2264 41 59 2048 46 2254 40 2015 46 2264 41 59 325 59 621 621 328 2265 58 2048 46 2254 40 2015 46 2266 41 59 2046 46 2254 40 2009 46 2266 41 59 325 59 621 328 2267 58 621 328 2268 58 621 621 2046 46 2254 40 2009 46 2266 41 59 325 59 328 2269 58 621 328 2270 58 621 2046 46 2254 40 2009 46 2271 41 59 325 59 328 2272 58 621 621 2046 46 2254 40 2009 46 2266 41 59 325 59 621 328 2273 58 621 2048 46 2254 40 2015 46 2271 41 59 325 59 621 328 2274 58 621 328 2275 58 621 328 2276 58 621 2048 46 2254 40 2015 46 2271 41 59 325 59 328 2277 58 621 328 2278 58 621 328 2279 58 621 2048 46 2254 40 2015 46 2280 41 59 325 59 621 328 2281 58 621 328 2282 58 2046 46 2254 40 2009 46 2280 41 59 325 59 328 2283 58 2048 46 2254 40 2051 41 59 2046 46 2254 40 2009 46 2051 41 59 325 59 349 58 2048 46 2254 40 2051 41 59 2046 46 2254 40 2009 46 2051 41 59 2250 46 2284 40 648 43 2249 41 59 2285 46 2286 40 648 43 2249 41 59 325 59 125 125 125 
