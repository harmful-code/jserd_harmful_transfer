id,language,text,smell,tokens,metrics
99076,C++,"class GMLASFakeDataset final: public GDALDataset
{
    public:
        GMLASFakeDataset() {}
};",0,587 2000 2001 58 777 2002 123 777 58 2000 40 41 123 125 125 59 ,"{'AvgLine': 1, 'CountLine': 5, 'CountStmt': 1, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 5, 'CountStmtDecl': 1, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 0, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 1, 'AltCountLineCode': 5, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 0, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 143, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98787,C++,"class ods_formula_parse_context {
public:
    ods_formula_parse_context() :
        nStartToken(0),
        pszInput(nullptr),
        pszNext(nullptr),
        poRoot(nullptr) {}

    int        nStartToken;
    const char *pszInput;
    const char *pszNext;

    ods_formula_node *poRoot;
};",0,587 2000 123 777 58 2000 40 41 58 2001 40 1500 41 44 2002 40 753 41 44 2003 40 753 41 44 2004 40 753 41 123 125 704 2001 59 601 582 42 2002 59 601 582 42 2003 59 2005 42 2004 59 125 59 ,"{'AvgLine': 5, 'CountLine': 14, 'CountStmt': 9, 'MaxNesting': 0, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 12, 'CountStmtDecl': 9, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 1, 'AltCountLineCode': 12, 'CountLineCodeExe': 4, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 1, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 4, 'CountDeclInstanceVariablePublic': 4, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98696,C++,"class IVFKReader
{
private:
    virtual void AddInfo(const char *) = 0;

protected:
    virtual IVFKDataBlock *CreateDataBlock(const char *) = 0;
    virtual void           AddDataBlock(IVFKDataBlock * = nullptr, const char * = nullptr) = 0;
    virtual OGRErr         AddFeature(IVFKDataBlock * = nullptr, VFKFeature * = nullptr) = 0;

public:
    virtual ~IVFKReader();

    virtual const char    *GetFilename() const = 0;

    virtual bool           IsLatin2() const = 0;
    virtual bool           IsSpatial() const = 0;
    virtual bool           IsPreProcessed() const = 0;
    virtual bool           IsValid() const = 0;
    virtual bool           HasFileField() const = 0;
    virtual int            ReadDataBlocks(bool = false) = 0;
    virtual int            ReadDataRecords(IVFKDataBlock * = nullptr) = 0;
    virtual int            LoadGeometry() = 0;

    virtual int            GetDataBlockCount() const = 0;
    virtual IVFKDataBlock *GetDataBlock(int) const = 0;
    virtual IVFKDataBlock *GetDataBlock(const char *) const = 0;

    virtual const char    *GetInfo(const char *) = 0;
};",0,587 2000 123 773 58 864 865 2001 40 601 582 42 41 61 1500 59 775 58 864 2002 42 2003 40 601 582 42 41 61 1500 59 864 865 2004 40 2002 42 61 753 44 601 582 42 61 753 41 61 1500 59 864 2005 2006 40 2002 42 61 753 44 2007 42 61 753 41 61 1500 59 777 58 864 126 2000 40 41 59 864 601 582 42 2008 40 41 601 61 1500 59 864 569 2009 40 41 601 61 1500 59 864 569 2010 40 41 601 61 1500 59 864 569 2011 40 41 601 61 1500 59 864 569 2012 40 41 601 61 1500 59 864 569 2013 40 41 601 61 1500 59 864 704 2014 40 569 61 655 41 61 1500 59 864 704 2015 40 2002 42 61 753 41 61 1500 59 864 704 2016 40 41 61 1500 59 864 704 2017 40 41 601 61 1500 59 864 2002 42 2018 40 704 41 601 61 1500 59 864 2002 42 2018 40 601 582 42 41 601 61 1500 59 864 601 582 42 2019 40 601 582 42 41 61 1500 59 125 59 ,"{'AvgLine': 3, 'CountLine': 33, 'CountStmt': 18, 'MaxNesting': 0, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 27, 'CountStmtDecl': 18, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 3, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 6, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 18, 'AltCountLineCode': 27, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 6, 'CountClassCoupled': 2, 'CountClassDerived': 1, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 18, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 9, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 14, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 19, 'CountDeclMethodProtected': 3, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99052,C++,    RegisterMinidriver(TileService);,0,2000 40 2001 41 59 ,"{'AvgLine': 27, 'CountLine': 27, 'CountStmt': 5, 'MaxNesting': 0, 'AvgLineCode': 23, 'AvgEssential': 1, 'AvgLineBlank': 4, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 1, 'CountLineCode': 23, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 3, 'AltAvgLineCode': 23, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 4, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 4, 'CountDeclMethod': 3, 'AltCountLineCode': 23, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 4, 'CountClassCoupled': 3, 'CountClassDerived': 0, 'CountLineCodeDecl': 0, 'CountLineInactive': 0, 'CountDeclMethodAll': 6, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 3, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 3, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98999,C++,"    class MetadataSet
    {
    public:
        MetadataSet();
        ~MetadataSet();

        void        Initialize( PCIDSKFile *file, const std::string& group, int id );
        std::string GetMetadataValue( const std::string& key );
        void        SetMetadataValue( const std::string& key, const std::string& value );
        std::vector<std::string> GetMetadataKeys();

    private:
        PCIDSKFile  *file;

        bool         loaded;
        std::map<std::string,std::string> md_set;

        std::string  group;
        int          id;

        void         Load();
    };",0,587 2000 123 777 58 2000 40 41 59 126 2000 40 41 59 865 2001 40 2002 42 2003 44 601 2004 321 2005 38 2006 44 704 2007 41 59 2004 321 2005 2008 40 601 2004 321 2005 38 2009 41 59 865 2010 40 601 2004 321 2005 38 2009 44 601 2004 321 2005 38 2011 41 59 2004 321 2012 60 2004 321 2005 62 2013 40 41 59 773 58 2002 42 2003 59 569 2014 59 2004 321 2015 60 2004 321 2005 44 2004 321 2005 62 2016 59 2004 321 2005 2006 59 704 2007 59 865 2017 40 41 59 125 59 ,"{'AvgLine': 14, 'CountLine': 123, 'CountStmt': 58, 'MaxNesting': 2, 'AvgLineCode': 11, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 44, 'MaxEssential': 4, 'SumEssential': 10, 'AvgCyclomatic': 2, 'CountLineCode': 95, 'CountStmtDecl': 19, 'MaxCyclomatic': 5, 'SumCyclomatic': 20, 'AltAvgLineCode': 11, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 24, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 7, 'AltCountLineCode': 95, 'CountLineCodeExe': 48, 'CountLineComment': 5, 'AltAvgLineComment': 0, 'AltCountLineBlank': 24, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 14, 'CountLineInactive': 0, 'CountDeclMethodAll': 7, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.05', 'AltCountLineComment': 5, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 5, 'SumCyclomaticStrict': 20, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 6, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 5, 'PercentLackOfCohesion': 51, 'SumCyclomaticModified': 20, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 9, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 5, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 5, 'CountDeclInstanceVariableProtected': 0}"
98804,C++,"    class PCIDSKBinarySegment
    {
    public:
        virtual const char* GetBuffer(void) const = 0;
        virtual unsigned int GetBufferSize(void) const = 0;
        virtual void SetBuffer(const char* pabyBuf,
            unsigned int nBufSize) = 0;

        // Virtual destructor
        virtual ~PCIDSKBinarySegment() {}
    };",0,587 2000 123 777 58 864 601 582 42 2001 40 865 41 601 61 1500 59 864 856 704 2002 40 865 41 601 61 1500 59 864 865 2003 40 601 582 42 2004 44 856 704 2005 41 61 1500 59 330 864 126 2000 40 41 123 125 125 59 ,"{'AvgLine': 1, 'CountLine': 11, 'CountStmt': 4, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 9, 'CountStmtDecl': 4, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 4, 'AltCountLineCode': 9, 'CountLineCodeExe': 0, 'CountLineComment': 1, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 0, 'CountClassDerived': 1, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.11', 'AltCountLineComment': 1, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98616,C++,"class OGRJMLDataset final: public GDALDataset
{
    OGRLayer           *poLayer;

    VSILFILE           *fp; /* Virtual file API */
    bool                bWriteMode;

  public:
                        OGRJMLDataset();
                        ~OGRJMLDataset();

    int                 GetLayerCount() override { return poLayer != nullptr ? 1 : 0; }
    OGRLayer*           GetLayer( int ) override;

    OGRLayer *          ICreateLayer( const char * pszLayerName,
                                    OGRSpatialReference *poSRS,
                                    OGRwkbGeometryType eType,
                                    char ** papszOptions ) override;

    int                 TestCapability( const char * ) override;

    static int          Identify( GDALOpenInfo* poOpenInfo );
    static GDALDataset* Open( GDALOpenInfo* poOpenInfo );
    static GDALDataset* Create( const char *pszFilename,
                                 int nBands,
                                 int nXSize,
                                 int nYSize,
                                 GDALDataType eDT,
                                 char **papszOptions );
};",0,587 2000 2001 58 777 2002 123 2003 42 2004 59 2005 42 2006 59 305 569 2007 59 777 58 2000 40 41 59 126 2000 40 41 59 704 2008 40 41 2009 123 792 2004 340 753 63 1501 58 1500 59 125 2003 42 2010 40 704 41 2009 59 2003 42 2011 40 601 582 42 2012 44 2013 42 2014 44 2015 2016 44 582 42 42 2017 41 2009 59 704 2018 40 601 582 42 41 2009 59 809 704 2019 40 2020 42 2021 41 59 809 2002 42 2022 40 2020 42 2021 41 59 809 2002 42 2023 40 601 582 42 2024 44 704 2025 44 704 2026 44 704 2027 44 2028 2029 44 582 42 42 2017 41 59 125 59 ,"{'AvgLine': 14, 'CountLine': 162, 'CountStmt': 57, 'MaxNesting': 1, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 40, 'MaxEssential': 3, 'SumEssential': 11, 'AvgCyclomatic': 2, 'CountLineCode': 121, 'CountStmtDecl': 21, 'MaxCyclomatic': 4, 'SumCyclomatic': 20, 'AltAvgLineCode': 12, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 22, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 9, 'AltCountLineCode': 131, 'CountLineCodeExe': 58, 'CountLineComment': 13, 'AltAvgLineComment': 1, 'AltCountLineBlank': 25, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 34, 'CountLineInactive': 10, 'CountDeclMethodAll': 151, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.11', 'AltCountLineComment': 13, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 5, 'SumCyclomaticStrict': 25, 'CountDeclClassMethod': 3, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 9, 'CountLinePreprocessor': 3, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 57, 'SumCyclomaticModified': 20, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 8, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
99049,C++,    RegisterMinidriver(OGCAPICoverage);,0,2000 40 2001 41 59 ,"{'AvgLine': 18, 'CountLine': 18, 'CountStmt': 5, 'MaxNesting': 0, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 4, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 1, 'CountLineCode': 14, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 3, 'AltAvgLineCode': 14, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 4, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 4, 'CountDeclMethod': 3, 'AltCountLineCode': 14, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 4, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 0, 'CountLineInactive': 0, 'CountDeclMethodAll': 6, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 3, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 3, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98962,C++,"class PackedRTree {
    NodeItem _extent;
    NodeItem *_nodeItems = nullptr;
    uint64_t _numItems;
    uint64_t _numNodes;
    uint16_t _nodeSize;
    std::vector<std::pair<uint64_t, uint64_t>> _levelBounds;
    void init(const uint16_t nodeSize);
    void generateNodes();
    void fromData(const void *data);
public:
    ~PackedRTree() {
        if (_nodeItems != nullptr)
            delete[] _nodeItems;
    }
    PackedRTree(const std::vector<std::shared_ptr<Item>> &items, const NodeItem &extent, const uint16_t nodeSize = 16);
    PackedRTree(const std::vector<NodeItem> &nodes, const NodeItem &extent, const uint16_t nodeSize = 16);
    PackedRTree(const void *data, const uint64_t numItems, const uint16_t nodeSize = 16);
    std::vector<SearchResultItem> search(double minX, double minY, double maxX, double maxY) const;
    static std::vector<SearchResultItem> streamSearch(
        const uint64_t numItems, const uint16_t nodeSize, const NodeItem &item,
        const std::function<void(uint8_t *, size_t, size_t)> &readNode);
    static std::vector<std::pair<uint64_t, uint64_t>> generateLevelBounds(const uint64_t numItems, const uint16_t nodeSize);
    uint64_t size() const;
    static uint64_t size(const uint64_t numItems, const uint16_t nodeSize = 16);
    NodeItem getExtent() const;
    void streamWrite(const std::function<void(uint8_t *, size_t)> &writeData);
};",0,587 2000 123 2001 2002 59 2001 42 2003 61 753 59 2004 2005 59 2004 2006 59 2007 2008 59 2009 321 2010 60 2009 321 2011 60 2004 44 2004 355 2012 59 865 2013 40 601 2007 2014 41 59 865 2015 40 41 59 865 2016 40 601 865 42 2017 41 59 777 58 126 2000 40 41 123 688 40 2003 340 753 41 619 91 93 2003 59 125 2000 40 601 2009 321 2010 60 2009 321 2018 60 2019 355 38 2020 44 601 2001 38 2021 44 601 2007 2014 61 1503 41 59 2000 40 601 2009 321 2010 60 2001 62 38 2022 44 601 2001 38 2021 44 601 2007 2014 61 1503 41 59 2000 40 601 865 42 2017 44 601 2004 2023 44 601 2007 2014 61 1503 41 59 2009 321 2010 60 2024 62 2025 40 625 2026 44 625 2027 44 625 2028 44 625 2029 41 601 59 809 2009 321 2010 60 2024 62 2030 40 601 2004 2023 44 601 2007 2014 44 601 2001 38 2031 44 601 2009 321 2032 60 865 40 2033 42 44 2034 44 2034 41 62 38 2035 41 59 809 2009 321 2010 60 2009 321 2011 60 2004 44 2004 355 2036 40 601 2004 2023 44 601 2007 2014 41 59 2004 2037 40 41 601 59 809 2004 2037 40 601 2004 2023 44 601 2007 2014 61 1503 41 59 2001 2038 40 41 601 59 865 2039 40 601 2009 321 2032 60 865 40 2033 42 44 2034 41 62 38 2040 41 59 125 59 ,"{'AvgLine': 15, 'CountLine': 238, 'CountStmt': 161, 'MaxNesting': 3, 'AvgLineCode': 12, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 122, 'MaxEssential': 4, 'SumEssential': 20, 'AvgCyclomatic': 2, 'CountLineCode': 198, 'CountStmtDecl': 78, 'MaxCyclomatic': 7, 'SumCyclomatic': 41, 'AltAvgLineCode': 14, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 14, 'AltCountLineCode': 228, 'CountLineCodeExe': 135, 'CountLineComment': 8, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 21, 'CountClassDerived': 0, 'CountLineCodeDecl': 66, 'CountLineInactive': 24, 'CountDeclMethodAll': 14, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 8, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 7, 'SumCyclomaticStrict': 42, 'CountDeclClassMethod': 3, 'CountDeclMethodConst': 3, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 11, 'CountLinePreprocessor': 6, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 64, 'SumCyclomaticModified': 41, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 3, 'CountDeclInstanceMethod': 13, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 6, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 6, 'CountDeclInstanceVariableProtected': 0}"
99114,C++,"    class PCIDSK_DLL PCIDSK_BLUT
    {
    public:
        virtual ~PCIDSK_BLUT() {}

/**
\brief Read a LUT Segment (SEG_BLUT).

@param vBLUT  Breakpoint Pseudo-Color Table buffer into which the breakpoint
pseudo-color table is read.  It consists of a vector of BLUTEntry.

*/
        virtual void ReadBLUT(std::vector<BLUTEntry>& vBLUT) = 0;

/**
\brief Write a BLUT Segment.

@param vBLUT  Breakpoint Pseudo-Color Table buffer from which the breakpoint
pseudo-color table is written.  It consists of a vector of BLUTEntry.

*/
        virtual void WriteBLUT(const std::vector<BLUTEntry>& vBLUT) = 0;
    };",0,587 2000 2001 123 777 58 864 126 2001 40 41 123 125 306 864 865 2002 40 2003 321 2004 60 2005 62 38 2006 41 61 1500 59 306 864 865 2007 40 601 2003 321 2004 60 2005 62 38 2006 41 61 1500 59 125 59 ,"{'AvgLine': 1, 'CountLine': 23, 'CountStmt': 3, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 7, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 3, 'AltCountLineCode': 7, 'CountLineCodeExe': 0, 'CountLineComment': 14, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 2, 'CountClassDerived': 1, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 3, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '2.00', 'AltCountLineComment': 14, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98798,C++,"class NullLock {
 public:
  void lock() {}
  void unlock() {}
  bool try_lock() { return true; }
};",0,587 2000 123 777 58 865 2001 40 41 123 125 865 2002 40 41 123 125 569 2003 40 41 123 792 829 59 125 125 59 ,"{'AvgLine': 1, 'CountLine': 6, 'CountStmt': 4, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 1, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 1, 'CountLineCode': 6, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 3, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 0, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 3, 'AltCountLineCode': 6, 'CountLineCodeExe': 1, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 0, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 4, 'CountLineInactive': 0, 'CountDeclMethodAll': 3, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 3, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 3, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 3, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98857,C++,"class CPL_DLL CPLODBCSession {

    CPL_DISALLOW_COPY_ASSIGN(CPLODBCSession)

    CPLString m_osLastError{};
    HENV      m_hEnv = nullptr;
    HDBC      m_hDBC = nullptr;
    int       m_bInTransaction = false;
    int       m_bAutoCommit = true;

  public:
    CPLODBCSession();
    ~CPLODBCSession();

    int         EstablishSession( const char *pszDSN,
                                  const char *pszUserid,
                                  const char *pszPassword );
    const char  *GetLastError();

    // Transaction handling

    int         ClearTransaction();
    int         BeginTransaction();
    int         CommitTransaction();
    int         RollbackTransaction();
    /** Returns whether a transaction is active */
    int         IsInTransaction() { return m_bInTransaction; }

    // Essentially internal.

    int         CloseSession();

    int         Failed( int, HSTMT = nullptr );
    /** Return connection handle */
    HDBC        GetConnection() { return m_hDBC; }
    /** Return GetEnvironment handle */
    HENV        GetEnvironment()  { return m_hEnv; }

    bool ConnectToMsAccess( const char * pszName, const char* pszDSNStringTemplate );

};",0,587 2000 2001 123 2002 40 2001 41 2003 2004 123 125 59 2005 2006 61 753 59 2007 2008 61 753 59 704 2009 61 655 59 704 2010 61 829 59 777 58 2001 40 41 59 126 2001 40 41 59 704 2011 40 601 582 42 2012 44 601 582 42 2013 44 601 582 42 2014 41 59 601 582 42 2015 40 41 59 330 704 2016 40 41 59 704 2017 40 41 59 704 2018 40 41 59 704 2019 40 41 59 306 704 2020 40 41 123 792 2009 59 125 330 704 2021 40 41 59 704 2022 40 704 44 2023 61 753 41 59 306 2007 2024 40 41 123 792 2008 59 125 306 2005 2025 40 41 123 792 2006 59 125 569 2026 40 601 582 42 2027 44 601 582 42 2028 41 59 125 59 ,"{'AvgLine': 20, 'CountLine': 328, 'CountStmt': 71, 'MaxNesting': 2, 'AvgLineCode': 12, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 40, 'MaxEssential': 4, 'SumEssential': 17, 'AvgCyclomatic': 1, 'CountLineCode': 198, 'CountStmtDecl': 32, 'MaxCyclomatic': 7, 'SumCyclomatic': 26, 'AltAvgLineCode': 17, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 39, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 3, 'CountDeclMethod': 16, 'AltCountLineCode': 260, 'CountLineCodeExe': 53, 'CountLineComment': 7, 'AltAvgLineComment': 0, 'AltCountLineBlank': 53, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 52, 'CountLineInactive': 72, 'CountDeclMethodAll': 16, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 15, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 7, 'SumCyclomaticStrict': 26, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 14, 'CountLinePreprocessor': 22, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 26, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 16, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 5, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
99011,C++,"    class SG_Exception_Existential: public SG_Exception
    {
        std::string err_msg;

        public:
            const char* get_err_msg() override { return err_msg.c_str(); }
        
        SG_Exception_Existential(const char* geometry_container, const char* missing_name);
    };",0,587 2000 58 777 2001 123 2002 321 2003 2004 59 777 58 601 582 42 2005 40 41 2006 123 792 2004 46 2007 40 41 59 125 2000 40 601 582 42 2008 44 601 582 42 2009 41 59 125 59 ,"{'AvgLine': 5, 'CountLine': 18, 'CountStmt': 7, 'MaxNesting': 0, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 15, 'CountStmtDecl': 5, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 4, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 15, 'CountLineCodeExe': 6, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 5, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 71, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
99050,C++,    RegisterMinidriver(OGCAPIMaps);,0,2000 40 2001 41 59 ,"{'AvgLine': 19, 'CountLine': 19, 'CountStmt': 5, 'MaxNesting': 0, 'AvgLineCode': 15, 'AvgEssential': 1, 'AvgLineBlank': 4, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 1, 'CountLineCode': 15, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 3, 'AltAvgLineCode': 15, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 4, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 4, 'CountDeclMethod': 3, 'AltCountLineCode': 15, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 4, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 0, 'CountLineInactive': 0, 'CountDeclMethodAll': 6, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 3, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 3, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98856,C++,"class OGREDIGEOObjectDescriptor
{
    public:
        OGREDIGEOObjectDescriptor() {}

        CPLString osRID;        /* e.g. BATIMENT_id */
        CPLString osNameRID;    /* e.g. ID_N_OBJ_E_2_1_0 */
        CPLString osKND;        /* e.g. ARE */
        strListType aosAttrRID; /* e.g. DUR_id, TEX_id */
};",0,587 2000 123 777 58 2000 40 41 123 125 2001 2002 59 305 2001 2003 59 305 2001 2004 59 305 2005 2006 59 305 125 59 ,"{'AvgLine': 1, 'CountLine': 10, 'CountStmt': 8, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 3, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 9, 'CountStmtDecl': 5, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 1, 'AltCountLineCode': 9, 'CountLineCodeExe': 1, 'CountLineComment': 4, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.44', 'AltCountLineComment': 4, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 81, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 4, 'CountDeclInstanceVariablePublic': 4, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98869,C++,"class WMSMiniDriver_IIP : public WMSMiniDriver {
public:
    WMSMiniDriver_IIP();
    virtual ~WMSMiniDriver_IIP();

public:
    virtual CPLErr Initialize(CPLXMLNode *config, char **papszOpenOptions) override;
    virtual void GetCapabilities(WMSMiniDriverCapabilities *caps) override;
    virtual CPLErr TiledImageRequest(WMSHTTPRequest &request,
                                     const GDALWMSImageRequestInfo &iri,
                                     const GDALWMSTiledImageRequestInfo &tiri) override;
};",0,587 2000 58 777 2001 123 777 58 2000 40 41 59 864 126 2000 40 41 59 777 58 864 2002 2003 40 2004 42 2005 44 582 42 42 2006 41 2007 59 864 865 2008 40 2009 42 2010 41 2007 59 864 2002 2011 40 2012 38 2013 44 601 2014 38 2015 44 601 2016 38 2017 41 2007 59 125 59 ,"{'AvgLine': 6, 'CountLine': 46, 'CountStmt': 20, 'MaxNesting': 1, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 11, 'MaxEssential': 1, 'SumEssential': 5, 'AvgCyclomatic': 1, 'CountLineCode': 42, 'CountStmtDecl': 9, 'MaxCyclomatic': 2, 'SumCyclomatic': 6, 'AltAvgLineCode': 6, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 4, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 5, 'AltCountLineCode': 42, 'CountLineCodeExe': 18, 'CountLineComment': 1, 'AltAvgLineComment': 0, 'AltCountLineBlank': 4, 'CountClassCoupled': 7, 'CountClassDerived': 0, 'CountLineCodeDecl': 16, 'CountLineInactive': 0, 'CountDeclMethodAll': 14, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.02', 'AltCountLineComment': 1, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 6, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 5, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 6, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98805,C++,"    class PCIDSK_DLL MutexHolder
    {
    public:
        MutexHolder( Mutex *mutexIn )
        {
            this->mutex = mutexIn;
            if( mutex != nullptr )
                mutex->Acquire();
        }
        ~MutexHolder()
        {
            if( mutex )
                mutex->Release();
        }

        void Release()
        {
            if (mutex)
            {
                mutex->Release();
                mutex = nullptr;
            }
        }

    private:
        Mutex     *mutex;

    };",0,587 2000 2001 123 777 58 2001 40 2002 42 2003 41 123 823 354 2004 61 2003 59 688 40 2004 340 753 41 2004 354 2005 40 41 59 125 126 2001 40 41 123 688 40 2006 41 2006 354 2007 40 41 59 125 865 2008 40 41 123 688 40 2009 41 123 2009 354 2008 40 41 59 2009 61 753 59 125 125 773 58 2002 42 2010 59 125 59 ,"{'AvgLine': 6, 'CountLine': 28, 'CountStmt': 12, 'MaxNesting': 1, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 8, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 2, 'CountLineCode': 25, 'CountStmtDecl': 4, 'MaxCyclomatic': 2, 'SumCyclomatic': 6, 'AltAvgLineCode': 6, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 3, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 3, 'AltCountLineCode': 25, 'CountLineCodeExe': 8, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 4, 'CountLineInactive': 0, 'CountDeclMethodAll': 3, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 6, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 25, 'SumCyclomaticModified': 6, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
99095,C++,"    class PCIDSKEphemerisSegment
    {
    public:

        // Virtual destructor
        virtual ~PCIDSKEphemerisSegment() {}

        virtual const EphemerisSeg_t& GetEphemeris() const=0;
        virtual void SetEphemeris(const EphemerisSeg_t& oEph) =0;
    };",0,587 2000 123 777 58 330 864 126 2000 40 41 123 125 864 601 2001 38 2002 40 41 601 61 1500 59 864 865 2003 40 601 2001 38 2004 41 61 1500 59 125 59 ,"{'AvgLine': 1, 'CountLine': 10, 'CountStmt': 3, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 7, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 3, 'AltCountLineCode': 7, 'CountLineCodeExe': 0, 'CountLineComment': 1, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 1, 'CountClassDerived': 1, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 3, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.14', 'AltCountLineComment': 1, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99009,C++,"    class SG_Exception_Dim_MM : public SG_Exception
    {
        std::string err_msg;

        public:
            const char* get_err_msg() override { return err_msg.c_str(); }

        SG_Exception_Dim_MM(const char* geometry_container, const char* field_1, const char *field_2);
    };",0,587 2000 58 777 2001 123 2002 321 2003 2004 59 777 58 601 582 42 2005 40 41 2006 123 792 2004 46 2007 40 41 59 125 2000 40 601 582 42 2008 44 601 582 42 2009 44 601 582 42 2010 41 59 125 59 ,"{'AvgLine': 6, 'CountLine': 21, 'CountStmt': 8, 'MaxNesting': 0, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 18, 'CountStmtDecl': 6, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 6, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 18, 'CountLineCodeExe': 9, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 6, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 71, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98797,C++,"class KeyNotFound : public std::invalid_argument {
 public:
  KeyNotFound() : std::invalid_argument(""key_not_found"") {}
};",0,587 2000 58 777 2001 321 2002 123 777 58 2000 40 41 58 2001 321 2002 40 362 41 123 125 125 59 ,"{'AvgLine': 1, 'CountLine': 4, 'CountStmt': 1, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 4, 'CountStmtDecl': 1, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 0, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 1, 'AltCountLineCode': 4, 'CountLineCodeExe': 1, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 0, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98888,C++,"class OCAD_EXTERN CADClasses
{
public:
    CADClasses();

public:
    void                addClass(CADClass stClass);
    CADClass            getClassByNum(short num) const;
    void                print() const;

protected:
    std::vector<CADClass>    classes;
};",0,587 2000 2001 123 777 58 2001 40 41 59 777 58 865 2002 40 2003 2004 41 59 2003 2005 40 803 2006 41 601 59 865 2007 40 41 601 59 775 58 2008 321 2009 60 2003 62 2010 59 125 59 ,"{'AvgLine': 10, 'CountLine': 56, 'CountStmt': 21, 'MaxNesting': 1, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 13, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 52, 'CountStmtDecl': 14, 'MaxCyclomatic': 3, 'SumCyclomatic': 7, 'AltAvgLineCode': 10, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 4, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 4, 'AltCountLineCode': 52, 'CountLineCodeExe': 26, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 4, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 7, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 7, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 55, 'SumCyclomaticModified': 7, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 9, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 1}"
98760,C++,"    class VecSegDataIndex
    {
        friend class CPCIDSKVectorSegment;
        friend class VecSegHeader;

    public:
        VecSegDataIndex();
        ~VecSegDataIndex();

        void                 Initialize( CPCIDSKVectorSegment *seg,
                                         int section );

        uint32               SerializedSize();

        void                 SetDirty();
        void                 Flush();

        const std::vector<uint32> *GetIndex();
        void            AddBlockToIndex( uint32 block );
        void            VacateBlockRange( uint32 start, uint32 count );

        uint32          GetSectionEnd();
        void            SetSectionEnd( uint32 new_size );

    private:
        CPCIDSKVectorSegment *vs;

        int                  section;

        uint32               offset_on_disk_within_section;
        uint32               size_on_disk;

        bool                 block_initialized;
        uint32               block_count;
        uint32               bytes;
        std::vector<uint32>  block_index;
        bool                 dirty;
    };",0,587 2000 123 667 587 2001 59 667 587 2002 59 777 58 2000 40 41 59 126 2000 40 41 59 865 2003 40 2001 42 2004 44 704 2005 41 59 2006 2007 40 41 59 865 2008 40 41 59 865 2009 40 41 59 601 2010 321 2011 60 2006 62 42 2012 40 41 59 865 2013 40 2006 2014 41 59 865 2015 40 2006 2016 44 2006 2017 41 59 2006 2018 40 41 59 865 2019 40 2006 2020 41 59 773 58 2001 42 2021 59 704 2005 59 2006 2022 59 2006 2023 59 569 2024 59 2006 2025 59 2006 2026 59 2010 321 2011 60 2006 62 2027 59 569 2028 59 125 59 ,"{'AvgLine': 18, 'CountLine': 240, 'CountStmt': 98, 'MaxNesting': 3, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 3, 'CountStmtExe': 72, 'MaxEssential': 1, 'SumEssential': 11, 'AvgCyclomatic': 2, 'CountLineCode': 182, 'CountStmtDecl': 33, 'MaxCyclomatic': 6, 'SumCyclomatic': 26, 'AltAvgLineCode': 14, 'AvgLineComment': 1, 'CountClassBase': 0, 'CountLineBlank': 48, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 3, 'CountDeclMethod': 11, 'AltCountLineCode': 182, 'CountLineCodeExe': 99, 'CountLineComment': 13, 'AltAvgLineComment': 1, 'AltCountLineBlank': 48, 'CountClassCoupled': 7, 'CountClassDerived': 0, 'CountLineCodeDecl': 23, 'CountLineInactive': 0, 'CountDeclMethodAll': 11, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.07', 'AltCountLineComment': 13, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 27, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 54, 'CountDeclMethodPublic': 11, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 66, 'SumCyclomaticModified': 26, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 13, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 9, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 9, 'CountDeclInstanceVariableProtected': 0}"
98896,C++,"class IOGRMemLayerFeatureIterator
{
  public:
    virtual ~IOGRMemLayerFeatureIterator() {}

    virtual OGRFeature *Next() = 0;
};",0,587 2000 123 777 58 864 126 2000 40 41 123 125 864 2001 42 2002 40 41 61 1500 59 125 59 ,"{'AvgLine': 1, 'CountLine': 7, 'CountStmt': 2, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 6, 'CountStmtDecl': 2, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 6, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 1, 'CountClassDerived': 2, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 2, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98663,C++,"class CPL_DLL VRTSource
{
public:
    virtual ~VRTSource();

    virtual CPLErr  RasterIO( GDALDataType eBandDataType,
                              int nXOff, int nYOff, int nXSize, int nYSize,
                              void *pData, int nBufXSize, int nBufYSize,
                              GDALDataType eBufType,
                              GSpacing nPixelSpace, GSpacing nLineSpace,
                              GDALRasterIOExtraArg* psExtraArg ) = 0;

    virtual double GetMinimum( int nXSize, int nYSize, int *pbSuccess ) = 0;
    virtual double GetMaximum( int nXSize, int nYSize, int *pbSuccess ) = 0;
    virtual CPLErr ComputeRasterMinMax( int nXSize, int nYSize, int bApproxOK,
                                        double* adfMinMax ) = 0;
    virtual CPLErr ComputeStatistics( int nXSize, int nYSize,
                                      int bApproxOK,
                                      double *pdfMin, double *pdfMax,
                                      double *pdfMean, double *pdfStdDev,
                                      GDALProgressFunc pfnProgress,
                                      void *pProgressData ) = 0;
    virtual CPLErr  GetHistogram( int nXSize, int nYSize,
                                  double dfMin, double dfMax,
                                  int nBuckets, GUIntBig * panHistogram,
                                  int bIncludeOutOfRange, int bApproxOK,
                                  GDALProgressFunc pfnProgress,
                                  void *pProgressData ) = 0;

    virtual CPLErr  XMLInit( CPLXMLNode *psTree, const char *,
                             std::map<CPLString, GDALDataset*>& ) = 0;
    virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath ) = 0;

    virtual void   GetFileList(char*** ppapszFileList, int *pnSize,
                               int *pnMaxSize, CPLHashSet* hSetFiles);

    virtual int    IsSimpleSource() { return FALSE; }
    virtual CPLErr FlushCache(bool /*bAtClosing*/) { return CE_None; }
};",0,587 2000 2001 123 777 58 864 126 2001 40 41 59 864 2002 2003 40 2004 2005 44 704 2006 44 704 2007 44 704 2008 44 704 2009 44 865 42 2010 44 704 2011 44 704 2012 44 2004 2013 44 2014 2015 44 2014 2016 44 2017 42 2018 41 61 1500 59 864 625 2019 40 704 2008 44 704 2009 44 704 42 2020 41 61 1500 59 864 625 2021 40 704 2008 44 704 2009 44 704 42 2020 41 61 1500 59 864 2002 2022 40 704 2008 44 704 2009 44 704 2023 44 625 42 2024 41 61 1500 59 864 2002 2025 40 704 2008 44 704 2009 44 704 2023 44 625 42 2026 44 625 42 2027 44 625 42 2028 44 625 42 2029 44 2030 2031 44 865 42 2032 41 61 1500 59 864 2002 2033 40 704 2008 44 704 2009 44 625 2034 44 625 2035 44 704 2036 44 2037 42 2038 44 704 2039 44 704 2023 44 2030 2031 44 865 42 2032 41 61 1500 59 864 2002 2040 40 2041 42 2042 44 601 582 42 44 2043 321 2044 60 2045 44 2046 42 62 38 41 61 1500 59 864 2041 42 2047 40 601 582 42 2048 41 61 1500 59 864 865 2049 40 582 42 42 42 2050 44 704 42 2051 44 704 42 2052 44 2053 42 2054 41 59 864 704 2055 40 41 123 792 2056 59 125 864 2002 2057 40 569 305 41 123 792 2058 59 125 125 59 ,"{'AvgLine': 2, 'CountLine': 45, 'CountStmt': 14, 'MaxNesting': 0, 'AvgLineCode': 2, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 40, 'CountStmtDecl': 12, 'MaxCyclomatic': 1, 'SumCyclomatic': 4, 'AltAvgLineCode': 2, 'AvgLineComment': 1, 'CountClassBase': 0, 'CountLineBlank': 5, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 12, 'AltCountLineCode': 40, 'CountLineCodeExe': 1, 'CountLineComment': 5, 'AltAvgLineComment': 1, 'AltCountLineBlank': 5, 'CountClassCoupled': 3, 'CountClassDerived': 2, 'CountLineCodeDecl': 8, 'CountLineInactive': 0, 'CountDeclMethodAll': 12, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.13', 'AltCountLineComment': 5, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 4, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 12, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 4, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 13, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99113,C++,"class BSBRasterBand final: public GDALPamRasterBand
{
    GDALColorTable      oCT;

  public:
    explicit    BSBRasterBand( BSBDataset * );

    CPLErr IReadBlock( int, int, void * ) override;
    GDALColorTable *GetColorTable() override;
    GDALColorInterp GetColorInterpretation() override;
};",0,587 2000 2001 58 777 2002 123 2003 2004 59 777 58 648 2000 40 2005 42 41 59 2006 2007 40 704 44 704 44 865 42 41 2008 59 2003 42 2009 40 41 2008 59 2010 2011 40 41 2008 59 125 59 ,"{'AvgLine': 14, 'CountLine': 69, 'CountStmt': 23, 'MaxNesting': 3, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 17, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 2, 'CountLineCode': 52, 'CountStmtDecl': 10, 'MaxCyclomatic': 4, 'SumCyclomatic': 8, 'AltAvgLineCode': 10, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 12, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 4, 'AltCountLineCode': 52, 'CountLineCodeExe': 21, 'CountLineComment': 5, 'AltAvgLineComment': 1, 'AltCountLineBlank': 12, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 17, 'CountLineInactive': 0, 'CountDeclMethodAll': 132, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.10', 'AltCountLineComment': 5, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 4, 'SumCyclomaticStrict': 8, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 8, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 9, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98830,C++,"class OGRSXFDriver final: public GDALDriver
{
  public:
                ~OGRSXFDriver();

    static GDALDataset* Open( GDALOpenInfo * );
    static int          Identify( GDALOpenInfo * );
    static CPLErr       DeleteDataSource(const char* pszName);
};",0,587 2000 2001 58 777 2002 123 777 58 126 2000 40 41 59 809 2003 42 2004 40 2005 42 41 59 809 704 2006 40 2005 42 41 59 809 2007 2008 40 601 582 42 2009 41 59 125 59 ,"{'AvgLine': 18, 'CountLine': 82, 'CountStmt': 29, 'MaxNesting': 2, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 3, 'CountStmtExe': 23, 'MaxEssential': 4, 'SumEssential': 7, 'AvgCyclomatic': 3, 'CountLineCode': 65, 'CountStmtDecl': 10, 'MaxCyclomatic': 4, 'SumCyclomatic': 12, 'AltAvgLineCode': 14, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 13, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 3, 'CountDeclMethod': 4, 'AltCountLineCode': 65, 'CountLineCodeExe': 31, 'CountLineComment': 4, 'AltAvgLineComment': 1, 'AltCountLineBlank': 13, 'CountClassCoupled': 4, 'CountClassDerived': 0, 'CountLineCodeDecl': 21, 'CountLineInactive': 0, 'CountDeclMethodAll': 38, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.06', 'AltCountLineComment': 4, 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 16, 'CountDeclClassMethod': 3, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 12, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 1, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99085,C++,"class GMLASErrorHandler : public ErrorHandler
{
    public:
        GMLASErrorHandler () : m_bFailed (false),
                               m_bSchemaFullChecking (false),
                               m_bHandleMultipleImports (false)   {}

        void SetSchemaFullCheckingEnabled(bool b)
                                            { m_bSchemaFullChecking = b; }

        void SetHandleMultipleImportsEnabled(bool b)
                                            { m_bHandleMultipleImports = b; }

        bool hasFailed () const { return m_bFailed; }

        virtual void warning (const SAXParseException& e) override;
        virtual void error (const SAXParseException& e) override;
        virtual void fatalError (const SAXParseException& e) override;

        virtual void resetErrors () override { m_bFailed = false; }

    private:
        bool m_bFailed;
        bool m_bSchemaFullChecking;
        bool m_bHandleMultipleImports;

        void handle (const SAXParseException& e, CPLErr eErr);
};",0,587 2000 58 777 2001 123 777 58 2000 40 41 58 2002 40 655 41 44 2003 40 655 41 44 2004 40 655 41 123 125 865 2005 40 569 2006 41 123 2003 61 2006 59 125 865 2007 40 569 2006 41 123 2004 61 2006 59 125 569 2008 40 41 601 123 792 2002 59 125 864 865 2009 40 601 2010 38 2011 41 2012 59 864 865 2013 40 601 2010 38 2011 41 2012 59 864 865 2014 40 601 2010 38 2011 41 2012 59 864 865 2015 40 41 2012 123 2002 61 655 59 125 773 58 569 2002 59 569 2003 59 569 2004 59 865 2016 40 601 2010 38 2011 44 2017 2018 41 59 125 59 ,"{'AvgLine': 5, 'CountLine': 71, 'CountStmt': 27, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 10, 'MaxEssential': 1, 'SumEssential': 9, 'AvgCyclomatic': 1, 'CountLineCode': 62, 'CountStmtDecl': 17, 'MaxCyclomatic': 3, 'SumCyclomatic': 11, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 9, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 9, 'AltCountLineCode': 62, 'CountLineCodeExe': 16, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 9, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 12, 'CountLineInactive': 0, 'CountDeclMethodAll': 9, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 11, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 9, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 78, 'SumCyclomaticModified': 11, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 14, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
98592,C++,"class CPL_DLL GDALMajorObject
{
  protected:
//! @cond Doxygen_Suppress
    int                 nFlags; // GMO_* flags.
    CPLString           sDescription{};
    GDALMultiDomainMetadata oMDMD{};

//! @endcond

    char               **BuildMetadataDomainList( char** papszList,
                                                  int bCheckNonEmpty, ... ) CPL_NULL_TERMINATED;
  public:
                        GDALMajorObject();
    virtual            ~GDALMajorObject();

    int                 GetMOFlags() const;
    void                SetMOFlags( int nFlagsIn );

    virtual const char *GetDescription() const;
    virtual void        SetDescription( const char * );

    virtual char      **GetMetadataDomainList();

    virtual char      **GetMetadata( const char * pszDomain = """" );
    virtual CPLErr      SetMetadata( char ** papszMetadata,
                                     const char * pszDomain = """" );
    virtual const char *GetMetadataItem( const char * pszName,
                                         const char * pszDomain = """" );
    virtual CPLErr      SetMetadataItem( const char * pszName,
                                         const char * pszValue,
                                         const char * pszDomain = """" );

    /** Convert a GDALMajorObject* to a GDALMajorObjectH.
     * @since GDAL 2.3
     */
    static inline GDALMajorObjectH ToHandle(GDALMajorObject* poMajorObject)
        { return static_cast<GDALMajorObjectH>(poMajorObject); }

    /** Convert a GDALMajorObjectH to a GDALMajorObject*.
     * @since GDAL 2.3
     */
    static inline GDALMajorObject* FromHandle(GDALMajorObjectH hMajorObject)
        { return static_cast<GDALMajorObject*>(hMajorObject); }
};",0,587 2000 2001 123 775 58 330 704 2002 59 330 2003 2004 123 125 59 2005 2006 123 125 59 330 582 42 42 2007 40 582 42 42 2008 44 704 2009 44 322 41 2010 59 777 58 2001 40 41 59 864 126 2001 40 41 59 704 2011 40 41 601 59 865 2012 40 704 2013 41 59 864 601 582 42 2014 40 41 601 59 864 865 2015 40 601 582 42 41 59 864 582 42 42 2016 40 41 59 864 582 42 42 2017 40 601 582 42 2018 61 362 41 59 864 2019 2020 40 582 42 42 2021 44 601 582 42 2018 61 362 41 59 864 601 582 42 2022 40 601 582 42 2023 44 601 582 42 2018 61 362 41 59 864 2019 2024 40 601 582 42 2023 44 601 582 42 2025 44 601 582 42 2018 61 362 41 59 306 809 700 2026 2027 40 2001 42 2028 41 123 792 811 60 2026 62 40 2028 41 59 125 306 809 700 2001 42 2029 40 2026 2030 41 123 792 811 60 2001 42 62 40 2030 41 59 125 125 59 ,"{'AvgLine': 6, 'CountLine': 126, 'CountStmt': 40, 'MaxNesting': 2, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 21, 'MaxEssential': 1, 'SumEssential': 14, 'AvgCyclomatic': 1, 'CountLineCode': 97, 'CountStmtDecl': 20, 'MaxCyclomatic': 3, 'SumCyclomatic': 17, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 21, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 14, 'AltCountLineCode': 97, 'CountLineCodeExe': 21, 'CountLineComment': 9, 'AltAvgLineComment': 0, 'AltCountLineBlank': 21, 'CountClassCoupled': 2, 'CountClassDerived': 5, 'CountLineCodeDecl': 22, 'CountLineInactive': 0, 'CountDeclMethodAll': 14, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 9, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 5, 'SumCyclomaticStrict': 19, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 13, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 77, 'SumCyclomaticModified': 17, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 14, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 2}"
98589,C++,"class CPL_DLL GDALColorTable
{
    GDALPaletteInterp eInterp;

    std::vector<GDALColorEntry> aoEntries{};

public:
    explicit     GDALColorTable( GDALPaletteInterp = GPI_RGB );
                ~GDALColorTable();

    GDALColorTable *Clone() const;
    int             IsSame(const GDALColorTable* poOtherCT) const;

    GDALPaletteInterp GetPaletteInterpretation() const;

    int           GetColorEntryCount() const;
    const GDALColorEntry *GetColorEntry( int ) const;
    int           GetColorEntryAsRGB( int, GDALColorEntry * ) const;
    void          SetColorEntry( int, const GDALColorEntry * );
    int           CreateColorRamp( int, const GDALColorEntry * ,
                                   int, const GDALColorEntry * );
    bool          IsIdentity() const;

    /** Convert a GDALColorTable* to a GDALRasterBandH.
     * @since GDAL 2.3
     */
    static inline GDALColorTableH ToHandle(GDALColorTable* poCT)
        { return static_cast<GDALColorTableH>(poCT); }

    /** Convert a GDALColorTableH to a GDALColorTable*.
     * @since GDAL 2.3
     */
    static inline GDALColorTable* FromHandle(GDALColorTableH hCT)
        { return static_cast<GDALColorTable*>(hCT); }

};",0,587 2000 2001 123 2002 2003 59 2004 321 2005 60 2006 62 2007 123 125 59 777 58 648 2001 40 2002 61 2008 41 59 126 2001 40 41 59 2001 42 2009 40 41 601 59 704 2010 40 601 2001 42 2011 41 601 59 2002 2012 40 41 601 59 704 2013 40 41 601 59 601 2006 42 2014 40 704 41 601 59 704 2015 40 704 44 2006 42 41 601 59 865 2016 40 704 44 601 2006 42 41 59 704 2017 40 704 44 601 2006 42 44 704 44 601 2006 42 41 59 569 2018 40 41 601 59 306 809 700 2019 2020 40 2001 42 2021 41 123 792 811 60 2019 62 40 2021 41 59 125 306 809 700 2001 42 2022 40 2019 2023 41 123 792 811 60 2001 42 62 40 2023 41 59 125 125 59 ,"{'AvgLine': 11, 'CountLine': 168, 'CountStmt': 58, 'MaxNesting': 1, 'AvgLineCode': 9, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 33, 'MaxEssential': 4, 'SumEssential': 15, 'AvgCyclomatic': 1, 'CountLineCode': 126, 'CountStmtDecl': 27, 'MaxCyclomatic': 5, 'SumCyclomatic': 22, 'AltAvgLineCode': 9, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 28, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 13, 'AltCountLineCode': 126, 'CountLineCodeExe': 37, 'CountLineComment': 15, 'AltAvgLineComment': 0, 'AltCountLineBlank': 28, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 26, 'CountLineInactive': 0, 'CountDeclMethodAll': 13, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.12', 'AltCountLineComment': 15, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 27, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 7, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 13, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 5, 'PercentLackOfCohesion': 92, 'SumCyclomaticModified': 22, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 11, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
99008,C++,"    class SG_Exception_Dep: public SG_Exception
    {
        std::string err_msg;

        public:
            const char* get_err_msg() override { return err_msg.c_str(); }
        
        SG_Exception_Dep(const char* geometry_container, const char* arg_1, const char* arg_2);
    };",0,587 2000 58 777 2001 123 2002 321 2003 2004 59 777 58 601 582 42 2005 40 41 2006 123 792 2004 46 2007 40 41 59 125 2000 40 601 582 42 2008 44 601 582 42 2009 44 601 582 42 2010 41 59 125 59 ,"{'AvgLine': 6, 'CountLine': 21, 'CountStmt': 8, 'MaxNesting': 0, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 18, 'CountStmtDecl': 6, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 6, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 18, 'CountLineCodeExe': 9, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 6, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 71, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
99061,C++,"class OGRCouchDBRowsLayer final: public OGRCouchDBLayer
{
    bool                      bAllInOne;

    virtual bool              FetchNextRows() override;

    public:
            explicit OGRCouchDBRowsLayer( OGRCouchDBDataSource* poDS );
            virtual ~OGRCouchDBRowsLayer();

    virtual void                ResetReading() override;

    bool                        BuildFeatureDefn();

    virtual CouchDBLayerType    GetLayerType() override { return COUCHDB_TABLE_LAYER; }
};",0,587 2000 2001 58 777 2002 123 569 2003 59 864 569 2004 40 41 2005 59 777 58 648 2000 40 2006 42 2007 41 59 864 126 2000 40 41 59 864 865 2008 40 41 2005 59 569 2009 40 41 59 864 2010 2011 40 41 2005 123 792 2012 59 125 125 59 ,"{'AvgLine': 13, 'CountLine': 96, 'CountStmt': 46, 'MaxNesting': 2, 'AvgLineCode': 11, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 38, 'MaxEssential': 3, 'SumEssential': 8, 'AvgCyclomatic': 2, 'CountLineCode': 77, 'CountStmtDecl': 14, 'MaxCyclomatic': 6, 'SumCyclomatic': 15, 'AltAvgLineCode': 11, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 18, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 6, 'AltCountLineCode': 77, 'CountLineCodeExe': 50, 'CountLineComment': 1, 'AltAvgLineComment': 0, 'AltCountLineBlank': 18, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 13, 'CountLineInactive': 0, 'CountDeclMethodAll': 105, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.01', 'AltCountLineComment': 1, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 7, 'SumCyclomaticStrict': 16, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 5, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 50, 'SumCyclomaticModified': 15, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 8, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98852,C++,"class OGREDIGEOAttributeDescriptor
{
    public:
        OGREDIGEOAttributeDescriptor() : nWidth(0) {}

        CPLString osRID;        /* e.g. TEX2_id */
        CPLString osNameRID;    /* e.g. ID_N_ATT_TEX2 */
        int nWidth;             /* e.g. 80 */
};",0,587 2000 123 777 58 2000 40 41 58 2001 40 1500 41 123 125 2002 2003 59 305 2002 2004 59 305 704 2001 59 305 125 59 ,"{'AvgLine': 1, 'CountLine': 9, 'CountStmt': 7, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 8, 'CountStmtDecl': 5, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 1, 'AltCountLineCode': 8, 'CountLineCodeExe': 1, 'CountLineComment': 3, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.38', 'AltCountLineComment': 3, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 75, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 3, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98629,C++,"class TigerZeroCellID final: public TigerFileBase
{
public:
                      TigerZeroCellID( OGRTigerDataSource *, const char * );
};",0,587 2000 2001 58 777 2002 123 777 58 2000 40 2003 42 44 601 582 42 41 59 125 59 ,"{'AvgLine': 15, 'CountLine': 20, 'CountStmt': 6, 'MaxNesting': 0, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 5, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 15, 'CountStmtDecl': 1, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 10, 'AvgLineComment': 3, 'CountClassBase': 1, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 1, 'AltCountLineCode': 15, 'CountLineCodeExe': 6, 'CountLineComment': 3, 'AltAvgLineComment': 3, 'AltCountLineBlank': 2, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 3, 'CountLineInactive': 0, 'CountDeclMethodAll': 25, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.20', 'AltCountLineComment': 3, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99012,C++,"    class SG_Exception_General_Malformed : public SG_Exception
    {
        std::string err_msg;

        public:
            const char* get_err_msg() override { return err_msg.c_str(); }
        
        explicit SG_Exception_General_Malformed(const char*); 
    };",0,587 2000 58 777 2001 123 2002 321 2003 2004 59 777 58 601 582 42 2005 40 41 2006 123 792 2004 46 2007 40 41 59 125 648 2000 40 601 582 42 41 59 125 59 ,"{'AvgLine': 4, 'CountLine': 16, 'CountStmt': 6, 'MaxNesting': 0, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 13, 'CountStmtDecl': 4, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 3, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 13, 'CountLineCodeExe': 3, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 4, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 71, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
99107,C++,"class GDALPDFDictionaryRW : public GDALPDFDictionary
{
    private:
        std::map<CPLString, GDALPDFObject*> m_map;

    public:
                               GDALPDFDictionaryRW();
        virtual               ~GDALPDFDictionaryRW();

        virtual GDALPDFObject*                       Get(const char* pszKey) override;
        virtual std::map<CPLString, GDALPDFObject*>& GetValues() override;

        GDALPDFDictionaryRW&   Add(const char* pszKey, GDALPDFObject* poVal);
        GDALPDFDictionaryRW&   Remove(const char* pszKey);

        GDALPDFDictionaryRW&   Add(const char* pszKey, GDALPDFArrayRW* poArray) { return Add(pszKey, GDALPDFObjectRW::CreateArray(poArray)); }
        GDALPDFDictionaryRW&   Add(const char* pszKey, GDALPDFDictionaryRW* poDict) { return Add(pszKey, GDALPDFObjectRW::CreateDictionary(poDict)); }
        GDALPDFDictionaryRW&   Add(const char* pszKey, const char* pszVal) { return Add(pszKey, GDALPDFObjectRW::CreateString(pszVal)); }
        GDALPDFDictionaryRW&   Add(const char* pszKey, int nVal) { return Add(pszKey, GDALPDFObjectRW::CreateInt(nVal)); }
        GDALPDFDictionaryRW&   Add(const char* pszKey, double dfVal, int bCanRepresentRealAsString = FALSE) { return Add(pszKey, GDALPDFObjectRW::CreateReal(dfVal, bCanRepresentRealAsString)); }
        GDALPDFDictionaryRW&   Add(const char* pszKey, const GDALPDFObjectNum& nNum, int nGen) { return Add(pszKey, GDALPDFObjectRW::CreateIndirect(nNum, nGen)); }
};",0,587 2000 58 777 2001 123 773 58 2002 321 2003 60 2004 44 2005 42 62 2006 59 777 58 2000 40 41 59 864 126 2000 40 41 59 864 2005 42 2007 40 601 582 42 2008 41 2009 59 864 2002 321 2003 60 2004 44 2005 42 62 38 2010 40 41 2009 59 2000 38 2011 40 601 582 42 2008 44 2005 42 2012 41 59 2000 38 2013 40 601 582 42 2008 41 59 2000 38 2011 40 601 582 42 2008 44 2014 42 2015 41 123 792 2011 40 2008 44 2016 321 2017 40 2015 41 41 59 125 2000 38 2011 40 601 582 42 2008 44 2000 42 2018 41 123 792 2011 40 2008 44 2019 321 2020 40 2018 41 41 59 125 2000 38 2011 40 601 582 42 2008 44 601 582 42 2021 41 123 792 2011 40 2008 44 2022 321 2023 40 2021 41 41 59 125 2000 38 2011 40 601 582 42 2008 44 704 2024 41 123 792 2011 40 2008 44 2025 321 2026 40 2024 41 41 59 125 2000 38 2011 40 601 582 42 2008 44 625 2027 44 704 2028 61 2029 41 123 792 2011 40 2008 44 2030 321 2031 40 2027 44 2028 41 41 59 125 2000 38 2011 40 601 582 42 2008 44 601 2032 38 2033 44 704 2034 41 123 792 2011 40 2008 44 2035 321 2036 40 2033 44 2034 41 41 59 125 125 59 ,"{'AvgLine': 4, 'CountLine': 65, 'CountStmt': 30, 'MaxNesting': 1, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 11, 'MaxEssential': 1, 'SumEssential': 12, 'AvgCyclomatic': 1, 'CountLineCode': 59, 'CountStmtDecl': 18, 'MaxCyclomatic': 2, 'SumCyclomatic': 14, 'AltAvgLineCode': 3, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 6, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 0, 'CountDeclMethod': 12, 'AltCountLineCode': 59, 'CountLineCodeExe': 10, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 6, 'CountClassCoupled': 4, 'CountClassDerived': 0, 'CountLineCodeDecl': 17, 'CountLineInactive': 0, 'CountDeclMethodAll': 19, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 14, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 12, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 14, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 14, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98957,C++,"    class PCIDSK_DLL PCIDSKInterfaces
    {
      public:
        PCIDSKInterfaces();

        const IOInterfaces *io;

        std::string       (*MergeRelativePath)(const PCIDSK::IOInterfaces *,
                                               const std::string& base,
                                               const std::string& filename);

        EDBFile           *(*OpenEDB)(const std::string& filename, const std::string& access);

        Mutex             *(*CreateMutex)(void);

        void              (*JPEGDecompressBlock)
            ( uint8 *src_data, int src_bytes, uint8 *dst_data, int dst_bytes,
              int xsize, int ysize, eChanType pixel_type );
        void              (*JPEGCompressBlock)
            ( uint8 *src_data, int src_bytes, uint8 *dst_data, int &dst_bytes,
              int xsize, int ysize, eChanType pixel_type, int quality );

        void              (*Debug)( const char * );
    };",0,587 2000 2001 123 777 58 2001 40 41 59 601 2002 42 2003 59 2004 321 2005 40 42 2006 41 40 601 2007 321 2002 42 44 601 2004 321 2005 38 2008 44 601 2004 321 2005 38 2009 41 59 2010 42 40 42 2011 41 40 601 2004 321 2005 38 2009 44 601 2004 321 2005 38 2012 41 59 2013 42 40 42 2014 41 40 865 41 59 865 40 42 2015 41 40 2016 42 2017 44 704 2018 44 2016 42 2019 44 704 2020 44 704 2021 44 704 2022 44 2023 2024 41 59 865 40 42 2025 41 40 2016 42 2017 44 704 2018 44 2016 42 2019 44 704 38 2020 44 704 2021 44 704 2022 44 2023 2024 44 704 2026 41 59 865 40 42 2027 41 40 601 582 42 41 59 125 59 ,"{'AvgLine': 17, 'CountLine': 41, 'CountStmt': 15, 'MaxNesting': 0, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 7, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 28, 'CountStmtDecl': 8, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 15, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 8, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 1, 'AltCountLineCode': 33, 'CountLineCodeExe': 7, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 8, 'CountClassCoupled': 6, 'CountClassDerived': 0, 'CountLineCodeDecl': 2, 'CountLineInactive': 2, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 3, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 1, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 7, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98754,C++,"class ISCERasterBand final: public RawRasterBand
{
        CPL_DISALLOW_COPY_ASSIGN(ISCERasterBand)

    public:
                ISCERasterBand( GDALDataset *poDS, int nBand, VSILFILE *fpRaw,
                                  vsi_l_offset nImgOffset, int nPixelOffset,
                                  int nLineOffset,
                                  GDALDataType eDataType, int bNativeOrder );
};",0,587 2000 2001 58 777 2002 123 2003 40 2000 41 777 58 2000 40 2004 42 2005 44 704 2006 44 2007 42 2008 44 2009 2010 44 704 2011 44 704 2012 44 2013 2014 44 704 2015 41 59 125 59 ,"{'AvgLine': 8, 'CountLine': 18, 'CountStmt': 1, 'MaxNesting': 0, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 17, 'CountStmtDecl': 1, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 8, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 3, 'AltCountLineCode': 17, 'CountLineCodeExe': 3, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 5, 'CountLineInactive': 0, 'CountDeclMethodAll': 171, 'MaxInheritanceTree': 4, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98861,C++,"class IOGRSQLiteSelectLayer
{
    public:
        virtual                     ~IOGRSQLiteSelectLayer() {}

        virtual char*&               GetAttrQueryString() = 0;
        virtual OGRFeatureQuery*&    GetFeatureQuery() = 0;
        virtual OGRGeometry*&        GetFilterGeom() = 0;
        virtual int&                 GetIGeomFieldFilter() = 0;
        virtual OGRSpatialReference* GetSpatialRef() = 0;
        virtual OGRFeatureDefn      *GetLayerDefn() = 0;
        virtual int                  InstallFilter( OGRGeometry * ) = 0;
        virtual int                  HasReadFeature() = 0;
        virtual void                 BaseResetReading() = 0;
        virtual OGRFeature          *BaseGetNextFeature() = 0;
        virtual OGRErr               BaseSetAttributeFilter(const char* pszQuery) = 0;
        virtual GIntBig              BaseGetFeatureCount(int bForce) = 0;
        virtual int                  BaseTestCapability( const char * ) = 0;
        virtual OGRErr               BaseGetExtent(OGREnvelope *psExtent, int bForce) = 0;
        virtual OGRErr               BaseGetExtent(int iGeomField, OGREnvelope *psExtent, int bForce) = 0;
};",0,587 2000 123 777 58 864 126 2000 40 41 123 125 864 582 42 38 2001 40 41 61 1500 59 864 2002 42 38 2003 40 41 61 1500 59 864 2004 42 38 2005 40 41 61 1500 59 864 704 38 2006 40 41 61 1500 59 864 2007 42 2008 40 41 61 1500 59 864 2009 42 2010 40 41 61 1500 59 864 704 2011 40 2004 42 41 61 1500 59 864 704 2012 40 41 61 1500 59 864 865 2013 40 41 61 1500 59 864 2014 42 2015 40 41 61 1500 59 864 2016 2017 40 601 582 42 2018 41 61 1500 59 864 2019 2020 40 704 2021 41 61 1500 59 864 704 2022 40 601 582 42 41 61 1500 59 864 2016 2023 40 2024 42 2025 44 704 2021 41 61 1500 59 864 2016 2023 40 704 2026 44 2024 42 2025 44 704 2021 41 61 1500 59 125 59 ,"{'AvgLine': 1, 'CountLine': 21, 'CountStmt': 16, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 20, 'CountStmtDecl': 16, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 16, 'AltCountLineCode': 20, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 6, 'CountClassDerived': 2, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 16, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 16, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 17, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98851,C++,"class OGREDIGEOAttributeDef
{
    public:
        OGREDIGEOAttributeDef() {}

        CPLString osLAB; /* e.g. TEX2 */
        CPLString osTYP; /* e.g. T */
};",0,587 2000 123 777 58 2000 40 41 123 125 2001 2002 59 305 2001 2003 59 305 125 59 ,"{'AvgLine': 1, 'CountLine': 8, 'CountStmt': 5, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 7, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 1, 'AltCountLineCode': 7, 'CountLineCodeExe': 1, 'CountLineComment': 2, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.29', 'AltCountLineComment': 2, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 75, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99024,C++,"class Blob : public Sized {
 public:
  Blob(const uint8_t *data_buf, uint8_t byte_width)
      : Sized(data_buf, byte_width) {}

  static Blob EmptyBlob() {
    static const uint8_t empty_blob[] = { 0 /*len*/ };
    return Blob(empty_blob + 1, 1);
  }
  bool IsTheEmptyBlob() const { return data_ == EmptyBlob().data_; }
  const uint8_t *data() const { return data_; }
};",0,587 2000 58 777 2001 123 777 58 2000 40 601 2002 42 2003 44 2002 2004 41 58 2001 40 2003 44 2004 41 123 125 809 2000 2005 40 41 123 809 601 2002 2006 91 93 61 123 1500 305 125 59 792 2000 40 2006 43 1501 44 1501 41 59 125 569 2007 40 41 601 123 792 2008 323 2005 40 41 46 2008 59 125 601 2002 42 2009 40 41 601 123 792 2010 59 125 125 59 ,"{'AvgLine': 2, 'CountLine': 12, 'CountStmt': 8, 'MaxNesting': 0, 'AvgLineCode': 2, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 3, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 11, 'CountStmtDecl': 5, 'MaxCyclomatic': 1, 'SumCyclomatic': 4, 'AltAvgLineCode': 2, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 4, 'AltCountLineCode': 11, 'CountLineCodeExe': 5, 'CountLineComment': 1, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 6, 'CountLineInactive': 0, 'CountDeclMethodAll': 9, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 1, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 4, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 4, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98641,C++,"class VRTAverageFilteredSource final: public VRTKernelFilteredSource
{
    CPL_DISALLOW_COPY_ASSIGN(VRTAverageFilteredSource)

public:
            explicit VRTAverageFilteredSource( int nKernelSize );
    virtual ~VRTAverageFilteredSource();

    virtual CPLErr  XMLInit( CPLXMLNode *psTree, const char *,
                             std::map<CPLString, GDALDataset*>& ) override;
    virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath ) override;
};",0,587 2000 2001 58 777 2002 123 2003 40 2000 41 777 58 648 2000 40 704 2004 41 59 864 126 2000 40 41 59 864 2005 2006 40 2007 42 2008 44 601 582 42 44 2009 321 2010 60 2011 44 2012 42 62 38 41 2013 59 864 2007 42 2014 40 601 582 42 2015 41 2013 59 125 59 ,"{'AvgLine': 0, 'CountLine': 12, 'CountStmt': 4, 'MaxNesting': 0, 'AvgLineCode': 0, 'AvgEssential': 0, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 0, 'SumEssential': 0, 'AvgCyclomatic': 0, 'CountLineCode': 10, 'CountStmtDecl': 4, 'MaxCyclomatic': 0, 'SumCyclomatic': 0, 'AltAvgLineCode': 0, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 6, 'AltCountLineCode': 10, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 1, 'CountLineInactive': 0, 'CountDeclMethodAll': 94, 'MaxInheritanceTree': 5, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 0, 'MaxCyclomaticStrict': 0, 'SumCyclomaticStrict': 0, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 0, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 0, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 0, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98918,C++,"class GDALWMSCache {
    friend class GDALWMSDataset;

public:
    GDALWMSCache();
    ~GDALWMSCache();

public:
    CPLErr Initialize(const char *pszUrl, CPLXMLNode *pConfig);
    CPLErr Insert(const char *pszKey, const CPLString &osFileName);
    enum GDALWMSCacheItemStatus GetItemStatus(const char *pszKey) const;
    GDALDataset* GetDataset(const char *pszKey, char **papszOpenOptions) const;
    void Clean();

protected:
    CPLString CachePath() const { return m_osCachePath; }

protected:
    CPLString m_osCachePath;
    bool m_bIsCleanThreadRunning;
    time_t m_nCleanThreadLastRunTime;

private:
    GDALWMSCacheImpl* m_poCache;
    CPLJoinableThread* m_hThread;
};",0,587 2000 123 667 587 2001 59 777 58 2000 40 41 59 126 2000 40 41 59 777 58 2002 2003 40 601 582 42 2004 44 2005 42 2006 41 59 2002 2007 40 601 582 42 2008 44 601 2009 38 2010 41 59 640 2011 2012 40 601 582 42 2008 41 601 59 2013 42 2014 40 601 582 42 2008 44 582 42 42 2015 41 601 59 865 2016 40 41 59 775 58 2009 2017 40 41 601 123 792 2018 59 125 775 58 2009 2019 59 569 2020 59 2021 2022 59 773 58 2023 42 2024 59 2025 42 2026 59 125 59 ,"{'AvgLine': 12, 'CountLine': 122, 'CountStmt': 57, 'MaxNesting': 4, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 39, 'MaxEssential': 1, 'SumEssential': 8, 'AvgCyclomatic': 2, 'CountLineCode': 107, 'CountStmtDecl': 23, 'MaxCyclomatic': 5, 'SumCyclomatic': 20, 'AltAvgLineCode': 10, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 11, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 8, 'AltCountLineCode': 107, 'CountLineCodeExe': 45, 'CountLineComment': 4, 'AltAvgLineComment': 0, 'AltCountLineBlank': 11, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 16, 'CountLineInactive': 0, 'CountDeclMethodAll': 8, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 4, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 23, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 3, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 42, 'CountDeclMethodPublic': 7, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 5, 'PercentLackOfCohesion': 52, 'SumCyclomaticModified': 20, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 8, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 5, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 2, 'CountDeclInstanceVariableProtected': 3}"
99094,C++,"class ExponentialLevelRangeIterator
{
public:
    typedef RangeIterator<ExponentialLevelRangeIterator> Iterator;
    ExponentialLevelRangeIterator( double base ) : base_( base ), base_ln_( std::log( base_ ) ) {}

    double level( int idx ) const
    {
        if ( idx <= 0 )
            return 0.0;
        return std::pow( base_, idx - 1);
    }

    Range<Iterator> range( double min, double max ) const
    {
        if ( min > max )
            std::swap(min, max);

        int i1 = index1( min );
        double l1 = fudge( level( i1 ), min );
        if ( l1 > min )
            i1 = index1(l1 );
        Iterator b( *this, i1 );

        if ( min == max )
            return Range<Iterator>( b, b );

        int i2 = index2( max );
        double l2 = fudge( level( i2 ), max );
        if ( l2 > max )
            i2 = index2( l2 );
        Iterator e( *this, i2 );

        // Arbitrary threshold to avoid too much computation time and memory
        // consumption
        if( i2 > i1 + static_cast<double>(knMAX_NUMBER_LEVELS) )
            throw TooManyLevelsException();

        return Range<Iterator>( b, e );
    }

private:
    int index1( double plevel ) const
    {
        if ( plevel < 1.0 )
            return 1;
        const double dfVal = ceil(std::log( plevel ) / base_ln_)+1;
        if( !(dfVal >= INT_MIN && dfVal < INT_MAX) )
            throw TooManyLevelsException();
        return static_cast<int>(dfVal);
    }
    int index2( double plevel ) const
    {
        if ( plevel < 1.0 )
            return 0;
        const double dfVal = floor(std::log( plevel ) / base_ln_)+1+1;
        if( !(dfVal >= INT_MIN && dfVal < INT_MAX) )
            throw TooManyLevelsException();
        return static_cast<int>(dfVal);
    }

    // exponentiation base
    const double base_;
    const double base_ln_;
};",0,587 2000 123 777 58 833 2001 60 2000 62 2002 59 2000 40 625 2003 41 58 2004 40 2003 41 44 2005 40 2006 321 2007 40 2004 41 41 123 125 625 2008 40 704 2009 41 601 123 688 40 2009 329 1500 41 792 1500 59 792 2006 321 2010 40 2004 44 2009 45 1501 41 59 125 2011 60 2002 62 2012 40 625 2013 44 625 2014 41 601 123 688 40 2013 62 2014 41 2006 321 2015 40 2013 44 2014 41 59 704 2016 61 2017 40 2013 41 59 625 2018 61 2019 40 2008 40 2016 41 44 2013 41 59 688 40 2018 62 2013 41 2016 61 2017 40 2018 41 59 2002 2020 40 42 823 44 2016 41 59 688 40 2013 323 2014 41 792 2011 60 2002 62 40 2020 44 2020 41 59 704 2021 61 2022 40 2014 41 59 625 2023 61 2019 40 2008 40 2021 41 44 2014 41 59 688 40 2023 62 2014 41 2021 61 2022 40 2023 41 59 2002 2024 40 42 823 44 2021 41 59 330 330 688 40 2021 62 2016 43 811 60 625 62 40 2025 41 41 825 2026 40 41 59 792 2011 60 2002 62 40 2020 44 2024 41 59 125 773 58 704 2027 40 625 2028 41 601 123 688 40 2028 60 1501 41 792 1501 59 601 625 2029 61 2030 40 2006 321 2007 40 2028 41 47 2005 41 43 1501 59 688 40 33 40 2029 325 2031 307 2029 60 2032 41 41 825 2033 40 41 59 792 811 60 704 62 40 2029 41 59 125 704 2034 40 625 2028 41 601 123 688 40 2028 60 1501 41 792 1500 59 601 625 2035 61 2036 40 2006 321 2007 40 2028 41 47 2005 41 43 1501 43 1501 59 688 40 33 40 2035 325 2037 307 2035 60 2038 41 41 825 2039 40 41 59 792 811 60 704 62 40 2035 41 59 125 330 601 625 2004 59 601 625 2005 59 125 59 ,"{'AvgLine': 10, 'CountLine': 65, 'CountStmt': 42, 'MaxNesting': 1, 'AvgLineCode': 9, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 33, 'MaxEssential': 1, 'SumEssential': 5, 'AvgCyclomatic': 3, 'CountLineCode': 53, 'CountStmtDecl': 17, 'MaxCyclomatic': 6, 'SumCyclomatic': 15, 'AltAvgLineCode': 9, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 9, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 5, 'AltCountLineCode': 53, 'CountLineCodeExe': 33, 'CountLineComment': 3, 'AltAvgLineComment': 0, 'AltCountLineBlank': 9, 'CountClassCoupled': 3, 'CountClassDerived': 0, 'CountLineCodeDecl': 14, 'CountLineInactive': 0, 'CountDeclMethodAll': 5, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.06', 'AltCountLineComment': 3, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 17, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 4, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 64, 'SumCyclomaticModified': 15, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 2, 'CountDeclInstanceVariableProtected': 0}"
98894,C++,"class OGRSQLiteFeatureDefn final : public OGRFeatureDefn
{
    public:
        explicit OGRSQLiteFeatureDefn( const char * pszName = nullptr ) :
            OGRFeatureDefn(pszName)
        {
            SetGeomType(wkbNone);
        }

        OGRSQLiteGeomFieldDefn* myGetGeomFieldDefn(int i)
        {
            return (OGRSQLiteGeomFieldDefn*) GetGeomFieldDefn(i);
        }
};",0,587 2000 2001 58 777 2002 123 777 58 648 2000 40 601 582 42 2003 61 753 41 58 2002 40 2003 41 123 2004 40 2005 41 59 125 2006 42 2007 40 704 2008 41 123 792 40 2006 42 41 2009 40 2008 41 59 125 125 59 ,"{'AvgLine': 4, 'CountLine': 14, 'CountStmt': 4, 'MaxNesting': 0, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 13, 'CountStmtDecl': 2, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 4, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 13, 'CountLineCodeExe': 4, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 3, 'CountLineInactive': 0, 'CountDeclMethodAll': 41, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98960,C++,"class OGRAVCDataSource CPL_NON_FINAL: public OGRDataSource
{
  protected:
    bool                 m_bSRSFetched = false;
    OGRSpatialReference *poSRS;
    char                *pszCoverageName;

  public:
                        OGRAVCDataSource();
    virtual ~OGRAVCDataSource();

    virtual OGRSpatialReference *DSGetSpatialRef();

    const char          *GetCoverageName();
};",0,587 2000 2001 58 777 2002 123 775 58 569 2003 61 655 59 2004 42 2005 59 582 42 2006 59 777 58 2000 40 41 59 864 126 2000 40 41 59 864 2004 42 2007 40 41 59 601 582 42 2008 40 41 59 125 59 ,"{'AvgLine': 6, 'CountLine': 39, 'CountStmt': 16, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 7, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 32, 'CountStmtDecl': 9, 'MaxCyclomatic': 2, 'SumCyclomatic': 6, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 7, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 4, 'AltCountLineCode': 32, 'CountLineCodeExe': 12, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 7, 'CountClassCoupled': 1, 'CountClassDerived': 2, 'CountLineCodeDecl': 5, 'CountLineInactive': 0, 'CountDeclMethodAll': 149, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 6, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 66, 'SumCyclomaticModified': 6, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 3}"
99039,C++,"class WMSMiniDriver_TileService : public WMSMiniDriver {
public:
    WMSMiniDriver_TileService();
    virtual ~WMSMiniDriver_TileService();

public:
    virtual CPLErr Initialize(CPLXMLNode *config, char **papszOpenOptions) override;
    virtual CPLErr TiledImageRequest(WMSHTTPRequest &request,
                                const GDALWMSImageRequestInfo &iri,
                                const GDALWMSTiledImageRequestInfo &tiri) override;
};",0,587 2000 58 777 2001 123 777 58 2000 40 41 59 864 126 2000 40 41 59 777 58 864 2002 2003 40 2004 42 2005 44 582 42 42 2006 41 2007 59 864 2002 2008 40 2009 38 2010 44 601 2011 38 2012 44 601 2013 38 2014 41 2007 59 125 59 ,"{'AvgLine': 7, 'CountLine': 42, 'CountStmt': 18, 'MaxNesting': 1, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 12, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 36, 'CountStmtDecl': 8, 'MaxCyclomatic': 2, 'SumCyclomatic': 5, 'AltAvgLineCode': 6, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 4, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 4, 'AltCountLineCode': 36, 'CountLineCodeExe': 16, 'CountLineComment': 3, 'AltAvgLineComment': 0, 'AltCountLineBlank': 4, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 11, 'CountLineInactive': 0, 'CountDeclMethodAll': 13, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.08', 'AltCountLineComment': 3, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 5, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 5, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98821,C++,"class CPL_DLL IOGRTransactionBehaviour
{
    public:
        virtual ~IOGRTransactionBehaviour();

        /** Start a transaction.
        *
        * The implementation may update the poDSInOut reference by closing
        * and reopening the datasource (or assigning it to NULL in case of error).
        * In which case bOutHasReopenedDS must be set to TRUE.
        *
        * The implementation can for example backup the existing files/directories
        * that compose the current datasource.
        *
        * @param poDSInOut datasource handle that may be modified
        * @param bOutHasReopenedDS output boolean to indicate if datasource has been closed
        * @return OGRERR_NONE in case of success
        */
       virtual OGRErr StartTransaction(OGRDataSource*& poDSInOut,
                                       int& bOutHasReopenedDS) = 0;

        /** Commit a transaction.
        *
        * The implementation may update the poDSInOut reference by closing
        * and reopening the datasource (or assigning it to NULL in case of error).
        * In which case bOutHasReopenedDS must be set to TRUE.
        *
        * The implementation can for example remove the backup it may have done
        * at StartTransaction() time.
        *
        * @param poDSInOut datasource handle that may be modified
        * @param bOutHasReopenedDS output boolean to indicate if datasource has been closed
        * @return OGRERR_NONE in case of success
        */
       virtual OGRErr CommitTransaction(OGRDataSource*& poDSInOut,
                                        int& bOutHasReopenedDS) = 0;

        /** Rollback a transaction.
        *
        * The implementation may update the poDSInOut reference by closing
        * and reopening the datasource (or assigning it to NULL in case of error).
        * In which case bOutHasReopenedDS must be set to TRUE.
        *
        * The implementation can for example restore the backup it may have done
        * at StartTransaction() time.
        *
        * @param poDSInOut datasource handle that may be modified
        * @param bOutHasReopenedDS output boolean to indicate if datasource has been closed
        * @return OGRERR_NONE in case of success
        */
       virtual OGRErr RollbackTransaction(OGRDataSource*& poDSInOut,
                                          int& bOutHasReopenedDS) = 0;
};",0,587 2000 2001 123 777 58 864 126 2001 40 41 59 306 864 2002 2003 40 2004 42 38 2005 44 704 38 2006 41 61 1500 59 306 864 2002 2007 40 2004 42 38 2005 44 704 38 2006 41 61 1500 59 306 864 2002 2008 40 2004 42 38 2005 44 704 38 2006 41 61 1500 59 125 59 ,"{'AvgLine': 3, 'CountLine': 56, 'CountStmt': 4, 'MaxNesting': 0, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 14, 'CountStmtDecl': 4, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 3, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 3, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 4, 'AltCountLineCode': 14, 'CountLineCodeExe': 0, 'CountLineComment': 39, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 1, 'CountClassDerived': 1, 'CountLineCodeDecl': 2, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '2.79', 'AltCountLineComment': 39, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99007,C++,"    class SG_Exception_BadSum : public SG_Exception
    {
        std::string err_msg;

        public:
            const char* get_err_msg() override { return err_msg.c_str(); }
        
        SG_Exception_BadSum(const char* geometry_container, const char* arg_1, const char* arg_2);
    };",0,587 2000 58 777 2001 123 2002 321 2003 2004 59 777 58 601 582 42 2005 40 41 2006 123 792 2004 46 2007 40 41 59 125 2000 40 601 582 42 2008 44 601 582 42 2009 44 601 582 42 2010 41 59 125 59 ,"{'AvgLine': 7, 'CountLine': 22, 'CountStmt': 8, 'MaxNesting': 0, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 19, 'CountStmtDecl': 6, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 6, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 19, 'CountLineCodeExe': 10, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 6, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 71, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98793,C++,"class JPGMaskBand final: public GDALRasterBand
{
  protected:
    virtual CPLErr IReadBlock( int, int, void * ) override;

  public:
    explicit JPGMaskBand( JPGDatasetCommon *poDS );
    virtual ~JPGMaskBand() {}
};",0,587 2000 2001 58 777 2002 123 775 58 864 2003 2004 40 704 44 704 44 865 42 41 2005 59 777 58 648 2000 40 2006 42 2007 41 59 864 126 2000 40 41 123 125 125 59 ,"{'AvgLine': 17, 'CountLine': 61, 'CountStmt': 30, 'MaxNesting': 3, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 26, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 3, 'CountLineCode': 51, 'CountStmtDecl': 8, 'MaxCyclomatic': 7, 'SumCyclomatic': 9, 'AltAvgLineCode': 14, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 8, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 3, 'AltCountLineCode': 51, 'CountLineCodeExe': 28, 'CountLineComment': 3, 'AltAvgLineComment': 1, 'AltCountLineBlank': 8, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 10, 'CountLineInactive': 0, 'CountDeclMethodAll': 97, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.06', 'AltCountLineComment': 3, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 7, 'SumCyclomaticStrict': 9, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 9, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 3, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98955,C++,"    class GIL_Holder
    {
            bool             m_bExclusiveLock;
            PyGILState_STATE m_eState = 0;

        public:

            explicit GIL_Holder(bool bExclusiveLock);
            virtual ~GIL_Holder();
    };",0,587 2000 123 569 2001 59 2002 2003 61 1500 59 777 58 648 2000 40 569 2004 41 59 864 126 2000 40 41 59 125 59 ,"{'AvgLine': 10, 'CountLine': 30, 'CountStmt': 11, 'MaxNesting': 1, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 6, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 2, 'CountLineCode': 28, 'CountStmtDecl': 5, 'MaxCyclomatic': 2, 'SumCyclomatic': 4, 'AltAvgLineCode': 10, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 28, 'CountLineCodeExe': 8, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 3, 'CountLineInactive': 0, 'CountDeclMethodAll': 2, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 4, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 50, 'SumCyclomaticModified': 4, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 2, 'CountDeclInstanceVariableProtected': 0}"
98676,C++,"class MRFLRasterBand final: public GDALPamRasterBand {
public:
    explicit MRFLRasterBand(MRFRasterBand *b) {
        pBand = b;
        eDataType = b->GetRasterDataType();
        b->GetBlockSize(&nBlockXSize, &nBlockYSize);
        eAccess = b->GetAccess();
        nRasterXSize = b->GetXSize();
        nRasterYSize = b->GetYSize();
    }
    virtual CPLErr IReadBlock(int xblk, int yblk, void *buffer) override {
        return pBand->IReadBlock(xblk, yblk, buffer);
    }
    virtual CPLErr IWriteBlock(int xblk, int yblk, void *buffer) override {
        return pBand->IWriteBlock(xblk, yblk, buffer);
    }
    virtual GDALColorTable *GetColorTable() override {
        return pBand->GetColorTable();
    }
    virtual GDALColorInterp GetColorInterpretation() override {
        return pBand->GetColorInterpretation();
    }
    virtual double  GetNoDataValue(int * pbSuccess) override {
        return pBand->GetNoDataValue(pbSuccess);
    }
    virtual double  GetMinimum(int *b) override {
        return pBand->GetMinimum(b);
    }
    virtual double  GetMaximum(int *b) override {
        return pBand->GetMaximum(b);
    }

protected:
    virtual int GetOverviewCount() override { return 0; }
    virtual GDALRasterBand *GetOverview(int ) override { return nullptr; }

    MRFRasterBand *pBand;
};",0,587 2000 2001 58 777 2002 123 777 58 648 2000 40 2003 42 2004 41 123 2005 61 2004 59 2006 61 2004 354 2007 40 41 59 2004 354 2008 40 38 2009 44 38 2010 41 59 2011 61 2004 354 2012 40 41 59 2013 61 2004 354 2014 40 41 59 2015 61 2004 354 2016 40 41 59 125 864 2017 2018 40 704 2019 44 704 2020 44 865 42 2021 41 2022 123 792 2023 354 2018 40 2019 44 2020 44 2021 41 59 125 864 2017 2024 40 704 2019 44 704 2020 44 865 42 2021 41 2022 123 792 2025 354 2024 40 2019 44 2020 44 2021 41 59 125 864 2026 42 2027 40 41 2022 123 792 2028 354 2027 40 41 59 125 864 2029 2030 40 41 2022 123 792 2031 354 2030 40 41 59 125 864 625 2032 40 704 42 2033 41 2022 123 792 2034 354 2032 40 2033 41 59 125 864 625 2035 40 704 42 2004 41 2022 123 792 2036 354 2035 40 2004 41 59 125 864 625 2037 40 704 42 2004 41 2022 123 792 2038 354 2037 40 2004 41 59 125 775 58 864 704 2039 40 41 2022 123 792 1500 59 125 864 2040 42 2041 40 704 41 2022 123 792 753 59 125 2003 42 2042 59 125 59 ,"{'AvgLine': 3, 'CountLine': 38, 'CountStmt': 26, 'MaxNesting': 0, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 15, 'MaxEssential': 1, 'SumEssential': 10, 'AvgCyclomatic': 1, 'CountLineCode': 36, 'CountStmtDecl': 11, 'MaxCyclomatic': 1, 'SumCyclomatic': 10, 'AltAvgLineCode': 3, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 10, 'AltCountLineCode': 36, 'CountLineCodeExe': 15, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 11, 'CountLineInactive': 0, 'CountDeclMethodAll': 138, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 10, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 8, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 46, 'SumCyclomaticModified': 10, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 15, 'CountDeclMethodProtected': 2, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 1}"
99048,C++,    RegisterMinidriver(MRF);,0,2000 40 2001 41 59 ,"{'AvgLine': 20, 'CountLine': 20, 'CountStmt': 4, 'MaxNesting': 0, 'AvgLineCode': 16, 'AvgEssential': 1, 'AvgLineBlank': 4, 'CountStmtExe': 1, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 1, 'CountLineCode': 16, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 3, 'AltAvgLineCode': 16, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 4, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 4, 'CountDeclMethod': 3, 'AltCountLineCode': 16, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 4, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 0, 'CountLineInactive': 0, 'CountDeclMethodAll': 6, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 3, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 3, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98693,C++,"class BIGGIFDataset final: public GIFAbstractDataset
{
    friend class BIGGifRasterBand;

    int         nLastLineRead;

    GDALDataset *poWorkDS;

    CPLErr       ReOpen();

  protected:
    int CloseDependentDatasets() override;

  public:
    BIGGIFDataset();
    ~BIGGIFDataset() override;

    static GDALDataset *Open( GDALOpenInfo * );
};",0,587 2000 2001 58 777 2002 123 667 587 2003 59 704 2004 59 2005 42 2006 59 2007 2008 40 41 59 775 58 704 2009 40 41 2010 59 777 58 2000 40 41 59 126 2000 40 41 2010 59 809 2005 42 2011 40 2012 42 41 59 125 59 ,"{'AvgLine': 36, 'CountLine': 202, 'CountStmt': 76, 'MaxNesting': 2, 'AvgLineCode': 22, 'AvgEssential': 2, 'AvgLineBlank': 6, 'CountStmtExe': 63, 'MaxEssential': 6, 'SumEssential': 13, 'AvgCyclomatic': 3, 'CountLineCode': 127, 'CountStmtDecl': 18, 'MaxCyclomatic': 7, 'SumCyclomatic': 18, 'AltAvgLineCode': 22, 'AvgLineComment': 7, 'CountClassBase': 1, 'CountLineBlank': 39, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 6, 'CountDeclMethod': 5, 'AltCountLineCode': 127, 'CountLineCodeExe': 79, 'CountLineComment': 36, 'AltAvgLineComment': 7, 'AltCountLineBlank': 39, 'CountClassCoupled': 8, 'CountClassDerived': 0, 'CountLineCodeDecl': 14, 'CountLineInactive': 0, 'CountDeclMethodAll': 211, 'MaxInheritanceTree': 4, 'RatioCommentToCode': '0.28', 'AltCountLineComment': 36, 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 20, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 2, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 64, 'SumCyclomaticModified': 18, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 2, 'CountDeclInstanceVariableProtected': 0}"
98612,C++,"class TimeDelta
{

  private:

    int days ;     /* number of days */
    int secs ;     /* number of seconds since day start */
    int usecs ;    /* number of micro sec. since second start */

    /* SETTERS */

    /* set object using number of days, seconds and micro-seconds */
    inline void set( int daysIn , int secsIn , int usecsIn )
    {
        int tmp0 , tmp1 ;
        /* overflow check with proper handling of negative values */
        /* note that division and modulo for negative values is impl.dependent */

        secsIn += ( tmp0 = usecsIn>=0 ? usecsIn/1000000 : -1-((-usecsIn)/1000000) ) ;
        daysIn += ( tmp1 = secsIn>=0 ? secsIn/86400 : -1-((-secsIn)/86400) ) ;

        this->usecs = usecsIn - 1000000*tmp0 ;
        this->secs  = secsIn - 86400*tmp1 ;
        this->days  = daysIn ;
    }

    /* set object from floating point number of seconds */
    inline void fromSeconds( double secsIn )
    {
        int _days = (int)( secsIn / 86400 ) ;
        int _secs = (int)( secsIn - 86400*_days ) ;
        int _uscs = (int)(( secsIn - ((int)secsIn) )*1e6) ;

        this->set( _days , _secs , _uscs ) ;
    }

  public:

    /* CONSTRUCTORS */
    TimeDelta( void ) : days(0), secs(0), usecs(0) {}

    /* construct object using number of days, seconds and micro-seconds */
    TimeDelta( int daysIn , int secsIn , int usecsIn )
    {
        this->set( daysIn, secsIn, usecsIn ) ;
    }

    /* construct object from floating point number of seconds */
    explicit TimeDelta( double secsIn )
    {
        this->fromSeconds( secsIn ) ;
    }

    /* GETTERS */

    inline int getDays( void ) const
    {
        return this->days ;
    }

    inline int getSeconds( void ) const
    {
        return this->secs ;
    }

    inline int getMicroseconds( void ) const
    {
        return this->usecs ;
    }

    /* convert to seconds - can handle safely at least 250 years dif. */
    /*  ... before losing the microsecond precision */
    inline operator double( void ) const
    {
        return (this->days*86400.0) + this->secs + (this->usecs*1e-6) ;
    }

    /* OPERATORS */

    /* difference */
    inline TimeDelta operator -( const TimeDelta & that ) const
    {
        return TimeDelta( this->days - that.days, this->secs - that.secs,
                                this->usecs - that.usecs ) ;
    }

    /* addition */
    inline TimeDelta operator +( const TimeDelta & that ) const
    {
        return TimeDelta( this->days + that.days, this->secs + that.secs,
                                this->usecs + that.usecs ) ;
    }

    /* division */
    inline double operator /( const TimeDelta & that ) const
    {
        return ( (double)*this / (double)that ) ;
    }

    /* integer multiplication */
    inline TimeDelta operator *( const int i ) const
    {
        return TimeDelta( i*this->days, i*this->secs, i*this->usecs ) ;
    }

    /* float multiplication */
    inline TimeDelta operator *( const double f ) const
    {
        return TimeDelta( f * (double)*this ) ;
    }

    /* comparisons operators */

    inline bool operator ==( const TimeDelta & that ) const
    {
        return ( (this->usecs == that.usecs)&&(this->secs == that.secs)&&
                 (this->days == that.days) )  ;
    }


    inline bool operator >( const TimeDelta & that ) const
    {
        return  (this->days > that.days)
                ||(
                    (this->days == that.days)
                    &&(
                        (this->secs > that.secs)
                        ||(
                            (this->secs == that.secs)
                            &&(this->usecs > that.usecs)
                        )
                    )
                ) ;
    }

    inline bool operator <( const TimeDelta & that ) const
    {
        return  (this->days < that.days)
                ||(
                    (this->days == that.days)
                    &&(
                        (this->secs < that.secs)
                        ||(
                            (this->secs == that.secs)
                            &&(this->usecs < that.usecs)
                        )
                    )
                ) ;
    }

    inline bool operator !=( const TimeDelta & that ) const
    {
        return !( *this == that ) ;
    }

    inline bool operator >=( const TimeDelta & that ) const
    {
        return !( *this < that ) ;
    }

    inline bool operator <=( const TimeDelta & that ) const
    {
        return !( *this > that ) ;
    }

};",0,587 2000 123 773 58 704 2001 59 305 704 2002 59 305 704 2003 59 305 305 305 700 865 2004 40 704 2005 44 704 2006 44 704 2007 41 123 704 2008 44 2009 59 305 305 2006 348 40 2008 61 2007 325 1500 63 2007 47 1507 58 45 1501 45 40 40 45 2007 41 47 1507 41 41 59 2005 348 40 2009 61 2006 325 1500 63 2006 47 1506 58 45 1501 45 40 40 45 2006 41 47 1506 41 41 59 823 354 2003 61 2007 45 1507 42 2008 59 823 354 2002 61 2006 45 1506 42 2009 59 823 354 2001 61 2005 59 125 305 700 865 2010 40 625 2006 41 123 704 2011 61 40 704 41 40 2006 47 1506 41 59 704 2012 61 40 704 41 40 2006 45 1506 42 2011 41 59 704 2013 61 40 704 41 40 40 2006 45 40 40 704 41 2006 41 41 42 1507 41 59 823 354 2004 40 2011 44 2012 44 2013 41 59 125 777 58 305 2000 40 865 41 58 2001 40 1500 41 44 2002 40 1500 41 44 2003 40 1500 41 123 125 305 2000 40 704 2005 44 704 2006 44 704 2007 41 123 823 354 2004 40 2005 44 2006 44 2007 41 59 125 305 648 2000 40 625 2006 41 123 823 354 2010 40 2006 41 59 125 305 700 704 2014 40 865 41 601 123 792 823 354 2001 59 125 700 704 2015 40 865 41 601 123 792 823 354 2002 59 125 700 704 2016 40 865 41 601 123 792 823 354 2003 59 125 305 305 700 758 625 40 865 41 601 123 792 40 823 354 2001 42 1506 41 43 823 354 2002 43 40 823 354 2003 42 1500 41 59 125 305 305 700 2000 758 45 40 601 2000 38 2017 41 601 123 792 2000 40 823 354 2001 45 2017 46 2001 44 823 354 2002 45 2017 46 2002 44 823 354 2003 45 2017 46 2003 41 59 125 305 700 2000 758 43 40 601 2000 38 2017 41 601 123 792 2000 40 823 354 2001 43 2017 46 2001 44 823 354 2002 43 2017 46 2002 44 823 354 2003 43 2017 46 2003 41 59 125 305 700 625 758 47 40 601 2000 38 2017 41 601 123 792 40 40 625 41 42 823 47 40 625 41 2017 41 59 125 305 700 2000 758 42 40 601 704 2018 41 601 123 792 2000 40 2018 42 823 354 2001 44 2018 42 823 354 2002 44 2018 42 823 354 2003 41 59 125 305 700 2000 758 42 40 601 625 2019 41 601 123 792 2000 40 2019 42 40 625 41 42 823 41 59 125 305 700 569 758 323 40 601 2000 38 2017 41 601 123 792 40 40 823 354 2003 323 2017 46 2003 41 307 40 823 354 2002 323 2017 46 2002 41 307 40 823 354 2001 323 2017 46 2001 41 41 59 125 700 569 758 62 40 601 2000 38 2017 41 601 123 792 40 823 354 2001 62 2017 46 2001 41 309 40 40 823 354 2001 323 2017 46 2001 41 307 40 40 823 354 2002 62 2017 46 2002 41 309 40 40 823 354 2002 323 2017 46 2002 41 307 40 823 354 2003 62 2017 46 2003 41 41 41 41 59 125 700 569 758 60 40 601 2000 38 2017 41 601 123 792 40 823 354 2001 60 2017 46 2001 41 309 40 40 823 354 2001 323 2017 46 2001 41 307 40 40 823 354 2002 60 2017 46 2002 41 309 40 40 823 354 2002 323 2017 46 2002 41 307 40 823 354 2003 60 2017 46 2003 41 41 41 41 59 125 700 569 758 340 40 601 2000 38 2017 41 601 123 792 33 40 42 823 323 2017 41 59 125 700 569 758 325 40 601 2000 38 2017 41 601 123 792 33 40 42 823 60 2017 41 59 125 700 569 758 329 40 601 2000 38 2017 41 601 123 792 33 40 42 823 62 2017 41 59 125 125 59 ,"{'AvgLine': 5, 'CountLine': 166, 'CountStmt': 54, 'MaxNesting': 0, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 23, 'MaxEssential': 1, 'SumEssential': 20, 'AvgCyclomatic': 1, 'CountLineCode': 116, 'CountStmtDecl': 31, 'MaxCyclomatic': 3, 'SumCyclomatic': 22, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 32, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 20, 'AltCountLineCode': 116, 'CountLineCodeExe': 50, 'CountLineComment': 21, 'AltAvgLineComment': 0, 'AltCountLineBlank': 32, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 25, 'CountLineInactive': 0, 'CountDeclMethodAll': 20, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.18', 'AltCountLineComment': 21, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 5, 'SumCyclomaticStrict': 32, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 15, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 18, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 60, 'SumCyclomaticModified': 22, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 25, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
98580,C++,"    class PCIDSKBuffer
    {
        friend class MetadataSegment; // ?
    public:
        PCIDSKBuffer( int size = 0 );
        PCIDSKBuffer( const char *src, int size );
        ~PCIDSKBuffer();

        char        *buffer;
        int         buffer_size;

        PCIDSKBuffer &operator=(const PCIDSKBuffer& src);

        const char *Get( int offset, int size ) const;
        void        Get( int offset, int size, std::string &target, int unpad=1 ) const;

        double      GetDouble( int offset, int size ) const;
        int         GetInt( int offset, int size ) const;
        int64       GetInt64( int offset, int size ) const;
        uint64      GetUInt64( int offset, int size ) const;

        void        Put( const char *value,  int offset, int size, bool null_term = false );
        void        Put( uint64 value, int offset, int size );
        void        Put( double value, int offset, int size, const char *fmt=nullptr );
        void        Put( int value, int offset, int size )
            { Put( (uint64) value, offset, size ); }
        void        Put( unsigned int value, int offset, int size )
            { Put( (uint64) value, offset, size ); }

        void        PutBin(double value, int offset);
        void        PutBin(int16 value, int offset);

        void        SetSize( int size );

    private:
        mutable std::string work_field;
    };",0,587 2000 123 667 587 2001 59 330 777 58 2000 40 704 2002 61 1500 41 59 2000 40 601 582 42 2003 44 704 2002 41 59 126 2000 40 41 59 582 42 2004 59 704 2005 59 2000 38 758 61 40 601 2000 38 2003 41 59 601 582 42 2006 40 704 2007 44 704 2002 41 601 59 865 2006 40 704 2007 44 704 2002 44 2008 321 2009 38 2010 44 704 2011 61 1501 41 601 59 625 2012 40 704 2007 44 704 2002 41 601 59 704 2013 40 704 2007 44 704 2002 41 601 59 2014 2015 40 704 2007 44 704 2002 41 601 59 2016 2017 40 704 2007 44 704 2002 41 601 59 865 2018 40 601 582 42 2019 44 704 2007 44 704 2002 44 569 2020 61 655 41 59 865 2018 40 2016 2019 44 704 2007 44 704 2002 41 59 865 2018 40 625 2019 44 704 2007 44 704 2002 44 601 582 42 2021 61 753 41 59 865 2018 40 704 2019 44 704 2007 44 704 2002 41 123 2018 40 40 2016 41 2019 44 2007 44 2002 41 59 125 865 2018 40 856 704 2019 44 704 2007 44 704 2002 41 123 2018 40 40 2016 41 2019 44 2007 44 2002 41 59 125 865 2022 40 625 2019 44 704 2007 41 59 865 2022 40 2023 2019 44 704 2007 41 59 865 2024 40 704 2002 41 59 773 58 740 2008 321 2009 2025 59 125 59 ,"{'AvgLine': 11, 'CountLine': 222, 'CountStmt': 107, 'MaxNesting': 2, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 81, 'MaxEssential': 1, 'SumEssential': 17, 'AvgCyclomatic': 2, 'CountLineCode': 169, 'CountStmtDecl': 34, 'MaxCyclomatic': 5, 'SumCyclomatic': 35, 'AltAvgLineCode': 8, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 49, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 18, 'AltCountLineCode': 169, 'CountLineCodeExe': 105, 'CountLineComment': 5, 'AltAvgLineComment': 0, 'AltCountLineBlank': 49, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 31, 'CountLineInactive': 0, 'CountDeclMethodAll': 18, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.03', 'AltCountLineComment': 5, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 5, 'SumCyclomaticStrict': 36, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 6, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 7, 'CountDeclMethodPublic': 18, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 5, 'PercentLackOfCohesion': 57, 'SumCyclomaticModified': 35, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 19, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
99081,C++,"class KEAMaskBand final: public GDALRasterBand
{
    int m_nSrcBand;
    kealib::KEAImageIO  *m_pImageIO; // our image access pointer - refcounted
    LockedRefCount      *m_pRefCount; // reference count of m_pImageIO
public:
    KEAMaskBand(GDALRasterBand *pParent, kealib::KEAImageIO *pImageIO, LockedRefCount *pRefCount );
    ~KEAMaskBand();

protected:
    // we just override these functions from GDALRasterBand
    virtual CPLErr IReadBlock( int, int, void * ) override;
    virtual CPLErr IWriteBlock( int, int, void * ) override;
};",0,587 2000 2001 58 777 2002 123 704 2003 59 2004 321 2005 42 2006 59 330 2007 42 2008 59 330 777 58 2000 40 2002 42 2009 44 2004 321 2005 42 2010 44 2007 42 2011 41 59 126 2000 40 41 59 775 58 330 864 2012 2013 40 704 44 704 44 865 42 41 2014 59 864 2012 2015 40 704 44 704 44 865 42 41 2014 59 125 59 ,"{'AvgLine': 26, 'CountLine': 118, 'CountStmt': 49, 'MaxNesting': 1, 'AvgLineCode': 22, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 31, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 3, 'CountLineCode': 103, 'CountStmtDecl': 18, 'MaxCyclomatic': 5, 'SumCyclomatic': 15, 'AltAvgLineCode': 22, 'AvgLineComment': 2, 'CountClassBase': 1, 'CountLineBlank': 6, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 4, 'AltCountLineCode': 103, 'CountLineCodeExe': 39, 'CountLineComment': 11, 'AltAvgLineComment': 2, 'AltCountLineBlank': 6, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 16, 'CountLineInactive': 0, 'CountDeclMethodAll': 98, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.11', 'AltCountLineComment': 11, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 5, 'SumCyclomaticStrict': 15, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 5, 'PercentLackOfCohesion': 85, 'SumCyclomaticModified': 15, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 2, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 2, 'CountDeclInstanceVariableProtected': 0}"
98735,C++,"class OCAD_EXTERN CADPolyline3D : public CADGeometry
{
public:
    CADPolyline3D();
    virtual ~CADPolyline3D(){}
    void   addVertex( const CADVector& vertex );
    size_t getVertexCount() const;
    CADVector& getVertex( size_t index );

    virtual void print() const override;
    virtual void transform( const Matrix& matrix ) override;
protected:
    std::vector<CADVector> vertices;
};",0,587 2000 2001 58 777 2002 123 777 58 2001 40 41 59 864 126 2001 40 41 123 125 865 2003 40 601 2004 38 2005 41 59 2006 2007 40 41 601 59 2004 38 2008 40 2006 2009 41 59 864 865 2010 40 41 601 2011 59 864 865 2012 40 601 2013 38 2014 41 2011 59 775 58 2015 321 2016 60 2004 62 2017 59 125 59 ,"{'AvgLine': 5, 'CountLine': 48, 'CountStmt': 23, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 14, 'MaxEssential': 1, 'SumEssential': 7, 'AvgCyclomatic': 1, 'CountLineCode': 47, 'CountStmtDecl': 14, 'MaxCyclomatic': 2, 'SumCyclomatic': 9, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 7, 'AltCountLineCode': 47, 'CountLineCodeExe': 13, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 3, 'CountClassDerived': 1, 'CountLineCodeDecl': 10, 'CountLineInactive': 0, 'CountDeclMethodAll': 20, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 9, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 7, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 33, 'SumCyclomaticModified': 9, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 9, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 1}"
99172,C++,"class MIFFile final : public IMapInfoFile
{
    CPL_DISALLOW_COPY_ASSIGN(MIFFile)

  private:
    char        *m_pszFname;
    TABAccess    m_eAccessMode;
    int          m_nVersion;   /* Dataset version: 300, 450, 600, 900, etc. */
    char        *m_pszDelimiter;
    char        *m_pszUnique;
    char        *m_pszIndex;
    char        *m_pszCoordSys;

    TABFieldType *m_paeFieldType;
    GBool       *m_pabFieldIndexed;
    GBool       *m_pabFieldUnique;

    double       m_dfXMultiplier;
    double       m_dfYMultiplier;
    double       m_dfXDisplacement;
    double       m_dfYDisplacement;

    /* these are the projection bounds, possibly much broader than extents */
    double      m_dXMin;
    double      m_dYMin;
    double      m_dXMax;
    double      m_dYMax;

    /* extents, as cached by MIFFile::PreParseFile() */
    int         m_bExtentsSet;
    OGREnvelope m_sExtents{};

    int         m_nPoints;
    int         m_nLines;
    int         m_nRegions;
    int         m_nTexts;

    int         m_nPreloadedId;  // preloaded mif line is for this feature id
    MIDDATAFile  *m_poMIDFile;   // Mid file
    MIDDATAFile  *m_poMIFFile;   // Mif File

    OGRFeatureDefn *m_poDefn;
    OGRSpatialReference *m_poSpatialRef;

    int         m_nFeatureCount;
    int         m_nWriteFeatureId;
    int         m_nAttribute;

    ///////////////
    // Private Read access specific stuff
    //
    int         ReadFeatureDefn();
    int         ParseMIFHeader(int* pbIsEmpty);
    void        PreParseFile();
    int         AddFields(const char *pszLine);
    int         GotoFeature(int nFeatureId);

    ///////////////
    // Private Write access specific stuff
    //
    GBool       m_bPreParsed;
    GBool       m_bHeaderWrote;

    int         WriteMIFHeader();
    void UpdateExtents(double dfX,double dfY);

  public:
    MIFFile();
    virtual ~MIFFile();

    virtual TABFileClass GetFileClass() override {return TABFC_MIFFile;}

    virtual int Open(const char *pszFname, const char* pszAccess,
                     GBool bTestOpenNoError = FALSE,
                     const char* pszCharset = nullptr ) override { return IMapInfoFile::Open(pszFname, pszAccess, bTestOpenNoError, pszCharset); }
    virtual int Open(const char *pszFname, TABAccess eAccess,
                     GBool bTestOpenNoError = FALSE,
                     const char* pszCharset = nullptr ) override;
    virtual int Close() override;

    virtual const char *GetTableName() override
                           {return m_poDefn?m_poDefn->GetName():"""";}

    virtual int         TestCapability( const char * pszCap ) override ;
    virtual GIntBig     GetFeatureCount (int bForce) override;
    virtual void        ResetReading() override;
    virtual OGRErr      GetExtent(OGREnvelope *psExtent, int bForce) override;
    virtual OGRErr      GetExtent(int iGeomField, OGREnvelope *psExtent, int bForce) override
                { return OGRLayer::GetExtent(iGeomField, psExtent, bForce); }

    ///////////////
    // Read access specific stuff
    //

    virtual GIntBig GetNextFeatureId(GIntBig nPrevId) override;
    virtual TABFeature *GetFeatureRef(GIntBig nFeatureId) override;
    virtual OGRFeatureDefn *GetLayerDefn() override;

    virtual TABFieldType GetNativeFieldType(int nFieldId) override;

    virtual int GetBounds(double &dXMin, double &dYMin,
                          double &dXMax, double &dYMax,
                          GBool bForce = TRUE ) override;

    virtual OGRSpatialReference *GetSpatialRef() override;

    virtual int GetFeatureCountByType(int &numPoints, int &numLines,
                                      int &numRegions, int &numTexts,
                                      GBool bForce = TRUE) override;

    virtual GBool IsFieldIndexed(int nFieldId) override;
    virtual GBool IsFieldUnique(int nFieldId) override;

    virtual int GetVersion() { return m_nVersion; }

    ///////////////
    // Write access specific stuff
    //
    virtual int SetBounds(double dXMin, double dYMin,
                          double dXMax, double dYMax) override;
    virtual int SetFeatureDefn(OGRFeatureDefn *poFeatureDefn,
                            TABFieldType *paeMapInfoNativeFieldTypes = nullptr) override;
    virtual int AddFieldNative(const char *pszName, TABFieldType eMapInfoType,
                               int nWidth=0, int nPrecision=0,
                               GBool bIndexed=FALSE, GBool bUnique=FALSE,
                               int bApproxOK = TRUE) override;
    /* TODO */
    virtual int SetSpatialRef(OGRSpatialReference *poSpatialRef) override;

    virtual OGRErr CreateFeature(TABFeature *poFeature) override;

    virtual int SetFieldIndexed(int nFieldId) override;

    ///////////////
    // semi-private.
    virtual int  GetProjInfo(TABProjInfo * /*poPI*/) override{return -1;}
    /*  { return m_poMAPFile->GetHeaderBlock()->GetProjInfo( poPI ); }*/
    virtual int  SetProjInfo(TABProjInfo * /*poPI*/) override{return -1;}
    /*  { return m_poMAPFile->GetHeaderBlock()->SetProjInfo( poPI ); }*/
    virtual int  SetMIFCoordSys(const char * pszMIFCoordSys) override;
    virtual int SetCharset(const char* pszCharset) override;

#ifdef DEBUG
    virtual void Dump(FILE * /*fpOut*/ = nullptr) override {}
#endif
};",1,587 2000 2001 58 777 2002 123 2003 40 2000 41 773 58 582 42 2004 59 2005 2006 59 704 2007 59 305 582 42 2008 59 582 42 2009 59 582 42 2010 59 582 42 2011 59 2012 42 2013 59 2014 42 2015 59 2014 42 2016 59 625 2017 59 625 2018 59 625 2019 59 625 2020 59 305 625 2021 59 625 2022 59 625 2023 59 625 2024 59 305 704 2025 59 2026 2027 123 125 59 704 2028 59 704 2029 59 704 2030 59 704 2031 59 704 2032 59 330 2033 42 2034 59 330 2033 42 2035 59 330 2036 42 2037 59 2038 42 2039 59 704 2040 59 704 2041 59 704 2042 59 331 330 330 704 2043 40 41 59 704 2044 40 704 42 2045 41 59 865 2046 40 41 59 704 2047 40 601 582 42 2048 41 59 704 2049 40 704 2050 41 59 331 330 330 2014 2051 59 2014 2052 59 704 2053 40 41 59 865 2054 40 625 2055 44 625 2056 41 59 777 58 2000 40 41 59 864 126 2000 40 41 59 864 2057 2058 40 41 2059 123 792 2060 59 125 864 704 2061 40 601 582 42 2062 44 601 582 42 2063 44 2014 2064 61 2065 44 601 582 42 2066 61 753 41 2059 123 792 2002 321 2061 40 2062 44 2063 44 2064 44 2066 41 59 125 864 704 2061 40 601 582 42 2062 44 2005 2067 44 2014 2064 61 2065 44 601 582 42 2066 61 753 41 2059 59 864 704 2068 40 41 2059 59 864 601 582 42 2069 40 41 2059 123 792 2037 63 2037 354 2070 40 41 58 362 59 125 864 704 2071 40 601 582 42 2072 41 2059 59 864 2073 2074 40 704 2075 41 2059 59 864 865 2076 40 41 2059 59 864 2077 2078 40 2026 42 2079 44 704 2075 41 2059 59 864 2077 2078 40 704 2080 44 2026 42 2079 44 704 2075 41 2059 123 792 2081 321 2078 40 2080 44 2079 44 2075 41 59 125 331 330 330 864 2073 2082 40 2073 2083 41 2059 59 864 2084 42 2085 40 2073 2050 41 2059 59 864 2036 42 2086 40 41 2059 59 864 2012 2087 40 704 2088 41 2059 59 864 704 2089 40 625 38 2090 44 625 38 2091 44 625 38 2092 44 625 38 2093 44 2014 2075 61 2094 41 2059 59 864 2038 42 2095 40 41 2059 59 864 704 2096 40 704 38 2097 44 704 38 2098 44 704 38 2099 44 704 38 2100 44 2014 2075 61 2094 41 2059 59 864 2014 2101 40 704 2088 41 2059 59 864 2014 2102 40 704 2088 41 2059 59 864 704 2103 40 41 123 792 2007 59 125 331 330 330 864 704 2104 40 625 2090 44 625 2091 44 625 2092 44 625 2093 41 2059 59 864 704 2105 40 2036 42 2106 44 2012 42 2107 61 753 41 2059 59 864 704 2108 40 601 582 42 2109 44 2012 2110 44 704 2111 61 1500 44 704 2112 61 1500 44 2014 2113 61 2065 44 2014 2114 61 2065 44 704 2115 61 2094 41 2059 59 305 864 704 2116 40 2038 42 2117 41 2059 59 864 2077 2118 40 2084 42 2119 41 2059 59 864 704 2120 40 704 2088 41 2059 59 331 330 864 704 2121 40 2122 42 305 41 2059 123 792 45 1501 59 125 305 864 704 2123 40 2122 42 305 41 2059 123 792 45 1501 59 125 305 864 704 2124 40 601 582 42 2125 41 2059 59 864 704 2126 40 601 582 42 2066 41 2059 59 35 689 2127 864 865 2128 40 2129 42 305 61 753 41 2059 123 125 35 636 125 59 ,"{'AvgLine': 48, 'CountLine': 1960, 'CountStmt': 929, 'MaxNesting': 5, 'AvgLineCode': 37, 'AvgEssential': 4, 'AvgLineBlank': 5, 'CountStmtExe': 794, 'MaxEssential': 24, 'SumEssential': 153, 'AvgCyclomatic': 7, 'CountLineCode': 1490, 'CountStmtDecl': 165, 'MaxCyclomatic': 36, 'SumCyclomatic': 276, 'AltAvgLineCode': 37, 'AvgLineComment': 5, 'CountClassBase': 1, 'CountLineBlank': 229, 'CountStmtEmpty': 7, 'AltAvgLineBlank': 5, 'CountDeclMethod': 41, 'AltCountLineCode': 1509, 'CountLineCodeExe': 1186, 'CountLineComment': 240, 'AltAvgLineComment': 5, 'AltCountLineBlank': 229, 'CountClassCoupled': 21, 'CountClassDerived': 0, 'CountLineCodeDecl': 104, 'CountLineInactive': 4, 'CountDeclMethodAll': 172, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.16', 'AltCountLineComment': 241, 'AvgCyclomaticStrict': 9, 'MaxCyclomaticStrict': 50, 'SumCyclomaticStrict': 351, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 6, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 32, 'CountLinePreprocessor': 15, 'MaxCyclomaticModified': 36, 'PercentLackOfCohesion': 87, 'SumCyclomaticModified': 253, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 9, 'CountDeclInstanceMethod': 41, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 34, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 34, 'CountDeclInstanceVariableProtected': 0}"
117969,C++,"class MixingOutput : public ModuleParams
{
public:
	static constexpr int MAX_ACTUATORS = OutputModuleInterface::MAX_ACTUATORS;

	enum class SchedulingPolicy {
		Disabled, ///< Do not drive scheduling (the module needs to call ScheduleOnInterval() for example)
		Auto ///< Drive scheduling based on subscribed actuator controls topics (via uORB callbacks)
	};

	/**
	 * Constructor
	 * @param param_prefix for min/max/etc. params, e.g. ""PWM_MAIN"". This needs to match 'param_prefix' in the module.yaml
	 * @param max_num_outputs maximum number of supported outputs
	 * @param interface Parent module for scheduling, parameter updates and callbacks
	 * @param scheduling_policy
	 * @param support_esc_calibration true if the output module supports ESC calibration via max, then min setting
	 * @param ramp_up true if motor ramp up from disarmed to min upon arming is wanted
	 */
	MixingOutput(const char *param_prefix, uint8_t max_num_outputs, OutputModuleInterface &interface,
		     SchedulingPolicy scheduling_policy,
		     bool support_esc_calibration, bool ramp_up = true);

	~MixingOutput();

	void setDriverInstance(uint8_t instance) { _driver_instance = instance; }

	void printStatus() const;

	bool useDynamicMixing() const { return _use_dynamic_mixing; }

	/**
	 * Permanently disable an output function
	 */
	void disableFunction(int index) { _param_handles[index].function = PARAM_INVALID; _need_function_update = true; }

	/**
	 * Check if a function is configured, i.e. not set to Disabled and initialized
	 */
	bool isFunctionSet(int index) const { return !_use_dynamic_mixing || _functions[index] != nullptr; }

	OutputFunction outputFunction(int index) const { return _function_assignment[index]; }

	/**
	 * Call this regularly from Run(). It will call interface.updateOutputs().
	 * @return true if outputs were updated
	 */
	bool update();

	/**
	 * Check for subscription updates (e.g. after a mixer is loaded).
	 * Call this at the very end of Run() if allow_wq_switch
	 * @param allow_wq_switch if true
	 * @param limit_callbacks_to_primary set to only register callbacks for primary actuator controls (if used)
	 * @return true if subscriptions got changed
	 */
	bool updateSubscriptions(bool allow_wq_switch = false, bool limit_callbacks_to_primary = false);

	/**
	 * unregister uORB subscription callbacks
	 */
	void unregister();

	void setMaxTopicUpdateRate(unsigned max_topic_update_interval_us);

	/**
	 * Reset (unload) the complete mixer, called from another thread.
	 * This is thread-safe, as long as only one other thread at a time calls this.
	 */
	void resetMixerThreadSafe();

	void resetMixer();

	/**
	 * Load (append) a new mixer from a buffer, called from another thread.
	 * This is thread-safe, as long as only one other thread at a time calls this.
	 * @return 0 on success, <0 error otherwise
	 */
	int loadMixerThreadSafe(const char *buf, unsigned len);

	int loadMixer(const char *buf, unsigned len);

	const actuator_armed_s &armed() const { return _armed; }

	bool initialized() const { return _use_dynamic_mixing || _mixers != nullptr; }

	MixerGroup *mixers() const { return _mixers; }

	void setAllFailsafeValues(uint16_t value);
	void setAllDisarmedValues(uint16_t value);
	void setAllMinValues(uint16_t value);
	void setAllMaxValues(uint16_t value);

	uint16_t &reverseOutputMask() { return _reverse_output_mask; }
	uint16_t &failsafeValue(int index) { return _failsafe_value[index]; }
	/** Disarmed values: disarmedValue < minValue needs to hold */
	uint16_t &disarmedValue(int index) { return _disarmed_value[index]; }
	uint16_t &minValue(int index) { return _min_value[index]; }
	uint16_t &maxValue(int index) { return _max_value[index]; }

	/**
	 * Returns the actual failsafe value taking into account the assigned function
	 */
	uint16_t actualFailsafeValue(int index);

	/**
	 * Get the motor index that maps from PX4 convention to the configured one
	 * @param index motor index in [0, num_motors-1]
	 * @return reordered motor index. When out of range, the input index is returned
	 */
	int reorderedMotorIndex(int index) const;

	void setIgnoreLockdown(bool ignore_lockdown) { _ignore_lockdown = ignore_lockdown; }

	/**
	 * Set the maximum number of outputs. This can only be used to reduce the maximum.
	 */
	void setMaxNumOutputs(uint8_t max_num_outputs) { if (max_num_outputs < _max_num_outputs) { _max_num_outputs = max_num_outputs; } }

	const char *paramPrefix() const { return _param_prefix; }

	void setLowrateSchedulingInterval(hrt_abstime interval) { _lowrate_schedule_interval = interval; }

protected:
	void updateParams() override;

private:
	bool updateSubscriptionsStaticMixer(bool allow_wq_switch, bool limit_callbacks_to_primary);
	bool updateSubscriptionsDynamicMixer(bool allow_wq_switch, bool limit_callbacks_to_primary);

	bool updateStaticMixer();
	bool updateDynamicMixer();

	void handleCommands();

	bool armNoThrottle() const
	{
		return (_armed.prearmed && !_armed.armed) || _armed.in_esc_calibration_mode;
	}

	unsigned motorTest();

	void updateOutputSlewrateMultirotorMixer();
	void updateOutputSlewrateSimplemixer();
	void setAndPublishActuatorOutputs(unsigned num_outputs, actuator_outputs_s &actuator_outputs);
	void publishMixerStatus(const actuator_outputs_s &actuator_outputs);
	void updateLatencyPerfCounter(const actuator_outputs_s &actuator_outputs);

	static int controlCallback(uintptr_t handle, uint8_t control_group, uint8_t control_index, float &input);

	void cleanupFunctions();

	void initParamHandles();

	void limitAndUpdateOutputs(float outputs[MAX_ACTUATORS], bool has_updates);

	struct ParamHandles {
		param_t function{PARAM_INVALID};
		param_t disarmed{PARAM_INVALID};
		param_t min{PARAM_INVALID};
		param_t max{PARAM_INVALID};
		param_t failsafe{PARAM_INVALID};
	};

	enum class MotorOrdering : int32_t {
		PX4 = 0,
		Betaflight = 1
	};

	struct Command {
		enum class Type : int {
			None,
			resetMixer,
			loadMixer
		};
		px4::atomic<int> command{(int)Type::None};
		const char *mixer_buf;
		unsigned mixer_buf_length;
		int result;
	};
	Command _command; ///< incoming commands (from another thread)

	/**
	 * Reorder outputs according to _param_mot_ordering
	 * @param values values to reorder
	 */
	inline void reorderOutputs(uint16_t values[MAX_ACTUATORS]);

	void lock() { do {} while (px4_sem_wait(&_lock) != 0); }
	void unlock() { px4_sem_post(&_lock); }

	px4_sem_t _lock; /**< lock to protect access to work queue changes (includes ScheduleNow calls from another thread) */

	uint16_t _failsafe_value[MAX_ACTUATORS] {};
	uint16_t _disarmed_value[MAX_ACTUATORS] {};
	uint16_t _min_value[MAX_ACTUATORS] {};
	uint16_t _max_value[MAX_ACTUATORS] {};
	uint16_t _current_output_value[MAX_ACTUATORS] {}; ///< current output values (reordered)
	uint16_t _reverse_output_mask{0}; ///< reverses the interval [min, max] -> [max, min], NOT motor direction
	output_limit_t _output_limit;

	uORB::Subscription _armed_sub{ORB_ID(actuator_armed)};
	uORB::SubscriptionCallbackWorkItem _control_subs[actuator_controls_s::NUM_ACTUATOR_CONTROL_GROUPS];

	uORB::PublicationMulti<actuator_outputs_s> _outputs_pub{ORB_ID(actuator_outputs)};
	uORB::PublicationMulti<control_allocator_status_s> _control_allocator_status_pub{ORB_ID(control_allocator_status)};

	actuator_controls_s _controls[actuator_controls_s::NUM_ACTUATOR_CONTROL_GROUPS] {};
	actuator_armed_s _armed{};

	hrt_abstime _time_last_dt_update_multicopter{0};
	hrt_abstime _time_last_dt_update_simple_mixer{0};
	unsigned _max_topic_update_interval_us{0}; ///< max _control_subs topic update interval (0=unlimited)

	bool _throttle_armed{false};
	bool _ignore_lockdown{false}; ///< if true, ignore the _armed.lockdown flag (for HIL outputs)

	MixerGroup *_mixers{nullptr};
	uint32_t _groups_required{0};
	uint32_t _groups_subscribed{1u << 31}; ///< initialize to a different value than _groups_required and outside of (1 << NUM_ACTUATOR_CONTROL_GROUPS)

	const SchedulingPolicy _scheduling_policy;
	const bool _support_esc_calibration;

	bool _wq_switched{false};
	uint8_t _driver_instance{0}; ///< for boards that supports multiple outputs (e.g. PX4IO + FMU)
	uint8_t _max_num_outputs;

	struct MotorTest {
		uORB::Subscription test_motor_sub{ORB_ID(test_motor)};
		bool in_test_mode{false};
		hrt_abstime timeout{0};
	};
	MotorTest _motor_test;

	OutputModuleInterface &_interface;

	perf_counter_t _control_latency_perf;

	/* SYS_CTRL_ALLOC == 1 */
	FunctionProviderBase *_function_allocated[MAX_ACTUATORS] {}; ///< unique allocated functions
	FunctionProviderBase *_functions[MAX_ACTUATORS] {}; ///< currently assigned functions
	OutputFunction _function_assignment[MAX_ACTUATORS] {};
	bool _need_function_update{true};
	bool _use_dynamic_mixing{false}; ///< set to _param_sys_ctrl_alloc on init (avoid changing after startup)
	bool _has_backup_schedule{false};
	bool _reversible_motors =
		false; ///< whether or not the output module supports reversible motors (range [-1, 0] for motors)
	const char *const _param_prefix;
	ParamHandles _param_handles[MAX_ACTUATORS];
	hrt_abstime _lowrate_schedule_interval{300_ms};
	ActuatorTest _actuator_test{_function_assignment};

	uORB::SubscriptionCallbackWorkItem *_subscription_callback{nullptr}; ///< current scheduling callback


	DEFINE_PARAMETERS(
		(ParamInt<px4::params::MC_AIRMODE>) _param_mc_airmode,   ///< multicopter air-mode
		(ParamFloat<px4::params::MOT_SLEW_MAX>) _param_mot_slew_max,
		(ParamFloat<px4::params::THR_MDL_FAC>) _param_thr_mdl_fac, ///< thrust to motor control signal modelling factor
		(ParamInt<px4::params::MOT_ORDERING>) _param_mot_ordering,
		(ParamBool<px4::params::SYS_CTRL_ALLOC>) _param_sys_ctrl_alloc

	)
};",1,587 2000 58 777 2001 123 777 58 809 603 704 2002 61 2003 321 2002 59 640 587 2004 123 2005 44 331 2006 331 125 59 306 2000 40 601 582 42 2007 44 2008 2009 44 2003 38 2010 44 2004 2011 44 569 2012 44 569 2013 61 829 41 59 126 2000 40 41 59 865 2014 40 2008 2015 41 123 2016 61 2015 59 125 865 2017 40 41 601 59 569 2018 40 41 601 123 792 2019 59 125 306 865 2020 40 704 2021 41 123 2022 91 2021 93 46 2023 61 2024 59 2025 61 829 59 125 306 569 2026 40 704 2021 41 601 123 792 33 2027 309 2028 91 2021 93 340 753 59 125 2029 2030 40 704 2021 41 601 123 792 2031 91 2021 93 59 125 306 569 2032 40 41 59 306 569 2033 40 569 2034 61 655 44 569 2035 61 655 41 59 306 865 2036 40 41 59 865 2037 40 856 2038 41 59 306 865 2039 40 41 59 865 2040 40 41 59 306 704 2041 40 601 582 42 2042 44 856 2043 41 59 704 2044 40 601 582 42 2042 44 856 2043 41 59 601 2045 38 2046 40 41 601 123 792 2047 59 125 569 2048 40 41 601 123 792 2049 309 2050 340 753 59 125 2051 42 2052 40 41 601 123 792 2053 59 125 865 2054 40 2055 2056 41 59 865 2057 40 2055 2056 41 59 865 2058 40 2055 2056 41 59 865 2059 40 2055 2056 41 59 2055 38 2060 40 41 123 792 2061 59 125 2055 38 2062 40 704 2021 41 123 792 2063 91 2021 93 59 125 306 2055 38 2064 40 704 2021 41 123 792 2065 91 2021 93 59 125 2055 38 2066 40 704 2021 41 123 792 2067 91 2021 93 59 125 2055 38 2068 40 704 2021 41 123 792 2069 91 2021 93 59 125 306 2055 2070 40 704 2021 41 59 306 704 2071 40 704 2021 41 601 59 865 2072 40 569 2073 41 123 2074 61 2073 59 125 306 865 2075 40 2008 2009 41 123 688 40 2009 60 2076 41 123 2076 61 2009 59 125 125 601 582 42 2077 40 41 601 123 792 2078 59 125 865 2079 40 2080 2081 41 123 2082 61 2081 59 125 775 58 865 2083 40 41 2084 59 773 58 569 2085 40 569 2034 44 569 2035 41 59 569 2086 40 569 2034 44 569 2035 41 59 569 2087 40 41 59 569 2088 40 41 59 865 2089 40 41 59 569 2090 40 41 601 123 792 40 2091 46 2092 307 33 2091 46 2046 41 309 2091 46 2093 59 125 856 2094 40 41 59 865 2095 40 41 59 865 2096 40 41 59 865 2097 40 856 2098 44 2099 38 2100 41 59 865 2101 40 601 2099 38 2100 41 59 865 2102 40 601 2099 38 2100 41 59 809 704 2103 40 2104 2105 44 2008 2106 44 2008 2107 44 660 38 2108 41 59 865 2109 40 41 59 865 2110 40 41 59 865 2111 40 660 2112 91 2002 93 44 569 2113 41 59 816 2114 123 2115 2116 123 2117 125 59 2115 2118 123 2119 125 59 2115 2120 123 2121 125 59 2115 2122 123 2123 125 59 2115 2124 123 2125 125 59 125 59 640 587 2126 58 2127 123 2128 61 1500 44 2129 61 1501 125 59 816 2130 123 640 587 2131 58 704 123 2132 44 2040 44 2044 125 59 2133 321 2134 60 704 62 2135 123 40 704 41 2131 321 2136 125 59 601 582 42 2137 59 856 2138 59 704 2139 59 125 59 2130 2140 59 331 306 700 865 2141 40 2055 2142 91 2002 93 41 59 865 2143 40 41 123 624 123 125 870 40 2144 40 38 2145 41 340 1500 41 59 125 865 2146 40 41 123 2147 40 38 2148 41 59 125 2149 2150 59 306 2055 2151 91 2002 93 123 125 59 2055 2152 91 2002 93 123 125 59 2055 2153 91 2002 93 123 125 59 2055 2154 91 2002 93 123 125 59 2055 2155 91 2002 93 123 125 59 331 2055 2156 123 1500 125 59 331 2157 2158 59 2159 321 2160 2161 123 2162 40 2163 41 125 59 2159 321 2164 2165 91 2166 321 2167 93 59 2159 321 2168 60 2099 62 2169 123 2170 40 2100 41 125 59 2159 321 2168 60 2171 62 2172 123 2173 40 2174 41 125 59 2166 2175 91 2166 321 2167 93 123 125 59 2045 2176 123 125 59 2080 2177 123 1500 125 59 2080 2178 123 1500 125 59 856 2179 123 1500 125 59 331 569 2180 123 655 125 59 569 2181 123 655 125 59 331 2051 42 2182 123 753 125 59 2183 2184 123 1500 125 59 2183 2185 123 1501 332 1503 125 59 331 601 2004 2186 59 601 569 2187 59 569 2188 123 655 125 59 2008 2189 123 1500 125 59 331 2008 2190 59 816 2191 123 2159 321 2160 2192 123 2193 40 2194 41 125 59 569 2195 123 655 125 59 2080 2196 123 1500 125 59 125 59 2191 2197 59 2003 38 2198 59 2199 2200 59 305 2201 42 2202 91 2002 93 123 125 59 331 2201 42 2203 91 2002 93 123 125 59 331 2029 2204 91 2002 93 123 125 59 569 2205 123 829 125 59 569 2206 123 655 125 59 331 569 2207 123 655 125 59 569 2208 61 655 59 331 601 582 42 601 2209 59 2114 2210 91 2002 93 59 2080 2211 123 1504 125 59 2212 2213 123 2204 125 59 2159 321 2164 42 2214 123 753 125 59 331 2215 40 40 2216 60 2217 321 2218 321 2219 62 41 2220 44 331 40 2221 60 2217 321 2218 321 2222 62 41 2223 44 40 2221 60 2217 321 2218 321 2224 62 41 2225 44 331 40 2216 60 2217 321 2218 321 2226 62 41 2227 44 40 2228 60 2217 321 2218 321 2229 62 41 2230 41 125 59 ,"{'AvgLine': 19, 'CountLine': 1324, 'CountStmt': 503, 'MaxNesting': 4, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 3, 'CountStmtExe': 357, 'MaxEssential': 6, 'SumEssential': 77, 'AvgCyclomatic': 3, 'CountLineCode': 926, 'CountStmtDecl': 193, 'MaxCyclomatic': 16, 'SumCyclomatic': 185, 'AltAvgLineCode': 14, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 263, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 3, 'CountDeclMethod': 55, 'AltCountLineCode': 926, 'CountLineCodeExe': 326, 'CountLineComment': 154, 'AltAvgLineComment': 1, 'AltCountLineBlank': 263, 'CountClassCoupled': 19, 'CountClassDerived': 0, 'CountLineCodeDecl': 131, 'CountLineInactive': 0, 'CountDeclMethodAll': 64, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.17', 'AltCountLineComment': 154, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 18, 'SumCyclomaticStrict': 196, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 10, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 37, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 16, 'PercentLackOfCohesion': 95, 'SumCyclomaticModified': 182, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 16, 'CountDeclInstanceMethod': 56, 'CountDeclMethodProtected': 2, 'CountDeclInstanceVariable': 48, 'CountDeclInstanceVariablePublic': 16, 'CountDeclInstanceVariablePrivate': 32, 'CountDeclInstanceVariableProtected': 0}"
99660,C++,"class TABEllipse final : public TABFeature,
                  public ITABFeaturePen,
                  public ITABFeatureBrush
{
  private:
    virtual int UpdateMBR(TABMAPFile *poMapFile = nullptr) override;

  public:
    explicit TABEllipse(OGRFeatureDefn *poDefnIn);
    virtual ~TABEllipse();

    virtual TABFeatureClass GetFeatureClass() override { return TABFCEllipse; }
    virtual TABGeomType     ValidateMapInfoType(TABMAPFile *poMapFile = nullptr) override;

    virtual TABFeature *CloneTABFeature(OGRFeatureDefn *poNewDefn = nullptr ) override;

    virtual int ReadGeometryFromMAPFile(TABMAPFile *poMapFile, TABMAPObjHdr *,
                                        GBool bCoordDataOnly=FALSE,
                                        TABMAPCoordBlock **ppoCoordBlock=nullptr) override;
    virtual int WriteGeometryToMAPFile(TABMAPFile *poMapFile, TABMAPObjHdr *,
                                       GBool bCoordDataOnly=FALSE,
                                       TABMAPCoordBlock **ppoCoordBlock=nullptr) override;

    virtual int ReadGeometryFromMIFFile(MIDDATAFile *fp) override;
    virtual int WriteGeometryToMIFFile(MIDDATAFile *fp) override;

    virtual const char *GetStyleString() const override;

    virtual void DumpMIF(FILE *fpOut = nullptr) override;

    // MapInfo-specific attributes... made available through public vars
    // for now.
    double      m_dCenterX;
    double      m_dCenterY;
    double      m_dXRadius;
    double      m_dYRadius;
};",1,587 2000 2001 58 777 2002 44 777 2003 44 777 2004 123 773 58 864 704 2005 40 2006 42 2007 61 753 41 2008 59 777 58 648 2000 40 2009 42 2010 41 59 864 126 2000 40 41 59 864 2011 2012 40 41 2008 123 792 2013 59 125 864 2014 2015 40 2006 42 2007 61 753 41 2008 59 864 2002 42 2016 40 2009 42 2017 61 753 41 2008 59 864 704 2018 40 2006 42 2007 44 2019 42 44 2020 2021 61 2022 44 2023 42 42 2024 61 753 41 2008 59 864 704 2025 40 2006 42 2007 44 2019 42 44 2020 2021 61 2022 44 2023 42 42 2024 61 753 41 2008 59 864 704 2026 40 2027 42 2028 41 2008 59 864 704 2029 40 2027 42 2028 41 2008 59 864 601 582 42 2030 40 41 601 2008 59 864 865 2031 40 2032 42 2033 61 753 41 2008 59 330 330 625 2034 59 625 2035 59 625 2036 59 625 2037 59 125 59 ,"{'AvgLine': 36, 'CountLine': 477, 'CountStmt': 197, 'MaxNesting': 5, 'AvgLineCode': 24, 'AvgEssential': 1, 'AvgLineBlank': 4, 'CountStmtExe': 157, 'MaxEssential': 4, 'SumEssential': 20, 'AvgCyclomatic': 3, 'CountLineCode': 319, 'CountStmtDecl': 57, 'MaxCyclomatic': 9, 'SumCyclomatic': 41, 'AltAvgLineCode': 24, 'AvgLineComment': 8, 'CountClassBase': 3, 'CountLineBlank': 67, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 4, 'CountDeclMethod': 12, 'AltCountLineCode': 319, 'CountLineCodeExe': 246, 'CountLineComment': 104, 'AltAvgLineComment': 8, 'AltCountLineBlank': 67, 'CountClassCoupled': 13, 'CountClassDerived': 0, 'CountLineCodeDecl': 58, 'CountLineInactive': 0, 'CountDeclMethodAll': 184, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.33', 'AltCountLineComment': 104, 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 54, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 11, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 9, 'PercentLackOfCohesion': 67, 'SumCyclomaticModified': 41, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 14, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 4, 'CountDeclInstanceVariablePublic': 4, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99092,C++,"class OGRGMLASLayer final: public OGRLayer
{
        friend class OGRGMLASDataSource;

        OGRGMLASDataSource            *m_poDS;
        GMLASFeatureClass              m_oFC;
        bool                           m_bLayerDefnFinalized;
        int                            m_nMaxFieldIndex;
        OGRFeatureDefn                *m_poFeatureDefn;

        /** Map from XPath to corresponding field index in OGR layer
            definition */
        std::map<CPLString, int>       m_oMapFieldXPathToOGRFieldIdx;

        /** Map from XPath to corresponding geometry field index in OGR layer
            definition */
        std::map<CPLString, int>       m_oMapFieldXPathToOGRGeomFieldIdx;

        /** Map from a OGR field index to the corresponding field index in
            m_oFC.GetFields() */
        std::map<int, int>             m_oMapOGRFieldIdxtoFCFieldIdx;
        std::map<int, int>             m_oMapOGRGeomFieldIdxtoFCFieldIdx;

        /** Map from XPath to corresponding field index in m_oFC.GetFields() */
        std::map<CPLString, int>       m_oMapFieldXPathToFCFieldIdx;

        bool                           m_bEOF;
        GMLASReader                   *m_poReader;
        VSILFILE                      *m_fpGML;
        /** OGR field index of the ID field */
        int                            m_nIDFieldIdx;
        /** Whether the ID field is generated, or comes from the XML content */
        bool                           m_bIDFieldIsGenerated;
        /** Pointer to parent layer */
        OGRGMLASLayer                 *m_poParentLayer;
        /** OGR field index of the field that points to the parent ID */
        int                            m_nParentIDFieldIdx;

        std::map<CPLString, CPLString> m_oMapSWEFieldToOGRFieldName;

        OGRFeature*                    GetNextRawFeature();

        bool                           InitReader();

        void                           SetLayerDefnFinalized(bool bVal)
                                            { m_bLayerDefnFinalized = bVal; }

        CPLString               LaunderFieldName(const CPLString& osFieldName);

        CPLString               GetXPathFromOGRFieldIndex(int nIdx) const;

    public:
        OGRGMLASLayer(OGRGMLASDataSource* poDS,
                      const GMLASFeatureClass& oFC,
                      OGRGMLASLayer* poParentLayer,
                      bool bAlwaysGenerateOGRPKId);
        explicit OGRGMLASLayer(const char* pszLayerName);
        virtual ~OGRGMLASLayer();

        virtual const char* GetName() override { return GetDescription(); }
        virtual OGRFeatureDefn* GetLayerDefn() override;
        virtual void ResetReading() override;
        virtual OGRFeature* GetNextFeature() override;
        virtual int TestCapability( const char* ) override { return FALSE; }

        void SetDataSource(OGRGMLASDataSource* poDS) { m_poDS = poDS; }

        void PostInit(bool bIncludeGeometryXML);
        void ProcessDataRecordCreateFields(CPLXMLNode* psDataRecord,
                                const std::vector<OGRFeature*>& apoFeatures,
                                OGRLayer* poFieldsMetadataLayer);
        void ProcessDataRecordFillFeature(CPLXMLNode* psDataRecord,
                                          OGRFeature* poFeature);
        void ProcessDataRecordOfDataArrayCreateFields(OGRGMLASLayer* poParentLayer,
                                                      CPLXMLNode* psDataRecord,
                                                      OGRLayer* poFieldsMetadataLayer);
        void CreateCompoundFoldedMappings();

        const GMLASFeatureClass& GetFeatureClass() const { return m_oFC; }
        int GetOGRFieldIndexFromXPath(const CPLString& osXPath) const;
        int GetOGRGeomFieldIndexFromXPath(const CPLString& osXPath) const;
        int GetIDFieldIdx() const { return m_nIDFieldIdx; }
        bool IsGeneratedIDField() const { return m_bIDFieldIsGenerated; }
        OGRGMLASLayer* GetParent() { return m_poParentLayer; }
        int GetParentIDFieldIdx() const { return m_nParentIDFieldIdx; }
        int GetFCFieldIndexFromOGRFieldIdx(int iOGRFieldIdx) const;
        int GetFCFieldIndexFromOGRGeomFieldIdx(int iOGRGeomFieldIdx) const;
        int GetFCFieldIndexFromXPath(const CPLString& osXPath) const;

        bool EvaluateFilter( OGRFeature* poFeature );

        bool RemoveField( int nIdx );
        void InsertNewField( int nInsertPos,
                             OGRFieldDefn& oFieldDefn,
                             const CPLString& osXPath );

        CPLString GetXPathOfFieldLinkForAttrToOtherLayer(
                                        const CPLString& osFieldName,
                                        const CPLString& osTargetLayerXPath );
        CPLString CreateLinkForAttrToOtherLayer( const CPLString& osFieldName,
                                            const CPLString& osTargetLayerXPath );
};",1,587 2000 2001 58 777 2002 123 667 587 2003 59 2003 42 2004 59 2005 2006 59 569 2007 59 704 2008 59 2009 42 2010 59 306 2011 321 2012 60 2013 44 704 62 2014 59 306 2011 321 2012 60 2013 44 704 62 2015 59 306 2011 321 2012 60 704 44 704 62 2016 59 2011 321 2012 60 704 44 704 62 2017 59 306 2011 321 2012 60 2013 44 704 62 2018 59 569 2019 59 2020 42 2021 59 2022 42 2023 59 306 704 2024 59 306 569 2025 59 306 2000 42 2026 59 306 704 2027 59 2011 321 2012 60 2013 44 2013 62 2028 59 2029 42 2030 40 41 59 569 2031 40 41 59 865 2032 40 569 2033 41 123 2007 61 2033 59 125 2013 2034 40 601 2013 38 2035 41 59 2013 2036 40 704 2037 41 601 59 777 58 2000 40 2003 42 2038 44 601 2005 38 2039 44 2000 42 2040 44 569 2041 41 59 648 2000 40 601 582 42 2042 41 59 864 126 2000 40 41 59 864 601 582 42 2043 40 41 2044 123 792 2045 40 41 59 125 864 2009 42 2046 40 41 2044 59 864 865 2047 40 41 2044 59 864 2029 42 2048 40 41 2044 59 864 704 2049 40 601 582 42 41 2044 123 792 2050 59 125 865 2051 40 2003 42 2038 41 123 2004 61 2038 59 125 865 2052 40 569 2053 41 59 865 2054 40 2055 42 2056 44 601 2011 321 2057 60 2029 42 62 38 2058 44 2002 42 2059 41 59 865 2060 40 2055 42 2056 44 2029 42 2061 41 59 865 2062 40 2000 42 2040 44 2055 42 2056 44 2002 42 2059 41 59 865 2063 40 41 59 601 2005 38 2064 40 41 601 123 792 2006 59 125 704 2065 40 601 2013 38 2066 41 601 59 704 2067 40 601 2013 38 2066 41 601 59 704 2068 40 41 601 123 792 2024 59 125 569 2069 40 41 601 123 792 2025 59 125 2000 42 2070 40 41 123 792 2026 59 125 704 2071 40 41 601 123 792 2027 59 125 704 2072 40 704 2073 41 601 59 704 2074 40 704 2075 41 601 59 704 2076 40 601 2013 38 2066 41 601 59 569 2077 40 2029 42 2061 41 59 569 2078 40 704 2037 41 59 865 2079 40 704 2080 44 2081 38 2082 44 601 2013 38 2066 41 59 2013 2083 40 601 2013 38 2035 44 601 2013 38 2084 41 59 2013 2085 40 601 2013 38 2035 44 601 2013 38 2084 41 59 125 59 ,"{'AvgLine': 38, 'CountLine': 1398, 'CountStmt': 532, 'MaxNesting': 8, 'AvgLineCode': 35, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 394, 'MaxEssential': 9, 'SumEssential': 52, 'AvgCyclomatic': 3, 'CountLineCode': 1253, 'CountStmtDecl': 225, 'MaxCyclomatic': 14, 'SumCyclomatic': 111, 'AltAvgLineCode': 35, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 101, 'CountStmtEmpty': 10, 'AltAvgLineBlank': 2, 'CountDeclMethod': 34, 'AltCountLineCode': 1253, 'CountLineCodeExe': 503, 'CountLineComment': 44, 'AltAvgLineComment': 0, 'AltCountLineBlank': 101, 'CountClassCoupled': 12, 'CountClassDerived': 0, 'CountLineCodeDecl': 224, 'CountLineInactive': 0, 'CountDeclMethodAll': 116, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 44, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 16, 'SumCyclomaticStrict': 126, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 10, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 29, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 14, 'PercentLackOfCohesion': 89, 'SumCyclomaticModified': 111, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 5, 'CountDeclInstanceMethod': 36, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 18, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 11, 'CountDeclInstanceVariableProtected': 0}"
117544,C++,"class Magnetometer
{
public:
	static constexpr int MAX_SENSOR_COUNT = 4;

	static constexpr uint8_t DEFAULT_PRIORITY = 50;
	static constexpr uint8_t DEFAULT_EXTERNAL_PRIORITY = 75;

	static constexpr const char *SensorString() { return ""MAG""; }

	Magnetometer();
	explicit Magnetometer(uint32_t device_id, bool external = false);

	~Magnetometer() = default;

	void PrintStatus();

	void set_calibration_index(uint8_t calibration_index) { _calibration_index = calibration_index; }
	void set_device_id(uint32_t device_id, bool external = false);
	void set_external(bool external = true);
	bool set_offset(const matrix::Vector3f &offset);
	bool set_scale(const matrix::Vector3f &scale);
	bool set_offdiagonal(const matrix::Vector3f &offdiagonal);
	void set_rotation(Rotation rotation);
	void set_temperature(float temperature) { _temperature = temperature; };

	bool calibrated() const { return (_device_id != 0) && (_calibration_index >= 0); }
	uint8_t calibration_count() const { return _calibration_count; }
	int8_t calibration_index() const { return _calibration_index; }
	uint32_t device_id() const { return _device_id; }
	bool enabled() const { return (_priority > 0); }
	bool external() const { return _external; }
	const matrix::Vector3f &offset() const { return _offset; }
	const int32_t &priority() const { return _priority; }
	const matrix::Dcmf &rotation() const { return _rotation; }
	const Rotation &rotation_enum() const { return _rotation_enum; }
	const matrix::Matrix3f &scale() const { return _scale; }

	// apply offsets and scale
	// rotate corrected measurements from sensor to body frame
	inline matrix::Vector3f Correct(const matrix::Vector3f &data) const
	{
		return _rotation * (_scale * ((data + _power * _power_compensation) - _offset));
	}

	// Compute sensor offset from bias (board frame)
	matrix::Vector3f BiasCorrectedSensorOffset(const matrix::Vector3f &bias) const
	{
		return _scale.I() * _rotation.I() * bias + _offset;
	}

	bool ParametersSave();
	void ParametersUpdate();

	void Reset();

	void UpdatePower(float power) { _power = power; }

private:
	static constexpr float TEMPERATURE_INVALID = -1000.f;

	Rotation _rotation_enum{ROTATION_NONE};

	matrix::Dcmf _rotation;
	matrix::Vector3f _offset;
	matrix::Matrix3f _scale;
	matrix::Vector3f _power_compensation;
	float _power{0.f};
	float _temperature{NAN};

	int8_t _calibration_index{-1};
	uint32_t _device_id{0};
	int32_t _priority{-1};

	bool _external{false};

	uint8_t _calibration_count{0};
};",1,587 2000 123 777 58 809 603 704 2001 61 1502 59 809 603 2002 2003 61 1503 59 809 603 2002 2004 61 1503 59 809 603 601 582 42 2005 40 41 123 792 362 59 125 2000 40 41 59 648 2000 40 2006 2007 44 569 2008 61 655 41 59 126 2000 40 41 61 613 59 865 2009 40 41 59 865 2010 40 2002 2011 41 123 2012 61 2011 59 125 865 2013 40 2006 2007 44 569 2008 61 655 41 59 865 2014 40 569 2008 61 829 41 59 569 2015 40 601 2016 321 2017 38 2018 41 59 569 2019 40 601 2016 321 2017 38 2020 41 59 569 2021 40 601 2016 321 2017 38 2022 41 59 865 2023 40 2024 2025 41 59 865 2026 40 660 2027 41 123 2028 61 2027 59 125 59 569 2029 40 41 601 123 792 40 2030 340 1500 41 307 40 2031 325 1500 41 59 125 2002 2032 40 41 601 123 792 2033 59 125 2034 2011 40 41 601 123 792 2035 59 125 2006 2007 40 41 601 123 792 2036 59 125 569 2037 40 41 601 123 792 40 2038 62 1500 41 59 125 569 2008 40 41 601 123 792 2039 59 125 601 2016 321 2017 38 2018 40 41 601 123 792 2040 59 125 601 2041 38 2042 40 41 601 123 792 2043 59 125 601 2016 321 2044 38 2025 40 41 601 123 792 2045 59 125 601 2024 38 2046 40 41 601 123 792 2047 59 125 601 2016 321 2048 38 2020 40 41 601 123 792 2049 59 125 330 330 700 2016 321 2017 2050 40 601 2016 321 2017 38 2051 41 601 123 792 2052 42 40 2053 42 40 40 2051 43 2054 42 2055 41 45 2056 41 41 59 125 330 2016 321 2017 2057 40 601 2016 321 2017 38 2058 41 601 123 792 2059 46 2060 40 41 42 2061 46 2060 40 41 42 2058 43 2062 59 125 569 2063 40 41 59 865 2064 40 41 59 865 2065 40 41 59 865 2066 40 660 2067 41 123 2068 61 2067 59 125 773 58 809 603 660 2069 61 45 1504 59 2024 2070 123 2071 125 59 2016 321 2044 2072 59 2016 321 2017 2073 59 2016 321 2048 2074 59 2016 321 2017 2075 59 660 2076 123 1500 125 59 660 2077 123 2078 125 59 2034 2079 123 45 1501 125 59 2006 2080 123 1500 125 59 2041 2081 123 45 1501 125 59 569 2082 123 655 125 59 2002 2083 123 1500 125 59 125 59 ,"{'AvgLine': 9, 'CountLine': 330, 'CountStmt': 155, 'MaxNesting': 4, 'AvgLineCode': 7, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 103, 'MaxEssential': 3, 'SumEssential': 35, 'AvgCyclomatic': 2, 'CountLineCode': 240, 'CountStmtDecl': 55, 'MaxCyclomatic': 13, 'SumCyclomatic': 61, 'AltAvgLineCode': 7, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 68, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 30, 'AltCountLineCode': 243, 'CountLineCodeExe': 107, 'CountLineComment': 20, 'AltAvgLineComment': 0, 'AltCountLineBlank': 68, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 36, 'CountLineInactive': 1, 'CountDeclMethodAll': 30, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.08', 'AltCountLineComment': 20, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 15, 'SumCyclomaticStrict': 80, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 13, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 30, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 13, 'PercentLackOfCohesion': 88, 'SumCyclomaticModified': 61, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 30, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 12, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 10, 'CountDeclInstanceVariableProtected': 0}"
118146,C++,"class MavlinkParametersManager
{
public:
	explicit MavlinkParametersManager(Mavlink *mavlink);
	~MavlinkParametersManager() = default;

	/**
	 * Handle sending of messages. Call this regularly at a fixed frequency.
	 * @param t current time
	 */
	void send();

	unsigned get_size();

	void handle_message(const mavlink_message_t *msg);

private:
	int		_send_all_index{-1};

	/* do not allow top copying this class */
	MavlinkParametersManager(MavlinkParametersManager &);
	MavlinkParametersManager &operator = (const MavlinkParametersManager &);

protected:
	/// send a single param if a PARAM_REQUEST_LIST is in progress
	/// @return true if a parameter was sent
	bool send_one();

	/**
	 * Handle any open param send transfer
	 */
	bool send_params();

	/**
	 * Send UAVCAN params
	 */
	bool send_uavcan();

	/**
	 * Send untransmitted params
	 */
	bool send_untransmitted();

	int send_param(param_t param, int component_id = -1);

	// Item of a single-linked list to store requested uavcan parameters
	struct _uavcan_open_request_list_item {
		uavcan_parameter_request_s req;
		struct _uavcan_open_request_list_item *next;
	};

	/**
	 * Request the next uavcan parameter
	 */
	void request_next_uavcan_parameter();

	/**
	 * Enqueue one uavcan parameter reqest. We store 10 at max.
	 */
	void enque_uavcan_request(uavcan_parameter_request_s *req);

	/**
	 * Drop the first reqest from the list
	 */
	void dequeue_uavcan_request();

	_uavcan_open_request_list_item *_uavcan_open_request_list{nullptr}; ///< Pointer to the first item in the linked list
	bool _uavcan_waiting_for_request_response{false}; ///< We have reqested a parameter and wait for the response
	uint16_t _uavcan_queued_request_items{0};	///< Number of stored parameter requests currently in the list

	uORB::Publication<rc_parameter_map_s>	_rc_param_map_pub{ORB_ID(rc_parameter_map)};
	rc_parameter_map_s _rc_param_map{};

	uORB::Publication<uavcan_parameter_request_s> _uavcan_parameter_request_pub{ORB_ID(uavcan_parameter_request)};
	// enforce ORB_ID(uavcan_parameter_request) constants that map to MAVLINK defines
	static_assert(uavcan_parameter_request_s::MESSAGE_TYPE_PARAM_REQUEST_READ == MAVLINK_MSG_ID_PARAM_REQUEST_READ,
		      ""uavcan_parameter_request_s MAVLINK_MSG_ID_PARAM_REQUEST_READ constant mismatch"");
	static_assert(uavcan_parameter_request_s::MESSAGE_TYPE_PARAM_SET == MAVLINK_MSG_ID_PARAM_SET,
		      ""uavcan_parameter_request_s MAVLINK_MSG_ID_PARAM_SET constant mismatch"");
	static_assert(uavcan_parameter_request_s::MESSAGE_TYPE_PARAM_REQUEST_LIST == MAVLINK_MSG_ID_PARAM_REQUEST_LIST,
		      ""uavcan_parameter_request_s MAVLINK_MSG_ID_PARAM_REQUEST_LIST constant mismatch"");
	static_assert(uavcan_parameter_request_s::NODE_ID_ALL == MAV_COMP_ID_ALL,
		      ""uavcan_parameter_request_s MAV_COMP_ID_ALL constant mismatch"");
	static_assert(uavcan_parameter_request_s::PARAM_TYPE_UINT8 == MAV_PARAM_TYPE_UINT8,
		      ""uavcan_parameter_request_s MAV_PARAM_TYPE_UINT8 constant mismatch"");
	static_assert(uavcan_parameter_request_s::PARAM_TYPE_REAL32 == MAV_PARAM_TYPE_REAL32,
		      ""uavcan_parameter_request_s MAV_PARAM_TYPE_REAL32 constant mismatch"");
	static_assert(uavcan_parameter_request_s::PARAM_TYPE_INT64 == MAV_PARAM_TYPE_INT64,
		      ""uavcan_parameter_request_s MAV_PARAM_TYPE_INT64 constant mismatch"");

	uORB::Subscription _uavcan_parameter_value_sub{ORB_ID(uavcan_parameter_value)};

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};
	hrt_abstime _param_update_time{0};
	int _param_update_index{0};

	Mavlink *_mavlink;

	bool _first_send{false};
};",1,587 2000 123 777 58 648 2000 40 2001 42 2002 41 59 126 2000 40 41 61 613 59 306 865 2003 40 41 59 856 2004 40 41 59 865 2005 40 601 2006 42 2007 41 59 773 58 704 2008 123 45 1501 125 59 305 2000 40 2000 38 41 59 2000 38 758 61 40 601 2000 38 41 59 775 58 331 331 569 2009 40 41 59 306 569 2010 40 41 59 306 569 2011 40 41 59 306 569 2012 40 41 59 704 2013 40 2014 2015 44 704 2016 61 45 1501 41 59 330 816 2017 123 2018 2019 59 816 2017 42 2020 59 125 59 306 865 2021 40 41 59 306 865 2022 40 2023 42 2024 41 59 306 865 2025 40 41 59 2017 42 2026 123 753 125 59 331 569 2027 123 655 125 59 331 2028 2029 123 1500 125 59 331 2030 321 2031 60 2032 62 2033 123 2034 40 2035 41 125 59 2032 2036 123 125 59 2030 321 2031 60 2023 62 2037 123 2038 40 2039 41 125 59 330 810 40 2023 321 2040 323 2041 44 362 41 59 810 40 2023 321 2042 323 2043 44 362 41 59 810 40 2023 321 2044 323 2045 44 362 41 59 810 40 2023 321 2046 323 2047 44 362 41 59 810 40 2023 321 2048 323 2049 44 362 41 59 810 40 2023 321 2050 323 2051 44 362 41 59 810 40 2023 321 2052 323 2053 44 362 41 59 2030 321 2054 2055 123 2056 40 2057 41 125 59 2030 321 2058 2059 123 2060 40 2061 41 44 1501 125 59 2062 2063 123 1500 125 59 704 2064 123 1500 125 59 2001 42 2065 59 569 2066 123 655 125 59 125 59 ,"{'AvgLine': 48, 'CountLine': 686, 'CountStmt': 157, 'MaxNesting': 2, 'AvgLineCode': 32, 'AvgEssential': 1, 'AvgLineBlank': 8, 'CountStmtExe': 92, 'MaxEssential': 6, 'SumEssential': 23, 'AvgCyclomatic': 3, 'CountLineCode': 444, 'CountStmtDecl': 66, 'MaxCyclomatic': 9, 'SumCyclomatic': 42, 'AltAvgLineCode': 33, 'AvgLineComment': 7, 'CountClassBase': 0, 'CountLineBlank': 122, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 8, 'CountDeclMethod': 15, 'AltCountLineCode': 457, 'CountLineCodeExe': 100, 'CountLineComment': 115, 'AltAvgLineComment': 7, 'AltCountLineBlank': 122, 'CountClassCoupled': 4, 'CountClassDerived': 0, 'CountLineCodeDecl': 50, 'CountLineInactive': 5, 'CountDeclMethodAll': 15, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.26', 'AltCountLineComment': 115, 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 9, 'SumCyclomaticStrict': 48, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 6, 'CountLinePreprocessor': 13, 'MaxCyclomaticModified': 9, 'PercentLackOfCohesion': 93, 'SumCyclomaticModified': 42, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 15, 'CountDeclMethodProtected': 7, 'CountDeclInstanceVariable': 13, 'CountDeclInstanceVariablePublic': 5, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 7}"
117603,C++,"class BMI088_Gyroscope : public BMI088
{
public:
	BMI088_Gyroscope(const I2CSPIDriverConfig &config);
	~BMI088_Gyroscope() override;

	void RunImpl() override;
	void print_status() override;

private:
	void exit_and_cleanup() override;

	// Sensor Configuration
	static constexpr uint32_t RATE{2000}; // 2000 Hz
	static constexpr float FIFO_SAMPLE_DT{1e6f / RATE};

	static constexpr int32_t FIFO_MAX_SAMPLES{math::min(FIFO::SIZE / sizeof(FIFO::DATA), sizeof(sensor_gyro_fifo_s::x) / sizeof(sensor_gyro_fifo_s::x[0]))};

	// Transfer data
	struct FIFOTransferBuffer {
		uint8_t cmd{static_cast<uint8_t>(Register::FIFO_DATA) | DIR_READ};
		FIFO::DATA f[FIFO_MAX_SAMPLES] {};
	};
	// ensure no struct padding
	static_assert(sizeof(FIFOTransferBuffer) == (1 + FIFO_MAX_SAMPLES *sizeof(FIFO::DATA)));

	struct register_config_t {
		Register reg;
		uint8_t set_bits{0};
		uint8_t clear_bits{0};
	};

	int probe() override;

	bool Configure();
	void ConfigureGyro();
	void ConfigureSampleRate(int sample_rate = 0);
	void ConfigureFIFOWatermark(uint8_t samples);

	static int DataReadyInterruptCallback(int irq, void *context, void *arg);
	void DataReady();
	bool DataReadyInterruptConfigure();
	bool DataReadyInterruptDisable();

	bool RegisterCheck(const register_config_t &reg_cfg);

	uint8_t RegisterRead(Register reg);
	void RegisterWrite(Register reg, uint8_t value);
	void RegisterSetAndClearBits(Register reg, uint8_t setbits, uint8_t clearbits);

	bool FIFORead(const hrt_abstime &timestamp_sample, uint8_t samples);
	void FIFOReset();

	PX4Gyroscope _px4_gyro;

	perf_counter_t _bad_register_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: bad register"")};
	perf_counter_t _bad_transfer_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: bad transfer"")};
	perf_counter_t _fifo_empty_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: FIFO empty"")};
	perf_counter_t _fifo_overflow_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: FIFO overflow"")};
	perf_counter_t _fifo_reset_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: FIFO reset"")};
	perf_counter_t _drdy_missed_perf{nullptr};

	uint8_t _fifo_samples{static_cast<uint8_t>(_fifo_empty_interval_us / (1000000 / RATE))};

	uint8_t _checked_register{0};
	static constexpr uint8_t size_register_cfg{8};
	register_config_t _register_cfg[size_register_cfg] {
		// Register                         | Set bits, Clear bits
		{ Register::GYRO_RANGE,             GYRO_RANGE_BIT::gyro_range_2000_dps, 0 },
		{ Register::GYRO_BANDWIDTH,         0, GYRO_BANDWIDTH_BIT::gyro_bw_532_Hz },
		{ Register::GYRO_INT_CTRL,          GYRO_INT_CTRL_BIT::fifo_en, 0 },
		{ Register::INT3_INT4_IO_CONF,      0, INT3_INT4_IO_CONF_BIT::Int3_od | INT3_INT4_IO_CONF_BIT::Int3_lvl },
		{ Register::INT3_INT4_IO_MAP,       INT3_INT4_IO_MAP_BIT::Int3_fifo, 0 },
		{ Register::FIFO_WM_ENABLE,         FIFO_WM_ENABLE_BIT::fifo_wm_enable, 0 },
		{ Register::FIFO_CONFIG_0,          0, 0 }, // fifo_water_mark_level_trigger_retain<6:0>
		{ Register::FIFO_CONFIG_1,          FIFO_CONFIG_1_BIT::FIFO_MODE, 0 },
	};
};",1,587 2000 58 777 2001 123 777 58 2000 40 601 2002 38 2003 41 59 126 2000 40 41 2004 59 865 2005 40 41 2004 59 865 2006 40 41 2004 59 773 58 865 2007 40 41 2004 59 330 809 603 2008 2009 123 1505 125 59 330 809 603 660 2010 123 1507 47 2009 125 59 809 603 2011 2012 123 2013 321 2014 40 2015 321 2016 47 805 40 2015 321 2017 41 44 805 40 2018 321 2019 41 47 805 40 2018 321 2019 91 1500 93 41 41 125 59 330 816 2020 123 2021 2022 123 811 60 2021 62 40 2023 321 2024 41 124 2025 125 59 2026 321 2027 2028 91 2012 93 123 125 59 125 59 330 810 40 805 40 2020 41 323 40 1501 43 2012 42 805 40 2029 321 2030 41 41 41 59 816 2031 123 2032 2033 59 2034 2035 123 1500 125 59 2034 2036 123 1500 125 59 125 59 704 2037 40 41 2004 59 569 2038 40 41 59 865 2039 40 41 59 865 2040 40 704 2041 61 1500 41 59 865 2042 40 2043 2044 41 59 809 704 2045 40 704 2046 44 865 42 2047 44 865 42 2048 41 59 865 2049 40 41 59 569 2050 40 41 59 569 2051 40 41 59 569 2052 40 601 2031 38 2053 41 59 2043 2054 40 2055 2056 41 59 865 2057 40 2055 2056 44 2043 2058 41 59 865 2059 40 2055 2056 44 2043 2060 44 2043 2061 41 59 569 2062 40 601 2063 38 2064 44 2043 2044 41 59 865 2065 40 41 59 2066 2067 59 2068 2069 123 2070 40 2071 44 2072 362 41 125 59 2068 2073 123 2074 40 2075 44 2076 362 41 125 59 2068 2077 123 2078 40 2079 44 2080 362 41 125 59 2068 2081 123 2082 40 2083 44 2084 362 41 125 59 2068 2085 123 2086 40 2087 44 2088 362 41 125 59 2068 2089 123 753 125 59 2043 2090 123 811 60 2043 62 40 2091 47 40 1507 47 2009 41 41 125 59 2043 2092 123 1500 125 59 809 603 2043 2093 123 1502 125 59 2031 2094 91 2093 93 123 330 123 2055 321 2095 44 2096 321 2097 44 1500 125 44 123 2055 321 2098 44 1500 44 2099 321 2100 125 44 123 2055 321 2101 44 2102 321 2103 44 1500 125 44 123 2055 321 2104 44 1500 44 2105 321 2106 124 2105 321 2107 125 44 123 2055 321 2108 44 2109 321 2110 44 1500 125 44 123 2055 321 2111 44 2112 321 2113 44 1500 125 44 123 2055 321 2114 44 1500 44 1500 125 44 330 123 2055 321 2115 44 2116 321 2117 44 1500 125 44 125 59 125 59 ,"{'AvgLine': 19, 'CountLine': 930, 'CountStmt': 292, 'MaxNesting': 4, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 3, 'CountStmtExe': 164, 'MaxEssential': 4, 'SumEssential': 48, 'AvgCyclomatic': 2, 'CountLineCode': 700, 'CountStmtDecl': 142, 'MaxCyclomatic': 6, 'SumCyclomatic': 99, 'AltAvgLineCode': 14, 'AvgLineComment': 1, 'CountClassBase': 0, 'CountLineBlank': 168, 'CountStmtEmpty': 10, 'AltAvgLineBlank': 3, 'CountDeclMethod': 43, 'AltCountLineCode': 700, 'CountLineCodeExe': 193, 'CountLineComment': 64, 'AltAvgLineComment': 1, 'AltCountLineBlank': 168, 'CountClassCoupled': 6, 'CountClassDerived': 0, 'CountLineCodeDecl': 127, 'CountLineInactive': 0, 'CountDeclMethodAll': 43, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 64, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 105, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 8, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 91, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 35, 'CountDeclInstanceMethod': 42, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 10, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
118079,C++,"class BMI055_Accelerometer : public BMI055
{
public:
	BMI055_Accelerometer(const I2CSPIDriverConfig &config);
	~BMI055_Accelerometer() override;

	void RunImpl() override;
	void print_status() override;

private:
	void exit_and_cleanup() override;

	// Sensor Configuration
	static constexpr uint32_t RATE{2000}; // 2000 Hz
	static constexpr float FIFO_SAMPLE_DT{1e6f / RATE};

	static constexpr int32_t FIFO_MAX_SAMPLES{math::min(FIFO::SIZE / sizeof(FIFO::DATA), sizeof(sensor_accel_fifo_s::x) / sizeof(sensor_accel_fifo_s::x[0]))};

	// Transfer data
	struct FIFOTransferBuffer {
		uint8_t cmd{static_cast<uint8_t>(Register::FIFO_DATA) | DIR_READ};
		FIFO::DATA f[FIFO_MAX_SAMPLES] {};
	};
	// ensure no struct padding
	static_assert(sizeof(FIFOTransferBuffer) == (1 + FIFO_MAX_SAMPLES *sizeof(FIFO::DATA)));

	struct register_config_t {
		Register reg;
		uint8_t set_bits{0};
		uint8_t clear_bits{0};
	};

	int probe() override;

	bool Configure();
	void ConfigureAccel();
	void ConfigureSampleRate(int sample_rate = 0);
	void ConfigureFIFOWatermark(uint8_t samples);

	static int DataReadyInterruptCallback(int irq, void *context, void *arg);
	void DataReady();
	bool DataReadyInterruptConfigure();
	bool DataReadyInterruptDisable();

	bool RegisterCheck(const register_config_t &reg_cfg);

	uint8_t RegisterRead(Register reg);
	void RegisterWrite(Register reg, uint8_t value);
	void RegisterSetAndClearBits(Register reg, uint8_t setbits, uint8_t clearbits);

	bool FIFORead(const hrt_abstime &timestamp_sample, uint8_t samples);
	void FIFOReset();

	void UpdateTemperature();

	PX4Accelerometer _px4_accel;

	perf_counter_t _bad_register_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: bad register"")};
	perf_counter_t _bad_transfer_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: bad transfer"")};
	perf_counter_t _fifo_empty_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: FIFO empty"")};
	perf_counter_t _fifo_overflow_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: FIFO overflow"")};
	perf_counter_t _fifo_reset_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: FIFO reset"")};
	perf_counter_t _drdy_missed_perf{nullptr};

	uint8_t _fifo_samples{static_cast<uint8_t>(_fifo_empty_interval_us / (1000000 / RATE))};

	uint8_t _checked_register{0};
	static constexpr uint8_t size_register_cfg{7};
	register_config_t _register_cfg[size_register_cfg] {
		// Register                    | Set bits, Clear bits
		{ Register::PMU_RANGE,         PMU_RANGE_BIT::range_16g_set, PMU_RANGE_BIT::range_16g_clear},
		{ Register::ACCD_HBW,          ACCD_HBW_BIT::data_high_bw, 0},
		{ Register::INT_EN_1,          INT_EN_1_BIT::int_fwm_en, 0},
		{ Register::INT_MAP_1,         INT_MAP_1_BIT::int1_fwm, 0},
		{ Register::INT_OUT_CTRL,      0, INT_OUT_CTRL_BIT::int1_od | INT_OUT_CTRL_BIT::int1_lvl},
		{ Register::FIFO_CONFIG_0,     0, 0 }, // fifo_water_mark_level_trigger_retain<5:0>
		{ Register::FIFO_CONFIG_1,     FIFO_CONFIG_1_BIT::fifo_mode, 0},
	};
};",1,587 2000 58 777 2001 123 777 58 2000 40 601 2002 38 2003 41 59 126 2000 40 41 2004 59 865 2005 40 41 2004 59 865 2006 40 41 2004 59 773 58 865 2007 40 41 2004 59 330 809 603 2008 2009 123 1505 125 59 330 809 603 660 2010 123 1507 47 2009 125 59 809 603 2011 2012 123 2013 321 2014 40 2015 321 2016 47 805 40 2015 321 2017 41 44 805 40 2018 321 2019 41 47 805 40 2018 321 2019 91 1500 93 41 41 125 59 330 816 2020 123 2021 2022 123 811 60 2021 62 40 2023 321 2024 41 124 2025 125 59 2026 321 2027 2028 91 2012 93 123 125 59 125 59 330 810 40 805 40 2020 41 323 40 1501 43 2012 42 805 40 2029 321 2030 41 41 41 59 816 2031 123 2032 2033 59 2034 2035 123 1500 125 59 2034 2036 123 1500 125 59 125 59 704 2037 40 41 2004 59 569 2038 40 41 59 865 2039 40 41 59 865 2040 40 704 2041 61 1500 41 59 865 2042 40 2043 2044 41 59 809 704 2045 40 704 2046 44 865 42 2047 44 865 42 2048 41 59 865 2049 40 41 59 569 2050 40 41 59 569 2051 40 41 59 569 2052 40 601 2031 38 2053 41 59 2043 2054 40 2055 2056 41 59 865 2057 40 2055 2056 44 2043 2058 41 59 865 2059 40 2055 2056 44 2043 2060 44 2043 2061 41 59 569 2062 40 601 2063 38 2064 44 2043 2044 41 59 865 2065 40 41 59 865 2066 40 41 59 2067 2068 59 2069 2070 123 2071 40 2072 44 2073 362 41 125 59 2069 2074 123 2075 40 2076 44 2077 362 41 125 59 2069 2078 123 2079 40 2080 44 2081 362 41 125 59 2069 2082 123 2083 40 2084 44 2085 362 41 125 59 2069 2086 123 2087 40 2088 44 2089 362 41 125 59 2069 2090 123 753 125 59 2043 2091 123 811 60 2043 62 40 2092 47 40 1507 47 2009 41 41 125 59 2043 2093 123 1500 125 59 809 603 2043 2094 123 1502 125 59 2031 2095 91 2094 93 123 330 123 2055 321 2096 44 2097 321 2098 44 2097 321 2099 125 44 123 2055 321 2100 44 2101 321 2102 44 1500 125 44 123 2055 321 2103 44 2104 321 2105 44 1500 125 44 123 2055 321 2106 44 2107 321 2108 44 1500 125 44 123 2055 321 2109 44 1500 44 2110 321 2111 124 2110 321 2112 125 44 123 2055 321 2113 44 1500 44 1500 125 44 330 123 2055 321 2114 44 2115 321 2116 44 1500 125 44 125 59 125 59 ,"{'AvgLine': 19, 'CountLine': 497, 'CountStmt': 141, 'MaxNesting': 1, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 3, 'CountStmtExe': 65, 'MaxEssential': 1, 'SumEssential': 21, 'AvgCyclomatic': 2, 'CountLineCode': 370, 'CountStmtDecl': 83, 'MaxCyclomatic': 5, 'SumCyclomatic': 43, 'AltAvgLineCode': 14, 'AvgLineComment': 1, 'CountClassBase': 0, 'CountLineBlank': 91, 'CountStmtEmpty': 4, 'AltAvgLineBlank': 3, 'CountDeclMethod': 21, 'AltCountLineCode': 370, 'CountLineCodeExe': 70, 'CountLineComment': 42, 'AltAvgLineComment': 1, 'AltCountLineBlank': 91, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 53, 'CountLineInactive': 0, 'CountDeclMethodAll': 21, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.11', 'AltCountLineComment': 42, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 5, 'SumCyclomaticStrict': 46, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 40, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 17, 'CountDeclInstanceMethod': 21, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 10, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
118438,C++,"class SmileyPack : public QObject
{
    Q_OBJECT

public:
    static SmileyPack& getInstance();
    static QList<QPair<QString, QString>> listSmileyPacks(const QStringList& paths);
    static QList<QPair<QString, QString>> listSmileyPacks();

    QString smileyfied(const QString& msg);
    QList<QStringList> getEmoticons() const;
    std::shared_ptr<QIcon> getAsIcon(const QString& key) const;

private slots:
    void onSmileyPackChanged();
    void cleanupIconsCache();

private:
    SmileyPack();
    SmileyPack(SmileyPack&) = delete;
    SmileyPack& operator=(const SmileyPack&) = delete;
    ~SmileyPack() override;

    bool load(const QString& filename);
    void constructRegex();

    mutable std::map<QString, std::shared_ptr<QIcon>> cachedIcon;
    QHash<QString, QString> emoticonToPath;
    QList<QStringList> emoticons;
    QString path;
    QTimer* cleanupTimer;
    QRegularExpression smilify;
    mutable QMutex loadingMutex;
};",1,587 2000 58 777 2001 123 2002 777 58 809 2000 38 2003 40 41 59 809 2004 60 2005 60 2006 44 2006 355 2007 40 601 2008 38 2009 41 59 809 2004 60 2005 60 2006 44 2006 355 2007 40 41 59 2006 2010 40 601 2006 38 2011 41 59 2004 60 2008 62 2012 40 41 601 59 2013 321 2014 60 2015 62 2016 40 601 2006 38 2017 41 601 59 773 2018 58 865 2019 40 41 59 865 2020 40 41 59 773 58 2000 40 41 59 2000 40 2000 38 41 61 619 59 2000 38 758 61 40 601 2000 38 41 61 619 59 126 2000 40 41 2021 59 569 2022 40 601 2006 38 2023 41 59 865 2024 40 41 59 740 2013 321 2025 60 2006 44 2013 321 2014 60 2015 355 2026 59 2027 60 2006 44 2006 62 2028 59 2004 60 2008 62 2029 59 2006 2030 59 2031 42 2032 59 2033 2034 59 740 2035 2036 59 125 59 ,"{'AvgLine': 16, 'CountLine': 234, 'CountStmt': 68, 'MaxNesting': 1, 'AvgLineCode': 13, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 12, 'MaxEssential': 1, 'SumEssential': 12, 'AvgCyclomatic': 1, 'CountLineCode': 192, 'CountStmtDecl': 59, 'MaxCyclomatic': 3, 'SumCyclomatic': 16, 'AltAvgLineCode': 13, 'AvgLineComment': 1, 'CountClassBase': 0, 'CountLineBlank': 24, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 17, 'AltCountLineCode': 192, 'CountLineCodeExe': 8, 'CountLineComment': 18, 'AltAvgLineComment': 1, 'AltCountLineBlank': 24, 'CountClassCoupled': 3, 'CountClassDerived': 0, 'CountLineCodeDecl': 49, 'CountLineInactive': 0, 'CountDeclMethodAll': 17, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 18, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 16, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 3, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 8, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 99, 'SumCyclomaticModified': 16, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 9, 'CountDeclInstanceMethod': 17, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 8, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
118118,C++,"class ParameterTest : public UnitTest
{
public:
	virtual bool run_tests();

	ParameterTest()
	{
		p0 = param_find(""TEST_RC_X"");
		p1 = param_find(""TEST_RC2_X"");
		p2 = param_find(""TEST_1"");
		p3 = param_find(""TEST_2"");
		p4 = param_find(""TEST_3"");
	}

private:

	param_t p0{PARAM_INVALID};
	param_t p1{PARAM_INVALID};
	param_t p2{PARAM_INVALID};
	param_t p3{PARAM_INVALID};
	param_t p4{PARAM_INVALID};

	bool _assert_parameter_int_value(param_t param, int32_t expected);
	bool _assert_parameter_float_value(param_t param, float expected);

	bool _set_all_int_parameters_to(int32_t value);

	// tests on the test parameters (TEST_RC_X, TEST_RC2_X, TEST_1, TEST_2, TEST_3)
	bool SimpleFind();
	bool ResetAll();
	bool ResetAllExcludesOne();
	bool ResetAllExcludesTwo();
	bool ResetAllExcludesBoundaryCheck();
	bool ResetAllExcludesWildcard();
	bool CustomDefaults();
	bool exportImport();

	// tests on system parameters
	// WARNING, can potentially trash your system
	bool exportImportAll();
};",1,587 2000 58 777 2001 123 777 58 864 569 2002 40 41 59 2000 40 41 123 2003 61 2004 40 362 41 59 2005 61 2004 40 362 41 59 2006 61 2004 40 362 41 59 2007 61 2004 40 362 41 59 2008 61 2004 40 362 41 59 125 773 58 2009 2010 123 2011 125 59 2009 2012 123 2013 125 59 2009 2014 123 2015 125 59 2009 2016 123 2017 125 59 2009 2018 123 2019 125 59 569 2020 40 2009 2021 44 2022 2023 41 59 569 2024 40 2009 2021 44 660 2023 41 59 569 2025 40 2022 2026 41 59 330 569 2027 40 41 59 569 2028 40 41 59 569 2029 40 41 59 569 2030 40 41 59 569 2031 40 41 59 569 2032 40 41 59 569 2033 40 41 59 569 2034 40 41 59 330 330 569 2035 40 41 59 125 59 ,"{'AvgLine': 36, 'CountLine': 542, 'CountStmt': 559, 'MaxNesting': 5, 'AvgLineCode': 26, 'AvgEssential': 10, 'AvgLineBlank': 8, 'CountStmtExe': 431, 'MaxEssential': 59, 'SumEssential': 149, 'AvgCyclomatic': 16, 'CountLineCode': 388, 'CountStmtDecl': 140, 'MaxCyclomatic': 78, 'SumCyclomatic': 229, 'AltAvgLineCode': 26, 'AvgLineComment': 1, 'CountClassBase': 0, 'CountLineBlank': 128, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 8, 'CountDeclMethod': 14, 'AltCountLineCode': 391, 'CountLineCodeExe': 165, 'CountLineComment': 25, 'AltAvgLineComment': 1, 'AltCountLineBlank': 128, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 71, 'CountLineInactive': 1, 'CountDeclMethodAll': 14, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.06', 'AltCountLineComment': 25, 'AvgCyclomaticStrict': 18, 'MaxCyclomaticStrict': 78, 'SumCyclomaticStrict': 253, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 16, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 78, 'PercentLackOfCohesion': 64, 'SumCyclomaticModified': 229, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 12, 'CountDeclInstanceMethod': 19, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 5, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 5, 'CountDeclInstanceVariableProtected': 0}"
99468,C++,"class TABINDNode
{
    CPL_DISALLOW_COPY_ASSIGN(TABINDNode)

  private:
    VSILFILE    *m_fp;
    TABAccess   m_eAccessMode;
    TABINDNode *m_poCurChildNode;
    TABINDNode *m_poParentNodeRef;

    TABBinBlockManager *m_poBlockManagerRef;

    int         m_nSubTreeDepth;
    int         m_nKeyLength;
    TABFieldType m_eFieldType;
    GBool       m_bUnique;

    GInt32      m_nCurDataBlockPtr;
    int         m_nCurIndexEntry;
    TABRawBinBlock *m_poDataBlock;
    int         m_numEntriesInNode;
    GInt32      m_nPrevNodePtr;
    GInt32      m_nNextNodePtr;

    int         GotoNodePtr(GInt32 nNewNodePtr);
    GInt32      ReadIndexEntry(int nEntryNo, GByte *pKeyValue);
    int         IndexKeyCmp(const GByte *pKeyValue, int nEntryNo);

    int         InsertEntry(GByte *pKeyValue, GInt32 nRecordNo,
                            GBool bInsertAfterCurChild=FALSE,
                            GBool bMakeNewEntryCurChild=FALSE);
    int         SetNodeBufferDirectly(int numEntries, GByte *pBuf,
                                      int nCurIndexEntry=0,
                                      TABINDNode *poCurChild=nullptr);
    GInt32      FindFirst(const GByte *pKeyValue,
                          std::set<int>& oSetVisitedNodePtr);

   public:
    explicit TABINDNode(TABAccess eAccessMode = TABRead);
    ~TABINDNode();

    int         InitNode(VSILFILE *fp, int nBlockPtr,
                         int nKeyLength, int nSubTreeDepth, GBool bUnique,
                         TABBinBlockManager *poBlockMgr=nullptr,
                         TABINDNode *poParentNode=nullptr,
                         int nPrevNodePtr=0, int nNextNodePtr=0);

    int         SetFieldType(TABFieldType eType);
    TABFieldType GetFieldType()         {return m_eFieldType;}

    void        SetUnique(GBool bUnique){m_bUnique = bUnique;}
    GBool       IsUnique()              {return m_bUnique;}

    int         GetKeyLength()          {return m_nKeyLength;}
    int         GetSubTreeDepth()       {return m_nSubTreeDepth;}
    GInt32      GetNodeBlockPtr()       {return m_nCurDataBlockPtr;}
    int         GetNumEntries()         {return m_numEntriesInNode;}
    int         GetMaxNumEntries()      {return (512-12)/(m_nKeyLength+4);}

    GInt32      FindFirst(const GByte *pKeyValue);
    GInt32      FindNext(GByte *pKeyValue);

    int         CommitToFile();

    int         AddEntry(GByte *pKeyValue, GInt32 nRecordNo,
                         GBool bAddInThisNodeOnly=FALSE,
                         GBool bInsertAfterCurChild=FALSE,
                         GBool bMakeNewEntryCurChild=FALSE);
    int         SplitNode();
    int         SplitRootNode();
    GByte*      GetNodeKey();
    int         UpdateCurChildEntry(GByte *pKeyValue, GInt32 nRecordNo);
    int         UpdateSplitChild(GByte *pKeyValue1, GInt32 nRecordNo1,
                                 GByte *pKeyValue2, GInt32 nRecordNo2,
                                 int nNewCurChildNo /* 1 or 2 */);

    int         SetNodeBlockPtr(GInt32 nThisNodePtr);
    int         SetPrevNodePtr(GInt32 nPrevNodePtr);
    int         SetNextNodePtr(GInt32 nNextNodePtr);

#ifdef DEBUG
    void Dump(FILE *fpOut = nullptr);
#endif
};",1,587 2000 123 2001 40 2000 41 773 58 2002 42 2003 59 2004 2005 59 2000 42 2006 59 2000 42 2007 59 2008 42 2009 59 704 2010 59 704 2011 59 2012 2013 59 2014 2015 59 2016 2017 59 704 2018 59 2019 42 2020 59 704 2021 59 2016 2022 59 2016 2023 59 704 2024 40 2016 2025 41 59 2016 2026 40 704 2027 44 2028 42 2029 41 59 704 2030 40 601 2028 42 2029 44 704 2027 41 59 704 2031 40 2028 42 2029 44 2016 2032 44 2014 2033 61 2034 44 2014 2035 61 2034 41 59 704 2036 40 704 2037 44 2028 42 2038 44 704 2039 61 1500 44 2000 42 2040 61 753 41 59 2016 2041 40 601 2028 42 2029 44 2042 321 2043 60 704 62 38 2044 41 59 777 58 648 2000 40 2004 2045 61 2046 41 59 126 2000 40 41 59 704 2047 40 2002 42 2048 44 704 2049 44 704 2050 44 704 2051 44 2014 2052 44 2008 42 2053 61 753 44 2000 42 2054 61 753 44 704 2055 61 1500 44 704 2056 61 1500 41 59 704 2057 40 2012 2058 41 59 2012 2059 40 41 123 792 2013 59 125 865 2060 40 2014 2052 41 123 2015 61 2052 59 125 2014 2061 40 41 123 792 2015 59 125 704 2062 40 41 123 792 2011 59 125 704 2063 40 41 123 792 2010 59 125 2016 2064 40 41 123 792 2017 59 125 704 2065 40 41 123 792 2021 59 125 704 2066 40 41 123 792 40 1504 45 1503 41 47 40 2011 43 1502 41 59 125 2016 2041 40 601 2028 42 2029 41 59 2016 2067 40 2028 42 2029 41 59 704 2068 40 41 59 704 2069 40 2028 42 2029 44 2016 2032 44 2014 2070 61 2034 44 2014 2033 61 2034 44 2014 2035 61 2034 41 59 704 2071 40 41 59 704 2072 40 41 59 2028 42 2073 40 41 59 704 2074 40 2028 42 2029 44 2016 2032 41 59 704 2075 40 2028 42 2076 44 2016 2077 44 2028 42 2078 44 2016 2079 44 704 2080 305 41 59 704 2081 40 2016 2082 41 59 704 2083 40 2016 2055 41 59 704 2084 40 2016 2056 41 59 35 689 2085 865 2086 40 2087 42 2088 61 753 41 59 35 636 125 59 ,"{'AvgLine': 33, 'CountLine': 1044, 'CountStmt': 367, 'MaxNesting': 6, 'AvgLineCode': 21, 'AvgEssential': 3, 'AvgLineBlank': 3, 'CountStmtExe': 288, 'MaxEssential': 15, 'SumEssential': 92, 'AvgCyclomatic': 4, 'CountLineCode': 692, 'CountStmtDecl': 77, 'MaxCyclomatic': 19, 'SumCyclomatic': 124, 'AltAvgLineCode': 22, 'AvgLineComment': 8, 'CountClassBase': 0, 'CountLineBlank': 117, 'CountStmtEmpty': 12, 'AltAvgLineBlank': 3, 'CountDeclMethod': 32, 'AltCountLineCode': 706, 'CountLineCodeExe': 397, 'CountLineComment': 243, 'AltAvgLineComment': 8, 'AltCountLineBlank': 117, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 62, 'CountLineInactive': 9, 'CountDeclMethodAll': 32, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.35', 'AltCountLineComment': 246, 'AvgCyclomaticStrict': 6, 'MaxCyclomaticStrict': 28, 'SumCyclomaticStrict': 180, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 4, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 25, 'CountLinePreprocessor': 8, 'MaxCyclomaticModified': 19, 'PercentLackOfCohesion': 72, 'SumCyclomaticModified': 124, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 7, 'CountDeclInstanceMethod': 32, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 15, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 15, 'CountDeclInstanceVariableProtected': 0}"
98858,C++,"class CPL_DLL CPLODBCStatement {

    CPL_DISALLOW_COPY_ASSIGN(CPLODBCStatement)

    CPLODBCSession     *m_poSession = nullptr;
    HSTMT               m_hStmt = nullptr;

    SQLSMALLINT    m_nColCount = 0;
    char         **m_papszColNames = nullptr;
    SQLSMALLINT   *m_panColType = nullptr;
    char         **m_papszColTypeNames = nullptr;
    CPL_SQLULEN      *m_panColSize = nullptr;
    SQLSMALLINT   *m_panColPrecision = nullptr;
    SQLSMALLINT   *m_panColNullable = nullptr;
    char         **m_papszColColumnDef = nullptr;

    char         **m_papszColValues = nullptr;
    CPL_SQLLEN       *m_panColValueLengths = nullptr;

    int            Failed( int );

    char          *m_pszStatement = nullptr;
    size_t         m_nStatementMax = 0;
    size_t         m_nStatementLen = 0;

  public:
    explicit CPLODBCStatement( CPLODBCSession * );
    ~CPLODBCStatement();

    /** Return statement handle */
    HSTMT          GetStatement() { return m_hStmt; }

    // Command buffer related.
    void           Clear();
    void           AppendEscaped( const char * );
    void           Append( const char * );
    void           Append( int );
    void           Append( double );
    int            Appendf( CPL_FORMAT_STRING(const char *), ... ) CPL_PRINT_FUNC_FORMAT (2, 3);
    /** Return statement string */
    const char    *GetCommand() { return m_pszStatement; }

    int            ExecuteSQL( const char * = nullptr );

    // Results fetching
    int            Fetch( int nOrientation = SQL_FETCH_NEXT,
                          int nOffset = 0 );
    void           ClearColumnData();

    int            GetColCount();
    const char    *GetColName( int );
    short          GetColType( int );
    const char    *GetColTypeName( int );
    short          GetColSize( int );
    short          GetColPrecision( int );
    short          GetColNullable( int );
    const char    *GetColColumnDef( int );

    int            GetColId( const char * );
    const char    *GetColData( int, const char * = nullptr );
    const char    *GetColData( const char *, const char * = nullptr );
    int            GetColDataLength( int );
    int            GetRowCountAffected();

    // Fetch special metadata.
    int            GetColumns( const char *pszTable,
                               const char *pszCatalog = nullptr,
                               const char *pszSchema = nullptr );
    int            GetPrimaryKeys( const char *pszTable,
                                   const char *pszCatalog = nullptr,
                                   const char *pszSchema = nullptr );

    int            GetTables( const char *pszCatalog = nullptr,
                              const char *pszSchema = nullptr );

    void           DumpResult( FILE *fp, int bShowSchema = FALSE );

    static CPLString GetTypeName( int );
    static SQLSMALLINT GetTypeMapping( SQLSMALLINT );

    int            CollectResultsInfo();
};",1,587 2000 2001 123 2002 40 2001 41 2003 42 2004 61 753 59 2005 2006 61 753 59 2007 2008 61 1500 59 582 42 42 2009 61 753 59 2007 42 2010 61 753 59 582 42 42 2011 61 753 59 2012 42 2013 61 753 59 2007 42 2014 61 753 59 2007 42 2015 61 753 59 582 42 42 2016 61 753 59 582 42 42 2017 61 753 59 2018 42 2019 61 753 59 704 2020 40 704 41 59 582 42 2021 61 753 59 2022 2023 61 1500 59 2022 2024 61 1500 59 777 58 648 2001 40 2003 42 41 59 126 2001 40 41 59 306 2005 2025 40 41 123 792 2006 59 125 330 865 2026 40 41 59 865 2027 40 601 582 42 41 59 865 2028 40 601 582 42 41 59 865 2028 40 704 41 59 865 2028 40 625 41 59 704 2029 40 2030 40 601 582 42 41 44 322 41 2031 40 1502 44 1502 41 59 306 601 582 42 2032 40 41 123 792 2021 59 125 704 2033 40 601 582 42 61 753 41 59 330 704 2034 40 704 2035 61 2036 44 704 2037 61 1500 41 59 865 2038 40 41 59 704 2039 40 41 59 601 582 42 2040 40 704 41 59 803 2041 40 704 41 59 601 582 42 2042 40 704 41 59 803 2043 40 704 41 59 803 2044 40 704 41 59 803 2045 40 704 41 59 601 582 42 2046 40 704 41 59 704 2047 40 601 582 42 41 59 601 582 42 2048 40 704 44 601 582 42 61 753 41 59 601 582 42 2048 40 601 582 42 44 601 582 42 61 753 41 59 704 2049 40 704 41 59 704 2050 40 41 59 330 704 2051 40 601 582 42 2052 44 601 582 42 2053 61 753 44 601 582 42 2054 61 753 41 59 704 2055 40 601 582 42 2052 44 601 582 42 2053 61 753 44 601 582 42 2054 61 753 41 59 704 2056 40 601 582 42 2053 61 753 44 601 582 42 2054 61 753 41 59 865 2057 40 2058 42 2059 44 704 2060 61 2061 41 59 809 2062 2063 40 704 41 59 809 2007 2064 40 2007 41 59 704 2065 40 41 59 125 59 ,"{'AvgLine': 27, 'CountLine': 1027, 'CountStmt': 239, 'MaxNesting': 3, 'AvgLineCode': 19, 'AvgEssential': 1, 'AvgLineBlank': 4, 'CountStmtExe': 167, 'MaxEssential': 5, 'SumEssential': 46, 'AvgCyclomatic': 2, 'CountLineCode': 716, 'CountStmtDecl': 84, 'MaxCyclomatic': 7, 'SumCyclomatic': 80, 'AltAvgLineCode': 21, 'AvgLineComment': 2, 'CountClassBase': 0, 'CountLineBlank': 173, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 4, 'CountDeclMethod': 36, 'AltCountLineCode': 774, 'CountLineCodeExe': 186, 'CountLineComment': 74, 'AltAvgLineComment': 2, 'AltCountLineBlank': 183, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 271, 'CountLineInactive': 52, 'CountDeclMethodAll': 36, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.10', 'AltCountLineComment': 81, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 81, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 33, 'CountLinePreprocessor': 22, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 96, 'SumCyclomaticModified': 79, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 3, 'CountDeclInstanceMethod': 35, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 15, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 8, 'CountDeclInstanceVariableProtected': 0}"
99102,C++,"class GDALPDFBaseWriter
{
protected:
    VSILFILE* m_fp = nullptr;
    bool m_bInWriteObj = false;
    std::vector<GDALXRefEntry> m_asXRefEntries{};
    GDALPDFObjectNum m_nPageResourceId{};
    GDALPDFObjectNum m_nCatalogId{};
    int         m_nCatalogGen = 0;
    GDALPDFObjectNum m_nInfoId{};
    int         m_nInfoGen = 0;
    GDALPDFObjectNum m_nXMPId{};
    int         m_nXMPGen = 0;
    GDALPDFObjectNum m_nStructTreeRootId{};
    GDALPDFObjectNum m_nNamesId{};

    GDALPDFObjectNum m_nContentLengthId{};
    VSILFILE* m_fpBack = nullptr;
    VSILFILE* m_fpGZip = nullptr;
    vsi_l_offset m_nStreamStart = 0;

    std::vector<GDALPDFObjectNum> m_asPageId{};
    std::vector<GDALPDFOCGDesc> m_asOCGs{};
    std::map<CPLString,GDALPDFImageDesc> m_oMapSymbolFilenameToDesc{};

public:

    struct ObjectStyle
    {
        unsigned int nPenR = 0;
        unsigned int nPenG = 0;
        unsigned int nPenB = 0;
        unsigned int nPenA = 255;
        unsigned int nBrushR = 127;
        unsigned int nBrushG = 127;
        unsigned int nBrushB = 127;
        unsigned int nBrushA = 127;
        unsigned int nTextR = 0;
        unsigned int nTextG = 0;
        unsigned int nTextB = 0;
        unsigned int nTextA = 255;
        int bSymbolColorDefined = FALSE;
        unsigned int nSymbolR = 0;
        unsigned int nSymbolG = 0;
        unsigned int nSymbolB = 0;
        unsigned int nSymbolA = 255;
        bool bHasPenBrushOrSymbol = false;
        CPLString osTextFont{};
        bool bTextBold = false;
        bool bTextItalic = false;
        double dfTextSize = 12.0;
        double dfTextAngle = 0.0;
        double dfTextStretch = 1.0;
        double dfTextDx = 0.0;
        double dfTextDy = 0.0;
        int nTextAnchor = 1;
        double dfPenWidth = 1.0;
        double dfSymbolSize = 5.0;
        CPLString osDashArray{};
        CPLString osLabelText{};
        CPLString osSymbolId{};
        GDALPDFObjectNum nImageSymbolId{};
        int nImageWidth = 0;
        int nImageHeight = 0;
    };

protected:
    explicit GDALPDFBaseWriter(VSILFILE* fp);
    ~GDALPDFBaseWriter();

    GDALPDFObjectNum AllocNewObject();

    void    StartObj(const GDALPDFObjectNum& nObjectId, int nGen = 0);
    void    EndObj();

    void    StartObjWithStream(const GDALPDFObjectNum& nObjectId,
                                           GDALPDFDictionaryRW& oDict,
                                           bool bDeflate);
    void    EndObjWithStream();

    void    StartNewDoc();
    void    Close();

    void    WriteXRefTableAndTrailer(bool bUpdate,
                                     vsi_l_offset nLastStartXRef);

    GDALPDFObjectNum     WriteSRS_ISO32000(GDALDataset* poSrcDS,
                                double dfUserUnit,
                                const char* pszNEATLINE,
                                PDFMargins* psMargins,
                                int bWriteViewport);
    GDALPDFObjectNum     WriteSRS_OGC_BP(GDALDataset* poSrcDS,
                            double dfUserUnit,
                            const char* pszNEATLINE,
                            PDFMargins* psMargins);
    static GDALPDFDictionaryRW* GDALPDFBuildOGC_BP_Projection(const OGRSpatialReference* poSRS);

    GDALPDFObjectNum WriteOCG(const char* pszLayerName, const GDALPDFObjectNum& nParentId = GDALPDFObjectNum());

    GDALPDFObjectNum     WriteBlock( GDALDataset* poSrcDS,
                        int nXOff, int nYOff, int nReqXSize, int nReqYSize,
                        const GDALPDFObjectNum& nColorTableIdIn,
                        PDFCompressMethod eCompressMethod,
                        int nPredictor,
                        int nJPEGQuality,
                        const char* pszJPEG2000_DRIVER,
                        GDALProgressFunc pfnProgress,
                        void * pProgressData );
    GDALPDFObjectNum     WriteMask(GDALDataset* poSrcDS,
                      int nXOff, int nYOff, int nReqXSize, int nReqYSize,
                      PDFCompressMethod eCompressMethod);

    GDALPDFObjectNum     WriteColorTable(GDALDataset* poSrcDS);

    void GetObjectStyle(const char* pszStyleString,
                        OGRFeatureH hFeat, const double adfMatrix[4],
                        std::map<CPLString,GDALPDFImageDesc> oMapSymbolFilenameToDesc,
                        ObjectStyle& os);
    static CPLString GenerateDrawingStream(OGRGeometryH hGeom,
                                    const double adfMatrix[4],
                                    ObjectStyle& os,
                                    double dfRadius);
    GDALPDFObjectNum WriteAttributes(
        OGRFeatureH hFeat,
        const std::vector<CPLString>& aosIncludedFields,
        const char* pszOGRDisplayField,
        int nMCID,
        const GDALPDFObjectNum& oParent,
        const GDALPDFObjectNum& oPage,
        CPLString& osOutFeatureName);

    GDALPDFObjectNum WriteLabel(OGRGeometryH hGeom,
                                    const double adfMatrix[4],
                                    ObjectStyle& os,
                                    PDFCompressMethod eStreamCompressMethod,
                                    double bboxXMin,
                                    double bboxYMin,
                                    double bboxXMax,
                                    double bboxYMax);

    GDALPDFObjectNum WriteLink(OGRFeatureH hFeat,
                              const char* pszOGRLinkField,
                              const double adfMatrix[4],
                              int bboxXMin,
                              int bboxYMin,
                              int bboxXMax,
                              int bboxYMax);

    static void ComputeIntBBox(OGRGeometryH hGeom,
                           const OGREnvelope& sEnvelope,
                           const double adfMatrix[4],
                           const ObjectStyle& os,
                           double dfRadius,
                           int& bboxXMin,
                           int& bboxYMin,
                           int& bboxXMax,
                           int& bboxYMax);

    GDALPDFObjectNum  WriteJavascript(const char* pszJavascript, bool bDeflate);

public:
    GDALPDFObjectNum  SetInfo(GDALDataset* poSrcDS,
                char** papszOptions);
    GDALPDFObjectNum  SetInfo(const char* pszAUTHOR,
                 const char* pszPRODUCER,
                 const char* pszCREATOR,
                 const char* pszCREATION_DATE,
                 const char* pszSUBJECT,
                 const char* pszTITLE,
                 const char* pszKEYWORDS);
    GDALPDFObjectNum  SetXMP(GDALDataset* poSrcDS,
                const char* pszXMP);
};",1,587 2000 123 775 58 2001 42 2002 61 753 59 569 2003 61 655 59 2004 321 2005 60 2006 62 2007 123 125 59 2008 2009 123 125 59 2008 2010 123 125 59 704 2011 61 1500 59 2008 2012 123 125 59 704 2013 61 1500 59 2008 2014 123 125 59 704 2015 61 1500 59 2008 2016 123 125 59 2008 2017 123 125 59 2008 2018 123 125 59 2001 42 2019 61 753 59 2001 42 2020 61 753 59 2021 2022 61 1500 59 2004 321 2005 60 2008 62 2023 123 125 59 2004 321 2005 60 2024 62 2025 123 125 59 2004 321 2026 60 2027 44 2028 62 2029 123 125 59 777 58 816 2030 123 856 704 2031 61 1500 59 856 704 2032 61 1500 59 856 704 2033 61 1500 59 856 704 2034 61 1504 59 856 704 2035 61 1504 59 856 704 2036 61 1504 59 856 704 2037 61 1504 59 856 704 2038 61 1504 59 856 704 2039 61 1500 59 856 704 2040 61 1500 59 856 704 2041 61 1500 59 856 704 2042 61 1504 59 704 2043 61 2044 59 856 704 2045 61 1500 59 856 704 2046 61 1500 59 856 704 2047 61 1500 59 856 704 2048 61 1504 59 569 2049 61 655 59 2027 2050 123 125 59 569 2051 61 655 59 569 2052 61 655 59 625 2053 61 1503 59 625 2054 61 1500 59 625 2055 61 1501 59 625 2056 61 1500 59 625 2057 61 1500 59 704 2058 61 1501 59 625 2059 61 1501 59 625 2060 61 1502 59 2027 2061 123 125 59 2027 2062 123 125 59 2027 2063 123 125 59 2008 2064 123 125 59 704 2065 61 1500 59 704 2066 61 1500 59 125 59 775 58 648 2000 40 2001 42 2067 41 59 126 2000 40 41 59 2008 2068 40 41 59 865 2069 40 601 2008 38 2070 44 704 2071 61 1500 41 59 865 2072 40 41 59 865 2073 40 601 2008 38 2070 44 2074 38 2075 44 569 2076 41 59 865 2077 40 41 59 865 2078 40 41 59 865 2079 40 41 59 865 2080 40 569 2081 44 2021 2082 41 59 2008 2083 40 2084 42 2085 44 625 2086 44 601 582 42 2087 44 2088 42 2089 44 704 2090 41 59 2008 2091 40 2084 42 2085 44 625 2086 44 601 582 42 2087 44 2088 42 2089 41 59 809 2074 42 2092 40 601 2093 42 2094 41 59 2008 2095 40 601 582 42 2096 44 601 2008 38 2097 61 2008 40 41 41 59 2008 2098 40 2084 42 2085 44 704 2099 44 704 2100 44 704 2101 44 704 2102 44 601 2008 38 2103 44 2104 2105 44 704 2106 44 704 2107 44 601 582 42 2108 44 2109 2110 44 865 42 2111 41 59 2008 2112 40 2084 42 2085 44 704 2099 44 704 2100 44 704 2101 44 704 2102 44 2104 2105 41 59 2008 2113 40 2084 42 2085 41 59 865 2114 40 601 582 42 2115 44 2116 2117 44 601 625 2118 91 1502 93 44 2004 321 2026 60 2027 44 2028 62 2119 44 2030 38 2120 41 59 809 2027 2121 40 2122 2123 44 601 625 2118 91 1502 93 44 2030 38 2120 44 625 2124 41 59 2008 2125 40 2116 2117 44 601 2004 321 2005 60 2027 62 38 2126 44 601 582 42 2127 44 704 2128 44 601 2008 38 2129 44 601 2008 38 2130 44 2027 38 2131 41 59 2008 2132 40 2122 2123 44 601 625 2118 91 1502 93 44 2030 38 2120 44 2104 2133 44 625 2134 44 625 2135 44 625 2136 44 625 2137 41 59 2008 2138 40 2116 2117 44 601 582 42 2139 44 601 625 2118 91 1502 93 44 704 2134 44 704 2135 44 704 2136 44 704 2137 41 59 809 865 2140 40 2122 2123 44 601 2141 38 2142 44 601 625 2118 91 1502 93 44 601 2030 38 2120 44 625 2124 44 704 38 2134 44 704 38 2135 44 704 38 2136 44 704 38 2137 41 59 2008 2143 40 601 582 42 2144 44 569 2076 41 59 777 58 2008 2145 40 2084 42 2085 44 582 42 42 2146 41 59 2008 2145 40 601 582 42 2147 44 601 582 42 2148 44 601 582 42 2149 44 601 582 42 2150 44 601 582 42 2151 44 601 582 42 2152 44 601 582 42 2153 41 59 2008 2154 40 2084 42 2085 44 601 582 42 2155 41 59 125 59 ,"{'AvgLine': 80, 'CountLine': 2353, 'CountStmt': 1209, 'MaxNesting': 7, 'AvgLineCode': 69, 'AvgEssential': 2, 'AvgLineBlank': 8, 'CountStmtExe': 1029, 'MaxEssential': 20, 'SumEssential': 74, 'AvgCyclomatic': 9, 'CountLineCode': 2040, 'CountStmtDecl': 376, 'MaxCyclomatic': 56, 'SumCyclomatic': 267, 'AltAvgLineCode': 70, 'AvgLineComment': 2, 'CountClassBase': 0, 'CountLineBlank': 249, 'CountStmtEmpty': 10, 'AltAvgLineBlank': 8, 'CountDeclMethod': 27, 'AltCountLineCode': 2054, 'CountLineCodeExe': 1730, 'CountLineComment': 71, 'AltAvgLineComment': 2, 'AltCountLineBlank': 250, 'CountClassCoupled': 32, 'CountClassDerived': 3, 'CountLineCodeDecl': 389, 'CountLineInactive': 13, 'CountDeclMethodAll': 27, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.03', 'AltCountLineComment': 71, 'AvgCyclomaticStrict': 13, 'MaxCyclomaticStrict': 78, 'SumCyclomaticStrict': 366, 'CountDeclClassMethod': 3, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 9, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 5, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 56, 'PercentLackOfCohesion': 92, 'SumCyclomaticModified': 267, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 26, 'CountDeclMethodProtected': 22, 'CountDeclInstanceVariable': 19, 'CountDeclInstanceVariablePublic': 4, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 15}"
118423,C++,"class CoreVideoSource : public VideoSource
{
    Q_OBJECT
public:
    // VideoSource interface
    void subscribe() override;
    void unsubscribe() override;

private:
    CoreVideoSource();

    void pushFrame(const vpx_image_t* frame);
    void setDeleteOnClose(bool newstate);

    void stopSource();
    void restartSource();

private:
    std::atomic_int subscribers;
    std::atomic_bool deleteOnClose;
    QMutex biglock;
    std::atomic_bool stopped;

    friend class CoreAV;
    friend class ToxFriendCall;
};",1,587 2000 58 777 2001 123 2002 777 58 330 865 2003 40 41 2004 59 865 2005 40 41 2004 59 773 58 2000 40 41 59 865 2006 40 601 2007 42 2008 41 59 865 2009 40 569 2010 41 59 865 2011 40 41 59 865 2012 40 41 59 773 58 2013 321 2014 2015 59 2013 321 2016 2017 59 2018 2019 59 2013 321 2016 2020 59 667 587 2021 59 667 587 2022 59 125 59 ,"{'AvgLine': 12, 'CountLine': 113, 'CountStmt': 46, 'MaxNesting': 2, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 19, 'MaxEssential': 5, 'SumEssential': 13, 'AvgCyclomatic': 2, 'CountLineCode': 96, 'CountStmtDecl': 31, 'MaxCyclomatic': 8, 'SumCyclomatic': 16, 'AltAvgLineCode': 10, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 15, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 7, 'AltCountLineCode': 96, 'CountLineCodeExe': 12, 'CountLineComment': 2, 'AltAvgLineComment': 0, 'AltCountLineBlank': 15, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 27, 'CountLineInactive': 0, 'CountDeclMethodAll': 12, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.02', 'AltCountLineComment': 2, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 16, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 43, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 8, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 16, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 5, 'CountDeclInstanceMethod': 12, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 4, 'CountDeclInstanceVariablePublic': 4, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
117667,C++,"class VehicleAngularVelocity : public ModuleParams, public px4::ScheduledWorkItem
{
public:
	VehicleAngularVelocity();
	~VehicleAngularVelocity() override;

	void PrintStatus();
	bool Start();
	void Stop();

private:
	void Run() override;

	bool CalibrateAndPublish(const hrt_abstime &timestamp_sample, const matrix::Vector3f &angular_velocity_uncalibrated,
				 const matrix::Vector3f &angular_acceleration_uncalibrated);

	inline float FilterAngularVelocity(int axis, float data[], int N = 1);
	inline float FilterAngularAcceleration(int axis, float inverse_dt_s, float data[], int N = 1);

	void DisableDynamicNotchEscRpm();
	void DisableDynamicNotchFFT();
	void ParametersUpdate(bool force = false);

	void ResetFilters();
	void SensorBiasUpdate(bool force = false);
	bool SensorSelectionUpdate(bool force = false);
	void UpdateDynamicNotchEscRpm(bool force = false);
	void UpdateDynamicNotchFFT(bool force = false);
	bool UpdateSampleRate();

	// scaled appropriately for current sensor
	matrix::Vector3f GetResetAngularVelocity() const;
	matrix::Vector3f GetResetAngularAcceleration() const;

	static constexpr int MAX_SENSOR_COUNT = 4;

	uORB::Publication<vehicle_angular_acceleration_s> _vehicle_angular_acceleration_pub{ORB_ID(vehicle_angular_acceleration)};
	uORB::Publication<vehicle_angular_velocity_s>     _vehicle_angular_velocity_pub{ORB_ID(vehicle_angular_velocity)};

	uORB::Subscription _estimator_selector_status_sub{ORB_ID(estimator_selector_status)};
	uORB::Subscription _estimator_sensor_bias_sub{ORB_ID(estimator_sensor_bias)};
#if !defined(CONSTRAINED_FLASH)
	uORB::Subscription _esc_status_sub {ORB_ID(esc_status)};
	uORB::Subscription _sensor_gyro_fft_sub {ORB_ID(sensor_gyro_fft)};
#endif // !CONSTRAINED_FLASH

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};

	uORB::SubscriptionCallbackWorkItem _sensor_selection_sub{this, ORB_ID(sensor_selection)};
	uORB::SubscriptionCallbackWorkItem _sensor_sub{this, ORB_ID(sensor_gyro)};
	uORB::SubscriptionCallbackWorkItem _sensor_fifo_sub{this, ORB_ID(sensor_gyro_fifo)};

	calibration::Gyroscope _calibration{};

	matrix::Vector3f _bias{};

	matrix::Vector3f _angular_velocity{};
	matrix::Vector3f _angular_acceleration{};

	matrix::Vector3f _angular_velocity_raw_prev{};
	hrt_abstime _timestamp_sample_last{0};

	hrt_abstime _publish_interval_min_us{0};
	hrt_abstime _last_publish{0};

	float _filter_sample_rate_hz{NAN};

	// angular velocity filters
	math::LowPassFilter2p<float> _lp_filter_velocity[3] {};
	math::NotchFilter<float> _notch_filter_velocity[3] {};

#if !defined(CONSTRAINED_FLASH)

	enum DynamicNotch {
		EscRpm = 1,
		FFT    = 2,
	};

	static constexpr hrt_abstime DYNAMIC_NOTCH_FITLER_TIMEOUT = 1_s;

	static constexpr int MAX_NUM_ESC_RPM = sizeof(esc_status_s::esc) / sizeof(esc_status_s::esc[0]);
	static constexpr int MAX_NUM_ESC_RPM_HARMONICS = 3;

	static constexpr int MAX_NUM_FFT_PEAKS = sizeof(sensor_gyro_fft_s::peak_frequencies_x) / sizeof(
				sensor_gyro_fft_s::peak_frequencies_x[0]);

	math::NotchFilter<float> _dynamic_notch_filter_esc_rpm[3][MAX_NUM_ESC_RPM][MAX_NUM_ESC_RPM_HARMONICS] {};
	math::NotchFilter<float> _dynamic_notch_filter_fft[3][MAX_NUM_FFT_PEAKS] {};

	px4::Bitset<MAX_NUM_ESC_RPM> _esc_available{};
	hrt_abstime _last_esc_rpm_notch_update[MAX_NUM_ESC_RPM] {};

	perf_counter_t _dynamic_notch_filter_esc_rpm_update_perf{nullptr};
	perf_counter_t _dynamic_notch_filter_esc_rpm_reset_perf{nullptr};
	perf_counter_t _dynamic_notch_filter_esc_rpm_disable_perf{nullptr};

	perf_counter_t _dynamic_notch_filter_fft_disable_perf{nullptr};
	perf_counter_t _dynamic_notch_filter_fft_reset_perf{nullptr};
	perf_counter_t _dynamic_notch_filter_fft_update_perf{nullptr};

	bool _dynamic_notch_esc_rpm_available{false};
	bool _dynamic_notch_fft_available{false};
#endif // !CONSTRAINED_FLASH

	// angular acceleration filter
	AlphaFilter<float> _lp_filter_acceleration[3] {};

	uint32_t _selected_sensor_device_id{0};

	bool _reset_filters{true};
	bool _fifo_available{false};
	bool _update_sample_rate{true};

	perf_counter_t _cycle_perf{perf_alloc(PC_ELAPSED, MODULE_NAME"": gyro filter"")};
	perf_counter_t _filter_reset_perf{perf_alloc(PC_COUNT, MODULE_NAME"": gyro filter reset"")};
	perf_counter_t _selection_changed_perf{perf_alloc(PC_COUNT, MODULE_NAME"": gyro selection changed"")};

	DEFINE_PARAMETERS(
#if !defined(CONSTRAINED_FLASH)
		(ParamInt<px4::params::IMU_GYRO_DNF_EN>) _param_imu_gyro_dnf_en,
		(ParamFloat<px4::params::IMU_GYRO_DNF_BW>) _param_imu_gyro_dnf_bw,
#endif // !CONSTRAINED_FLASH
		(ParamFloat<px4::params::IMU_GYRO_CUTOFF>) _param_imu_gyro_cutoff,
		(ParamFloat<px4::params::IMU_GYRO_NF_FREQ>) _param_imu_gyro_nf_freq,
		(ParamFloat<px4::params::IMU_GYRO_NF_BW>) _param_imu_gyro_nf_bw,
		(ParamInt<px4::params::IMU_GYRO_RATEMAX>) _param_imu_gyro_ratemax,
		(ParamFloat<px4::params::IMU_DGYRO_CUTOFF>) _param_imu_dgyro_cutoff
	)
};",1,587 2000 58 777 2001 44 777 2002 321 2003 123 777 58 2000 40 41 59 126 2000 40 41 2004 59 865 2005 40 41 59 569 2006 40 41 59 865 2007 40 41 59 773 58 865 2008 40 41 2004 59 569 2009 40 601 2010 38 2011 44 601 2012 321 2013 38 2014 44 601 2012 321 2013 38 2015 41 59 700 660 2016 40 704 2017 44 660 2018 91 93 44 704 2019 61 1501 41 59 700 660 2020 40 704 2017 44 660 2021 44 660 2018 91 93 44 704 2019 61 1501 41 59 865 2022 40 41 59 865 2023 40 41 59 865 2024 40 569 2025 61 655 41 59 865 2026 40 41 59 865 2027 40 569 2025 61 655 41 59 569 2028 40 569 2025 61 655 41 59 865 2029 40 569 2025 61 655 41 59 865 2030 40 569 2025 61 655 41 59 569 2031 40 41 59 330 2012 321 2013 2032 40 41 601 59 2012 321 2013 2033 40 41 601 59 809 603 704 2034 61 1502 59 2035 321 2036 60 2037 62 2038 123 2039 40 2040 41 125 59 2035 321 2036 60 2041 62 2042 123 2043 40 2044 41 125 59 2035 321 2045 2046 123 2047 40 2048 41 125 59 2035 321 2045 2049 123 2050 40 2051 41 125 59 35 688 33 2052 40 2053 41 2035 321 2045 2054 123 2055 40 2056 41 125 59 2035 321 2045 2057 123 2058 40 2059 41 125 59 35 636 330 2035 321 2060 2061 123 2062 40 2063 41 44 1501 125 59 2035 321 2064 2065 123 823 44 2066 40 2067 41 125 59 2035 321 2064 2068 123 823 44 2069 40 2070 41 125 59 2035 321 2064 2071 123 823 44 2072 40 2073 41 125 59 2074 321 2075 2076 123 125 59 2012 321 2013 2077 123 125 59 2012 321 2013 2078 123 125 59 2012 321 2013 2079 123 125 59 2012 321 2013 2080 123 125 59 2010 2081 123 1500 125 59 2010 2082 123 1500 125 59 2010 2083 123 1500 125 59 660 2084 123 2085 125 59 330 2086 321 2087 60 660 62 2088 91 1502 93 123 125 59 2086 321 2089 60 660 62 2090 91 1502 93 123 125 59 35 688 33 2052 40 2053 41 640 2091 123 2092 61 1501 44 2093 61 1502 44 125 59 809 603 2010 2094 61 1501 59 809 603 704 2095 61 805 40 2096 321 2097 41 47 805 40 2096 321 2097 91 1500 93 41 59 809 603 704 2098 61 1502 59 809 603 704 2099 61 805 40 2100 321 2101 41 47 805 40 2100 321 2101 91 1500 93 41 59 2086 321 2089 60 660 62 2102 91 1502 93 91 2095 93 91 2098 93 123 125 59 2086 321 2089 60 660 62 2103 91 1502 93 91 2099 93 123 125 59 2002 321 2104 60 2095 62 2105 123 125 59 2010 2106 91 2095 93 123 125 59 2107 2108 123 753 125 59 2107 2109 123 753 125 59 2107 2110 123 753 125 59 2107 2111 123 753 125 59 2107 2112 123 753 125 59 2107 2113 123 753 125 59 569 2114 123 655 125 59 569 2115 123 655 125 59 35 636 330 330 2116 60 660 62 2117 91 1502 93 123 125 59 2118 2119 123 1500 125 59 569 2120 123 829 125 59 569 2121 123 655 125 59 569 2122 123 829 125 59 2107 2123 123 2124 40 2125 44 2126 362 41 125 59 2107 2127 123 2128 40 2129 44 2130 362 41 125 59 2107 2131 123 2132 40 2133 44 2134 362 41 125 59 2135 40 35 688 33 2052 40 2053 41 40 2136 60 2002 321 2137 321 2138 62 41 2139 44 40 2140 60 2002 321 2137 321 2141 62 41 2142 44 35 636 330 40 2140 60 2002 321 2137 321 2143 62 41 2144 44 40 2140 60 2002 321 2137 321 2145 62 41 2146 44 40 2140 60 2002 321 2137 321 2147 62 41 2148 44 40 2136 60 2002 321 2137 321 2149 62 41 2150 44 40 2140 60 2002 321 2137 321 2151 62 41 2152 41 125 59 ,"{'AvgLine': 40, 'CountLine': 960, 'CountStmt': 341, 'MaxNesting': 6, 'AvgLineCode': 27, 'AvgEssential': 1, 'AvgLineBlank': 8, 'CountStmtExe': 213, 'MaxEssential': 11, 'SumEssential': 41, 'AvgCyclomatic': 4, 'CountLineCode': 653, 'CountStmtDecl': 173, 'MaxCyclomatic': 20, 'SumCyclomatic': 102, 'AltAvgLineCode': 28, 'AvgLineComment': 3, 'CountClassBase': 2, 'CountLineBlank': 216, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 8, 'CountDeclMethod': 21, 'AltCountLineCode': 675, 'CountLineCodeExe': 173, 'CountLineComment': 87, 'AltAvgLineComment': 3, 'AltCountLineBlank': 216, 'CountClassCoupled': 11, 'CountClassDerived': 0, 'CountLineCodeDecl': 119, 'CountLineInactive': 0, 'CountDeclMethodAll': 65, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.13', 'AltCountLineComment': 87, 'AvgCyclomaticStrict': 6, 'MaxCyclomaticStrict': 23, 'SumCyclomaticStrict': 126, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 4, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 5, 'CountLinePreprocessor': 22, 'MaxCyclomaticModified': 20, 'PercentLackOfCohesion': 94, 'SumCyclomaticModified': 102, 'CountDeclClassVariable': 5, 'CountDeclMethodPrivate': 15, 'CountDeclInstanceMethod': 23, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 48, 'CountDeclInstanceVariablePublic': 28, 'CountDeclInstanceVariablePrivate': 20, 'CountDeclInstanceVariableProtected': 0}"
98771,C++,"class FlatBufferBuilder {
 public:
  /// @brief Default constructor for FlatBufferBuilder.
  /// @param[in] initial_size The initial size of the buffer, in bytes. Defaults
  /// to `1024`.
  /// @param[in] allocator An `Allocator` to use. If null will use
  /// `DefaultAllocator`.
  /// @param[in] own_allocator Whether the builder/vector should own the
  /// allocator. Defaults to / `false`.
  /// @param[in] buffer_minalign Force the buffer to be aligned to the given
  /// minimum alignment upon reallocation. Only needed if you intend to store
  /// types with custom alignment AND you wish to read the buffer in-place
  /// directly after creation.
  explicit FlatBufferBuilder(
      size_t initial_size = 1024, Allocator *allocator = nullptr,
      bool own_allocator = false,
      size_t buffer_minalign = AlignOf<largest_scalar_t>())
      : buf_(initial_size, allocator, own_allocator, buffer_minalign),
        num_field_loc(0),
        max_voffset_(0),
        nested(false),
        finished(false),
        minalign_(1),
        force_defaults_(false),
        dedup_vtables_(true),
        string_pool(nullptr) {
    EndianCheck();
  }

  // clang-format off
  /// @brief Move constructor for FlatBufferBuilder.
  #if !defined(FLATBUFFERS_CPP98_STL)
  FlatBufferBuilder(FlatBufferBuilder &&other)
  #else
  FlatBufferBuilder(FlatBufferBuilder &other)
  #endif  // #if !defined(FLATBUFFERS_CPP98_STL)
    : buf_(1024, nullptr, false, AlignOf<largest_scalar_t>()),
      num_field_loc(0),
      max_voffset_(0),
      nested(false),
      finished(false),
      minalign_(1),
      force_defaults_(false),
      dedup_vtables_(true),
      string_pool(nullptr) {
    EndianCheck();
    // Default construct and swap idiom.
    // Lack of delegating constructors in vs2010 makes it more verbose than needed.
    Swap(other);
  }
  // clang-format on

  // clang-format off
  #if !defined(FLATBUFFERS_CPP98_STL)
  // clang-format on
  /// @brief Move assignment operator for FlatBufferBuilder.
  FlatBufferBuilder &operator=(FlatBufferBuilder &&other) {
    // Move construct a temporary and swap idiom
    FlatBufferBuilder temp(std::move(other));
    Swap(temp);
    return *this;
  }
  // clang-format off
  #endif  // defined(FLATBUFFERS_CPP98_STL)
  // clang-format on

  void Swap(FlatBufferBuilder &other) {
    using std::swap;
    buf_.swap(other.buf_);
    swap(num_field_loc, other.num_field_loc);
    swap(max_voffset_, other.max_voffset_);
    swap(nested, other.nested);
    swap(finished, other.finished);
    swap(minalign_, other.minalign_);
    swap(force_defaults_, other.force_defaults_);
    swap(dedup_vtables_, other.dedup_vtables_);
    swap(string_pool, other.string_pool);
  }

  ~FlatBufferBuilder() {
    if (string_pool) delete string_pool;
  }

  void Reset() {
    Clear();       // clear builder state
    buf_.reset();  // deallocate buffer
  }

  /// @brief Reset all the state in this FlatBufferBuilder so it can be reused
  /// to construct another buffer.
  void Clear() {
    ClearOffsets();
    buf_.clear();
    nested = false;
    finished = false;
    minalign_ = 1;
    if (string_pool) string_pool->clear();
  }

  /// @brief The current size of the serialized buffer, counting from the end.
  /// @return Returns an `uoffset_t` with the current size of the buffer.
  uoffset_t GetSize() const { return buf_.size(); }

  /// @brief Get the serialized buffer (after you call `Finish()`).
  /// @return Returns an `uint8_t` pointer to the FlatBuffer data inside the
  /// buffer.
  uint8_t *GetBufferPointer() const {
    Finished();
    return buf_.data();
  }

  /// @brief Get the serialized buffer (after you call `Finish()`) as a span.
  /// @return Returns a constructed flatbuffers::span that is a view over the
  /// FlatBuffer data inside the buffer.
  flatbuffers::span<uint8_t> GetBufferSpan() const {
    Finished();
    return flatbuffers::span<uint8_t>(buf_.data(), buf_.size());
  }

  /// @brief Get a pointer to an unfinished buffer.
  /// @return Returns a `uint8_t` pointer to the unfinished buffer.
  uint8_t *GetCurrentBufferPointer() const { return buf_.data(); }

  /// @brief Get the released pointer to the serialized buffer.
  /// @warning Do NOT attempt to use this FlatBufferBuilder afterwards!
  /// @return A `FlatBuffer` that owns the buffer and its allocator and
  /// behaves similar to a `unique_ptr` with a deleter.
  FLATBUFFERS_ATTRIBUTE(deprecated(""use Release() instead""))
  DetachedBuffer ReleaseBufferPointer() {
    Finished();
    return buf_.release();
  }

  /// @brief Get the released DetachedBuffer.
  /// @return A `DetachedBuffer` that owns the buffer and its allocator.
  DetachedBuffer Release() {
    Finished();
    return buf_.release();
  }

  /// @brief Get the released pointer to the serialized buffer.
  /// @param size The size of the memory block containing
  /// the serialized `FlatBuffer`.
  /// @param offset The offset from the released pointer where the finished
  /// `FlatBuffer` starts.
  /// @return A raw pointer to the start of the memory block containing
  /// the serialized `FlatBuffer`.
  /// @remark If the allocator is owned, it gets deleted when the destructor is
  /// called..
  uint8_t *ReleaseRaw(size_t &size, size_t &offset) {
    Finished();
    return buf_.release_raw(size, offset);
  }

  /// @brief get the minimum alignment this buffer needs to be accessed
  /// properly. This is only known once all elements have been written (after
  /// you call Finish()). You can use this information if you need to embed
  /// a FlatBuffer in some other buffer, such that you can later read it
  /// without first having to copy it into its own buffer.
  size_t GetBufferMinAlignment() const {
    Finished();
    return minalign_;
  }

  /// @cond FLATBUFFERS_INTERNAL
  void Finished() const {
    // If you get this assert, you're attempting to get access a buffer
    // which hasn't been finished yet. Be sure to call
    // FlatBufferBuilder::Finish with your root table.
    // If you really need to access an unfinished buffer, call
    // GetCurrentBufferPointer instead.
    FLATBUFFERS_ASSERT(finished);
  }
  /// @endcond

  /// @brief In order to save space, fields that are set to their default value
  /// don't get serialized into the buffer.
  /// @param[in] fd When set to `true`, always serializes default values that
  /// are set. Optional fields which are not set explicitly, will still not be
  /// serialized.
  void ForceDefaults(bool fd) { force_defaults_ = fd; }

  /// @brief By default vtables are deduped in order to save space.
  /// @param[in] dedup When set to `true`, dedup vtables.
  void DedupVtables(bool dedup) { dedup_vtables_ = dedup; }

  /// @cond FLATBUFFERS_INTERNAL
  void Pad(size_t num_bytes) { buf_.fill(num_bytes); }

  void TrackMinAlign(size_t elem_size) {
    if (elem_size > minalign_) minalign_ = elem_size;
  }

  void Align(size_t elem_size) {
    TrackMinAlign(elem_size);
    buf_.fill(PaddingBytes(buf_.size(), elem_size));
  }

  void PushFlatBuffer(const uint8_t *bytes, size_t size) {
    PushBytes(bytes, size);
    finished = true;
  }

  void PushBytes(const uint8_t *bytes, size_t size) { buf_.push(bytes, size); }

  void PopBytes(size_t amount) { buf_.pop(amount); }

  template<typename T> void AssertScalarT() {
    // The code assumes power of 2 sizes and endian-swap-ability.
    static_assert(flatbuffers::is_scalar<T>::value, ""T must be a scalar type"");
  }

  // Write a single aligned scalar to the buffer
  template<typename T> uoffset_t PushElement(T element) {
    AssertScalarT<T>();
    T litle_endian_element = EndianScalar(element);
    Align(sizeof(T));
    buf_.push_small(litle_endian_element);
    return GetSize();
  }

  template<typename T> uoffset_t PushElement(Offset<T> off) {
    // Special case for offsets: see ReferTo below.
    return PushElement(ReferTo(off.o));
  }

  // When writing fields, we track where they are, so we can create correct
  // vtables later.
  void TrackField(voffset_t field, uoffset_t off) {
    FieldLoc fl = { off, field };
    buf_.scratch_push_small(fl);
    num_field_loc++;
    max_voffset_ = (std::max)(max_voffset_, field);
  }

  // Like PushElement, but additionally tracks the field this represents.
  template<typename T> void AddElement(voffset_t field, T e, T def) {
    // We don't serialize values equal to the default.
    if (IsTheSameAs(e, def) && !force_defaults_) return;
    auto off = PushElement(e);
    TrackField(field, off);
  }

  template<typename T> void AddElement(voffset_t field, T e) {
    auto off = PushElement(e);
    TrackField(field, off);
  }

  template<typename T> void AddOffset(voffset_t field, Offset<T> off) {
    if (off.IsNull()) return;  // Don't store.
    AddElement(field, ReferTo(off.o), static_cast<uoffset_t>(0));
  }

  template<typename T> void AddStruct(voffset_t field, const T *structptr) {
    if (!structptr) return;  // Default, don't store.
    Align(AlignOf<T>());
    buf_.push_small(*structptr);
    TrackField(field, GetSize());
  }

  void AddStructOffset(voffset_t field, uoffset_t off) {
    TrackField(field, off);
  }

  // Offsets initially are relative to the end of the buffer (downwards).
  // This function converts them to be relative to the current location
  // in the buffer (when stored here), pointing upwards.
  uoffset_t ReferTo(uoffset_t off) {
    // Align to ensure GetSize() below is correct.
    Align(sizeof(uoffset_t));
    // Offset must refer to something already in buffer.
    FLATBUFFERS_ASSERT(off && off <= GetSize());
    return GetSize() - off + static_cast<uoffset_t>(sizeof(uoffset_t));
  }

  void NotNested() {
    // If you hit this, you're trying to construct a Table/Vector/String
    // during the construction of its parent table (between the MyTableBuilder
    // and table.Finish().
    // Move the creation of these sub-objects to above the MyTableBuilder to
    // not get this assert.
    // Ignoring this assert may appear to work in simple cases, but the reason
    // it is here is that storing objects in-line may cause vtable offsets
    // to not fit anymore. It also leads to vtable duplication.
    FLATBUFFERS_ASSERT(!nested);
    // If you hit this, fields were added outside the scope of a table.
    FLATBUFFERS_ASSERT(!num_field_loc);
  }

  // From generated code (or from the parser), we call StartTable/EndTable
  // with a sequence of AddElement calls in between.
  uoffset_t StartTable() {
    NotNested();
    nested = true;
    return GetSize();
  }

  // This finishes one serialized object by generating the vtable if it's a
  // table, comparing it against existing vtables, and writing the
  // resulting vtable offset.
  uoffset_t EndTable(uoffset_t start) {
    // If you get this assert, a corresponding StartTable wasn't called.
    FLATBUFFERS_ASSERT(nested);
    // Write the vtable offset, which is the start of any Table.
    // We fill it's value later.
    auto vtableoffsetloc = PushElement<soffset_t>(0);
    // Write a vtable, which consists entirely of voffset_t elements.
    // It starts with the number of offsets, followed by a type id, followed
    // by the offsets themselves. In reverse:
    // Include space for the last offset and ensure empty tables have a
    // minimum size.
    max_voffset_ =
        (std::max)(static_cast<voffset_t>(max_voffset_ + sizeof(voffset_t)),
                   FieldIndexToOffset(0));
    buf_.fill_big(max_voffset_);
    auto table_object_size = vtableoffsetloc - start;
    // Vtable use 16bit offsets.
    FLATBUFFERS_ASSERT(table_object_size < 0x10000);
    WriteScalar<voffset_t>(buf_.data() + sizeof(voffset_t),
                           static_cast<voffset_t>(table_object_size));
    WriteScalar<voffset_t>(buf_.data(), max_voffset_);
    // Write the offsets into the table
    for (auto it = buf_.scratch_end() - num_field_loc * sizeof(FieldLoc);
         it < buf_.scratch_end(); it += sizeof(FieldLoc)) {
      auto field_location = reinterpret_cast<FieldLoc *>(it);
      auto pos = static_cast<voffset_t>(vtableoffsetloc - field_location->off);
      // If this asserts, it means you've set a field twice.
      FLATBUFFERS_ASSERT(
          !ReadScalar<voffset_t>(buf_.data() + field_location->id));
      WriteScalar<voffset_t>(buf_.data() + field_location->id, pos);
    }
    ClearOffsets();
    auto vt1 = reinterpret_cast<voffset_t *>(buf_.data());
    auto vt1_size = ReadScalar<voffset_t>(vt1);
    auto vt_use = GetSize();
    // See if we already have generated a vtable with this exact same
    // layout before. If so, make it point to the old one, remove this one.
    if (dedup_vtables_) {
      for (auto it = buf_.scratch_data(); it < buf_.scratch_end();
           it += sizeof(uoffset_t)) {
        auto vt_offset_ptr = reinterpret_cast<uoffset_t *>(it);
        auto vt2 = reinterpret_cast<voffset_t *>(buf_.data_at(*vt_offset_ptr));
        auto vt2_size = ReadScalar<voffset_t>(vt2);
        if (vt1_size != vt2_size || 0 != memcmp(vt2, vt1, vt1_size)) continue;
        vt_use = *vt_offset_ptr;
        buf_.pop(GetSize() - vtableoffsetloc);
        break;
      }
    }
    // If this is a new vtable, remember it.
    if (vt_use == GetSize()) { buf_.scratch_push_small(vt_use); }
    // Fill the vtable offset we created above.
    // The offset points from the beginning of the object to where the
    // vtable is stored.
    // Offsets default direction is downward in memory for future format
    // flexibility (storing all vtables at the start of the file).
    WriteScalar(buf_.data_at(vtableoffsetloc),
                static_cast<soffset_t>(vt_use) -
                    static_cast<soffset_t>(vtableoffsetloc));

    nested = false;
    return vtableoffsetloc;
  }

  FLATBUFFERS_ATTRIBUTE(deprecated(""call the version above instead""))
  uoffset_t EndTable(uoffset_t start, voffset_t /*numfields*/) {
    return EndTable(start);
  }

  // This checks a required field has been set in a given table that has
  // just been constructed.
  template<typename T> void Required(Offset<T> table, voffset_t field);

  uoffset_t StartStruct(size_t alignment) {
    Align(alignment);
    return GetSize();
  }

  uoffset_t EndStruct() { return GetSize(); }

  void ClearOffsets() {
    buf_.scratch_pop(num_field_loc * sizeof(FieldLoc));
    num_field_loc = 0;
    max_voffset_ = 0;
  }

  // Aligns such that when ""len"" bytes are written, an object can be written
  // after it with ""alignment"" without padding.
  void PreAlign(size_t len, size_t alignment) {
    TrackMinAlign(alignment);
    buf_.fill(PaddingBytes(GetSize() + len, alignment));
  }
  template<typename T> void PreAlign(size_t len) {
    AssertScalarT<T>();
    PreAlign(len, sizeof(T));
  }
  /// @endcond

  /// @brief Store a string in the buffer, which can contain any binary data.
  /// @param[in] str A const char pointer to the data to be stored as a string.
  /// @param[in] len The number of bytes that should be stored from `str`.
  /// @return Returns the offset in the buffer where the string starts.
  Offset<String> CreateString(const char *str, size_t len) {
    NotNested();
    PreAlign<uoffset_t>(len + 1);  // Always 0-terminated.
    buf_.fill(1);
    PushBytes(reinterpret_cast<const uint8_t *>(str), len);
    PushElement(static_cast<uoffset_t>(len));
    return Offset<String>(GetSize());
  }

  /// @brief Store a string in the buffer, which is null-terminated.
  /// @param[in] str A const char pointer to a C-string to add to the buffer.
  /// @return Returns the offset in the buffer where the string starts.
  Offset<String> CreateString(const char *str) {
    return CreateString(str, strlen(str));
  }

  /// @brief Store a string in the buffer, which is null-terminated.
  /// @param[in] str A char pointer to a C-string to add to the buffer.
  /// @return Returns the offset in the buffer where the string starts.
  Offset<String> CreateString(char *str) {
    return CreateString(str, strlen(str));
  }

  /// @brief Store a string in the buffer, which can contain any binary data.
  /// @param[in] str A const reference to a std::string to store in the buffer.
  /// @return Returns the offset in the buffer where the string starts.
  Offset<String> CreateString(const std::string &str) {
    return CreateString(str.c_str(), str.length());
  }

  // clang-format off
  #ifdef FLATBUFFERS_HAS_STRING_VIEW
  /// @brief Store a string in the buffer, which can contain any binary data.
  /// @param[in] str A const string_view to copy in to the buffer.
  /// @return Returns the offset in the buffer where the string starts.
  Offset<String> CreateString(flatbuffers::string_view str) {
    return CreateString(str.data(), str.size());
  }
  #endif // FLATBUFFERS_HAS_STRING_VIEW
  // clang-format on

  /// @brief Store a string in the buffer, which can contain any binary data.
  /// @param[in] str A const pointer to a `String` struct to add to the buffer.
  /// @return Returns the offset in the buffer where the string starts
  Offset<String> CreateString(const String *str) {
    return str ? CreateString(str->c_str(), str->size()) : 0;
  }

  /// @brief Store a string in the buffer, which can contain any binary data.
  /// @param[in] str A const reference to a std::string like type with support
  /// of T::c_str() and T::length() to store in the buffer.
  /// @return Returns the offset in the buffer where the string starts.
  template<typename T> Offset<String> CreateString(const T &str) {
    return CreateString(str.c_str(), str.length());
  }

  /// @brief Store a string in the buffer, which can contain any binary data.
  /// If a string with this exact contents has already been serialized before,
  /// instead simply returns the offset of the existing string.
  /// @param[in] str A const char pointer to the data to be stored as a string.
  /// @param[in] len The number of bytes that should be stored from `str`.
  /// @return Returns the offset in the buffer where the string starts.
  Offset<String> CreateSharedString(const char *str, size_t len) {
    if (!string_pool)
      string_pool = new StringOffsetMap(StringOffsetCompare(buf_));
    auto size_before_string = buf_.size();
    // Must first serialize the string, since the set is all offsets into
    // buffer.
    auto off = CreateString(str, len);
    auto it = string_pool->find(off);
    // If it exists we reuse existing serialized data!
    if (it != string_pool->end()) {
      // We can remove the string we serialized.
      buf_.pop(buf_.size() - size_before_string);
      return *it;
    }
    // Record this string for future use.
    string_pool->insert(off);
    return off;
  }

#ifdef FLATBUFFERS_HAS_STRING_VIEW
  /// @brief Store a string in the buffer, which can contain any binary data.
  /// If a string with this exact contents has already been serialized before,
  /// instead simply returns the offset of the existing string.
  /// @param[in] str A const std::string_view to store in the buffer.
  /// @return Returns the offset in the buffer where the string starts
  Offset<String> CreateSharedString(const flatbuffers::string_view str) {
    return CreateSharedString(str.data(), str.size());
  }
#else
  /// @brief Store a string in the buffer, which null-terminated.
  /// If a string with this exact contents has already been serialized before,
  /// instead simply returns the offset of the existing string.
  /// @param[in] str A const char pointer to a C-string to add to the buffer.
  /// @return Returns the offset in the buffer where the string starts.
  Offset<String> CreateSharedString(const char *str) {
    return CreateSharedString(str, strlen(str));
  }

  /// @brief Store a string in the buffer, which can contain any binary data.
  /// If a string with this exact contents has already been serialized before,
  /// instead simply returns the offset of the existing string.
  /// @param[in] str A const reference to a std::string to store in the buffer.
  /// @return Returns the offset in the buffer where the string starts.
  Offset<String> CreateSharedString(const std::string &str) {
    return CreateSharedString(str.c_str(), str.length());
  }
#endif

  /// @brief Store a string in the buffer, which can contain any binary data.
  /// If a string with this exact contents has already been serialized before,
  /// instead simply returns the offset of the existing string.
  /// @param[in] str A const pointer to a `String` struct to add to the buffer.
  /// @return Returns the offset in the buffer where the string starts
  Offset<String> CreateSharedString(const String *str) {
    return CreateSharedString(str->c_str(), str->size());
  }

  /// @cond FLATBUFFERS_INTERNAL
  uoffset_t EndVector(size_t len) {
    FLATBUFFERS_ASSERT(nested);  // Hit if no corresponding StartVector.
    nested = false;
    return PushElement(static_cast<uoffset_t>(len));
  }

  void StartVector(size_t len, size_t elemsize) {
    NotNested();
    nested = true;
    PreAlign<uoffset_t>(len * elemsize);
    PreAlign(len * elemsize, elemsize);  // Just in case elemsize > uoffset_t.
  }

  // Call this right before StartVector/CreateVector if you want to force the
  // alignment to be something different than what the element size would
  // normally dictate.
  // This is useful when storing a nested_flatbuffer in a vector of bytes,
  // or when storing SIMD floats, etc.
  void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {
    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));
    PreAlign(len * elemsize, alignment);
  }

  // Similar to ForceVectorAlignment but for String fields.
  void ForceStringAlignment(size_t len, size_t alignment) {
    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));
    PreAlign((len + 1) * sizeof(char), alignment);
  }

  /// @endcond

  /// @brief Serialize an array into a FlatBuffer `vector`.
  /// @tparam T The data type of the array elements.
  /// @param[in] v A pointer to the array of type `T` to serialize into the
  /// buffer as a `vector`.
  /// @param[in] len The number of elements to serialize.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T> Offset<Vector<T>> CreateVector(const T *v, size_t len) {
    // If this assert hits, you're specifying a template argument that is
    // causing the wrong overload to be selected, remove it.
    AssertScalarT<T>();
    StartVector(len, sizeof(T));
    if (len == 0) { return Offset<Vector<T>>(EndVector(len)); }
    // clang-format off
    #if FLATBUFFERS_LITTLEENDIAN
      PushBytes(reinterpret_cast<const uint8_t *>(v), len * sizeof(T));
    #else
      if (sizeof(T) == 1) {
        PushBytes(reinterpret_cast<const uint8_t *>(v), len);
      } else {
        for (auto i = len; i > 0; ) {
          PushElement(v[--i]);
        }
      }
    #endif
    // clang-format on
    return Offset<Vector<T>>(EndVector(len));
  }

  template<typename T>
  Offset<Vector<Offset<T>>> CreateVector(const Offset<T> *v, size_t len) {
    StartVector(len, sizeof(Offset<T>));
    for (auto i = len; i > 0;) { PushElement(v[--i]); }
    return Offset<Vector<Offset<T>>>(EndVector(len));
  }

  /// @brief Serialize a `std::vector` into a FlatBuffer `vector`.
  /// @tparam T The data type of the `std::vector` elements.
  /// @param v A const reference to the `std::vector` to serialize into the
  /// buffer as a `vector`.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T> Offset<Vector<T>> CreateVector(const std::vector<T> &v) {
    return CreateVector(data(v), v.size());
  }

  // vector<bool> may be implemented using a bit-set, so we can't access it as
  // an array. Instead, read elements manually.
  // Background: https://isocpp.org/blog/2012/11/on-vectorbool
  Offset<Vector<uint8_t>> CreateVector(const std::vector<bool> &v) {
    StartVector(v.size(), sizeof(uint8_t));
    for (auto i = v.size(); i > 0;) {
      PushElement(static_cast<uint8_t>(v[--i]));
    }
    return Offset<Vector<uint8_t>>(EndVector(v.size()));
  }

  // clang-format off
  #ifndef FLATBUFFERS_CPP98_STL
  /// @brief Serialize values returned by a function into a FlatBuffer `vector`.
  /// This is a convenience function that takes care of iteration for you.
  /// @tparam T The data type of the `std::vector` elements.
  /// @param f A function that takes the current iteration 0..vector_size-1 and
  /// returns any type that you can construct a FlatBuffers vector out of.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T> Offset<Vector<T>> CreateVector(size_t vector_size,
      const std::function<T (size_t i)> &f) {
    std::vector<T> elems(vector_size);
    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i);
    return CreateVector(elems);
  }
  #endif
  // clang-format on

  /// @brief Serialize values returned by a function into a FlatBuffer `vector`.
  /// This is a convenience function that takes care of iteration for you.
  /// @tparam T The data type of the `std::vector` elements.
  /// @param f A function that takes the current iteration 0..vector_size-1,
  /// and the state parameter returning any type that you can construct a
  /// FlatBuffers vector out of.
  /// @param state State passed to f.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T, typename F, typename S>
  Offset<Vector<T>> CreateVector(size_t vector_size, F f, S *state) {
    std::vector<T> elems(vector_size);
    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i, state);
    return CreateVector(elems);
  }

  /// @brief Serialize a `std::vector<std::string>` into a FlatBuffer `vector`.
  /// This is a convenience function for a common case.
  /// @param v A const reference to the `std::vector` to serialize into the
  /// buffer as a `vector`.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  Offset<Vector<Offset<String>>> CreateVectorOfStrings(
      const std::vector<std::string> &v) {
    std::vector<Offset<String>> offsets(v.size());
    for (size_t i = 0; i < v.size(); i++) offsets[i] = CreateString(v[i]);
    return CreateVector(offsets);
  }

  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
  /// @tparam T The data type of the struct array elements.
  /// @param[in] v A pointer to the array of type `T` to serialize into the
  /// buffer as a `vector`.
  /// @param[in] len The number of elements to serialize.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T>
  Offset<Vector<const T *>> CreateVectorOfStructs(const T *v, size_t len) {
    StartVector(len * sizeof(T) / AlignOf<T>(), AlignOf<T>());
    PushBytes(reinterpret_cast<const uint8_t *>(v), sizeof(T) * len);
    return Offset<Vector<const T *>>(EndVector(len));
  }

  /// @brief Serialize an array of native structs into a FlatBuffer `vector`.
  /// @tparam T The data type of the struct array elements.
  /// @tparam S The data type of the native struct array elements.
  /// @param[in] v A pointer to the array of type `S` to serialize into the
  /// buffer as a `vector`.
  /// @param[in] len The number of elements to serialize.
  /// @param[in] pack_func Pointer to a function to convert the native struct
  /// to the FlatBuffer struct.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
      const S *v, size_t len, T((*const pack_func)(const S &))) {
    FLATBUFFERS_ASSERT(pack_func);
    std::vector<T> vv(len);
    std::transform(v, v + len, vv.begin(), pack_func);
    return CreateVectorOfStructs<T>(data(vv), vv.size());
  }

  /// @brief Serialize an array of native structs into a FlatBuffer `vector`.
  /// @tparam T The data type of the struct array elements.
  /// @tparam S The data type of the native struct array elements.
  /// @param[in] v A pointer to the array of type `S` to serialize into the
  /// buffer as a `vector`.
  /// @param[in] len The number of elements to serialize.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfNativeStructs(const S *v,
                                                        size_t len) {
    extern T Pack(const S &);
    return CreateVectorOfNativeStructs(v, len, Pack);
  }

  // clang-format off
  #ifndef FLATBUFFERS_CPP98_STL
  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
  /// @tparam T The data type of the struct array elements.
  /// @param[in] filler A function that takes the current iteration 0..vector_size-1
  /// and a pointer to the struct that must be filled.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  /// This is mostly useful when flatbuffers are generated with mutation
  /// accessors.
  template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(
      size_t vector_size, const std::function<void(size_t i, T *)> &filler) {
    T* structs = StartVectorOfStructs<T>(vector_size);
    for (size_t i = 0; i < vector_size; i++) {
      filler(i, structs);
      structs++;
    }
    return EndVectorOfStructs<T>(vector_size);
  }
  #endif
  // clang-format on

  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
  /// @tparam T The data type of the struct array elements.
  /// @param[in] f A function that takes the current iteration 0..vector_size-1,
  /// a pointer to the struct that must be filled and the state argument.
  /// @param[in] state Arbitrary state to pass to f.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  /// This is mostly useful when flatbuffers are generated with mutation
  /// accessors.
  template<typename T, typename F, typename S>
  Offset<Vector<const T *>> CreateVectorOfStructs(size_t vector_size, F f,
                                                  S *state) {
    T *structs = StartVectorOfStructs<T>(vector_size);
    for (size_t i = 0; i < vector_size; i++) {
      f(i, structs, state);
      structs++;
    }
    return EndVectorOfStructs<T>(vector_size);
  }

  /// @brief Serialize a `std::vector` of structs into a FlatBuffer `vector`.
  /// @tparam T The data type of the `std::vector` struct elements.
  /// @param[in] v A const reference to the `std::vector` of structs to
  /// serialize into the buffer as a `vector`.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T, typename Alloc>
  Offset<Vector<const T *>> CreateVectorOfStructs(
      const std::vector<T, Alloc> &v) {
    return CreateVectorOfStructs(data(v), v.size());
  }

  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
  /// `vector`.
  /// @tparam T The data type of the `std::vector` struct elements.
  /// @tparam S The data type of the `std::vector` native struct elements.
  /// @param[in] v A const reference to the `std::vector` of structs to
  /// serialize into the buffer as a `vector`.
  /// @param[in] pack_func Pointer to a function to convert the native struct
  /// to the FlatBuffer struct.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
      const std::vector<S> &v, T((*const pack_func)(const S &))) {
    return CreateVectorOfNativeStructs<T, S>(data(v), v.size(), pack_func);
  }

  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
  /// `vector`.
  /// @tparam T The data type of the `std::vector` struct elements.
  /// @tparam S The data type of the `std::vector` native struct elements.
  /// @param[in] v A const reference to the `std::vector` of structs to
  /// serialize into the buffer as a `vector`.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
      const std::vector<S> &v) {
    return CreateVectorOfNativeStructs<T, S>(data(v), v.size());
  }

  /// @cond FLATBUFFERS_INTERNAL
  template<typename T> struct StructKeyComparator {
    bool operator()(const T &a, const T &b) const {
      return a.KeyCompareLessThan(&b);
    }

    FLATBUFFERS_DELETE_FUNC(
        StructKeyComparator &operator=(const StructKeyComparator &));
  };
  /// @endcond

  /// @brief Serialize a `std::vector` of structs into a FlatBuffer `vector`
  /// in sorted order.
  /// @tparam T The data type of the `std::vector` struct elements.
  /// @param[in] v A const reference to the `std::vector` of structs to
  /// serialize into the buffer as a `vector`.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T>
  Offset<Vector<const T *>> CreateVectorOfSortedStructs(std::vector<T> *v) {
    return CreateVectorOfSortedStructs(data(*v), v->size());
  }

  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
  /// `vector` in sorted order.
  /// @tparam T The data type of the `std::vector` struct elements.
  /// @tparam S The data type of the `std::vector` native struct elements.
  /// @param[in] v A const reference to the `std::vector` of structs to
  /// serialize into the buffer as a `vector`.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfSortedNativeStructs(
      std::vector<S> *v) {
    return CreateVectorOfSortedNativeStructs<T, S>(data(*v), v->size());
  }

  /// @brief Serialize an array of structs into a FlatBuffer `vector` in sorted
  /// order.
  /// @tparam T The data type of the struct array elements.
  /// @param[in] v A pointer to the array of type `T` to serialize into the
  /// buffer as a `vector`.
  /// @param[in] len The number of elements to serialize.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T>
  Offset<Vector<const T *>> CreateVectorOfSortedStructs(T *v, size_t len) {
    std::sort(v, v + len, StructKeyComparator<T>());
    return CreateVectorOfStructs(v, len);
  }

  /// @brief Serialize an array of native structs into a FlatBuffer `vector` in
  /// sorted order.
  /// @tparam T The data type of the struct array elements.
  /// @tparam S The data type of the native struct array elements.
  /// @param[in] v A pointer to the array of type `S` to serialize into the
  /// buffer as a `vector`.
  /// @param[in] len The number of elements to serialize.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfSortedNativeStructs(S *v,
                                                              size_t len) {
    extern T Pack(const S &);
    typedef T (*Pack_t)(const S &);
    std::vector<T> vv(len);
    std::transform(v, v + len, vv.begin(), static_cast<Pack_t &>(Pack));
    return CreateVectorOfSortedStructs<T>(vv, len);
  }

  /// @cond FLATBUFFERS_INTERNAL
  template<typename T> struct TableKeyComparator {
    TableKeyComparator(vector_downward &buf) : buf_(buf) {}
    TableKeyComparator(const TableKeyComparator &other) : buf_(other.buf_) {}
    bool operator()(const Offset<T> &a, const Offset<T> &b) const {
      auto table_a = reinterpret_cast<T *>(buf_.data_at(a.o));
      auto table_b = reinterpret_cast<T *>(buf_.data_at(b.o));
      return table_a->KeyCompareLessThan(table_b);
    }
    vector_downward &buf_;

   private:
    FLATBUFFERS_DELETE_FUNC(
        TableKeyComparator &operator=(const TableKeyComparator &other));
  };
  /// @endcond

  /// @brief Serialize an array of `table` offsets as a `vector` in the buffer
  /// in sorted order.
  /// @tparam T The data type that the offset refers to.
  /// @param[in] v An array of type `Offset<T>` that contains the `table`
  /// offsets to store in the buffer in sorted order.
  /// @param[in] len The number of elements to store in the `vector`.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T>
  Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(Offset<T> *v,
                                                       size_t len) {
    std::sort(v, v + len, TableKeyComparator<T>(buf_));
    return CreateVector(v, len);
  }

  /// @brief Serialize an array of `table` offsets as a `vector` in the buffer
  /// in sorted order.
  /// @tparam T The data type that the offset refers to.
  /// @param[in] v An array of type `Offset<T>` that contains the `table`
  /// offsets to store in the buffer in sorted order.
  /// @return Returns a typed `Offset` into the serialized data indicating
  /// where the vector is stored.
  template<typename T>
  Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(
      std::vector<Offset<T>> *v) {
    return CreateVectorOfSortedTables(data(*v), v->size());
  }

  /// @brief Specialized version of `CreateVector` for non-copying use cases.
  /// Write the data any time later to the returned buffer pointer `buf`.
  /// @param[in] len The number of elements to store in the `vector`.
  /// @param[in] elemsize The size of each element in the `vector`.
  /// @param[out] buf A pointer to a `uint8_t` pointer that can be
  /// written to at a later time to serialize the data into a `vector`
  /// in the buffer.
  uoffset_t CreateUninitializedVector(size_t len, size_t elemsize,
                                      uint8_t **buf) {
    NotNested();
    StartVector(len, elemsize);
    buf_.make_space(len * elemsize);
    auto vec_start = GetSize();
    auto vec_end = EndVector(len);
    *buf = buf_.data_at(vec_start);
    return vec_end;
  }

  /// @brief Specialized version of `CreateVector` for non-copying use cases.
  /// Write the data any time later to the returned buffer pointer `buf`.
  /// @tparam T The data type of the data that will be stored in the buffer
  /// as a `vector`.
  /// @param[in] len The number of elements to store in the `vector`.
  /// @param[out] buf A pointer to a pointer of type `T` that can be
  /// written to at a later time to serialize the data into a `vector`
  /// in the buffer.
  template<typename T>
  Offset<Vector<T>> CreateUninitializedVector(size_t len, T **buf) {
    AssertScalarT<T>();
    return CreateUninitializedVector(len, sizeof(T),
                                     reinterpret_cast<uint8_t **>(buf));
  }

  template<typename T>
  Offset<Vector<const T *>> CreateUninitializedVectorOfStructs(size_t len,
                                                               T **buf) {
    return CreateUninitializedVector(len, sizeof(T),
                                     reinterpret_cast<uint8_t **>(buf));
  }

  // @brief Create a vector of scalar type T given as input a vector of scalar
  // type U, useful with e.g. pre ""enum class"" enums, or any existing scalar
  // data of the wrong type.
  template<typename T, typename U>
  Offset<Vector<T>> CreateVectorScalarCast(const U *v, size_t len) {
    AssertScalarT<T>();
    AssertScalarT<U>();
    StartVector(len, sizeof(T));
    for (auto i = len; i > 0;) { PushElement(static_cast<T>(v[--i])); }
    return Offset<Vector<T>>(EndVector(len));
  }

  /// @brief Write a struct by itself, typically to be part of a union.
  template<typename T> Offset<const T *> CreateStruct(const T &structobj) {
    NotNested();
    Align(AlignOf<T>());
    buf_.push_small(structobj);
    return Offset<const T *>(GetSize());
  }

  /// @brief The length of a FlatBuffer file header.
  static const size_t kFileIdentifierLength = 4;

  /// @brief Finish serializing a buffer by writing the root offset.
  /// @param[in] file_identifier If a `file_identifier` is given, the buffer
  /// will be prefixed with a standard FlatBuffers file header.
  template<typename T>
  void Finish(Offset<T> root, const char *file_identifier = nullptr) {
    Finish(root.o, file_identifier, false);
  }

  /// @brief Finish a buffer with a 32 bit size field pre-fixed (size of the
  /// buffer following the size field). These buffers are NOT compatible
  /// with standard buffers created by Finish, i.e. you can't call GetRoot
  /// on them, you have to use GetSizePrefixedRoot instead.
  /// All >32 bit quantities in this buffer will be aligned when the whole
  /// size pre-fixed buffer is aligned.
  /// These kinds of buffers are useful for creating a stream of FlatBuffers.
  template<typename T>
  void FinishSizePrefixed(Offset<T> root,
                          const char *file_identifier = nullptr) {
    Finish(root.o, file_identifier, true);
  }

  void SwapBufAllocator(FlatBufferBuilder &other) {
    buf_.swap_allocator(other.buf_);
  }

 protected:
  // You shouldn't really be copying instances of this class.
  FlatBufferBuilder(const FlatBufferBuilder &);
  FlatBufferBuilder &operator=(const FlatBufferBuilder &);

  void Finish(uoffset_t root, const char *file_identifier, bool size_prefix) {
    NotNested();
    buf_.clear_scratch();
    // This will cause the whole buffer to be aligned.
    PreAlign((size_prefix ? sizeof(uoffset_t) : 0) + sizeof(uoffset_t) +
                 (file_identifier ? kFileIdentifierLength : 0),
             minalign_);
    if (file_identifier) {
      FLATBUFFERS_ASSERT(strlen(file_identifier) == kFileIdentifierLength);
      PushBytes(reinterpret_cast<const uint8_t *>(file_identifier),
                kFileIdentifierLength);
    }
    PushElement(ReferTo(root));  // Location of root.
    if (size_prefix) { PushElement(GetSize()); }
    finished = true;
  }

  struct FieldLoc {
    uoffset_t off;
    voffset_t id;
  };

  vector_downward buf_;

  // Accumulating offsets of table members while it is being built.
  // We store these in the scratch pad of buf_, after the vtable offsets.
  uoffset_t num_field_loc;
  // Track how much of the vtable is in use, so we can output the most compact
  // possible vtable.
  voffset_t max_voffset_;

  // Ensure objects are not nested.
  bool nested;

  // Ensure the buffer is finished before it is being accessed.
  bool finished;

  size_t minalign_;

  bool force_defaults_;  // Serialize values equal to their defaults anyway.

  bool dedup_vtables_;

  struct StringOffsetCompare {
    StringOffsetCompare(const vector_downward &buf) : buf_(&buf) {}
    bool operator()(const Offset<String> &a, const Offset<String> &b) const {
      auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));
      auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));
      return StringLessThan(stra->data(), stra->size(), strb->data(),
                            strb->size());
    }
    const vector_downward *buf_;
  };

  // For use with CreateSharedString. Instantiated on first use only.
  typedef std::set<Offset<String>, StringOffsetCompare> StringOffsetMap;
  StringOffsetMap *string_pool;

 private:
  // Allocates space for a vector of structures.
  // Must be completed with EndVectorOfStructs().
  template<typename T> T *StartVectorOfStructs(size_t vector_size) {
    StartVector(vector_size * sizeof(T) / AlignOf<T>(), AlignOf<T>());
    return reinterpret_cast<T *>(buf_.make_space(vector_size * sizeof(T)));
  }

  // End the vector of structures in the flatbuffers.
  // Vector should have previously be started with StartVectorOfStructs().
  template<typename T>
  Offset<Vector<const T *>> EndVectorOfStructs(size_t vector_size) {
    return Offset<Vector<const T *>>(EndVector(vector_size));
  }
};",1,587 2000 123 777 58 331 331 331 331 331 331 331 331 331 331 331 648 2000 40 2001 2002 61 1505 44 2003 42 2004 61 753 44 569 2005 61 655 44 2001 2006 61 2007 60 2008 62 40 41 41 58 2009 40 2002 44 2004 44 2005 44 2006 41 44 2010 40 1500 41 44 2011 40 1500 41 44 2012 40 655 41 44 2013 40 655 41 44 2014 40 1501 41 44 2015 40 655 41 44 2016 40 829 41 44 2017 40 753 41 123 2018 40 41 59 125 330 331 35 688 33 2019 40 2020 41 2000 40 2000 307 2021 41 35 630 2000 40 2000 38 2021 41 35 636 330 58 2009 40 1505 44 753 44 655 44 2007 60 2008 62 40 41 41 44 2010 40 1500 41 44 2011 40 1500 41 44 2012 40 655 41 44 2013 40 655 41 44 2014 40 1501 41 44 2015 40 655 41 44 2016 40 829 41 44 2017 40 753 41 123 2022 40 41 59 330 330 2023 40 2021 41 59 125 330 330 35 688 33 2019 40 2020 41 330 331 2000 38 758 61 40 2000 307 2021 41 123 330 2000 2024 40 2025 321 2026 40 2021 41 41 59 2027 40 2024 41 59 792 42 823 59 125 330 35 636 330 330 865 2028 40 2000 38 2021 41 123 860 2029 321 2030 59 2009 46 2030 40 2021 46 2009 41 59 2030 40 2010 44 2021 46 2010 41 59 2030 40 2011 44 2021 46 2011 41 59 2030 40 2012 44 2021 46 2012 41 59 2030 40 2013 44 2021 46 2013 41 59 2030 40 2014 44 2021 46 2014 41 59 2030 40 2015 44 2021 46 2015 41 59 2030 40 2016 44 2021 46 2016 41 59 2030 40 2017 44 2021 46 2017 41 59 125 126 2000 40 41 123 688 40 2017 41 619 2017 59 125 865 2031 40 41 123 2032 40 41 59 330 2009 46 2033 40 41 59 330 125 331 331 865 2034 40 41 123 2035 40 41 59 2009 46 2036 40 41 59 2012 61 655 59 2013 61 655 59 2014 61 1501 59 688 40 2017 41 2017 354 2036 40 41 59 125 331 331 2037 2038 40 41 601 123 792 2009 46 2039 40 41 59 125 331 331 331 2040 42 2041 40 41 601 123 2042 40 41 59 792 2009 46 2043 40 41 59 125 331 331 331 2044 321 2045 60 2040 62 2046 40 41 601 123 2047 40 41 59 792 2044 321 2045 60 2040 62 40 2009 46 2048 40 41 44 2009 46 2049 40 41 41 59 125 331 331 2040 42 2050 40 41 601 123 792 2009 46 2051 40 41 59 125 331 331 331 331 2052 40 2053 40 362 41 41 2054 2055 40 41 123 2056 40 41 59 792 2009 46 2057 40 41 59 125 331 331 2054 2058 40 41 123 2059 40 41 59 792 2009 46 2060 40 41 59 125 331 331 331 331 331 331 331 331 331 2040 42 2061 40 2001 38 2062 44 2001 38 2063 41 123 2064 40 41 59 792 2009 46 2065 40 2062 44 2063 41 59 125 331 331 331 331 331 2001 2066 40 41 601 123 2067 40 41 59 792 2014 59 125 331 865 2068 40 41 601 123 330 330 330 330 330 2069 40 2013 41 59 125 331 331 331 331 331 331 865 2070 40 569 2071 41 123 2015 61 2071 59 125 331 331 865 2072 40 569 2073 41 123 2016 61 2073 59 125 331 865 2074 40 2001 2075 41 123 2009 46 2076 40 2075 41 59 125 865 2077 40 2001 2078 41 123 688 40 2078 62 2014 41 2014 61 2078 59 125 865 2079 40 2001 2078 41 123 2077 40 2078 41 59 2009 46 2080 40 2081 40 2009 46 2062 40 41 44 2078 41 41 59 125 865 2082 40 601 2040 42 2083 44 2001 2062 41 123 2084 40 2083 44 2062 41 59 2013 61 829 59 125 865 2085 40 601 2040 42 2083 44 2001 2062 41 123 2009 46 2086 40 2083 44 2062 41 59 125 865 2087 40 2001 2088 41 123 2009 46 2089 40 2088 41 59 125 822 60 835 2090 62 865 2091 40 41 123 330 810 40 2044 321 2092 60 2090 62 321 2093 44 362 41 59 125 330 822 60 835 2090 62 2037 2094 40 2090 2095 41 123 2091 60 2090 62 40 41 59 2090 2096 61 2097 40 2095 41 59 2079 40 805 40 2090 41 41 59 2009 46 2098 40 2096 41 59 792 2038 40 41 59 125 822 60 835 2090 62 2037 2094 40 2099 60 2090 62 2100 41 123 330 792 2094 40 2101 40 2100 46 2102 41 41 59 125 330 330 865 2103 40 2104 2105 44 2037 2100 41 123 2106 2107 61 123 2100 44 2105 125 59 2009 46 2108 40 2107 41 59 2010 349 59 2011 61 40 2109 321 2110 41 40 2011 44 2105 41 59 125 330 822 60 835 2090 62 865 2111 40 2104 2105 44 2090 2112 44 2090 2113 41 123 330 688 40 2114 40 2112 44 2113 41 307 33 2015 41 792 59 561 2100 61 2094 40 2112 41 59 2103 40 2105 44 2100 41 59 125 822 60 835 2090 62 865 2111 40 2104 2105 44 2090 2112 41 123 561 2100 61 2094 40 2112 41 59 2103 40 2105 44 2100 41 59 125 822 60 835 2090 62 865 2115 40 2104 2105 44 2099 60 2090 62 2100 41 123 688 40 2100 46 2116 40 41 41 792 59 330 2111 40 2105 44 2117 40 2100 46 2118 41 44 811 60 2037 62 40 1500 41 41 59 125 822 60 835 2090 62 865 2119 40 2104 2105 44 601 2090 42 2120 41 123 688 40 33 2120 41 792 59 330 2079 40 2007 60 2090 62 40 41 41 59 2009 46 2121 40 42 2120 41 59 2103 40 2105 44 2038 40 41 41 59 125 865 2122 40 2104 2105 44 2037 2100 41 123 2103 40 2105 44 2100 41 59 125 330 330 330 2037 2123 40 2037 2100 41 123 330 2079 40 805 40 2037 41 41 59 330 2124 40 2100 307 2100 329 2038 40 41 41 59 792 2038 40 41 45 2100 43 811 60 2037 62 40 805 40 2037 41 41 59 125 865 2125 40 41 123 330 330 330 330 330 330 330 330 2126 40 33 2012 41 59 330 2126 40 33 2010 41 59 125 330 330 2037 2127 40 41 123 2125 40 41 59 2012 61 829 59 792 2038 40 41 59 125 330 330 330 2037 2128 40 2037 2129 41 123 330 2130 40 2012 41 59 330 330 561 2131 61 2094 60 2132 62 40 1500 41 59 330 330 330 330 330 2011 61 40 2133 321 2134 41 40 811 60 2104 62 40 2011 43 805 40 2104 41 41 44 2135 40 1500 41 41 59 2009 46 2136 40 2011 41 59 561 2137 61 2131 45 2129 59 330 2130 40 2137 60 1506 41 59 2138 60 2104 62 40 2009 46 2139 40 41 43 805 40 2104 41 44 811 60 2104 62 40 2137 41 41 59 2138 60 2104 62 40 2009 46 2139 40 41 44 2011 41 59 330 664 40 561 2140 61 2009 46 2141 40 41 45 2010 42 805 40 2142 41 59 2140 60 2009 46 2141 40 41 59 2140 348 805 40 2142 41 41 123 561 2143 61 786 60 2142 42 62 40 2140 41 59 561 2144 61 811 60 2104 62 40 2131 45 2143 354 2100 41 59 330 2130 40 33 2145 60 2104 62 40 2009 46 2139 40 41 43 2143 354 2146 41 41 59 2138 60 2104 62 40 2009 46 2139 40 41 43 2143 354 2146 44 2144 41 59 125 2147 40 41 59 561 2148 61 786 60 2104 42 62 40 2009 46 2139 40 41 41 59 561 2149 61 2150 60 2104 62 40 2148 41 59 561 2151 61 2038 40 41 59 330 330 688 40 2016 41 123 664 40 561 2140 61 2009 46 2152 40 41 59 2140 60 2009 46 2141 40 41 59 2140 348 805 40 2037 41 41 123 561 2153 61 786 60 2037 42 62 40 2140 41 59 561 2154 61 786 60 2104 42 62 40 2009 46 2155 40 42 2153 41 41 59 561 2156 61 2150 60 2104 62 40 2154 41 59 688 40 2149 340 2156 309 1500 340 2157 40 2154 44 2148 44 2149 41 41 605 59 2151 61 42 2153 59 2009 46 2158 40 2038 40 41 45 2131 41 59 572 59 125 125 330 688 40 2151 323 2038 40 41 41 123 2009 46 2159 40 2151 41 59 125 330 330 330 330 330 2138 40 2009 46 2160 40 2131 41 44 811 60 2132 62 40 2151 41 45 811 60 2132 62 40 2131 41 41 59 2012 61 655 59 792 2131 59 125 2052 40 2053 40 362 41 41 2037 2128 40 2037 2129 44 2104 305 41 123 792 2128 40 2129 41 59 125 330 330 822 60 835 2090 62 865 2161 40 2099 60 2090 62 2162 44 2104 2105 41 59 2037 2163 40 2001 2164 41 123 2079 40 2164 41 59 792 2038 40 41 59 125 2037 2165 40 41 123 792 2038 40 41 59 125 865 2166 40 41 123 2009 46 2167 40 2010 42 805 40 2168 41 41 59 2010 61 1500 59 2011 61 1500 59 125 330 330 865 2169 40 2001 2170 44 2001 2164 41 123 2077 40 2164 41 59 2009 46 2171 40 2172 40 2038 40 41 43 2170 44 2164 41 41 59 125 822 60 835 2090 62 865 2169 40 2001 2170 41 123 2091 60 2090 62 40 41 59 2169 40 2170 44 805 40 2090 41 41 59 125 331 331 331 331 331 2099 60 2173 62 2174 40 601 582 42 2175 44 2001 2170 41 123 2125 40 41 59 2169 60 2037 62 40 2170 43 1501 41 59 330 2009 46 2176 40 1501 41 59 2085 40 786 60 601 2040 42 62 40 2175 41 44 2170 41 59 2094 40 811 60 2037 62 40 2170 41 41 59 792 2099 60 2173 62 40 2038 40 41 41 59 125 331 331 331 2099 60 2173 62 2174 40 601 582 42 2175 41 123 792 2174 40 2175 44 2177 40 2175 41 41 59 125 331 331 331 2099 60 2173 62 2174 40 582 42 2175 41 123 792 2174 40 2175 44 2178 40 2175 41 41 59 125 331 331 331 2099 60 2173 62 2174 40 601 2179 321 2180 38 2175 41 123 792 2174 40 2175 46 2181 40 41 44 2175 46 2182 40 41 41 59 125 330 35 689 2183 331 331 331 2099 60 2173 62 2174 40 2044 321 2184 2175 41 123 792 2174 40 2175 46 2185 40 41 44 2175 46 2062 40 41 41 59 125 35 636 330 330 331 331 331 2099 60 2173 62 2174 40 601 2173 42 2175 41 123 792 2175 63 2174 40 2175 354 2186 40 41 44 2175 354 2062 40 41 41 58 1500 59 125 331 331 331 331 822 60 835 2090 62 2099 60 2173 62 2174 40 601 2090 38 2175 41 123 792 2174 40 2175 46 2187 40 41 44 2175 46 2188 40 41 41 59 125 331 331 331 331 331 331 2099 60 2173 62 2189 40 601 582 42 2175 44 2001 2170 41 123 688 40 33 2017 41 2017 61 744 2190 40 2191 40 2009 41 41 59 561 2192 61 2009 46 2062 40 41 59 330 330 561 2100 61 2174 40 2175 44 2170 41 59 561 2193 61 2017 354 2194 40 2100 41 59 330 688 40 2193 340 2017 354 2195 40 41 41 123 330 2009 46 2196 40 2009 46 2062 40 41 45 2192 41 59 792 42 2193 59 125 330 2017 354 2197 40 2100 41 59 792 2100 59 125 35 689 2183 331 331 331 331 331 2099 60 2173 62 2189 40 601 2044 321 2184 2175 41 123 792 2189 40 2175 46 2198 40 41 44 2175 46 2062 40 41 41 59 125 35 630 331 331 331 331 331 2099 60 2173 62 2189 40 601 582 42 2175 41 123 792 2189 40 2175 44 2199 40 2175 41 41 59 125 331 331 331 331 331 2099 60 2173 62 2189 40 601 2179 321 2180 38 2175 41 123 792 2189 40 2175 46 2200 40 41 44 2175 46 2201 40 41 41 59 125 35 636 331 331 331 331 331 2099 60 2173 62 2189 40 601 2173 42 2175 41 123 792 2189 40 2175 354 2202 40 41 44 2175 354 2062 40 41 41 59 125 331 2037 2203 40 2001 2170 41 123 2204 40 2012 41 59 330 2012 61 655 59 792 2094 40 811 60 2037 62 40 2170 41 41 59 125 865 2205 40 2001 2170 44 2001 2206 41 123 2125 40 41 59 2012 61 829 59 2169 60 2037 62 40 2170 42 2206 41 59 2169 40 2170 42 2206 44 2206 41 59 330 125 330 330 330 330 330 865 2207 40 2001 2170 44 2001 2206 44 2001 2164 41 123 2208 40 2209 40 2164 41 41 59 2169 40 2170 42 2206 44 2164 41 59 125 330 865 2210 40 2001 2170 44 2001 2164 41 123 2211 40 2212 40 2164 41 41 59 2169 40 40 2170 43 1501 41 42 805 40 582 41 44 2164 41 59 125 331 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 2090 355 2214 40 601 2090 42 2215 44 2001 2170 41 123 330 330 2091 60 2090 62 40 41 59 2205 40 2170 44 805 40 2090 41 41 59 688 40 2170 323 1500 41 123 792 2099 60 2213 60 2090 355 40 2203 40 2170 41 41 59 125 330 35 688 2216 2085 40 786 60 601 2040 42 62 40 2215 41 44 2170 42 805 40 2090 41 41 59 35 630 688 40 805 40 2090 41 323 1501 41 123 2085 40 786 60 601 2040 42 62 40 2215 41 44 2170 41 59 125 630 123 664 40 561 2217 61 2170 59 2217 62 1500 59 41 123 2094 40 2215 91 338 2217 93 41 59 125 125 35 636 330 792 2099 60 2213 60 2090 355 40 2203 40 2170 41 41 59 125 822 60 835 2090 62 2099 60 2213 60 2099 60 2090 355 62 2214 40 601 2099 60 2090 62 42 2215 44 2001 2170 41 123 2205 40 2170 44 805 40 2099 60 2090 62 41 41 59 664 40 561 2218 61 2170 59 2218 62 1500 59 41 123 2094 40 2215 91 338 2218 93 41 59 125 792 2099 60 2213 60 2099 60 2090 355 62 40 2203 40 2170 41 41 59 125 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 2090 355 2214 40 601 2179 321 2219 60 2090 62 38 2215 41 123 792 2214 40 2220 40 2215 41 44 2215 46 2062 40 41 41 59 125 330 330 330 2099 60 2213 60 2040 355 2214 40 601 2179 321 2219 60 569 62 38 2215 41 123 2205 40 2215 46 2062 40 41 44 805 40 2040 41 41 59 664 40 561 2221 61 2215 46 2062 40 41 59 2221 62 1500 59 41 123 2094 40 811 60 2040 62 40 2215 91 338 2221 93 41 41 59 125 792 2099 60 2213 60 2040 355 40 2203 40 2215 46 2062 40 41 41 41 59 125 330 35 690 2020 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 2090 355 2214 40 2001 2222 44 601 2179 321 2223 60 2090 40 2001 2224 41 62 38 2225 41 123 2179 321 2219 60 2090 62 2226 40 2222 41 59 664 40 2001 2224 61 1500 59 2224 60 2222 59 2224 349 41 2226 91 2224 93 61 2225 40 2224 41 59 792 2214 40 2226 41 59 125 35 636 330 331 331 331 331 331 331 331 331 331 822 60 835 2090 44 835 2227 44 835 2228 62 2099 60 2213 60 2090 355 2214 40 2001 2222 44 2227 2225 44 2228 42 2229 41 123 2179 321 2219 60 2090 62 2230 40 2222 41 59 664 40 2001 2224 61 1500 59 2224 60 2222 59 2224 349 41 2230 91 2224 93 61 2225 40 2224 44 2229 41 59 792 2214 40 2230 41 59 125 331 331 331 331 331 331 2099 60 2213 60 2099 60 2173 355 62 2231 40 601 2179 321 2219 60 2179 321 2180 62 38 2215 41 123 2179 321 2219 60 2099 60 2173 355 2232 40 2215 46 2062 40 41 41 59 664 40 2001 2224 61 1500 59 2224 60 2215 46 2062 40 41 59 2224 349 41 2232 91 2224 93 61 2174 40 2215 91 2224 93 41 59 792 2214 40 2232 41 59 125 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 601 2090 42 355 2233 40 601 2090 42 2215 44 2001 2170 41 123 2205 40 2170 42 805 40 2090 41 47 2007 60 2090 62 40 41 44 2007 60 2090 62 40 41 41 59 2085 40 786 60 601 2040 42 62 40 2215 41 44 805 40 2090 41 42 2170 41 59 792 2099 60 2213 60 601 2090 42 355 40 2203 40 2170 41 41 59 125 331 331 331 331 331 331 331 331 331 331 822 60 835 2090 44 835 2228 62 2099 60 2213 60 601 2090 42 355 2234 40 601 2228 42 2215 44 2001 2170 44 2090 40 40 42 601 2235 41 40 601 2228 38 41 41 41 123 2236 40 2235 41 59 2179 321 2219 60 2090 62 2237 40 2170 41 59 2179 321 2238 40 2215 44 2215 43 2170 44 2237 46 2239 40 41 44 2235 41 59 792 2233 60 2090 62 40 2240 40 2237 41 44 2237 46 2062 40 41 41 59 125 331 331 331 331 331 331 331 331 822 60 835 2090 44 835 2228 62 2099 60 2213 60 601 2090 42 355 2234 40 601 2228 42 2215 44 2001 2170 41 123 651 2090 2241 40 601 2228 38 41 59 792 2234 40 2215 44 2170 44 2241 41 59 125 330 35 690 2020 331 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 601 2090 42 355 2233 40 2001 2222 44 601 2179 321 2223 60 865 40 2001 2224 44 2090 42 41 62 38 2242 41 123 2090 42 2243 61 2244 60 2090 62 40 2222 41 59 664 40 2001 2224 61 1500 59 2224 60 2222 59 2224 349 41 123 2242 40 2224 44 2243 41 59 2243 349 59 125 792 2245 60 2090 62 40 2222 41 59 125 35 636 330 331 331 331 331 331 331 331 331 331 822 60 835 2090 44 835 2227 44 835 2228 62 2099 60 2213 60 601 2090 42 355 2233 40 2001 2222 44 2227 2225 44 2228 42 2229 41 123 2090 42 2246 61 2247 60 2090 62 40 2222 41 59 664 40 2001 2224 61 1500 59 2224 60 2222 59 2224 349 41 123 2225 40 2224 44 2246 44 2229 41 59 2246 349 59 125 792 2248 60 2090 62 40 2222 41 59 125 331 331 331 331 331 331 822 60 835 2090 44 835 2249 62 2099 60 2213 60 601 2090 42 355 2233 40 601 2179 321 2219 60 2090 44 2249 62 38 2215 41 123 792 2233 40 2250 40 2215 41 44 2215 46 2062 40 41 41 59 125 331 331 331 331 331 331 331 331 331 331 822 60 835 2090 44 835 2228 62 2099 60 2213 60 601 2090 42 355 2234 40 601 2179 321 2219 60 2228 62 38 2215 44 2090 40 40 42 601 2235 41 40 601 2228 38 41 41 41 123 792 2234 60 2090 44 2228 62 40 2251 40 2215 41 44 2215 46 2062 40 41 44 2235 41 59 125 331 331 331 331 331 331 331 331 822 60 835 2090 44 835 2228 62 2099 60 2213 60 601 2090 42 355 2234 40 601 2179 321 2219 60 2228 62 38 2215 41 123 792 2234 60 2090 44 2228 62 40 2252 40 2215 41 44 2215 46 2062 40 41 41 59 125 331 822 60 835 2090 62 816 2253 123 569 758 40 41 40 601 2090 38 2254 44 601 2090 38 2255 41 601 123 792 2254 46 2256 40 38 2255 41 59 125 2257 40 2253 38 758 61 40 601 2253 38 41 41 59 125 59 331 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 601 2090 42 355 2258 40 2179 321 2219 60 2090 62 42 2215 41 123 792 2258 40 2259 40 42 2215 41 44 2215 354 2062 40 41 41 59 125 331 331 331 331 331 331 331 331 822 60 835 2090 44 835 2228 62 2099 60 2213 60 601 2090 42 355 2260 40 2179 321 2219 60 2228 62 42 2215 41 123 792 2260 60 2090 44 2228 62 40 2261 40 42 2215 41 44 2215 354 2062 40 41 41 59 125 331 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 601 2090 42 355 2258 40 2090 42 2215 44 2001 2170 41 123 2179 321 2262 40 2215 44 2215 43 2170 44 2253 60 2090 62 40 41 41 59 792 2233 40 2215 44 2170 41 59 125 331 331 331 331 331 331 331 331 331 822 60 835 2090 44 835 2228 62 2099 60 2213 60 601 2090 42 355 2260 40 2228 42 2215 44 2001 2170 41 123 651 2090 2263 40 601 2228 38 41 59 833 2090 40 42 2264 41 40 601 2228 38 41 59 2179 321 2219 60 2090 62 2265 40 2170 41 59 2179 321 2266 40 2215 44 2215 43 2170 44 2265 46 2267 40 41 44 811 60 2264 38 62 40 2263 41 41 59 792 2258 60 2090 62 40 2265 44 2170 41 59 125 331 822 60 835 2090 62 816 2268 123 2268 40 2269 38 2270 41 58 2009 40 2270 41 123 125 2268 40 601 2268 38 2021 41 58 2009 40 2021 46 2009 41 123 125 569 758 40 41 40 601 2099 60 2090 62 38 2271 44 601 2099 60 2090 62 38 2272 41 601 123 561 2273 61 786 60 2090 42 62 40 2009 46 2274 40 2271 46 2275 41 41 59 561 2276 61 786 60 2090 42 62 40 2009 46 2274 40 2272 46 2275 41 41 59 792 2273 354 2277 40 2276 41 59 125 2269 38 2009 59 773 58 2278 40 2268 38 758 61 40 601 2268 38 2021 41 41 59 125 59 331 331 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 2099 60 2090 355 62 2279 40 2099 60 2090 62 42 2215 44 2001 2170 41 123 2179 321 2280 40 2215 44 2215 43 2170 44 2268 60 2090 62 40 2009 41 41 59 792 2214 40 2215 44 2170 41 59 125 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 2099 60 2090 355 62 2279 40 2179 321 2219 60 2099 60 2090 355 42 2215 41 123 792 2279 40 2281 40 42 2215 41 44 2215 354 2062 40 41 41 59 125 331 331 331 331 331 331 331 2037 2282 40 2001 2170 44 2001 2206 44 2040 42 42 2283 41 123 2125 40 41 59 2205 40 2170 44 2206 41 59 2009 46 2284 40 2170 42 2206 41 59 561 2285 61 2038 40 41 59 561 2286 61 2203 40 2170 41 59 42 2283 61 2009 46 2287 40 2285 41 59 792 2286 59 125 331 331 331 331 331 331 331 331 822 60 835 2090 62 2099 60 2213 60 2090 355 2282 40 2001 2170 44 2090 42 42 2283 41 123 2091 60 2090 62 40 41 59 792 2282 40 2170 44 805 40 2090 41 44 786 60 2040 42 42 62 40 2283 41 41 59 125 822 60 835 2090 62 2099 60 2213 60 601 2090 42 355 2288 40 2001 2170 44 2090 42 42 2283 41 123 792 2282 40 2170 44 805 40 2090 41 44 786 60 2040 42 42 62 40 2283 41 41 59 125 330 330 330 822 60 835 2090 44 835 2289 62 2099 60 2213 60 2090 355 2290 40 601 2289 42 2215 44 2001 2170 41 123 2091 60 2090 62 40 41 59 2091 60 2289 62 40 41 59 2205 40 2170 44 805 40 2090 41 41 59 664 40 561 2224 61 2170 59 2224 62 1500 59 41 123 2094 40 811 60 2090 62 40 2215 91 338 2224 93 41 41 59 125 792 2099 60 2213 60 2090 355 40 2203 40 2170 41 41 59 125 331 822 60 835 2090 62 2099 60 601 2090 42 62 2291 40 601 2090 38 2292 41 123 2125 40 41 59 2079 40 2007 60 2090 62 40 41 41 59 2009 46 2293 40 2292 41 59 792 2099 60 601 2090 42 62 40 2038 40 41 41 59 125 331 809 601 2001 2294 61 1502 59 331 331 331 822 60 835 2090 62 865 2295 40 2099 60 2090 62 2296 44 601 582 42 2297 61 753 41 123 2295 40 2296 46 2298 44 2297 44 655 41 59 125 331 331 331 331 331 331 331 822 60 835 2090 62 865 2299 40 2099 60 2090 62 2296 44 601 582 42 2297 61 753 41 123 2295 40 2296 46 2300 44 2297 44 829 41 59 125 865 2301 40 2000 38 2021 41 123 2009 46 2302 40 2021 46 2009 41 59 125 775 58 330 2000 40 601 2000 38 41 59 2000 38 758 61 40 601 2000 38 41 59 865 2295 40 2037 2296 44 601 582 42 2297 44 569 2303 41 123 2125 40 41 59 2009 46 2304 40 41 59 330 2169 40 40 2303 63 805 40 2037 41 58 1500 41 43 805 40 2037 41 43 40 2297 63 2294 58 1500 41 44 2014 41 59 688 40 2297 41 123 2305 40 2306 40 2297 41 323 2294 41 59 2085 40 786 60 601 2040 42 62 40 2297 41 44 2294 41 59 125 2094 40 2123 40 2296 41 41 59 330 688 40 2303 41 123 2094 40 2038 40 41 41 59 125 2013 61 829 59 125 816 2307 123 2037 2100 59 2104 2308 59 125 59 2309 2009 59 330 330 2037 2010 59 330 330 2104 2011 59 330 569 2012 59 330 569 2013 59 2001 2014 59 569 2015 59 330 569 2016 59 816 2310 123 2310 40 601 2309 38 2283 41 58 2009 40 38 2283 41 123 125 569 758 40 41 40 601 2099 60 2173 62 38 2311 44 601 2099 60 2173 62 38 2312 41 601 123 561 2313 61 786 60 601 2173 42 62 40 2009 354 2314 40 2311 46 2315 41 41 59 561 2316 61 786 60 601 2173 42 62 40 2009 354 2314 40 2312 46 2315 41 41 59 792 2317 40 2313 354 2318 40 41 44 2313 354 2062 40 41 44 2316 354 2318 40 41 44 2316 354 2062 40 41 41 59 125 601 2309 42 2009 59 125 59 330 833 2179 321 2319 60 2099 60 2173 62 44 2310 62 2320 59 2320 42 2017 59 773 58 330 330 822 60 835 2090 62 2090 42 2321 40 2001 2222 41 123 2205 40 2222 42 805 40 2090 41 47 2007 60 2090 62 40 41 44 2007 60 2090 62 40 41 41 59 792 786 60 2090 42 62 40 2009 46 2322 40 2222 42 805 40 2090 41 41 41 59 125 330 330 822 60 835 2090 62 2099 60 2213 60 601 2090 42 355 2323 40 2001 2222 41 123 792 2099 60 2213 60 601 2090 42 355 40 2203 40 2222 41 41 59 125 125 59 ,"{'AvgLine': 5, 'CountLine': 1077, 'CountStmt': 476, 'MaxNesting': 3, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 273, 'MaxEssential': 4, 'SumEssential': 93, 'AvgCyclomatic': 1, 'CountLineCode': 549, 'CountStmtDecl': 237, 'MaxCyclomatic': 9, 'SumCyclomatic': 130, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 107, 'CountStmtEmpty': 3, 'AltAvgLineBlank': 0, 'CountDeclMethod': 92, 'AltCountLineCode': 580, 'CountLineCodeExe': 273, 'CountLineComment': 395, 'AltAvgLineComment': 0, 'AltCountLineBlank': 107, 'CountClassCoupled': 28, 'CountClassDerived': 1, 'CountLineCodeDecl': 158, 'CountLineInactive': 22, 'CountDeclMethodAll': 92, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.72', 'AltCountLineComment': 403, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 133, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 6, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 87, 'CountLinePreprocessor': 17, 'MaxCyclomaticModified': 9, 'PercentLackOfCohesion': 90, 'SumCyclomaticModified': 130, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 92, 'CountDeclMethodProtected': 3, 'CountDeclInstanceVariable': 9, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 9}"
118594,C++,"class NotificationIcon : public ChatLineContent
{
    Q_OBJECT
public:
    explicit NotificationIcon(QSize size);

    QRectF boundingRect() const override;
    void paint(QPainter* painter, const QStyleOptionGraphicsItem* option,
                       QWidget* widget) override;
    void setWidth(qreal width) override;
    qreal getAscent() const override;

private slots:
    void updateGradient();

private:
    static constexpr int framerate = 30; // 30Hz

    QSize size;
    QPixmap pmap;
    QLinearGradient grad;
    QTimer updateTimer;

    qreal dotWidth = 0.2;
    qreal alpha = 0.0;
};",1,587 2000 58 777 2001 123 2002 777 58 648 2000 40 2003 2004 41 59 2005 2006 40 41 601 2007 59 865 2008 40 2009 42 2010 44 601 2011 42 2012 44 2013 42 2014 41 2007 59 865 2015 40 2016 2017 41 2007 59 2016 2018 40 41 601 2007 59 773 2019 58 865 2020 40 41 59 773 58 809 603 704 2021 61 1503 59 330 2003 2004 59 2022 2023 59 2024 2025 59 2026 2027 59 2016 2028 61 1500 59 2016 2029 61 1500 59 125 59 ,"{'AvgLine': 10, 'CountLine': 87, 'CountStmt': 17, 'MaxNesting': 1, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 5, 'MaxEssential': 1, 'SumEssential': 6, 'AvgCyclomatic': 1, 'CountLineCode': 70, 'CountStmtDecl': 12, 'MaxCyclomatic': 3, 'SumCyclomatic': 9, 'AltAvgLineCode': 8, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 14, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 7, 'AltCountLineCode': 70, 'CountLineCodeExe': 3, 'CountLineComment': 4, 'AltAvgLineComment': 0, 'AltCountLineBlank': 14, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 5, 'CountLineInactive': 0, 'CountDeclMethodAll': 27, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.06', 'AltCountLineComment': 4, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 4, 'SumCyclomaticStrict': 10, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 6, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 9, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 13, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 7, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99817,C++,"class FetchBufferDirectIO final
{
    VSILFILE*    fp;
    GByte       *pTempBuffer;
    size_t       nTempBufferSize;

public:
            FetchBufferDirectIO( VSILFILE* fpIn,
                                 GByte* pTempBufferIn,
                                 size_t nTempBufferSizeIn ) :
                fp(fpIn),
                pTempBuffer(pTempBufferIn),
                nTempBufferSize(nTempBufferSizeIn) {}

    const GByte* FetchBytes( vsi_l_offset nOffset,
                             int nPixels, int nDTSize,
                             bool bIsByteSwapped, bool bIsComplex,
                             int nBlockId )
    {
        if( !FetchBytes(pTempBuffer, nOffset, nPixels, nDTSize, bIsByteSwapped,
                        bIsComplex, nBlockId) )
        {
            return nullptr;
        }
        return pTempBuffer;
    }

    bool FetchBytes( GByte* pabyDstBuffer,
                     vsi_l_offset nOffset,
                     int nPixels, int nDTSize,
                     bool bIsByteSwapped, bool bIsComplex,
                     int nBlockId )
    {
        vsi_l_offset nSeekForward = 0;
        if( nOffset <= VSIFTellL(fp) ||
            (nSeekForward = nOffset - VSIFTellL(fp)) > nTempBufferSize )
        {
            if( VSIFSeekL(fp, nOffset, SEEK_SET) != 0 )
            {
                CPLError(CE_Failure, CPLE_FileIO,
                         ""Cannot seek to block %d"", nBlockId);
                return false;
            }
        }
        else
        {
            while( nSeekForward > 0 )
            {
                vsi_l_offset nToRead = nSeekForward;
                if( nToRead > nTempBufferSize )
                    nToRead = nTempBufferSize;
                if( VSIFReadL(pTempBuffer, static_cast<size_t>(nToRead),
                              1, fp) != 1 )
                {
                    CPLError(CE_Failure, CPLE_FileIO,
                             ""Cannot seek to block %d"", nBlockId);
                    return false;
                }
                nSeekForward -= nToRead;
            }
        }
        if( VSIFReadL(pabyDstBuffer, nPixels * nDTSize, 1, fp) != 1 )
        {
            CPLError(CE_Failure, CPLE_FileIO,
                     ""Missing data for block %d"", nBlockId);
            return false;
        }

        if( bIsByteSwapped )
        {
            if( bIsComplex )
                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,
                               nDTSize / 2 );
            else
                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);
        }
        return true;
    }

    static const EMULATED_BOOL bMinimizeIO = true;
};",1,587 2000 2001 123 2002 42 2003 59 2004 42 2005 59 2006 2007 59 777 58 2000 40 2002 42 2008 44 2004 42 2009 44 2006 2010 41 58 2003 40 2008 41 44 2005 40 2009 41 44 2007 40 2010 41 123 125 601 2004 42 2011 40 2012 2013 44 704 2014 44 704 2015 44 569 2016 44 569 2017 44 704 2018 41 123 688 40 33 2011 40 2005 44 2013 44 2014 44 2015 44 2016 44 2017 44 2018 41 41 123 792 753 59 125 792 2005 59 125 569 2011 40 2004 42 2019 44 2012 2013 44 704 2014 44 704 2015 44 569 2016 44 569 2017 44 704 2018 41 123 2012 2020 61 1500 59 688 40 2013 329 2021 40 2003 41 309 40 2020 61 2013 45 2021 40 2003 41 41 62 2007 41 123 688 40 2022 40 2003 44 2013 44 2023 41 340 1500 41 123 2024 40 2025 44 2026 44 362 44 2018 41 59 792 655 59 125 125 630 123 870 40 2020 62 1500 41 123 2012 2027 61 2020 59 688 40 2027 62 2007 41 2027 61 2007 59 688 40 2028 40 2005 44 811 60 2006 62 40 2027 41 44 1501 44 2003 41 340 1501 41 123 2029 40 2030 44 2031 44 362 44 2018 41 59 792 655 59 125 2020 337 2027 59 125 125 688 40 2032 40 2019 44 2014 42 2015 44 1501 44 2003 41 340 1501 41 123 2033 40 2034 44 2035 44 362 44 2018 41 59 792 655 59 125 688 40 2016 41 123 688 40 2017 41 2036 40 2019 44 2015 47 1502 44 1502 42 2014 44 2015 47 1502 41 59 630 2036 40 2019 44 2015 44 2014 44 2015 41 59 125 792 829 59 125 809 601 2037 2038 61 829 59 125 59 ,"{'AvgLine': 23, 'CountLine': 81, 'CountStmt': 34, 'MaxNesting': 3, 'AvgLineCode': 22, 'AvgEssential': 2, 'AvgLineBlank': 0, 'CountStmtExe': 22, 'MaxEssential': 6, 'SumEssential': 8, 'AvgCyclomatic': 4, 'CountLineCode': 76, 'CountStmtDecl': 12, 'MaxCyclomatic': 9, 'SumCyclomatic': 12, 'AltAvgLineCode': 22, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 5, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 3, 'AltCountLineCode': 76, 'CountLineCodeExe': 36, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 5, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 15, 'CountLineInactive': 0, 'CountDeclMethodAll': 3, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 13, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 4, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 9, 'PercentLackOfCohesion': 65, 'SumCyclomaticModified': 12, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
117641,C++,"class RoverPositionControl final : public ModuleBase<RoverPositionControl>, public ModuleParams, public px4::WorkItem
{
public:
	RoverPositionControl();
	~RoverPositionControl();
	RoverPositionControl(const RoverPositionControl &) = delete;
	RoverPositionControl operator=(const RoverPositionControl &other) = delete;

	/** @see ModuleBase */
	static int task_spawn(int argc, char *argv[]);

	/** @see ModuleBase */
	static int custom_command(int argc, char *argv[]);

	/** @see ModuleBase */
	static int print_usage(const char *reason = nullptr);

	bool init();

private:
	void Run() override;

	uORB::SubscriptionCallbackWorkItem _vehicle_angular_velocity_sub{this, ORB_ID(vehicle_angular_velocity)};

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};

	uORB::Publication<vehicle_attitude_setpoint_s>	_attitude_sp_pub{ORB_ID(vehicle_attitude_setpoint)};
	uORB::Publication<position_controller_status_s>	_pos_ctrl_status_pub{ORB_ID(position_controller_status)};  /**< navigation capabilities publication */
	uORB::Publication<actuator_controls_s>		_actuator_controls_pub{ORB_ID(actuator_controls_0)};  /**< actuator controls publication */

	uORB::Subscription _control_mode_sub{ORB_ID(vehicle_control_mode)}; /**< control mode subscription */
	uORB::Subscription _global_pos_sub{ORB_ID(vehicle_global_position)};
	uORB::Subscription _local_pos_sub{ORB_ID(vehicle_local_position)};
	uORB::Subscription _manual_control_setpoint_sub{ORB_ID(manual_control_setpoint)}; /**< notification of manual control updates */
	uORB::Subscription _pos_sp_triplet_sub{ORB_ID(position_setpoint_triplet)};
	uORB::Subscription _att_sub{ORB_ID(vehicle_attitude)};
	uORB::Subscription _att_sp_sub{ORB_ID(vehicle_attitude_setpoint)};
	uORB::Subscription _trajectory_setpoint_sub{ORB_ID(trajectory_setpoint)};

	manual_control_setpoint_s		_manual_control_setpoint{};			    /**< r/c channel data */
	position_setpoint_triplet_s		_pos_sp_triplet{};		/**< triplet of mission items */
	vehicle_attitude_setpoint_s		_att_sp{};			/**< attitude setpoint > */
	vehicle_control_mode_s			_control_mode{};		/**< control mode */
	vehicle_global_position_s		_global_pos{};			/**< global vehicle position */
	vehicle_local_position_s		_local_pos{};			/**< global vehicle position */
	actuator_controls_s				_act_controls{};		/**< direct control of actuators */
	vehicle_attitude_s				_vehicle_att{};
	vehicle_local_position_setpoint_s       _trajectory_setpoint{};

	uORB::SubscriptionData<vehicle_acceleration_s>		_vehicle_acceleration_sub{ORB_ID(vehicle_acceleration)};

	perf_counter_t	_loop_perf;			/**< loop performance counter */

	hrt_abstime _control_position_last_called{0}; 	/**<last call of control_position  */
	hrt_abstime _manual_setpoint_last_called{0};

	MapProjection _global_local_proj_ref{};
	float                      _global_local_alt0{NAN};

	/* Pid controller for the speed. Here we assume we can control airspeed but the control variable is actually on
	 the throttle. For now just assuming a proportional scaler between controlled airspeed and throttle output.*/
	PID_t _speed_ctrl{};

	// estimator reset counters
	uint8_t _pos_reset_counter{0};		// captures the number of times the estimator has reset the horizontal position

	ECL_L1_Pos_Controller				_gnd_control;

	enum UGV_POSCTRL_MODE {
		UGV_POSCTRL_MODE_AUTO,
		UGV_POSCTRL_MODE_OTHER
	} _control_mode_current{UGV_POSCTRL_MODE_OTHER};			///< used to check the mode in the last control loop iteration. Use to check if the last iteration was in the same mode.


	enum POS_CTRLSTATES {
		GOTO_WAYPOINT,
		STOPPING
	} _pos_ctrl_state {STOPPING};			/// Position control state machine

	/* previous waypoint */
	matrix::Vector2d _prev_wp{0, 0};

	enum class VelocityFrame {
		NED,
		BODY,
	} _velocity_frame{VelocityFrame::NED};

	float _manual_yaw_sp{0.0};
	bool _reset_yaw_sp{true};

	DEFINE_PARAMETERS(
		(ParamFloat<px4::params::GND_L1_PERIOD>) _param_l1_period,
		(ParamFloat<px4::params::GND_L1_DAMPING>) _param_l1_damping,
		(ParamFloat<px4::params::GND_L1_DIST>) _param_l1_distance,

		(ParamFloat<px4::params::GND_SPEED_TRIM>) _param_gndspeed_trim,
		(ParamFloat<px4::params::GND_SPEED_MAX>) _param_gndspeed_max,

		(ParamInt<px4::params::GND_SP_CTRL_MODE>) _param_speed_control_mode,
		(ParamFloat<px4::params::GND_SPEED_P>) _param_speed_p,
		(ParamFloat<px4::params::GND_SPEED_I>) _param_speed_i,
		(ParamFloat<px4::params::GND_SPEED_D>) _param_speed_d,
		(ParamFloat<px4::params::GND_SPEED_IMAX>) _param_speed_imax,
		(ParamFloat<px4::params::GND_SPEED_THR_SC>) _param_throttle_speed_scaler,

		(ParamFloat<px4::params::GND_THR_MIN>) _param_throttle_min,
		(ParamFloat<px4::params::GND_THR_MAX>) _param_throttle_max,
		(ParamFloat<px4::params::GND_THR_CRUISE>) _param_throttle_cruise,

		(ParamFloat<px4::params::GND_WHEEL_BASE>) _param_wheel_base,
		(ParamFloat<px4::params::GND_MAX_ANG>) _param_max_turn_angle,
		(ParamFloat<px4::params::GND_MAN_Y_MAX>) _param_gnd_man_y_max,
		(ParamFloat<px4::params::NAV_LOITER_RAD>) _param_nav_loiter_rad	/**< loiter radius for Rover */
	)

	/**
	 * Update our local parameter cache.
	 */
	void parameters_update(bool force = false);

	void		position_setpoint_triplet_poll();
	void		attitude_setpoint_poll();
	void		vehicle_control_mode_poll();
	void 		vehicle_attitude_poll();
	void		manual_control_setpoint_poll();

	/**
	 * Control position.
	 */
	bool		control_position(const matrix::Vector2d &global_pos, const matrix::Vector3f &ground_speed,
					 const position_setpoint_triplet_s &_pos_sp_triplet);
	void		control_velocity(const matrix::Vector3f &current_velocity);
	void		control_attitude(const vehicle_attitude_s &att, const vehicle_attitude_setpoint_s &att_sp);

};",1,587 2000 2001 58 777 2002 60 2000 62 44 777 2003 44 777 2004 321 2005 123 777 58 2000 40 41 59 126 2000 40 41 59 2000 40 601 2000 38 41 61 619 59 2000 758 61 40 601 2000 38 2006 41 61 619 59 306 809 704 2007 40 704 2008 44 582 42 2009 91 93 41 59 306 809 704 2010 40 704 2008 44 582 42 2009 91 93 41 59 306 809 704 2011 40 601 582 42 2012 61 753 41 59 569 2013 40 41 59 773 58 865 2014 40 41 2015 59 2016 321 2017 2018 123 823 44 2019 40 2020 41 125 59 2016 321 2021 2022 123 2023 40 2024 41 44 1501 125 59 2016 321 2025 60 2026 62 2027 123 2028 40 2029 41 125 59 2016 321 2025 60 2030 62 2031 123 2032 40 2033 41 125 59 306 2016 321 2025 60 2034 62 2035 123 2036 40 2037 41 125 59 306 2016 321 2038 2039 123 2040 40 2041 41 125 59 306 2016 321 2038 2042 123 2043 40 2044 41 125 59 2016 321 2038 2045 123 2046 40 2047 41 125 59 2016 321 2038 2048 123 2049 40 2050 41 125 59 306 2016 321 2038 2051 123 2052 40 2053 41 125 59 2016 321 2038 2054 123 2055 40 2056 41 125 59 2016 321 2038 2057 123 2058 40 2059 41 125 59 2016 321 2038 2060 123 2061 40 2062 41 125 59 2063 2064 123 125 59 306 2065 2066 123 125 59 306 2026 2067 123 125 59 306 2068 2069 123 125 59 306 2070 2071 123 125 59 306 2072 2073 123 125 59 306 2034 2074 123 125 59 306 2075 2076 123 125 59 2077 2078 123 125 59 2016 321 2079 60 2080 62 2081 123 2082 40 2083 41 125 59 2084 2085 59 306 2086 2087 123 1500 125 59 306 2086 2088 123 1500 125 59 2089 2090 123 125 59 660 2091 123 2092 125 59 305 2093 2094 123 125 59 330 2095 2096 123 1500 125 59 330 2097 2098 59 640 2099 123 2100 44 2101 125 2102 123 2103 125 59 331 640 2104 123 2105 44 2106 125 2107 123 2108 125 59 331 305 2109 321 2110 2111 123 1500 44 1500 125 59 640 587 2112 123 2113 44 2114 44 125 2115 123 2112 321 2116 125 59 660 2117 123 1500 125 59 569 2118 123 829 125 59 2119 40 40 2120 60 2004 321 2121 321 2122 62 41 2123 44 40 2120 60 2004 321 2121 321 2124 62 41 2125 44 40 2120 60 2004 321 2121 321 2126 62 41 2127 44 40 2120 60 2004 321 2121 321 2128 62 41 2129 44 40 2120 60 2004 321 2121 321 2130 62 41 2131 44 40 2132 60 2004 321 2121 321 2133 62 41 2134 44 40 2120 60 2004 321 2121 321 2135 62 41 2136 44 40 2120 60 2004 321 2121 321 2137 62 41 2138 44 40 2120 60 2004 321 2121 321 2139 62 41 2140 44 40 2120 60 2004 321 2121 321 2141 62 41 2142 44 40 2120 60 2004 321 2121 321 2143 62 41 2144 44 40 2120 60 2004 321 2121 321 2145 62 41 2146 44 40 2120 60 2004 321 2121 321 2147 62 41 2148 44 40 2120 60 2004 321 2121 321 2149 62 41 2150 44 40 2120 60 2004 321 2121 321 2151 62 41 2152 44 40 2120 60 2004 321 2121 321 2153 62 41 2154 44 40 2120 60 2004 321 2121 321 2155 62 41 2156 44 40 2120 60 2004 321 2121 321 2157 62 41 2158 306 41 306 865 2159 40 569 2160 61 655 41 59 865 2161 40 41 59 865 2162 40 41 59 865 2163 40 41 59 865 2164 40 41 59 865 2165 40 41 59 306 569 2166 40 601 2109 321 2110 38 2167 44 601 2109 321 2168 38 2169 44 601 2065 38 2066 41 59 865 2170 40 601 2109 321 2168 38 2171 41 59 865 2172 40 601 2075 38 2173 44 601 2026 38 2174 41 59 125 59 ,"{'AvgLine': 30, 'CountLine': 595, 'CountStmt': 207, 'MaxNesting': 5, 'AvgLineCode': 21, 'AvgEssential': 1, 'AvgLineBlank': 6, 'CountStmtExe': 95, 'MaxEssential': 3, 'SumEssential': 19, 'AvgCyclomatic': 3, 'CountLineCode': 405, 'CountStmtDecl': 119, 'MaxCyclomatic': 12, 'SumCyclomatic': 56, 'AltAvgLineCode': 21, 'AvgLineComment': 3, 'CountClassBase': 2, 'CountLineBlank': 136, 'CountStmtEmpty': 2, 'AltAvgLineBlank': 6, 'CountDeclMethod': 19, 'AltCountLineCode': 405, 'CountLineCodeExe': 95, 'CountLineComment': 81, 'AltAvgLineComment': 3, 'AltCountLineBlank': 136, 'CountClassCoupled': 13, 'CountClassDerived': 0, 'CountLineCodeDecl': 62, 'CountLineInactive': 0, 'CountDeclMethodAll': 53, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.20', 'AltCountLineComment': 81, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 12, 'SumCyclomaticStrict': 56, 'CountDeclClassMethod': 3, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 10, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 11, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 55, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 8, 'CountDeclInstanceMethod': 16, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 55, 'CountDeclInstanceVariablePublic': 42, 'CountDeclInstanceVariablePrivate': 13, 'CountDeclInstanceVariableProtected': 0}"
117669,C++,"class VehicleMagnetometer : public ModuleParams, public px4::ScheduledWorkItem
{
public:

	VehicleMagnetometer();
	~VehicleMagnetometer() override;

	bool Start();
	void Stop();

	void PrintStatus();

private:
	void Run() override;

	void ParametersUpdate(bool force = false);

	void Publish(uint8_t instance, bool multi = false);

	/**
	 * Calculates the magnitude in Gauss of the largest difference between the primary and any other magnetometers
	 */
	void calcMagInconsistency();

	void UpdateMagBiasEstimate();
	void UpdateMagCalibration();
	void UpdatePowerCompensation();

	static constexpr int MAX_SENSOR_COUNT = 4;

	uORB::Publication<sensor_preflight_mag_s> _sensor_preflight_mag_pub{ORB_ID(sensor_preflight_mag)};

	uORB::PublicationMulti<vehicle_magnetometer_s> _vehicle_magnetometer_pub[MAX_SENSOR_COUNT] {
		{ORB_ID(vehicle_magnetometer)},
		{ORB_ID(vehicle_magnetometer)},
		{ORB_ID(vehicle_magnetometer)},
		{ORB_ID(vehicle_magnetometer)},
	};

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};

	uORB::Subscription _actuator_controls_0_sub{ORB_ID(actuator_controls_0)};
	uORB::Subscription _battery_status_sub{ORB_ID(battery_status), 0};
	uORB::Subscription _magnetometer_bias_estimate_sub{ORB_ID(magnetometer_bias_estimate)};
	uORB::Subscription _vehicle_control_mode_sub{ORB_ID(vehicle_control_mode)};

	// Used to check, save and use learned magnetometer biases
	uORB::SubscriptionMultiArray<estimator_sensor_bias_s> _estimator_sensor_bias_subs{ORB_ID::estimator_sensor_bias};

	bool _in_flight_mag_cal_available{false}; ///< from navigation filter

	struct MagCal {
		uint32_t device_id{0};
		matrix::Vector3f offset{};
		matrix::Vector3f variance{};
		float temperature{NAN};
	} _mag_cal[ORB_MULTI_MAX_INSTANCES] {};

	uORB::SubscriptionCallbackWorkItem _sensor_sub[MAX_SENSOR_COUNT] {
		{this, ORB_ID(sensor_mag), 0},
		{this, ORB_ID(sensor_mag), 1},
		{this, ORB_ID(sensor_mag), 2},
		{this, ORB_ID(sensor_mag), 3}
	};

	hrt_abstime _last_calibration_update{0};

	matrix::Vector3f _calibration_estimator_bias[MAX_SENSOR_COUNT] {};

	calibration::Magnetometer _calibration[MAX_SENSOR_COUNT];

	// Magnetometer interference compensation
	enum class MagCompensationType {
		Disabled = 0,
		Throttle,
		Current_inst0,
		Current_inst1
	};
	MagCompensationType _mag_comp_type{MagCompensationType::Disabled};

	perf_counter_t _cycle_perf{perf_alloc(PC_ELAPSED, MODULE_NAME"": cycle"")};

	hrt_abstime _last_error_message{0};
	orb_advert_t _mavlink_log_pub{nullptr};

	DataValidatorGroup _voter{1};
	unsigned _last_failover_count{0};

	uint64_t _timestamp_sample_sum[MAX_SENSOR_COUNT] {};
	matrix::Vector3f _mag_sum[MAX_SENSOR_COUNT] {};
	int _mag_sum_count[MAX_SENSOR_COUNT] {};
	hrt_abstime _last_publication_timestamp[MAX_SENSOR_COUNT] {};

	sensor_mag_s _last_data[MAX_SENSOR_COUNT] {};
	bool _advertised[MAX_SENSOR_COUNT] {};

	float _mag_angle_diff[2] {};			/**< filtered mag angle differences between sensor instances (Ga) */

	uint8_t _priority[MAX_SENSOR_COUNT] {};

	int8_t _selected_sensor_sub_index{-1};

	bool _armed{false};

	DEFINE_PARAMETERS(
		(ParamInt<px4::params::CAL_MAG_COMP_TYP>) _param_mag_comp_typ,
		(ParamBool<px4::params::SENS_MAG_MODE>) _param_sens_mag_mode,
		(ParamFloat<px4::params::SENS_MAG_RATE>) _param_sens_mag_rate,
		(ParamBool<px4::params::SENS_MAG_AUTOCAL>) _param_sens_mag_autocal
	)
};",1,587 2000 58 777 2001 44 777 2002 321 2003 123 777 58 2000 40 41 59 126 2000 40 41 2004 59 569 2005 40 41 59 865 2006 40 41 59 865 2007 40 41 59 773 58 865 2008 40 41 2004 59 865 2009 40 569 2010 61 655 41 59 865 2011 40 2012 2013 44 569 2014 61 655 41 59 306 865 2015 40 41 59 865 2016 40 41 59 865 2017 40 41 59 865 2018 40 41 59 809 603 704 2019 61 1502 59 2020 321 2021 60 2022 62 2023 123 2024 40 2025 41 125 59 2020 321 2026 60 2027 62 2028 91 2019 93 123 123 2029 40 2030 41 125 44 123 2031 40 2032 41 125 44 123 2033 40 2034 41 125 44 123 2035 40 2036 41 125 44 125 59 2020 321 2037 2038 123 2039 40 2040 41 44 1501 125 59 2020 321 2041 2042 123 2043 40 2044 41 125 59 2020 321 2041 2045 123 2046 40 2047 41 44 1500 125 59 2020 321 2041 2048 123 2049 40 2050 41 125 59 2020 321 2041 2051 123 2052 40 2053 41 125 59 330 2020 321 2054 60 2055 62 2056 123 2057 321 2058 125 59 569 2059 123 655 125 59 331 816 2060 123 2061 2062 123 1500 125 59 2063 321 2064 2065 123 125 59 2063 321 2064 2066 123 125 59 660 2067 123 2068 125 59 125 2069 91 2070 93 123 125 59 2020 321 2071 2072 91 2019 93 123 123 823 44 2073 40 2074 41 44 1500 125 44 123 823 44 2075 40 2076 41 44 1501 125 44 123 823 44 2077 40 2078 41 44 1502 125 44 123 823 44 2079 40 2080 41 44 1502 125 125 59 2081 2082 123 1500 125 59 2083 321 2084 2085 91 2019 93 123 125 59 2086 321 2087 2088 91 2019 93 59 330 640 587 2089 123 2090 61 1500 44 2091 44 2092 44 2093 125 59 2089 2094 123 2089 321 2095 125 59 2096 2097 123 2098 40 2099 44 2100 362 41 125 59 2081 2101 123 1500 125 59 2102 2103 123 753 125 59 2104 2105 123 1501 125 59 856 2106 123 1500 125 59 2107 2108 91 2019 93 123 125 59 2083 321 2084 2109 91 2019 93 123 125 59 704 2110 91 2019 93 123 125 59 2081 2111 91 2019 93 123 125 59 2112 2113 91 2019 93 123 125 59 569 2114 91 2019 93 123 125 59 660 2115 91 1502 93 123 125 59 306 2012 2116 91 2019 93 123 125 59 2117 2118 123 45 1501 125 59 569 2119 123 655 125 59 2120 40 40 2121 60 2002 321 2122 321 2123 62 41 2124 44 40 2125 60 2002 321 2122 321 2126 62 41 2127 44 40 2128 60 2002 321 2122 321 2129 62 41 2130 44 40 2125 60 2002 321 2122 321 2131 62 41 2132 41 125 59 ,"{'AvgLine': 48, 'CountLine': 729, 'CountStmt': 286, 'MaxNesting': 10, 'AvgLineCode': 34, 'AvgEssential': 1, 'AvgLineBlank': 10, 'CountStmtExe': 176, 'MaxEssential': 11, 'SumEssential': 25, 'AvgCyclomatic': 7, 'CountLineCode': 503, 'CountStmtDecl': 139, 'MaxCyclomatic': 35, 'SumCyclomatic': 99, 'AltAvgLineCode': 34, 'AvgLineComment': 4, 'CountClassBase': 2, 'CountLineBlank': 167, 'CountStmtEmpty': 4, 'AltAvgLineBlank': 10, 'CountDeclMethod': 13, 'AltCountLineCode': 503, 'CountLineCodeExe': 156, 'CountLineComment': 65, 'AltAvgLineComment': 4, 'AltCountLineBlank': 167, 'CountClassCoupled': 9, 'CountClassDerived': 0, 'CountLineCodeDecl': 94, 'CountLineInactive': 0, 'CountDeclMethodAll': 57, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.13', 'AltCountLineComment': 65, 'AvgCyclomaticStrict': 8, 'MaxCyclomaticStrict': 37, 'SumCyclomaticStrict': 106, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 7, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 5, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 35, 'PercentLackOfCohesion': 92, 'SumCyclomaticModified': 97, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 7, 'CountDeclInstanceMethod': 15, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 34, 'CountDeclInstanceVariablePublic': 16, 'CountDeclInstanceVariablePrivate': 18, 'CountDeclInstanceVariableProtected': 0}"
118567,C++,"class OpenAL : public IAudioControl
{
    Q_OBJECT

public:
    OpenAL(IAudioSettings& _settings);
    virtual ~OpenAL();

    qreal maxOutputVolume() const
    {
        return 1;
    }
    qreal minOutputVolume() const
    {
        return 0;
    }
    qreal outputVolume() const;
    void setOutputVolume(qreal volume);

    qreal minInputGain() const;
    qreal maxInputGain() const;

    qreal inputGain() const;
    void setInputGain(qreal dB);

    qreal minInputThreshold() const;
    qreal maxInputThreshold() const;

    qreal getInputThreshold() const;
    void setInputThreshold(qreal normalizedThreshold);

    void reinitInput(const QString& inDevDesc);
    bool reinitOutput(const QString& outDevDesc);

    bool isOutputReady() const;

    QStringList outDeviceNames();
    QStringList inDeviceNames();

    std::unique_ptr<IAudioSink> makeSink();
    void destroySink(AlSink& sink);

    std::unique_ptr<IAudioSource> makeSource();
    void destroySource(AlSource& source);

    void startLoop(uint sourceId);
    void stopLoop(uint sourceId);
    void playMono16Sound(AlSink& sink, const IAudioSink::Sound& sound);
    void stopActive();

    void playAudioBuffer(uint sourceId, const int16_t* data, int samples, unsigned channels,
                         int sampleRate);
signals:
    void startActive(qreal msec);

protected:
    static void checkAlError() noexcept;
    static void checkAlcError(ALCdevice* device) noexcept;

    qreal inputGainFactor() const;
    virtual void cleanupInput();
    virtual void cleanupOutput();

    bool autoInitInput();
    bool autoInitOutput();

    bool initInput(const QString& deviceName, uint32_t channels);

    void doAudio();

    virtual void doInput();
    virtual void doOutput();
    virtual void captureSamples(ALCdevice* device, int16_t* buffer, ALCsizei samples);

private:
    virtual bool initInput(const QString& deviceName);
    virtual bool initOutput(const QString& outDevDescr);

    void cleanupBuffers(uint sourceId);
    void cleanupSound();

    float getVolume();

protected:
    IAudioSettings& settings;
    QThread* audioThread;
    mutable CompatibleRecursiveMutex audioLock;
    QString inDev{};
    QString outDev{};

    ALCdevice* alInDev = nullptr;
    QTimer captureTimer;
    QTimer cleanupTimer;

    ALCdevice* alOutDev = nullptr;
    ALCcontext* alOutContext = nullptr;

    bool outputInitialized = false;

    // Qt containers need copy operators, so use stdlib containers
    std::unordered_set<AlSink*> sinks;
    std::unordered_set<AlSink*> soundSinks;
    std::unordered_set<AlSource*> sources;

    int channels = 0;
    qreal gain = 0;
    qreal gainFactor = 1;
    static constexpr qreal minInGain = -30;
    static constexpr qreal maxInGain = 30;
    qreal inputThreshold = 0;
    qreal voiceHold = 250;
    bool isActive = false;
    QTimer voiceTimer;
    const qreal minInThreshold = 0.0;
    const qreal maxInThreshold = 0.4;
    int16_t* inputBuffer = nullptr;
};",1,587 2000 58 777 2001 123 2002 777 58 2000 40 2003 38 2004 41 59 864 126 2000 40 41 59 2005 2006 40 41 601 123 792 1501 59 125 2005 2007 40 41 601 123 792 1500 59 125 2005 2008 40 41 601 59 865 2009 40 2005 2010 41 59 2005 2011 40 41 601 59 2005 2012 40 41 601 59 2005 2013 40 41 601 59 865 2014 40 2005 2015 41 59 2005 2016 40 41 601 59 2005 2017 40 41 601 59 2005 2018 40 41 601 59 865 2019 40 2005 2020 41 59 865 2021 40 601 2022 38 2023 41 59 569 2024 40 601 2022 38 2025 41 59 569 2026 40 41 601 59 2027 2028 40 41 59 2027 2029 40 41 59 2030 321 2031 60 2032 62 2033 40 41 59 865 2034 40 2035 38 2036 41 59 2030 321 2031 60 2037 62 2038 40 41 59 865 2039 40 2040 38 2041 41 59 865 2042 40 2043 2044 41 59 865 2045 40 2043 2044 41 59 865 2046 40 2035 38 2036 44 601 2032 321 2047 38 2048 41 59 865 2049 40 41 59 865 2050 40 2043 2044 44 601 2051 42 2052 44 704 2053 44 856 2054 44 704 2055 41 59 2056 58 865 2057 40 2005 2058 41 59 775 58 809 865 2059 40 41 748 59 809 865 2060 40 2061 42 2062 41 748 59 2005 2063 40 41 601 59 864 865 2064 40 41 59 864 865 2065 40 41 59 569 2066 40 41 59 569 2067 40 41 59 569 2068 40 601 2022 38 2069 44 2070 2054 41 59 865 2071 40 41 59 864 865 2072 40 41 59 864 865 2073 40 41 59 864 865 2074 40 2061 42 2062 44 2051 42 2075 44 2076 2053 41 59 773 58 864 569 2068 40 601 2022 38 2069 41 59 864 569 2077 40 601 2022 38 2078 41 59 865 2079 40 2043 2044 41 59 865 2080 40 41 59 660 2081 40 41 59 775 58 2003 38 2082 59 2083 42 2084 59 740 2085 2086 59 2022 2087 123 125 59 2022 2088 123 125 59 2061 42 2089 61 753 59 2090 2091 59 2090 2092 59 2061 42 2093 61 753 59 2094 42 2095 61 753 59 569 2096 61 655 59 330 2030 321 2097 60 2035 42 62 2098 59 2030 321 2097 60 2035 42 62 2099 59 2030 321 2097 60 2040 42 62 2100 59 704 2054 61 1500 59 2005 2101 61 1500 59 2005 2102 61 1501 59 809 603 2005 2103 61 45 1503 59 809 603 2005 2104 61 1503 59 2005 2105 61 1500 59 2005 2106 61 1504 59 569 2107 61 655 59 2090 2108 59 601 2005 2109 61 1500 59 601 2005 2110 61 1500 59 2051 42 2111 61 753 59 125 59 ,"{'AvgLine': 4, 'CountLine': 117, 'CountStmt': 73, 'MaxNesting': 0, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 88, 'CountStmtDecl': 71, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 4, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 28, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 45, 'AltCountLineCode': 88, 'CountLineCodeExe': 2, 'CountLineComment': 1, 'AltAvgLineComment': 0, 'AltCountLineBlank': 28, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 1, 'CountLineInactive': 0, 'CountDeclMethodAll': 64, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.01', 'AltCountLineComment': 1, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 11, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 2, 'CountDeclMethodPrivate': 32, 'CountDeclInstanceMethod': 46, 'CountDeclMethodProtected': 12, 'CountDeclInstanceVariable': 25, 'CountDeclInstanceVariablePublic': 19, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 6}"
117602,C++,"class BMI088_Accelerometer : public BMI088
{
public:
	BMI088_Accelerometer(const I2CSPIDriverConfig &config);
	~BMI088_Accelerometer() override;

	void RunImpl() override;
	void print_status() override;

private:
	void exit_and_cleanup() override;

	// Sensor Configuration
	static constexpr uint32_t RATE{1600}; // 1600 Hz
	static constexpr float FIFO_SAMPLE_DT{1e6f / RATE};

	static constexpr int32_t FIFO_MAX_SAMPLES{math::min(FIFO::SIZE / sizeof(FIFO::DATA), sizeof(sensor_accel_fifo_s::x) / sizeof(sensor_accel_fifo_s::x[0]))};

	// Transfer data
	struct FIFOTransferBuffer {
		uint8_t cmd{static_cast<uint8_t>(Register::FIFO_LENGTH_0) | DIR_READ};
		uint8_t dummy{0};
		uint8_t FIFO_LENGTH_0{0};
		uint8_t FIFO_LENGTH_1{0};
		FIFO::DATA f[FIFO_MAX_SAMPLES] {};
	};
	// ensure no struct padding
	static_assert(sizeof(FIFOTransferBuffer) == (4 + FIFO_MAX_SAMPLES *sizeof(FIFO::DATA)));

	struct register_config_t {
		Register reg;
		uint8_t set_bits{0};
		uint8_t clear_bits{0};
	};

	int probe() override;

	bool Configure();
	void ConfigureAccel();
	void ConfigureSampleRate(int sample_rate = 0);
	void ConfigureFIFOWatermark(uint8_t samples);

	static int DataReadyInterruptCallback(int irq, void *context, void *arg);
	void DataReady();
	bool DataReadyInterruptConfigure();
	bool DataReadyInterruptDisable();

	bool RegisterCheck(const register_config_t &reg_cfg);

	uint8_t RegisterRead(Register reg);
	void RegisterWrite(Register reg, uint8_t value);
	void RegisterSetAndClearBits(Register reg, uint8_t setbits, uint8_t clearbits);

	uint16_t FIFOReadCount();
	bool FIFORead(const hrt_abstime &timestamp_sample, uint8_t samples);
	void FIFOReset();

	void UpdateTemperature();

	PX4Accelerometer _px4_accel;

	perf_counter_t _bad_register_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: bad register"")};
	perf_counter_t _bad_transfer_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: bad transfer"")};
	perf_counter_t _fifo_empty_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: FIFO empty"")};
	perf_counter_t _fifo_overflow_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: FIFO overflow"")};
	perf_counter_t _fifo_reset_perf{perf_alloc(PC_COUNT, MODULE_NAME""_accel: FIFO reset"")};
	perf_counter_t _drdy_missed_perf{nullptr};

	uint8_t _fifo_samples{static_cast<uint8_t>(_fifo_empty_interval_us / (1000000 / RATE))};

	uint8_t _checked_register{0};
	static constexpr uint8_t size_register_cfg{10};
	register_config_t _register_cfg[size_register_cfg] {
		// Register                        | Set bits, Clear bits
		{ Register::ACC_PWR_CONF,          0, ACC_PWR_CONF_BIT::acc_pwr_save },
		{ Register::ACC_PWR_CTRL,          ACC_PWR_CTRL_BIT::acc_enable, 0 },
		{ Register::ACC_CONF,              ACC_CONF_BIT::acc_bwp_Normal | ACC_CONF_BIT::acc_odr_1600, Bit1 | Bit0 },
		{ Register::ACC_RANGE,             ACC_RANGE_BIT::acc_range_24g, 0 },
		{ Register::FIFO_WTM_0,            0, 0 },
		{ Register::FIFO_WTM_1,            0, 0 },
		{ Register::FIFO_CONFIG_0,         FIFO_CONFIG_0_BIT::BIT1_ALWAYS | FIFO_CONFIG_0_BIT::FIFO_mode, 0 },
		{ Register::FIFO_CONFIG_1,         FIFO_CONFIG_1_BIT::BIT4_ALWAYS | FIFO_CONFIG_1_BIT::Acc_en, 0 },
		{ Register::INT1_IO_CONF,          INT1_IO_CONF_BIT::int1_out, 0 },
		{ Register::INT1_INT2_MAP_DATA,    INT1_INT2_MAP_DATA_BIT::int1_fwm, 0},
	};
};",1,587 2000 58 777 2001 123 777 58 2000 40 601 2002 38 2003 41 59 126 2000 40 41 2004 59 865 2005 40 41 2004 59 865 2006 40 41 2004 59 773 58 865 2007 40 41 2004 59 330 809 603 2008 2009 123 1505 125 59 330 809 603 660 2010 123 1507 47 2009 125 59 809 603 2011 2012 123 2013 321 2014 40 2015 321 2016 47 805 40 2015 321 2017 41 44 805 40 2018 321 2019 41 47 805 40 2018 321 2019 91 1500 93 41 41 125 59 330 816 2020 123 2021 2022 123 811 60 2021 62 40 2023 321 2024 41 124 2025 125 59 2021 2026 123 1500 125 59 2021 2027 123 1500 125 59 2021 2028 123 1500 125 59 2029 321 2030 2031 91 2012 93 123 125 59 125 59 330 810 40 805 40 2020 41 323 40 1502 43 2012 42 805 40 2032 321 2033 41 41 41 59 816 2034 123 2035 2036 59 2037 2038 123 1500 125 59 2037 2039 123 1500 125 59 125 59 704 2040 40 41 2004 59 569 2041 40 41 59 865 2042 40 41 59 865 2043 40 704 2044 61 1500 41 59 865 2045 40 2046 2047 41 59 809 704 2048 40 704 2049 44 865 42 2050 44 865 42 2051 41 59 865 2052 40 41 59 569 2053 40 41 59 569 2054 40 41 59 569 2055 40 601 2034 38 2056 41 59 2046 2057 40 2058 2059 41 59 865 2060 40 2058 2059 44 2046 2061 41 59 865 2062 40 2058 2059 44 2046 2063 44 2046 2064 41 59 2065 2066 40 41 59 569 2067 40 601 2068 38 2069 44 2046 2047 41 59 865 2070 40 41 59 865 2071 40 41 59 2072 2073 59 2074 2075 123 2076 40 2077 44 2078 362 41 125 59 2074 2079 123 2080 40 2081 44 2082 362 41 125 59 2074 2083 123 2084 40 2085 44 2086 362 41 125 59 2074 2087 123 2088 40 2089 44 2090 362 41 125 59 2074 2091 123 2092 40 2093 44 2094 362 41 125 59 2074 2095 123 753 125 59 2046 2096 123 811 60 2046 62 40 2097 47 40 1507 47 2009 41 41 125 59 2046 2098 123 1500 125 59 809 603 2046 2099 123 1502 125 59 2034 2100 91 2099 93 123 330 123 2058 321 2101 44 1500 44 2102 321 2103 125 44 123 2058 321 2104 44 2105 321 2106 44 1500 125 44 123 2058 321 2107 44 2108 321 2109 124 2108 321 2110 44 2111 124 2112 125 44 123 2058 321 2113 44 2114 321 2115 44 1500 125 44 123 2058 321 2116 44 1500 44 1500 125 44 123 2058 321 2117 44 1500 44 1500 125 44 123 2058 321 2118 44 2119 321 2120 124 2119 321 2121 44 1500 125 44 123 2058 321 2122 44 2123 321 2124 124 2123 321 2125 44 1500 125 44 123 2058 321 2126 44 2127 321 2128 44 1500 125 44 123 2058 321 2129 44 2130 321 2131 44 1500 125 44 125 59 125 59 ,"{'AvgLine': 26, 'CountLine': 1482, 'CountStmt': 555, 'MaxNesting': 3, 'AvgLineCode': 19, 'AvgEssential': 1, 'AvgLineBlank': 4, 'CountStmtExe': 380, 'MaxEssential': 5, 'SumEssential': 66, 'AvgCyclomatic': 3, 'CountLineCode': 1058, 'CountStmtDecl': 193, 'MaxCyclomatic': 51, 'SumCyclomatic': 197, 'AltAvgLineCode': 19, 'AvgLineComment': 3, 'CountClassBase': 0, 'CountLineBlank': 271, 'CountStmtEmpty': 9, 'AltAvgLineBlank': 4, 'CountDeclMethod': 52, 'AltCountLineCode': 1058, 'CountLineCodeExe': 404, 'CountLineComment': 166, 'AltAvgLineComment': 3, 'AltCountLineBlank': 271, 'CountClassCoupled': 7, 'CountClassDerived': 0, 'CountLineCodeDecl': 191, 'CountLineInactive': 0, 'CountDeclMethodAll': 52, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.16', 'AltCountLineComment': 166, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 51, 'SumCyclomaticStrict': 201, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 8, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 51, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 179, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 44, 'CountDeclInstanceMethod': 51, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 10, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
118514,C++,"class AddFriendForm : public QObject
{
    Q_OBJECT
public:
    enum Mode
    {
        AddFriend = 0,
        ImportContacts = 1,
        FriendRequest = 2
    };

    AddFriendForm(ToxId _ownId);
    AddFriendForm(const AddFriendForm&) = delete;
    AddFriendForm& operator=(const AddFriendForm&) = delete;
    ~AddFriendForm();

    bool isShown() const;
    void show(ContentLayout* contentLayout);
    void setMode(Mode mode);

    bool addFriendRequest(const QString& friendAddress, const QString& message);

signals:
    void friendRequested(const ToxId& friendAddress, const QString& message);
    void friendRequestAccepted(const ToxPk& friendAddress);
    void friendRequestsSeen();

public slots:
    void onUsernameSet(const QString& userName);

private slots:
    void onSendTriggered();
    void onIdChanged(const QString& id);
    void onImportSendClicked();
    void onImportOpenClicked();
    void onFriendRequestAccepted();
    void onFriendRequestRejected();
    void onCurrentChanged(int index);

private:
    void addFriend(const QString& idText);
    void retranslateUi();
    void addFriendRequestWidget(const QString& friendAddress, const QString& message);
    void removeFriendRequestWidget(QWidget* friendWidget);
    void retranslateAcceptButton(QPushButton* acceptButton);
    void retranslateRejectButton(QPushButton* rejectButton);
    void deleteFriendRequest(const ToxId& toxId);
    void setIdFromClipboard();
    QString getMessage() const;
    QString getImportMessage() const;

private:
    QLabel headLabel;
    QLabel toxIdLabel;
    QLabel messageLabel;
    QLabel importFileLabel;
    QLabel importMessageLabel;

    QPushButton sendButton;
    QPushButton importFileButton;
    QPushButton importSendButton;
    QLineEdit toxId;
    QTextEdit message;
    QTextEdit importMessage;
    QVBoxLayout layout;
    QVBoxLayout headLayout;
    QVBoxLayout importContactsLayout;
    QHBoxLayout importFileLine;
    QWidget* head;
    QWidget* main;
    QWidget* importContacts;
    QString lastUsername;
    QTabWidget* tabWidget;
    QVBoxLayout* requestsLayout;
    QList<QPushButton*> acceptButtons;
    QList<QPushButton*> rejectButtons;
    QList<QString> contactsToImport;

    ToxId ownId;
};",1,587 2000 58 777 2001 123 2002 777 58 640 2003 123 2004 61 1500 44 2005 61 1501 44 2006 61 1502 125 59 2000 40 2007 2008 41 59 2000 40 601 2000 38 41 61 619 59 2000 38 758 61 40 601 2000 38 41 61 619 59 126 2000 40 41 59 569 2009 40 41 601 59 865 2010 40 2011 42 2012 41 59 865 2013 40 2003 2014 41 59 569 2015 40 601 2016 38 2017 44 601 2016 38 2018 41 59 2019 58 865 2020 40 601 2007 38 2017 44 601 2016 38 2018 41 59 865 2021 40 601 2022 38 2017 41 59 865 2023 40 41 59 777 2024 58 865 2025 40 601 2016 38 2026 41 59 773 2024 58 865 2027 40 41 59 865 2028 40 601 2016 38 2029 41 59 865 2030 40 41 59 865 2031 40 41 59 865 2032 40 41 59 865 2033 40 41 59 865 2034 40 704 2035 41 59 773 58 865 2036 40 601 2016 38 2037 41 59 865 2038 40 41 59 865 2039 40 601 2016 38 2017 44 601 2016 38 2018 41 59 865 2040 40 2041 42 2042 41 59 865 2043 40 2044 42 2045 41 59 865 2046 40 2044 42 2047 41 59 865 2048 40 601 2007 38 2049 41 59 865 2050 40 41 59 2016 2051 40 41 601 59 2016 2052 40 41 601 59 773 58 2053 2054 59 2053 2055 59 2053 2056 59 2053 2057 59 2053 2058 59 2044 2059 59 2044 2060 59 2044 2061 59 2062 2049 59 2063 2018 59 2063 2064 59 2065 2066 59 2065 2067 59 2065 2068 59 2069 2070 59 2041 42 2071 59 2041 42 2072 59 2041 42 2073 59 2016 2074 59 2075 42 2076 59 2065 42 2077 59 2078 60 2044 42 62 2079 59 2078 60 2044 42 62 2080 59 2078 60 2016 62 2081 59 2007 2082 59 125 59 ,"{'AvgLine': 14, 'CountLine': 439, 'CountStmt': 146, 'MaxNesting': 2, 'AvgLineCode': 13, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 51, 'MaxEssential': 3, 'SumEssential': 28, 'AvgCyclomatic': 1, 'CountLineCode': 384, 'CountStmtDecl': 104, 'MaxCyclomatic': 4, 'SumCyclomatic': 37, 'AltAvgLineCode': 13, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 43, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 33, 'AltCountLineCode': 384, 'CountLineCodeExe': 42, 'CountLineComment': 14, 'AltAvgLineComment': 0, 'AltCountLineBlank': 43, 'CountClassCoupled': 11, 'CountClassDerived': 0, 'CountLineCodeDecl': 76, 'CountLineInactive': 0, 'CountDeclMethodAll': 33, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 14, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 4, 'SumCyclomaticStrict': 37, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 3, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 12, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 99, 'SumCyclomaticModified': 37, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 21, 'CountDeclInstanceMethod': 33, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 28, 'CountDeclInstanceVariablePublic': 27, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
118180,C++,"class BMI055_Gyroscope : public BMI055
{
public:
	BMI055_Gyroscope(const I2CSPIDriverConfig &config);
	~BMI055_Gyroscope() override;

	void RunImpl() override;
	void print_status() override;

private:
	void exit_and_cleanup() override;

	// Sensor Configuration
	static constexpr uint32_t RATE{2000}; // 2000 Hz
	static constexpr float FIFO_SAMPLE_DT{1e6f / RATE};

	static constexpr int32_t FIFO_MAX_SAMPLES{math::min(FIFO::SIZE / sizeof(FIFO::DATA), sizeof(sensor_gyro_fifo_s::x) / sizeof(sensor_gyro_fifo_s::x[0]))};

	// Transfer data
	struct FIFOTransferBuffer {
		uint8_t cmd{static_cast<uint8_t>(Register::FIFO_DATA) | DIR_READ};
		FIFO::DATA f[FIFO_MAX_SAMPLES] {};
	};
	// ensure no struct padding
	static_assert(sizeof(FIFOTransferBuffer) == (1 + FIFO_MAX_SAMPLES *sizeof(FIFO::DATA)));

	struct register_config_t {
		Register reg;
		uint8_t set_bits{0};
		uint8_t clear_bits{0};
	};

	int probe() override;

	bool Configure();
	void ConfigureGyro();
	void ConfigureSampleRate(int sample_rate = 0);
	void ConfigureFIFOWatermark(uint8_t samples);

	static int DataReadyInterruptCallback(int irq, void *context, void *arg);
	void DataReady();
	bool DataReadyInterruptConfigure();
	bool DataReadyInterruptDisable();

	bool RegisterCheck(const register_config_t &reg_cfg);

	uint8_t RegisterRead(Register reg);
	void RegisterWrite(Register reg, uint8_t value);
	void RegisterSetAndClearBits(Register reg, uint8_t setbits, uint8_t clearbits);

	bool FIFORead(const hrt_abstime &timestamp_sample, uint8_t samples);
	void FIFOReset();

	PX4Gyroscope _px4_gyro;

	perf_counter_t _bad_register_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: bad register"")};
	perf_counter_t _bad_transfer_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: bad transfer"")};
	perf_counter_t _fifo_empty_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: FIFO empty"")};
	perf_counter_t _fifo_overflow_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: FIFO overflow"")};
	perf_counter_t _fifo_reset_perf{perf_alloc(PC_COUNT, MODULE_NAME""_gyro: FIFO reset"")};
	perf_counter_t _drdy_missed_perf{nullptr};

	uint8_t _fifo_samples{static_cast<uint8_t>(_fifo_empty_interval_us / (1000000 / RATE))};

	uint8_t _checked_register{0};
	static constexpr uint8_t size_register_cfg{8};
	register_config_t _register_cfg[size_register_cfg] {
		// Register                    | Set bits, Clear bits
		{ Register::RANGE,             RANGE_BIT::gyro_range_2000_dps, 0 },
		{ Register::RATE_HBW,          RATE_HBW_BIT::data_high_bw, 0 },
		{ Register::INT_EN_0,          INT_EN_0_BIT::fifo_en, 0 },
		{ Register::INT_EN_1,          0, INT_EN_1_BIT::int1_od | INT_EN_1_BIT::int1_lvl },
		{ Register::INT_MAP_1,         INT_MAP_1_BIT::int1_fifo, 0 },
		{ Register::FIFO_WM_ENABLE,    FIFO_WM_ENABLE_BIT::fifo_wm_enable, 0 },
		{ Register::FIFO_CONFIG_0,     0, FIFO_CONFIG_0_BIT::tag }, // fifo_water_mark_level_trigger_retain<6:0>
		{ Register::FIFO_CONFIG_1,     FIFO_CONFIG_1_BIT::fifo_mode, 0 },
	};
};",1,587 2000 58 777 2001 123 777 58 2000 40 601 2002 38 2003 41 59 126 2000 40 41 2004 59 865 2005 40 41 2004 59 865 2006 40 41 2004 59 773 58 865 2007 40 41 2004 59 330 809 603 2008 2009 123 1505 125 59 330 809 603 660 2010 123 1507 47 2009 125 59 809 603 2011 2012 123 2013 321 2014 40 2015 321 2016 47 805 40 2015 321 2017 41 44 805 40 2018 321 2019 41 47 805 40 2018 321 2019 91 1500 93 41 41 125 59 330 816 2020 123 2021 2022 123 811 60 2021 62 40 2023 321 2024 41 124 2025 125 59 2026 321 2027 2028 91 2012 93 123 125 59 125 59 330 810 40 805 40 2020 41 323 40 1501 43 2012 42 805 40 2029 321 2030 41 41 41 59 816 2031 123 2032 2033 59 2034 2035 123 1500 125 59 2034 2036 123 1500 125 59 125 59 704 2037 40 41 2004 59 569 2038 40 41 59 865 2039 40 41 59 865 2040 40 704 2041 61 1500 41 59 865 2042 40 2043 2044 41 59 809 704 2045 40 704 2046 44 865 42 2047 44 865 42 2048 41 59 865 2049 40 41 59 569 2050 40 41 59 569 2051 40 41 59 569 2052 40 601 2031 38 2053 41 59 2043 2054 40 2055 2056 41 59 865 2057 40 2055 2056 44 2043 2058 41 59 865 2059 40 2055 2056 44 2043 2060 44 2043 2061 41 59 569 2062 40 601 2063 38 2064 44 2043 2044 41 59 865 2065 40 41 59 2066 2067 59 2068 2069 123 2070 40 2071 44 2072 362 41 125 59 2068 2073 123 2074 40 2075 44 2076 362 41 125 59 2068 2077 123 2078 40 2079 44 2080 362 41 125 59 2068 2081 123 2082 40 2083 44 2084 362 41 125 59 2068 2085 123 2086 40 2087 44 2088 362 41 125 59 2068 2089 123 753 125 59 2043 2090 123 811 60 2043 62 40 2091 47 40 1507 47 2009 41 41 125 59 2043 2092 123 1500 125 59 809 603 2043 2093 123 1502 125 59 2031 2094 91 2093 93 123 330 123 2055 321 2095 44 2096 321 2097 44 1500 125 44 123 2055 321 2098 44 2099 321 2100 44 1500 125 44 123 2055 321 2101 44 2102 321 2103 44 1500 125 44 123 2055 321 2104 44 1500 44 2105 321 2106 124 2105 321 2107 125 44 123 2055 321 2108 44 2109 321 2110 44 1500 125 44 123 2055 321 2111 44 2112 321 2113 44 1500 125 44 123 2055 321 2114 44 1500 44 2115 321 2116 125 44 330 123 2055 321 2117 44 2118 321 2119 44 1500 125 44 125 59 125 59 ,"{'AvgLine': 20, 'CountLine': 480, 'CountStmt': 141, 'MaxNesting': 1, 'AvgLineCode': 15, 'AvgEssential': 1, 'AvgLineBlank': 3, 'CountStmtExe': 65, 'MaxEssential': 1, 'SumEssential': 20, 'AvgCyclomatic': 2, 'CountLineCode': 360, 'CountStmtDecl': 81, 'MaxCyclomatic': 6, 'SumCyclomatic': 42, 'AltAvgLineCode': 15, 'AvgLineComment': 1, 'CountClassBase': 0, 'CountLineBlank': 88, 'CountStmtEmpty': 5, 'AltAvgLineBlank': 3, 'CountDeclMethod': 20, 'AltCountLineCode': 360, 'CountLineCodeExe': 69, 'CountLineComment': 34, 'AltAvgLineComment': 1, 'AltCountLineBlank': 88, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 51, 'CountLineInactive': 0, 'CountDeclMethodAll': 20, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 34, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 45, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 97, 'SumCyclomaticModified': 38, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 16, 'CountDeclInstanceMethod': 20, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 10, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
118512,C++,"class ContentDialog : public ActivateDialog, public IDialogs
{
    Q_OBJECT
public:
    explicit ContentDialog(const Core& core, QWidget* parent = nullptr);
    ~ContentDialog() override;

    FriendWidget* addFriend(std::shared_ptr<FriendChatroom> chatroom, GenericChatForm* form);
    GroupWidget* addGroup(std::shared_ptr<GroupChatroom> chatroom, GenericChatForm* form);
    void removeFriend(const ToxPk& friendPk) override;
    void removeGroup(const GroupId& groupId) override;
    int chatroomCount() const override;
    void ensureSplitterVisible();
    void updateTitleAndStatusIcon();

    void cycleContacts(bool forward, bool loop = true);
    void onVideoShow(QSize size);
    void onVideoHide();

    void addFriendWidget(FriendWidget* widget, Status::Status status);
    bool isActiveWidget(GenericChatroomWidget* widget);

    bool hasContact(const ContactId& contactId) const override;
    bool isContactActive(const ContactId& contactId) const override;

    void focusContact(const ContactId& friendPk);
    void updateFriendStatus(const ToxPk& friendPk, Status::Status status);
    void updateContactStatusLight(const ContactId& contactId);

    void setStatusMessage(const ToxPk& friendPk, const QString& message);

signals:
    void friendDialogShown(const Friend* f);
    void groupDialogShown(Group* g);
    void addFriendDialog(Friend* frnd, ContentDialog* contentDialog);
    void addGroupDialog(Group* group, ContentDialog* contentDialog);
    void activated();
    void willClose();
    void connectFriendWidget(FriendWidget& friendWidget);

public slots:
    void reorderLayouts(bool newGroupOnTop);
    void previousContact();
    void nextContact();
    void setUsername(const QString& newName);
    void reloadTheme() override;

protected:
    bool event(QEvent* event) final;
    void dragEnterEvent(QDragEnterEvent* event) final;
    void dropEvent(QDropEvent* event) final;
    void changeEvent(QEvent* event) override;
    void resizeEvent(QResizeEvent* event) override;
    void moveEvent(QMoveEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

public slots:
    void activate(GenericChatroomWidget* widget);

private slots:
    void updateFriendWidget(const ToxPk& friendPk, QString alias);
    void onGroupchatPositionChanged(bool top);

private:
    void closeIfEmpty();
    void closeEvent(QCloseEvent* event) override;

    void retranslateUi();
    void saveDialogGeometry();
    void saveSplitterState();
    QLayout* nextLayout(QLayout* layout, bool forward) const;
    int getCurrentLayout(QLayout*& layout);
    void focusCommon(const ContactId& id, QHash<const ContactId&, GenericChatroomWidget*> list);

private:
    QList<QLayout*> layouts;
    QSplitter* splitter;
    QScrollArea* friendScroll;
    FriendListLayout* friendLayout;
    GenericChatItemLayout groupLayout;
    ContentLayout* contentLayout;
    GenericChatroomWidget* activeChatroomWidget;
    QSize videoSurfaceSize;
    int videoCount;

    QHash<const ContactId&, GenericChatroomWidget*> contactWidgets;
    QHash<const ContactId&, GenericChatForm*> contactChatForms;

    QString username;
};",1,587 2000 58 777 2001 44 777 2002 123 2003 777 58 648 2000 40 601 2004 38 2005 44 2006 42 2007 61 753 41 59 126 2000 40 41 2008 59 2009 42 2010 40 2011 321 2012 60 2013 62 2014 44 2015 42 2016 41 59 2017 42 2018 40 2011 321 2012 60 2019 62 2014 44 2015 42 2016 41 59 865 2020 40 601 2021 38 2022 41 2008 59 865 2023 40 601 2024 38 2025 41 2008 59 704 2026 40 41 601 2008 59 865 2027 40 41 59 865 2028 40 41 59 865 2029 40 569 2030 44 569 2031 61 829 41 59 865 2032 40 2033 2034 41 59 865 2035 40 41 59 865 2036 40 2009 42 2037 44 2038 321 2038 2039 41 59 569 2040 40 2041 42 2037 41 59 569 2042 40 601 2043 38 2044 41 601 2008 59 569 2045 40 601 2043 38 2044 41 601 2008 59 865 2046 40 601 2043 38 2022 41 59 865 2047 40 601 2021 38 2022 44 2038 321 2038 2039 41 59 865 2048 40 601 2043 38 2044 41 59 865 2049 40 601 2021 38 2022 44 601 2050 38 2051 41 59 2052 58 865 2053 40 601 2054 42 2055 41 59 865 2056 40 2057 42 2058 41 59 865 2059 40 2054 42 2060 44 2000 42 2061 41 59 865 2062 40 2057 42 2063 44 2000 42 2061 41 59 865 2064 40 41 59 865 2065 40 41 59 865 2066 40 2009 38 2067 41 59 777 2068 58 865 2069 40 569 2070 41 59 865 2071 40 41 59 865 2072 40 41 59 865 2073 40 601 2050 38 2074 41 59 865 2075 40 41 2008 59 775 58 569 2076 40 2077 42 2076 41 2078 59 865 2079 40 2080 42 2076 41 2078 59 865 2081 40 2082 42 2076 41 2078 59 865 2083 40 2077 42 2076 41 2008 59 865 2084 40 2085 42 2076 41 2008 59 865 2086 40 2087 42 2076 41 2008 59 865 2088 40 2089 42 2076 41 2008 59 777 2068 58 865 2090 40 2041 42 2037 41 59 773 2068 58 865 2091 40 601 2021 38 2022 44 2050 2092 41 59 865 2093 40 569 2094 41 59 773 58 865 2095 40 41 59 865 2096 40 2097 42 2076 41 2008 59 865 2098 40 41 59 865 2099 40 41 59 865 2100 40 41 59 2101 42 2102 40 2101 42 2103 44 569 2030 41 601 59 704 2104 40 2101 42 38 2103 41 59 865 2105 40 601 2043 38 2106 44 2107 60 601 2043 38 44 2041 42 62 2108 41 59 773 58 2109 60 2101 42 62 2110 59 2111 42 2112 59 2113 42 2114 59 2115 42 2116 59 2117 2118 59 2119 42 2120 59 2041 42 2121 59 2033 2122 59 704 2123 59 2107 60 601 2043 38 44 2041 42 62 2124 59 2107 60 601 2043 38 44 2015 42 62 2125 59 2050 2126 59 125 59 ,"{'AvgLine': 13, 'CountLine': 658, 'CountStmt': 260, 'MaxNesting': 2, 'AvgLineCode': 11, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 138, 'MaxEssential': 5, 'SumEssential': 56, 'AvgCyclomatic': 2, 'CountLineCode': 556, 'CountStmtDecl': 143, 'MaxCyclomatic': 7, 'SumCyclomatic': 86, 'AltAvgLineCode': 11, 'AvgLineComment': 0, 'CountClassBase': 2, 'CountLineBlank': 82, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 52, 'AltCountLineCode': 564, 'CountLineCodeExe': 135, 'CountLineComment': 13, 'AltAvgLineComment': 0, 'AltCountLineBlank': 82, 'CountClassCoupled': 35, 'CountClassDerived': 0, 'CountLineCodeDecl': 119, 'CountLineInactive': 2, 'CountDeclMethodAll': 65, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.02', 'AltCountLineComment': 13, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 16, 'SumCyclomaticStrict': 96, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 4, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 17, 'CountLinePreprocessor': 6, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 97, 'SumCyclomaticModified': 86, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 33, 'CountDeclInstanceMethod': 54, 'CountDeclMethodProtected': 2, 'CountDeclInstanceVariable': 16, 'CountDeclInstanceVariablePublic': 9, 'CountDeclInstanceVariablePrivate': 7, 'CountDeclInstanceVariableProtected': 0}"
99078,C++,"class VFKDataBlockSQLite : public IVFKDataBlock
{
private:
    sqlite3_stmt        *m_hStmt;

    bool                 SetGeometryLineString(VFKFeatureSQLite *, OGRLineString *,
                                               bool&, const char *,
                                               std::vector<int>&, int&);

    int                  LoadGeometryPoint() override;
    int                  LoadGeometryLineStringSBP() override;
    int                  LoadGeometryLineStringHP() override;
    int                  LoadGeometryPolygon() override;

    bool                 LoadGeometryFromDB();
    OGRErr               SaveGeometryToDB(const OGRGeometry *, int);

    OGRErr               LoadProperties() override;
    OGRErr               CleanProperties() override;

    static bool          IsRingClosed(const OGRLinearRing *);
    void                 UpdateVfkBlocks(int);
    void                 UpdateFID(GIntBig, std::vector<int>);

    friend class         VFKFeatureSQLite;
public:
    VFKDataBlockSQLite(const char *, const IVFKReader *);

    const char          *GetKey() const;
    IVFKFeature         *GetFeature(GIntBig);
    VFKFeatureSQLite    *GetFeature( const char *, GUIntBig, bool = false );
    VFKFeatureSQLite    *GetFeature( const char **, GUIntBig *, int,
                                     bool = false);
    VFKFeatureSQLiteList GetFeatures(const char **, GUIntBig *, int);

    int                  GetGeometrySQLType() const;

    OGRErr               AddGeometryColumn() const;
};",1,587 2000 58 777 2001 123 773 58 2002 42 2003 59 569 2004 40 2005 42 44 2006 42 44 569 38 44 601 582 42 44 2007 321 2008 60 704 62 38 44 704 38 41 59 704 2009 40 41 2010 59 704 2011 40 41 2010 59 704 2012 40 41 2010 59 704 2013 40 41 2010 59 569 2014 40 41 59 2015 2016 40 601 2017 42 44 704 41 59 2015 2018 40 41 2010 59 2015 2019 40 41 2010 59 809 569 2020 40 601 2021 42 41 59 865 2022 40 704 41 59 865 2023 40 2024 44 2007 321 2008 60 704 62 41 59 667 587 2005 59 777 58 2000 40 601 582 42 44 601 2025 42 41 59 601 582 42 2026 40 41 601 59 2027 42 2028 40 2024 41 59 2005 42 2028 40 601 582 42 44 2029 44 569 61 655 41 59 2005 42 2028 40 601 582 42 42 44 2029 42 44 704 44 569 61 655 41 59 2030 2031 40 601 582 42 42 44 2029 42 44 704 41 59 704 2032 40 41 601 59 2015 2033 40 41 601 59 125 59 ,"{'AvgLine': 55, 'CountLine': 1141, 'CountStmt': 477, 'MaxNesting': 4, 'AvgLineCode': 43, 'AvgEssential': 3, 'AvgLineBlank': 7, 'CountStmtExe': 372, 'MaxEssential': 12, 'SumEssential': 71, 'AvgCyclomatic': 6, 'CountLineCode': 903, 'CountStmtDecl': 169, 'MaxCyclomatic': 23, 'SumCyclomatic': 128, 'AltAvgLineCode': 44, 'AvgLineComment': 3, 'CountClassBase': 1, 'CountLineBlank': 157, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 7, 'CountDeclMethod': 20, 'AltCountLineCode': 925, 'CountLineCodeExe': 486, 'CountLineComment': 78, 'AltAvgLineComment': 3, 'AltCountLineBlank': 157, 'CountClassCoupled': 14, 'CountClassDerived': 0, 'CountLineCodeDecl': 177, 'CountLineInactive': 19, 'CountDeclMethodAll': 54, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 78, 'AvgCyclomaticStrict': 7, 'MaxCyclomaticStrict': 26, 'SumCyclomaticStrict': 154, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 3, 'AvgCyclomaticModified': 6, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 10, 'CountLinePreprocessor': 3, 'MaxCyclomaticModified': 23, 'PercentLackOfCohesion': 88, 'SumCyclomaticModified': 128, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 10, 'CountDeclInstanceMethod': 24, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
118492,C++,"class ChatHistory : public IChatLog
{
    Q_OBJECT
public:
    ChatHistory(Friend& f_, History* history_, const ICoreIdHandler& coreIdHandler,
                const Settings& settings, IMessageDispatcher& messageDispatcher);
    const ChatLogItem& at(ChatLogIdx idx) const override;
    SearchResult searchForward(SearchPos startIdx, const QString& phrase,
                               const ParameterSearch& parameter) const override;
    SearchResult searchBackward(SearchPos startIdx, const QString& phrase,
                                const ParameterSearch& parameter) const override;
    ChatLogIdx getFirstIdx() const override;
    ChatLogIdx getNextIdx() const override;
    std::vector<DateChatLogIdxPair> getDateIdxs(const QDate& startDate, size_t maxDates) const override;
    void addSystemMessage(const SystemMessage& message) override;

public slots:
    void onFileUpdated(const ToxPk& sender, const ToxFile& file);
    void onFileTransferRemotePausedUnpaused(const ToxPk& sender, const ToxFile& file, bool paused);
    void onFileTransferBrokenUnbroken(const ToxPk& sender, const ToxFile& file, bool broken);


private slots:
    void onMessageReceived(const ToxPk& sender, const Message& message);
    void onMessageSent(DispatchedMessageId id, const Message& message);
    void onMessageComplete(DispatchedMessageId id);
    void onMessageBroken(DispatchedMessageId id, BrokenMessageReason reason);

private:
    void ensureIdxInSessionChatLog(ChatLogIdx idx) const;
    void loadHistoryIntoSessionChatLog(ChatLogIdx start) const;
    void dispatchUnsentMessages(IMessageDispatcher& messageDispatcher);
    void handleDispatchedMessage(DispatchedMessageId dispatchId, RowId historyId);
    void completeMessage(DispatchedMessageId id);
    void breakMessage(DispatchedMessageId id, BrokenMessageReason reason);
    bool canUseHistory() const;
    ChatLogIdx getInitialChatLogIdx() const;

    Friend& f;
    History* history;
    const Settings& settings;
    const ICoreIdHandler& coreIdHandler;
    mutable SessionChatLog sessionChatLog;

    // If a message completes before it's inserted into history it will end up
    // in this set
    QSet<DispatchedMessageId> completedMessages;
    // If a message breaks before it's inserted into history it will end up
    // in this set
    QMap<DispatchedMessageId, BrokenMessageReason> brokenMessages;

    // If a message is inserted into history before it gets a completion
    // callback it will end up in this map
    QMap<DispatchedMessageId, RowId> dispatchedMessageRowIdMap;
};",1,587 2000 58 777 2001 123 2002 777 58 2000 40 2003 38 2004 44 2005 42 2006 44 601 2007 38 2008 44 601 2009 38 2010 44 2011 38 2012 41 59 601 2013 38 2014 40 2015 2016 41 601 2017 59 2018 2019 40 2020 2021 44 601 2022 38 2023 44 601 2024 38 2025 41 601 2017 59 2018 2026 40 2020 2021 44 601 2022 38 2023 44 601 2024 38 2025 41 601 2017 59 2015 2027 40 41 601 2017 59 2015 2028 40 41 601 2017 59 2029 321 2030 60 2031 62 2032 40 601 2033 38 2034 44 2035 2036 41 601 2017 59 865 2037 40 601 2038 38 2039 41 2017 59 777 2040 58 865 2041 40 601 2042 38 2043 44 601 2044 38 2045 41 59 865 2046 40 601 2042 38 2043 44 601 2044 38 2045 44 569 2047 41 59 865 2048 40 601 2042 38 2043 44 601 2044 38 2045 44 569 2049 41 59 773 2040 58 865 2050 40 601 2042 38 2043 44 601 2051 38 2039 41 59 865 2052 40 2053 2054 44 601 2051 38 2039 41 59 865 2055 40 2053 2054 41 59 865 2056 40 2053 2054 44 2057 2058 41 59 773 58 865 2059 40 2015 2016 41 601 59 865 2060 40 2015 2061 41 601 59 865 2062 40 2011 38 2012 41 59 865 2063 40 2053 2064 44 2065 2066 41 59 865 2067 40 2053 2054 41 59 865 2068 40 2053 2054 44 2057 2058 41 59 569 2069 40 41 601 59 2015 2070 40 41 601 59 2003 38 2071 59 2005 42 2072 59 601 2009 38 2010 59 601 2007 38 2008 59 740 2073 2074 59 330 330 2075 60 2053 62 2076 59 330 330 2077 60 2053 44 2057 62 2078 59 330 330 2077 60 2053 44 2065 62 2079 59 125 59 ,"{'AvgLine': 17, 'CountLine': 459, 'CountStmt': 123, 'MaxNesting': 2, 'AvgLineCode': 13, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 47, 'MaxEssential': 5, 'SumEssential': 27, 'AvgCyclomatic': 2, 'CountLineCode': 356, 'CountStmtDecl': 81, 'MaxCyclomatic': 8, 'SumCyclomatic': 52, 'AltAvgLineCode': 13, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 55, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 23, 'AltCountLineCode': 356, 'CountLineCodeExe': 58, 'CountLineComment': 48, 'AltAvgLineComment': 1, 'AltCountLineBlank': 55, 'CountClassCoupled': 15, 'CountClassDerived': 0, 'CountLineCodeDecl': 74, 'CountLineInactive': 0, 'CountDeclMethodAll': 30, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.13', 'AltCountLineComment': 48, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 53, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 10, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 18, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 94, 'SumCyclomaticModified': 47, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 5, 'CountDeclInstanceMethod': 29, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 10, 'CountDeclInstanceVariablePublic': 6, 'CountDeclInstanceVariablePrivate': 4, 'CountDeclInstanceVariableProtected': 0}"
117618,C++,"class PX4Accelerometer
{
public:
	PX4Accelerometer(uint32_t device_id, enum Rotation rotation = ROTATION_NONE);
	~PX4Accelerometer();

	uint32_t get_device_id() const { return _device_id; }

	int32_t get_max_rate_hz() const { return math::constrain(_imu_gyro_rate_max, static_cast<int32_t>(100), static_cast<int32_t>(4000)); }

	void set_device_id(uint32_t device_id) { _device_id = device_id; }
	void set_device_type(uint8_t devtype);
	void set_error_count(uint32_t error_count) { _error_count = error_count; }
	void increase_error_count() { _error_count++; }
	void set_range(float range) { _range = range; UpdateClipLimit(); }
	void set_scale(float scale);
	void set_temperature(float temperature) { _temperature = temperature; }

	void update(const hrt_abstime &timestamp_sample, float x, float y, float z);

	void updateFIFO(sensor_accel_fifo_s &sample);

	int get_instance() { return _sensor_pub.get_instance(); };

private:
	void UpdateClipLimit();

	uORB::PublicationMulti<sensor_accel_s> _sensor_pub{ORB_ID(sensor_accel)};
	uORB::PublicationMulti<sensor_accel_fifo_s>  _sensor_fifo_pub{ORB_ID(sensor_accel_fifo)};

	uint32_t		_device_id{0};
	const enum Rotation	_rotation;

	int32_t			_imu_gyro_rate_max{0}; // match gyro max rate

	float			_range{16 * CONSTANTS_ONE_G};
	float			_scale{1.f};
	float			_temperature{NAN};

	float			_clip_limit{_range / _scale};

	uint32_t		_error_count{0};

	int16_t			_last_sample[3] {};
};",1,587 2000 123 777 58 2000 40 2001 2002 44 640 2003 2004 61 2005 41 59 126 2000 40 41 59 2001 2006 40 41 601 123 792 2007 59 125 2008 2009 40 41 601 123 792 2010 321 2011 40 2012 44 811 60 2008 62 40 1503 41 44 811 60 2008 62 40 1505 41 41 59 125 865 2013 40 2001 2002 41 123 2014 61 2002 59 125 865 2015 40 2016 2017 41 59 865 2018 40 2001 2019 41 123 2020 61 2019 59 125 865 2021 40 41 123 2022 349 59 125 865 2023 40 660 2024 41 123 2025 61 2024 59 2026 40 41 59 125 865 2027 40 660 2028 41 59 865 2029 40 660 2030 41 123 2031 61 2030 59 125 865 2032 40 601 2033 38 2034 44 660 2035 44 660 2036 44 660 2037 41 59 865 2038 40 2039 38 2040 41 59 704 2041 40 41 123 792 2042 46 2041 40 41 59 125 59 773 58 865 2043 40 41 59 2044 321 2045 60 2046 62 2047 123 2048 40 2049 41 125 59 2044 321 2045 60 2039 62 2050 123 2051 40 2052 41 125 59 2001 2053 123 1500 125 59 601 640 2003 2054 59 2008 2055 123 1500 125 59 330 660 2056 123 1503 42 2057 125 59 660 2058 123 1501 125 59 660 2059 123 2060 125 59 660 2061 123 2056 47 2058 125 59 2001 2062 123 1500 125 59 2063 2064 91 1502 93 123 125 59 125 59 ,"{'AvgLine': 7, 'CountLine': 154, 'CountStmt': 55, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 19, 'MaxEssential': 1, 'SumEssential': 15, 'AvgCyclomatic': 1, 'CountLineCode': 112, 'CountStmtDecl': 39, 'MaxCyclomatic': 3, 'SumCyclomatic': 18, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 31, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 15, 'AltCountLineCode': 112, 'CountLineCodeExe': 19, 'CountLineComment': 12, 'AltAvgLineComment': 0, 'AltCountLineBlank': 31, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 24, 'CountLineInactive': 0, 'CountDeclMethodAll': 15, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.11', 'AltCountLineComment': 12, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 18, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 14, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 89, 'SumCyclomaticModified': 18, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 15, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 11, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 9, 'CountDeclInstanceVariableProtected': 0}"
98823,C++,"class CPL_DLL VSIFilesystemHandler {

public:

    virtual ~VSIFilesystemHandler() {}

    VSIVirtualHandle *Open( const char *pszFilename,
                            const char *pszAccess );

    virtual VSIVirtualHandle *Open( const char *pszFilename,
                                    const char *pszAccess,
                                    bool bSetError,
                                    CSLConstList papszOptions ) = 0;
    virtual int Stat( const char *pszFilename, VSIStatBufL *pStatBuf, int nFlags) = 0;
    virtual int Unlink( const char *pszFilename )
                      { (void) pszFilename; errno=ENOENT; return -1; }
    virtual int* UnlinkBatch( CSLConstList papszFiles );
    virtual int Mkdir( const char *pszDirname, long nMode )
                      {(void)pszDirname; (void)nMode; errno=ENOENT; return -1;}
    virtual int Rmdir( const char *pszDirname )
                      { (void) pszDirname; errno=ENOENT; return -1; }
    virtual int RmdirRecursive( const char *pszDirname );
    virtual char **ReadDir( const char *pszDirname )
                      { (void) pszDirname; return nullptr; }
    virtual char **ReadDirEx( const char *pszDirname, int /* nMaxFiles */ )
                      { return ReadDir(pszDirname); }
    virtual char **SiblingFiles( const char * /*pszFilename*/ )
                      { return nullptr; }
    virtual int Rename( const char *oldpath, const char *newpath )
                      { (void) oldpath; (void)newpath; errno=ENOENT; return -1; }
    virtual int IsCaseSensitive( const char* pszFilename )
                      { (void) pszFilename; return TRUE; }
    virtual GIntBig GetDiskFreeSpace( const char* /* pszDirname */ ) { return -1; }
    virtual int SupportsSparseFiles( const char* /* pszPath */ ) { return FALSE; }
    virtual int HasOptimizedReadMultiRange(const char* /* pszPath */) { return FALSE; }
    virtual const char* GetActualURL(const char* /*pszFilename*/) { return nullptr; }
    virtual const char* GetOptions() { return nullptr; }
    virtual char* GetSignedURL(const char* /*pszFilename*/, CSLConstList /* papszOptions */) { return nullptr; }
    virtual bool Sync( const char* pszSource, const char* pszTarget,
                            const char* const * papszOptions,
                            GDALProgressFunc pProgressFunc,
                            void *pProgressData,
                            char*** ppapszOutputs  );

    virtual VSIDIR* OpenDir( const char *pszPath, int nRecurseDepth,
                             const char* const *papszOptions);

    virtual char** GetFileMetadata( const char * pszFilename, const char* pszDomain,
                                    CSLConstList papszOptions );

    virtual bool   SetFileMetadata( const char * pszFilename,
                                    CSLConstList papszMetadata,
                                    const char* pszDomain,
                                    CSLConstList papszOptions );

    virtual bool    AbortPendingUploads(const char* /*pszFilename*/) { return true;}

    virtual std::string GetStreamingFilename(const std::string& osFilename) const { return osFilename; }
};",1,587 2000 2001 123 777 58 864 126 2001 40 41 123 125 2002 42 2003 40 601 582 42 2004 44 601 582 42 2005 41 59 864 2002 42 2003 40 601 582 42 2004 44 601 582 42 2005 44 569 2006 44 2007 2008 41 61 1500 59 864 704 2009 40 601 582 42 2004 44 2010 42 2011 44 704 2012 41 61 1500 59 864 704 2013 40 601 582 42 2004 41 123 40 865 41 2004 59 2014 61 2015 59 792 45 1501 59 125 864 704 42 2016 40 2007 2017 41 59 864 704 2018 40 601 582 42 2019 44 726 2020 41 123 40 865 41 2019 59 40 865 41 2020 59 2021 61 2022 59 792 45 1501 59 125 864 704 2023 40 601 582 42 2019 41 123 40 865 41 2019 59 2024 61 2025 59 792 45 1501 59 125 864 704 2026 40 601 582 42 2019 41 59 864 582 42 42 2027 40 601 582 42 2019 41 123 40 865 41 2019 59 792 753 59 125 864 582 42 42 2028 40 601 582 42 2019 44 704 305 41 123 792 2027 40 2019 41 59 125 864 582 42 42 2029 40 601 582 42 305 41 123 792 753 59 125 864 704 2030 40 601 582 42 2031 44 601 582 42 2032 41 123 40 865 41 2031 59 40 865 41 2032 59 2033 61 2034 59 792 45 1501 59 125 864 704 2035 40 601 582 42 2004 41 123 40 865 41 2004 59 792 2036 59 125 864 2037 2038 40 601 582 42 305 41 123 792 45 1501 59 125 864 704 2039 40 601 582 42 305 41 123 792 2040 59 125 864 704 2041 40 601 582 42 305 41 123 792 2042 59 125 864 601 582 42 2043 40 601 582 42 305 41 123 792 753 59 125 864 601 582 42 2044 40 41 123 792 753 59 125 864 582 42 2045 40 601 582 42 305 44 2007 305 41 123 792 753 59 125 864 569 2046 40 601 582 42 2047 44 601 582 42 2048 44 601 582 42 601 42 2008 44 2049 2050 44 865 42 2051 44 582 42 42 42 2052 41 59 864 2053 42 2054 40 601 582 42 2055 44 704 2056 44 601 582 42 601 42 2008 41 59 864 582 42 42 2057 40 601 582 42 2004 44 601 582 42 2058 44 2007 2008 41 59 864 569 2059 40 601 582 42 2004 44 2007 2060 44 601 582 42 2058 44 2007 2008 41 59 864 569 2061 40 601 582 42 305 41 123 792 829 59 125 864 2062 321 2063 2064 40 601 2062 321 2063 38 2065 41 601 123 792 2065 59 125 125 59 ,"{'AvgLine': 11, 'CountLine': 321, 'CountStmt': 184, 'MaxNesting': 4, 'AvgLineCode': 11, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 148, 'MaxEssential': 18, 'SumEssential': 47, 'AvgCyclomatic': 2, 'CountLineCode': 295, 'CountStmtDecl': 68, 'MaxCyclomatic': 26, 'SumCyclomatic': 59, 'AltAvgLineCode': 11, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 24, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 26, 'AltCountLineCode': 295, 'CountLineCodeExe': 157, 'CountLineComment': 16, 'AltAvgLineComment': 0, 'AltCountLineBlank': 24, 'CountClassCoupled': 9, 'CountClassDerived': 12, 'CountLineCodeDecl': 150, 'CountLineInactive': 0, 'CountDeclMethodAll': 26, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.05', 'AltCountLineComment': 16, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 33, 'SumCyclomaticStrict': 70, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 26, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 26, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 59, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 27, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98644,C++,"class CPL_DLL VRTDataset CPL_NON_FINAL: public GDALDataset
{
    friend class VRTRasterBand;
    friend struct VRTFlushCacheStruct<VRTDataset>;
    friend struct VRTFlushCacheStruct<VRTWarpedDataset>;
    friend struct VRTFlushCacheStruct<VRTPansharpenedDataset>;
    friend class VRTSourcedRasterBand;
    friend VRTDatasetH CPL_STDCALL VRTCreate(int nXSize, int nYSize);

    OGRSpatialReference* m_poSRS = nullptr;

    int            m_bGeoTransformSet = false;
    double         m_adfGeoTransform[6];

    int            m_nGCPCount = 0;
    GDAL_GCP      *m_pasGCPList = nullptr;
    OGRSpatialReference *m_poGCP_SRS = nullptr;

    bool           m_bNeedsFlush = false;
    bool           m_bWritable = true;
    bool           m_bCanTakeRef = true;

    char          *m_pszVRTPath = nullptr;

    VRTRasterBand *m_poMaskBand = nullptr;

    int            m_bCompatibleForDatasetIO = -1;
    int            CheckCompatibleForDatasetIO();

    // Virtual (ie not materialized) overviews, created either implicitly
    // when it is cheap to do it, or explicitly.
    std::vector<GDALDataset*> m_apoOverviews{};
    std::vector<GDALDataset*> m_apoOverviewsBak{};
    CPLString           m_osOverviewResampling{};
    std::vector<int>    m_anOverviewFactors{};

    char         **m_papszXMLVRTMetadata = nullptr;

    std::map<CPLString, GDALDataset*> m_oMapSharedSources{};
    std::shared_ptr<VRTGroup> m_poRootGroup{};

    VRTRasterBand*      InitBand(const char* pszSubclass, int nBand,
                                 bool bAllowPansharpened);
    static GDALDataset *OpenVRTProtocol( const char* pszSpec );
    bool                AddVirtualOverview(int nOvFactor,
                                           const char* pszResampling);

    CPL_DISALLOW_COPY_ASSIGN(VRTDataset)

  protected:
    virtual int         CloseDependentDatasets() override;

  public:
                 VRTDataset(int nXSize, int nYSize);
    virtual ~VRTDataset();

    void          SetNeedsFlush() { m_bNeedsFlush = true; }
    virtual void  FlushCache(bool bAtClosing) override;

    void SetWritable(int bWritableIn) { m_bWritable = CPL_TO_BOOL(bWritableIn); }

    virtual CPLErr          CreateMaskBand( int nFlags ) override;
    void SetMaskBand(VRTRasterBand* poMaskBand);

    const OGRSpatialReference* GetSpatialRef() const override { return m_poSRS; }
    CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override;

    virtual CPLErr GetGeoTransform( double * ) override;
    virtual CPLErr SetGeoTransform( double * ) override;

    virtual CPLErr SetMetadata( char **papszMetadata,
                                const char *pszDomain = """" ) override;
    virtual CPLErr SetMetadataItem( const char *pszName, const char *pszValue,
                                    const char *pszDomain = """" ) override;

    virtual char** GetMetadata( const char *pszDomain = """" ) override;

    virtual int    GetGCPCount() override;
    const OGRSpatialReference* GetGCPSpatialRef() const override { return m_poGCP_SRS; }
    virtual const GDAL_GCP *GetGCPs() override;
    using GDALDataset::SetGCPs;
    CPLErr SetGCPs( int nGCPCount, const GDAL_GCP *pasGCPList,
                    const OGRSpatialReference* poSRS ) override;

    virtual CPLErr AddBand( GDALDataType eType,
                            char **papszOptions=nullptr ) override;

    virtual char      **GetFileList() override;

    virtual CPLErr  IRasterIO( GDALRWFlag eRWFlag,
                               int nXOff, int nYOff, int nXSize, int nYSize,
                               void * pData, int nBufXSize, int nBufYSize,
                               GDALDataType eBufType,
                               int nBandCount, int *panBandMap,
                               GSpacing nPixelSpace, GSpacing nLineSpace,
                               GSpacing nBandSpace,
                               GDALRasterIOExtraArg* psExtraArg) override;

    virtual CPLErr AdviseRead( int nXOff, int nYOff, int nXSize, int nYSize,
                               int nBufXSize, int nBufYSize,
                               GDALDataType eDT,
                               int nBandCount, int *panBandList,
                               char **papszOptions ) override;

    virtual CPLXMLNode *SerializeToXML( const char *pszVRTPath);
    virtual CPLErr      XMLInit( CPLXMLNode *, const char * );

    virtual CPLErr IBuildOverviews( const char *, int, int *,
                                    int, int *, GDALProgressFunc, void * ) override;

    std::shared_ptr<GDALGroup> GetRootGroup() const override;

    /* Used by PDF driver for example */
    GDALDataset*        GetSingleSimpleSource();
    void                BuildVirtualOverviews();

    void                UnsetPreservedRelativeFilenames();

    static int          Identify( GDALOpenInfo * );
    static GDALDataset *Open( GDALOpenInfo * );
    static GDALDataset *OpenXML( const char *, const char * = nullptr,
                                 GDALAccess eAccess = GA_ReadOnly );
    static GDALDataset *Create( const char * pszName,
                                int nXSize, int nYSize, int nBands,
                                GDALDataType eType, char ** papszOptions );
    static GDALDataset *CreateMultiDimensional( const char * pszFilename,
                                                CSLConstList papszRootGroupOptions,
                                                CSLConstList papszOptions );
    static CPLErr       Delete( const char * pszFilename );
};",1,587 2000 2001 2002 58 777 2003 123 667 587 2004 59 667 816 2005 60 2001 62 59 667 816 2005 60 2006 62 59 667 816 2005 60 2007 62 59 667 587 2008 59 667 2009 2010 2011 40 704 2012 44 704 2013 41 59 2014 42 2015 61 753 59 704 2016 61 655 59 625 2017 91 1502 93 59 704 2018 61 1500 59 2019 42 2020 61 753 59 2014 42 2021 61 753 59 569 2022 61 655 59 569 2023 61 829 59 569 2024 61 829 59 582 42 2025 61 753 59 2004 42 2026 61 753 59 704 2027 61 45 1501 59 704 2028 40 41 59 330 330 2029 321 2030 60 2003 42 62 2031 123 125 59 2029 321 2030 60 2003 42 62 2032 123 125 59 2033 2034 123 125 59 2029 321 2030 60 704 62 2035 123 125 59 582 42 42 2036 61 753 59 2029 321 2037 60 2033 44 2003 42 62 2038 123 125 59 2029 321 2039 60 2040 62 2041 123 125 59 2004 42 2042 40 601 582 42 2043 44 704 2044 44 569 2045 41 59 809 2003 42 2046 40 601 582 42 2047 41 59 569 2048 40 704 2049 44 601 582 42 2050 41 59 2051 40 2001 41 775 58 864 704 2052 40 41 2053 59 777 58 2001 40 704 2012 44 704 2013 41 59 864 126 2001 40 41 59 865 2054 40 41 123 2022 61 829 59 125 864 865 2055 40 569 2056 41 2053 59 865 2057 40 704 2058 41 123 2023 61 2059 40 2058 41 59 125 864 2060 2061 40 704 2062 41 2053 59 865 2063 40 2004 42 2064 41 59 601 2014 42 2065 40 41 601 2053 123 792 2015 59 125 2060 2066 40 601 2014 42 2067 41 2053 59 864 2060 2068 40 625 42 41 2053 59 864 2060 2069 40 625 42 41 2053 59 864 2060 2070 40 582 42 42 2071 44 601 582 42 2072 61 362 41 2053 59 864 2060 2073 40 601 582 42 2074 44 601 582 42 2075 44 601 582 42 2072 61 362 41 2053 59 864 582 42 42 2076 40 601 582 42 2072 61 362 41 2053 59 864 704 2077 40 41 2053 59 601 2014 42 2078 40 41 601 2053 123 792 2021 59 125 864 601 2019 42 2079 40 41 2053 59 860 2003 321 2080 59 2060 2080 40 704 2081 44 601 2019 42 2082 44 601 2014 42 2067 41 2053 59 864 2060 2083 40 2084 2085 44 582 42 42 2086 61 753 41 2053 59 864 582 42 42 2087 40 41 2053 59 864 2060 2088 40 2089 2090 44 704 2091 44 704 2092 44 704 2012 44 704 2013 44 865 42 2093 44 704 2094 44 704 2095 44 2084 2096 44 704 2097 44 704 42 2098 44 2099 2100 44 2099 2101 44 2099 2102 44 2103 42 2104 41 2053 59 864 2060 2105 40 704 2091 44 704 2092 44 704 2012 44 704 2013 44 704 2094 44 704 2095 44 2084 2106 44 704 2097 44 704 42 2107 44 582 42 42 2086 41 2053 59 864 2108 42 2109 40 601 582 42 2110 41 59 864 2060 2111 40 2108 42 44 601 582 42 41 59 864 2060 2112 40 601 582 42 44 704 44 704 42 44 704 44 704 42 44 2113 44 865 42 41 2053 59 2029 321 2039 60 2114 62 2115 40 41 601 2053 59 305 2003 42 2116 40 41 59 865 2117 40 41 59 865 2118 40 41 59 809 704 2119 40 2120 42 41 59 809 2003 42 2121 40 2120 42 41 59 809 2003 42 2122 40 601 582 42 44 601 582 42 61 753 44 2123 2124 61 2125 41 59 809 2003 42 2126 40 601 582 42 2074 44 704 2012 44 704 2013 44 704 2127 44 2084 2085 44 582 42 42 2086 41 59 809 2003 42 2128 40 601 582 42 2129 44 2130 2131 44 2130 2086 41 59 809 2060 2132 40 601 582 42 2129 41 59 125 59 ,"{'AvgLine': 45, 'CountLine': 1948, 'CountStmt': 772, 'MaxNesting': 6, 'AvgLineCode': 35, 'AvgEssential': 3, 'AvgLineBlank': 5, 'CountStmtExe': 616, 'MaxEssential': 17, 'SumEssential': 139, 'AvgCyclomatic': 5, 'CountLineCode': 1514, 'CountStmtDecl': 288, 'MaxCyclomatic': 24, 'SumCyclomatic': 221, 'AltAvgLineCode': 36, 'AvgLineComment': 3, 'CountClassBase': 1, 'CountLineBlank': 254, 'CountStmtEmpty': 11, 'AltAvgLineBlank': 5, 'CountDeclMethod': 43, 'AltCountLineCode': 1561, 'CountLineCodeExe': 1054, 'CountLineComment': 132, 'AltAvgLineComment': 3, 'AltCountLineBlank': 257, 'CountClassCoupled': 25, 'CountClassDerived': 10, 'CountLineCodeDecl': 415, 'CountLineInactive': 51, 'CountDeclMethodAll': 184, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 135, 'AvgCyclomaticStrict': 7, 'MaxCyclomaticStrict': 28, 'SumCyclomaticStrict': 280, 'CountDeclClassMethod': 7, 'CountDeclMethodConst': 3, 'AvgCyclomaticModified': 5, 'CountDeclMethodFriend': 82, 'CountDeclMethodPublic': 36, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 24, 'PercentLackOfCohesion': 94, 'SumCyclomaticModified': 221, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 6, 'CountDeclInstanceMethod': 36, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 19, 'CountDeclInstanceVariablePublic': 5, 'CountDeclInstanceVariablePrivate': 14, 'CountDeclInstanceVariableProtected': 0}"
118104,C++,"class MavlinkMissionManager
{
public:
	explicit MavlinkMissionManager(Mavlink *mavlink);

	~MavlinkMissionManager() = default;

	/**
	 * Handle sending of messages. Call this regularly at a fixed frequency.
	 * @param t current time
	 */
	void send();

	void handle_message(const mavlink_message_t *msg);

	void check_active_mission(void);

private:
	enum MAVLINK_WPM_STATES _state {MAVLINK_WPM_STATE_IDLE};	///< Current state
	enum MAV_MISSION_TYPE _mission_type {MAV_MISSION_TYPE_MISSION};	///< mission type of current transmission (only one at a time possible)

	uint64_t		_time_last_recv{0};
	uint64_t		_time_last_sent{0};

	uint8_t			_reached_sent_count{0};			///< last time when the vehicle reached a waypoint

	bool			_int_mode{false};			///< Use accurate int32 instead of float

	unsigned		_filesystem_errcount{0};		///< File system error count

	static dm_item_t		_dataman_id;				///< Global Dataman storage ID for active mission
	dm_item_t			_my_dataman_id{DM_KEY_WAYPOINTS_OFFBOARD_0};			///< class Dataman storage ID

	static bool		_dataman_init;				///< Dataman initialized

	static uint16_t		_count[3];				///< Count of items in (active) mission for each MAV_MISSION_TYPE
	static int32_t		_current_seq;				///< Current item sequence in active mission

	int32_t			_last_reached{-1};			///< Last reached waypoint in active mission (-1 means nothing reached)

	dm_item_t			_transfer_dataman_id{DM_KEY_WAYPOINTS_OFFBOARD_1};		///< Dataman storage ID for current transmission

	uint16_t		_transfer_count{0};			///< Items count in current transmission
	uint16_t		_transfer_seq{0};			///< Item sequence in current transmission

	int32_t			_transfer_current_seq{-1};		///< Current item ID for current transmission (-1 means not initialized)

	uint8_t			_transfer_partner_sysid{0};		///< Partner system ID for current transmission
	uint8_t			_transfer_partner_compid{0};		///< Partner component ID for current transmission

	static bool		_transfer_in_progress;			///< Global variable checking for current transmission

	uORB::Subscription	_mission_result_sub{ORB_ID(mission_result)};

	uORB::Publication<mission_s>	_offboard_mission_pub{ORB_ID(mission)};

	static uint16_t		_geofence_update_counter;
	static uint16_t		_safepoint_update_counter;
	bool			_geofence_locked{false};		///< if true, we currently hold the dm_lock for the geofence (transaction in progress)

	MavlinkRateLimiter	_slow_rate_limiter{100 * 1000};		///< Rate limit sending of the current WP sequence to 10 Hz

	Mavlink *_mavlink;

	static constexpr unsigned int	FILESYSTEM_ERRCOUNT_NOTIFY_LIMIT =
		2;	///< Error count limit before stopping to report FS errors
	static constexpr uint16_t	MAX_COUNT[] = {
		DM_KEY_WAYPOINTS_OFFBOARD_0_MAX,
		DM_KEY_FENCE_POINTS_MAX - 1,
		DM_KEY_SAFE_POINTS_MAX - 1
	};	/**< Maximum number of mission items for each type
					(fence & safe points use the first item for the stats) */

	/** get the maximum number of item count for the current _mission_type */
	uint16_t current_max_item_count();

	/** get the number of item count for the current _mission_type */
	uint16_t current_item_count();

	/* do not allow top copying this class */
	MavlinkMissionManager(MavlinkMissionManager &);
	MavlinkMissionManager &operator = (const MavlinkMissionManager &);

	void init_offboard_mission();

	int update_active_mission(dm_item_t dataman_id, uint16_t count, int32_t seq);

	/** store the geofence count to dataman */
	int update_geofence_count(unsigned count);

	/** store the safepoint count to dataman */
	int update_safepoint_count(unsigned count);

	/** load geofence stats from dataman */
	int load_geofence_stats();

	/** load safe point stats from dataman */
	int load_safepoint_stats();

	/**
	 *  @brief Sends an waypoint ack message
	 */
	void send_mission_ack(uint8_t sysid, uint8_t compid, uint8_t type);

	/**
	 *  @brief Broadcasts the new target waypoint and directs the MAV to fly there
	 *
	 *  This function broadcasts its new active waypoint sequence number and
	 *  sends a message to the controller, advising it to fly to the coordinates
	 *  of the waypoint with a given orientation
	 *
	 *  @param seq The waypoint sequence number the MAV should fly to.
	 */
	void send_mission_current(int32_t seq);

	void send_mission_count(uint8_t sysid, uint8_t compid, uint16_t count, MAV_MISSION_TYPE mission_type);

	void send_mission_item(uint8_t sysid, uint8_t compid, uint16_t seq);

	void send_mission_request(uint8_t sysid, uint8_t compid, uint16_t seq);

	/**
	 *  @brief emits a message that a waypoint reached
	 *
	 *  This function broadcasts a message that a waypoint is reached.
	 *
	 *  @param seq The waypoint sequence number the MAV has reached.
	 */
	void send_mission_item_reached(uint16_t seq);

	void handle_mission_ack(const mavlink_message_t *msg);

	void handle_mission_set_current(const mavlink_message_t *msg);

	void handle_mission_request_list(const mavlink_message_t *msg);

	void handle_mission_request(const mavlink_message_t *msg);
	void handle_mission_request_int(const mavlink_message_t *msg);
	void handle_mission_request_both(const mavlink_message_t *msg);

	void handle_mission_count(const mavlink_message_t *msg);

	void handle_mission_item(const mavlink_message_t *msg);
	void handle_mission_item_int(const mavlink_message_t *msg);
	void handle_mission_item_both(const mavlink_message_t *msg);

	void handle_mission_clear_all(const mavlink_message_t *msg);

	/**
	 * Parse mavlink MISSION_ITEM message to get mission_item_s.
	 *
	 * @param mavlink_mission_item pointer to mavlink_mission_item_t or mavlink_mission_item_int_t
	 *			       depending on _int_mode
	 * @param mission_item	       pointer to mission_item to construct
	 */
	int parse_mavlink_mission_item(const mavlink_mission_item_t *mavlink_mission_item, struct mission_item_s *mission_item);

	/**
	 * Format mission_item_s as mavlink MISSION_ITEM(_INT) message.
	 *
	 * @param mission_item:		pointer to the existing mission item
	 * @param mavlink_mission_item: pointer to mavlink_mission_item_t or mavlink_mission_item_int_t
	 *				depending on _int_mode.
	 */
	int format_mavlink_mission_item(const struct mission_item_s *mission_item,
					mavlink_mission_item_t *mavlink_mission_item);

	/**
	 * set _state to idle (and do necessary cleanup)
	 */
	void switch_to_idle_state();
};",1,587 2000 123 777 58 648 2000 40 2001 42 2002 41 59 126 2000 40 41 61 613 59 306 865 2003 40 41 59 865 2004 40 601 2005 42 2006 41 59 865 2007 40 865 41 59 773 58 640 2008 2009 123 2010 125 59 331 640 2011 2012 123 2013 125 59 331 2014 2015 123 1500 125 59 2014 2016 123 1500 125 59 2017 2018 123 1500 125 59 331 569 2019 123 655 125 59 331 856 2020 123 1500 125 59 331 809 2021 2022 59 331 2021 2023 123 2024 125 59 331 809 569 2025 59 331 809 2026 2027 91 1502 93 59 331 809 2028 2029 59 331 2028 2030 123 45 1501 125 59 331 2021 2031 123 2032 125 59 331 2026 2033 123 1500 125 59 331 2026 2034 123 1500 125 59 331 2028 2035 123 45 1501 125 59 331 2017 2036 123 1500 125 59 331 2017 2037 123 1500 125 59 331 809 569 2038 59 331 2039 321 2040 2041 123 2042 40 2043 41 125 59 2039 321 2044 60 2045 62 2046 123 2047 40 2048 41 125 59 809 2026 2049 59 809 2026 2050 59 569 2051 123 655 125 59 331 2052 2053 123 1503 42 1504 125 59 331 2001 42 2054 59 809 603 856 704 2055 61 1502 59 331 809 603 2026 2056 91 93 61 123 2057 44 2058 45 1501 44 2059 45 1501 125 59 306 306 2026 2060 40 41 59 306 2026 2061 40 41 59 305 2000 40 2000 38 41 59 2000 38 758 61 40 601 2000 38 41 59 865 2062 40 41 59 704 2063 40 2021 2064 44 2026 2065 44 2028 2066 41 59 306 704 2067 40 856 2065 41 59 306 704 2068 40 856 2065 41 59 306 704 2069 40 41 59 306 704 2070 40 41 59 306 865 2071 40 2017 2072 44 2017 2073 44 2017 2074 41 59 306 865 2075 40 2028 2066 41 59 865 2076 40 2017 2072 44 2017 2073 44 2026 2065 44 2011 2077 41 59 865 2078 40 2017 2072 44 2017 2073 44 2026 2066 41 59 865 2079 40 2017 2072 44 2017 2073 44 2026 2066 41 59 306 865 2080 40 2026 2066 41 59 865 2081 40 601 2005 42 2006 41 59 865 2082 40 601 2005 42 2006 41 59 865 2083 40 601 2005 42 2006 41 59 865 2084 40 601 2005 42 2006 41 59 865 2085 40 601 2005 42 2006 41 59 865 2086 40 601 2005 42 2006 41 59 865 2087 40 601 2005 42 2006 41 59 865 2088 40 601 2005 42 2006 41 59 865 2089 40 601 2005 42 2006 41 59 865 2090 40 601 2005 42 2006 41 59 865 2091 40 601 2005 42 2006 41 59 306 704 2092 40 601 2093 42 2094 44 816 2095 42 2096 41 59 306 704 2097 40 601 816 2095 42 2096 44 2093 42 2094 41 59 306 865 2098 40 41 59 125 59 ,"{'AvgLine': 51, 'CountLine': 1815, 'CountStmt': 415, 'MaxNesting': 5, 'AvgLineCode': 38, 'AvgEssential': 1, 'AvgLineBlank': 10, 'CountStmtExe': 296, 'MaxEssential': 8, 'SumEssential': 59, 'AvgCyclomatic': 4, 'CountLineCode': 1296, 'CountStmtDecl': 115, 'MaxCyclomatic': 14, 'SumCyclomatic': 158, 'AltAvgLineCode': 38, 'AvgLineComment': 2, 'CountClassBase': 0, 'CountLineBlank': 397, 'CountStmtEmpty': 6, 'AltAvgLineBlank': 10, 'CountDeclMethod': 35, 'AltCountLineCode': 1296, 'CountLineCodeExe': 272, 'CountLineComment': 153, 'AltAvgLineComment': 2, 'AltCountLineBlank': 397, 'CountClassCoupled': 8, 'CountClassDerived': 0, 'CountLineCodeDecl': 85, 'CountLineInactive': 0, 'CountDeclMethodAll': 35, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.12', 'AltCountLineComment': 153, 'AvgCyclomaticStrict': 5, 'MaxCyclomaticStrict': 18, 'SumCyclomaticStrict': 166, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 4, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 18, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 14, 'PercentLackOfCohesion': 90, 'SumCyclomaticModified': 153, 'CountDeclClassVariable': 9, 'CountDeclMethodPrivate': 17, 'CountDeclInstanceMethod': 35, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 20, 'CountDeclInstanceVariablePublic': 3, 'CountDeclInstanceVariablePrivate': 17, 'CountDeclInstanceVariableProtected': 0}"
118585,C++,"class MockSettings : public QObject, public ICoreSettings
{
Q_OBJECT
public:
    MockSettings() {
        Q_INIT_RESOURCE(res);
        qRegisterMetaType<QList<DhtServer>>(""QList<DhtServer>"");
    }

    bool getEnableIPv6() const override { return false; }
    void setEnableIPv6(bool) override { }

    bool getForceTCP() const override { return false; }
    void setForceTCP(bool) override { }

    bool getEnableLanDiscovery() const override { return false; }
    void setEnableLanDiscovery(bool) override { }

    QString getProxyAddr() const override { return Addr; }
    void setProxyAddr(const QString &Addr) override { this->Addr = Addr; }

    ProxyType getProxyType() const override { return type; }
    void setProxyType(ProxyType type) override { this->type = type; }

    quint16 getProxyPort() const override { return port; }
    void setProxyPort(quint16 port) override { this->port = port; }

    QNetworkProxy getProxy() const override { return QNetworkProxy(QNetworkProxy::ProxyType::NoProxy); }

    SIGNAL_IMPL(MockSettings, enableIPv6Changed, bool enabled)
    SIGNAL_IMPL(MockSettings, forceTCPChanged, bool enabled)
    SIGNAL_IMPL(MockSettings, enableLanDiscoveryChanged, bool enabled)
    SIGNAL_IMPL(MockSettings, proxyTypeChanged, ICoreSettings::ProxyType type)
    SIGNAL_IMPL(MockSettings, proxyAddressChanged, const QString& address)
    SIGNAL_IMPL(MockSettings, proxyPortChanged, quint16 port)

private:
    QList<DhtServer> dhtServerList;
    QString Addr;
    ProxyType type;
    quint16 port;
};",1,587 2000 58 777 2001 44 777 2002 123 2003 777 58 2000 40 41 123 2004 40 2005 41 59 2006 60 2007 60 2008 355 40 362 41 59 125 569 2009 40 41 601 2010 123 792 655 59 125 865 2011 40 569 41 2010 123 125 569 2012 40 41 601 2010 123 792 655 59 125 865 2013 40 569 41 2010 123 125 569 2014 40 41 601 2010 123 792 655 59 125 865 2015 40 569 41 2010 123 125 2016 2017 40 41 601 2010 123 792 2018 59 125 865 2019 40 601 2016 38 2020 41 2010 123 823 354 2020 61 2020 59 125 2021 2022 40 41 601 2010 123 792 2023 59 125 865 2024 40 2021 2025 41 2010 123 823 354 2025 61 2025 59 125 2026 2027 40 41 601 2010 123 792 2028 59 125 865 2029 40 2026 2030 41 2010 123 823 354 2030 61 2030 59 125 2031 2032 40 41 601 2010 123 792 2031 40 2031 321 2021 321 2033 41 59 125 2034 40 2000 44 2035 44 569 2036 41 2034 40 2000 44 2037 44 569 2036 41 2034 40 2000 44 2038 44 569 2036 41 2034 40 2000 44 2039 44 2002 321 2021 2025 41 2034 40 2000 44 2040 44 601 2016 38 2041 41 2034 40 2000 44 2042 44 2026 2030 41 773 58 2043 60 2044 62 2045 59 2016 2020 59 2021 2025 59 2026 2030 59 125 59 ,"{'AvgLine': 100, 'CountLine': 42, 'CountStmt': 20, 'MaxNesting': 0, 'AvgLineCode': 67, 'AvgEssential': 1, 'AvgLineBlank': 28, 'CountStmtExe': 0, 'MaxEssential': 1, 'SumEssential': 6, 'AvgCyclomatic': 1, 'CountLineCode': 33, 'CountStmtDecl': 20, 'MaxCyclomatic': 1, 'SumCyclomatic': 6, 'AltAvgLineCode': 68, 'AvgLineComment': 7, 'CountClassBase': 1, 'CountLineBlank': 9, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 28, 'CountDeclMethod': 12, 'AltCountLineCode': 33, 'CountLineCodeExe': 0, 'CountLineComment': 0, 'AltAvgLineComment': 7, 'AltCountLineBlank': 9, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 1, 'CountLineInactive': 0, 'CountDeclMethodAll': 37, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 6, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 6, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 0, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 6, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 12, 'CountDeclInstanceMethod': 18, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 4, 'CountDeclInstanceVariablePublic': 3, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
99471,C++,"class TABRelation
{
    CPL_DISALLOW_COPY_ASSIGN(TABRelation)

  private:
    /* Information about the main table.
     */
    TABFile     *m_poMainTable;
    char        *m_pszMainFieldName;
    int         m_nMainFieldNo;

    /* Information about the related table.
     * NOTE: The related field MUST be indexed.
     */
    TABFile     *m_poRelTable;
    char        *m_pszRelFieldName;
    int         m_nRelFieldNo;

    TABINDFile  *m_poRelINDFileRef;
    int         m_nRelFieldIndexNo;

    int         m_nUniqueRecordNo;

    /* Main and Rel table field map:
     * For each field in the source tables, -1 means that the field is not
     * selected, and a value >=0 is the index of this field in the combined
     * FeatureDefn
     */
    int         *m_panMainTableFieldMap;
    int         *m_panRelTableFieldMap;

    OGRFeatureDefn *m_poDefn;

    void        ResetAllMembers();
    GByte       *BuildFieldKey(TABFeature *poFeature, int nFieldNo,
                                  TABFieldType eType, int nIndexNo);

   public:
    TABRelation();
    ~TABRelation();

    int         Init(const char *pszViewName,
                     TABFile *poMainTable, TABFile *poRelTable,
                     const char *pszMainFieldName,
                     const char *pszRelFieldName,
                     char **papszSelectedFields);
    int         CreateRelFields();

    OGRFeatureDefn *GetFeatureDefn()  {return m_poDefn;}
    TABFieldType    GetNativeFieldType(int nFieldId);
    TABFeature     *GetFeature(int nFeatureId);

    int         WriteFeature(TABFeature *poFeature, int nFeatureId=-1);

    int         SetFeatureDefn(OGRFeatureDefn *poFeatureDefn,
                           TABFieldType *paeMapInfoNativeFieldTypes=nullptr);
    int         AddFieldNative(const char *pszName, TABFieldType eMapInfoType,
                               int nWidth=0, int nPrecision=0,
                               GBool bIndexed=FALSE, GBool bUnique=FALSE, int bApproxOK=TRUE);

    int         SetFieldIndexed(int nFieldId);
    GBool       IsFieldIndexed(int nFieldId);
    GBool       IsFieldUnique(int nFieldId);

    const char *GetMainFieldName()      {return m_pszMainFieldName;}
    const char *GetRelFieldName()       {return m_pszRelFieldName;}
};",1,587 2000 123 2001 40 2000 41 773 58 305 2002 42 2003 59 582 42 2004 59 704 2005 59 305 2002 42 2006 59 582 42 2007 59 704 2008 59 2009 42 2010 59 704 2011 59 704 2012 59 305 704 42 2013 59 704 42 2014 59 2015 42 2016 59 865 2017 40 41 59 2018 42 2019 40 2020 42 2021 44 704 2022 44 2023 2024 44 704 2025 41 59 777 58 2000 40 41 59 126 2000 40 41 59 704 2026 40 601 582 42 2027 44 2002 42 2028 44 2002 42 2029 44 601 582 42 2030 44 601 582 42 2031 44 582 42 42 2032 41 59 704 2033 40 41 59 2015 42 2034 40 41 123 792 2016 59 125 2023 2035 40 704 2036 41 59 2020 42 2037 40 704 2038 41 59 704 2039 40 2020 42 2021 44 704 2038 61 45 1501 41 59 704 2040 40 2015 42 2041 44 2023 42 2042 61 753 41 59 704 2043 40 601 582 42 2044 44 2023 2045 44 704 2046 61 1500 44 704 2047 61 1500 44 2048 2049 61 2050 44 2048 2051 61 2050 44 704 2052 61 2053 41 59 704 2054 40 704 2036 41 59 2048 2055 40 704 2036 41 59 2048 2056 40 704 2036 41 59 601 582 42 2057 40 41 123 792 2004 59 125 601 582 42 2058 40 41 123 792 2007 59 125 125 59 ,"{'AvgLine': 39, 'CountLine': 732, 'CountStmt': 311, 'MaxNesting': 4, 'AvgLineCode': 27, 'AvgEssential': 3, 'AvgLineBlank': 5, 'CountStmtExe': 272, 'MaxEssential': 7, 'SumEssential': 60, 'AvgCyclomatic': 5, 'CountLineCode': 500, 'CountStmtDecl': 87, 'MaxCyclomatic': 18, 'SumCyclomatic': 97, 'AltAvgLineCode': 27, 'AvgLineComment': 7, 'CountClassBase': 0, 'CountLineBlank': 108, 'CountStmtEmpty': 2, 'AltAvgLineBlank': 5, 'CountDeclMethod': 19, 'AltCountLineCode': 500, 'CountLineCodeExe': 315, 'CountLineComment': 130, 'AltAvgLineComment': 7, 'AltCountLineBlank': 108, 'CountClassCoupled': 7, 'CountClassDerived': 0, 'CountLineCodeDecl': 72, 'CountLineInactive': 0, 'CountDeclMethodAll': 19, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.26', 'AltCountLineComment': 130, 'AvgCyclomaticStrict': 7, 'MaxCyclomaticStrict': 26, 'SumCyclomaticStrict': 126, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 5, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 15, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 18, 'PercentLackOfCohesion': 61, 'SumCyclomaticModified': 89, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 4, 'CountDeclInstanceMethod': 19, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 12, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 12, 'CountDeclInstanceVariableProtected': 0}"
118504,C++,"class CoreAV : public QObject
{
    Q_OBJECT

public:
    using CoreAVPtr = std::unique_ptr<CoreAV>;
    static CoreAVPtr makeCoreAV(Tox* core, CompatibleRecursiveMutex& toxCoreLock,
                                IAudioSettings& audioSettings, IGroupSettings& groupSettings);

    void setAudio(IAudioControl& newAudio);
    IAudioControl* getAudio();

    ~CoreAV();

    bool isCallStarted(const Friend* f) const;
    bool isCallStarted(const Group* f) const;
    bool isCallActive(const Friend* f) const;
    bool isCallActive(const Group* g) const;
    bool isCallVideoEnabled(const Friend* f) const;
    bool sendCallAudio(uint32_t friendNum, const int16_t* pcm, size_t samples, uint8_t chans,
                       uint32_t rate) const;
    void sendCallVideo(uint32_t friendNum, std::shared_ptr<VideoFrame> frame);
    bool sendGroupCallAudio(int groupNum, const int16_t* pcm, size_t samples, uint8_t chans,
                            uint32_t rate) const;

    VideoSource* getVideoSourceFromCall(int callNumber) const;
    void sendNoVideo();

    void joinGroupCall(const Group& group);
    void leaveGroupCall(int groupNum);
    void muteCallInput(const Group* g, bool mute);
    void muteCallOutput(const Group* g, bool mute);
    bool isGroupCallInputMuted(const Group* g) const;
    bool isGroupCallOutputMuted(const Group* g) const;

    bool isCallInputMuted(const Friend* f) const;
    bool isCallOutputMuted(const Friend* f) const;
    void toggleMuteCallInput(const Friend* f);
    void toggleMuteCallOutput(const Friend* f);
    static void groupCallCallback(void* tox, uint32_t group, uint32_t peer, const int16_t* data,
                                  unsigned samples, uint8_t channels, uint32_t sample_rate,
                                  void* core);
    void invalidateGroupCallPeerSource(const Group& group, ToxPk peerPk);

public slots:
    bool startCall(uint32_t friendNum, bool video);
    bool answerCall(uint32_t friendNum, bool video);
    bool cancelCall(uint32_t friendNum);
    void timeoutCall(uint32_t friendNum);
    void start();

signals:
    void avInvite(uint32_t friendId, bool video);
    void avStart(uint32_t friendId, bool video);
    void avEnd(uint32_t friendId, bool error = false);

private slots:
    static void callCallback(ToxAV* toxAV, uint32_t friendNum, bool audio, bool video, void* self);
    static void stateCallback(ToxAV*, uint32_t friendNum, uint32_t state, void* self);
    static void bitrateCallback(ToxAV* toxAV, uint32_t friendNum, uint32_t arate, uint32_t vrate,
                                void* self);
    static void audioBitrateCallback(ToxAV* toxAV, uint32_t friendNum, uint32_t rate, void* self);
    static void videoBitrateCallback(ToxAV* toxAV, uint32_t friendNum, uint32_t rate, void* self);

private:
    struct ToxAVDeleter
    {
        void operator()(ToxAV* tox)
        {
            toxav_kill(tox);
        }
    };

    CoreAV(std::unique_ptr<ToxAV, ToxAVDeleter> tox, CompatibleRecursiveMutex &toxCoreLock,
           IAudioSettings& _audioSettings, IGroupSettings& _groupSettings);
    void connectCallbacks(ToxAV& toxav);

    void process();
    static void audioFrameCallback(ToxAV* toxAV, uint32_t friendNum, const int16_t* pcm,
                                   size_t sampleCount, uint8_t channels, uint32_t samplingRate,
                                   void* self);
    static void videoFrameCallback(ToxAV* toxAV, uint32_t friendNum, uint16_t w, uint16_t h,
                                   const uint8_t* y, const uint8_t* u, const uint8_t* v,
                                   int32_t ystride, int32_t ustride, int32_t vstride, void* self);

private:
    static constexpr uint32_t VIDEO_DEFAULT_BITRATE = 2500;

private:
    // atomic because potentially accessed by different threads
    std::atomic<IAudioControl*> audio;
    std::unique_ptr<ToxAV, ToxAVDeleter> toxav;
    std::unique_ptr<QThread> coreavThread;
    QTimer* iterateTimer = nullptr;
    using ToxFriendCallPtr = std::unique_ptr<ToxFriendCall>;
    /**
     * @brief Maps friend IDs to ToxFriendCall.
     * @note Need to use STL container here, because Qt containers need a copy constructor.
     */
    std::map<uint32_t, ToxFriendCallPtr> calls;


    using ToxGroupCallPtr = std::unique_ptr<ToxGroupCall>;
    /**
     * @brief Maps group IDs to ToxGroupCalls.
     * @note Need to use STL container here, because Qt containers need a copy constructor.
     */
    std::map<int, ToxGroupCallPtr> groupCalls;

    // protect 'calls' and 'groupCalls'
    mutable QReadWriteLock callsLock{QReadWriteLock::Recursive};

    /**
     * @brief needed to synchronize with the Core thread, some toxav_* functions
     *        must not execute at the same time as tox_iterate()
     * @note This must be a recursive mutex as we're going to lock it in callbacks
     */
    CompatibleRecursiveMutex& coreLock;

    IAudioSettings& audioSettings;
    IGroupSettings& groupSettings;
};",1,587 2000 58 777 2001 123 2002 777 58 860 2003 61 2004 321 2005 60 2000 62 59 809 2003 2006 40 2007 42 2008 44 2009 38 2010 44 2011 38 2012 44 2013 38 2014 41 59 865 2015 40 2016 38 2017 41 59 2016 42 2018 40 41 59 126 2000 40 41 59 569 2019 40 601 2020 42 2021 41 601 59 569 2019 40 601 2022 42 2021 41 601 59 569 2023 40 601 2020 42 2021 41 601 59 569 2023 40 601 2022 42 2024 41 601 59 569 2025 40 601 2020 42 2021 41 601 59 569 2026 40 2027 2028 44 601 2029 42 2030 44 2031 2032 44 2033 2034 44 2027 2035 41 601 59 865 2036 40 2027 2028 44 2004 321 2037 60 2038 62 2039 41 59 569 2040 40 704 2041 44 601 2029 42 2030 44 2031 2032 44 2033 2034 44 2027 2035 41 601 59 2042 42 2043 40 704 2044 41 601 59 865 2045 40 41 59 865 2046 40 601 2022 38 2047 41 59 865 2048 40 704 2041 41 59 865 2049 40 601 2022 42 2024 44 569 2050 41 59 865 2051 40 601 2022 42 2024 44 569 2050 41 59 569 2052 40 601 2022 42 2024 41 601 59 569 2053 40 601 2022 42 2024 41 601 59 569 2054 40 601 2020 42 2021 41 601 59 569 2055 40 601 2020 42 2021 41 601 59 865 2056 40 601 2020 42 2021 41 59 865 2057 40 601 2020 42 2021 41 59 809 865 2058 40 865 42 2059 44 2027 2047 44 2027 2060 44 601 2029 42 2061 44 856 2032 44 2033 2062 44 2027 2063 44 865 42 2008 41 59 865 2064 40 601 2022 38 2047 44 2065 2066 41 59 777 2067 58 569 2068 40 2027 2028 44 569 2069 41 59 569 2070 40 2027 2028 44 569 2069 41 59 569 2071 40 2027 2028 41 59 865 2072 40 2027 2028 41 59 865 2073 40 41 59 2074 58 865 2075 40 2027 2076 44 569 2069 41 59 865 2077 40 2027 2076 44 569 2069 41 59 865 2078 40 2027 2076 44 569 2079 61 655 41 59 773 2067 58 809 865 2080 40 2081 42 2082 44 2027 2028 44 569 2083 44 569 2069 44 865 42 2084 41 59 809 865 2085 40 2081 42 44 2027 2028 44 2027 2086 44 865 42 2084 41 59 809 865 2087 40 2081 42 2082 44 2027 2028 44 2027 2088 44 2027 2089 44 865 42 2084 41 59 809 865 2090 40 2081 42 2082 44 2027 2028 44 2027 2035 44 865 42 2084 41 59 809 865 2091 40 2081 42 2082 44 2027 2028 44 2027 2035 44 865 42 2084 41 59 773 58 816 2092 123 865 758 40 41 40 2081 42 2059 41 123 2093 40 2059 41 59 125 125 59 2000 40 2004 321 2005 60 2081 44 2092 62 2059 44 2009 38 2010 44 2011 38 2094 44 2013 38 2095 41 59 865 2096 40 2081 38 2097 41 59 865 2098 40 41 59 809 865 2099 40 2081 42 2082 44 2027 2028 44 601 2029 42 2030 44 2031 2100 44 2033 2062 44 2027 2101 44 865 42 2084 41 59 809 865 2102 40 2081 42 2082 44 2027 2028 44 2103 2104 44 2103 2105 44 601 2033 42 2106 44 601 2033 42 2107 44 601 2033 42 2108 44 2109 2110 44 2109 2111 44 2109 2112 44 865 42 2084 41 59 773 58 809 603 2027 2113 61 1505 59 773 58 330 2004 321 2114 60 2016 42 62 2083 59 2004 321 2005 60 2081 44 2092 62 2097 59 2004 321 2005 60 2115 62 2116 59 2117 42 2118 61 753 59 860 2119 61 2004 321 2005 60 2120 62 59 306 2004 321 2121 60 2027 44 2119 62 2122 59 860 2123 61 2004 321 2005 60 2124 62 59 306 2004 321 2121 60 704 44 2123 62 2125 59 330 740 2126 2127 123 2126 321 2128 125 59 306 2009 38 2129 59 2011 38 2012 59 2013 38 2014 59 125 59 ,"{'AvgLine': 16, 'CountLine': 779, 'CountStmt': 283, 'MaxNesting': 3, 'AvgLineCode': 13, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 125, 'MaxEssential': 4, 'SumEssential': 57, 'AvgCyclomatic': 2, 'CountLineCode': 629, 'CountStmtDecl': 164, 'MaxCyclomatic': 9, 'SumCyclomatic': 90, 'AltAvgLineCode': 13, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 103, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 43, 'AltCountLineCode': 629, 'CountLineCodeExe': 116, 'CountLineComment': 47, 'AltAvgLineComment': 0, 'AltCountLineBlank': 103, 'CountClassCoupled': 19, 'CountClassDerived': 0, 'CountLineCodeDecl': 155, 'CountLineInactive': 0, 'CountDeclMethodAll': 43, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.07', 'AltCountLineComment': 47, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 92, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 12, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 17, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 9, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 90, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 26, 'CountDeclInstanceMethod': 44, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 13, 'CountDeclInstanceVariablePublic': 9, 'CountDeclInstanceVariablePrivate': 4, 'CountDeclInstanceVariableProtected': 0}"
117565,C++,"class ModuleParams : public ListNode<ModuleParams *>
{
public:

	ModuleParams(ModuleParams *parent)
	{
		setParent(parent);
	}

	/**
	 * @brief Sets the parent module. This is typically not required,
	 *         only in cases where the parent cannot be set via constructor.
	 */
	void setParent(ModuleParams *parent)
	{
		if (parent) {
			parent->_children.add(this);
		}

		_parent = parent;
	}

	virtual ~ModuleParams()
	{
		if (_parent) { _parent->_children.remove(this); }
	}

	// Disallow copy construction and move assignment.
	ModuleParams(const ModuleParams &) = delete;
	ModuleParams &operator=(const ModuleParams &) = delete;
	ModuleParams(ModuleParams &&) = delete;
	ModuleParams &operator=(ModuleParams &&) = delete;

protected:
	/**
	 * @brief Call this method whenever the module gets a parameter change notification.
	 *        It will automatically call updateParams() for all children, which then call updateParamsImpl().
	 */
	virtual void updateParams()
	{
		for (const auto &child : _children) {
			child->updateParams();
		}

		updateParamsImpl();
	}

	/**
	 * @brief The implementation for this is generated with the macro DEFINE_PARAMETERS()
	 */
	virtual void updateParamsImpl() {}

private:
	/** @list _children The module parameter list of inheriting classes. */
	List<ModuleParams *> _children;
	ModuleParams *_parent{nullptr};
};",1,587 2000 58 777 2001 60 2000 42 62 123 777 58 2000 40 2000 42 2002 41 123 2003 40 2002 41 59 125 306 865 2004 40 2000 42 2002 41 123 688 40 2002 41 123 2002 354 2005 46 2006 40 823 41 59 125 2007 61 2002 59 125 864 126 2000 40 41 123 688 40 2008 41 123 2008 354 2009 46 2010 40 823 41 59 125 125 330 2000 40 601 2000 38 41 61 619 59 2000 38 758 61 40 601 2000 38 41 61 619 59 2000 40 2000 307 41 61 619 59 2000 38 758 61 40 2000 307 41 61 619 59 775 58 306 864 865 2011 40 41 123 664 40 601 561 38 2012 58 2013 41 123 2012 354 2011 40 41 59 125 2014 40 41 59 125 306 864 865 2015 40 41 123 125 773 58 306 2016 60 2000 42 62 2017 59 2000 42 2018 123 753 125 59 125 59 ,"{'AvgLine': 5, 'CountLine': 57, 'CountStmt': 15, 'MaxNesting': 1, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 7, 'MaxEssential': 1, 'SumEssential': 5, 'AvgCyclomatic': 1, 'CountLineCode': 35, 'CountStmtDecl': 8, 'MaxCyclomatic': 2, 'SumCyclomatic': 7, 'AltAvgLineCode': 4, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 9, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 9, 'AltCountLineCode': 35, 'CountLineCodeExe': 6, 'CountLineComment': 13, 'AltAvgLineComment': 0, 'AltCountLineBlank': 9, 'CountClassCoupled': 1, 'CountClassDerived': 91, 'CountLineCodeDecl': 7, 'CountLineInactive': 0, 'CountDeclMethodAll': 9, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.37', 'AltCountLineComment': 13, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 7, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 7, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 88, 'SumCyclomaticModified': 7, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 9, 'CountDeclMethodProtected': 2, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
118521,C++,"class ChatLine
{
public:
    using Ptr = std::shared_ptr<ChatLine>;

    ChatLine();
    virtual ~ChatLine();

    QRectF sceneBoundingRect() const;

    void replaceContent(int col, ChatLineContent* lineContent);
    void layout(qreal width, QPointF scenePos);
    void moveBy(qreal deltaY);
    void removeFromScene();
    void addToScene(QGraphicsScene* scene);
    void setVisible(bool visible);
    void selectionCleared();
    void selectionFocusChanged(bool focusIn);
    void fontChanged(const QFont& font);
    void reloadTheme();

    int getColumnCount();

    ChatLineContent* getContent(int col) const;
    ChatLineContent* getContent(QPointF scenePos) const;

    bool isOverSelection(QPointF scenePos);

    // comparators
    static bool lessThanBSRectTop(const ChatLine::Ptr& lhs, const qreal& rhs);
    static bool lessThanBSRectBottom(const ChatLine::Ptr& lhs, const qreal& rhs);

protected:
    friend class ChatWidget;

    QPointF mapToContent(ChatLineContent* c, QPointF pos);

    void addColumn(ChatLineContent* item, ColumnFormat fmt);
    void updateBBox();
    void visibilityChanged(bool visible);

private:
    int row = -1;
    QVector<ChatLineContent*> content;
    QVector<ColumnFormat> format;
    qreal width = 100.0;
    qreal columnSpacing = 15.0;
    QRectF bbox;
    bool isVisible = false;
};",1,587 2000 123 777 58 860 2001 61 2002 321 2003 60 2000 62 59 2000 40 41 59 864 126 2000 40 41 59 2004 2005 40 41 601 59 865 2006 40 704 2007 44 2008 42 2009 41 59 865 2010 40 2011 2012 44 2013 2014 41 59 865 2015 40 2011 2016 41 59 865 2017 40 41 59 865 2018 40 2019 42 2020 41 59 865 2021 40 569 2022 41 59 865 2023 40 41 59 865 2024 40 569 2025 41 59 865 2026 40 601 2027 38 2028 41 59 865 2029 40 41 59 704 2030 40 41 59 2008 42 2031 40 704 2007 41 601 59 2008 42 2031 40 2013 2014 41 601 59 569 2032 40 2013 2014 41 59 330 809 569 2033 40 601 2000 321 2001 38 2034 44 601 2011 38 2035 41 59 809 569 2036 40 601 2000 321 2001 38 2034 44 601 2011 38 2035 41 59 775 58 667 587 2037 59 2013 2038 40 2008 42 2039 44 2013 2040 41 59 865 2041 40 2008 42 2042 44 2043 2044 41 59 865 2045 40 41 59 865 2046 40 569 2022 41 59 773 58 704 2047 61 45 1501 59 2048 60 2008 42 62 2049 59 2048 60 2043 62 2050 59 2011 2012 61 1503 59 2011 2051 61 1503 59 2004 2052 59 569 2053 61 655 59 125 59 ,"{'AvgLine': 9, 'CountLine': 257, 'CountStmt': 69, 'MaxNesting': 1, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 13, 'MaxEssential': 1, 'SumEssential': 21, 'AvgCyclomatic': 1, 'CountLineCode': 211, 'CountStmtDecl': 56, 'MaxCyclomatic': 2, 'SumCyclomatic': 26, 'AltAvgLineCode': 8, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 37, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 23, 'AltCountLineCode': 211, 'CountLineCodeExe': 11, 'CountLineComment': 10, 'AltAvgLineComment': 0, 'AltCountLineBlank': 37, 'CountClassCoupled': 5, 'CountClassDerived': 3, 'CountLineCodeDecl': 45, 'CountLineInactive': 0, 'CountDeclMethodAll': 23, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.05', 'AltCountLineComment': 10, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 26, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 3, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 80, 'CountDeclMethodPublic': 19, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 26, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 25, 'CountDeclMethodProtected': 4, 'CountDeclInstanceVariable': 7, 'CountDeclInstanceVariablePublic': 5, 'CountDeclInstanceVariablePrivate': 2, 'CountDeclInstanceVariableProtected': 0}"
118436,C++,"class Core : public QObject,
             public ICoreFriendMessageSender,
             public ICoreIdHandler,
             public ICoreGroupMessageSender,
             public ICoreGroupQuery
{
    Q_OBJECT
public:
    enum class ToxCoreErrors
    {
        BAD_PROXY,
        INVALID_SAVE,
        FAILED_TO_START,
        ERROR_ALLOC
    };

    static ToxCorePtr makeToxCore(const QByteArray& savedata, const ICoreSettings* const settings,
                                  IBootstrapListGenerator& bootstrapNodes, ToxCoreErrors* err = nullptr);
    const CoreAV* getAv() const;
    CoreAV* getAv();
    void setAv(CoreAV* coreAv);

    CoreFile* getCoreFile() const;
    Tox* getTox() const;
    CompatibleRecursiveMutex& getCoreLoopLock() const;

    const CoreExt* getExt() const;
    CoreExt* getExt();
    ~Core();

    static const QString TOX_EXT;
    uint64_t getMaxMessageSize() const;
    QString getPeerName(const ToxPk& id) const;
    QVector<uint32_t> getFriendList() const;
    GroupId getGroupPersistentId(uint32_t groupNumber) const override;
    uint32_t getGroupNumberPeers(int groupId) const override;
    QString getGroupPeerName(int groupId, int peerId) const override;
    ToxPk getGroupPeerPk(int groupId, int peerId) const override;
    QStringList getGroupPeerNames(int groupId) const override;
    bool getGroupAvEnabled(int groupId) const override;
    ToxPk getFriendPublicKey(uint32_t friendNumber) const;
    QString getFriendUsername(uint32_t friendNumber) const;

    bool isFriendOnline(uint32_t friendId) const;
    bool hasFriendWithPublicKey(const ToxPk& publicKey) const;
    uint32_t joinGroupchat(const GroupInvite& inviteInfo);
    void quitGroupChat(int groupId) const;

    QString getUsername() const override;
    Status::Status getStatus() const;
    QString getStatusMessage() const;
    ToxId getSelfId() const override;
    ToxPk getSelfPublicKey() const override;
    QPair<QByteArray, QByteArray> getKeypair() const;

    void sendFile(uint32_t friendId, QString filename, QString filePath, long long filesize);

public slots:
    void start();

    QByteArray getToxSaveData();

    void acceptFriendRequest(const ToxPk& friendPk);
    void requestFriendship(const ToxId& friendAddress, const QString& message);
    void groupInviteFriend(uint32_t friendId, int groupId);
    int createGroup(uint8_t type = TOX_CONFERENCE_TYPE_AV);

    void removeFriend(uint32_t friendId);
    void removeGroup(int groupId);

    void setStatus(Status::Status status);
    void setUsername(const QString& username);
    void setStatusMessage(const QString& message);

    bool sendMessage(uint32_t friendId, const QString& message, ReceiptNum& receipt) override;
    void sendGroupMessage(int groupId, const QString& message) override;
    void sendGroupAction(int groupId, const QString& message) override;
    void changeGroupTitle(int groupId, const QString& title);
    bool sendAction(uint32_t friendId, const QString& action, ReceiptNum& receipt) override;
    void sendTyping(uint32_t friendId, bool typing);

    void setNospam(uint32_t nospam);

signals:
    void connected();
    void disconnected();

    void friendRequestReceived(const ToxPk& friendPk, const QString& message);
    void friendAvatarChanged(const ToxPk& friendPk, const QByteArray& pic);
    void friendAvatarRemoved(const ToxPk& friendPk);

    void requestSent(const ToxPk& friendPk, const QString& message);
    void failedToAddFriend(const ToxPk& friendPk, const QString& errorInfo = QString());

    void usernameSet(const QString& username);
    void statusMessageSet(const QString& message);
    void statusSet(Status::Status status);
    void idSet(const ToxId& id);

    void failedToSetUsername(const QString& username);
    void failedToSetStatusMessage(const QString& message);
    void failedToSetStatus(Status::Status status);
    void failedToSetTyping(bool typing);

    void saveRequest();

    /**
     * @deprecated prefer signals using ToxPk
     */

    void fileAvatarOfferReceived(uint32_t friendId, uint32_t fileId, const QByteArray& avatarHash);

    void friendMessageReceived(uint32_t friendId, const QString& message, bool isAction);
    void friendAdded(uint32_t friendId, const ToxPk& friendPk);

    void friendStatusChanged(uint32_t friendId, Status::Status status);
    void friendStatusMessageChanged(uint32_t friendId, const QString& message);
    void friendUsernameChanged(uint32_t friendId, const QString& username);
    void friendTypingChanged(uint32_t friendId, bool isTyping);

    void friendRemoved(uint32_t friendId);
    void friendLastSeenChanged(uint32_t friendId, const QDateTime& dateTime);

    void emptyGroupCreated(int groupnumber, const GroupId groupId, const QString& title = QString());
    void groupInviteReceived(const GroupInvite& inviteInfo);
    void groupMessageReceived(int groupnumber, int peernumber, const QString& message, bool isAction);
    void groupNamelistChanged(int groupnumber, int peernumber, uint8_t change);
    void groupPeerlistChanged(int groupnumber);
    void groupPeerNameChanged(int groupnumber, const ToxPk& peerPk, const QString& newName);
    void groupTitleChanged(int groupnumber, const QString& author, const QString& title);
    void groupPeerAudioPlaying(int groupnumber, ToxPk peerPk);
    void groupSentFailed(int groupId);
    void groupJoined(int groupnumber, GroupId groupId);
    void actionSentResult(uint32_t friendId, const QString& action, int success);

    void receiptRecieved(int friedId, ReceiptNum receipt);

    void failedToRemoveFriend(uint32_t friendId);

private:
    Core(QThread* coreThread, IBootstrapListGenerator& _bootstrapNodes);

    static void onFriendRequest(Tox* tox, const uint8_t* cUserId, const uint8_t* cMessage,
                                size_t cMessageSize, void* core);
    static void onFriendMessage(Tox* tox, uint32_t friendId, Tox_Message_Type type,
                                const uint8_t* cMessage, size_t cMessageSize, void* core);
    static void onFriendNameChange(Tox* tox, uint32_t friendId, const uint8_t* cName,
                                   size_t cNameSize, void* core);
    static void onFriendTypingChange(Tox* tox, uint32_t friendId, bool isTyping, void* core);
    static void onStatusMessageChanged(Tox* tox, uint32_t friendId, const uint8_t* cMessage,
                                       size_t cMessageSize, void* core);
    static void onUserStatusChanged(Tox* tox, uint32_t friendId, Tox_User_Status userstatus,
                                    void* core);
    static void onConnectionStatusChanged(Tox* tox, uint32_t friendId, Tox_Connection status,
                                          void* vCore);
    static void onGroupInvite(Tox* tox, uint32_t friendId, Tox_Conference_Type type,
                              const uint8_t* cookie, size_t length, void* vCore);
    static void onGroupMessage(Tox* tox, uint32_t groupId, uint32_t peerId, Tox_Message_Type type,
                               const uint8_t* cMessage, size_t length, void* vCore);
    static void onGroupPeerListChange(Tox*, uint32_t groupId, void* core);
    static void onGroupPeerNameChange(Tox*, uint32_t groupId, uint32_t peerId, const uint8_t* name,
                                      size_t length, void* core);
    static void onGroupTitleChange(Tox* tox, uint32_t groupId, uint32_t peerId,
                                   const uint8_t* cTitle, size_t length, void* vCore);

    static void onLosslessPacket(Tox* tox, uint32_t friendId,
                                   const uint8_t* data, size_t length, void* core);
    static void onReadReceiptCallback(Tox* tox, uint32_t friendId, uint32_t receipt, void* core);

    void sendGroupMessageWithType(int groupId, const QString& message, Tox_Message_Type type);
    bool sendMessageWithType(uint32_t friendId, const QString& message, Tox_Message_Type type, ReceiptNum& receipt);
    bool checkConnection();

    void makeTox(QByteArray savedata, ICoreSettings* s);
    void loadFriends();
    void loadGroups();
    void bootstrapDht();

    void checkLastOnline(uint32_t friendId);

    QString getFriendRequestErrorMessage(const ToxId& friendId, const QString& message) const;
    static void registerCallbacks(Tox* tox);

private slots:
    void process();
    void onStarted();

private:
    struct ToxDeleter
    {
        void operator()(Tox* tox)
        {
            tox_kill(tox);
        }
    };

    using ToxPtr = std::unique_ptr<Tox, ToxDeleter>;
    ToxPtr tox;

    std::unique_ptr<CoreFile> file;
    CoreAV* av = nullptr;
    std::unique_ptr<CoreExt> ext;
    QTimer* toxTimer = nullptr;
    // recursive, since we might call our own functions
    mutable CompatibleRecursiveMutex coreLoopLock;

    std::unique_ptr<QThread> coreThread;
    IBootstrapListGenerator& bootstrapNodes;
};",1,587 2000 58 777 2001 44 777 2002 44 777 2003 44 777 2004 44 777 2005 123 2006 777 58 640 587 2007 123 2008 44 2009 44 2010 44 2011 125 59 809 2012 2013 40 601 2014 38 2015 44 601 2016 42 601 2017 44 2018 38 2019 44 2007 42 2020 61 753 41 59 601 2021 42 2022 40 41 601 59 2021 42 2022 40 41 59 865 2023 40 2021 42 2024 41 59 2025 42 2026 40 41 601 59 2027 42 2028 40 41 601 59 2029 38 2030 40 41 601 59 601 2031 42 2032 40 41 601 59 2031 42 2032 40 41 59 126 2000 40 41 59 809 601 2033 2034 59 2035 2036 40 41 601 59 2033 2037 40 601 2038 38 2039 41 601 59 2040 60 2041 62 2042 40 41 601 59 2043 2044 40 2041 2045 41 601 2046 59 2041 2047 40 704 2048 41 601 2046 59 2033 2049 40 704 2048 44 704 2050 41 601 2046 59 2038 2051 40 704 2048 44 704 2050 41 601 2046 59 2052 2053 40 704 2048 41 601 2046 59 569 2054 40 704 2048 41 601 2046 59 2038 2055 40 2041 2056 41 601 59 2033 2057 40 2041 2056 41 601 59 569 2058 40 2041 2059 41 601 59 569 2060 40 601 2038 38 2061 41 601 59 2041 2062 40 601 2063 38 2064 41 59 865 2065 40 704 2048 41 601 59 2033 2066 40 41 601 2046 59 2067 321 2067 2068 40 41 601 59 2033 2069 40 41 601 59 2070 2071 40 41 601 2046 59 2038 2072 40 41 601 2046 59 2073 60 2014 44 2014 62 2074 40 41 601 59 865 2075 40 2041 2059 44 2033 2076 44 2033 2077 44 726 726 2078 41 59 777 2079 58 865 2080 40 41 59 2014 2081 40 41 59 865 2082 40 601 2038 38 2083 41 59 865 2084 40 601 2070 38 2085 44 601 2033 38 2086 41 59 865 2087 40 2041 2059 44 704 2048 41 59 704 2088 40 2089 2090 61 2091 41 59 865 2092 40 2041 2059 41 59 865 2093 40 704 2048 41 59 865 2094 40 2067 321 2067 2095 41 59 865 2096 40 601 2033 38 2097 41 59 865 2098 40 601 2033 38 2086 41 59 569 2099 40 2041 2059 44 601 2033 38 2086 44 2100 38 2101 41 2046 59 865 2102 40 704 2048 44 601 2033 38 2086 41 2046 59 865 2103 40 704 2048 44 601 2033 38 2086 41 2046 59 865 2104 40 704 2048 44 601 2033 38 2105 41 59 569 2106 40 2041 2059 44 601 2033 38 2107 44 2100 38 2101 41 2046 59 865 2108 40 2041 2059 44 569 2109 41 59 865 2110 40 2041 2111 41 59 2112 58 865 2113 40 41 59 865 2114 40 41 59 865 2115 40 601 2038 38 2083 44 601 2033 38 2086 41 59 865 2116 40 601 2038 38 2083 44 601 2014 38 2117 41 59 865 2118 40 601 2038 38 2083 41 59 865 2119 40 601 2038 38 2083 44 601 2033 38 2086 41 59 865 2120 40 601 2038 38 2083 44 601 2033 38 2121 61 2033 40 41 41 59 865 2122 40 601 2033 38 2097 41 59 865 2123 40 601 2033 38 2086 41 59 865 2124 40 2067 321 2067 2095 41 59 865 2125 40 601 2070 38 2039 41 59 865 2126 40 601 2033 38 2097 41 59 865 2127 40 601 2033 38 2086 41 59 865 2128 40 2067 321 2067 2095 41 59 865 2129 40 569 2109 41 59 865 2130 40 41 59 306 865 2131 40 2041 2059 44 2041 2132 44 601 2014 38 2133 41 59 865 2134 40 2041 2059 44 601 2033 38 2086 44 569 2135 41 59 865 2136 40 2041 2059 44 601 2038 38 2083 41 59 865 2137 40 2041 2059 44 2067 321 2067 2095 41 59 865 2138 40 2041 2059 44 601 2033 38 2086 41 59 865 2139 40 2041 2059 44 601 2033 38 2097 41 59 865 2140 40 2041 2059 44 569 2141 41 59 865 2142 40 2041 2059 41 59 865 2143 40 2041 2059 44 601 2144 38 2145 41 59 865 2146 40 704 2147 44 601 2043 2048 44 601 2033 38 2105 61 2033 40 41 41 59 865 2148 40 601 2063 38 2064 41 59 865 2149 40 704 2147 44 704 2150 44 601 2033 38 2086 44 569 2135 41 59 865 2151 40 704 2147 44 704 2150 44 2089 2152 41 59 865 2153 40 704 2147 41 59 865 2154 40 704 2147 44 601 2038 38 2155 44 601 2033 38 2156 41 59 865 2157 40 704 2147 44 601 2033 38 2158 44 601 2033 38 2105 41 59 865 2159 40 704 2147 44 2038 2155 41 59 865 2160 40 704 2048 41 59 865 2161 40 704 2147 44 2043 2048 41 59 865 2162 40 2041 2059 44 601 2033 38 2107 44 704 2163 41 59 865 2164 40 704 2165 44 2100 2101 41 59 865 2166 40 2041 2059 41 59 773 58 2000 40 2167 42 2168 44 2018 38 2169 41 59 809 865 2170 40 2027 42 2171 44 601 2089 42 2172 44 601 2089 42 2173 44 2174 2175 44 865 42 2176 41 59 809 865 2177 40 2027 42 2171 44 2041 2059 44 2178 2090 44 601 2089 42 2173 44 2174 2175 44 865 42 2176 41 59 809 865 2179 40 2027 42 2171 44 2041 2059 44 601 2089 42 2180 44 2174 2181 44 865 42 2176 41 59 809 865 2182 40 2027 42 2171 44 2041 2059 44 569 2141 44 865 42 2176 41 59 809 865 2183 40 2027 42 2171 44 2041 2059 44 601 2089 42 2173 44 2174 2175 44 865 42 2176 41 59 809 865 2184 40 2027 42 2171 44 2041 2059 44 2185 2186 44 865 42 2176 41 59 809 865 2187 40 2027 42 2171 44 2041 2059 44 2188 2095 44 865 42 2189 41 59 809 865 2190 40 2027 42 2171 44 2041 2059 44 2191 2090 44 601 2089 42 2192 44 2174 2193 44 865 42 2189 41 59 809 865 2194 40 2027 42 2171 44 2041 2048 44 2041 2050 44 2178 2090 44 601 2089 42 2173 44 2174 2193 44 865 42 2189 41 59 809 865 2195 40 2027 42 44 2041 2048 44 865 42 2176 41 59 809 865 2196 40 2027 42 44 2041 2048 44 2041 2050 44 601 2089 42 2197 44 2174 2193 44 865 42 2176 41 59 809 865 2198 40 2027 42 2171 44 2041 2048 44 2041 2050 44 601 2089 42 2199 44 2174 2193 44 865 42 2189 41 59 809 865 2200 40 2027 42 2171 44 2041 2059 44 601 2089 42 2201 44 2174 2193 44 865 42 2176 41 59 809 865 2202 40 2027 42 2171 44 2041 2059 44 2041 2101 44 865 42 2176 41 59 865 2203 40 704 2048 44 601 2033 38 2086 44 2178 2090 41 59 569 2204 40 2041 2059 44 601 2033 38 2086 44 2178 2090 44 2100 38 2101 41 59 569 2205 40 41 59 865 2206 40 2014 2015 44 2016 42 2207 41 59 865 2208 40 41 59 865 2209 40 41 59 865 2210 40 41 59 865 2211 40 2041 2059 41 59 2033 2212 40 601 2070 38 2059 44 601 2033 38 2086 41 601 59 809 865 2213 40 2027 42 2171 41 59 773 2079 58 865 2214 40 41 59 865 2215 40 41 59 773 58 816 2216 123 865 758 40 41 40 2027 42 2171 41 123 2217 40 2171 41 59 125 125 59 860 2218 61 2219 321 2220 60 2027 44 2216 62 59 2218 2171 59 2219 321 2220 60 2025 62 2221 59 2021 42 2222 61 753 59 2219 321 2220 60 2031 62 2223 59 2224 42 2225 61 753 59 330 740 2029 2226 59 2219 321 2220 60 2167 62 2168 59 2018 38 2019 59 125 59 ,"{'AvgLine': 15, 'CountLine': 1375, 'CountStmt': 544, 'MaxNesting': 3, 'AvgLineCode': 13, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 193, 'MaxEssential': 5, 'SumEssential': 107, 'AvgCyclomatic': 2, 'CountLineCode': 1167, 'CountStmtDecl': 366, 'MaxCyclomatic': 8, 'SumCyclomatic': 156, 'AltAvgLineCode': 13, 'AvgLineComment': 0, 'CountClassBase': 4, 'CountLineBlank': 162, 'CountStmtEmpty': 3, 'AltAvgLineBlank': 1, 'CountDeclMethod': 130, 'AltCountLineCode': 1170, 'CountLineCodeExe': 164, 'CountLineComment': 43, 'AltAvgLineComment': 0, 'AltCountLineBlank': 162, 'CountClassCoupled': 17, 'CountClassDerived': 0, 'CountLineCodeDecl': 298, 'CountLineInactive': 2, 'CountDeclMethodAll': 167, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 44, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 159, 'CountDeclClassMethod': 15, 'CountDeclMethodConst': 26, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 85, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 8, 'PercentLackOfCohesion': 99, 'SumCyclomaticModified': 154, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 45, 'CountDeclInstanceMethod': 118, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 11, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 4, 'CountDeclInstanceVariableProtected': 0}"
117612,C++,"class Accelerometer
{
public:
	static constexpr int MAX_SENSOR_COUNT = 4;

	static constexpr uint8_t DEFAULT_PRIORITY = 50;
	static constexpr uint8_t DEFAULT_EXTERNAL_PRIORITY = 25;

	static constexpr const char *SensorString() { return ""ACC""; }

	Accelerometer();
	explicit Accelerometer(uint32_t device_id, bool external = false);

	~Accelerometer() = default;

	void PrintStatus();

	void set_calibration_index(uint8_t calibration_index) { _calibration_index = calibration_index; }
	void set_device_id(uint32_t device_id, bool external = false);
	void set_external(bool external = true);
	bool set_offset(const matrix::Vector3f &offset);
	bool set_scale(const matrix::Vector3f &scale);
	void set_rotation(Rotation rotation);
	void set_temperature(float temperature) { _temperature = temperature; };

	uint8_t calibration_count() const { return _calibration_count; }
	uint32_t device_id() const { return _device_id; }
	bool enabled() const { return (_priority > 0); }
	bool external() const { return _external; }
	const matrix::Vector3f &offset() const { return _offset; }
	const int32_t &priority() const { return _priority; }
	const matrix::Dcmf &rotation() const { return _rotation; }
	const Rotation &rotation_enum() const { return _rotation_enum; }
	const matrix::Vector3f &scale() const { return _scale; }

	// apply offsets and scale
	// rotate corrected measurements from sensor to body frame
	inline matrix::Vector3f Correct(const matrix::Vector3f &data) const
	{
		return _rotation * matrix::Vector3f{(data - _thermal_offset - _offset).emult(_scale)};
	}

	// Compute sensor offset from bias (board frame)
	matrix::Vector3f BiasCorrectedSensorOffset(const matrix::Vector3f &bias) const
	{
		return (_rotation.I() * bias).edivide(_scale) + _thermal_offset + _offset;
	}

	bool ParametersSave();
	void ParametersUpdate();

	void Reset();

	void SensorCorrectionsUpdate(bool force = false);

private:
	static constexpr float TEMPERATURE_INVALID = -1000.f;

	uORB::Subscription _sensor_correction_sub{ORB_ID(sensor_correction)};

	Rotation _rotation_enum{ROTATION_NONE};

	matrix::Dcmf _rotation;
	matrix::Vector3f _offset;
	matrix::Vector3f _scale;
	matrix::Vector3f _thermal_offset;
	float _temperature{NAN};

	int8_t _calibration_index{-1};
	uint32_t _device_id{0};
	int32_t _priority{-1};

	bool _external{false};

	uint8_t _calibration_count{0};
};",1,587 2000 123 777 58 809 603 704 2001 61 1502 59 809 603 2002 2003 61 1503 59 809 603 2002 2004 61 1503 59 809 603 601 582 42 2005 40 41 123 792 362 59 125 2000 40 41 59 648 2000 40 2006 2007 44 569 2008 61 655 41 59 126 2000 40 41 61 613 59 865 2009 40 41 59 865 2010 40 2002 2011 41 123 2012 61 2011 59 125 865 2013 40 2006 2007 44 569 2008 61 655 41 59 865 2014 40 569 2008 61 829 41 59 569 2015 40 601 2016 321 2017 38 2018 41 59 569 2019 40 601 2016 321 2017 38 2020 41 59 865 2021 40 2022 2023 41 59 865 2024 40 660 2025 41 123 2026 61 2025 59 125 59 2002 2027 40 41 601 123 792 2028 59 125 2006 2007 40 41 601 123 792 2029 59 125 569 2030 40 41 601 123 792 40 2031 62 1500 41 59 125 569 2008 40 41 601 123 792 2032 59 125 601 2016 321 2017 38 2018 40 41 601 123 792 2033 59 125 601 2034 38 2035 40 41 601 123 792 2036 59 125 601 2016 321 2037 38 2023 40 41 601 123 792 2038 59 125 601 2022 38 2039 40 41 601 123 792 2040 59 125 601 2016 321 2017 38 2020 40 41 601 123 792 2041 59 125 330 330 700 2016 321 2017 2042 40 601 2016 321 2017 38 2043 41 601 123 792 2044 42 2016 321 2017 123 40 2043 45 2045 45 2046 41 46 2047 40 2048 41 125 59 125 330 2016 321 2017 2049 40 601 2016 321 2017 38 2050 41 601 123 792 40 2051 46 2052 40 41 42 2050 41 46 2053 40 2054 41 43 2055 43 2056 59 125 569 2057 40 41 59 865 2058 40 41 59 865 2059 40 41 59 865 2060 40 569 2061 61 655 41 59 773 58 809 603 660 2062 61 45 1504 59 2063 321 2064 2065 123 2066 40 2067 41 125 59 2022 2068 123 2069 125 59 2016 321 2037 2070 59 2016 321 2017 2071 59 2016 321 2017 2072 59 2016 321 2017 2073 59 660 2074 123 2075 125 59 2076 2077 123 45 1501 125 59 2006 2078 123 1500 125 59 2034 2079 123 45 1501 125 59 569 2080 123 655 125 59 2002 2081 123 1500 125 59 125 59 ,"{'AvgLine': 10, 'CountLine': 318, 'CountStmt': 165, 'MaxNesting': 5, 'AvgLineCode': 7, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 112, 'MaxEssential': 10, 'SumEssential': 39, 'AvgCyclomatic': 2, 'CountLineCode': 237, 'CountStmtDecl': 54, 'MaxCyclomatic': 12, 'SumCyclomatic': 65, 'AltAvgLineCode': 7, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 60, 'CountStmtEmpty': 4, 'AltAvgLineBlank': 1, 'CountDeclMethod': 27, 'AltCountLineCode': 237, 'CountLineCodeExe': 112, 'CountLineComment': 21, 'AltAvgLineComment': 0, 'AltCountLineBlank': 60, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 33, 'CountLineInactive': 0, 'CountDeclMethodAll': 27, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 21, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 14, 'SumCyclomaticStrict': 81, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 11, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 27, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 12, 'PercentLackOfCohesion': 87, 'SumCyclomaticModified': 62, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 27, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 12, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 10, 'CountDeclInstanceVariableProtected': 0}"
118398,C++,"class Text : public ChatLineContent
{
    Q_OBJECT

public:
    enum TextType
    {
        NORMAL,
        ACTION,
        CUSTOM
    };

    Text(const QString& txt = """", const QFont& font = QFont(), bool enableElide = false,
         const QString& rawText = QString(), const TextType& type = NORMAL, const QColor& custom = Style::getColor(Style::MainText));
    virtual ~Text();

    void setText(const QString& txt);
    void selectText(const QString& txt, const std::pair<int, int>& point);
    void selectText(const QRegularExpression& exp, const std::pair<int, int>& point);
    void deselectText();

    void setWidth(qreal width) final;

    void selectionMouseMove(QPointF scenePos) final;
    void selectionStarted(QPointF scenePos) final;
    void selectionCleared() final;
    void selectionDoubleClick(QPointF scenePos) final;
    void selectionTripleClick(QPointF scenePos) final;
    void selectionFocusChanged(bool focusIn) final;
    bool isOverSelection(QPointF scenePos) const final;
    QString getSelectedText() const final;
    void fontChanged(const QFont& font) final;

    QRectF boundingRect() const final;
    void paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget) final;

    void visibilityChanged(bool keepInMemory) final;
    void reloadTheme() final;

    qreal getAscent() const final;
    void mousePressEvent(QGraphicsSceneMouseEvent* event) final;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) final;
    void hoverMoveEvent(QGraphicsSceneHoverEvent* event) final;

    QString getText() const final;
    QString getLinkAt(QPointF scenePos) const;

protected:
    // dynamic resource management
    void regenerate();
    void freeResources();

    virtual QSizeF idealSize();
    int cursorFromPos(QPointF scenePos, bool fuzzy = true) const;
    int getSelectionEnd() const;
    int getSelectionStart() const;
    bool hasSelection() const;
    QString extractSanitizedText(int from, int to) const;
    QString extractImgTooltip(int pos) const;

    QTextDocument* doc = nullptr;
    QSizeF size;
    qreal width = 0.0;

private:
    void selectText(QTextCursor& cursor, const std::pair<int, int>& point);
    QColor textColor() const;

    QString text;
    QString rawText;
    QString selectedText;
    bool keepInMemory = false;
    bool elide = false;
    bool dirty = false;
    bool selectionHasFocus = true;
    int selectionEnd = -1;
    int selectionAnchor = -1;
    qreal ascent = 0.0;
    QFont defFont;
    QString defStyleSheet;
    TextType textType;
    QColor color;
    QColor customColor;
};",1,587 2000 58 777 2001 123 2002 777 58 640 2003 123 2004 44 2005 44 2006 125 59 2000 40 601 2007 38 2008 61 362 44 601 2009 38 2010 61 2009 40 41 44 569 2011 61 655 44 601 2007 38 2012 61 2007 40 41 44 601 2003 38 2013 61 2014 44 601 2015 38 2016 61 2017 321 2018 40 2017 321 2019 41 41 59 864 126 2000 40 41 59 865 2020 40 601 2007 38 2008 41 59 865 2021 40 601 2007 38 2008 44 601 2022 321 2023 60 704 44 704 62 38 2024 41 59 865 2021 40 601 2025 38 2026 44 601 2022 321 2023 60 704 44 704 62 38 2024 41 59 865 2027 40 41 59 865 2028 40 2029 2030 41 2031 59 865 2032 40 2033 2034 41 2031 59 865 2035 40 2033 2034 41 2031 59 865 2036 40 41 2031 59 865 2037 40 2033 2034 41 2031 59 865 2038 40 2033 2034 41 2031 59 865 2039 40 569 2040 41 2031 59 569 2041 40 2033 2034 41 601 2031 59 2007 2042 40 41 601 2031 59 865 2043 40 601 2009 38 2010 41 2031 59 2044 2045 40 41 601 2031 59 865 2046 40 2047 42 2048 44 601 2049 42 2050 44 2051 42 2052 41 2031 59 865 2053 40 569 2054 41 2031 59 865 2055 40 41 2031 59 2029 2056 40 41 601 2031 59 865 2057 40 2058 42 2059 41 2031 59 865 2060 40 2058 42 2059 41 2031 59 865 2061 40 2062 42 2059 41 2031 59 2007 2063 40 41 601 2031 59 2007 2064 40 2033 2034 41 601 59 775 58 330 865 2065 40 41 59 865 2066 40 41 59 864 2067 2068 40 41 59 704 2069 40 2033 2034 44 569 2070 61 829 41 601 59 704 2071 40 41 601 59 704 2072 40 41 601 59 569 2073 40 41 601 59 2007 2074 40 704 2075 44 704 2076 41 601 59 2007 2077 40 704 2078 41 601 59 2079 42 2080 61 753 59 2067 2081 59 2029 2030 61 1500 59 773 58 865 2021 40 2082 38 2083 44 601 2022 321 2023 60 704 44 704 62 38 2024 41 59 2015 2084 40 41 601 59 2007 2085 59 2007 2012 59 2007 2086 59 569 2054 61 655 59 569 2087 61 655 59 569 2088 61 655 59 569 2089 61 829 59 704 2090 61 45 1501 59 704 2091 61 45 1501 59 2029 2092 61 1500 59 2009 2093 59 2007 2094 59 2003 2095 59 2015 2096 59 2015 2097 59 125 59 ,"{'AvgLine': 11, 'CountLine': 491, 'CountStmt': 163, 'MaxNesting': 2, 'AvgLineCode': 9, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 74, 'MaxEssential': 1, 'SumEssential': 37, 'AvgCyclomatic': 1, 'CountLineCode': 404, 'CountStmtDecl': 89, 'MaxCyclomatic': 6, 'SumCyclomatic': 61, 'AltAvgLineCode': 9, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 74, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 37, 'AltCountLineCode': 404, 'CountLineCodeExe': 71, 'CountLineComment': 16, 'AltAvgLineComment': 0, 'AltCountLineBlank': 74, 'CountClassCoupled': 4, 'CountClassDerived': 1, 'CountLineCodeDecl': 67, 'CountLineInactive': 0, 'CountDeclMethodAll': 57, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 16, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 62, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 13, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 25, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 95, 'SumCyclomaticModified': 61, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 7, 'CountDeclInstanceMethod': 40, 'CountDeclMethodProtected': 5, 'CountDeclInstanceVariable': 18, 'CountDeclInstanceVariablePublic': 11, 'CountDeclInstanceVariablePrivate': 6, 'CountDeclInstanceVariableProtected': 1}"
118545,C++,"class CoreFile : public QObject
{
    Q_OBJECT

public:
    void handleAvatarOffer(uint32_t friendId, uint32_t fileId, bool accept);
    static CoreFilePtr makeCoreFile(Core* core, Tox* tox, CompatibleRecursiveMutex& coreLoopLock);

    void sendFile(uint32_t friendId, QString filename, QString filePath,
                         long long filesize);
    void sendAvatarFile(uint32_t friendId, const QByteArray& data);
    void pauseResumeFile(uint32_t friendId, uint32_t fileId);
    void cancelFileSend(uint32_t friendId, uint32_t fileId);

    void cancelFileRecv(uint32_t friendId, uint32_t fileId);
    void rejectFileRecvRequest(uint32_t friendId, uint32_t fileId);
    void acceptFileRecvRequest(uint32_t friendId, uint32_t fileId, QString path);

    unsigned corefileIterationInterval();

signals:
    void fileSendStarted(ToxFile file);
    void fileReceiveRequested(ToxFile file);
    void fileTransferAccepted(ToxFile file);
    void fileTransferCancelled(ToxFile file);
    void fileTransferFinished(ToxFile file);
    void fileTransferPaused(ToxFile file);
    void fileTransferInfo(ToxFile file);
    void fileTransferRemotePausedUnpaused(ToxFile file, bool paused);
    void fileTransferBrokenUnbroken(ToxFile file, bool broken);
    void fileNameChanged(const ToxPk& friendPk);
    void fileSendFailed(uint32_t friendId, const QString& fname);

private:
    CoreFile(Tox* core, CompatibleRecursiveMutex& coreLoopLock);

    ToxFile* findFile(uint32_t friendId, uint32_t fileId);
    void addFile(uint32_t friendId, uint32_t fileId, const ToxFile& file);
    void removeFile(uint32_t friendId, uint32_t fileId);
    static constexpr uint64_t getFriendKey(uint32_t friendId, uint32_t fileId)
    {
        return (static_cast<std::uint64_t>(friendId) << 32) + fileId;
    }

    static void connectCallbacks(Tox& tox);
    static void onFileReceiveCallback(Tox* tox, uint32_t friendId, uint32_t fileId, uint32_t kind,
                                      uint64_t filesize, const uint8_t* fname, size_t fnameLen,
                                      void* vCore);
    static void onFileControlCallback(Tox* tox, uint32_t friendId, uint32_t fileId,
                                      Tox_File_Control control, void* vCore);
    static void onFileDataCallback(Tox* tox, uint32_t friendId, uint32_t fileId, uint64_t pos,
                                   size_t length, void* vCore);
    static void onFileRecvChunkCallback(Tox* tox, uint32_t friendId, uint32_t fileId, uint64_t position,
                                        const uint8_t* data, size_t length, void* vCore);

    static QString getCleanFileName(QString filename);

private slots:
    void onConnectionStatusChanged(uint32_t friendId, Status::Status state);

private:
    QHash<uint64_t, ToxFile> fileMap;
    Tox* tox;
    CompatibleRecursiveMutex* coreLoopLock = nullptr;
};",1,587 2000 58 777 2001 123 2002 777 58 865 2003 40 2004 2005 44 2004 2006 44 569 2007 41 59 809 2008 2009 40 2010 42 2011 44 2012 42 2013 44 2014 38 2015 41 59 865 2016 40 2004 2005 44 2017 2018 44 2017 2019 44 726 726 2020 41 59 865 2021 40 2004 2005 44 601 2022 38 2023 41 59 865 2024 40 2004 2005 44 2004 2006 41 59 865 2025 40 2004 2005 44 2004 2006 41 59 865 2026 40 2004 2005 44 2004 2006 41 59 865 2027 40 2004 2005 44 2004 2006 41 59 865 2028 40 2004 2005 44 2004 2006 44 2017 2029 41 59 856 2030 40 41 59 2031 58 865 2032 40 2033 2034 41 59 865 2035 40 2033 2034 41 59 865 2036 40 2033 2034 41 59 865 2037 40 2033 2034 41 59 865 2038 40 2033 2034 41 59 865 2039 40 2033 2034 41 59 865 2040 40 2033 2034 41 59 865 2041 40 2033 2034 44 569 2042 41 59 865 2043 40 2033 2034 44 569 2044 41 59 865 2045 40 601 2046 38 2047 41 59 865 2048 40 2004 2005 44 601 2017 38 2049 41 59 773 58 2000 40 2012 42 2011 44 2014 38 2015 41 59 2033 42 2050 40 2004 2005 44 2004 2006 41 59 865 2051 40 2004 2005 44 2004 2006 44 601 2033 38 2034 41 59 865 2052 40 2004 2005 44 2004 2006 41 59 809 603 2053 2054 40 2004 2005 44 2004 2006 41 123 792 40 811 60 2055 321 2053 62 40 2005 41 332 1503 41 43 2006 59 125 809 865 2056 40 2012 38 2013 41 59 809 865 2057 40 2012 42 2013 44 2004 2005 44 2004 2006 44 2004 2058 44 2053 2020 44 601 2059 42 2049 44 2060 2061 44 865 42 2062 41 59 809 865 2063 40 2012 42 2013 44 2004 2005 44 2004 2006 44 2064 2065 44 865 42 2062 41 59 809 865 2066 40 2012 42 2013 44 2004 2005 44 2004 2006 44 2053 2067 44 2060 2068 44 865 42 2062 41 59 809 865 2069 40 2012 42 2013 44 2004 2005 44 2004 2006 44 2053 2070 44 601 2059 42 2023 44 2060 2068 44 865 42 2062 41 59 809 2017 2071 40 2017 2018 41 59 773 2072 58 865 2073 40 2004 2005 44 2074 321 2074 2075 41 59 773 58 2076 60 2053 44 2033 62 2077 59 2012 42 2013 59 2014 42 2015 61 753 59 125 59 ,"{'AvgLine': 22, 'CountLine': 553, 'CountStmt': 259, 'MaxNesting': 3, 'AvgLineCode': 19, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 158, 'MaxEssential': 6, 'SumEssential': 37, 'AvgCyclomatic': 3, 'CountLineCode': 486, 'CountStmtDecl': 118, 'MaxCyclomatic': 9, 'SumCyclomatic': 68, 'AltAvgLineCode': 19, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 49, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 32, 'AltCountLineCode': 486, 'CountLineCodeExe': 173, 'CountLineComment': 18, 'AltAvgLineComment': 0, 'AltCountLineBlank': 49, 'CountClassCoupled': 7, 'CountClassDerived': 0, 'CountLineCodeDecl': 107, 'CountLineInactive': 0, 'CountDeclMethodAll': 32, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 18, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 9, 'SumCyclomaticStrict': 69, 'CountDeclClassMethod': 5, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 8, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 9, 'PercentLackOfCohesion': 96, 'SumCyclomaticModified': 68, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 24, 'CountDeclInstanceMethod': 27, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 5, 'CountDeclInstanceVariablePublic': 3, 'CountDeclInstanceVariablePrivate': 2, 'CountDeclInstanceVariableProtected': 0}"
118389,C++,"class Mission : public MissionBlock, public ModuleParams
{
public:
	Mission(Navigator *navigator);
	~Mission() override = default;

	void on_inactive() override;
	void on_inactivation() override;
	void on_activation() override;
	void on_active() override;

	bool set_current_mission_index(uint16_t index);

	bool land_start();
	bool landing();

	uint16_t get_land_start_index() const { return _land_start_index; }
	bool get_land_start_available() const { return _land_start_available; }
	bool get_mission_finished() const { return _mission_type == MISSION_TYPE_NONE; }
	bool get_mission_changed() const { return _mission_changed ; }
	bool get_mission_waypoints_changed() const { return _mission_waypoints_changed ; }
	double get_landing_start_lat() { return _landing_start_lat; }
	double get_landing_start_lon() { return _landing_start_lon; }
	float get_landing_start_alt() { return _landing_start_alt; }

	double get_landing_lat() { return _landing_lat; }
	double get_landing_lon() { return _landing_lon; }
	float get_landing_alt() { return _landing_alt; }

	void set_closest_item_as_current();

	/**
	 * Set a new mission mode and handle the switching between the different modes
	 *
	 * For a list of the different modes refer to mission_result.msg
	 */
	void set_execution_mode(const uint8_t mode);
private:

	void mission_init();

	/**
	 * Update mission topic
	 */
	void update_mission();

	/**
	 * Move on to next mission item or switch to loiter
	 */
	void advance_mission();

	/**
	 * Set new mission items
	 */
	void set_mission_items();

	/**
	 * Returns true if we need to do a takeoff at the current state
	 */
	bool do_need_vertical_takeoff();

	/**
	 * Returns true if we need to move to waypoint location before starting descent
	 */
	bool do_need_move_to_land();

	/**
	 * Returns true if we need to move to waypoint location after vtol takeoff
	 */
	bool do_need_move_to_takeoff();

	/**
	 * Copies position from setpoint if valid, otherwise copies current position
	 */
	void copy_position_if_valid(struct mission_item_s *mission_item, struct position_setpoint_s *setpoint);

	/**
	 * Create mission item to align towards next waypoint
	 */
	void set_align_mission_item(struct mission_item_s *mission_item, struct mission_item_s *mission_item_next);

	/**
	 * Calculate takeoff height for mission item considering ground clearance
	 */
	float calculate_takeoff_altitude(struct mission_item_s *mission_item);

	/**
	 * Updates the heading of the vehicle. Rotary wings only.
	 */
	void heading_sp_update();

	/**
	 * Update the cruising speed setpoint.
	 */
	void cruising_speed_sp_update();

	/**
	 * Abort landing
	 */
	void do_abort_landing();

	/**
	 * Read the current and the next mission item. The next mission item read is the
	 * next mission item that contains a position.
	 *
	 * @return true if current mission item available
	 */
	bool prepare_mission_items(mission_item_s *mission_item,
				   mission_item_s *next_position_mission_item, bool *has_next_position_item,
				   mission_item_s *next_next_position_mission_item = nullptr, bool *has_next_next_position_item = nullptr);

	/**
	 * Read current (offset == 0) or a specific (offset > 0) mission item
	 * from the dataman and watch out for DO_JUMPS
	 *
	 * @return true if successful
	 */
	bool read_mission_item(int offset, struct mission_item_s *mission_item);

	/**
	 * Save current mission state to dataman
	 */
	void save_mission_state();

	/**
	 * Inform about a changed mission item after a DO_JUMP
	 */
	void report_do_jump_mission_changed(int index, int do_jumps_remaining);

	/**
	 * Set a mission item as reached
	 */
	void set_mission_item_reached();

	/**
	 * Set the current mission item
	 */
	void set_current_mission_item();

	/**
	 * Check whether a mission is ready to go
	 */
	void check_mission_valid(bool force);

	/**
	 * Reset mission
	 */
	void reset_mission(struct mission_s &mission);

	/**
	 * Returns true if we need to reset the mission (call this only when inactive)
	 */
	bool need_to_reset_mission();

	/**
	 * Find and store the index of the landing sequence (DO_LAND_START)
	 */
	bool find_mission_land_start();

	/**
	 * Return the index of the closest mission item to the current global position.
	 */
	int32_t index_closest_mission_item() const;

	bool position_setpoint_equal(const position_setpoint_s *p1, const position_setpoint_s *p2) const;

	void publish_navigator_mission_item();

	DEFINE_PARAMETERS(
		(ParamFloat<px4::params::MIS_DIST_1WP>) _param_mis_dist_1wp,
		(ParamFloat<px4::params::MIS_DIST_WPS>) _param_mis_dist_wps,
		(ParamInt<px4::params::MIS_MNT_YAW_CTL>) _param_mis_mnt_yaw_ctl
	)

	uORB::Publication<navigator_mission_item_s> _navigator_mission_item_pub{ORB_ID::navigator_mission_item};

	uORB::Subscription	_mission_sub{ORB_ID(mission)};		/**< mission subscription */
	mission_s		_mission {};

	int32_t _current_mission_index{-1};

	// track location of planned mission landing
	bool	_land_start_available{false};
	uint16_t _land_start_index{UINT16_MAX};		/**< index of DO_LAND_START, INVALID_DO_LAND_START if no planned landing */
	double _landing_start_lat{0.0};
	double _landing_start_lon{0.0};
	float _landing_start_alt{0.0f};

	double _landing_lat{0.0};
	double _landing_lon{0.0};
	float _landing_alt{0.0f};

	bool _need_takeoff{true};					/**< if true, then takeoff must be performed before going to the first waypoint (if needed) */

	hrt_abstime _time_mission_deactivated{0};

	enum {
		MISSION_TYPE_NONE,
		MISSION_TYPE_MISSION
	} _mission_type{MISSION_TYPE_NONE};

	bool _inited{false};
	bool _home_inited{false};
	bool _need_mission_reset{false};
	bool _mission_waypoints_changed{false};
	bool _mission_changed{false}; /** < true if the mission changed since the mission mode was active */

	enum work_item_type {
		WORK_ITEM_TYPE_DEFAULT,		/**< default mission item */
		WORK_ITEM_TYPE_TAKEOFF,		/**< takeoff before moving to waypoint */
		WORK_ITEM_TYPE_MOVE_TO_LAND,	/**< move to land waypoint before descent */
		WORK_ITEM_TYPE_ALIGN,		/**< align for next waypoint */
		WORK_ITEM_TYPE_TRANSITON_AFTER_TAKEOFF,
		WORK_ITEM_TYPE_MOVE_TO_LAND_AFTER_TRANSITION,
		WORK_ITEM_TYPE_PRECISION_LAND
	} _work_item_type{WORK_ITEM_TYPE_DEFAULT};	/**< current type of work to do (sub mission item) */

	uint8_t _mission_execution_mode{mission_result_s::MISSION_EXECUTION_MODE_NORMAL};	/**< the current mode of how the mission is executed,look at mission_result.msg for the definition */
	bool _execution_mode_changed{false};
};",1,587 2000 58 777 2001 44 777 2002 123 777 58 2000 40 2003 42 2004 41 59 126 2000 40 41 2005 61 613 59 865 2006 40 41 2005 59 865 2007 40 41 2005 59 865 2008 40 41 2005 59 865 2009 40 41 2005 59 569 2010 40 2011 2012 41 59 569 2013 40 41 59 569 2014 40 41 59 2011 2015 40 41 601 123 792 2016 59 125 569 2017 40 41 601 123 792 2018 59 125 569 2019 40 41 601 123 792 2020 323 2021 59 125 569 2022 40 41 601 123 792 2023 59 125 569 2024 40 41 601 123 792 2025 59 125 625 2026 40 41 123 792 2027 59 125 625 2028 40 41 123 792 2029 59 125 660 2030 40 41 123 792 2031 59 125 625 2032 40 41 123 792 2033 59 125 625 2034 40 41 123 792 2035 59 125 660 2036 40 41 123 792 2037 59 125 865 2038 40 41 59 306 865 2039 40 601 2040 2041 41 59 773 58 865 2042 40 41 59 306 865 2043 40 41 59 306 865 2044 40 41 59 306 865 2045 40 41 59 306 569 2046 40 41 59 306 569 2047 40 41 59 306 569 2048 40 41 59 306 865 2049 40 816 2050 42 2051 44 816 2052 42 2053 41 59 306 865 2054 40 816 2050 42 2051 44 816 2050 42 2055 41 59 306 660 2056 40 816 2050 42 2051 41 59 306 865 2057 40 41 59 306 865 2058 40 41 59 306 865 2059 40 41 59 306 569 2060 40 2050 42 2051 44 2050 42 2061 44 569 42 2062 44 2050 42 2063 61 753 44 569 42 2064 61 753 41 59 306 569 2065 40 704 2066 44 816 2050 42 2051 41 59 306 865 2067 40 41 59 306 865 2068 40 704 2012 44 704 2069 41 59 306 865 2070 40 41 59 306 865 2071 40 41 59 306 865 2072 40 569 2073 41 59 306 865 2074 40 816 2075 38 2076 41 59 306 569 2077 40 41 59 306 569 2078 40 41 59 306 2079 2080 40 41 601 59 569 2081 40 601 2052 42 2082 44 601 2052 42 2083 41 601 59 865 2084 40 41 59 2085 40 40 2086 60 2087 321 2088 321 2089 62 41 2090 44 40 2086 60 2087 321 2088 321 2091 62 41 2092 44 40 2093 60 2087 321 2088 321 2094 62 41 2095 41 2096 321 2097 60 2098 62 2099 123 2100 321 2101 125 59 2096 321 2102 2103 123 2104 40 2076 41 125 59 306 2075 2105 123 125 59 2079 2106 123 45 1501 125 59 330 569 2107 123 655 125 59 2011 2108 123 2109 125 59 306 625 2110 123 1500 125 59 625 2111 123 1500 125 59 660 2112 123 1500 125 59 625 2113 123 1500 125 59 625 2114 123 1500 125 59 660 2115 123 1500 125 59 569 2116 123 829 125 59 306 2117 2118 123 1500 125 59 640 123 2119 44 2120 125 2121 123 2122 125 59 569 2123 123 655 125 59 569 2124 123 655 125 59 569 2125 123 655 125 59 569 2126 123 655 125 59 569 2127 123 655 125 59 306 640 2128 123 2129 44 306 2130 44 306 2131 44 306 2132 44 306 2133 44 2134 44 2135 125 2136 123 2137 125 59 306 2040 2138 123 2139 321 2140 125 59 306 569 2141 123 655 125 59 125 59 ,"{'AvgLine': 39, 'CountLine': 2044, 'CountStmt': 525, 'MaxNesting': 7, 'AvgLineCode': 26, 'AvgEssential': 1, 'AvgLineBlank': 7, 'CountStmtExe': 369, 'MaxEssential': 9, 'SumEssential': 71, 'AvgCyclomatic': 4, 'CountLineCode': 1313, 'CountStmtDecl': 159, 'MaxCyclomatic': 34, 'SumCyclomatic': 196, 'AltAvgLineCode': 26, 'AvgLineComment': 5, 'CountClassBase': 2, 'CountLineBlank': 406, 'CountStmtEmpty': 14, 'AltAvgLineBlank': 7, 'CountDeclMethod': 49, 'AltCountLineCode': 1313, 'CountLineCodeExe': 334, 'CountLineComment': 339, 'AltAvgLineComment': 5, 'AltCountLineBlank': 406, 'CountClassCoupled': 13, 'CountClassDerived': 0, 'CountLineCodeDecl': 133, 'CountLineInactive': 0, 'CountDeclMethodAll': 89, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.26', 'AltCountLineComment': 339, 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 35, 'SumCyclomaticStrict': 214, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 7, 'AvgCyclomaticModified': 4, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 22, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 34, 'PercentLackOfCohesion': 96, 'SumCyclomaticModified': 195, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 26, 'CountDeclInstanceMethod': 51, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 26, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 19, 'CountDeclInstanceVariableProtected': 0}"
118405,C++,"class Friend : public Contact
{
    Q_OBJECT
public:
    Friend(uint32_t friendId, const ToxPk& friendPk, const QString& userAlias = {}, const QString &userName = {});
    Friend(const Friend& other) = delete;
    Friend& operator=(const Friend& other) = delete;

    void setName(const QString& name) override;
    void setAlias(const QString& name);
    QString getDisplayedName() const override;
    bool hasAlias() const;
    QString getUserName() const;
    void setStatusMessage(const QString& message);
    QString getStatusMessage() const;

    void setEventFlag(bool f) override;
    bool getEventFlag() const override;

    const ToxPk& getPublicKey() const;
    uint32_t getId() const override;
    const ContactId& getPersistentId() const override;

    void finishNegotiation();
    void setStatus(Status::Status s);
    Status::Status getStatus() const;

    void setExtendedMessageSupport(bool supported);
    ExtensionSet getSupportedExtensions() const;

signals:
    void nameChanged(const ToxPk& friendId, const QString& name);
    void aliasChanged(const ToxPk& friendId, QString alias);
    void statusChanged(const ToxPk& friendId, Status::Status status);
    void onlineOfflineChanged(const ToxPk& friendId, bool isOnline);
    void statusMessageChanged(const ToxPk& friendId, const QString& message);
    void extensionSupportChanged(ExtensionSet extensions);
    void loadChatHistory();

public slots:
    void onNegotiationComplete();
private:
    QString userName;
    QString userAlias;
    QString statusMessage;
    ToxPk friendPk;
    uint32_t friendId;
    bool hasNewEvents;
    Status::Status friendStatus;
    bool isNegotiating;
    ExtensionSet supportedExtensions;
};",1,587 2000 58 777 2001 123 2002 777 58 2000 40 2003 2004 44 601 2005 38 2006 44 601 2007 38 2008 61 123 125 44 601 2007 38 2009 61 123 125 41 59 2000 40 601 2000 38 2010 41 61 619 59 2000 38 758 61 40 601 2000 38 2010 41 61 619 59 865 2011 40 601 2007 38 2012 41 2013 59 865 2014 40 601 2007 38 2012 41 59 2007 2015 40 41 601 2013 59 569 2016 40 41 601 59 2007 2017 40 41 601 59 865 2018 40 601 2007 38 2019 41 59 2007 2020 40 41 601 59 865 2021 40 569 2022 41 2013 59 569 2023 40 41 601 2013 59 601 2005 38 2024 40 41 601 59 2003 2025 40 41 601 2013 59 601 2026 38 2027 40 41 601 2013 59 865 2028 40 41 59 865 2029 40 2030 321 2030 2031 41 59 2030 321 2030 2032 40 41 601 59 865 2033 40 569 2034 41 59 2035 2036 40 41 601 59 2037 58 865 2038 40 601 2005 38 2004 44 601 2007 38 2012 41 59 865 2039 40 601 2005 38 2004 44 2007 2040 41 59 865 2041 40 601 2005 38 2004 44 2030 321 2030 2042 41 59 865 2043 40 601 2005 38 2004 44 569 2044 41 59 865 2045 40 601 2005 38 2004 44 601 2007 38 2019 41 59 865 2046 40 2035 2047 41 59 865 2048 40 41 59 777 2049 58 865 2050 40 41 59 773 58 2007 2009 59 2007 2008 59 2007 2051 59 2005 2006 59 2003 2004 59 569 2052 59 2030 321 2030 2053 59 569 2054 59 2035 2055 59 125 59 ,"{'AvgLine': 9, 'CountLine': 217, 'CountStmt': 91, 'MaxNesting': 2, 'AvgLineCode': 7, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 34, 'MaxEssential': 1, 'SumEssential': 18, 'AvgCyclomatic': 2, 'CountLineCode': 188, 'CountStmtDecl': 59, 'MaxCyclomatic': 8, 'SumCyclomatic': 38, 'AltAvgLineCode': 7, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 21, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 27, 'AltCountLineCode': 188, 'CountLineCodeExe': 30, 'CountLineComment': 9, 'AltAvgLineComment': 0, 'AltCountLineBlank': 21, 'CountClassCoupled': 4, 'CountClassDerived': 0, 'CountLineCodeDecl': 40, 'CountLineInactive': 0, 'CountDeclMethodAll': 34, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.05', 'AltCountLineComment': 9, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 11, 'SumCyclomaticStrict': 41, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 10, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 9, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 8, 'PercentLackOfCohesion': 95, 'SumCyclomaticModified': 38, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 18, 'CountDeclInstanceMethod': 28, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 11, 'CountDeclInstanceVariablePublic': 7, 'CountDeclInstanceVariablePrivate': 4, 'CountDeclInstanceVariableProtected': 0}"
98853,C++,"class OGREDIGEODataSource final: public OGRDataSource
{
    friend class OGREDIGEOLayer;

    char*               pszName;
    VSILFILE*           fpTHF;

    OGRLayer**          papoLayers;
    int                 nLayers;

    VSILFILE*           OpenFile(const char *pszType,
                                 const CPLString& osExt);

    // TODO: Translate comments to English.
    CPLString osLON; /* Nom du lot */
    CPLString osGNN; /* Nom du sous-ensemble de données générales */
    CPLString osGON; /* Nom du sous-ensemble de la référence de coordonnées */
    CPLString osQAN; /* Nom du sous-ensemble de qualité */
    CPLString osDIN; /* Nom du sous-ensemble de définition de la nomenclature */
    CPLString osSCN; /* Nom du sous-ensemble de définition du SCD */
    strListType aosGDN; /* Nom du sous-ensemble de données géographiques */
    int                 ReadTHF(VSILFILE* fp);

    CPLString           osREL;
    OGRSpatialReference* poSRS;
    int                 ReadGEO();

    /* Map from ID_N_OBJ_E_2_1_0 to OBJ_E_2_1_0 */
    std::map<CPLString,CPLString> mapObjects;

    /* Map from ID_N_ATT_TEX2 to (osLAB=TEX2, osTYP=T) */
    std::map<CPLString,OGREDIGEOAttributeDef> mapAttributes;
    int                 ReadDIC();

    std::vector<OGREDIGEOObjectDescriptor> aoObjList;
    /* Map from TEX2_id to (osNameRID=ID_N_ATT_TEX2, nWidth=80) */
    std::map<CPLString,OGREDIGEOAttributeDescriptor> mapAttributesSCD;
    int                 ReadSCD();

    int                 bExtentValid;
    double              dfMinX;
    double              dfMinY;
    double              dfMaxX;
    double              dfMaxY;
    int                 ReadGEN();

    /* Map from Actualite_Objet_X to (creationData, updateData) */
    std::map<CPLString,intintType> mapQAL;
    int                 ReadQAL();

    std::map<CPLString, OGREDIGEOLayer*> mapLayer;

    int                 CreateLayerFromObjectDesc(const OGREDIGEOObjectDescriptor& objDesc);

    std::map< CPLString, xyPairType >                 mapPNO; /* Map Noeud_X to (x,y) */
    std::map< CPLString, xyPairListType >             mapPAR; /* Map Arc_X to ((x1,y1),...(xn,yn)) */
    std::map< CPLString, OGREDIGEOFEADesc >           mapFEA; /* Map Object_X to FEADesc */
    std::map< CPLString, strListType >                mapPFE_PAR; /* Map Face_X to (Arc_X1,..Arc_Xn) */
    std::vector< std::pair<CPLString, strListType > > listFEA_PFE; /* List of (Object_X,(Face_Y1,..Face_Yn)) */
    std::vector< std::pair<CPLString, strListType > > listFEA_PAR; /* List of (Object_X,(Arc_Y1,..Arc_Yn))) */
    std::vector< strstrType >                         listFEA_PNO; /* List of (Object_X,Noeud_Y) */
    std::map< CPLString, CPLString>                   mapFEA_FEA; /* Map Attribut_TEX{X}_id_Objet_{Y} to Objet_Y */

    int                 bRecodeToUTF8;
    int                 bHasUTF8ContentOnly;

    int                 ReadVEC(const char* pszVECName);

    OGRFeature*         CreateFeature(const CPLString& osFEA);
    int                 BuildPoints();
    int                 BuildLineStrings();
    int                 BuildPolygon(const CPLString& osFEA,
                                     const strListType& aosPFE);
    int                 BuildPolygons();

    int                 iATR, iDI3, iDI4, iHEI, iFON;
    int                 iATR_VAL, iANGLE, iSIZE, iOBJ_LNK, iOBJ_LNK_LAYER;
    double              dfSizeFactor;
    int                 bIncludeFontFamily;
    int                 SetStyle(const CPLString& osFEA,
                                 OGRFeature* poFeature);

    std::set< CPLString >  setLayersWithLabels;
    void                CreateLabelLayers();

    int                 bHasReadEDIGEO;
    void                ReadEDIGEO();

  public:
                        OGREDIGEODataSource();
                        virtual ~OGREDIGEODataSource();

    int                 Open( const char * pszFilename );

    virtual const char*         GetName() override { return pszName; }

    virtual int                 GetLayerCount() override;
    virtual OGRLayer*           GetLayer( int ) override;

    virtual int                 TestCapability( const char * ) override;

    int                         HasUTF8ContentOnly() { return bHasUTF8ContentOnly; }
};",1,587 2000 2001 58 777 2002 123 667 587 2003 59 582 42 2004 59 2005 42 2006 59 2007 42 42 2008 59 704 2009 59 2005 42 2010 40 601 582 42 2011 44 601 2012 38 2013 41 59 330 2012 2014 59 305 2012 2015 59 305 2012 2016 59 305 2012 2017 59 305 2012 2018 59 305 2012 2019 59 305 2020 2021 59 305 704 2022 40 2005 42 2023 41 59 2012 2024 59 2025 42 2026 59 704 2027 40 41 59 305 2028 321 2029 60 2012 44 2012 62 2030 59 305 2028 321 2029 60 2012 44 2031 62 2032 59 704 2033 40 41 59 2028 321 2034 60 2035 62 2036 59 305 2028 321 2029 60 2012 44 2037 62 2038 59 704 2039 40 41 59 704 2040 59 625 2041 59 625 2042 59 625 2043 59 625 2044 59 704 2045 40 41 59 305 2028 321 2029 60 2012 44 2046 62 2047 59 704 2048 40 41 59 2028 321 2029 60 2012 44 2003 42 62 2049 59 704 2050 40 601 2035 38 2051 41 59 2028 321 2029 60 2012 44 2052 62 2053 59 305 2028 321 2029 60 2012 44 2054 62 2055 59 305 2028 321 2029 60 2012 44 2056 62 2057 59 305 2028 321 2029 60 2012 44 2020 62 2058 59 305 2028 321 2034 60 2028 321 2059 60 2012 44 2020 62 62 2060 59 305 2028 321 2034 60 2028 321 2059 60 2012 44 2020 62 62 2061 59 305 2028 321 2034 60 2062 62 2063 59 305 2028 321 2029 60 2012 44 2012 62 2064 59 305 704 2065 59 704 2066 59 704 2067 40 601 582 42 2068 41 59 2069 42 2070 40 601 2012 38 2071 41 59 704 2072 40 41 59 704 2073 40 41 59 704 2074 40 601 2012 38 2071 44 601 2020 38 2075 41 59 704 2076 40 41 59 704 2077 44 2078 44 2079 44 2080 44 2081 59 704 2082 44 2083 44 2084 44 2085 44 2086 59 625 2087 59 704 2088 59 704 2089 40 601 2012 38 2071 44 2069 42 2090 41 59 2028 321 2091 60 2012 62 2092 59 865 2093 40 41 59 704 2094 59 865 2095 40 41 59 777 58 2000 40 41 59 864 126 2000 40 41 59 704 2096 40 601 582 42 2097 41 59 864 601 582 42 2098 40 41 2099 123 792 2004 59 125 864 704 2100 40 41 2099 59 864 2007 42 2101 40 704 41 2099 59 864 704 2102 40 601 582 42 41 2099 59 704 2103 40 41 123 792 2066 59 125 125 59 ,"{'AvgLine': 55, 'CountLine': 1481, 'CountStmt': 762, 'MaxNesting': 7, 'AvgLineCode': 47, 'AvgEssential': 3, 'AvgLineBlank': 4, 'CountStmtExe': 578, 'MaxEssential': 16, 'SumEssential': 95, 'AvgCyclomatic': 8, 'CountLineCode': 1264, 'CountStmtDecl': 271, 'MaxCyclomatic': 49, 'SumCyclomatic': 209, 'AltAvgLineCode': 47, 'AvgLineComment': 3, 'CountClassBase': 1, 'CountLineBlank': 139, 'CountStmtEmpty': 3, 'AltAvgLineBlank': 4, 'CountDeclMethod': 25, 'AltCountLineCode': 1264, 'CountLineCodeExe': 689, 'CountLineComment': 95, 'AltAvgLineComment': 3, 'AltCountLineBlank': 139, 'CountClassCoupled': 17, 'CountClassDerived': 0, 'CountLineCodeDecl': 200, 'CountLineInactive': 0, 'CountDeclMethodAll': 170, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.08', 'AltCountLineComment': 95, 'AvgCyclomaticStrict': 9, 'MaxCyclomaticStrict': 61, 'SumCyclomaticStrict': 242, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 8, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 8, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 49, 'PercentLackOfCohesion': 91, 'SumCyclomaticModified': 209, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 17, 'CountDeclInstanceMethod': 27, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 48, 'CountDeclInstanceVariablePublic': 15, 'CountDeclInstanceVariablePrivate': 33, 'CountDeclInstanceVariableProtected': 0}"
118410,C++,"class FriendListWidget : public QWidget
{
    Q_OBJECT
public:
    using SortingMode = Settings::FriendListSortingMode;
    explicit FriendListWidget(const Core& _core, Widget* parent, bool groupsOnTop = true);
    ~FriendListWidget();
    void setMode(SortingMode mode);
    SortingMode getMode() const;

    void addGroupWidget(GroupWidget* widget);
    void addFriendWidget(FriendWidget* w);
    void removeGroupWidget(GroupWidget* w);
    void removeFriendWidget(FriendWidget* w);
    void addCircleWidget(int id);
    void addCircleWidget(FriendWidget* widget = nullptr);
    void removeCircleWidget(CircleWidget* widget);
    void searchChatrooms(const QString& searchString, bool hideOnline = false,
                         bool hideOffline = false, bool hideGroups = false);

    void cycleContacts(GenericChatroomWidget* activeChatroomWidget, bool forward);

    void updateActivityTime(const QDateTime& date);

signals:
    void onCompactChanged(bool compact);
    void connectCircleWidget(CircleWidget& circleWidget);
    void searchCircle(CircleWidget& circleWidget);

public slots:
    void renameGroupWidget(GroupWidget* groupWidget, const QString& newName);
    void renameCircleWidget(CircleWidget* circleWidget, const QString& newName);
    void onGroupchatPositionChanged(bool top);
    void moveWidget(FriendWidget* w, Status::Status s, bool add = false);
    void itemsChanged();

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dropEvent(QDropEvent* event) override;

private slots:
    void dayTimeout();

private:
    CircleWidget* createCircleWidget(int id = -1);
    CategoryWidget* getTimeCategoryWidget(const Friend* frd) const;
    void sortByMode(SortingMode mode);
    void cleanMainLayout();
    QWidget* getNextWidgetForName(IFriendListItem* currentPos, bool forward) const;
    QVector<std::shared_ptr<IFriendListItem> > getItemsFromCircle(CircleWidget* circle) const;

    SortingMode mode;
    QVBoxLayout* listLayout = nullptr;
    QVBoxLayout* activityLayout = nullptr;
    QTimer* dayTimer;
    FriendListManager* manager;

    const Core& core;
};",1,587 2000 58 777 2001 123 2002 777 58 860 2003 61 2004 321 2005 59 648 2000 40 601 2006 38 2007 44 2008 42 2009 44 569 2010 61 829 41 59 126 2000 40 41 59 865 2011 40 2003 2012 41 59 2003 2013 40 41 601 59 865 2014 40 2015 42 2016 41 59 865 2017 40 2018 42 2019 41 59 865 2020 40 2015 42 2019 41 59 865 2021 40 2018 42 2019 41 59 865 2022 40 704 2023 41 59 865 2022 40 2018 42 2016 61 753 41 59 865 2024 40 2025 42 2016 41 59 865 2026 40 601 2027 38 2028 44 569 2029 61 655 44 569 2030 61 655 44 569 2031 61 655 41 59 865 2032 40 2033 42 2034 44 569 2035 41 59 865 2036 40 601 2037 38 2038 41 59 2039 58 865 2040 40 569 2041 41 59 865 2042 40 2025 38 2043 41 59 865 2044 40 2025 38 2043 41 59 777 2045 58 865 2046 40 2015 42 2047 44 601 2027 38 2048 41 59 865 2049 40 2025 42 2043 44 601 2027 38 2048 41 59 865 2050 40 569 2051 41 59 865 2052 40 2018 42 2019 44 2053 321 2053 2054 44 569 2055 61 655 41 59 865 2056 40 41 59 775 58 865 2057 40 2058 42 2059 41 2060 59 865 2061 40 2062 42 2059 41 2060 59 773 2045 58 865 2063 40 41 59 773 58 2025 42 2064 40 704 2023 61 45 1501 41 59 2065 42 2066 40 601 2067 42 2068 41 601 59 865 2069 40 2003 2012 41 59 865 2070 40 41 59 2001 42 2071 40 2072 42 2073 44 569 2035 41 601 59 2074 60 2075 321 2076 60 2072 62 62 2077 40 2025 42 2078 41 601 59 2003 2012 59 2079 42 2080 61 753 59 2079 42 2081 61 753 59 2082 42 2083 59 2084 42 2085 59 601 2006 38 2086 59 125 59 ,"{'AvgLine': 17, 'CountLine': 548, 'CountStmt': 236, 'MaxNesting': 4, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 141, 'MaxEssential': 10, 'SumEssential': 47, 'AvgCyclomatic': 2, 'CountLineCode': 460, 'CountStmtDecl': 121, 'MaxCyclomatic': 16, 'SumCyclomatic': 74, 'AltAvgLineCode': 14, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 70, 'CountStmtEmpty': 3, 'AltAvgLineBlank': 2, 'CountDeclMethod': 32, 'AltCountLineCode': 462, 'CountLineCodeExe': 139, 'CountLineComment': 19, 'AltAvgLineComment': 0, 'AltCountLineBlank': 70, 'CountClassCoupled': 19, 'CountClassDerived': 0, 'CountLineCodeDecl': 113, 'CountLineInactive': 0, 'CountDeclMethodAll': 32, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 19, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 17, 'SumCyclomaticStrict': 76, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 4, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 16, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 16, 'PercentLackOfCohesion': 94, 'SumCyclomaticModified': 74, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 16, 'CountDeclInstanceMethod': 32, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 9, 'CountDeclInstanceVariablePublic': 4, 'CountDeclInstanceVariablePrivate': 5, 'CountDeclInstanceVariableProtected': 0}"
117704,C++,"class FlightTask : public ModuleParams
{
public:
	FlightTask() :
		ModuleParams(nullptr)
	{
		_resetSetpoints();
		_constraints = empty_constraints;
	}

	virtual ~FlightTask() = default;

	/**
	 * Call once on the event where you switch to the task
	 * @param last_setpoint last output of the previous task
	 * @return true on success, false on error
	 */
	virtual bool activate(const vehicle_local_position_setpoint_s &last_setpoint);

	/**
	 * Call this to reset an active Flight Task
	 */
	virtual void reActivate();

	/**
	 * To be called to adopt parameters from an arrived vehicle command
	 * @param command received command message containing the parameters
	 * @return true if accepted, false if declined
	 */
	virtual bool applyCommandParameters(const vehicle_command_s &command) { return false; }

	/**
	 * Call before activate() or update()
	 * to initialize time and input data
	 * @return true on success, false on error
	 */
	virtual bool updateInitialize();

	/**
	 * To be called regularly in the control loop cycle to execute the task
	 * @return true on success, false on error
	 */
	virtual bool update();

	/**
	 * Get the output data
	 * @return task output setpoints that get executed by the positon controller
	 */
	const vehicle_local_position_setpoint_s getPositionSetpoint();

	const ekf_reset_counters_s getResetCounters() const { return _reset_counters; }
	void setResetCounters(const ekf_reset_counters_s &counters) { _reset_counters = counters; }

	/**
	 * Get vehicle constraints.
	 * The constraints can vary with task.
	 * @return constraints
	 */
	const vehicle_constraints_s &getConstraints() { return _constraints; }

	/**
	 * Get landing gear position.
	 * The constraints can vary with task.
	 * @return landing gear
	 */
	const landing_gear_s &getGear() { return _gear; }

	/**
	 * Get avoidance desired waypoint
	 * @return desired waypoints
	 */
	const vehicle_trajectory_waypoint_s &getAvoidanceWaypoint() { return _desired_waypoint; }

	/**
	 * Empty setpoint.
	 * All setpoints are set to NAN.
	 */
	static const vehicle_local_position_setpoint_s empty_setpoint;

	/**
	 * Empty constraints.
	 * All constraints are set to NAN.
	 */
	static const vehicle_constraints_s empty_constraints;

	/**
	 * default landing gear state
	 */
	static const landing_gear_s empty_landing_gear_default_keep;

	/**
	 * Call this whenever a parameter update notification is received (parameter_update uORB message)
	 */
	void handleParameterUpdate()
	{
		updateParams();
	}

	/**
	 * Sets an external yaw handler which can be used by any flight task to implement a different yaw control strategy.
	 * This method does nothing, each flighttask which wants to use the yaw handler needs to override this method.
	 */
	virtual void setYawHandler(WeatherVane *ext_yaw_handler) {}

	void updateVelocityControllerFeedback(const matrix::Vector3f &vel_sp,
					      const matrix::Vector3f &acc_sp)
	{
		_velocity_setpoint_feedback = vel_sp;
		_acceleration_setpoint_feedback = acc_sp;
	}

protected:
	uORB::SubscriptionData<vehicle_local_position_s> _sub_vehicle_local_position{ORB_ID(vehicle_local_position)};
	uORB::SubscriptionData<home_position_s> _sub_home_position{ORB_ID(home_position)};
	uORB::Subscription _vehicle_local_position_setpoint_sub{ORB_ID(vehicle_local_position_setpoint)};

	/** Reset all setpoints to NAN */
	void _resetSetpoints();

	/** Check and update local position */
	void _evaluateVehicleLocalPosition();
	void _evaluateVehicleLocalPositionSetpoint();
	void _evaluateDistanceToGround();

	/** Set constraints to default values */
	virtual void _setDefaultConstraints();

	/** Determine when to trigger a takeoff (ignored in flight) */
	virtual bool _checkTakeoff();

	/**
	 * Monitor the EKF reset counters and
	 * call the appropriate handling functions in case of a reset event
	 * TODO: add the delta values to all the handlers
	 */
	void _checkEkfResetCounters();
	virtual void _ekfResetHandlerPositionXY(const matrix::Vector2f &delta_xy) {};
	virtual void _ekfResetHandlerVelocityXY(const matrix::Vector2f &delta_vxy) {};
	virtual void _ekfResetHandlerPositionZ(float delta_z) {};
	virtual void _ekfResetHandlerVelocityZ(float delta_vz) {};
	virtual void _ekfResetHandlerHeading(float delta_psi) {};

	MapProjection _geo_projection{};
	float _global_local_alt0{NAN};

	/* Time abstraction */
	static constexpr uint64_t _timeout = 500000; /**< maximal time in us before a loop or data times out */

	float _deltatime{}; /**< passed time in seconds since the task was last updated */

	hrt_abstime _time_stamp_activate{}; /**< time stamp when task was activated */
	hrt_abstime _time_stamp_current{}; /**< time stamp at the beginning of the current task update */
	hrt_abstime _time_stamp_last{}; /**< time stamp when task was last updated */

	/* Current vehicle state */
	matrix::Vector3f _position; /**< current vehicle position */
	matrix::Vector3f _velocity; /**< current vehicle velocity */

	float _yaw{}; /**< current vehicle yaw heading */
	bool _is_yaw_good_for_control{}; /**< true if the yaw estimate can be used for yaw control */
	float _dist_to_bottom{}; /**< current height above ground level */
	float _dist_to_ground{}; /**< equals _dist_to_bottom if valid, height above home otherwise */

	/**
	 * Setpoints which the position controller has to execute.
	 * Setpoints that are set to NAN are not controlled. Not all setpoints can be set at the same time.
	 * If more than one type of setpoint is set, then order of control is a as follow: position, velocity,
	 * acceleration, thrust. The exception is _position_setpoint together with _velocity_setpoint, where the
	 * _velocity_setpoint and _acceleration_setpoint are used as feedforward.
	 * _jerk_setpoint does not executed but just serves as internal state.
	 */
	matrix::Vector3f _position_setpoint;
	matrix::Vector3f _velocity_setpoint;
	matrix::Vector3f _velocity_setpoint_feedback;
	matrix::Vector3f _acceleration_setpoint;
	matrix::Vector3f _acceleration_setpoint_feedback;
	matrix::Vector3f _jerk_setpoint;

	float _yaw_setpoint{};
	float _yawspeed_setpoint{};

	ekf_reset_counters_s _reset_counters{}; ///< Counters for estimator local position resets

	/**
	 * Vehicle constraints.
	 * The constraints can vary with tasks.
	 */
	vehicle_constraints_s _constraints{};

	landing_gear_s _gear{};

	/**
	 * Desired waypoints.
	 * Goals set by the FCU to be sent to the obstacle avoidance system.
	 */
	vehicle_trajectory_waypoint_s _desired_waypoint{};

	DEFINE_PARAMETERS_CUSTOM_PARENT(ModuleParams,
					(ParamFloat<px4::params::MPC_XY_VEL_MAX>) _param_mpc_xy_vel_max,
					(ParamFloat<px4::params::MPC_Z_VEL_MAX_DN>) _param_mpc_z_vel_max_dn,
					(ParamFloat<px4::params::MPC_Z_VEL_MAX_UP>) _param_mpc_z_vel_max_up
				       )
};",1,587 2000 58 777 2001 123 777 58 2000 40 41 58 2001 40 753 41 123 2002 40 41 59 2003 61 2004 59 125 864 126 2000 40 41 61 613 59 306 864 569 2005 40 601 2006 38 2007 41 59 306 864 865 2008 40 41 59 306 864 569 2009 40 601 2010 38 2011 41 123 792 655 59 125 306 864 569 2012 40 41 59 306 864 569 2013 40 41 59 306 601 2006 2014 40 41 59 601 2015 2016 40 41 601 123 792 2017 59 125 865 2018 40 601 2015 38 2019 41 123 2020 61 2019 59 125 306 601 2021 38 2022 40 41 123 792 2023 59 125 306 601 2024 38 2025 40 41 123 792 2026 59 125 306 601 2027 38 2028 40 41 123 792 2029 59 125 306 809 601 2006 2030 59 306 809 601 2021 2031 59 306 809 601 2024 2032 59 306 865 2033 40 41 123 2034 40 41 59 125 306 864 865 2035 40 2036 42 2037 41 123 125 865 2038 40 601 2039 321 2040 38 2041 44 601 2039 321 2040 38 2042 41 123 2043 61 2041 59 2044 61 2042 59 125 775 58 2045 321 2046 60 2047 62 2048 123 2049 40 2050 41 125 59 2045 321 2046 60 2051 62 2052 123 2053 40 2054 41 125 59 2045 321 2055 2056 123 2057 40 2058 41 125 59 306 865 2059 40 41 59 306 865 2060 40 41 59 865 2061 40 41 59 865 2062 40 41 59 306 864 865 2063 40 41 59 306 864 569 2064 40 41 59 306 865 2065 40 41 59 864 865 2066 40 601 2039 321 2067 38 2068 41 123 125 59 864 865 2069 40 601 2039 321 2067 38 2070 41 123 125 59 864 865 2071 40 660 2072 41 123 125 59 864 865 2073 40 660 2074 41 123 125 59 864 865 2075 40 660 2076 41 123 125 59 2077 2078 123 125 59 660 2079 123 2080 125 59 305 809 603 2081 2082 61 1507 59 306 660 2083 123 125 59 306 2084 2085 123 125 59 306 2084 2086 123 125 59 306 2084 2087 123 125 59 306 305 2039 321 2040 2088 59 306 2039 321 2040 2089 59 306 660 2090 123 125 59 306 569 2091 123 125 59 306 660 2092 123 125 59 306 660 2093 123 125 59 306 306 2039 321 2040 2094 59 2039 321 2040 2095 59 2039 321 2040 2096 59 2039 321 2040 2097 59 2039 321 2040 2098 59 2039 321 2040 2099 59 660 2100 123 125 59 660 2101 123 125 59 2015 2102 123 125 59 331 306 2021 2103 123 125 59 2024 2104 123 125 59 306 2027 2105 123 125 59 2106 40 2001 44 40 2107 60 2108 321 2109 321 2110 62 41 2111 44 40 2107 60 2108 321 2109 321 2112 62 41 2113 44 40 2107 60 2108 321 2109 321 2114 62 41 2115 41 125 59 ,"{'AvgLine': 8, 'CountLine': 414, 'CountStmt': 114, 'MaxNesting': 3, 'AvgLineCode': 7, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 46, 'MaxEssential': 1, 'SumEssential': 28, 'AvgCyclomatic': 1, 'CountLineCode': 244, 'CountStmtDecl': 69, 'MaxCyclomatic': 9, 'SumCyclomatic': 47, 'AltAvgLineCode': 7, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 68, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 29, 'AltCountLineCode': 244, 'CountLineCodeExe': 33, 'CountLineComment': 114, 'AltAvgLineComment': 0, 'AltCountLineBlank': 68, 'CountClassCoupled': 6, 'CountClassDerived': 5, 'CountLineCodeDecl': 32, 'CountLineInactive': 0, 'CountDeclMethodAll': 38, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.47', 'AltCountLineComment': 114, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 9, 'SumCyclomaticStrict': 48, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 16, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 9, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 47, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 31, 'CountDeclMethodProtected': 13, 'CountDeclInstanceVariable': 30, 'CountDeclInstanceVariablePublic': 17, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 13}"
118503,C++,"class Profile : public QObject
{
    Q_OBJECT

public:
    static Profile* loadProfile(const QString& name, const QString& password, Settings& settings,
                                const QCommandLineParser* parser);
    static Profile* createProfile(const QString& name, const QString& password, Settings& settings,
                                  const QCommandLineParser* parser);
    ~Profile();

    Core& getCore() const;
    QString getName() const;

    void startCore();
    bool isEncrypted() const;
    QString setPassword(const QString& newPassword);
    const ToxEncrypt* getPasskey() const;

    QPixmap loadAvatar();
    QPixmap loadAvatar(const ToxPk& owner);
    QByteArray loadAvatarData(const ToxPk& owner);
    void setAvatar(QByteArray pic);
    void setFriendAvatar(const ToxPk& owner, QByteArray pic);
    QByteArray getAvatarHash(const ToxPk& owner);
    void removeSelfAvatar();
    void removeFriendAvatar(const ToxPk& owner);
    bool isHistoryEnabled();
    History* getHistory();

    QStringList remove();

    bool rename(QString newName);

    static const QStringList getAllProfileNames();

    static bool exists(QString name);
    static bool isEncrypted(QString name);
    static QString getDbPath(const QString& profileName);

signals:
    void selfAvatarChanged(const QPixmap& pixmap);
    // emit on any change, including default avatar. Used by those that don't care about active on default avatar.
    void friendAvatarChanged(const ToxPk& friendPk, const QPixmap& pixmap);
    // emit on a set of avatar, including identicon, used by those two care about active for default, so can't use friendAvatarChanged
    void friendAvatarSet(const ToxPk& friendPk, const QPixmap& pixmap);
    // emit on set to default, used by those that modify on active
    void friendAvatarRemoved(const ToxPk& friendPk);
    // TODO(sudden6): this doesn't seem to be the right place for Core errors
    void failedToStart();
    void badProxy();
    void coreChanged(Core& core);

public slots:
    void onRequestSent(const ToxPk& friendPk, const QString& message);

private slots:
    void loadDatabase(QString password);
    void saveAvatar(const ToxPk& owner, const QByteArray& avatar);
    void removeAvatar(const ToxPk& owner);
    void onSaveToxSave();
    // TODO(sudden6): use ToxPk instead of friendId
    void onAvatarOfferReceived(uint32_t friendId, uint32_t fileId, const QByteArray& avatarHash);

private:
    Profile(const QString& name, std::unique_ptr<ToxEncrypt> passkey, Paths& paths, Settings &settings_);
    static QStringList getFilesByExt(QString extension);
    QString avatarPath(const ToxPk& owner, bool forceUnencrypted = false);
    bool saveToxSave(QByteArray data);
    void initCore(const QByteArray& toxsave, Settings &s, bool isNewProfile);

private:
    std::unique_ptr<AvatarBroadcaster> avatarBroadcaster;
    std::unique_ptr<Core> core;
    std::unique_ptr<CoreAV> coreAv;
    QString name;
    std::unique_ptr<ToxEncrypt> passkey;
    std::shared_ptr<RawDatabase> database;
    std::shared_ptr<History> history;
    bool isRemoved;
    bool encrypted = false;
    static QStringList profiles;
    std::unique_ptr<BootstrapNodeUpdater> bootstrapNodes;
    Paths& paths;
    Settings& settings;
};",1,587 2000 58 777 2001 123 2002 777 58 809 2000 42 2003 40 601 2004 38 2005 44 601 2004 38 2006 44 2007 38 2008 44 601 2009 42 2010 41 59 809 2000 42 2011 40 601 2004 38 2005 44 601 2004 38 2006 44 2007 38 2008 44 601 2009 42 2010 41 59 126 2000 40 41 59 2012 38 2013 40 41 601 59 2004 2014 40 41 601 59 865 2015 40 41 59 569 2016 40 41 601 59 2004 2017 40 601 2004 38 2018 41 59 601 2019 42 2020 40 41 601 59 2021 2022 40 41 59 2021 2022 40 601 2023 38 2024 41 59 2025 2026 40 601 2023 38 2024 41 59 865 2027 40 2025 2028 41 59 865 2029 40 601 2023 38 2024 44 2025 2028 41 59 2025 2030 40 601 2023 38 2024 41 59 865 2031 40 41 59 865 2032 40 601 2023 38 2024 41 59 569 2033 40 41 59 2034 42 2035 40 41 59 2036 2037 40 41 59 569 2038 40 2004 2039 41 59 809 601 2036 2040 40 41 59 809 569 2041 40 2004 2005 41 59 809 569 2016 40 2004 2005 41 59 809 2004 2042 40 601 2004 38 2043 41 59 2044 58 865 2045 40 601 2021 38 2046 41 59 330 865 2047 40 601 2023 38 2048 44 601 2021 38 2046 41 59 330 865 2049 40 601 2023 38 2048 44 601 2021 38 2046 41 59 330 865 2050 40 601 2023 38 2048 41 59 330 865 2051 40 41 59 865 2052 40 41 59 865 2053 40 2012 38 2054 41 59 777 2055 58 865 2056 40 601 2023 38 2048 44 601 2004 38 2057 41 59 773 2055 58 865 2058 40 2004 2006 41 59 865 2059 40 601 2023 38 2024 44 601 2025 38 2060 41 59 865 2061 40 601 2023 38 2024 41 59 865 2062 40 41 59 330 865 2063 40 2064 2065 44 2064 2066 44 601 2025 38 2067 41 59 773 58 2000 40 601 2004 38 2005 44 2068 321 2069 60 2019 62 2070 44 2071 38 2072 44 2007 38 2073 41 59 809 2036 2074 40 2004 2075 41 59 2004 2076 40 601 2023 38 2024 44 569 2077 61 655 41 59 569 2078 40 2025 2079 41 59 865 2080 40 601 2025 38 2081 44 2007 38 2082 44 569 2083 41 59 773 58 2068 321 2069 60 2084 62 2085 59 2068 321 2069 60 2012 62 2054 59 2068 321 2069 60 2086 62 2087 59 2004 2005 59 2068 321 2069 60 2019 62 2070 59 2068 321 2088 60 2089 62 2090 59 2068 321 2088 60 2034 62 2091 59 569 2092 59 569 2093 61 655 59 809 2036 2094 59 2068 321 2069 60 2095 62 2096 59 2071 38 2072 59 2007 38 2008 59 125 59 ,"{'AvgLine': 16, 'CountLine': 668, 'CountStmt': 244, 'MaxNesting': 2, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 105, 'MaxEssential': 5, 'SumEssential': 49, 'AvgCyclomatic': 2, 'CountLineCode': 572, 'CountStmtDecl': 143, 'MaxCyclomatic': 6, 'SumCyclomatic': 83, 'AltAvgLineCode': 14, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 72, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 42, 'AltCountLineCode': 572, 'CountLineCodeExe': 89, 'CountLineComment': 27, 'AltAvgLineComment': 0, 'AltCountLineBlank': 72, 'CountClassCoupled': 12, 'CountClassDerived': 0, 'CountLineCodeDecl': 106, 'CountLineInactive': 0, 'CountDeclMethodAll': 42, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.05', 'AltCountLineComment': 27, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 84, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 4, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 25, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 97, 'SumCyclomaticModified': 83, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 17, 'CountDeclInstanceMethod': 42, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 15, 'CountDeclInstanceVariablePublic': 11, 'CountDeclInstanceVariablePrivate': 4, 'CountDeclInstanceVariableProtected': 0}"
118522,C++,"class ChatMessage : public ChatLine
{
public:
    using Ptr = std::shared_ptr<ChatMessage>;

    enum SystemMessageType
    {
        INFO,
        ERROR,
        TYPING,
    };

    enum MessageType
    {
        NORMAL,
        ACTION,
        ALERT,
    };

    ChatMessage();
    ~ChatMessage();
    ChatMessage(const ChatMessage&) = default;
    ChatMessage& operator=(const ChatMessage&) = default;
    ChatMessage(ChatMessage&&) = default;

    static ChatMessage::Ptr createChatMessage(const QString& sender, const QString& rawMessage,
                                              MessageType type, bool isMe, MessageState state,
                                              const QDateTime& date, bool colorizeName = false);
    static ChatMessage::Ptr createChatInfoMessage(const QString& rawMessage, SystemMessageType type,
                                                  const QDateTime& date);
    static ChatMessage::Ptr createFileTransferMessage(const QString& sender, CoreFile& coreFile,
                                                      ToxFile file, bool isMe, const QDateTime& date);
    static ChatMessage::Ptr createTypingNotification();
    static ChatMessage::Ptr createBusyNotification();

    void markAsDelivered(const QDateTime& time);
    void markAsBroken();
    QString toString() const;
    bool isAction() const;
    void setAsAction();
    void hideSender();
    void hideDate();

protected:
    static QString detectQuotes(const QString& str, MessageType type);
    static QString wrapDiv(const QString& str, const QString& div);

private:
    bool action = false;
};",1,587 2000 58 777 2001 123 777 58 860 2002 61 2003 321 2004 60 2000 62 59 640 2005 123 2006 44 2007 44 2008 44 125 59 640 2009 123 2010 44 2011 44 2012 44 125 59 2000 40 41 59 126 2000 40 41 59 2000 40 601 2000 38 41 61 613 59 2000 38 758 61 40 601 2000 38 41 61 613 59 2000 40 2000 307 41 61 613 59 809 2000 321 2002 2013 40 601 2014 38 2015 44 601 2014 38 2016 44 2009 2017 44 569 2018 44 2019 2020 44 601 2021 38 2022 44 569 2023 61 655 41 59 809 2000 321 2002 2024 40 601 2014 38 2016 44 2005 2017 44 601 2021 38 2022 41 59 809 2000 321 2002 2025 40 601 2014 38 2015 44 2026 38 2027 44 2028 2029 44 569 2018 44 601 2021 38 2022 41 59 809 2000 321 2002 2030 40 41 59 809 2000 321 2002 2031 40 41 59 865 2032 40 601 2021 38 2033 41 59 865 2034 40 41 59 2014 2035 40 41 601 59 569 2036 40 41 601 59 865 2037 40 41 59 865 2038 40 41 59 865 2039 40 41 59 775 58 809 2014 2040 40 601 2014 38 2041 44 2009 2017 41 59 809 2014 2042 40 601 2014 38 2041 44 601 2014 38 2043 41 59 773 58 569 2044 61 655 59 125 59 ,"{'AvgLine': 15, 'CountLine': 275, 'CountStmt': 92, 'MaxNesting': 2, 'AvgLineCode': 12, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 35, 'MaxEssential': 1, 'SumEssential': 15, 'AvgCyclomatic': 2, 'CountLineCode': 222, 'CountStmtDecl': 48, 'MaxCyclomatic': 10, 'SumCyclomatic': 31, 'AltAvgLineCode': 12, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 35, 'CountStmtEmpty': 9, 'AltAvgLineBlank': 1, 'CountDeclMethod': 24, 'AltCountLineCode': 222, 'CountLineCodeExe': 36, 'CountLineComment': 19, 'AltAvgLineComment': 1, 'AltCountLineBlank': 35, 'CountClassCoupled': 7, 'CountClassDerived': 0, 'CountLineCodeDecl': 48, 'CountLineInactive': 0, 'CountDeclMethodAll': 47, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 19, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 31, 'CountDeclClassMethod': 7, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 22, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 91, 'SumCyclomaticModified': 25, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 17, 'CountDeclMethodProtected': 2, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
117619,C++,"class PX4Magnetometer
{
public:
	PX4Magnetometer(uint32_t device_id, enum Rotation rotation = ROTATION_NONE);
	~PX4Magnetometer();

	bool external() { return _external; }

	void set_device_id(uint32_t device_id) { _device_id = device_id; }
	void set_device_type(uint8_t devtype);
	void set_error_count(uint32_t error_count) { _error_count = error_count; }
	void increase_error_count() { _error_count++; }
	void set_scale(float scale) { _scale = scale; }
	void set_temperature(float temperature) { _temperature = temperature; }
	void set_external(bool external) { _external = external; }

	void update(const hrt_abstime &timestamp_sample, float x, float y, float z);

	int get_instance() { return _sensor_pub.get_instance(); };

private:
	uORB::PublicationMulti<sensor_mag_s> _sensor_pub{ORB_ID(sensor_mag)};

	uint32_t		_device_id{0};
	const enum Rotation	_rotation;

	float			_scale{1.f};
	float			_temperature{NAN};
	uint32_t		_error_count{0};

	bool _external{false};
};",1,587 2000 123 777 58 2000 40 2001 2002 44 640 2003 2004 61 2005 41 59 126 2000 40 41 59 569 2006 40 41 123 792 2007 59 125 865 2008 40 2001 2002 41 123 2009 61 2002 59 125 865 2010 40 2011 2012 41 59 865 2013 40 2001 2014 41 123 2015 61 2014 59 125 865 2016 40 41 123 2017 349 59 125 865 2018 40 660 2019 41 123 2020 61 2019 59 125 865 2021 40 660 2022 41 123 2023 61 2022 59 125 865 2024 40 569 2006 41 123 2025 61 2006 59 125 865 2026 40 601 2027 38 2028 44 660 2029 44 660 2030 44 660 2031 41 59 704 2032 40 41 123 792 2033 46 2032 40 41 59 125 59 773 58 2034 321 2035 60 2036 62 2037 123 2038 40 2039 41 125 59 2001 2040 123 1500 125 59 601 640 2003 2041 59 660 2042 123 1501 125 59 660 2043 123 2044 125 59 2001 2045 123 1500 125 59 569 2046 123 655 125 59 125 59 ,"{'AvgLine': 4, 'CountLine': 73, 'CountStmt': 31, 'MaxNesting': 0, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 9, 'MaxEssential': 1, 'SumEssential': 12, 'AvgCyclomatic': 1, 'CountLineCode': 55, 'CountStmtDecl': 23, 'MaxCyclomatic': 1, 'SumCyclomatic': 12, 'AltAvgLineCode': 3, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 14, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 12, 'AltCountLineCode': 55, 'CountLineCodeExe': 10, 'CountLineComment': 4, 'AltAvgLineComment': 0, 'AltCountLineBlank': 14, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 15, 'CountLineInactive': 0, 'CountDeclMethodAll': 12, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.07', 'AltCountLineComment': 4, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 12, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 12, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 88, 'SumCyclomaticModified': 12, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 12, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 7, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 6, 'CountDeclInstanceVariableProtected': 0}"
98587,C++,"class CPL_DLL GDALPamDataset : public GDALDataset
{
    friend class GDALPamRasterBand;

  private:
    int IsPamFilenameAPotentialSiblingFile();

  protected:

                GDALPamDataset(void);
//! @cond Doxygen_Suppress
    int         nPamFlags = 0;
    GDALDatasetPamInfo *psPam = nullptr;

    virtual const char *_GetProjectionRef() override;
    virtual const char *_GetGCPProjection() override;
    virtual CPLErr _SetProjection( const char * pszProjection ) override;
    virtual CPLErr _SetGCPs( int nGCPCount, const GDAL_GCP *pasGCPList,
                    const char *pszGCPProjection ) override;

    virtual CPLXMLNode *SerializeToXML( const char *);
    virtual CPLErr      XMLInit( CPLXMLNode *, const char * );

    virtual CPLErr TryLoadXML(char **papszSiblingFiles = nullptr);
    virtual CPLErr TrySaveXML();

    CPLErr  TryLoadAux(char **papszSiblingFiles = nullptr);
    CPLErr  TrySaveAux();

    virtual const char *BuildPamFilename();

    void   PamInitialize();
    void   PamClear();

    void   SetPhysicalFilename( const char * );
    const char *GetPhysicalFilename();
    void   SetSubdatasetName( const char *);
    const char *GetSubdatasetName();
//! @endcond

  public:
    ~GDALPamDataset() override;

    void FlushCache(bool bAtClosing) override;

    const OGRSpatialReference* GetSpatialRef() const override;
    CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override;

    CPLErr GetGeoTransform( double * ) override;
    CPLErr SetGeoTransform( double * ) override;
    void DeleteGeoTransform();

    int GetGCPCount() override;
    const OGRSpatialReference* GetGCPSpatialRef() const override;
    const GDAL_GCP *GetGCPs() override;
    using GDALDataset::SetGCPs;
    CPLErr SetGCPs( int nGCPCount, const GDAL_GCP *pasGCPList,
                    const OGRSpatialReference* poSRS ) override;

    CPLErr SetMetadata( char ** papszMetadata,
                        const char * pszDomain = """" ) override;
    CPLErr SetMetadataItem( const char * pszName,
                            const char * pszValue,
                            const char * pszDomain = """" ) override;
    char **GetMetadata( const char * pszDomain = """" ) override;
    const char *GetMetadataItem( const char * pszName,
                                 const char * pszDomain = """" ) override;

    char **GetFileList(void) override;

    void ClearStatistics() override;

//! @cond Doxygen_Suppress
    virtual CPLErr CloneInfo( GDALDataset *poSrcDS, int nCloneInfoFlags );

    CPLErr IBuildOverviews( const char *pszResampling,
                            int nOverviews, int *panOverviewList,
                            int nListBands, int *panBandList,
                            GDALProgressFunc pfnProgress,
                            void * pProgressData ) override;

    // ""semi private"" methods.
    void   MarkPamDirty() { nPamFlags |= GPF_DIRTY; }
    GDALDatasetPamInfo *GetPamInfo() { return psPam; }
    int    GetPamFlags() { return nPamFlags; }
    void   SetPamFlags(int nValue ) { nPamFlags = nValue; }
//! @endcond

  private:
    CPL_DISALLOW_COPY_ASSIGN(GDALPamDataset)
};",1,587 2000 2001 58 777 2002 123 667 587 2003 59 773 58 704 2004 40 41 59 775 58 2001 40 865 41 59 330 704 2005 61 1500 59 2006 42 2007 61 753 59 864 601 582 42 2008 40 41 2009 59 864 601 582 42 2010 40 41 2009 59 864 2011 2012 40 601 582 42 2013 41 2009 59 864 2011 2014 40 704 2015 44 601 2016 42 2017 44 601 582 42 2018 41 2009 59 864 2019 42 2020 40 601 582 42 41 59 864 2011 2021 40 2019 42 44 601 582 42 41 59 864 2011 2022 40 582 42 42 2023 61 753 41 59 864 2011 2024 40 41 59 2011 2025 40 582 42 42 2023 61 753 41 59 2011 2026 40 41 59 864 601 582 42 2027 40 41 59 865 2028 40 41 59 865 2029 40 41 59 865 2030 40 601 582 42 41 59 601 582 42 2031 40 41 59 865 2032 40 601 582 42 41 59 601 582 42 2033 40 41 59 330 777 58 126 2001 40 41 2009 59 865 2034 40 569 2035 41 2009 59 601 2036 42 2037 40 41 601 2009 59 2011 2038 40 601 2036 42 2039 41 2009 59 2011 2040 40 625 42 41 2009 59 2011 2041 40 625 42 41 2009 59 865 2042 40 41 59 704 2043 40 41 2009 59 601 2036 42 2044 40 41 601 2009 59 601 2016 42 2045 40 41 2009 59 860 2002 321 2046 59 2011 2046 40 704 2015 44 601 2016 42 2017 44 601 2036 42 2039 41 2009 59 2011 2047 40 582 42 42 2048 44 601 582 42 2049 61 362 41 2009 59 2011 2050 40 601 582 42 2051 44 601 582 42 2052 44 601 582 42 2049 61 362 41 2009 59 582 42 42 2053 40 601 582 42 2049 61 362 41 2009 59 601 582 42 2054 40 601 582 42 2051 44 601 582 42 2049 61 362 41 2009 59 582 42 42 2055 40 865 41 2009 59 865 2056 40 41 2009 59 330 864 2011 2057 40 2002 42 2058 44 704 2059 41 59 2011 2060 40 601 582 42 2061 44 704 2062 44 704 42 2063 44 704 2064 44 704 42 2065 44 2066 2067 44 865 42 2068 41 2009 59 330 865 2069 40 41 123 2005 347 2070 59 125 2006 42 2071 40 41 123 792 2007 59 125 704 2072 40 41 123 792 2005 59 125 865 2073 40 704 2074 41 123 2005 61 2074 59 125 330 773 58 2075 40 2001 41 125 59 ,"{'AvgLine': 35, 'CountLine': 1551, 'CountStmt': 623, 'MaxNesting': 6, 'AvgLineCode': 25, 'AvgEssential': 2, 'AvgLineBlank': 5, 'CountStmtExe': 532, 'MaxEssential': 9, 'SumEssential': 89, 'AvgCyclomatic': 5, 'CountLineCode': 1111, 'CountStmtDecl': 163, 'MaxCyclomatic': 34, 'SumCyclomatic': 214, 'AltAvgLineCode': 25, 'AvgLineComment': 4, 'CountClassBase': 1, 'CountLineBlank': 230, 'CountStmtEmpty': 2, 'AltAvgLineBlank': 5, 'CountDeclMethod': 45, 'AltCountLineCode': 1115, 'CountLineCodeExe': 766, 'CountLineComment': 206, 'AltAvgLineComment': 4, 'AltCountLineBlank': 230, 'CountClassCoupled': 13, 'CountClassDerived': 104, 'CountLineCodeDecl': 223, 'CountLineInactive': 1, 'CountDeclMethodAll': 186, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.19', 'AltCountLineComment': 206, 'AvgCyclomaticStrict': 6, 'MaxCyclomaticStrict': 43, 'SumCyclomaticStrict': 267, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 5, 'CountDeclMethodFriend': 34, 'CountDeclMethodPublic': 24, 'CountLinePreprocessor': 3, 'MaxCyclomaticModified': 34, 'PercentLackOfCohesion': 55, 'SumCyclomaticModified': 214, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 3, 'CountDeclInstanceMethod': 45, 'CountDeclMethodProtected': 18, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 2}"
118499,C++,"class CameraDevice
{
public:
    static CameraDevice* open(QString devName, VideoMode mode = VideoMode());
    void open();
    bool close();

    static QVector<QPair<QString, QString>> getDeviceList();

    static QVector<VideoMode> getVideoModes(QString devName);
    static QString getPixelFormatString(uint32_t pixel_format);
    static bool betterPixelFormat(uint32_t a, uint32_t b);

    static QString getDefaultDeviceName();

    static bool isScreen(const QString& devName);

private:
    CameraDevice(const QString& devName, AVFormatContext* context);
    static CameraDevice* open(QString devName, AVDictionary** options);
    static bool getDefaultInputFormat();
    static QVector<QPair<QString, QString>> getRawDeviceListGeneric();
    static QVector<VideoMode> getScreenModes();

public:
    const QString devName;
    AVFormatContext* context;

private:
    std::atomic_int refcount;
    static QHash<QString, CameraDevice*> openDevices;
    static QMutex openDeviceLock, iformatLock;
    static AVInputFormat *iformat, *idesktopFormat;
};",1,587 2000 123 777 58 809 2000 42 2001 40 2002 2003 44 2004 2005 61 2004 40 41 41 59 865 2001 40 41 59 569 2006 40 41 59 809 2007 60 2008 60 2002 44 2002 355 2009 40 41 59 809 2007 60 2004 62 2010 40 2002 2003 41 59 809 2002 2011 40 2012 2013 41 59 809 569 2014 40 2012 2015 44 2012 2016 41 59 809 2002 2017 40 41 59 809 569 2018 40 601 2002 38 2003 41 59 773 58 2000 40 601 2002 38 2003 44 2019 42 2020 41 59 809 2000 42 2001 40 2002 2003 44 2021 42 42 2022 41 59 809 569 2023 40 41 59 809 2007 60 2008 60 2002 44 2002 355 2024 40 41 59 809 2007 60 2004 62 2025 40 41 59 777 58 601 2002 2003 59 2019 42 2020 59 773 58 2026 321 2027 2028 59 809 2029 60 2002 44 2000 42 62 2030 59 809 2031 2032 44 2033 59 809 2034 42 2035 44 42 2036 59 125 59 ,"{'AvgLine': 27, 'CountLine': 425, 'CountStmt': 112, 'MaxNesting': 2, 'AvgLineCode': 15, 'AvgEssential': 1, 'AvgLineBlank': 3, 'CountStmtExe': 59, 'MaxEssential': 4, 'SumEssential': 19, 'AvgCyclomatic': 2, 'CountLineCode': 247, 'CountStmtDecl': 49, 'MaxCyclomatic': 7, 'SumCyclomatic': 36, 'AltAvgLineCode': 23, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 49, 'CountStmtEmpty': 4, 'AltAvgLineBlank': 3, 'CountDeclMethod': 14, 'AltCountLineCode': 361, 'CountLineCodeExe': 61, 'CountLineComment': 6, 'AltAvgLineComment': 0, 'AltCountLineBlank': 52, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 35, 'CountLineInactive': 80, 'CountDeclMethodAll': 14, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.02', 'AltCountLineComment': 9, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 7, 'SumCyclomaticStrict': 36, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 13, 'CountLinePreprocessor': 40, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 94, 'SumCyclomaticModified': 36, 'CountDeclClassVariable': 5, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 16, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 3, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98709,C++,"class CPL_DLL OGRLinearRing : public OGRLineString
{
    static OGRLineString*       CasterToLineString( OGRCurve* poCurve );

    // IWks Interface - Note this isn't really a first class object
    // for the purposes of WKB form.  These methods always fail since this
    // object can't be serialized on its own.
    virtual size_t WkbSize() const override;
    virtual OGRErr importFromWkb( const unsigned char *,
                                  size_t,
                                  OGRwkbVariant,
                                  size_t& nBytesConsumedOut ) override;
    virtual OGRErr exportToWkb( OGRwkbByteOrder, unsigned char *,
                                OGRwkbVariant=wkbVariantOldOgc )
        const override;

  protected:
//! @cond Doxygen_Suppress
    friend class OGRPolygon;
    friend class OGRTriangle;

    // These are not IWks compatible ... just a convenience for OGRPolygon.
    virtual size_t _WkbSize( int _flags ) const;
    virtual OGRErr _importFromWkb( OGRwkbByteOrder, int _flags,
                                   const unsigned char *, size_t,
                                   size_t& nBytesConsumedOut );
    virtual OGRErr _exportToWkb( OGRwkbByteOrder, int _flags,
                                 unsigned char * ) const;

    virtual OGRCurveCasterToLineString GetCasterToLineString()
        const override;
    virtual OGRCurveCasterToLinearRing GetCasterToLinearRing()
        const override;
//! @endcond

    static OGRLineString* CastToLineString( OGRLinearRing* poLR );

  public:
    OGRLinearRing();
    OGRLinearRing( const OGRLinearRing& other );
    explicit OGRLinearRing( OGRLinearRing * );
    ~OGRLinearRing() override;

    OGRLinearRing& operator=( const OGRLinearRing& other );

    // Non standard.
    virtual const char *getGeometryName() const override;
    virtual OGRLinearRing *clone() const override;
    virtual int isClockwise() const;
    virtual void reverseWindingOrder();
    virtual void closeRings() override;
    OGRBoolean isPointInRing( const OGRPoint* pt,
                              int bTestEnvelope = TRUE ) const;
    OGRBoolean isPointOnRingBoundary( const OGRPoint* pt,
                                      int bTestEnvelope = TRUE ) const;
    virtual OGRErr  transform( OGRCoordinateTransformation *poCT ) override;

    /** Return pointer of this in upper class */
    inline OGRLineString* toUpperClass() { return this; }
    /** Return pointer of this in upper class */
    inline const OGRLineString* toUpperClass() const { return this; }

    virtual void accept(IOGRGeometryVisitor* visitor) override { visitor->visit(this); }
    virtual void accept(IOGRConstGeometryVisitor* visitor) const override { visitor->visit(this); }

    OGR_ALLOW_UPCAST_TO(LineString)
    OGR_ALLOW_CAST_TO_THIS(LinearRing)
};",1,587 2000 2001 58 777 2002 123 809 2002 42 2003 40 2004 42 2005 41 59 330 330 330 864 2006 2007 40 41 601 2008 59 864 2009 2010 40 601 856 582 42 44 2006 44 2011 44 2006 38 2012 41 2008 59 864 2009 2013 40 2014 44 856 582 42 44 2011 61 2015 41 601 2008 59 775 58 330 667 587 2016 59 667 587 2017 59 330 864 2006 2018 40 704 2019 41 601 59 864 2009 2020 40 2014 44 704 2019 44 601 856 582 42 44 2006 44 2006 38 2012 41 59 864 2009 2021 40 2014 44 704 2019 44 856 582 42 41 601 59 864 2022 2023 40 41 601 2008 59 864 2024 2025 40 41 601 2008 59 330 809 2002 42 2026 40 2001 42 2027 41 59 777 58 2001 40 41 59 2001 40 601 2001 38 2028 41 59 648 2001 40 2001 42 41 59 126 2001 40 41 2008 59 2001 38 758 61 40 601 2001 38 2028 41 59 330 864 601 582 42 2029 40 41 601 2008 59 864 2001 42 2030 40 41 601 2008 59 864 704 2031 40 41 601 59 864 865 2032 40 41 59 864 865 2033 40 41 2008 59 2034 2035 40 601 2036 42 2037 44 704 2038 61 2039 41 601 59 2034 2040 40 601 2036 42 2037 44 704 2038 61 2039 41 601 59 864 2009 2041 40 2042 42 2043 41 2008 59 306 700 2002 42 2044 40 41 123 792 823 59 125 306 700 601 2002 42 2044 40 41 601 123 792 823 59 125 864 865 2045 40 2046 42 2047 41 2008 123 2047 354 2048 40 823 41 59 125 864 865 2045 40 2049 42 2047 41 601 2008 123 2047 354 2050 40 823 41 59 125 2051 40 2052 41 2053 40 2054 41 125 59 ,"{'AvgLine': 277, 'CountLine': 650, 'CountStmt': 307, 'MaxNesting': 5, 'AvgLineCode': 151, 'AvgEssential': 1, 'AvgLineBlank': 48, 'CountStmtExe': 254, 'MaxEssential': 10, 'SumEssential': 51, 'AvgCyclomatic': 3, 'CountLineCode': 496, 'CountStmtDecl': 104, 'MaxCyclomatic': 23, 'SumCyclomatic': 101, 'AltAvgLineCode': 157, 'AvgLineComment': 72, 'CountClassBase': 1, 'CountLineBlank': 88, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 48, 'CountDeclMethod': 31, 'AltCountLineCode': 496, 'CountLineCodeExe': 252, 'CountLineComment': 74, 'AltAvgLineComment': 72, 'AltCountLineBlank': 88, 'CountClassCoupled': 7, 'CountClassDerived': 1, 'CountLineCodeDecl': 99, 'CountLineInactive': 0, 'CountDeclMethodAll': 318, 'MaxInheritanceTree': 4, 'RatioCommentToCode': '0.15', 'AltCountLineComment': 74, 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 29, 'SumCyclomaticStrict': 130, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 15, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 68, 'CountDeclMethodPublic': 21, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 23, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 101, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 4, 'CountDeclInstanceMethod': 29, 'CountDeclMethodProtected': 6, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
118407,C++,"class Settings : public QObject,
                 public ICoreSettings,
                 public IFriendSettings,
                 public IGroupSettings,
                 public IAudioSettings,
                 public IVideoSettings,
                 public INotificationSettings
{
    Q_OBJECT

    Q_ENUMS(StyleType)

    // general
    Q_PROPERTY(bool compactLayout READ getCompactLayout WRITE setCompactLayout NOTIFY compactLayoutChanged FINAL)
    Q_PROPERTY(bool autorun READ getAutorun WRITE setAutorun NOTIFY autorunChanged FINAL)

    // GUI
    Q_PROPERTY(bool separateWindow READ getSeparateWindow WRITE setSeparateWindow NOTIFY
                   separateWindowChanged FINAL)
    Q_PROPERTY(QString smileyPack READ getSmileyPack WRITE setSmileyPack NOTIFY smileyPackChanged FINAL)
    Q_PROPERTY(int emojiFontPointSize READ getEmojiFontPointSize WRITE setEmojiFontPointSize NOTIFY
                   emojiFontPointSizeChanged FINAL)
    Q_PROPERTY(bool minimizeOnClose READ getMinimizeOnClose WRITE setMinimizeOnClose NOTIFY
                   minimizeOnCloseChanged FINAL)
    Q_PROPERTY(QByteArray windowGeometry READ getWindowGeometry WRITE setWindowGeometry NOTIFY
                   windowGeometryChanged FINAL)
    Q_PROPERTY(QByteArray windowState READ getWindowState WRITE setWindowState NOTIFY windowStateChanged FINAL)
    Q_PROPERTY(QByteArray splitterState READ getSplitterState WRITE setSplitterState NOTIFY
                   splitterStateChanged FINAL)
    Q_PROPERTY(QByteArray dialogGeometry READ getDialogGeometry WRITE setDialogGeometry NOTIFY
                   dialogGeometryChanged FINAL)
    Q_PROPERTY(QByteArray dialogSplitterState READ getDialogSplitterState WRITE
                   setDialogSplitterState NOTIFY dialogSplitterStateChanged FINAL)
    Q_PROPERTY(QByteArray dialogSettingsGeometry READ getDialogSettingsGeometry WRITE
                   setDialogSettingsGeometry NOTIFY dialogSettingsGeometryChanged FINAL)
    Q_PROPERTY(QString style READ getStyle WRITE setStyle NOTIFY styleChanged FINAL)
    Q_PROPERTY(bool showSystemTray READ getShowSystemTray WRITE setShowSystemTray NOTIFY
                   showSystemTrayChanged FINAL)
    Q_PROPERTY(bool showIdenticons READ getShowIdenticons WRITE setShowIdenticons NOTIFY
                   showIdenticonsChanged FINAL)

    // ChatView
    Q_PROPERTY(bool groupchatPosition READ getGroupchatPosition WRITE setGroupchatPosition NOTIFY
                   groupchatPositionChanged FINAL)
    Q_PROPERTY(QFont chatMessageFont READ getChatMessageFont WRITE setChatMessageFont NOTIFY
                   chatMessageFontChanged FINAL)
    Q_PROPERTY(StyleType stylePreference READ getStylePreference WRITE setStylePreference NOTIFY
                   stylePreferenceChanged FINAL)
    Q_PROPERTY(QString timestampFormat READ getTimestampFormat WRITE setTimestampFormat NOTIFY
                   timestampFormatChanged FINAL)
    Q_PROPERTY(QString dateFormat READ getDateFormat WRITE setDateFormat NOTIFY dateFormatChanged FINAL)
    Q_PROPERTY(bool statusChangeNotificationEnabled READ getStatusChangeNotificationEnabled WRITE
                   setStatusChangeNotificationEnabled NOTIFY statusChangeNotificationEnabledChanged FINAL)
    Q_PROPERTY(bool spellCheckingEnabled READ getSpellCheckingEnabled WRITE setSpellCheckingEnabled
                   NOTIFY spellCheckingEnabledChanged FINAL)

    // Privacy
    Q_PROPERTY(bool typingNotification READ getTypingNotification WRITE setTypingNotification NOTIFY
                   typingNotificationChanged FINAL)
    Q_PROPERTY(QStringList blackList READ getBlackList WRITE setBlackList NOTIFY blackListChanged FINAL)

    // Audio
    Q_PROPERTY(QString inDev READ getInDev WRITE setInDev NOTIFY inDevChanged FINAL)
    Q_PROPERTY(bool audioInDevEnabled READ getAudioInDevEnabled WRITE setAudioInDevEnabled NOTIFY
                   audioInDevEnabledChanged FINAL)
    Q_PROPERTY(qreal audioInGainDecibel READ getAudioInGainDecibel WRITE setAudioInGainDecibel
                   NOTIFY audioInGainDecibelChanged FINAL)
    Q_PROPERTY(qreal audioThreshold READ getAudioThreshold WRITE setAudioThreshold NOTIFY
                   audioThresholdChanged FINAL)
    Q_PROPERTY(QString outDev READ getOutDev WRITE setOutDev NOTIFY outDevChanged FINAL)
    Q_PROPERTY(bool audioOutDevEnabled READ getAudioOutDevEnabled WRITE setAudioOutDevEnabled NOTIFY
                   audioOutDevEnabledChanged FINAL)
    Q_PROPERTY(int outVolume READ getOutVolume WRITE setOutVolume NOTIFY outVolumeChanged FINAL)
    Q_PROPERTY(int audioBitrate READ getAudioBitrate WRITE setAudioBitrate NOTIFY audioBitrateChanged FINAL)

    // Video
    Q_PROPERTY(QString videoDev READ getVideoDev WRITE setVideoDev NOTIFY videoDevChanged FINAL)
    Q_PROPERTY(QRect camVideoRes READ getCamVideoRes WRITE setCamVideoRes NOTIFY camVideoResChanged FINAL)
    Q_PROPERTY(QRect screenRegion READ getScreenRegion WRITE setScreenRegion NOTIFY screenRegionChanged FINAL)
    Q_PROPERTY(bool screenGrabbed READ getScreenGrabbed WRITE setScreenGrabbed NOTIFY screenGrabbedChanged FINAL)
    Q_PROPERTY(float camVideoFPS READ getCamVideoFPS WRITE setCamVideoFPS NOTIFY camVideoFPSChanged FINAL)

public:
    enum class StyleType
    {
        NONE = 0,
        WITH_CHARS = 1,
        WITHOUT_CHARS = 2
    };

    enum class FriendListSortingMode
    {
        Name,
        Activity,
    };

public:
    static Settings& getInstance();
    static void destroyInstance();

    Paths& getPaths();
    void createSettingsDir();
    void createPersonal(const QString& basename) const;

    void savePersonal();

    void loadGlobal();
    bool isToxPortable();
    void loadPersonal(QString profileName, const ToxEncrypt* passKey);

    void resetToDefault();

    struct Request
    {
        QString address;
        QString message;
        bool read;
    };

public slots:
    void saveGlobal();
    void sync();
    void setAutoLogin(bool state);
    void updateProfileData(Profile* profile, const QCommandLineParser* parser);

signals:
    // General
    void autorunChanged(bool enabled);
    void autoSaveEnabledChanged(bool enabled);
    void autostartInTrayChanged(bool enabled);
    void closeToTrayChanged(bool enabled);
    void lightTrayIconChanged(bool enabled);
    void minimizeToTrayChanged(bool enabled);
    void notifyChanged(bool enabled);
    void desktopNotifyChanged(bool enabled);
    void showWindowChanged(bool enabled);
    void makeToxPortableChanged(bool enabled);
    void busySoundChanged(bool enabled);
    void notifySoundChanged(bool enabled);
    void notifyHideChanged(bool enabled);
    void groupAlwaysNotifyChanged(bool enabled);
    void translationChanged(const QString& translation);
    void currentProfileIdChanged(quint32 id);
    void enableLoggingChanged(bool enabled);
    void autoAwayTimeChanged(int minutes);
    void globalAutoAcceptDirChanged(const QString& path);
    void autoAcceptMaxSizeChanged(size_t size);
    void checkUpdatesChanged(bool enabled);
    void widgetDataChanged(const QString& key);

    // GUI
    void autoLoginChanged(bool enabled);
    void nameColorsChanged(bool enabled);
    void separateWindowChanged(bool enabled);
    void showSystemTrayChanged(bool enabled);
    bool minimizeOnCloseChanged(bool enabled);
    void windowGeometryChanged(const QByteArray& rect);
    void windowStateChanged(const QByteArray& state);
    void splitterStateChanged(const QByteArray& state);
    void dialogGeometryChanged(const QByteArray& rect);
    void dialogSplitterStateChanged(const QByteArray& state);
    void dialogSettingsGeometryChanged(const QByteArray& rect);
    void styleChanged(const QString& style);
    void themeColorChanged(int color);
    void compactLayoutChanged(bool enabled);
    void sortingModeChanged(FriendListSortingMode mode);
    void showIdenticonsChanged(bool enabled);

    // ChatView
    void useEmoticonsChanged(bool enabled);
    void smileyPackChanged(const QString& name);
    void emojiFontPointSizeChanged(int size);
    void dontGroupWindowsChanged(bool enabled);
    void groupchatPositionChanged(bool enabled);
    void chatMessageFontChanged(const QFont& font);
    void stylePreferenceChanged(StyleType type);
    void timestampFormatChanged(const QString& format);
    void dateFormatChanged(const QString& format);
    void statusChangeNotificationEnabledChanged(bool enabled);
    void spellCheckingEnabledChanged(bool enabled);

    // Privacy
    void typingNotificationChanged(bool enabled);
    void dbSyncTypeChanged(Db::syncType type);
    void blackListChanged(QStringList const& blist);

public:
    bool applyCommandLineOptions(const QCommandLineParser& parser);
    static bool verifyProxySettings(const QCommandLineParser& parser);

    bool getMakeToxPortable() const;
    void setMakeToxPortable(bool newValue);

    bool getAutorun() const;
    void setAutorun(bool newValue);

    bool getAutostartInTray() const;
    void setAutostartInTray(bool newValue);

    bool getCloseToTray() const;
    void setCloseToTray(bool newValue);

    bool getMinimizeToTray() const;
    void setMinimizeToTray(bool newValue);

    bool getLightTrayIcon() const;
    void setLightTrayIcon(bool newValue);

    QString getStyle() const;
    void setStyle(const QString& newValue);

    bool getShowSystemTray() const;
    void setShowSystemTray(bool newValue);

    bool getUseEmoticons() const;
    void setUseEmoticons(bool newValue);

    QString getCurrentProfile() const;
    uint32_t getCurrentProfileId() const;
    void setCurrentProfile(const QString& profile);

    QString getTranslation() const;
    void setTranslation(const QString& newValue);

    void setAutoSaveEnabled(bool newValue);
    bool getAutoSaveEnabled() const;

    // ICoreSettings
    bool getEnableIPv6() const override;
    void setEnableIPv6(bool enabled) override;

    bool getForceTCP() const override;
    void setForceTCP(bool enabled) override;

    bool getEnableLanDiscovery() const override;
    void setEnableLanDiscovery(bool enabled) override;

    QString getProxyAddr() const override;
    void setProxyAddr(const QString& address) override;

    ICoreSettings::ProxyType getProxyType() const override;
    void setProxyType(ICoreSettings::ProxyType type) override;

    quint16 getProxyPort() const override;
    void setProxyPort(quint16 port) override;

    QNetworkProxy getProxy() const override;

    SIGNAL_IMPL(Settings, enableIPv6Changed, bool enabled)
    SIGNAL_IMPL(Settings, forceTCPChanged, bool enabled)
    SIGNAL_IMPL(Settings, enableLanDiscoveryChanged, bool enabled)
    SIGNAL_IMPL(Settings, proxyTypeChanged, ICoreSettings::ProxyType type)
    SIGNAL_IMPL(Settings, proxyAddressChanged, const QString& address)
    SIGNAL_IMPL(Settings, proxyPortChanged, quint16 port)

    bool getEnableLogging() const;
    void setEnableLogging(bool newValue);

    Db::syncType getDbSyncType() const;
    void setDbSyncType(Db::syncType newValue);

    int getAutoAwayTime() const;
    void setAutoAwayTime(int newValue);

    bool getCheckUpdates() const;
    void setCheckUpdates(bool newValue);

    bool getNotify() const override;
    void setNotify(bool newValue) override;

    bool getShowWindow() const override;
    void setShowWindow(bool newValue) override;

    bool getDesktopNotify() const override;
    void setDesktopNotify(bool enabled) override;

    bool getNotifySound() const override;
    void setNotifySound(bool newValue) override;

    bool getNotifyHide() const override;
    void setNotifyHide(bool newValue) override;

    bool getBusySound() const override;
    void setBusySound(bool newValue) override;

    bool getGroupAlwaysNotify() const override;
    void setGroupAlwaysNotify(bool newValue) override;

    QString getInDev() const override;
    void setInDev(const QString& deviceSpecifier) override;

    bool getAudioInDevEnabled() const override;
    void setAudioInDevEnabled(bool enabled) override;

    QString getOutDev() const override;
    void setOutDev(const QString& deviceSpecifier) override;

    bool getAudioOutDevEnabled() const override;
    void setAudioOutDevEnabled(bool enabled) override;

    qreal getAudioInGainDecibel() const override;
    void setAudioInGainDecibel(qreal dB) override;

    qreal getAudioThreshold() const override;
    void setAudioThreshold(qreal percent) override;

    int getOutVolume() const override;
    int getOutVolumeMin() const override
    {
        return 0;
    }
    int getOutVolumeMax() const override
    {
        return 100;
    }
    void setOutVolume(int volume) override;

    int getAudioBitrate() const override;
    void setAudioBitrate(int bitrate) override;

    bool getEnableTestSound() const override;
    void setEnableTestSound(bool newValue) override;

    SIGNAL_IMPL(Settings, inDevChanged, const QString& device)
    SIGNAL_IMPL(Settings, audioInDevEnabledChanged, bool enabled)

    SIGNAL_IMPL(Settings, outDevChanged, const QString& device)
    SIGNAL_IMPL(Settings, audioOutDevEnabledChanged, bool enabled)

    SIGNAL_IMPL(Settings, audioInGainDecibelChanged, qreal dB)
    SIGNAL_IMPL(Settings, audioThresholdChanged, qreal percent)
    SIGNAL_IMPL(Settings, outVolumeChanged, int volume)
    SIGNAL_IMPL(Settings, audioBitrateChanged, int bitrate)
    SIGNAL_IMPL(Settings, enableTestSoundChanged, bool newValue)

    QString getVideoDev() const override;
    void setVideoDev(const QString& deviceSpecifier) override;

    QRect getScreenRegion() const override;
    void setScreenRegion(const QRect& value) override;

    bool getScreenGrabbed() const override;
    void setScreenGrabbed(bool value) override;

    QRect getCamVideoRes() const override;
    void setCamVideoRes(QRect newValue) override;

    float getCamVideoFPS() const override;
    void setCamVideoFPS(float newValue) override;

    SIGNAL_IMPL(Settings, videoDevChanged, const QString& device)
    SIGNAL_IMPL(Settings, screenRegionChanged, const QRect& region)
    SIGNAL_IMPL(Settings, screenGrabbedChanged, bool enabled)
    SIGNAL_IMPL(Settings, camVideoResChanged, const QRect& region)
    SIGNAL_IMPL(Settings, camVideoFPSChanged, unsigned short fps)

    bool isAnimationEnabled() const;
    void setAnimationEnabled(bool newValue);

    QString getSmileyPack() const;
    void setSmileyPack(const QString& value);

    int getThemeColor() const;
    void setThemeColor(int value);

    StyleType getStylePreference() const;
    void setStylePreference(StyleType newValue);

    bool isCurstomEmojiFont() const;
    void setCurstomEmojiFont(bool value);

    int getEmojiFontPointSize() const;
    void setEmojiFontPointSize(int value);

    QString getContactNote(const ToxPk& id) const override;
    void setContactNote(const ToxPk& id, const QString& note) override;

    QString getAutoAcceptDir(const ToxPk& id) const override;
    void setAutoAcceptDir(const ToxPk& id, const QString& dir) override;

    AutoAcceptCallFlags getAutoAcceptCall(const ToxPk& id) const override;
    void setAutoAcceptCall(const ToxPk& id, AutoAcceptCallFlags accept) override;

    QString getGlobalAutoAcceptDir() const;
    void setGlobalAutoAcceptDir(const QString& dir);

    size_t getMaxAutoAcceptSize() const;
    void setMaxAutoAcceptSize(size_t size);

    bool getAutoGroupInvite(const ToxPk& id) const override;
    void setAutoGroupInvite(const ToxPk& id, bool accept) override;

    // ChatView
    const QFont& getChatMessageFont() const;
    void setChatMessageFont(const QFont& font);

    const QString& getTimestampFormat() const;
    void setTimestampFormat(const QString& format);

    const QString& getDateFormat() const;
    void setDateFormat(const QString& format);

    bool getMinimizeOnClose() const;
    void setMinimizeOnClose(bool newValue);

    bool getStatusChangeNotificationEnabled() const;
    void setStatusChangeNotificationEnabled(bool newValue);

    bool getSpellCheckingEnabled() const;
    void setSpellCheckingEnabled(bool newValue);

    // Privacy
    bool getTypingNotification() const;
    void setTypingNotification(bool enabled);
    QStringList getBlackList() const override;
    void setBlackList(const QStringList& blist) override;

    // State
    QByteArray getWindowGeometry() const;
    void setWindowGeometry(const QByteArray& value);

    QByteArray getWindowState() const;
    void setWindowState(const QByteArray& value);

    QByteArray getSplitterState() const;
    void setSplitterState(const QByteArray& value);

    QByteArray getDialogGeometry() const;
    void setDialogGeometry(const QByteArray& value);

    QByteArray getDialogSplitterState() const;
    void setDialogSplitterState(const QByteArray& value);

    QByteArray getDialogSettingsGeometry() const;
    void setDialogSettingsGeometry(const QByteArray& value);

    QString getFriendAddress(const QString& publicKey) const;
    void updateFriendAddress(const QString& newAddr);

    QString getFriendAlias(const ToxPk& id) const override;
    void setFriendAlias(const ToxPk& id, const QString& alias) override;

    int getFriendCircleID(const ToxPk& id) const override;
    void setFriendCircleID(const ToxPk& id, int circleID) override;

    QDateTime getFriendActivity(const ToxPk& id) const override;
    void setFriendActivity(const ToxPk& id, const QDateTime& date) override;

    void saveFriendSettings(const ToxPk& id) override;
    void removeFriendSettings(const ToxPk& id) override;

    SIGNAL_IMPL(Settings, autoAcceptCallChanged, const ToxPk& id,
                IFriendSettings::AutoAcceptCallFlags accept)
    SIGNAL_IMPL(Settings, autoGroupInviteChanged, const ToxPk& id, bool accept)
    SIGNAL_IMPL(Settings, autoAcceptDirChanged, const ToxPk& id, const QString& dir)
    SIGNAL_IMPL(Settings, contactNoteChanged, const ToxPk& id, const QString& note)

    bool getCompactLayout() const;
    void setCompactLayout(bool compact);

    FriendListSortingMode getFriendSortingMode() const;
    void setFriendSortingMode(FriendListSortingMode mode);

    bool getSeparateWindow() const;
    void setSeparateWindow(bool value);

    bool getDontGroupWindows() const;
    void setDontGroupWindows(bool value);

    bool getGroupchatPosition() const;
    void setGroupchatPosition(bool value);

    bool getShowIdenticons() const;
    void setShowIdenticons(bool value);

    bool getAutoLogin() const;
    void setEnableGroupChatsColor(bool state);
    bool getEnableGroupChatsColor() const;

    int getCircleCount() const;
    int addCircle(const QString& name = QString());
    int removeCircle(int id);
    QString getCircleName(int id) const;
    void setCircleName(int id, const QString& name);
    bool getCircleExpanded(int id) const;
    void setCircleExpanded(int id, bool expanded);

    bool addFriendRequest(const QString& friendAddress, const QString& message);
    unsigned int getUnreadFriendRequests() const;
    Request getFriendRequest(int index) const;
    int getFriendRequestSize() const;
    void clearUnreadFriendRequests();
    void removeFriendRequest(int index);
    void readFriendRequest(int index);

    QByteArray getWidgetData(const QString& uniqueName) const;
    void setWidgetData(const QString& uniqueName, const QByteArray& data);

    // Wrappers around getWidgetData() and setWidgetData()
    // Assume widget has a unique objectName set
    template <class T>
    void restoreGeometryState(T* widget) const
    {
        widget->restoreGeometry(getWidgetData(widget->objectName() + ""Geometry""));
        widget->restoreState(getWidgetData(widget->objectName() + ""State""));
    }
    template <class T>
    void saveGeometryState(const T* widget)
    {
        setWidgetData(widget->objectName() + ""Geometry"", widget->saveGeometry());
        setWidgetData(widget->objectName() + ""State"", widget->saveState());
    }

    static uint32_t makeProfileId(const QString& profile);

private:
    struct friendProp;

    Settings();
    ~Settings();
    Settings(Settings& settings) = delete;
    Settings& operator=(const Settings&) = delete;
    void savePersonal(QString profileName, const ToxEncrypt* passkey);
    friendProp& getOrInsertFriendPropRef(const ToxPk& id);
    ICoreSettings::ProxyType fixInvalidProxyType(ICoreSettings::ProxyType proxyType);

    template <typename T>
    bool setVal(T& savedVal, T newVal);

public slots:
    void savePersonal(Profile* profile);

private:
    bool loaded;

    bool useCustomDhtList;
    int dhtServerId;
    bool dontShowDhtDialog;

    bool autoLogin;
    bool compactLayout;
    FriendListSortingMode sortingMode;
    bool groupchatPosition;
    bool separateWindow;
    bool dontGroupWindows;
    bool showIdenticons;
    bool enableIPv6;
    QString translation;
    bool makeToxPortable;
    bool autostartInTray;
    bool closeToTray;
    bool minimizeToTray;
    bool lightTrayIcon;
    bool useEmoticons;
    bool checkUpdates;
    bool notify;
    bool desktopNotify;
    bool showWindow;
    bool notifySound;
    bool notifyHide;
    bool busySound;
    bool groupAlwaysNotify;
    bool nameColors;

    bool forceTCP;
    bool enableLanDiscovery;

    ICoreSettings::ProxyType proxyType;
    QString proxyAddr;
    quint16 proxyPort;

    QString currentProfile;
    uint32_t currentProfileId;

    bool enableLogging;

    int autoAwayTime;

    QHash<QString, QByteArray> widgetSettings;
    QHash<QString, QString> autoAccept;
    bool autoSaveEnabled;
    QString globalAutoAcceptDir;
    size_t autoAcceptMaxSize;

    QList<Request> friendRequests;

    // GUI
    QString smileyPack;
    int emojiFontPointSize;
    bool minimizeOnClose;
    QByteArray windowGeometry;
    QByteArray windowState;
    QByteArray splitterState;
    QByteArray dialogGeometry;
    QByteArray dialogSplitterState;
    QByteArray dialogSettingsGeometry;
    QString style;
    bool showSystemTray;

    // ChatView
    QFont chatMessageFont;
    StyleType stylePreference;
    int firstColumnHandlePos;
    int secondColumnHandlePosFromRight;
    QString timestampFormat;
    QString dateFormat;
    bool statusChangeNotificationEnabled;
    bool spellCheckingEnabled;

    // Privacy
    bool typingNotification;
    Db::syncType dbSyncType;
    QStringList blackList;

    // Audio
    QString inDev;
    bool audioInDevEnabled;
    qreal audioInGainDecibel;
    qreal audioThreshold;
    QString outDev;
    bool audioOutDevEnabled;
    int outVolume;
    int audioBitrate;
    bool enableTestSound;

    // Video
    QString videoDev;
    QRect camVideoRes;
    QRect screenRegion;
    bool screenGrabbed;
    float camVideoFPS;

    struct friendProp
    {
        friendProp() = delete;
        friendProp(QString addr)
            : addr(addr)
        {}
        QString alias = """";
        QString addr = """";
        QString autoAcceptDir = """";
        QString note = """";
        int circleID = -1;
        QDateTime activity = QDateTime();
        AutoAcceptCallFlags autoAcceptCall;
        bool autoGroupInvite = false;
    };

    struct circleProp
    {
        QString name;
        bool expanded;
    };

    QHash<QByteArray, friendProp> friendLst;

    QVector<circleProp> circleLst;

    int themeColor;

    static CompatibleRecursiveMutex bigLock;
    static Settings* settings;
    static const QString globalSettingsFile;
    static QThread* settingsThread;
    Paths paths;
};",1,587 2000 58 777 2001 44 777 2002 44 777 2003 44 777 2004 44 777 2005 44 777 2006 44 777 2007 123 2008 2009 40 2010 41 330 2011 40 569 2012 2013 2014 2015 2016 2017 2018 2019 41 2011 40 569 2020 2013 2021 2015 2022 2017 2023 2019 41 330 2011 40 569 2024 2013 2025 2015 2026 2017 2027 2019 41 2011 40 2028 2029 2013 2030 2015 2031 2017 2032 2019 41 2011 40 704 2033 2013 2034 2015 2035 2017 2036 2019 41 2011 40 569 2037 2013 2038 2015 2039 2017 2040 2019 41 2011 40 2041 2042 2013 2043 2015 2044 2017 2045 2019 41 2011 40 2041 2046 2013 2047 2015 2048 2017 2049 2019 41 2011 40 2041 2050 2013 2051 2015 2052 2017 2053 2019 41 2011 40 2041 2054 2013 2055 2015 2056 2017 2057 2019 41 2011 40 2041 2058 2013 2059 2015 2060 2017 2061 2019 41 2011 40 2041 2062 2013 2063 2015 2064 2017 2065 2019 41 2011 40 2028 2066 2013 2067 2015 2068 2017 2069 2019 41 2011 40 569 2070 2013 2071 2015 2072 2017 2073 2019 41 2011 40 569 2074 2013 2075 2015 2076 2017 2077 2019 41 330 2011 40 569 2078 2013 2079 2015 2080 2017 2081 2019 41 2011 40 2082 2083 2013 2084 2015 2085 2017 2086 2019 41 2011 40 2010 2087 2013 2088 2015 2089 2017 2090 2019 41 2011 40 2028 2091 2013 2092 2015 2093 2017 2094 2019 41 2011 40 2028 2095 2013 2096 2015 2097 2017 2098 2019 41 2011 40 569 2099 2013 2100 2015 2101 2017 2102 2019 41 2011 40 569 2103 2013 2104 2015 2105 2017 2106 2019 41 330 2011 40 569 2107 2013 2108 2015 2109 2017 2110 2019 41 2011 40 2111 2112 2013 2113 2015 2114 2017 2115 2019 41 330 2011 40 2028 2116 2013 2117 2015 2118 2017 2119 2019 41 2011 40 569 2120 2013 2121 2015 2122 2017 2123 2019 41 2011 40 2124 2125 2013 2126 2015 2127 2017 2128 2019 41 2011 40 2124 2129 2013 2130 2015 2131 2017 2132 2019 41 2011 40 2028 2133 2013 2134 2015 2135 2017 2136 2019 41 2011 40 569 2137 2013 2138 2015 2139 2017 2140 2019 41 2011 40 704 2141 2013 2142 2015 2143 2017 2144 2019 41 2011 40 704 2145 2013 2146 2015 2147 2017 2148 2019 41 330 2011 40 2028 2149 2013 2150 2015 2151 2017 2152 2019 41 2011 40 2153 2154 2013 2155 2015 2156 2017 2157 2019 41 2011 40 2153 2158 2013 2159 2015 2160 2017 2161 2019 41 2011 40 569 2162 2013 2163 2015 2164 2017 2165 2019 41 2011 40 660 2166 2013 2167 2015 2168 2017 2169 2019 41 777 58 640 587 2010 123 2170 61 1500 44 2171 61 1501 44 2172 61 1502 125 59 640 587 2173 123 2174 44 2175 44 125 59 777 58 809 2000 38 2176 40 41 59 809 865 2177 40 41 59 2178 38 2179 40 41 59 865 2180 40 41 59 865 2181 40 601 2028 38 2182 41 601 59 865 2183 40 41 59 865 2184 40 41 59 569 2185 40 41 59 865 2186 40 2028 2187 44 601 2188 42 2189 41 59 865 2190 40 41 59 816 2191 123 2028 2192 59 2028 2193 59 569 2194 59 125 59 777 2195 58 865 2196 40 41 59 865 2197 40 41 59 865 2198 40 569 2199 41 59 865 2200 40 2201 42 2202 44 601 2203 42 2204 41 59 2205 58 330 865 2023 40 569 2206 41 59 865 2207 40 569 2206 41 59 865 2208 40 569 2206 41 59 865 2209 40 569 2206 41 59 865 2210 40 569 2206 41 59 865 2211 40 569 2206 41 59 865 2212 40 569 2206 41 59 865 2213 40 569 2206 41 59 865 2214 40 569 2206 41 59 865 2215 40 569 2206 41 59 865 2216 40 569 2206 41 59 865 2217 40 569 2206 41 59 865 2218 40 569 2206 41 59 865 2219 40 569 2206 41 59 865 2220 40 601 2028 38 2221 41 59 865 2222 40 2223 2224 41 59 865 2225 40 569 2206 41 59 865 2226 40 704 2227 41 59 865 2228 40 601 2028 38 2229 41 59 865 2230 40 2231 2232 41 59 865 2233 40 569 2206 41 59 865 2234 40 601 2028 38 2235 41 59 330 865 2236 40 569 2206 41 59 865 2237 40 569 2206 41 59 865 2027 40 569 2206 41 59 865 2073 40 569 2206 41 59 569 2040 40 569 2206 41 59 865 2045 40 601 2041 38 2238 41 59 865 2049 40 601 2041 38 2199 41 59 865 2053 40 601 2041 38 2199 41 59 865 2057 40 601 2041 38 2238 41 59 865 2061 40 601 2041 38 2199 41 59 865 2065 40 601 2041 38 2238 41 59 865 2069 40 601 2028 38 2066 41 59 865 2239 40 704 2240 41 59 865 2018 40 569 2206 41 59 865 2241 40 2173 2242 41 59 865 2077 40 569 2206 41 59 330 865 2243 40 569 2206 41 59 865 2032 40 601 2028 38 2244 41 59 865 2036 40 704 2232 41 59 865 2245 40 569 2206 41 59 865 2081 40 569 2206 41 59 865 2086 40 601 2082 38 2246 41 59 865 2090 40 2010 2247 41 59 865 2094 40 601 2028 38 2248 41 59 865 2098 40 601 2028 38 2248 41 59 865 2102 40 569 2206 41 59 865 2106 40 569 2206 41 59 330 865 2110 40 569 2206 41 59 865 2249 40 2250 321 2251 2247 41 59 865 2115 40 2111 601 38 2252 41 59 777 58 569 2253 40 601 2203 38 2204 41 59 809 569 2254 40 601 2203 38 2204 41 59 569 2255 40 41 601 59 865 2256 40 569 2257 41 59 569 2021 40 41 601 59 865 2022 40 569 2257 41 59 569 2258 40 41 601 59 865 2259 40 569 2257 41 59 569 2260 40 41 601 59 865 2261 40 569 2257 41 59 569 2262 40 41 601 59 865 2263 40 569 2257 41 59 569 2264 40 41 601 59 865 2265 40 569 2257 41 59 2028 2067 40 41 601 59 865 2068 40 601 2028 38 2257 41 59 569 2071 40 41 601 59 865 2072 40 569 2257 41 59 569 2266 40 41 601 59 865 2267 40 569 2257 41 59 2028 2268 40 41 601 59 2269 2270 40 41 601 59 865 2271 40 601 2028 38 2202 41 59 2028 2272 40 41 601 59 865 2273 40 601 2028 38 2257 41 59 865 2274 40 569 2257 41 59 569 2275 40 41 601 59 330 569 2276 40 41 601 2277 59 865 2278 40 569 2206 41 2277 59 569 2279 40 41 601 2277 59 865 2280 40 569 2206 41 2277 59 569 2281 40 41 601 2277 59 865 2282 40 569 2206 41 2277 59 2028 2283 40 41 601 2277 59 865 2284 40 601 2028 38 2285 41 2277 59 2002 321 2286 2287 40 41 601 2277 59 865 2288 40 2002 321 2286 2247 41 2277 59 2289 2290 40 41 601 2277 59 865 2291 40 2289 2292 41 2277 59 2293 2294 40 41 601 2277 59 2295 40 2000 44 2296 44 569 2206 41 2295 40 2000 44 2297 44 569 2206 41 2295 40 2000 44 2298 44 569 2206 41 2295 40 2000 44 2299 44 2002 321 2286 2247 41 2295 40 2000 44 2300 44 601 2028 38 2285 41 2295 40 2000 44 2301 44 2289 2292 41 569 2302 40 41 601 59 865 2303 40 569 2257 41 59 2250 321 2251 2304 40 41 601 59 865 2305 40 2250 321 2251 2257 41 59 704 2306 40 41 601 59 865 2307 40 704 2257 41 59 569 2308 40 41 601 59 865 2309 40 569 2257 41 59 569 2310 40 41 601 2277 59 865 2311 40 569 2257 41 2277 59 569 2312 40 41 601 2277 59 865 2313 40 569 2257 41 2277 59 569 2314 40 41 601 2277 59 865 2315 40 569 2206 41 2277 59 569 2316 40 41 601 2277 59 865 2317 40 569 2257 41 2277 59 569 2318 40 41 601 2277 59 865 2319 40 569 2257 41 2277 59 569 2320 40 41 601 2277 59 865 2321 40 569 2257 41 2277 59 569 2322 40 41 601 2277 59 865 2323 40 569 2257 41 2277 59 2028 2117 40 41 601 2277 59 865 2118 40 601 2028 38 2324 41 2277 59 569 2121 40 41 601 2277 59 865 2122 40 569 2206 41 2277 59 2028 2134 40 41 601 2277 59 865 2135 40 601 2028 38 2324 41 2277 59 569 2138 40 41 601 2277 59 865 2139 40 569 2206 41 2277 59 2124 2126 40 41 601 2277 59 865 2127 40 2124 2325 41 2277 59 2124 2130 40 41 601 2277 59 865 2131 40 2124 2326 41 2277 59 704 2142 40 41 601 2277 59 704 2327 40 41 601 2277 123 792 1500 59 125 704 2328 40 41 601 2277 123 792 1503 59 125 865 2143 40 704 2329 41 2277 59 704 2146 40 41 601 2277 59 865 2147 40 704 2330 41 2277 59 569 2331 40 41 601 2277 59 865 2332 40 569 2257 41 2277 59 2295 40 2000 44 2119 44 601 2028 38 2333 41 2295 40 2000 44 2123 44 569 2206 41 2295 40 2000 44 2136 44 601 2028 38 2333 41 2295 40 2000 44 2140 44 569 2206 41 2295 40 2000 44 2128 44 2124 2325 41 2295 40 2000 44 2132 44 2124 2326 41 2295 40 2000 44 2144 44 704 2329 41 2295 40 2000 44 2148 44 704 2330 41 2295 40 2000 44 2334 44 569 2257 41 2028 2150 40 41 601 2277 59 865 2151 40 601 2028 38 2324 41 2277 59 2153 2159 40 41 601 2277 59 865 2160 40 601 2153 38 2335 41 2277 59 569 2163 40 41 601 2277 59 865 2164 40 569 2335 41 2277 59 2153 2155 40 41 601 2277 59 865 2156 40 2153 2257 41 2277 59 660 2167 40 41 601 2277 59 865 2168 40 660 2257 41 2277 59 2295 40 2000 44 2152 44 601 2028 38 2333 41 2295 40 2000 44 2161 44 601 2153 38 2336 41 2295 40 2000 44 2165 44 569 2206 41 2295 40 2000 44 2157 44 601 2153 38 2336 41 2295 40 2000 44 2169 44 856 803 2337 41 569 2338 40 41 601 59 865 2339 40 569 2257 41 59 2028 2030 40 41 601 59 865 2031 40 601 2028 38 2335 41 59 704 2340 40 41 601 59 865 2341 40 704 2335 41 59 2010 2088 40 41 601 59 865 2089 40 2010 2257 41 59 569 2342 40 41 601 59 865 2343 40 569 2335 41 59 704 2034 40 41 601 59 865 2035 40 704 2335 41 59 2028 2344 40 601 2345 38 2224 41 601 2277 59 865 2346 40 601 2345 38 2224 44 601 2028 38 2347 41 2277 59 2028 2348 40 601 2345 38 2224 41 601 2277 59 865 2349 40 601 2345 38 2224 44 601 2028 38 2350 41 2277 59 2351 2352 40 601 2345 38 2224 41 601 2277 59 865 2353 40 601 2345 38 2224 44 2351 2354 41 2277 59 2028 2355 40 41 601 59 865 2356 40 601 2028 38 2350 41 59 2231 2357 40 41 601 59 865 2358 40 2231 2232 41 59 569 2359 40 601 2345 38 2224 41 601 2277 59 865 2360 40 601 2345 38 2224 44 569 2354 41 2277 59 330 601 2082 38 2084 40 41 601 59 865 2085 40 601 2082 38 2246 41 59 601 2028 38 2092 40 41 601 59 865 2093 40 601 2028 38 2248 41 59 601 2028 38 2096 40 41 601 59 865 2097 40 601 2028 38 2248 41 59 569 2038 40 41 601 59 865 2039 40 569 2257 41 59 569 2100 40 41 601 59 865 2101 40 569 2257 41 59 569 2104 40 41 601 59 865 2105 40 569 2257 41 59 330 569 2108 40 41 601 59 865 2109 40 569 2206 41 59 2111 2113 40 41 601 2277 59 865 2114 40 601 2111 38 2252 41 2277 59 330 2041 2043 40 41 601 59 865 2044 40 601 2041 38 2335 41 59 2041 2047 40 41 601 59 865 2048 40 601 2041 38 2335 41 59 2041 2051 40 41 601 59 865 2052 40 601 2041 38 2335 41 59 2041 2055 40 41 601 59 865 2056 40 601 2041 38 2335 41 59 2041 2059 40 41 601 59 865 2060 40 601 2041 38 2335 41 59 2041 2063 40 41 601 59 865 2064 40 601 2041 38 2335 41 59 2028 2361 40 601 2028 38 2362 41 601 59 865 2363 40 601 2028 38 2364 41 59 2028 2365 40 601 2345 38 2224 41 601 2277 59 865 2366 40 601 2345 38 2224 44 601 2028 38 2367 41 2277 59 704 2368 40 601 2345 38 2224 41 601 2277 59 865 2369 40 601 2345 38 2224 44 704 2370 41 2277 59 2371 2372 40 601 2345 38 2224 41 601 2277 59 865 2373 40 601 2345 38 2224 44 601 2371 38 2374 41 2277 59 865 2375 40 601 2345 38 2224 41 2277 59 865 2376 40 601 2345 38 2224 41 2277 59 2295 40 2000 44 2377 44 601 2345 38 2224 44 2003 321 2351 2354 41 2295 40 2000 44 2378 44 601 2345 38 2224 44 569 2354 41 2295 40 2000 44 2379 44 601 2345 38 2224 44 601 2028 38 2350 41 2295 40 2000 44 2380 44 601 2345 38 2224 44 601 2028 38 2347 41 569 2014 40 41 601 59 865 2016 40 569 2381 41 59 2173 2382 40 41 601 59 865 2383 40 2173 2242 41 59 569 2025 40 41 601 59 865 2026 40 569 2335 41 59 569 2384 40 41 601 59 865 2385 40 569 2335 41 59 569 2079 40 41 601 59 865 2080 40 569 2335 41 59 569 2075 40 41 601 59 865 2076 40 569 2335 41 59 569 2386 40 41 601 59 865 2387 40 569 2199 41 59 569 2388 40 41 601 59 704 2389 40 41 601 59 704 2390 40 601 2028 38 2244 61 2028 40 41 41 59 704 2391 40 704 2224 41 59 2028 2392 40 704 2224 41 601 59 865 2393 40 704 2224 44 601 2028 38 2244 41 59 569 2394 40 704 2224 41 601 59 865 2395 40 704 2224 44 569 2396 41 59 569 2397 40 601 2028 38 2398 44 601 2028 38 2399 41 59 856 704 2400 40 41 601 59 2191 2401 40 704 2402 41 601 59 704 2403 40 41 601 59 865 2404 40 41 59 865 2405 40 704 2402 41 59 865 2406 40 704 2402 41 59 2041 2407 40 601 2028 38 2408 41 601 59 865 2409 40 601 2028 38 2408 44 601 2041 38 2410 41 59 330 330 822 60 587 2411 62 865 2412 40 2411 42 2413 41 601 123 2413 354 2414 40 2407 40 2413 354 2415 40 41 43 362 41 41 59 2413 354 2416 40 2407 40 2413 354 2415 40 41 43 362 41 41 59 125 822 60 587 2411 62 865 2417 40 601 2411 42 2413 41 123 2409 40 2413 354 2418 40 41 43 362 44 2413 354 2419 40 41 41 59 2409 40 2413 354 2418 40 41 43 362 44 2413 354 2420 40 41 41 59 125 809 2269 2421 40 601 2028 38 2202 41 59 773 58 816 2422 59 2000 40 41 59 126 2000 40 41 59 2000 40 2000 38 2423 41 61 619 59 2000 38 758 61 40 601 2000 38 41 61 619 59 865 2183 40 2028 2187 44 601 2188 42 2424 41 59 2422 38 2425 40 601 2345 38 2224 41 59 2002 321 2286 2426 40 2002 321 2286 2427 41 59 822 60 835 2411 62 569 2428 40 2411 38 2429 44 2411 2430 41 59 777 2195 58 865 2183 40 2201 42 2202 41 59 773 58 569 2431 59 569 2432 59 704 2433 59 569 2434 59 569 2435 59 569 2012 59 2173 2436 59 569 2078 59 569 2024 59 569 2437 59 569 2074 59 569 2438 59 2028 2221 59 569 2439 59 569 2440 59 569 2441 59 569 2442 59 569 2443 59 569 2444 59 569 2445 59 569 2446 59 569 2447 59 569 2448 59 569 2449 59 569 2450 59 569 2451 59 569 2452 59 569 2453 59 569 2454 59 569 2455 59 2002 321 2286 2427 59 2028 2456 59 2289 2457 59 2028 2458 59 2269 2459 59 569 2460 59 704 2461 59 2462 60 2028 44 2041 62 2463 59 2462 60 2028 44 2028 62 2464 59 569 2465 59 2028 2466 59 2231 2467 59 2468 60 2191 62 2469 59 330 2028 2029 59 704 2033 59 569 2037 59 2041 2042 59 2041 2046 59 2041 2050 59 2041 2054 59 2041 2058 59 2041 2062 59 2028 2066 59 569 2070 59 330 2082 2083 59 2010 2087 59 704 2470 59 704 2471 59 2028 2091 59 2028 2095 59 569 2099 59 569 2103 59 330 569 2107 59 2250 321 2251 2472 59 2111 2112 59 330 2028 2116 59 569 2120 59 2124 2125 59 2124 2129 59 2028 2133 59 569 2137 59 704 2141 59 704 2145 59 569 2473 59 330 2028 2149 59 2153 2154 59 2153 2158 59 569 2162 59 660 2166 59 816 2422 123 2422 40 41 61 619 59 2422 40 2028 2474 41 58 2474 40 2474 41 123 125 2028 2367 61 362 59 2028 2474 61 362 59 2028 2475 61 362 59 2028 2347 61 362 59 704 2370 61 45 1501 59 2371 2476 61 2371 40 41 59 2351 2477 59 569 2478 61 655 59 125 59 816 2479 123 2028 2244 59 569 2396 59 125 59 2462 60 2041 44 2422 62 2480 59 2481 60 2479 62 2482 59 704 2483 59 809 2484 2485 59 809 2000 42 2423 59 809 601 2028 2486 59 809 2487 42 2488 59 2178 2489 59 125 59 ,"{'AvgLine': 43, 'CountLine': 2628, 'CountStmt': 1077, 'MaxNesting': 3, 'AvgLineCode': 34, 'AvgEssential': 1, 'AvgLineBlank': 8, 'CountStmtExe': 365, 'MaxEssential': 14, 'SumEssential': 240, 'AvgCyclomatic': 1, 'CountLineCode': 2307, 'CountStmtDecl': 722, 'MaxCyclomatic': 16, 'SumCyclomatic': 365, 'AltAvgLineCode': 34, 'AvgLineComment': 1, 'CountClassBase': 6, 'CountLineBlank': 268, 'CountStmtEmpty': 5, 'AltAvgLineBlank': 8, 'CountDeclMethod': 312, 'AltCountLineCode': 2319, 'CountLineCodeExe': 333, 'CountLineComment': 45, 'AltAvgLineComment': 1, 'AltCountLineBlank': 269, 'CountClassCoupled': 16, 'CountClassDerived': 0, 'CountLineCodeDecl': 478, 'CountLineInactive': 7, 'CountDeclMethodAll': 447, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.02', 'AltCountLineComment': 45, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 17, 'SumCyclomaticStrict': 369, 'CountDeclClassMethod': 3, 'CountDeclMethodConst': 118, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 304, 'CountLinePreprocessor': 6, 'MaxCyclomaticModified': 16, 'PercentLackOfCohesion': 99, 'SumCyclomaticModified': 361, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 8, 'CountDeclInstanceMethod': 309, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 86, 'CountDeclInstanceVariablePublic': 34, 'CountDeclInstanceVariablePrivate': 52, 'CountDeclInstanceVariableProtected': 0}"
118060,C++,"class MavlinkReceiver : public ModuleParams
{
public:
	MavlinkReceiver(Mavlink *parent);
	~MavlinkReceiver() override;

	void start();
	void stop();

	bool component_was_seen(int system_id, int component_id);
	void enable_message_statistics() { _message_statistics_enabled = true; }
	void print_detailed_rx_stats() const;

	void request_stop() { _should_exit.store(true); }

private:
	static void *start_trampoline(void *context);
	void run();

	void acknowledge(uint8_t sysid, uint8_t compid, uint16_t command, uint8_t result, uint8_t progress = 0);

	/**
	 * Common method to handle both mavlink command types. T is one of mavlink_command_int_t or mavlink_command_long_t.
	 */
	template<class T>
	void handle_message_command_both(mavlink_message_t *msg, const T &cmd_mavlink,
					 const vehicle_command_s &vehicle_command);

	uint8_t handle_request_message_command(uint16_t message_id, float param2 = 0.0f, float param3 = 0.0f,
					       float param4 = 0.0f, float param5 = 0.0f, float param6 = 0.0f, float param7 = 0.0f);

	void handle_message(mavlink_message_t *msg);

	void handle_message_adsb_vehicle(mavlink_message_t *msg);
	void handle_message_att_pos_mocap(mavlink_message_t *msg);
	void handle_message_battery_status(mavlink_message_t *msg);
	void handle_message_cellular_status(mavlink_message_t *msg);
	void handle_message_collision(mavlink_message_t *msg);
	void handle_message_command_ack(mavlink_message_t *msg);
	void handle_message_command_int(mavlink_message_t *msg);
	void handle_message_command_long(mavlink_message_t *msg);
	void handle_message_distance_sensor(mavlink_message_t *msg);
	void handle_message_follow_target(mavlink_message_t *msg);
	void handle_message_generator_status(mavlink_message_t *msg);
	void handle_message_set_gps_global_origin(mavlink_message_t *msg);
	void handle_message_gps_rtcm_data(mavlink_message_t *msg);
	void handle_message_heartbeat(mavlink_message_t *msg);
	void handle_message_hil_gps(mavlink_message_t *msg);
	void handle_message_hil_optical_flow(mavlink_message_t *msg);
	void handle_message_hil_sensor(mavlink_message_t *msg);
	void handle_message_hil_state_quaternion(mavlink_message_t *msg);
	void handle_message_landing_target(mavlink_message_t *msg);
	void handle_message_logging_ack(mavlink_message_t *msg);
	void handle_message_manual_control(mavlink_message_t *msg);
	void handle_message_obstacle_distance(mavlink_message_t *msg);
	void handle_message_odometry(mavlink_message_t *msg);
	void handle_message_onboard_computer_status(mavlink_message_t *msg);
	void handle_message_optical_flow_rad(mavlink_message_t *msg);
	void handle_message_ping(mavlink_message_t *msg);
	void handle_message_play_tune(mavlink_message_t *msg);
	void handle_message_play_tune_v2(mavlink_message_t *msg);
	void handle_message_radio_status(mavlink_message_t *msg);
	void handle_message_rc_channels(mavlink_message_t *msg);
	void handle_message_rc_channels_override(mavlink_message_t *msg);
	void handle_message_serial_control(mavlink_message_t *msg);
	void handle_message_set_actuator_control_target(mavlink_message_t *msg);
	void handle_message_set_attitude_target(mavlink_message_t *msg);
	void handle_message_set_mode(mavlink_message_t *msg);
	void handle_message_set_position_target_global_int(mavlink_message_t *msg);
	void handle_message_set_position_target_local_ned(mavlink_message_t *msg);
	void handle_message_statustext(mavlink_message_t *msg);
	void handle_message_trajectory_representation_bezier(mavlink_message_t *msg);
	void handle_message_trajectory_representation_waypoints(mavlink_message_t *msg);
	void handle_message_utm_global_position(mavlink_message_t *msg);
	void handle_message_vision_position_estimate(mavlink_message_t *msg);
	void handle_message_gimbal_manager_set_attitude(mavlink_message_t *msg);
	void handle_message_gimbal_manager_set_manual_control(mavlink_message_t *msg);
	void handle_message_gimbal_device_information(mavlink_message_t *msg);

#if !defined(CONSTRAINED_FLASH)
	void handle_message_debug(mavlink_message_t *msg);
	void handle_message_debug_float_array(mavlink_message_t *msg);
	void handle_message_debug_vect(mavlink_message_t *msg);
	void handle_message_named_value_float(mavlink_message_t *msg);
#endif // !CONSTRAINED_FLASH
	void handle_message_request_event(mavlink_message_t *msg);

	void CheckHeartbeats(const hrt_abstime &t, bool force = false);

	/**
	 * Set the interval at which the given message stream is published.
	 * The rate is the number of messages per second.
	 *
	 * @param msgId The ID of the message interval to be set.
	 * @param interval The interval in usec to send the message.
	 * @param data_rate The total link data rate in bytes per second.
	 *
	 * @return PX4_OK on success, PX4_ERROR on fail.
	 */
	int set_message_interval(int msgId, float interval, int data_rate = -1);
	void get_message_interval(int msgId);

	bool evaluate_target_ok(int command, int target_system, int target_component);

	void fill_thrust(float *thrust_body_array, uint8_t vehicle_type, float thrust);

	void schedule_tune(const char *tune);

	void update_message_statistics(const mavlink_message_t &message);
	void update_rx_stats(const mavlink_message_t &message);

	px4::atomic_bool 	_should_exit{false};
	pthread_t		_thread {};
	/**
	 * @brief Updates optical flow parameters.
	 */
	void updateParams() override;

	Mavlink				*_mavlink;

	MavlinkFTP			_mavlink_ftp;
	MavlinkLogHandler		_mavlink_log_handler;
	MavlinkMissionManager		_mission_manager;
	MavlinkParametersManager	_parameters_manager;
	MavlinkTimesync			_mavlink_timesync;
	MavlinkStatustextHandler	_mavlink_statustext_handler;

	mavlink_status_t		_status{}; ///< receiver status, used for mavlink_parse_char()

	orb_advert_t _mavlink_log_pub{nullptr};

	static constexpr unsigned MAX_REMOTE_COMPONENTS{16};
	struct ComponentState {
		uint32_t received_messages{0};
		uint32_t missed_messages{0};
		uint8_t system_id{0};
		uint8_t component_id{0};
		uint8_t last_sequence{0};
	};
	ComponentState _component_states[MAX_REMOTE_COMPONENTS] {};
	unsigned _component_states_count{0};
	bool _warned_component_states_full_once{false};

	bool _message_statistics_enabled {false};
#if !defined(CONSTRAINED_FLASH)
	static constexpr int MAX_MSG_STAT_SLOTS {16};
	struct ReceivedMessageStats {
		float avg_rate_hz{0.f}; // average rate
		uint32_t last_time_received_ms{0};
		uint16_t msg_id{0};
		uint8_t system_id{0};
		uint8_t component_id{0};
	};
	ReceivedMessageStats *_received_msg_stats{nullptr};
#endif // !CONSTRAINED_FLASH

	uint64_t _total_received_counter{0};                            ///< The total number of successfully received messages
	uint64_t _total_lost_counter{0};                                ///< Total messages lost during transmission.

	uint8_t _mavlink_status_last_buffer_overrun{0};
	uint8_t _mavlink_status_last_parse_error{0};
	uint16_t _mavlink_status_last_packet_rx_drop_count{0};

	// ORB publications
	uORB::Publication<actuator_controls_s>			_actuator_controls_pubs[4] {ORB_ID(actuator_controls_0), ORB_ID(actuator_controls_1), ORB_ID(actuator_controls_2), ORB_ID(actuator_controls_3)};
	uORB::Publication<airspeed_s>				_airspeed_pub{ORB_ID(airspeed)};
	uORB::Publication<battery_status_s>			_battery_pub{ORB_ID(battery_status)};
	uORB::Publication<camera_status_s>					_camera_status_pub{ORB_ID(camera_status)};
	uORB::Publication<cellular_status_s>			_cellular_status_pub{ORB_ID(cellular_status)};
	uORB::Publication<collision_report_s>			_collision_report_pub{ORB_ID(collision_report)};
	uORB::Publication<differential_pressure_s>		_differential_pressure_pub{ORB_ID(differential_pressure)};
	uORB::Publication<follow_target_s>			_follow_target_pub{ORB_ID(follow_target)};
	uORB::Publication<gimbal_manager_set_attitude_s>	_gimbal_manager_set_attitude_pub{ORB_ID(gimbal_manager_set_attitude)};
	uORB::Publication<gimbal_manager_set_manual_control_s>	_gimbal_manager_set_manual_control_pub{ORB_ID(gimbal_manager_set_manual_control)};
	uORB::Publication<gimbal_device_information_s>		_gimbal_device_information_pub{ORB_ID(gimbal_device_information)};
	uORB::Publication<irlock_report_s>			_irlock_report_pub{ORB_ID(irlock_report)};
	uORB::Publication<landing_target_pose_s>		_landing_target_pose_pub{ORB_ID(landing_target_pose)};
	uORB::Publication<log_message_s>			_log_message_pub{ORB_ID(log_message)};
	uORB::Publication<obstacle_distance_s>			_obstacle_distance_pub{ORB_ID(obstacle_distance)};
	uORB::Publication<offboard_control_mode_s>		_offboard_control_mode_pub{ORB_ID(offboard_control_mode)};
	uORB::Publication<onboard_computer_status_s>		_onboard_computer_status_pub{ORB_ID(onboard_computer_status)};
	uORB::Publication<generator_status_s>			_generator_status_pub{ORB_ID(generator_status)};
	uORB::Publication<optical_flow_s>			_flow_pub{ORB_ID(optical_flow)};
	uORB::Publication<sensor_gps_s>				_sensor_gps_pub{ORB_ID(sensor_gps)};
	uORB::Publication<vehicle_attitude_s>			_attitude_pub{ORB_ID(vehicle_attitude)};
	uORB::Publication<vehicle_attitude_setpoint_s>		_att_sp_pub{ORB_ID(vehicle_attitude_setpoint)};
	uORB::Publication<vehicle_attitude_setpoint_s>		_mc_virtual_att_sp_pub{ORB_ID(mc_virtual_attitude_setpoint)};
	uORB::Publication<vehicle_attitude_setpoint_s>		_fw_virtual_att_sp_pub{ORB_ID(fw_virtual_attitude_setpoint)};
	uORB::Publication<vehicle_global_position_s>		_global_pos_pub{ORB_ID(vehicle_global_position)};
	uORB::Publication<vehicle_land_detected_s>		_land_detector_pub{ORB_ID(vehicle_land_detected)};
	uORB::Publication<vehicle_local_position_s>		_local_pos_pub{ORB_ID(vehicle_local_position)};
	uORB::Publication<vehicle_local_position_setpoint_s>	_trajectory_setpoint_pub{ORB_ID(trajectory_setpoint)};
	uORB::Publication<vehicle_odometry_s>			_mocap_odometry_pub{ORB_ID(vehicle_mocap_odometry)};
	uORB::Publication<vehicle_odometry_s>			_visual_odometry_pub{ORB_ID(vehicle_visual_odometry)};
	uORB::Publication<vehicle_rates_setpoint_s>		_rates_sp_pub{ORB_ID(vehicle_rates_setpoint)};
	uORB::Publication<vehicle_trajectory_bezier_s>		_trajectory_bezier_pub{ORB_ID(vehicle_trajectory_bezier)};
	uORB::Publication<vehicle_trajectory_waypoint_s>	_trajectory_waypoint_pub{ORB_ID(vehicle_trajectory_waypoint)};

#if !defined(CONSTRAINED_FLASH)
	uORB::Publication<debug_array_s>			_debug_array_pub {ORB_ID(debug_array)};
	uORB::Publication<debug_key_value_s>			_debug_key_value_pub{ORB_ID(debug_key_value)};
	uORB::Publication<debug_value_s>			_debug_value_pub{ORB_ID(debug_value)};
	uORB::Publication<debug_vect_s>				_debug_vect_pub{ORB_ID(debug_vect)};
#endif // !CONSTRAINED_FLASH

	// ORB publications (multi)
	uORB::PublicationMulti<distance_sensor_s>		_distance_sensor_pub{ORB_ID(distance_sensor)};
	uORB::PublicationMulti<distance_sensor_s>		_flow_distance_sensor_pub{ORB_ID(distance_sensor)};
	uORB::PublicationMulti<input_rc_s>			_rc_pub{ORB_ID(input_rc)};
	uORB::PublicationMulti<manual_control_setpoint_s>		_manual_control_input_pub{ORB_ID(manual_control_input)};
	uORB::PublicationMulti<ping_s>				_ping_pub{ORB_ID(ping)};
	uORB::PublicationMulti<radio_status_s>			_radio_status_pub{ORB_ID(radio_status)};

	// ORB publications (queue length > 1)
	uORB::Publication<gps_inject_data_s>     _gps_inject_data_pub{ORB_ID(gps_inject_data)};
	uORB::Publication<transponder_report_s>  _transponder_report_pub{ORB_ID(transponder_report)};
	uORB::Publication<vehicle_command_s>     _cmd_pub{ORB_ID(vehicle_command)};
	uORB::Publication<vehicle_command_ack_s> _cmd_ack_pub{ORB_ID(vehicle_command_ack)};

	// ORB subscriptions
	uORB::Subscription	_actuator_armed_sub{ORB_ID(actuator_armed)};
	uORB::Subscription	_home_position_sub{ORB_ID(home_position)};
	uORB::Subscription	_vehicle_attitude_sub{ORB_ID(vehicle_attitude)};
	uORB::Subscription	_vehicle_local_position_sub{ORB_ID(vehicle_local_position)};
	uORB::Subscription	_vehicle_global_position_sub{ORB_ID(vehicle_global_position)};
	uORB::Subscription	_vehicle_status_sub{ORB_ID(vehicle_status)};
	uORB::Subscription 	_actuator_controls_3_sub{ORB_ID(actuator_controls_3)};
	uORB::Subscription	_autotune_attitude_control_status_sub{ORB_ID(autotune_attitude_control_status)};

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};

	// hil_sensor and hil_state_quaternion
	enum SensorSource {
		ACCEL		= 0b111,
		GYRO		= 0b111000,
		MAG		= 0b111000000,
		BARO		= 0b1101000000000,
		DIFF_PRESS	= 0b10000000000
	};
	PX4Accelerometer *_px4_accel{nullptr};
	PX4Barometer *_px4_baro{nullptr};
	PX4Gyroscope *_px4_gyro{nullptr};
	PX4Magnetometer *_px4_mag{nullptr};

	float _global_local_alt0{NAN};
	MapProjection _global_local_proj_ref{};

	hrt_abstime			_last_utm_global_pos_com{0};

	// Allocated if needed.
	TunePublisher *_tune_publisher{nullptr};

	hrt_abstime _last_heartbeat_check{0};

	hrt_abstime _heartbeat_type_antenna_tracker{0};
	hrt_abstime _heartbeat_type_gcs{0};
	hrt_abstime _heartbeat_type_onboard_controller{0};
	hrt_abstime _heartbeat_type_gimbal{0};
	hrt_abstime _heartbeat_type_adsb{0};
	hrt_abstime _heartbeat_type_camera{0};
	hrt_abstime _heartbeat_type_parachute{0};

	hrt_abstime _heartbeat_component_telemetry_radio{0};
	hrt_abstime _heartbeat_component_log{0};
	hrt_abstime _heartbeat_component_osd{0};
	hrt_abstime _heartbeat_component_obstacle_avoidance{0};
	hrt_abstime _heartbeat_component_visual_inertial_odometry{0};
	hrt_abstime _heartbeat_component_pairing_manager{0};
	hrt_abstime _heartbeat_component_udp_bridge{0};
	hrt_abstime _heartbeat_component_uart_bridge{0};

	param_t _handle_sens_flow_maxhgt{PARAM_INVALID};
	param_t _handle_sens_flow_maxr{PARAM_INVALID};
	param_t _handle_sens_flow_minhgt{PARAM_INVALID};
	param_t _handle_sens_flow_rot{PARAM_INVALID};

	float _param_sens_flow_maxhgt{-1.0f};
	float _param_sens_flow_maxr{-1.0f};
	float _param_sens_flow_minhgt{-1.0f};
	int32_t _param_sens_flow_rot{0};

	DEFINE_PARAMETERS(
		(ParamFloat<px4::params::BAT_CRIT_THR>)     _param_bat_crit_thr,
		(ParamFloat<px4::params::BAT_EMERGEN_THR>)  _param_bat_emergen_thr,
		(ParamFloat<px4::params::BAT_LOW_THR>)      _param_bat_low_thr
	);

	// Disallow copy construction and move assignment.
	MavlinkReceiver(const MavlinkReceiver &) = delete;
	MavlinkReceiver operator=(const MavlinkReceiver &) = delete;
};",1,587 2000 58 777 2001 123 777 58 2000 40 2002 42 2003 41 59 126 2000 40 41 2004 59 865 2005 40 41 59 865 2006 40 41 59 569 2007 40 704 2008 44 704 2009 41 59 865 2010 40 41 123 2011 61 829 59 125 865 2012 40 41 601 59 865 2013 40 41 123 2014 46 2015 40 829 41 59 125 773 58 809 865 42 2016 40 865 42 2017 41 59 865 2018 40 41 59 865 2019 40 2020 2021 44 2020 2022 44 2023 2024 44 2020 2025 44 2020 2026 61 1500 41 59 306 822 60 587 2027 62 865 2028 40 2029 42 2030 44 601 2027 38 2031 44 601 2032 38 2033 41 59 2020 2034 40 2023 2035 44 660 2036 61 1500 44 660 2037 61 1500 44 660 2038 61 1500 44 660 2039 61 1500 44 660 2040 61 1500 44 660 2041 61 1500 41 59 865 2042 40 2029 42 2030 41 59 865 2043 40 2029 42 2030 41 59 865 2044 40 2029 42 2030 41 59 865 2045 40 2029 42 2030 41 59 865 2046 40 2029 42 2030 41 59 865 2047 40 2029 42 2030 41 59 865 2048 40 2029 42 2030 41 59 865 2049 40 2029 42 2030 41 59 865 2050 40 2029 42 2030 41 59 865 2051 40 2029 42 2030 41 59 865 2052 40 2029 42 2030 41 59 865 2053 40 2029 42 2030 41 59 865 2054 40 2029 42 2030 41 59 865 2055 40 2029 42 2030 41 59 865 2056 40 2029 42 2030 41 59 865 2057 40 2029 42 2030 41 59 865 2058 40 2029 42 2030 41 59 865 2059 40 2029 42 2030 41 59 865 2060 40 2029 42 2030 41 59 865 2061 40 2029 42 2030 41 59 865 2062 40 2029 42 2030 41 59 865 2063 40 2029 42 2030 41 59 865 2064 40 2029 42 2030 41 59 865 2065 40 2029 42 2030 41 59 865 2066 40 2029 42 2030 41 59 865 2067 40 2029 42 2030 41 59 865 2068 40 2029 42 2030 41 59 865 2069 40 2029 42 2030 41 59 865 2070 40 2029 42 2030 41 59 865 2071 40 2029 42 2030 41 59 865 2072 40 2029 42 2030 41 59 865 2073 40 2029 42 2030 41 59 865 2074 40 2029 42 2030 41 59 865 2075 40 2029 42 2030 41 59 865 2076 40 2029 42 2030 41 59 865 2077 40 2029 42 2030 41 59 865 2078 40 2029 42 2030 41 59 865 2079 40 2029 42 2030 41 59 865 2080 40 2029 42 2030 41 59 865 2081 40 2029 42 2030 41 59 865 2082 40 2029 42 2030 41 59 865 2083 40 2029 42 2030 41 59 865 2084 40 2029 42 2030 41 59 865 2085 40 2029 42 2030 41 59 865 2086 40 2029 42 2030 41 59 865 2087 40 2029 42 2030 41 59 35 688 33 2088 40 2089 41 865 2090 40 2029 42 2030 41 59 865 2091 40 2029 42 2030 41 59 865 2092 40 2029 42 2030 41 59 865 2093 40 2029 42 2030 41 59 35 636 330 865 2094 40 2029 42 2030 41 59 865 2095 40 601 2096 38 2097 44 569 2098 61 655 41 59 306 704 2099 40 704 2100 44 660 2101 44 704 2102 61 45 1501 41 59 865 2103 40 704 2100 41 59 569 2104 40 704 2024 44 704 2105 44 704 2106 41 59 865 2107 40 660 42 2108 44 2020 2109 44 660 2110 41 59 865 2111 40 601 582 42 2112 41 59 865 2113 40 601 2029 38 2114 41 59 865 2115 40 601 2029 38 2114 41 59 2116 321 2117 2118 123 655 125 59 2119 2120 123 125 59 306 865 2121 40 41 2004 59 2002 42 2122 59 2123 2124 59 2125 2126 59 2127 2128 59 2129 2130 59 2131 2132 59 2133 2134 59 2135 2136 123 125 59 331 2137 2138 123 753 125 59 809 603 856 2139 123 1503 125 59 816 2140 123 2141 2142 123 1500 125 59 2141 2143 123 1500 125 59 2020 2008 123 1500 125 59 2020 2009 123 1500 125 59 2020 2144 123 1500 125 59 125 59 2140 2145 91 2139 93 123 125 59 856 2146 123 1500 125 59 569 2147 123 655 125 59 569 2148 123 655 125 59 35 688 33 2088 40 2089 41 809 603 704 2149 123 1503 125 59 816 2150 123 660 2151 123 1500 125 59 330 2152 2153 123 1500 125 59 2023 2154 123 1500 125 59 2020 2008 123 1500 125 59 2020 2009 123 1500 125 59 125 59 2150 42 2155 123 753 125 59 35 636 330 2156 2157 123 1500 125 59 331 2156 2158 123 1500 125 59 331 2020 2159 123 1500 125 59 2020 2160 123 1500 125 59 2023 2161 123 1500 125 59 330 2162 321 2163 60 2164 62 2165 91 1502 93 123 2166 40 2167 41 44 2166 40 2168 41 44 2166 40 2169 41 44 2166 40 2170 41 125 59 2162 321 2163 60 2171 62 2172 123 2173 40 2174 41 125 59 2162 321 2163 60 2175 62 2176 123 2177 40 2178 41 125 59 2162 321 2163 60 2179 62 2180 123 2181 40 2182 41 125 59 2162 321 2163 60 2183 62 2184 123 2185 40 2186 41 125 59 2162 321 2163 60 2187 62 2188 123 2189 40 2190 41 125 59 2162 321 2163 60 2191 62 2192 123 2193 40 2194 41 125 59 2162 321 2163 60 2195 62 2196 123 2197 40 2198 41 125 59 2162 321 2163 60 2199 62 2200 123 2201 40 2202 41 125 59 2162 321 2163 60 2203 62 2204 123 2205 40 2206 41 125 59 2162 321 2163 60 2207 62 2208 123 2209 40 2210 41 125 59 2162 321 2163 60 2211 62 2212 123 2213 40 2214 41 125 59 2162 321 2163 60 2215 62 2216 123 2217 40 2218 41 125 59 2162 321 2163 60 2219 62 2220 123 2221 40 2222 41 125 59 2162 321 2163 60 2223 62 2224 123 2225 40 2226 41 125 59 2162 321 2163 60 2227 62 2228 123 2229 40 2230 41 125 59 2162 321 2163 60 2231 62 2232 123 2233 40 2234 41 125 59 2162 321 2163 60 2235 62 2236 123 2237 40 2238 41 125 59 2162 321 2163 60 2239 62 2240 123 2241 40 2242 41 125 59 2162 321 2163 60 2243 62 2244 123 2245 40 2246 41 125 59 2162 321 2163 60 2247 62 2248 123 2249 40 2250 41 125 59 2162 321 2163 60 2251 62 2252 123 2253 40 2254 41 125 59 2162 321 2163 60 2251 62 2255 123 2256 40 2257 41 125 59 2162 321 2163 60 2251 62 2258 123 2259 40 2260 41 125 59 2162 321 2163 60 2261 62 2262 123 2263 40 2264 41 125 59 2162 321 2163 60 2265 62 2266 123 2267 40 2268 41 125 59 2162 321 2163 60 2269 62 2270 123 2271 40 2272 41 125 59 2162 321 2163 60 2273 62 2274 123 2275 40 2276 41 125 59 2162 321 2163 60 2277 62 2278 123 2279 40 2280 41 125 59 2162 321 2163 60 2277 62 2281 123 2282 40 2283 41 125 59 2162 321 2163 60 2284 62 2285 123 2286 40 2287 41 125 59 2162 321 2163 60 2288 62 2289 123 2290 40 2291 41 125 59 2162 321 2163 60 2292 62 2293 123 2294 40 2295 41 125 59 35 688 33 2088 40 2089 41 2162 321 2163 60 2296 62 2297 123 2298 40 2299 41 125 59 2162 321 2163 60 2300 62 2301 123 2302 40 2303 41 125 59 2162 321 2163 60 2304 62 2305 123 2306 40 2307 41 125 59 2162 321 2163 60 2308 62 2309 123 2310 40 2311 41 125 59 35 636 330 330 2162 321 2312 60 2313 62 2314 123 2315 40 2316 41 125 59 2162 321 2312 60 2313 62 2317 123 2318 40 2319 41 125 59 2162 321 2312 60 2320 62 2321 123 2322 40 2323 41 125 59 2162 321 2312 60 2324 62 2325 123 2326 40 2327 41 125 59 2162 321 2312 60 2328 62 2329 123 2330 40 2331 41 125 59 2162 321 2312 60 2332 62 2333 123 2334 40 2335 41 125 59 330 2162 321 2163 60 2336 62 2337 123 2338 40 2339 41 125 59 2162 321 2163 60 2340 62 2341 123 2342 40 2343 41 125 59 2162 321 2163 60 2032 62 2344 123 2345 40 2033 41 125 59 2162 321 2163 60 2346 62 2347 123 2348 40 2349 41 125 59 330 2162 321 2350 2351 123 2352 40 2353 41 125 59 2162 321 2350 2354 123 2355 40 2356 41 125 59 2162 321 2350 2357 123 2358 40 2359 41 125 59 2162 321 2350 2360 123 2361 40 2362 41 125 59 2162 321 2350 2363 123 2364 40 2365 41 125 59 2162 321 2350 2366 123 2367 40 2368 41 125 59 2162 321 2350 2369 123 2370 40 2371 41 125 59 2162 321 2350 2372 123 2373 40 2374 41 125 59 2162 321 2375 2376 123 2377 40 2378 41 44 1501 125 59 330 640 2379 123 2380 61 1500 44 2381 61 1500 44 2382 61 1500 44 2383 61 1500 44 2384 61 1500 125 59 2385 42 2386 123 753 125 59 2387 42 2388 123 753 125 59 2389 42 2390 123 753 125 59 2391 42 2392 123 753 125 59 660 2393 123 2394 125 59 2395 2396 123 125 59 2096 2397 123 1500 125 59 330 2398 42 2399 123 753 125 59 2096 2400 123 1500 125 59 2096 2401 123 1500 125 59 2096 2402 123 1500 125 59 2096 2403 123 1500 125 59 2096 2404 123 1500 125 59 2096 2405 123 1500 125 59 2096 2406 123 1500 125 59 2096 2407 123 1500 125 59 2096 2408 123 1500 125 59 2096 2409 123 1500 125 59 2096 2410 123 1500 125 59 2096 2411 123 1500 125 59 2096 2412 123 1500 125 59 2096 2413 123 1500 125 59 2096 2414 123 1500 125 59 2096 2415 123 1500 125 59 2416 2417 123 2418 125 59 2416 2419 123 2420 125 59 2416 2421 123 2422 125 59 2416 2423 123 2424 125 59 660 2425 123 45 1501 125 59 660 2426 123 45 1501 125 59 660 2427 123 45 1501 125 59 2428 2429 123 1500 125 59 2430 40 40 2431 60 2116 321 2432 321 2433 62 41 2434 44 40 2431 60 2116 321 2432 321 2435 62 41 2436 44 40 2431 60 2116 321 2432 321 2437 62 41 2438 41 59 330 2000 40 601 2000 38 41 61 619 59 2000 758 61 40 601 2000 38 41 61 619 59 125 59 ,"{'AvgLine': 45, 'CountLine': 3649, 'CountStmt': 861, 'MaxNesting': 7, 'AvgLineCode': 32, 'AvgEssential': 1, 'AvgLineBlank': 8, 'CountStmtExe': 439, 'MaxEssential': 15, 'SumEssential': 119, 'AvgCyclomatic': 4, 'CountLineCode': 2641, 'CountStmtDecl': 458, 'MaxCyclomatic': 33, 'SumCyclomatic': 311, 'AltAvgLineCode': 33, 'AvgLineComment': 3, 'CountClassBase': 1, 'CountLineBlank': 691, 'CountStmtEmpty': 7, 'AltAvgLineBlank': 8, 'CountDeclMethod': 77, 'AltCountLineCode': 2702, 'CountLineCodeExe': 382, 'CountLineComment': 286, 'AltAvgLineComment': 3, 'AltCountLineBlank': 705, 'CountClassCoupled': 27, 'CountClassDerived': 0, 'CountLineCodeDecl': 368, 'CountLineInactive': 53, 'CountDeclMethodAll': 86, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.11', 'AltCountLineComment': 292, 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 34, 'SumCyclomaticStrict': 325, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 4, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 62, 'CountLinePreprocessor': 29, 'MaxCyclomaticModified': 33, 'PercentLackOfCohesion': 99, 'SumCyclomaticModified': 311, 'CountDeclClassVariable': 2, 'CountDeclMethodPrivate': 14, 'CountDeclInstanceMethod': 76, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 112, 'CountDeclInstanceVariablePublic': 66, 'CountDeclInstanceVariablePrivate': 46, 'CountDeclInstanceVariableProtected': 0}"
117595,C++,"class MissionFeasibilityChecker
{
private:
	Navigator *_navigator{nullptr};

	/* Checks for all airframes */
	bool checkGeofence(const mission_s &mission, float home_alt, bool home_valid);

	bool checkHomePositionAltitude(const mission_s &mission, float home_alt, bool home_alt_valid);

	bool checkMissionItemValidity(const mission_s &mission);

	bool checkDistanceToFirstWaypoint(const mission_s &mission, float max_distance);
	bool checkDistancesBetweenWaypoints(const mission_s &mission, float max_distance);

	bool checkTakeoff(const mission_s &mission, float home_alt);

	/* Checks specific to fixedwing airframes */
	bool checkFixedwing(const mission_s &mission, float home_alt, bool land_start_req);
	bool checkFixedWingLanding(const mission_s &mission, bool land_start_req);

	/* Checks specific to rotarywing airframes */
	bool checkRotarywing(const mission_s &mission, float home_alt);

	/* Checks specific to VTOL airframes */
	bool checkVTOL(const mission_s &mission, float home_alt, bool land_start_req);
	bool checkVTOLLanding(const mission_s &mission, bool land_start_req);

public:
	MissionFeasibilityChecker(Navigator *navigator) : _navigator(navigator) {}
	~MissionFeasibilityChecker() = default;

	MissionFeasibilityChecker(const MissionFeasibilityChecker &) = delete;
	MissionFeasibilityChecker &operator=(const MissionFeasibilityChecker &) = delete;

	/*
	 * Returns true if mission is feasible and false otherwise
	 */
	bool checkMissionFeasible(const mission_s &mission,
				  float max_distance_to_1st_waypoint, float max_distance_between_waypoints,
				  bool land_start_req);

};",1,587 2000 123 773 58 2001 42 2002 123 753 125 59 305 569 2003 40 601 2004 38 2005 44 660 2006 44 569 2007 41 59 569 2008 40 601 2004 38 2005 44 660 2006 44 569 2009 41 59 569 2010 40 601 2004 38 2005 41 59 569 2011 40 601 2004 38 2005 44 660 2012 41 59 569 2013 40 601 2004 38 2005 44 660 2012 41 59 569 2014 40 601 2004 38 2005 44 660 2006 41 59 305 569 2015 40 601 2004 38 2005 44 660 2006 44 569 2016 41 59 569 2017 40 601 2004 38 2005 44 569 2016 41 59 305 569 2018 40 601 2004 38 2005 44 660 2006 41 59 305 569 2019 40 601 2004 38 2005 44 660 2006 44 569 2016 41 59 569 2020 40 601 2004 38 2005 44 569 2016 41 59 777 58 2000 40 2001 42 2021 41 58 2002 40 2021 41 123 125 126 2000 40 41 61 613 59 2000 40 601 2000 38 41 61 619 59 2000 38 758 61 40 601 2000 38 41 61 619 59 305 569 2022 40 601 2004 38 2005 44 660 2023 44 660 2024 44 569 2016 41 59 125 59 ,"{'AvgLine': 57, 'CountLine': 791, 'CountStmt': 150, 'MaxNesting': 4, 'AvgLineCode': 41, 'AvgEssential': 1, 'AvgLineBlank': 9, 'CountStmtExe': 77, 'MaxEssential': 7, 'SumEssential': 23, 'AvgCyclomatic': 3, 'CountLineCode': 556, 'CountStmtDecl': 76, 'MaxCyclomatic': 11, 'SumCyclomatic': 47, 'AltAvgLineCode': 41, 'AvgLineComment': 7, 'CountClassBase': 0, 'CountLineBlank': 136, 'CountStmtEmpty': 8, 'AltAvgLineBlank': 9, 'CountDeclMethod': 28, 'AltCountLineCode': 556, 'CountLineCodeExe': 84, 'CountLineComment': 99, 'AltAvgLineComment': 7, 'AltCountLineBlank': 136, 'CountClassCoupled': 4, 'CountClassDerived': 0, 'CountLineCodeDecl': 82, 'CountLineInactive': 0, 'CountDeclMethodAll': 28, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.18', 'AltCountLineComment': 99, 'AvgCyclomaticStrict': 6, 'MaxCyclomaticStrict': 39, 'SumCyclomaticStrict': 83, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 17, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 11, 'PercentLackOfCohesion': 78, 'SumCyclomaticModified': 47, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 11, 'CountDeclInstanceMethod': 28, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
100131,C++,"class JPIPKAKAsyncReader final: public GDALAsyncReader
{
private:
    void *pAppBuf;
    int  nAppPixelSpace, nAppLineSpace, nAppBandSpace;

    int nDataRead;
    int nLevel;
    int nQualityLayers;
    int bHighPriority;
    int bComplete;
    kdu_channel_mapping channels;
    kdu_coords exp_numerator, exp_denominator;

    kdu_dims rr_win; // user requested window expressed on reduced res level

    void Start();
    void Stop();

public:
    JPIPKAKAsyncReader();
    virtual ~JPIPKAKAsyncReader();

    virtual GDALAsyncStatusType GetNextUpdatedRegion(double timeout,
                                                     int* pnxbufoff,
                                                     int* pnybufoff,
                                                     int* pnxbufsize,
                                                     int* pnybufsize) override;
    void SetComplete(int bFinished){this->bComplete = bFinished;}

    friend class JPIPKAKDataset;

    CPLString  osErrorMsg;
};",1,587 2000 2001 58 777 2002 123 773 58 865 42 2003 59 704 2004 44 2005 44 2006 59 704 2007 59 704 2008 59 704 2009 59 704 2010 59 704 2011 59 2012 2013 59 2014 2015 44 2016 59 2017 2018 59 330 865 2019 40 41 59 865 2020 40 41 59 777 58 2000 40 41 59 864 126 2000 40 41 59 864 2021 2022 40 625 2023 44 704 42 2024 44 704 42 2025 44 704 42 2026 44 704 42 2027 41 2028 59 865 2029 40 704 2030 41 123 823 354 2011 61 2030 59 125 667 587 2031 59 2032 2033 59 125 59 ,"{'AvgLine': 79, 'CountLine': 511, 'CountStmt': 174, 'MaxNesting': 4, 'AvgLineCode': 58, 'AvgEssential': 2, 'AvgLineBlank': 11, 'CountStmtExe': 119, 'MaxEssential': 10, 'SumEssential': 15, 'AvgCyclomatic': 6, 'CountLineCode': 374, 'CountStmtDecl': 62, 'MaxCyclomatic': 21, 'SumCyclomatic': 38, 'AltAvgLineCode': 58, 'AvgLineComment': 10, 'CountClassBase': 1, 'CountLineBlank': 78, 'CountStmtEmpty': 2, 'AltAvgLineBlank': 11, 'CountDeclMethod': 6, 'AltCountLineCode': 374, 'CountLineCodeExe': 170, 'CountLineComment': 65, 'AltAvgLineComment': 10, 'AltCountLineBlank': 78, 'CountClassCoupled': 3, 'CountClassDerived': 0, 'CountLineCodeDecl': 50, 'CountLineInactive': 0, 'CountDeclMethodAll': 27, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.17', 'AltCountLineComment': 65, 'AvgCyclomaticStrict': 9, 'MaxCyclomaticStrict': 33, 'SumCyclomaticStrict': 56, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 6, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 21, 'PercentLackOfCohesion': 78, 'SumCyclomaticModified': 38, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 8, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 14, 'CountDeclInstanceVariablePublic': 5, 'CountDeclInstanceVariablePrivate': 9, 'CountDeclInstanceVariableProtected': 0}"
99389,C++,"class OGRGTMDataSource final: public OGRDataSource
{
public:

    // OGRDataSource Interface
    OGRGTMDataSource();
    ~OGRGTMDataSource();

    int Open( const char *pszFilename, int bUpdate );
    int Create( const char *pszFilename, char **papszOptions );

    const char* GetName() override { return pszName; }
    int GetLayerCount() override { return nLayers; }

    OGRLayer* GetLayer( int ) override;

    OGRLayer* ICreateLayer(const char *pszName,
                           OGRSpatialReference *poSpatialRef=nullptr,
                           OGRwkbGeometryType eGType=wkbUnknown,
                           char **papszOptions=nullptr) override;
    int TestCapability( const char * ) override;

    // OGRGTMDataSource Methods
    VSILFILE* getOutputFP() { return fpOutput; }
    VSILFILE* getTmpTrackpointsFP() { return fpTmpTrackpoints; }
    VSILFILE* getTmpTracksFP() { return fpTmpTracks; }
    bool isFirstCTError() { return !bIssuedCTError; }
    void issuedFirstCTError() { bIssuedCTError = true; }

    /* Functions to handle with waypoints */
    int getNWpts();
    bool hasNextWaypoint();
    Waypoint* fetchNextWaypoint();
    void rewindWaypoint();

    /* Functions to handle with tracks */
    int getNTracks();
    bool hasNextTrack();
    Track* fetchNextTrack();
    void rewindTrack();

    /* Functions for writing ne files */
    float getMinLat() { return minlat; }
    float getMaxLat() { return maxlat; }
    float getMinLon() { return minlon; }
    float getMaxLon() { return maxlon; }

    void checkBounds(float newLat,
                     float newLon);
    int getNumWaypoints() { return numWaypoints; }
    int getNumTrackpoints() { return numTrackpoints; }
    int getTracks() { return numTracks; }

    int incNumWaypoints() { return ++numWaypoints; }
    int incNumTrackpoints() { return ++numTrackpoints; }
    int incNumTracks() { return ++numTracks; }
private:
    VSILFILE* fpOutput;

    /* GTM is not a contiguous file. We need two temporary files because
       trackpoints and tracks are stored separated and we don't know in
       advance how many trackpoints and tracks the new file will
       have. So, we create temporary file and append at the end of
       the gtm file when everything is done, that is, in the
       destructor. */
    VSILFILE* fpTmpTrackpoints;
    char* pszTmpTrackpoints;

    VSILFILE* fpTmpTracks;
    char* pszTmpTracks;

    GTM* poGTMFile;
    char* pszName;

    OGRGTMLayer **papoLayers;
    int nLayers;

    bool bIssuedCTError;

    /* Used for creating a new file */
    float minlat;
    float maxlat;
    float minlon;
    float maxlon;

    int numWaypoints;
    int numTracks;
    int numTrackpoints;

    void AppendTemporaryFiles();
    void WriteWaypointStyles();
};",1,587 2000 2001 58 777 2002 123 777 58 330 2000 40 41 59 126 2000 40 41 59 704 2003 40 601 582 42 2004 44 704 2005 41 59 704 2006 40 601 582 42 2004 44 582 42 42 2007 41 59 601 582 42 2008 40 41 2009 123 792 2010 59 125 704 2011 40 41 2009 123 792 2012 59 125 2013 42 2014 40 704 41 2009 59 2013 42 2015 40 601 582 42 2016 44 2017 42 2018 61 753 44 2019 2020 61 2021 44 582 42 42 2007 61 753 41 2009 59 704 2022 40 601 582 42 41 2009 59 330 2023 42 2024 40 41 123 792 2025 59 125 2023 42 2026 40 41 123 792 2027 59 125 2023 42 2028 40 41 123 792 2029 59 125 569 2030 40 41 123 792 33 2031 59 125 865 2032 40 41 123 2033 61 829 59 125 305 704 2034 40 41 59 569 2035 40 41 59 2036 42 2037 40 41 59 865 2038 40 41 59 305 704 2039 40 41 59 569 2040 40 41 59 2041 42 2042 40 41 59 865 2043 40 41 59 305 660 2044 40 41 123 792 2045 59 125 660 2046 40 41 123 792 2047 59 125 660 2048 40 41 123 792 2049 59 125 660 2050 40 41 123 792 2051 59 125 865 2052 40 660 2053 44 660 2054 41 59 704 2055 40 41 123 792 2056 59 125 704 2057 40 41 123 792 2058 59 125 704 2059 40 41 123 792 2060 59 125 704 2061 40 41 123 792 349 2062 59 125 704 2063 40 41 123 792 349 2064 59 125 704 2065 40 41 123 792 349 2066 59 125 773 58 2023 42 2067 59 305 2023 42 2068 59 582 42 2069 59 2023 42 2070 59 582 42 2071 59 2072 42 2073 59 582 42 2016 59 2074 42 42 2075 59 704 2076 59 569 2077 59 305 660 2078 59 660 2079 59 660 2080 59 660 2081 59 704 2082 59 704 2083 59 704 2084 59 865 2085 40 41 59 865 2086 40 41 59 125 59 ,"{'AvgLine': 14, 'CountLine': 577, 'CountStmt': 312, 'MaxNesting': 3, 'AvgLineCode': 11, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 240, 'MaxEssential': 6, 'SumEssential': 49, 'AvgCyclomatic': 2, 'CountLineCode': 435, 'CountStmtDecl': 89, 'MaxCyclomatic': 8, 'SumCyclomatic': 79, 'AltAvgLineCode': 11, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 67, 'CountStmtEmpty': 3, 'AltAvgLineBlank': 1, 'CountDeclMethod': 35, 'AltCountLineCode': 435, 'CountLineCodeExe': 418, 'CountLineComment': 76, 'AltAvgLineComment': 1, 'AltCountLineBlank': 67, 'CountClassCoupled': 9, 'CountClassDerived': 0, 'CountLineCodeDecl': 79, 'CountLineInactive': 0, 'CountDeclMethodAll': 180, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.17', 'AltCountLineComment': 76, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 88, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 33, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 8, 'PercentLackOfCohesion': 86, 'SumCyclomaticModified': 79, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 36, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 17, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 17, 'CountDeclInstanceVariableProtected': 0}"
98573,C++,"class CPL_DLL OGRLayer : public GDALMajorObject
{
  private:
    struct Private;
    std::unique_ptr<Private> m_poPrivate;

    void         ConvertGeomsIfNecessary( OGRFeature *poFeature );

    class CPL_DLL FeatureIterator
    {
            struct Private;
            std::unique_ptr<Private> m_poPrivate;
        public:
            FeatureIterator(OGRLayer* poLayer, bool bStart);
            FeatureIterator(FeatureIterator&& oOther) noexcept; // declared but not defined. Needed for gcc 5.4 at least
            ~FeatureIterator();
            OGRFeatureUniquePtr& operator*();
            FeatureIterator& operator++();
            bool operator!=(const FeatureIterator& it) const;
    };

    friend inline FeatureIterator begin(OGRLayer* poLayer);
    friend inline FeatureIterator end(OGRLayer* poLayer);

    CPL_DISALLOW_COPY_ASSIGN(OGRLayer)

  protected:
//! @cond Doxygen_Suppress
    int          m_bFilterIsEnvelope;
    OGRGeometry *m_poFilterGeom;
    OGRPreparedGeometry *m_pPreparedFilterGeom; /* m_poFilterGeom compiled as a prepared geometry */
    OGREnvelope  m_sFilterEnvelope;
    int          m_iGeomFieldFilter; // specify the index on which the spatial
                                     // filter is active.

    int          FilterGeometry( OGRGeometry * );
    //int          FilterGeometry( OGRGeometry *, OGREnvelope* psGeometryEnvelope);
    int          InstallFilter( OGRGeometry * );

    OGRErr       GetExtentInternal(int iGeomField, OGREnvelope *psExtent, int bForce );
//! @endcond

    virtual OGRErr      ISetFeature( OGRFeature *poFeature ) CPL_WARN_UNUSED_RESULT;
    virtual OGRErr      ICreateFeature( OGRFeature *poFeature )  CPL_WARN_UNUSED_RESULT;

  public:
    OGRLayer();
    virtual     ~OGRLayer();

    /** Return begin of feature iterator.
     *
     * Using this iterator for standard range-based loops is safe, but
     * due to implementation limitations, you shouldn't try to access
     * (dereference) more than one iterator step at a time, since the
     * OGRFeatureUniquePtr reference is reused.
     *
     * Only one iterator per layer can be active at a time.
     * @since GDAL 2.3
     */
    FeatureIterator begin();

    /** Return end of feature iterator. */
    FeatureIterator end();

    virtual OGRGeometry *GetSpatialFilter();
    virtual void        SetSpatialFilter( OGRGeometry * );
    virtual void        SetSpatialFilterRect( double dfMinX, double dfMinY,
                                              double dfMaxX, double dfMaxY );

    virtual void        SetSpatialFilter( int iGeomField, OGRGeometry * );
    virtual void        SetSpatialFilterRect( int iGeomField,
                                            double dfMinX, double dfMinY,
                                            double dfMaxX, double dfMaxY );

    virtual OGRErr      SetAttributeFilter( const char * );

    virtual void        ResetReading() = 0;
    virtual OGRFeature *GetNextFeature() CPL_WARN_UNUSED_RESULT = 0;
    virtual OGRErr      SetNextByIndex( GIntBig nIndex );
    virtual OGRFeature *GetFeature( GIntBig nFID )  CPL_WARN_UNUSED_RESULT;

    OGRErr      SetFeature( OGRFeature *poFeature )  CPL_WARN_UNUSED_RESULT;
    OGRErr      CreateFeature( OGRFeature *poFeature ) CPL_WARN_UNUSED_RESULT;

    virtual OGRErr      DeleteFeature( GIntBig nFID )  CPL_WARN_UNUSED_RESULT;

    virtual const char *GetName();
    virtual OGRwkbGeometryType GetGeomType();
    virtual OGRFeatureDefn *GetLayerDefn() = 0;
    virtual int         FindFieldIndex( const char *pszFieldName, int bExactMatch );

    virtual OGRSpatialReference *GetSpatialRef();

    virtual GIntBig     GetFeatureCount( int bForce = TRUE );
    virtual OGRErr      GetExtent(OGREnvelope *psExtent, int bForce = TRUE)  CPL_WARN_UNUSED_RESULT;
    virtual OGRErr      GetExtent(int iGeomField, OGREnvelope *psExtent,
                                  int bForce = TRUE)  CPL_WARN_UNUSED_RESULT;

    virtual int         TestCapability( const char * ) = 0;

    virtual OGRErr      CreateField( OGRFieldDefn *poField,
                                     int bApproxOK = TRUE );
    virtual OGRErr      DeleteField( int iField );
    virtual OGRErr      ReorderFields( int* panMap );
    virtual OGRErr      AlterFieldDefn( int iField, OGRFieldDefn* poNewFieldDefn, int nFlagsIn );

    virtual OGRErr      CreateGeomField( OGRGeomFieldDefn *poField,
                                     int bApproxOK = TRUE );

    virtual OGRErr      SyncToDisk();

    virtual OGRStyleTable *GetStyleTable();
    virtual void        SetStyleTableDirectly( OGRStyleTable *poStyleTable );

    virtual void        SetStyleTable(OGRStyleTable *poStyleTable);

    virtual OGRErr      StartTransaction() CPL_WARN_UNUSED_RESULT;
    virtual OGRErr      CommitTransaction() CPL_WARN_UNUSED_RESULT;
    virtual OGRErr      RollbackTransaction();

    virtual const char *GetFIDColumn();
    virtual const char *GetGeometryColumn();

    virtual OGRErr      SetIgnoredFields( const char **papszFields );

    OGRErr              Intersection( OGRLayer *pLayerMethod,
                                      OGRLayer *pLayerResult,
                                      char** papszOptions = nullptr,
                                      GDALProgressFunc pfnProgress = nullptr,
                                      void * pProgressArg = nullptr );
    OGRErr              Union( OGRLayer *pLayerMethod,
                               OGRLayer *pLayerResult,
                               char** papszOptions = nullptr,
                               GDALProgressFunc pfnProgress = nullptr,
                               void * pProgressArg = nullptr );
    OGRErr              SymDifference( OGRLayer *pLayerMethod,
                                       OGRLayer *pLayerResult,
                                       char** papszOptions,
                                       GDALProgressFunc pfnProgress,
                                       void * pProgressArg );
    OGRErr              Identity( OGRLayer *pLayerMethod,
                                  OGRLayer *pLayerResult,
                                  char** papszOptions = nullptr,
                                  GDALProgressFunc pfnProgress = nullptr,
                                  void * pProgressArg = nullptr );
    OGRErr              Update( OGRLayer *pLayerMethod,
                                OGRLayer *pLayerResult,
                                char** papszOptions = nullptr,
                                GDALProgressFunc pfnProgress = nullptr,
                                void * pProgressArg = nullptr );
    OGRErr              Clip( OGRLayer *pLayerMethod,
                              OGRLayer *pLayerResult,
                              char** papszOptions = nullptr,
                              GDALProgressFunc pfnProgress = nullptr,
                              void * pProgressArg = nullptr );
    OGRErr              Erase( OGRLayer *pLayerMethod,
                               OGRLayer *pLayerResult,
                               char** papszOptions = nullptr,
                               GDALProgressFunc pfnProgress = nullptr,
                               void * pProgressArg = nullptr );

    int                 Reference();
    int                 Dereference();
    int                 GetRefCount() const;
//! @cond Doxygen_Suppress
    GIntBig             GetFeaturesRead();
//! @endcond

    /* non virtual : convenience wrapper for ReorderFields() */
    OGRErr              ReorderField( int iOldFieldPos, int iNewFieldPos );

//! @cond Doxygen_Suppress
    int                 AttributeFilterEvaluationNeedsGeometry();

    /* consider these private */
    OGRErr               InitializeIndexSupport( const char * );
    OGRLayerAttrIndex   *GetIndex() { return m_poAttrIndex; }
    int                 GetGeomFieldFilter() const { return m_iGeomFieldFilter; }
    const char          *GetAttrQueryString() const { return m_pszAttrQueryString; }
//! @endcond

    /** Convert a OGRLayer* to a OGRLayerH.
     * @since GDAL 2.3
     */
    static inline OGRLayerH ToHandle(OGRLayer* poLayer)
        { return reinterpret_cast<OGRLayerH>(poLayer); }

    /** Convert a OGRLayerH to a OGRLayer*.
     * @since GDAL 2.3
     */
    static inline OGRLayer* FromHandle(OGRLayerH hLayer)
        { return reinterpret_cast<OGRLayer*>(hLayer); }

 protected:
//! @cond Doxygen_Suppress
    OGRStyleTable       *m_poStyleTable;
    OGRFeatureQuery     *m_poAttrQuery;
    char                *m_pszAttrQueryString;
    OGRLayerAttrIndex   *m_poAttrIndex;

    int                  m_nRefCount;

    GIntBig              m_nFeaturesRead;
//! @endcond
};",1,587 2000 2001 58 777 2002 123 773 58 816 2003 59 2004 321 2005 60 2003 62 2006 59 865 2007 40 2008 42 2009 41 59 587 2000 2010 123 816 2003 59 2004 321 2005 60 2003 62 2006 59 777 58 2010 40 2001 42 2011 44 569 2012 41 59 2010 40 2010 307 2013 41 748 59 330 126 2010 40 41 59 2014 38 758 42 40 41 59 2010 38 758 349 40 41 59 569 758 340 40 601 2010 38 2015 41 601 59 125 59 667 700 2010 2016 40 2001 42 2017 41 59 667 700 2010 2018 40 2001 42 2017 41 59 2019 40 2001 41 775 58 330 704 2020 59 2021 42 2022 59 2023 42 2024 59 305 2025 2026 59 704 2027 59 330 330 704 2028 40 2021 42 41 59 330 704 2029 40 2021 42 41 59 2030 2031 40 704 2032 44 2025 42 2033 44 704 2034 41 59 330 864 2030 2035 40 2008 42 2009 41 2036 59 864 2030 2037 40 2008 42 2009 41 2036 59 777 58 2001 40 41 59 864 126 2001 40 41 59 306 2010 2016 40 41 59 306 2010 2018 40 41 59 864 2021 42 2038 40 41 59 864 865 2039 40 2021 42 41 59 864 865 2040 40 625 2041 44 625 2042 44 625 2043 44 625 2044 41 59 864 865 2039 40 704 2032 44 2021 42 41 59 864 865 2040 40 704 2032 44 625 2041 44 625 2042 44 625 2043 44 625 2044 41 59 864 2030 2045 40 601 582 42 41 59 864 865 2046 40 41 61 1500 59 864 2008 42 2047 40 41 2036 61 1500 59 864 2030 2048 40 2049 2050 41 59 864 2008 42 2051 40 2049 2052 41 2036 59 2030 2053 40 2008 42 2009 41 2036 59 2030 2054 40 2008 42 2009 41 2036 59 864 2030 2055 40 2049 2052 41 2036 59 864 601 582 42 2056 40 41 59 864 2057 2058 40 41 59 864 2059 42 2060 40 41 61 1500 59 864 704 2061 40 601 582 42 2062 44 704 2063 41 59 864 2064 42 2065 40 41 59 864 2049 2066 40 704 2034 61 2067 41 59 864 2030 2068 40 2025 42 2033 44 704 2034 61 2067 41 2036 59 864 2030 2068 40 704 2032 44 2025 42 2033 44 704 2034 61 2067 41 2036 59 864 704 2069 40 601 582 42 41 61 1500 59 864 2030 2070 40 2071 42 2072 44 704 2073 61 2067 41 59 864 2030 2074 40 704 2075 41 59 864 2030 2076 40 704 42 2077 41 59 864 2030 2078 40 704 2075 44 2071 42 2079 44 704 2080 41 59 864 2030 2081 40 2082 42 2072 44 704 2073 61 2067 41 59 864 2030 2083 40 41 59 864 2084 42 2085 40 41 59 864 865 2086 40 2084 42 2087 41 59 864 865 2088 40 2084 42 2087 41 59 864 2030 2089 40 41 2036 59 864 2030 2090 40 41 2036 59 864 2030 2091 40 41 59 864 601 582 42 2092 40 41 59 864 601 582 42 2093 40 41 59 864 2030 2094 40 601 582 42 42 2095 41 59 2030 2096 40 2001 42 2097 44 2001 42 2098 44 582 42 42 2099 61 753 44 2100 2101 61 753 44 865 42 2102 61 753 41 59 2030 2103 40 2001 42 2097 44 2001 42 2098 44 582 42 42 2099 61 753 44 2100 2101 61 753 44 865 42 2102 61 753 41 59 2030 2104 40 2001 42 2097 44 2001 42 2098 44 582 42 42 2099 44 2100 2101 44 865 42 2102 41 59 2030 2105 40 2001 42 2097 44 2001 42 2098 44 582 42 42 2099 61 753 44 2100 2101 61 753 44 865 42 2102 61 753 41 59 2030 2106 40 2001 42 2097 44 2001 42 2098 44 582 42 42 2099 61 753 44 2100 2101 61 753 44 865 42 2102 61 753 41 59 2030 2107 40 2001 42 2097 44 2001 42 2098 44 582 42 42 2099 61 753 44 2100 2101 61 753 44 865 42 2102 61 753 41 59 2030 2108 40 2001 42 2097 44 2001 42 2098 44 582 42 42 2099 61 753 44 2100 2101 61 753 44 865 42 2102 61 753 41 59 704 2109 40 41 59 704 2110 40 41 59 704 2111 40 41 601 59 330 2049 2112 40 41 59 330 305 2030 2113 40 704 2114 44 704 2115 41 59 330 704 2116 40 41 59 305 2030 2117 40 601 582 42 41 59 2118 42 2119 40 41 123 792 2120 59 125 704 2121 40 41 601 123 792 2027 59 125 601 582 42 2122 40 41 601 123 792 2123 59 125 330 306 809 700 2124 2125 40 2001 42 2017 41 123 792 786 60 2124 62 40 2017 41 59 125 306 809 700 2001 42 2126 40 2124 2127 41 123 792 786 60 2001 42 62 40 2127 41 59 125 775 58 330 2084 42 2128 59 2129 42 2130 59 582 42 2131 59 2118 42 2132 59 704 2133 59 2049 2134 59 330 125 59 ,"{'AvgLine': 33, 'CountLine': 2281, 'CountStmt': 1276, 'MaxNesting': 5, 'AvgLineCode': 28, 'AvgEssential': 4, 'AvgLineBlank': 3, 'CountStmtExe': 1027, 'MaxEssential': 45, 'SumEssential': 295, 'AvgCyclomatic': 6, 'CountLineCode': 1905, 'CountStmtDecl': 387, 'MaxCyclomatic': 56, 'SumCyclomatic': 405, 'AltAvgLineCode': 28, 'AvgLineComment': 2, 'CountClassBase': 1, 'CountLineBlank': 231, 'CountStmtEmpty': 4, 'AltAvgLineBlank': 3, 'CountDeclMethod': 68, 'AltCountLineCode': 1905, 'CountLineCodeExe': 1059, 'CountLineComment': 161, 'AltAvgLineComment': 2, 'AltCountLineBlank': 231, 'CountClassCoupled': 20, 'CountClassDerived': 120, 'CountLineCodeDecl': 311, 'CountLineInactive': 0, 'CountDeclMethodAll': 82, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.08', 'AltCountLineComment': 161, 'AvgCyclomaticStrict': 7, 'MaxCyclomaticStrict': 57, 'SumCyclomaticStrict': 451, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 3, 'AvgCyclomaticModified': 6, 'CountDeclMethodFriend': 2, 'CountDeclMethodPublic': 60, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 56, 'PercentLackOfCohesion': 94, 'SumCyclomaticModified': 404, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 3, 'CountDeclInstanceMethod': 66, 'CountDeclMethodProtected': 5, 'CountDeclInstanceVariable': 12, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 10}"
