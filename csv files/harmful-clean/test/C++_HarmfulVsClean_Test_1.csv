id,language,text,smell,tokens,metrics
98770,C++,"class GDALAntiRecursionGuard
{
    GDALAntiRecursionStruct* m_psAntiRecursionStruct;
    std::string m_osIdentifier;
    int m_nDepth;

    GDALAntiRecursionGuard(const GDALAntiRecursionGuard&) = delete;
    GDALAntiRecursionGuard& operator= (const GDALAntiRecursionGuard&) = delete;

public:
    explicit GDALAntiRecursionGuard(const std::string& osIdentifier);
             GDALAntiRecursionGuard(const GDALAntiRecursionGuard& other, const std::string& osIdentifier);
    ~GDALAntiRecursionGuard();
    int GetCallDepth() const { return m_nDepth; }
};",0,587 2000 123 2001 42 2002 59 2003 321 2004 2005 59 704 2006 59 2000 40 601 2000 38 41 61 619 59 2000 38 758 61 40 601 2000 38 41 61 619 59 777 58 648 2000 40 601 2003 321 2004 38 2007 41 59 2000 40 601 2000 38 2008 44 601 2003 321 2004 38 2007 41 59 126 2000 40 41 59 704 2009 40 41 601 123 792 2006 59 125 125 59 ,"{'AvgLine': 5, 'CountLine': 35, 'CountStmt': 17, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 4, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 33, 'CountStmtDecl': 12, 'MaxCyclomatic': 2, 'SumCyclomatic': 5, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 2, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 0, 'CountDeclMethod': 6, 'AltCountLineCode': 33, 'CountLineCodeExe': 9, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 5, 'CountLineInactive': 0, 'CountDeclMethodAll': 6, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 5, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 50, 'SumCyclomaticModified': 5, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
99109,C++,"class GDALPDFObjectNum
{
        int m_nId;

    public:
        explicit GDALPDFObjectNum(int nId = 0): m_nId(nId) {}
        GDALPDFObjectNum(const GDALPDFObjectNum& other) = default;
        GDALPDFObjectNum& operator=(const GDALPDFObjectNum&) = default;
        GDALPDFObjectNum& operator=(int nId) { m_nId = nId; return *this; }

        int toInt() const { return m_nId; }
        bool toBool() const { return m_nId > 0; }
        bool operator==(const GDALPDFObjectNum& other) const { return m_nId == other.m_nId; }
        bool operator<(const GDALPDFObjectNum& other) const { return m_nId < other.m_nId; }
};",0,587 2000 123 704 2001 59 777 58 648 2000 40 704 2002 61 1500 41 58 2001 40 2002 41 123 125 2000 40 601 2000 38 2003 41 61 613 59 2000 38 758 61 40 601 2000 38 41 61 613 59 2000 38 758 61 40 704 2002 41 123 2001 61 2002 59 792 42 823 59 125 704 2004 40 41 601 123 792 2001 59 125 569 2005 40 41 601 123 792 2001 62 1500 59 125 569 758 323 40 601 2000 38 2003 41 601 123 792 2001 323 2003 46 2001 59 125 569 758 60 40 601 2000 38 2003 41 601 123 792 2001 60 2003 46 2001 59 125 125 59 ,"{'AvgLine': 1, 'CountLine': 13, 'CountStmt': 14, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 6, 'MaxEssential': 1, 'SumEssential': 6, 'AvgCyclomatic': 1, 'CountLineCode': 11, 'CountStmtDecl': 8, 'MaxCyclomatic': 1, 'SumCyclomatic': 6, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 8, 'AltCountLineCode': 11, 'CountLineCodeExe': 6, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 7, 'CountLineInactive': 0, 'CountDeclMethodAll': 8, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 6, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 4, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 8, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 11, 'SumCyclomaticModified': 6, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 9, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98796,C++,"template <class Key, class Value, class Lock = NullLock,
          class Map = std::unordered_map<
              Key, typename std::list<KeyValuePair<Key, Value>>::iterator>>
class Cache {
 public:
  typedef KeyValuePair<Key, Value> node_type;
  typedef std::list<KeyValuePair<Key, Value>> list_type;
  typedef Map map_type;
  typedef Lock lock_type;
  using Guard = std::lock_guard<lock_type>;
  /**
   * the max size is the hard limit of keys and (maxSize + elasticity) is the
   * soft limit
   * the cache is allowed to grow till maxSize + elasticity and is pruned back
   * to maxSize keys
   * set maxSize = 0 for an unbounded cache (but in that case, you're better off
   * using a std::unordered_map
   * directly anyway! :)
   */
  explicit Cache(size_t maxSize = 64, size_t elasticity = 10)
      : maxSize_(maxSize), elasticity_(elasticity) {}
  virtual ~Cache() = default;
  size_t size() const {
    Guard g(lock_);
    return cache_.size();
  }
  bool empty() const {
    Guard g(lock_);
    return cache_.empty();
  }
  void clear() {
    Guard g(lock_);
    cache_.clear();
    keys_.clear();
  }
  void insert(const Key& k, const Value& v) {
    Guard g(lock_);
    const auto iter = cache_.find(k);
    if (iter != cache_.end()) {
      iter->second->value = v;
      keys_.splice(keys_.begin(), keys_, iter->second);
      return;
    }

    keys_.emplace_front(k, v);
    cache_[k] = keys_.begin();
    prune();
  }
  bool tryGet(const Key& kIn, Value& vOut) {
    Guard g(lock_);
    const auto iter = cache_.find(kIn);
    if (iter == cache_.end()) {
      return false;
    }
    keys_.splice(keys_.begin(), keys_, iter->second);
    vOut = iter->second->value;
    return true;
  }
  /**
   *	The const reference returned here is only
   *    guaranteed to be valid till the next insert/delete
   */
  const Value& get(const Key& k) {
    Guard g(lock_);
    const auto iter = cache_.find(k);
    if (iter == cache_.end()) {
      throw KeyNotFound();
    }
    keys_.splice(keys_.begin(), keys_, iter->second);
    return iter->second->value;
  }
  /**
   * returns a copy of the stored object (if found)
   */
  Value getCopy(const Key& k) {
   return get(k);
  }
  bool remove(const Key& k) {
    Guard g(lock_);
    auto iter = cache_.find(k);
    if (iter == cache_.end()) {
      return false;
    }
    keys_.erase(iter->second);
    cache_.erase(iter);
    return true;
  }
  bool contains(const Key& k) {
    Guard g(lock_);
    return cache_.find(k) != cache_.end();
  }

  bool getOldestEntry(Key& kOut, Value& vOut) {
    Guard g(lock_);
    if( keys_.empty() ) {
        return false;
    }
    kOut = keys_.back().key;
    vOut = keys_.back().value;
    return true;
  }

  size_t getMaxSize() const { return maxSize_; }
  size_t getElasticity() const { return elasticity_; }
  size_t getMaxAllowedSize() const { return maxSize_ + elasticity_; }
  template <typename F>
  void cwalk(F& f) const {
    Guard g(lock_);
    std::for_each(keys_.begin(), keys_.end(), f);
  }

  Cache(Cache&& other):
    cache_(std::move(other.cache_)),
    keys_(std::move(other.keys_)),
    maxSize_(other.maxSize_),
    elasticity_(other.elasticity_) {}

 protected:
  size_t prune() {
    size_t maxAllowed = maxSize_ + elasticity_;
    if (maxSize_ == 0 || cache_.size() <= maxAllowed) { /* ERO: changed < to <= */
      return 0;
    }
    size_t count = 0;
    while (cache_.size() > maxSize_) {
      cache_.erase(keys_.back().key);
      keys_.pop_back();
      ++count;
    }
    return count;
  }

 private:
  // Disallow copying.
  Cache(const Cache&) = delete;
  Cache& operator=(const Cache&) = delete;

  mutable Lock lock_{};
  Map cache_{};
  list_type keys_{};
  size_t maxSize_;
  size_t elasticity_;
};",0,822 60 587 2000 44 587 2001 44 587 2002 61 2003 44 587 2004 61 2005 321 2006 60 2000 44 835 2005 321 2007 60 2008 60 2000 44 2001 355 321 2009 355 587 2010 123 777 58 833 2008 60 2000 44 2001 62 2011 59 833 2005 321 2007 60 2008 60 2000 44 2001 355 2012 59 833 2004 2013 59 833 2002 2014 59 860 2015 61 2005 321 2016 60 2014 62 59 306 648 2010 40 2017 2018 61 1503 44 2017 2019 61 1502 41 58 2020 40 2018 41 44 2021 40 2019 41 123 125 864 126 2010 40 41 61 613 59 2017 2022 40 41 601 123 2015 2023 40 2024 41 59 792 2025 46 2022 40 41 59 125 569 2026 40 41 601 123 2015 2027 40 2028 41 59 792 2029 46 2026 40 41 59 125 865 2030 40 41 123 2015 2031 40 2032 41 59 2033 46 2030 40 41 59 2034 46 2030 40 41 59 125 865 2035 40 601 2000 38 2036 44 601 2001 38 2037 41 123 2015 2038 40 2039 41 59 601 561 2040 61 2041 46 2042 40 2036 41 59 688 40 2040 340 2041 46 2043 40 41 41 123 2040 354 2044 354 2045 61 2037 59 2046 46 2047 40 2046 46 2048 40 41 44 2046 44 2040 354 2044 41 59 792 59 125 2049 46 2050 40 2036 44 2037 41 59 2041 91 2036 93 61 2049 46 2051 40 41 59 2052 40 41 59 125 569 2053 40 601 2000 38 2054 44 2001 38 2055 41 123 2015 2056 40 2057 41 59 601 561 2058 61 2059 46 2060 40 2054 41 59 688 40 2058 323 2059 46 2061 40 41 41 123 792 655 59 125 2062 46 2063 40 2062 46 2064 40 41 44 2062 44 2058 354 2065 41 59 2055 61 2058 354 2065 354 2066 59 792 829 59 125 306 601 2001 38 2067 40 601 2000 38 2036 41 123 2015 2068 40 2069 41 59 601 561 2070 61 2071 46 2072 40 2036 41 59 688 40 2070 323 2071 46 2073 40 41 41 123 825 2074 40 41 59 125 2075 46 2076 40 2075 46 2077 40 41 44 2075 44 2070 354 2078 41 59 792 2070 354 2078 354 2079 59 125 306 2001 2080 40 601 2000 38 2036 41 123 792 2067 40 2036 41 59 125 569 2081 40 601 2000 38 2036 41 123 2015 2082 40 2083 41 59 561 2084 61 2085 46 2086 40 2036 41 59 688 40 2084 323 2085 46 2087 40 41 41 123 792 655 59 125 2088 46 2089 40 2084 354 2090 41 59 2085 46 2089 40 2084 41 59 792 829 59 125 569 2091 40 601 2000 38 2036 41 123 2015 2092 40 2093 41 59 792 2094 46 2095 40 2036 41 340 2094 46 2096 40 41 59 125 569 2097 40 2000 38 2098 44 2001 38 2055 41 123 2015 2099 40 2100 41 59 688 40 2101 46 2026 40 41 41 123 792 655 59 125 2098 61 2101 46 2102 40 41 46 2103 59 2055 61 2101 46 2102 40 41 46 2104 59 792 829 59 125 2017 2105 40 41 601 123 792 2020 59 125 2017 2106 40 41 601 123 792 2021 59 125 2017 2107 40 41 601 123 792 2020 43 2021 59 125 822 60 835 2108 62 865 2109 40 2108 38 2110 41 601 123 2015 2111 40 2112 41 59 2005 321 2113 40 2114 46 2115 40 41 44 2114 46 2116 40 41 44 2110 41 59 125 2010 40 2010 307 2117 41 58 2118 40 2005 321 2119 40 2117 46 2118 41 41 44 2120 40 2005 321 2119 40 2117 46 2120 41 41 44 2020 40 2117 46 2020 41 44 2021 40 2117 46 2021 41 123 125 775 58 2017 2121 40 41 123 2017 2122 61 2020 43 2021 59 688 40 2020 323 1500 309 2118 46 2022 40 41 329 2122 41 123 305 792 1500 59 125 2017 2123 61 1500 59 870 40 2118 46 2022 40 41 62 2020 41 123 2118 46 2124 40 2120 46 2125 40 41 46 2126 41 59 2120 46 2127 40 41 59 349 2123 59 125 792 2123 59 125 773 58 330 2010 40 601 2010 38 41 61 619 59 2010 38 758 61 40 601 2010 38 41 61 619 59 740 2002 2128 123 125 59 2004 2118 123 125 59 2012 2120 123 125 59 2017 2020 59 2017 2021 59 125 59 ,"{'AvgLine': 5, 'CountLine': 140, 'CountStmt': 93, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 43, 'MaxEssential': 1, 'SumEssential': 17, 'AvgCyclomatic': 1, 'CountLineCode': 116, 'CountStmtDecl': 50, 'MaxCyclomatic': 3, 'SumCyclomatic': 24, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 7, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 20, 'AltCountLineCode': 116, 'CountLineCodeExe': 65, 'CountLineComment': 18, 'AltAvgLineComment': 0, 'AltCountLineBlank': 7, 'CountClassCoupled': 3, 'CountClassDerived': 0, 'CountLineCodeDecl': 34, 'CountLineInactive': 0, 'CountDeclMethodAll': 20, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.16', 'AltCountLineComment': 18, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 4, 'SumCyclomaticStrict': 25, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 6, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 17, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 61, 'SumCyclomaticModified': 24, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 20, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 5, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 5, 'CountDeclInstanceVariableProtected': 0}"
98936,C++,"template <typename PolygonWriter>
class PolygonRingAppender
{
private:
    struct Ring
    {
        Ring() : points(), interiorRings() {}
        Ring( const Ring& other ) = default;
        Ring& operator=( const Ring& other ) = default;

        LineString points;

        mutable std::vector<Ring> interiorRings;

        const Ring* closestExterior = nullptr;

        bool isIn( const Ring& other ) const
        {
            // Check if this is inside other using the winding number algorithm
            auto checkPoint = this->points.front();
            int windingNum = 0;
            auto otherIter = other.points.begin();
            // p1 and p2 define each segment of the ring other that will be tested
            auto p1 = *otherIter;
            while(true) {
                otherIter++;
                if (otherIter == other.points.end()) {
                    break;
                }
                auto p2 = *otherIter;
                if ( p1.y <= checkPoint.y ) {
                    if ( p2.y  > checkPoint.y ) {
                        if ( isLeft(p1, p2, checkPoint) )  {
                             ++windingNum;
                        }
                    }
                } else {
                    if ( p2.y <= checkPoint.y ) {
                        if ( !isLeft( p1, p2, checkPoint)  ) {
                            --windingNum;
                        }
                    }
                }
                p1 = p2;
            }
            return windingNum != 0;
        }

#ifdef DEBUG
        size_t id() const
        {
            return size_t(static_cast<const void*>(this)) & 0xffff;
        }

        void print( std::ostream& ostr ) const
        {
            ostr << id() << "":"";
            for ( const auto& pt : points ) {
                ostr << pt.x << "","" << pt.y << "" "";
            }
        }
#endif
    };

    void processTree(const std::vector<Ring> &tree, int level) {
        if ( level % 2 == 0 ) {
            for( auto &r: tree ) {
                writer_.addPart(r.points);
                for( auto &innerRing: r.interiorRings ) {
                    writer_.addInteriorRing(innerRing.points);
                }
            }
        }
        for( auto &r: tree ) {
            processTree(r.interiorRings, level + 1);
        }
    }

    // level -> rings
    std::map<double, std::vector<Ring>> rings_;

    PolygonWriter& writer_;

public:
    const bool polygonize = true;

    PolygonRingAppender( PolygonWriter& writer )
        : rings_()
        , writer_( writer )
    {}

    void addLine( double level, LineString& ls, bool )
    {
        // Create a new ring from the LineString
        Ring newRing;
        newRing.points.swap( ls );
        auto &levelRings = rings_[level];
        // This queue holds the rings to be checked
        std::deque<Ring*> queue;
        std::transform(levelRings.begin(),
                       levelRings.end(),
                       std::back_inserter(queue),
                       [](Ring &r) {
                           return &r;
                       });
        Ring *parentRing = nullptr;
        while( !queue.empty() ) {
            Ring *curRing = queue.front();
            queue.pop_front();
            if ( newRing.isIn(*curRing) ) {
                // We know that there should only be one ring per level that we should fit in,
                // so we can discard the rest of the queue and try again with the children of this ring
                parentRing = curRing;
                queue.clear();
                std::transform(curRing->interiorRings.begin(),
                            curRing->interiorRings.end(),
                            std::back_inserter(queue),
                            [](Ring &r) {
                                return &r;
                            });
            }
        }
        // Get a pointer to the list we need to check for rings to include in this ring
        std::vector<Ring> *parentRingList;
        if ( parentRing == nullptr ) {
            parentRingList = &levelRings;
        } else {
            parentRingList = &(parentRing->interiorRings);
        }
        // We found a valid parent, so we need to:
        // 1. Find all the inner rings of the parent that are inside the new ring
        auto trueGroupIt = std::partition(
            parentRingList->begin(),
            parentRingList->end(),
            [newRing](Ring &pRing) {
                return !pRing.isIn(newRing);
            }
        );
        // 2. Move those rings out of the parent and into the new ring's interior rings
        std::move(trueGroupIt, parentRingList->end(), std::back_inserter(newRing.interiorRings));
        // 3. Get rid of the moved-from elements in the parent's interior rings
        parentRingList->erase(trueGroupIt, parentRingList->end());
        // 4. Add the new ring to the parent's interior rings
        parentRingList->push_back(newRing);
    }

    ~PolygonRingAppender()
    {
        // If there's no rings, nothing to do here
        if ( rings_.size() == 0 )
            return;

        // Traverse tree of rings
        for ( auto& r: rings_ ) {
            // For each level, create a multipolygon by traversing the tree of
            // rings and adding a part for every other level
            writer_.startPolygon( r.first );
            processTree(r.second, 0);
            writer_.endPolygon();
        }
    }
};",0,822 60 835 2000 62 587 2001 123 773 58 816 2002 123 2002 40 41 58 2003 40 41 44 2004 40 41 123 125 2002 40 601 2002 38 2005 41 61 613 59 2002 38 758 61 40 601 2002 38 2005 41 61 613 59 2006 2003 59 740 2007 321 2008 60 2002 62 2004 59 601 2002 42 2009 61 753 59 569 2010 40 601 2002 38 2005 41 601 123 330 561 2011 61 823 354 2003 46 2012 40 41 59 704 2013 61 1500 59 561 2014 61 2005 46 2003 46 2015 40 41 59 330 561 2016 61 42 2014 59 870 40 829 41 123 2014 349 59 688 40 2014 323 2005 46 2003 46 2017 40 41 41 123 572 59 125 561 2018 61 42 2014 59 688 40 2016 46 2019 329 2011 46 2019 41 123 688 40 2018 46 2019 62 2011 46 2019 41 123 688 40 2020 40 2016 44 2018 44 2011 41 41 123 349 2013 59 125 125 125 630 123 688 40 2018 46 2019 329 2011 46 2019 41 123 688 40 33 2021 40 2016 44 2018 44 2011 41 41 123 338 2013 59 125 125 125 2016 61 2018 59 125 792 2013 340 1500 59 125 35 689 2022 2023 2024 40 41 601 123 792 2023 40 811 60 601 865 42 62 40 823 41 41 38 1506 59 125 865 2025 40 2007 321 2026 38 2027 41 601 123 2027 332 2024 40 41 332 362 59 664 40 601 561 38 2028 58 2003 41 123 2027 332 2028 46 2029 332 362 332 2028 46 2030 332 362 59 125 125 35 636 125 59 865 2031 40 601 2032 321 2033 60 2002 62 38 2034 44 704 2035 41 123 688 40 2035 37 1502 323 1500 41 123 664 40 561 38 2036 58 2034 41 123 2037 46 2038 40 2036 46 2039 41 59 664 40 561 38 2040 58 2036 46 2041 41 123 2037 46 2042 40 2040 46 2039 41 59 125 125 125 664 40 561 38 2043 58 2034 41 123 2031 40 2043 46 2044 44 2035 43 1501 41 59 125 125 330 2032 321 2045 60 625 44 2032 321 2033 60 2002 355 2046 59 2000 38 2047 59 777 58 601 569 2048 61 829 59 2001 40 2000 38 2049 41 58 2046 40 41 44 2047 40 2049 41 123 125 865 2050 40 625 2035 44 2051 38 2052 44 569 41 123 330 2002 2053 59 2053 46 2054 46 2055 40 2052 41 59 561 38 2056 61 2046 91 2035 93 59 330 2032 321 2057 60 2002 42 62 2058 59 2032 321 2059 40 2056 46 2060 40 41 44 2056 46 2061 40 41 44 2032 321 2062 40 2058 41 44 91 93 40 2002 38 2063 41 123 792 38 2063 59 125 41 59 2002 42 2064 61 753 59 870 40 33 2058 46 2065 40 41 41 123 2002 42 2066 61 2058 46 2067 40 41 59 2058 46 2068 40 41 59 688 40 2053 46 2069 40 42 2066 41 41 123 330 330 2064 61 2066 59 2058 46 2070 40 41 59 2032 321 2059 40 2066 354 2071 46 2060 40 41 44 2066 354 2071 46 2061 40 41 44 2032 321 2062 40 2058 41 44 91 93 40 2002 38 2063 41 123 792 38 2063 59 125 41 59 125 125 330 2032 321 2033 60 2002 62 42 2072 59 688 40 2064 323 753 41 123 2072 61 38 2056 59 125 630 123 2072 61 38 40 2064 354 2073 41 59 125 330 330 561 2074 61 2032 321 2075 40 2072 354 2060 40 41 44 2072 354 2061 40 41 44 91 2053 93 40 2002 38 2076 41 123 792 33 2076 46 2077 40 2053 41 59 125 41 59 330 2032 321 2078 40 2074 44 2072 354 2061 40 41 44 2032 321 2062 40 2053 46 2079 41 41 59 330 2072 354 2080 40 2074 44 2072 354 2061 40 41 41 59 330 2072 354 2081 40 2053 41 59 125 126 2001 40 41 123 330 688 40 2046 46 2082 40 41 323 1500 41 792 59 330 664 40 561 38 2083 58 2046 41 123 330 330 2047 46 2084 40 2083 46 2085 41 59 2031 40 2083 46 2086 44 1500 41 59 2047 46 2087 40 41 59 125 125 125 59 ,"{'AvgLine': 21, 'CountLine': 161, 'CountStmt': 25, 'MaxNesting': 1, 'AvgLineCode': 17, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 5, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 117, 'CountStmtDecl': 20, 'MaxCyclomatic': 2, 'SumCyclomatic': 7, 'AltAvgLineCode': 17, 'AvgLineComment': 3, 'CountClassBase': 0, 'CountLineBlank': 13, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 4, 'AltCountLineCode': 130, 'CountLineCodeExe': 7, 'CountLineComment': 17, 'AltAvgLineComment': 3, 'AltCountLineBlank': 14, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 19, 'CountLineInactive': 12, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.15', 'AltCountLineComment': 17, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 7, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 91, 'SumCyclomaticModified': 7, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98566,C++,"class CPL_DLL OGRGeomFieldDefn
{
protected:
//! @cond Doxygen_Suppress
        char                *pszName = nullptr;
        OGRwkbGeometryType   eGeomType = wkbUnknown; /* all values possible except wkbNone */
        mutable OGRSpatialReference* poSRS = nullptr;

        int                 bIgnore = false;
        mutable int         bNullable = true;

        void                Initialize( const char *, OGRwkbGeometryType );
//! @endcond

public:
                            OGRGeomFieldDefn( const char *pszNameIn,
                                              OGRwkbGeometryType eGeomTypeIn );
                  explicit OGRGeomFieldDefn( const OGRGeomFieldDefn * );
        virtual            ~OGRGeomFieldDefn();

        void                SetName( const char * );
        const char         *GetNameRef() const { return pszName; }

        OGRwkbGeometryType  GetType() const { return eGeomType; }
        void                SetType( OGRwkbGeometryType eTypeIn );

        virtual OGRSpatialReference* GetSpatialRef() const;
        void                 SetSpatialRef( OGRSpatialReference* poSRSIn );

        int                 IsIgnored() const { return bIgnore; }
        void                SetIgnored( int bIgnoreIn ) { bIgnore = bIgnoreIn; }

        int                 IsNullable() const { return bNullable; }
        void                SetNullable( int bNullableIn )
            { bNullable = bNullableIn; }

        int                 IsSame( const OGRGeomFieldDefn * ) const;

        /** Convert a OGRGeomFieldDefn* to a OGRGeomFieldDefnH.
        * @since GDAL 2.3
        */
        static inline OGRGeomFieldDefnH ToHandle(OGRGeomFieldDefn* poGeomFieldDefn)
            { return reinterpret_cast<OGRGeomFieldDefnH>(poGeomFieldDefn); }

        /** Convert a OGRGeomFieldDefnH to a OGRGeomFieldDefn*.
        * @since GDAL 2.3
        */
        static inline OGRGeomFieldDefn* FromHandle(OGRGeomFieldDefnH hGeomFieldDefn)
            { return reinterpret_cast<OGRGeomFieldDefn*>(hGeomFieldDefn); }
  private:
    CPL_DISALLOW_COPY_ASSIGN(OGRGeomFieldDefn)
};",0,587 2000 2001 123 775 58 330 582 42 2002 61 753 59 2003 2004 61 2005 59 305 740 2006 42 2007 61 753 59 704 2008 61 655 59 740 704 2009 61 829 59 865 2010 40 601 582 42 44 2003 41 59 330 777 58 2001 40 601 582 42 2011 44 2003 2012 41 59 648 2001 40 601 2001 42 41 59 864 126 2001 40 41 59 865 2013 40 601 582 42 41 59 601 582 42 2014 40 41 601 123 792 2002 59 125 2003 2015 40 41 601 123 792 2004 59 125 865 2016 40 2003 2017 41 59 864 2006 42 2018 40 41 601 59 865 2019 40 2006 42 2020 41 59 704 2021 40 41 601 123 792 2008 59 125 865 2022 40 704 2023 41 123 2008 61 2023 59 125 704 2024 40 41 601 123 792 2009 59 125 865 2025 40 704 2026 41 123 2009 61 2026 59 125 704 2027 40 601 2001 42 41 601 59 306 809 700 2028 2029 40 2001 42 2030 41 123 792 786 60 2028 62 40 2030 41 59 125 306 809 700 2001 42 2031 40 2028 2032 41 123 792 786 60 2001 42 62 40 2032 41 59 125 773 58 2033 40 2001 41 125 59 ,"{'AvgLine': 4, 'CountLine': 124, 'CountStmt': 58, 'MaxNesting': 1, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 36, 'MaxEssential': 1, 'SumEssential': 17, 'AvgCyclomatic': 1, 'CountLineCode': 98, 'CountStmtDecl': 25, 'MaxCyclomatic': 3, 'SumCyclomatic': 23, 'AltAvgLineCode': 4, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 18, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 19, 'AltCountLineCode': 98, 'CountLineCodeExe': 46, 'CountLineComment': 9, 'AltAvgLineComment': 0, 'AltCountLineBlank': 18, 'CountClassCoupled': 2, 'CountClassDerived': 9, 'CountLineCodeDecl': 23, 'CountLineInactive': 0, 'CountDeclMethodAll': 19, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 9, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 7, 'SumCyclomaticStrict': 28, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 6, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 16, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 85, 'SumCyclomaticModified': 23, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 17, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 5, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 5}"
98618,C++,"class FeatureDefnInfo
{
    OGRFeatureDefn* poTableDefn;
public:
    GeomFieldInfos  poGeomFieldInfos;
    StructFieldInfos poStructFieldInfos;

    FeatureDefnInfo() : poTableDefn(nullptr) {}
    ~FeatureDefnInfo() {
       if( poTableDefn )
           poTableDefn->Release();
    }
    FeatureDefnInfo(const FeatureDefnInfo& other)
    {
        poTableDefn = other.poTableDefn;
        if( poTableDefn )
            poTableDefn->Reference();
        poGeomFieldInfos = other.poGeomFieldInfos;
        poStructFieldInfos = other.poStructFieldInfos;
    }

    FeatureDefnInfo& operator= (const FeatureDefnInfo& other)
    {
        if( this != &other )
        {
            if( poTableDefn )
                poTableDefn->Release();
            poTableDefn = other.poTableDefn;
            if( poTableDefn )
                poTableDefn->Reference();
            poGeomFieldInfos = other.poGeomFieldInfos;
            poStructFieldInfos = other.poStructFieldInfos;
        }
        return *this;
    }

    OGRFeatureDefn* GetTableDefnRef() const { return poTableDefn; }
    void            SetTableDefn(OGRFeatureDefn* poTableDefnIn)
    {
        CPLAssert(poTableDefn == nullptr);
        poTableDefn= poTableDefnIn;
        if( poTableDefn )
            poTableDefn->Reference();
    }
};",0,587 2000 123 2001 42 2002 59 777 58 2003 2004 59 2005 2006 59 2000 40 41 58 2002 40 753 41 123 125 126 2000 40 41 123 688 40 2002 41 2002 354 2007 40 41 59 125 2000 40 601 2000 38 2008 41 123 2002 61 2008 46 2002 59 688 40 2002 41 2002 354 2009 40 41 59 2004 61 2008 46 2004 59 2006 61 2008 46 2006 59 125 2000 38 758 61 40 601 2000 38 2008 41 123 688 40 823 340 38 2008 41 123 688 40 2002 41 2002 354 2010 40 41 59 2002 61 2008 46 2002 59 688 40 2002 41 2002 354 2011 40 41 59 2004 61 2008 46 2004 59 2006 61 2008 46 2006 59 125 792 42 823 59 125 2001 42 2012 40 41 601 123 792 2002 59 125 865 2013 40 2001 42 2014 41 123 2015 40 2002 323 753 41 59 2002 61 2014 59 688 40 2002 41 2002 354 2016 40 41 59 125 125 59 ,"{'AvgLine': 5, 'CountLine': 45, 'CountStmt': 31, 'MaxNesting': 2, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 20, 'MaxEssential': 1, 'SumEssential': 6, 'AvgCyclomatic': 2, 'CountLineCode': 42, 'CountStmtDecl': 10, 'MaxCyclomatic': 4, 'SumCyclomatic': 12, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 3, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 0, 'CountDeclMethod': 6, 'AltCountLineCode': 42, 'CountLineCodeExe': 21, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 7, 'CountLineInactive': 0, 'CountDeclMethodAll': 6, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 4, 'SumCyclomaticStrict': 12, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 6, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 44, 'SumCyclomaticModified': 12, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98728,C++,"class OCAD_EXTERN CADCircle : public CADPoint3D
{
public:
    CADCircle();
    virtual ~CADCircle(){}

    double getRadius() const;
    void   setRadius( double value );

    virtual void print() const override;
protected:
    double radius;
};",0,587 2000 2001 58 777 2002 123 777 58 2001 40 41 59 864 126 2001 40 41 123 125 625 2003 40 41 601 59 865 2004 40 625 2005 41 59 864 865 2006 40 41 601 2007 59 775 58 625 2008 59 125 59 ,"{'AvgLine': 4, 'CountLine': 33, 'CountStmt': 11, 'MaxNesting': 0, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 4, 'MaxEssential': 1, 'SumEssential': 5, 'AvgCyclomatic': 1, 'CountLineCode': 31, 'CountStmtDecl': 7, 'MaxCyclomatic': 1, 'SumCyclomatic': 5, 'AltAvgLineCode': 4, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 5, 'AltCountLineCode': 31, 'CountLineCodeExe': 9, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 1, 'CountClassDerived': 1, 'CountLineCodeDecl': 6, 'CountLineInactive': 0, 'CountDeclMethodAll': 29, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 5, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 5, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 42, 'SumCyclomaticModified': 5, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 1}"
98844,C++,"class OGRPLScenesDataV1FeatureDefn final: public OGRFeatureDefn
{
            OGRPLScenesDataV1Layer* m_poLayer;

    public:
        OGRPLScenesDataV1FeatureDefn(OGRPLScenesDataV1Layer* poLayer,
                                 const char* pszName):
                            OGRFeatureDefn(pszName), m_poLayer(poLayer) {}
       ~OGRPLScenesDataV1FeatureDefn() {}

       virtual int GetFieldCount() const override;

       void DropRefToLayer() { m_poLayer = nullptr; }
};",0,587 2000 2001 58 777 2002 123 2003 42 2004 59 777 58 2000 40 2003 42 2005 44 601 582 42 2006 41 58 2002 40 2006 41 44 2004 40 2005 41 123 125 126 2000 40 41 123 125 864 704 2007 40 41 601 2008 59 865 2009 40 41 123 2004 61 753 59 125 125 59 ,"{'AvgLine': 2, 'CountLine': 20, 'CountStmt': 10, 'MaxNesting': 1, 'AvgLineCode': 2, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 4, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 17, 'CountStmtDecl': 6, 'MaxCyclomatic': 2, 'SumCyclomatic': 5, 'AltAvgLineCode': 2, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 4, 'AltCountLineCode': 17, 'CountLineCodeExe': 5, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 3, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 6, 'CountLineInactive': 0, 'CountDeclMethodAll': 43, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 6, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 50, 'SumCyclomaticModified': 5, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98976,C++,"class test_runner
{

public:

    /**
     * Constructor
     */
    test_runner()
    {
    }

    /**
     * Stores another group for getting by name.
     */
    void register_group(const std::string& name, group_base* gr)
    {
        if (gr == nullptr)
        {
            throw tut_error(""group shall be non-null"");
        }

        if (groups_.find(name) != groups_.end())
        {
            std::string msg(""attempt to add already existent group "" + name);
            // this exception terminates application so we use cerr also
            // TODO: should this message appear in stream?
            std::cerr << msg << std::endl;
            throw tut_error(msg);
        }

        groups_.insert( std::make_pair(name, gr) );
    }

    void set_callback(callback *cb)
    {
        clear_callbacks();
        insert_callback(cb);
    }

    /**
     * Stores callback object.
     */
    void insert_callback(callback* cb)
    {
        if(cb != nullptr)
        {
            callbacks_.insert(cb);
        }
    }

    void erase_callback(callback* cb)
    {
        callbacks_.erase(cb);
    }

    void clear_callbacks()
    {
        callbacks_.clear();
    }

    /**
     * Returns callback list.
     */
    const callbacks &get_callbacks() const
    {
        return callbacks_;
    }

    void set_callbacks(const callbacks &cb)
    {
        callbacks_ = cb;
    }

    /**
     * Returns list of known test groups.
     */
    const groupnames list_groups() const
    {
        groupnames ret;
        const_iterator i = groups_.begin();
        const_iterator e = groups_.end();
        while (i != e)
        {
            ret.push_back(i->first);
            ++i;
        }
        return ret;
    }

    /**
     * Runs all tests in all groups.
     */
    void run_tests() const
    {
        cb_run_started_();

        const_iterator i = groups_.begin();
        const_iterator e = groups_.end();
        while (i != e)
        {
            cb_group_started_(i->first);
            run_all_tests_in_group_(i);
            cb_group_completed_(i->first);

            ++i;
        }

        cb_run_completed_();
    }

    /**
     * Runs all tests in specified group.
     */
    void run_tests(const std::string& group_name) const
    {
        cb_run_started_();

        const_iterator i = groups_.find(group_name);
        if (i == groups_.end())
        {
            cb_run_completed_();
            throw no_such_group(group_name);
        }

        cb_group_started_(group_name);
        run_all_tests_in_group_(i);
        cb_group_completed_(group_name);
        cb_run_completed_();
    }

    /**
     * Runs one test in specified group.
     */
    bool run_test(const std::string& group_name, int n, test_result &tr) const
    {
        cb_run_started_();

        const_iterator i = groups_.find(group_name);
        if (i == groups_.end())
        {
            cb_run_completed_();
            throw no_such_group(group_name);
        }

        cb_group_started_(group_name);

        bool t = i->second->run_test(n, tr);

        if(t && tr.result != test_result::dummy)
        {
            cb_test_completed_(tr);
        }

        cb_group_completed_(group_name);
        cb_run_completed_();

        return t;
    }

protected:

    typedef std::map<std::string, group_base*> groups;
    typedef groups::iterator iterator;
    typedef groups::const_iterator const_iterator;
    groups groups_;

    callbacks callbacks_;

private:
    friend class restartable_wrapper;

    void cb_run_started_() const
    {
        for(callbacks::const_iterator i = callbacks_.begin(); i != callbacks_.end(); ++i)
        {
            (*i)->run_started();
        }
    }

    void cb_run_completed_() const
    {
        for(callbacks::const_iterator i = callbacks_.begin(); i != callbacks_.end(); ++i)
        {
            (*i)->run_completed();
        }
    }

    void cb_group_started_(const std::string &group_name) const
    {
        for(callbacks::const_iterator i = callbacks_.begin(); i != callbacks_.end(); ++i)
        {
            (*i)->group_started(group_name);
        }
    }

    void cb_group_completed_(const std::string &group_name) const
    {
        for(callbacks::const_iterator i = callbacks_.begin(); i != callbacks_.end(); ++i)
        {
            (*i)->group_completed(group_name);
        }
    }

    void cb_test_completed_(const test_result &tr) const
    {
        for(callbacks::const_iterator i = callbacks_.begin(); i != callbacks_.end(); ++i)
        {
            (*i)->test_completed(tr);
        }
    }

    void run_all_tests_in_group_(const_iterator i) const
    {
        i->second->rewind();

        test_result tr;
        while(i->second->run_next(tr))
        {
            if(tr.result != test_result::dummy)
            {
                cb_test_completed_(tr);
            }

            if (tr.result == test_result::ex_ctor)
            {
                // test object ctor failed, skip whole group
                break;
            }
        }
    }
};",0,587 2000 123 777 58 306 2000 40 41 123 125 306 865 2001 40 601 2002 321 2003 38 2004 44 2005 42 2006 41 123 688 40 2006 323 753 41 123 825 2007 40 362 41 59 125 688 40 2008 46 2009 40 2004 41 340 2008 46 2010 40 41 41 123 2002 321 2003 2011 40 362 43 2004 41 59 330 330 2002 321 2012 332 2011 332 2002 321 2013 59 825 2014 40 2011 41 59 125 2008 46 2015 40 2002 321 2016 40 2004 44 2006 41 41 59 125 865 2017 40 2018 42 2019 41 123 2020 40 41 59 2021 40 2019 41 59 125 306 865 2022 40 2018 42 2019 41 123 688 40 2019 340 753 41 123 2023 46 2024 40 2019 41 59 125 125 865 2025 40 2018 42 2019 41 123 2026 46 2027 40 2019 41 59 125 865 2028 40 41 123 2029 46 2030 40 41 59 125 306 601 2031 38 2032 40 41 601 123 792 2033 59 125 865 2034 40 601 2031 38 2019 41 123 2035 61 2019 59 125 306 601 2036 2037 40 41 601 123 2036 2038 59 2039 2040 61 2041 46 2042 40 41 59 2039 2043 61 2041 46 2044 40 41 59 870 40 2040 340 2043 41 123 2038 46 2045 40 2040 354 2046 41 59 349 2040 59 125 792 2038 59 125 306 865 2047 40 41 601 123 2048 40 41 59 2049 2050 61 2051 46 2052 40 41 59 2049 2053 61 2051 46 2054 40 41 59 870 40 2050 340 2053 41 123 2055 40 2050 354 2056 41 59 2057 40 2050 41 59 2058 40 2050 354 2056 41 59 349 2050 59 125 2059 40 41 59 125 306 865 2047 40 601 2002 321 2003 38 2060 41 601 123 2061 40 41 59 2062 2063 61 2064 46 2065 40 2060 41 59 688 40 2063 323 2064 46 2066 40 41 41 123 2067 40 41 59 825 2068 40 2060 41 59 125 2069 40 2060 41 59 2070 40 2063 41 59 2071 40 2060 41 59 2072 40 41 59 125 306 569 2073 40 601 2002 321 2003 38 2060 44 704 2074 44 2075 38 2076 41 601 123 2077 40 41 59 2078 2079 61 2080 46 2081 40 2060 41 59 688 40 2079 323 2080 46 2082 40 41 41 123 2083 40 41 59 825 2084 40 2060 41 59 125 2085 40 2060 41 59 569 2086 61 2079 354 2087 354 2073 40 2074 44 2076 41 59 688 40 2086 307 2076 46 2088 340 2075 321 2089 41 123 2090 40 2076 41 59 125 2091 40 2060 41 59 2092 40 41 59 792 2086 59 125 775 58 833 2002 321 2093 60 2002 321 2003 44 2005 42 62 2094 59 833 2094 321 2095 2095 59 833 2094 321 2096 2096 59 2094 2097 59 2031 2098 59 773 58 667 587 2099 59 865 2100 40 41 601 123 664 40 2031 321 2096 2101 61 2098 46 2102 40 41 59 2101 340 2098 46 2103 40 41 59 349 2101 41 123 40 42 2101 41 354 2104 40 41 59 125 125 865 2105 40 41 601 123 664 40 2031 321 2096 2106 61 2098 46 2107 40 41 59 2106 340 2098 46 2108 40 41 59 349 2106 41 123 40 42 2106 41 354 2109 40 41 59 125 125 865 2110 40 601 2002 321 2003 38 2060 41 601 123 664 40 2031 321 2096 2111 61 2098 46 2112 40 41 59 2111 340 2098 46 2113 40 41 59 349 2111 41 123 40 42 2111 41 354 2114 40 2060 41 59 125 125 865 2115 40 601 2002 321 2003 38 2060 41 601 123 664 40 2031 321 2096 2116 61 2098 46 2117 40 41 59 2116 340 2098 46 2118 40 41 59 349 2116 41 123 40 42 2116 41 354 2119 40 2060 41 59 125 125 865 2120 40 601 2075 38 2076 41 601 123 664 40 2031 321 2096 2121 61 2098 46 2122 40 41 59 2121 340 2098 46 2123 40 41 59 349 2121 41 123 40 42 2121 41 354 2124 40 2076 41 59 125 125 865 2125 40 2096 2126 41 601 123 2126 354 2127 354 2128 40 41 59 2075 2076 59 870 40 2126 354 2127 354 2129 40 2076 41 41 123 688 40 2076 46 2130 340 2075 321 2131 41 123 2120 40 2076 41 59 125 688 40 2076 46 2130 323 2075 321 2132 41 123 330 572 59 125 125 125 125 59 ,"{'AvgLine': 9, 'CountLine': 232, 'CountStmt': 86, 'MaxNesting': 2, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 48, 'MaxEssential': 3, 'SumEssential': 20, 'AvgCyclomatic': 1, 'CountLineCode': 167, 'CountStmtDecl': 39, 'MaxCyclomatic': 4, 'SumCyclomatic': 29, 'AltAvgLineCode': 8, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 38, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 18, 'AltCountLineCode': 167, 'CountLineCodeExe': 55, 'CountLineComment': 27, 'AltAvgLineComment': 0, 'AltCountLineBlank': 38, 'CountClassCoupled': 4, 'CountClassDerived': 0, 'CountLineCodeDecl': 34, 'CountLineInactive': 0, 'CountDeclMethodAll': 18, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.16', 'AltCountLineComment': 27, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 4, 'SumCyclomaticStrict': 30, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 11, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 14, 'CountDeclMethodPublic': 12, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 75, 'SumCyclomaticModified': 29, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 6, 'CountDeclInstanceMethod': 20, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 2}"
99005,C++,"    class SG_Exception_BadFeature : public SG_Exception
    {
        std::string err_msg;

        public:
            const char* get_err_msg() override { return err_msg.c_str(); }
        
        SG_Exception_BadFeature() : err_msg(""Unsupported or unrecognized feature type."") {}
    };",0,587 2000 58 777 2001 123 2002 321 2003 2004 59 777 58 601 582 42 2005 40 41 2006 123 792 2004 46 2007 40 41 59 125 2000 40 41 58 2004 40 362 41 123 125 125 59 ,"{'AvgLine': 1, 'CountLine': 9, 'CountStmt': 4, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 1, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 7, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 7, 'CountLineCodeExe': 1, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 3, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 85, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98865,C++,"class SDTSIndexedReader
{
    int                 nIndexSize;
    SDTSFeature       **papoFeatures;

    int                 iCurrentFeature;

protected:
    DDFModule           oDDFModule;

public:
                        SDTSIndexedReader();
    virtual            ~SDTSIndexedReader();

    virtual SDTSFeature  *GetNextRawFeature() = 0;

    SDTSFeature        *GetNextFeature();

    virtual void        Rewind();

    void                FillIndex();
    void                ClearIndex();
    int                 IsIndexed() const;

    SDTSFeature        *GetIndexedFeatureRef( int );
    char **             ScanModuleReferences( const char * = ""ATID"" );

    DDFModule          *GetModule() { return &oDDFModule; }
};",0,587 2000 123 704 2001 59 2002 42 42 2003 59 704 2004 59 775 58 2005 2006 59 777 58 2000 40 41 59 864 126 2000 40 41 59 864 2002 42 2007 40 41 61 1500 59 2002 42 2008 40 41 59 864 865 2009 40 41 59 865 2010 40 41 59 865 2011 40 41 59 704 2012 40 41 601 59 2002 42 2013 40 704 41 59 582 42 42 2014 40 601 582 42 61 362 41 59 2005 42 2015 40 41 123 792 38 2006 59 125 125 59 ,"{'AvgLine': 11, 'CountLine': 139, 'CountStmt': 66, 'MaxNesting': 3, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 47, 'MaxEssential': 5, 'SumEssential': 17, 'AvgCyclomatic': 2, 'CountLineCode': 108, 'CountStmtDecl': 23, 'MaxCyclomatic': 7, 'SumCyclomatic': 24, 'AltAvgLineCode': 8, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 31, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 2, 'CountDeclMethod': 11, 'AltCountLineCode': 108, 'CountLineCodeExe': 58, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 31, 'CountClassCoupled': 3, 'CountClassDerived': 4, 'CountLineCodeDecl': 16, 'CountLineInactive': 0, 'CountDeclMethodAll': 11, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 9, 'SumCyclomaticStrict': 27, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 11, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 63, 'SumCyclomaticModified': 24, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 13, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 4, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 1}"
99013,C++,"    class SG_Exception_Not1D : public SG_Exception
    {
        std::string err_msg;

        public:
            const char* get_err_msg() override { return err_msg.c_str(); }
        
        SG_Exception_Not1D() : err_msg(""A node coordinates axis variable or node_counts is not one dimensional."") {}
    };",0,587 2000 58 777 2001 123 2002 321 2003 2004 59 777 58 601 582 42 2005 40 41 2006 123 792 2004 46 2007 40 41 59 125 2000 40 41 58 2004 40 362 41 123 125 125 59 ,"{'AvgLine': 1, 'CountLine': 9, 'CountStmt': 4, 'MaxNesting': 0, 'AvgLineCode': 1, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 1, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 7, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AltAvgLineCode': 1, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 2, 'AltCountLineCode': 7, 'CountLineCodeExe': 1, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 3, 'CountLineInactive': 0, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 2, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 85, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 1, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
98977,C++,"class test_runner_singleton
{
public:

    static test_runner& get()
    {
        static test_runner tr;
        return tr;
    }
};",0,587 2000 123 777 58 809 2001 38 2002 40 41 123 809 2001 2003 59 792 2003 59 125 125 59 ,"{'AvgLine': 5, 'CountLine': 10, 'CountStmt': 3, 'MaxNesting': 0, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 9, 'CountStmtDecl': 2, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 1, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 1, 'AltCountLineCode': 9, 'CountLineCodeExe': 2, 'CountLineComment': 0, 'AltAvgLineComment': 0, 'AltCountLineBlank': 1, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 3, 'CountLineInactive': 0, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.00', 'AltCountLineComment': 0, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 3, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99033,C++,"class Vector : public Sized {
 public:
  Vector(const uint8_t *data, uint8_t byte_width) : Sized(data, byte_width) {}

  Reference operator[](size_t i) const;

  static Vector EmptyVector() {
    static const uint8_t empty_vector[] = { 0 /*len*/ };
    return Vector(empty_vector + 1, 1);
  }
  bool IsTheEmptyVector() const { return data_ == EmptyVector().data_; }
};",0,587 2000 58 777 2001 123 777 58 2000 40 601 2002 42 2003 44 2002 2004 41 58 2001 40 2003 44 2004 41 123 125 2005 758 91 93 40 2006 2007 41 601 59 809 2000 2008 40 41 123 809 601 2002 2009 91 93 61 123 1500 305 125 59 792 2000 40 2009 43 1501 44 1501 41 59 125 569 2010 40 41 601 123 792 2011 323 2008 40 41 46 2011 59 125 125 59 ,"{'AvgLine': 3, 'CountLine': 19, 'CountStmt': 13, 'MaxNesting': 1, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 6, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 17, 'CountStmtDecl': 8, 'MaxCyclomatic': 2, 'SumCyclomatic': 5, 'AltAvgLineCode': 3, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 2, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 4, 'AltCountLineCode': 17, 'CountLineCodeExe': 9, 'CountLineComment': 1, 'AltAvgLineComment': 0, 'AltCountLineBlank': 2, 'CountClassCoupled': 1, 'CountClassDerived': 1, 'CountLineCodeDecl': 9, 'CountLineInactive': 0, 'CountDeclMethodAll': 9, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.06', 'AltCountLineComment': 1, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 5, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 4, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 5, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
98777,C++,"class CPL_DLL CPLJSONArray : public CPLJSONObject
{
    friend class CPLJSONObject;
    friend class CPLJSONDocument;
public:
/*! @cond Doxygen_Suppress */
    CPLJSONArray();
    explicit CPLJSONArray(const std::string &osName);
    explicit CPLJSONArray(const CPLJSONObject &other);

private:
    explicit CPLJSONArray(const std::string &osName, JSONObjectH poJsonObject);

    class CPL_DLL ConstIterator
    {
            const CPLJSONArray& m_oSelf;
            int m_nIdx;
            mutable CPLJSONObject m_oObj{};

        public:
            ConstIterator(const CPLJSONArray& oSelf, bool bStart): m_oSelf(oSelf), m_nIdx(bStart ? 0 : oSelf.Size()) {}
            ~ConstIterator() = default;
            CPLJSONObject& operator*() const { m_oObj = m_oSelf[m_nIdx]; return m_oObj; }
            ConstIterator& operator++() { m_nIdx ++; return *this; }
            bool operator==(const ConstIterator& it) const { return m_nIdx == it.m_nIdx; }
            bool operator!=(const ConstIterator& it) const { return m_nIdx != it.m_nIdx; }
    };

/*! @endcond */
public:
    int Size() const;
    void Add(const CPLJSONObject &oValue);
    void Add(const std::string &osValue);
    void Add(const char* pszValue);
    void Add(double dfValue);
    void Add(int nValue);
    void Add(GInt64 nValue);
    void Add(bool bValue);
    CPLJSONObject operator[](int nIndex);
    const CPLJSONObject operator[](int nIndex) const;

    /** Iterator to first element */
    ConstIterator begin() const { return ConstIterator(*this, true); }
    /** Iterator to after last element */
    ConstIterator end() const { return ConstIterator(*this, false); }
};",0,587 2000 2001 58 777 2002 123 667 587 2002 59 667 587 2003 59 777 58 305 2001 40 41 59 648 2001 40 601 2004 321 2005 38 2006 41 59 648 2001 40 601 2002 38 2007 41 59 773 58 648 2001 40 601 2004 321 2005 38 2006 44 2008 2009 41 59 587 2000 2010 123 601 2001 38 2011 59 704 2012 59 740 2002 2013 123 125 59 777 58 2010 40 601 2001 38 2014 44 569 2015 41 58 2011 40 2014 41 44 2012 40 2015 63 1500 58 2014 46 2016 40 41 41 123 125 126 2010 40 41 61 613 59 2002 38 758 42 40 41 601 123 2013 61 2011 91 2012 93 59 792 2013 59 125 2010 38 758 349 40 41 123 2012 349 59 792 42 823 59 125 569 758 323 40 601 2010 38 2017 41 601 123 792 2012 323 2017 46 2012 59 125 569 758 340 40 601 2010 38 2017 41 601 123 792 2012 340 2017 46 2012 59 125 125 59 305 777 58 704 2018 40 41 601 59 865 2019 40 601 2002 38 2020 41 59 865 2019 40 601 2004 321 2005 38 2021 41 59 865 2019 40 601 582 42 2022 41 59 865 2019 40 625 2023 41 59 865 2019 40 704 2024 41 59 865 2019 40 2025 2024 41 59 865 2019 40 569 2026 41 59 2002 758 91 93 40 704 2027 41 59 601 2002 758 91 93 40 704 2027 41 601 59 306 2010 2028 40 41 601 123 792 2010 40 42 823 44 829 41 59 125 306 2010 2029 40 41 601 123 792 2010 40 42 823 44 655 41 59 125 125 59 ,"{'AvgLine': 5, 'CountLine': 126, 'CountStmt': 59, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 32, 'MaxEssential': 1, 'SumEssential': 16, 'AvgCyclomatic': 1, 'CountLineCode': 115, 'CountStmtDecl': 28, 'MaxCyclomatic': 3, 'SumCyclomatic': 24, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 7, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 19, 'AltCountLineCode': 115, 'CountLineCodeExe': 64, 'CountLineComment': 4, 'AltAvgLineComment': 0, 'AltCountLineBlank': 7, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 23, 'CountLineInactive': 0, 'CountDeclMethodAll': 97, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.03', 'AltCountLineComment': 4, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 25, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 4, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 100, 'CountDeclMethodPublic': 17, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 24, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 24, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99276,C++,"class PCIDSK2Dataset final: public GDALPamDataset
{
    friend class PCIDSK2Band;

    mutable OGRSpatialReference* m_poSRS = nullptr;

    std::unordered_map<std::string, std::string> m_oCacheMetadataItem{};
    char      **papszLastMDListValue;

    PCIDSK::PCIDSKFile  *poFile;

    std::vector<OGRPCIDSKLayer*> apoLayers;

    static GDALDataType  PCIDSKTypeToGDAL( PCIDSK::eChanType eType );
    void                 ProcessRPC();

  public:
                PCIDSK2Dataset();
    virtual ~PCIDSK2Dataset();

    static int           Identify( GDALOpenInfo * );
    static GDALDataset  *Open( GDALOpenInfo * );
    static GDALDataset  *LLOpen( const char *pszFilename, PCIDSK::PCIDSKFile *,
                                 GDALAccess eAccess,
                                 char** papszSiblingFiles = nullptr );
    static GDALDataset  *Create( const char * pszFilename,
                                 int nXSize, int nYSize, int nBands,
                                 GDALDataType eType,
                                 char **papszParamList );

    char              **GetFileList() override;
    CPLErr              GetGeoTransform( double * padfTransform ) override;
    CPLErr              SetGeoTransform( double * ) override;

    const OGRSpatialReference* GetSpatialRef() const override;
    CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override;

    virtual char      **GetMetadataDomainList() override;
    CPLErr              SetMetadata( char **, const char * ) override;
    char              **GetMetadata( const char* ) override;
    CPLErr              SetMetadataItem(const char*,const char*,const char*) override;
    const char         *GetMetadataItem( const char*, const char*) override;

    virtual void FlushCache(bool bAtClosing) override;

    virtual CPLErr IBuildOverviews( const char *, int, int *,
                                    int, int *, GDALProgressFunc, void * ) override;

    virtual int                 GetLayerCount() override { return (int) apoLayers.size(); }
    virtual OGRLayer            *GetLayer( int ) override;

    virtual int                 TestCapability( const char * ) override;

    virtual OGRLayer           *ICreateLayer( const char *, OGRSpatialReference *,
                                     OGRwkbGeometryType, char ** ) override;
};",1,587 2000 2001 58 777 2002 123 667 587 2003 59 740 2004 42 2005 61 753 59 2006 321 2007 60 2006 321 2008 44 2006 321 2008 62 2009 123 125 59 582 42 42 2010 59 2011 321 2012 42 2013 59 2006 321 2014 60 2015 42 62 2016 59 809 2017 2018 40 2011 321 2019 2020 41 59 865 2021 40 41 59 777 58 2000 40 41 59 864 126 2000 40 41 59 809 704 2022 40 2023 42 41 59 809 2024 42 2025 40 2023 42 41 59 809 2024 42 2026 40 601 582 42 2027 44 2011 321 2012 42 44 2028 2029 44 582 42 42 2030 61 753 41 59 809 2024 42 2031 40 601 582 42 2027 44 704 2032 44 704 2033 44 704 2034 44 2017 2020 44 582 42 42 2035 41 59 582 42 42 2036 40 41 2037 59 2038 2039 40 625 42 2040 41 2037 59 2038 2041 40 625 42 41 2037 59 601 2004 42 2042 40 41 601 2037 59 2038 2043 40 601 2004 42 2044 41 2037 59 864 582 42 42 2045 40 41 2037 59 2038 2046 40 582 42 42 44 601 582 42 41 2037 59 582 42 42 2047 40 601 582 42 41 2037 59 2038 2048 40 601 582 42 44 601 582 42 44 601 582 42 41 2037 59 601 582 42 2049 40 601 582 42 44 601 582 42 41 2037 59 864 865 2050 40 569 2051 41 2037 59 864 2038 2052 40 601 582 42 44 704 44 704 42 44 704 44 704 42 44 2053 44 865 42 41 2037 59 864 704 2054 40 41 2037 123 792 40 704 41 2016 46 2055 40 41 59 125 864 2056 42 2057 40 704 41 2037 59 864 704 2058 40 601 582 42 41 2037 59 864 2056 42 2059 40 601 582 42 44 2004 42 44 2060 44 582 42 42 41 2037 59 125 59 ,"{'AvgLine': 55, 'CountLine': 1381, 'CountStmt': 557, 'MaxNesting': 4, 'AvgLineCode': 42, 'AvgEssential': 3, 'AvgLineBlank': 7, 'CountStmtExe': 463, 'MaxEssential': 11, 'SumEssential': 84, 'AvgCyclomatic': 7, 'CountLineCode': 1050, 'CountStmtDecl': 155, 'MaxCyclomatic': 20, 'SumCyclomatic': 172, 'AltAvgLineCode': 42, 'AvgLineComment': 5, 'CountClassBase': 1, 'CountLineBlank': 191, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 7, 'CountDeclMethod': 24, 'AltCountLineCode': 1050, 'CountLineCodeExe': 820, 'CountLineComment': 140, 'AltAvgLineComment': 5, 'AltCountLineBlank': 191, 'CountClassCoupled': 16, 'CountClassDerived': 0, 'CountLineCodeDecl': 172, 'CountLineInactive': 0, 'CountDeclMethodAll': 210, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.13', 'AltCountLineComment': 140, 'AvgCyclomaticStrict': 8, 'MaxCyclomaticStrict': 25, 'SumCyclomaticStrict': 214, 'CountDeclClassMethod': 5, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 6, 'CountDeclMethodFriend': 20, 'CountDeclMethodPublic': 22, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 20, 'PercentLackOfCohesion': 83, 'SumCyclomaticModified': 162, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 21, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 5, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
117958,C++,"class RTL : public MissionBlock, public ModuleParams
{
public:
	RTL(Navigator *navigator);

	~RTL() = default;

	enum RTLType {
		RTL_TYPE_HOME_OR_RALLY = 0,
		RTL_TYPE_MISSION_LANDING,
		RTL_TYPE_MISSION_LANDING_REVERSED,
		RTL_TYPE_CLOSEST,
	};

	enum RTLDestinationType {
		RTL_DESTINATION_HOME = 0,
		RTL_DESTINATION_MISSION_LANDING,
		RTL_DESTINATION_SAFE_POINT,
	};

	enum RTLHeadingMode {
		RTL_NAVIGATION_HEADING = 0,
		RTL_DESTINATION_HEADING,
		RTL_CURRENT_HEADING,
	};

	void on_inactivation() override;
	void on_inactive() override;
	void on_activation() override;
	void on_active() override;

	void find_RTL_destination();

	void set_return_alt_min(bool min) { _rtl_alt_min = min; }

	int get_rtl_type() const { return _param_rtl_type.get(); }

	void setClimbAndReturnDone(bool done) { _climb_and_return_done = done; }

	bool getClimbAndReturnDone() { return _climb_and_return_done; }

	void get_rtl_xy_z_speed(float &xy, float &z);
	matrix::Vector2f get_wind();

	bool getDestinationTypeMissionLanding() { return _destination.type == RTL_DESTINATION_MISSION_LANDING; }

private:

	void set_rtl_item();

	void advance_rtl();

	float calculate_return_alt_from_cone_half_angle(float cone_half_angle_deg);
	void calc_and_pub_rtl_time_estimate();

	float getCruiseGroundSpeed();

	float getClimbRate();

	float getDescendRate();

	float getCruiseSpeed();

	float getHoverLandSpeed();

	enum RTLState {
		RTL_STATE_NONE = 0,
		RTL_STATE_CLIMB,
		RTL_STATE_RETURN,
		RTL_STATE_DESCEND,
		RTL_STATE_LOITER,
		RTL_STATE_TRANSITION_TO_MC,
		RTL_MOVE_TO_LAND_HOVER_VTOL,
		RTL_STATE_LAND,
		RTL_STATE_LANDED,
		RTL_STATE_HEAD_TO_CENTER,
	} _rtl_state{RTL_STATE_NONE};

	struct RTLPosition {
		double lat;
		double lon;
		float alt;
		float yaw;
		uint8_t safe_point_index; ///< 0 = home position, 1 = mission landing, >1 = safe landing points (rally points)
		RTLDestinationType type{RTL_DESTINATION_HOME};

		void set(const home_position_s &home_position)
		{
			lat = home_position.lat;
			lon = home_position.lon;
			alt = home_position.alt;
			yaw = home_position.yaw;
			safe_point_index = 0;
			type = RTL_DESTINATION_HOME;
		}
	};

	RTLPosition _destination{}; ///< the RTL position to fly to (typically the home position or a safe point)

	hrt_abstime _destination_check_time{0};

	float _rtl_alt{0.0f};	// AMSL altitude at which the vehicle should return to the home position
	float _rtl_loiter_rad{50.0f};		// radius at which a fixed wing would loiter while descending

	bool _climb_and_return_done{false};	// this flag is set to true if RTL is active and we are past the climb state and return state
	bool _rtl_alt_min{false};

	DEFINE_PARAMETERS(
		(ParamFloat<px4::params::RTL_RETURN_ALT>)  _param_rtl_return_alt,
		(ParamFloat<px4::params::RTL_DESCEND_ALT>) _param_rtl_descend_alt,
		(ParamFloat<px4::params::RTL_LAND_DELAY>)  _param_rtl_land_delay,
		(ParamFloat<px4::params::RTL_MIN_DIST>)    _param_rtl_min_dist,
		(ParamInt<px4::params::RTL_TYPE>)          _param_rtl_type,
		(ParamInt<px4::params::RTL_CONE_ANG>)      _param_rtl_cone_half_angle_deg,
		(ParamInt<px4::params::RTL_PLD_MD>)        _param_rtl_pld_md,
		(ParamFloat<px4::params::RTL_LOITER_RAD>)  _param_rtl_loiter_rad,
		(ParamInt<px4::params::RTL_HDG_MD>)        _param_rtl_hdg_md,
		(ParamFloat<px4::params::RTL_TIME_FACTOR>) _param_rtl_time_factor,
		(ParamInt<px4::params::RTL_TIME_MARGIN>)   _param_rtl_time_margin
	)

	param_t		_param_mpc_z_vel_max_up{PARAM_INVALID};
	param_t		_param_mpc_z_vel_max_down{PARAM_INVALID};
	param_t		_param_mpc_land_speed{PARAM_INVALID};
	param_t		_param_fw_climb_rate{PARAM_INVALID};
	param_t		_param_fw_sink_rate{PARAM_INVALID};

	param_t 	_param_fw_airspeed_trim{PARAM_INVALID};
	param_t 	_param_mpc_xy_cruise{PARAM_INVALID};
	param_t 	_param_rover_cruise_speed{PARAM_INVALID};

	uORB::SubscriptionData<wind_s>		_wind_sub{ORB_ID(wind)};
	uORB::Publication<rtl_time_estimate_s> _rtl_time_estimate_pub{ORB_ID(rtl_time_estimate)};
};",1,587 2000 58 777 2001 44 777 2002 123 777 58 2000 40 2003 42 2004 41 59 126 2000 40 41 61 613 59 640 2005 123 2006 61 1500 44 2007 44 2008 44 2009 44 125 59 640 2010 123 2011 61 1500 44 2012 44 2013 44 125 59 640 2014 123 2015 61 1500 44 2016 44 2017 44 125 59 865 2018 40 41 2019 59 865 2020 40 41 2019 59 865 2021 40 41 2019 59 865 2022 40 41 2019 59 865 2023 40 41 59 865 2024 40 569 2025 41 123 2026 61 2025 59 125 704 2027 40 41 601 123 792 2028 46 2029 40 41 59 125 865 2030 40 569 2031 41 123 2032 61 2031 59 125 569 2033 40 41 123 792 2034 59 125 865 2035 40 660 38 2036 44 660 38 2037 41 59 2038 321 2039 2040 40 41 59 569 2041 40 41 123 792 2042 46 2043 323 2044 59 125 773 58 865 2045 40 41 59 865 2046 40 41 59 660 2047 40 660 2048 41 59 865 2049 40 41 59 660 2050 40 41 59 660 2051 40 41 59 660 2052 40 41 59 660 2053 40 41 59 660 2054 40 41 59 640 2055 123 2056 61 1500 44 2057 44 2058 44 2059 44 2060 44 2061 44 2062 44 2063 44 2064 44 2065 44 125 2066 123 2067 125 59 816 2068 123 625 2069 59 625 2070 59 660 2071 59 660 2072 59 2073 2074 59 331 2010 2075 123 2076 125 59 865 2077 40 601 2078 38 2079 41 123 2069 61 2079 46 2069 59 2070 61 2079 46 2070 59 2071 61 2079 46 2071 59 2072 61 2079 46 2072 59 2074 61 1500 59 2075 61 2080 59 125 125 59 2068 2081 123 125 59 331 2082 2083 123 1500 125 59 660 2084 123 1500 125 59 330 660 2085 123 1503 125 59 330 569 2086 123 655 125 59 330 569 2087 123 655 125 59 2088 40 40 2089 60 2090 321 2091 321 2092 62 41 2093 44 40 2089 60 2090 321 2091 321 2094 62 41 2095 44 40 2089 60 2090 321 2091 321 2096 62 41 2097 44 40 2089 60 2090 321 2091 321 2098 62 41 2099 44 40 2100 60 2090 321 2091 321 2101 62 41 2102 44 40 2100 60 2090 321 2091 321 2103 62 41 2104 44 40 2100 60 2090 321 2091 321 2105 62 41 2106 44 40 2089 60 2090 321 2091 321 2107 62 41 2108 44 40 2100 60 2090 321 2091 321 2109 62 41 2110 44 40 2089 60 2090 321 2091 321 2111 62 41 2112 44 40 2100 60 2090 321 2091 321 2113 62 41 2114 41 2115 2116 123 2117 125 59 2115 2118 123 2119 125 59 2115 2120 123 2121 125 59 2115 2122 123 2123 125 59 2115 2124 123 2125 125 59 2115 2126 123 2127 125 59 2115 2128 123 2129 125 59 2115 2130 123 2131 125 59 2132 321 2133 60 2134 62 2135 123 2136 40 2137 41 125 59 2132 321 2138 60 2139 62 2140 123 2141 40 2142 41 125 59 125 59 ,"{'AvgLine': 41, 'CountLine': 983, 'CountStmt': 480, 'MaxNesting': 5, 'AvgLineCode': 29, 'AvgEssential': 1, 'AvgLineBlank': 9, 'CountStmtExe': 363, 'MaxEssential': 8, 'SumEssential': 35, 'AvgCyclomatic': 6, 'CountLineCode': 682, 'CountStmtDecl': 120, 'MaxCyclomatic': 50, 'SumCyclomatic': 152, 'AltAvgLineCode': 29, 'AvgLineComment': 3, 'CountClassBase': 2, 'CountLineBlank': 228, 'CountStmtEmpty': 14, 'AltAvgLineBlank': 9, 'CountDeclMethod': 24, 'AltCountLineCode': 682, 'CountLineCodeExe': 339, 'CountLineComment': 85, 'AltAvgLineComment': 3, 'AltCountLineBlank': 228, 'CountClassCoupled': 14, 'CountClassDerived': 0, 'CountLineCodeDecl': 86, 'CountLineInactive': 0, 'CountDeclMethodAll': 64, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.12', 'AltCountLineComment': 85, 'AvgCyclomaticStrict': 7, 'MaxCyclomaticStrict': 50, 'SumCyclomaticStrict': 155, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 5, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 14, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 42, 'PercentLackOfCohesion': 97, 'SumCyclomaticModified': 125, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 9, 'CountDeclInstanceMethod': 26, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 28, 'CountDeclInstanceVariablePublic': 21, 'CountDeclInstanceVariablePrivate': 7, 'CountDeclInstanceVariableProtected': 0}"
98916,C++,"class OGROpenFileGDBLayer final: public OGRLayer
{
    friend class OGROpenFileGDBGeomFieldDefn;
    friend class OGROpenFileGDBFeatureDefn;

    CPLString         m_osGDBFilename;
    CPLString         m_osName;
    FileGDBTable     *m_poLyrTable;
    OGROpenFileGDBFeatureDefn   *m_poFeatureDefn;
    int               m_iGeomFieldIdx;
    int               m_iCurFeat;
    std::string       m_osDefinition;
    std::string       m_osDocumentation;
    OGRwkbGeometryType m_eGeomType;
    int               m_bValidLayerDefn;
    int               m_bEOF;
    bool              m_bTimeInUTC = false;

    int               BuildLayerDefinition();
    int               BuildGeometryColumnGDBv10();
    OGRFeature       *GetCurrentFeature();

    FileGDBOGRGeometryConverter* m_poGeomConverter;

    int               m_iFieldToReadAsBinary;

    FileGDBIterator      *m_poAttributeIterator;
    int                   m_bIteratorSufficientToEvaluateFilter;
    FileGDBIterator*      BuildIteratorFromExprNode(swq_expr_node* poNode);

    FileGDBIterator*      m_poIterMinMax;

    FileGDBSpatialIndexIterator* m_poSpatialIndexIterator = nullptr;
    FileGDBIterator      *m_poCombinedIterator = nullptr;

    // Legacy behavior prior to handling of .spx file
    // To remove ultimately.
    SPIState            m_eSpatialIndexState;
    CPLQuadTree        *m_pQuadTree;
    void              **m_pahFilteredFeatures;
    int                 m_nFilteredFeatureCount;
    static void         GetBoundsFuncEx(const void* hFeature,
                                        CPLRectObj* pBounds,
                                        void* pQTUserData);

    void                TryToDetectMultiPatchKind();
    void                BuildCombinedIterator();

public:

                        OGROpenFileGDBLayer(const char* pszGDBFilename,
                                            const char* pszName,
                                            const std::string& osDefinition,
                                            const std::string& osDocumentation,
                                            const char* pszGeomName = nullptr,
                                            OGRwkbGeometryType eGeomType = wkbUnknown);
  virtual              ~OGROpenFileGDBLayer();

  const std::string&    GetXMLDefinition() { return m_osDefinition; }
  const std::string&    GetXMLDocumentation() { return m_osDocumentation; }
  int                   GetAttrIndexUse() { return (m_poAttributeIterator == nullptr) ? 0 : (m_bIteratorSufficientToEvaluateFilter) ? 2 : 1; }
  const OGRField*       GetMinMaxValue(OGRFieldDefn* poFieldDefn, int bIsMin,
                                       int& eOutType);
  int                   GetMinMaxSumCount(OGRFieldDefn* poFieldDefn,
                                          double& dfMin, double& dfMax,
                                          double& dfSum, int& nCount);
  int                   HasIndexForField(const char* pszFieldName);
  FileGDBIterator*      BuildIndex(const char* pszFieldName,
                                   int bAscending,
                                   int op,
                                   swq_expr_node* poValue);
  SPIState              GetSpatialIndexState() const { return m_eSpatialIndexState; }
  int                   IsValidLayerDefn() { return BuildLayerDefinition(); }

  virtual const char* GetName() override { return m_osName.c_str(); }
  virtual OGRwkbGeometryType GetGeomType() override;

  virtual const char* GetFIDColumn() override;

  virtual void        ResetReading() override;
  virtual OGRFeature* GetNextFeature() override;
  virtual OGRFeature* GetFeature( GIntBig nFeatureId ) override;
  virtual OGRErr      SetNextByIndex( GIntBig nIndex ) override;

  virtual GIntBig     GetFeatureCount( int bForce = TRUE ) override;
  virtual OGRErr      GetExtent(OGREnvelope *psExtent, int bForce = TRUE) override;
  virtual OGRErr      GetExtent(int iGeomField, OGREnvelope *psExtent, int bForce) override
                { return OGRLayer::GetExtent(iGeomField, psExtent, bForce); }

  virtual OGRFeatureDefn* GetLayerDefn() override;

  virtual void        SetSpatialFilter( OGRGeometry * ) override;
  virtual void        SetSpatialFilter( int iGeomField, OGRGeometry *poGeom ) override
                { OGRLayer::SetSpatialFilter(iGeomField, poGeom); }
  virtual OGRErr      SetAttributeFilter( const char* pszFilter ) override;

  virtual int         TestCapability( const char * ) override;
};",1,587 2000 2001 58 777 2002 123 667 587 2003 59 667 587 2004 59 2005 2006 59 2005 2007 59 2008 42 2009 59 2004 42 2010 59 704 2011 59 704 2012 59 2013 321 2014 2015 59 2013 321 2014 2016 59 2017 2018 59 704 2019 59 704 2020 59 569 2021 61 655 59 704 2022 40 41 59 704 2023 40 41 59 2024 42 2025 40 41 59 2026 42 2027 59 704 2028 59 2029 42 2030 59 704 2031 59 2029 42 2032 40 2033 42 2034 41 59 2029 42 2035 59 2036 42 2037 61 753 59 2029 42 2038 61 753 59 330 330 2039 2040 59 2041 42 2042 59 865 42 42 2043 59 704 2044 59 809 865 2045 40 601 865 42 2046 44 2047 42 2048 44 865 42 2049 41 59 865 2050 40 41 59 865 2051 40 41 59 777 58 2000 40 601 582 42 2052 44 601 582 42 2053 44 601 2013 321 2014 38 2054 44 601 2013 321 2014 38 2055 44 601 582 42 2056 61 753 44 2017 2057 61 2058 41 59 864 126 2000 40 41 59 601 2013 321 2014 38 2059 40 41 123 792 2015 59 125 601 2013 321 2014 38 2060 40 41 123 792 2016 59 125 704 2061 40 41 123 792 40 2030 323 753 41 63 1500 58 40 2031 41 63 1502 58 1501 59 125 601 2062 42 2063 40 2064 42 2065 44 704 2066 44 704 38 2067 41 59 704 2068 40 2064 42 2065 44 625 38 2069 44 625 38 2070 44 625 38 2071 44 704 38 2072 41 59 704 2073 40 601 582 42 2074 41 59 2029 42 2075 40 601 582 42 2074 44 704 2076 44 704 2077 44 2033 42 2078 41 59 2039 2079 40 41 601 123 792 2040 59 125 704 2080 40 41 123 792 2022 40 41 59 125 864 601 582 42 2081 40 41 2082 123 792 2007 46 2083 40 41 59 125 864 2017 2084 40 41 2082 59 864 601 582 42 2085 40 41 2082 59 864 865 2086 40 41 2082 59 864 2024 42 2087 40 41 2082 59 864 2024 42 2088 40 2089 2090 41 2082 59 864 2091 2092 40 2089 2093 41 2082 59 864 2089 2094 40 704 2095 61 2096 41 2082 59 864 2091 2097 40 2098 42 2099 44 704 2095 61 2096 41 2082 59 864 2091 2097 40 704 2100 44 2098 42 2099 44 704 2095 41 2082 123 792 2002 321 2097 40 2100 44 2099 44 2095 41 59 125 864 2101 42 2102 40 41 2082 59 864 865 2103 40 2104 42 41 2082 59 864 865 2103 40 704 2100 44 2104 42 2105 41 2082 123 2002 321 2103 40 2100 44 2105 41 59 125 864 2091 2106 40 601 582 42 2107 41 2082 59 864 704 2108 40 601 582 42 41 2082 59 125 59 ,"{'AvgLine': 49, 'CountLine': 1673, 'CountStmt': 904, 'MaxNesting': 7, 'AvgLineCode': 44, 'AvgEssential': 4, 'AvgLineBlank': 3, 'CountStmtExe': 790, 'MaxEssential': 30, 'SumEssential': 157, 'AvgCyclomatic': 9, 'CountLineCode': 1496, 'CountStmtDecl': 200, 'MaxCyclomatic': 63, 'SumCyclomatic': 310, 'AltAvgLineCode': 44, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 127, 'CountStmtEmpty': 6, 'AltAvgLineBlank': 3, 'CountDeclMethod': 33, 'AltCountLineCode': 1500, 'CountLineCodeExe': 1047, 'CountLineComment': 53, 'AltAvgLineComment': 1, 'AltCountLineBlank': 127, 'CountClassCoupled': 30, 'CountClassDerived': 0, 'CountLineCodeDecl': 199, 'CountLineInactive': 2, 'CountDeclMethodAll': 115, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.04', 'AltCountLineComment': 53, 'AvgCyclomaticStrict': 12, 'MaxCyclomaticStrict': 80, 'SumCyclomaticStrict': 399, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 8, 'CountDeclMethodFriend': 12, 'CountDeclMethodPublic': 26, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 45, 'PercentLackOfCohesion': 84, 'SumCyclomaticModified': 278, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 7, 'CountDeclInstanceMethod': 34, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 23, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 23, 'CountDeclInstanceVariableProtected': 0}"
118569,C++,"class ToxOptions
{
public:
    ~ToxOptions();
    ToxOptions(ToxOptions&& from);
    operator Tox_Options*();
    const char* getProxyAddrData() const;
    static std::unique_ptr<ToxOptions> makeToxOptions(const QByteArray& savedata,
                                                      const ICoreSettings* s);
    bool getIPv6Enabled() const;
    void setIPv6Enabled(bool enabled);

private:
    ToxOptions(Tox_Options* options, const QByteArray& proxyAddrData);

private:
    Tox_Options* options = nullptr;
    QByteArray proxyAddrData;
};",1,587 2000 123 777 58 126 2000 40 41 59 2000 40 2000 307 2001 41 59 758 2002 42 40 41 59 601 582 42 2003 40 41 601 59 809 2004 321 2005 60 2000 62 2006 40 601 2007 38 2008 44 601 2009 42 2010 41 59 569 2011 40 41 601 59 865 2012 40 569 2013 41 59 773 58 2000 40 2002 42 2014 44 601 2007 38 2015 41 59 773 58 2002 42 2014 61 753 59 2007 2015 59 125 59 ,"{'AvgLine': 14, 'CountLine': 132, 'CountStmt': 45, 'MaxNesting': 3, 'AvgLineCode': 11, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 30, 'MaxEssential': 1, 'SumEssential': 8, 'AvgCyclomatic': 2, 'CountLineCode': 108, 'CountStmtDecl': 19, 'MaxCyclomatic': 12, 'SumCyclomatic': 19, 'AltAvgLineCode': 11, 'AvgLineComment': 1, 'CountClassBase': 0, 'CountLineBlank': 15, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 8, 'AltCountLineCode': 108, 'CountLineCodeExe': 31, 'CountLineComment': 9, 'AltAvgLineComment': 1, 'AltCountLineBlank': 15, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 16, 'CountLineInactive': 0, 'CountDeclMethodAll': 8, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.08', 'AltCountLineComment': 9, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 13, 'SumCyclomaticStrict': 20, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 8, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 12, 'PercentLackOfCohesion': 70, 'SumCyclomaticModified': 19, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 10, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 2, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 1, 'CountDeclInstanceVariableProtected': 0}"
117665,C++,"class VehicleAcceleration : public ModuleParams, public px4::ScheduledWorkItem
{
public:
	VehicleAcceleration();
	~VehicleAcceleration() override;

	bool Start();
	void Stop();

	void PrintStatus();

private:
	void Run() override;

	void CheckAndUpdateFilters();
	void ParametersUpdate(bool force = false);
	void SensorBiasUpdate(bool force = false);
	bool SensorSelectionUpdate(bool force = false);

	static constexpr int MAX_SENSOR_COUNT = 4;

	uORB::Publication<vehicle_acceleration_s> _vehicle_acceleration_pub{ORB_ID(vehicle_acceleration)};

	uORB::Subscription _estimator_selector_status_sub{ORB_ID(estimator_selector_status)};
	uORB::Subscription _estimator_sensor_bias_sub{ORB_ID(estimator_sensor_bias)};

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};

	uORB::SubscriptionCallbackWorkItem _sensor_selection_sub{this, ORB_ID(sensor_selection)};
	uORB::SubscriptionCallbackWorkItem _sensor_sub{this, ORB_ID(sensor_accel)};

	calibration::Accelerometer _calibration{};

	matrix::Vector3f _bias{};

	matrix::Vector3f _acceleration_prev{};

	float _filter_sample_rate{NAN};

	math::LowPassFilter2p<matrix::Vector3f> _lp_filter{};

	DEFINE_PARAMETERS(
		(ParamFloat<px4::params::IMU_ACCEL_CUTOFF>) _param_imu_accel_cutoff,
		(ParamInt<px4::params::IMU_INTEG_RATE>) _param_imu_integ_rate
	)
};",1,587 2000 58 777 2001 44 777 2002 321 2003 123 777 58 2000 40 41 59 126 2000 40 41 2004 59 569 2005 40 41 59 865 2006 40 41 59 865 2007 40 41 59 773 58 865 2008 40 41 2004 59 865 2009 40 41 59 865 2010 40 569 2011 61 655 41 59 865 2012 40 569 2011 61 655 41 59 569 2013 40 569 2011 61 655 41 59 809 603 704 2014 61 1502 59 2015 321 2016 60 2017 62 2018 123 2019 40 2020 41 125 59 2015 321 2021 2022 123 2023 40 2024 41 125 59 2015 321 2021 2025 123 2026 40 2027 41 125 59 2015 321 2028 2029 123 2030 40 2031 41 44 1501 125 59 2015 321 2032 2033 123 823 44 2034 40 2035 41 125 59 2015 321 2032 2036 123 823 44 2037 40 2038 41 125 59 2039 321 2040 2041 123 125 59 2042 321 2043 2044 123 125 59 2042 321 2043 2045 123 125 59 660 2046 123 2047 125 59 2048 321 2049 60 2042 321 2043 62 2050 123 125 59 2051 40 40 2052 60 2002 321 2053 321 2054 62 41 2055 44 40 2056 60 2002 321 2053 321 2057 62 41 2058 41 125 59 ,"{'AvgLine': 19, 'CountLine': 257, 'CountStmt': 90, 'MaxNesting': 5, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 3, 'CountStmtExe': 51, 'MaxEssential': 6, 'SumEssential': 21, 'AvgCyclomatic': 3, 'CountLineCode': 181, 'CountStmtDecl': 45, 'MaxCyclomatic': 7, 'SumCyclomatic': 34, 'AltAvgLineCode': 14, 'AvgLineComment': 2, 'CountClassBase': 2, 'CountLineBlank': 55, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 3, 'CountDeclMethod': 11, 'AltCountLineCode': 181, 'CountLineCodeExe': 33, 'CountLineComment': 21, 'AltAvgLineComment': 2, 'AltCountLineBlank': 55, 'CountClassCoupled': 7, 'CountClassDerived': 0, 'CountLineCodeDecl': 32, 'CountLineInactive': 0, 'CountDeclMethodAll': 55, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.12', 'AltCountLineComment': 21, 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 7, 'SumCyclomaticStrict': 35, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 5, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 96, 'SumCyclomaticModified': 34, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 5, 'CountDeclInstanceMethod': 13, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 13, 'CountDeclInstanceVariablePublic': 10, 'CountDeclInstanceVariablePrivate': 3, 'CountDeclInstanceVariableProtected': 0}"
118565,C++,"class CameraSource : public VideoSource
{
    Q_OBJECT

public:
    static CameraSource& getInstance();
    static void destroyInstance();
    void setupDefault();
    bool isNone() const;

    // VideoSource interface
    void subscribe() override;
    void unsubscribe() override;

public slots:
    void setupDevice(const QString& deviceName, const VideoMode& mode);

signals:
    void deviceOpened();
    void openFailed();

private:
    CameraSource();
    ~CameraSource();
    void stream();

private slots:
    void openDevice();
    void closeDevice();

private:
    QFuture<void> streamFuture;
    QThread* deviceThread;

    QString deviceName;
    CameraDevice* device;
    VideoMode mode;
    AVCodecContext* cctx;
    // TODO: Remove when ffmpeg version will be bumped to the 3.1.0
    AVCodecContext* cctxOrig;
    int videoStreamIndex;

    QReadWriteLock deviceMutex;
    QReadWriteLock streamMutex;

    std::atomic_bool _isNone;
    std::atomic_int subscriptions;

    static CameraSource* instance;
};",1,587 2000 58 777 2001 123 2002 777 58 809 2000 38 2003 40 41 59 809 865 2004 40 41 59 865 2005 40 41 59 569 2006 40 41 601 59 330 865 2007 40 41 2008 59 865 2009 40 41 2008 59 777 2010 58 865 2011 40 601 2012 38 2013 44 601 2014 38 2015 41 59 2016 58 865 2017 40 41 59 865 2018 40 41 59 773 58 2000 40 41 59 126 2000 40 41 59 865 2019 40 41 59 773 2010 58 865 2020 40 41 59 865 2021 40 41 59 773 58 2022 60 865 62 2023 59 2024 42 2025 59 2012 2013 59 2026 42 2027 59 2014 2015 59 2028 42 2029 59 330 2028 42 2030 59 704 2031 59 2032 2033 59 2032 2034 59 2035 321 2036 2037 59 2035 321 2038 2039 59 809 2000 42 2040 59 125 59 ,"{'AvgLine': 0, 'CountLine': 50, 'CountStmt': 26, 'MaxNesting': 0, 'AvgLineCode': 0, 'AvgEssential': 0, 'AvgLineBlank': 0, 'CountStmtExe': 0, 'MaxEssential': 0, 'SumEssential': 0, 'AvgCyclomatic': 0, 'CountLineCode': 37, 'CountStmtDecl': 26, 'MaxCyclomatic': 0, 'SumCyclomatic': 0, 'AltAvgLineCode': 0, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 11, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 10, 'AltCountLineCode': 37, 'CountLineCodeExe': 0, 'CountLineComment': 2, 'AltAvgLineComment': 0, 'AltCountLineBlank': 11, 'CountClassCoupled': 4, 'CountClassDerived': 0, 'CountLineCodeDecl': 1, 'CountLineInactive': 0, 'CountDeclMethodAll': 15, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.05', 'AltCountLineComment': 2, 'AvgCyclomaticStrict': 0, 'MaxCyclomaticStrict': 0, 'SumCyclomaticStrict': 0, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 1, 'AvgCyclomaticModified': 0, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 1, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 0, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 0, 'CountDeclClassVariable': 1, 'CountDeclMethodPrivate': 9, 'CountDeclInstanceMethod': 11, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 15, 'CountDeclInstanceVariablePublic': 9, 'CountDeclInstanceVariablePrivate': 6, 'CountDeclInstanceVariableProtected': 0}"
118140,C++,"class FixedwingPositionControl final : public ModuleBase<FixedwingPositionControl>, public ModuleParams,
	public px4::WorkItem
{
public:
	FixedwingPositionControl(bool vtol = false);
	~FixedwingPositionControl() override;

	/** @see ModuleBase */
	static int task_spawn(int argc, char *argv[]);

	/** @see ModuleBase */
	static int custom_command(int argc, char *argv[]);

	/** @see ModuleBase */
	static int print_usage(const char *reason = nullptr);

	bool init();

private:
	void Run() override;

	orb_advert_t	_mavlink_log_pub{nullptr};

	uORB::SubscriptionCallbackWorkItem _local_pos_sub{this, ORB_ID(vehicle_local_position)};

	uORB::SubscriptionInterval _parameter_update_sub{ORB_ID(parameter_update), 1_s};

	uORB::Subscription _airspeed_validated_sub{ORB_ID(airspeed_validated)};
	uORB::Subscription _control_mode_sub{ORB_ID(vehicle_control_mode)};
	uORB::Subscription _global_pos_sub{ORB_ID(vehicle_global_position)};
	uORB::Subscription _manual_control_setpoint_sub{ORB_ID(manual_control_setpoint)};
	uORB::Subscription _pos_sp_triplet_sub{ORB_ID(position_setpoint_triplet)};
	uORB::Subscription _trajectory_setpoint_sub{ORB_ID(trajectory_setpoint)};
	uORB::Subscription _vehicle_air_data_sub{ORB_ID(vehicle_air_data)};
	uORB::Subscription _vehicle_angular_velocity_sub{ORB_ID(vehicle_angular_velocity)};
	uORB::Subscription _vehicle_attitude_sub{ORB_ID(vehicle_attitude)};
	uORB::Subscription _vehicle_command_sub{ORB_ID(vehicle_command)};
	uORB::Subscription _vehicle_land_detected_sub{ORB_ID(vehicle_land_detected)};
	uORB::Subscription _vehicle_status_sub{ORB_ID(vehicle_status)};

	uORB::Publication<vehicle_attitude_setpoint_s>		_attitude_sp_pub;
	uORB::Publication<position_controller_status_s>		_pos_ctrl_status_pub{ORB_ID(position_controller_status)};			///< navigation capabilities publication
	uORB::Publication<position_controller_landing_status_s>	_pos_ctrl_landing_status_pub{ORB_ID(position_controller_landing_status)};	///< landing status publication
	uORB::Publication<tecs_status_s>			_tecs_status_pub{ORB_ID(tecs_status)};						///< TECS status publication
	uORB::PublicationMulti<orbit_status_s>			_orbit_status_pub{ORB_ID(orbit_status)};

	manual_control_setpoint_s	_manual_control_setpoint {};			///< r/c channel data
	position_setpoint_triplet_s	_pos_sp_triplet {};		///< triplet of mission items
	vehicle_attitude_setpoint_s	_att_sp {};			///< vehicle attitude setpoint
	vehicle_control_mode_s		_control_mode {};		///< control mode
	vehicle_local_position_s	_local_pos {};			///< vehicle local position
	vehicle_status_s		_vehicle_status {};		///< vehicle status

	double _current_latitude{0};
	double _current_longitude{0};
	float _current_altitude{0.f};

	perf_counter_t	_loop_perf;				///< loop performance counter

	MapProjection _global_local_proj_ref{};
	float	_global_local_alt0{NAN};

	float	_takeoff_ground_alt{0.0f};			///< ground altitude at which plane was launched
	float	_hdg_hold_yaw{0.0f};				///< hold heading for velocity mode
	bool	_hdg_hold_enabled{false};			///< heading hold enabled
	bool	_yaw_lock_engaged{false};			///< yaw is locked for heading hold

	float	_min_current_sp_distance_xy{FLT_MAX};

	position_setpoint_s _hdg_hold_prev_wp {};		///< position where heading hold started
	position_setpoint_s _hdg_hold_curr_wp {};		///< position to which heading hold flies

	hrt_abstime _control_position_last_called{0};		///< last call of control_position

	bool _landed{true};

	/* Landing */
	bool _land_noreturn_horizontal{false};
	bool _land_noreturn_vertical{false};
	bool _land_stayonground{false};
	bool _land_motor_lim{false};
	bool _land_onslope{false};
	bool _land_abort{false};

	Landingslope _landingslope;

	hrt_abstime _time_started_landing{0};			///< time at which landing started

	float _t_alt_prev_valid{0};				///< last terrain estimate which was valid
	hrt_abstime _time_last_t_alt{0};			///< time at which we had last valid terrain alt

	float _flare_height{0.0f};				///< estimated height to ground at which flare started
	float _flare_pitch_sp{0.0f};			///< Current forced (i.e. not determined using TECS) flare pitch setpoint
	float _flare_curve_alt_rel_last{0.0f};
	float _target_bearing{0.0f};				///< estimated height to ground at which flare started

	bool _was_in_air{false};				///< indicated wether the plane was in the air in the previous interation*/
	hrt_abstime _time_went_in_air{0};			///< time at which the plane went in the air

	/* Takeoff launch detection and runway */
	LaunchDetector _launchDetector;
	LaunchDetectionResult _launch_detection_state{LAUNCHDETECTION_RES_NONE};
	hrt_abstime _launch_detection_notify{0};

	RunwayTakeoff _runway_takeoff;

	bool _last_manual{false};				///< true if the last iteration was in manual mode (used to determine when a reset is needed)

	/* throttle and airspeed states */
	bool _airspeed_valid{false};				///< flag if a valid airspeed estimate exists
	hrt_abstime _airspeed_last_valid{0};			///< last time airspeed was received. Used to detect timeouts.
	float _airspeed{0.0f};
	float _eas2tas{1.0f};

	float _pitch{0.0f};
	float _yaw{0.0f};
	float _yawrate{0.0f};

	matrix::Vector3f _body_acceleration{};
	matrix::Vector3f _body_velocity{};

	bool _reinitialize_tecs{true};				///< indicates if the TECS states should be reinitialized (used for VTOL)
	bool _is_tecs_running{false};
	hrt_abstime _last_tecs_update{0};

	float _asp_after_transition{0.0f};
	bool _was_in_transition{false};

	bool _vtol_tailsitter{false};

	matrix::Vector2d _transition_waypoint{(double)NAN, (double)NAN};

	// estimator reset counters
	uint8_t _pos_reset_counter{0};				///< captures the number of times the estimator has reset the horizontal position
	uint8_t _alt_reset_counter{0};				///< captures the number of times the estimator has reset the altitude state

	float _manual_control_setpoint_altitude{0.0f};
	float _manual_control_setpoint_airspeed{0.0f};

	hrt_abstime _time_in_fixed_bank_loiter{0};

	ECL_L1_Pos_Controller	_l1_control;
	TECS			_tecs;

	uint8_t _position_sp_type{0};
	enum FW_POSCTRL_MODE {
		FW_POSCTRL_MODE_AUTO,
		FW_POSCTRL_MODE_AUTO_ALTITUDE,
		FW_POSCTRL_MODE_AUTO_CLIMBRATE,
		FW_POSCTRL_MODE_MANUAL_POSITION,
		FW_POSCTRL_MODE_MANUAL_ALTITUDE,
		FW_POSCTRL_MODE_OTHER
	} _control_mode_current{FW_POSCTRL_MODE_OTHER};		///< used to check the mode in the last control loop iteration. Use to check if the last iteration was in the same mode.

	param_t _param_handle_airspeed_trans{PARAM_INVALID};
	float _param_airspeed_trans{NAN};

	// Update our local parameter cache.
	int		parameters_update();

	// Update subscriptions
	void		airspeed_poll();
	void		control_update();
	void 		manual_control_setpoint_poll();
	void		vehicle_attitude_poll();
	void		vehicle_command_poll();
	void		vehicle_control_mode_poll();
	void		vehicle_status_poll();

	void		status_publish();
	void		landing_status_publish();
	void		tecs_status_publish();

	void		abort_landing(bool abort);

	/**
	 * Get a new waypoint based on heading and distance from current position
	 *
	 * @param heading the heading to fly to
	 * @param distance the distance of the generated waypoint
	 * @param waypoint_prev the waypoint at the current position
	 * @param waypoint_next the waypoint in the heading direction
	 */
	void		get_waypoint_heading_distance(float heading, position_setpoint_s &waypoint_prev,
			position_setpoint_s &waypoint_next, bool flag_init);

	/**
	 * Return the terrain estimate during takeoff or takeoff_alt if terrain estimate is not available
	 */
	float		get_terrain_altitude_takeoff(float takeoff_alt);

	float getManualHeightRateSetpoint();

	/**
	 * Check if we are in a takeoff situation
	 */
	bool 		in_takeoff_situation();

	/**
	 * Update desired altitude base on user pitch stick input
	 *
	 * @param dt Time step
	 */
	void		update_desired_altitude(float dt);
	uint8_t		handle_setpoint_type(const uint8_t setpoint_type, const position_setpoint_s &pos_sp_curr);
	void		control_auto(const hrt_abstime &now, const Vector2d &curr_pos, const Vector2f &ground_speed,
				     const position_setpoint_s &pos_sp_prev,
				     const position_setpoint_s &pos_sp_curr, const position_setpoint_s &pos_sp_next);

	void		control_auto_fixed_bank_alt_hold(const hrt_abstime &now);
	void		control_auto_descend(const hrt_abstime &now);

	void		control_auto_position(const hrt_abstime &now, const Vector2d &curr_pos, const Vector2f &ground_speed,
					      const position_setpoint_s &pos_sp_prev, const position_setpoint_s &pos_sp_curr);
	void		control_auto_loiter(const hrt_abstime &now, const Vector2d &curr_pos, const Vector2f &ground_speed,
					    const position_setpoint_s &pos_sp_prev, const position_setpoint_s &pos_sp_curr, const position_setpoint_s &pos_sp_next);
	void		control_auto_takeoff(const hrt_abstime &now, const float dt,  const Vector2d &curr_pos,
					     const Vector2f &ground_speed,
					     const position_setpoint_s &pos_sp_prev,
					     const position_setpoint_s &pos_sp_curr);
	void		control_auto_landing(const hrt_abstime &now, const Vector2d &curr_pos, const Vector2f &ground_speed,
					     const position_setpoint_s &pos_sp_prev,
					     const position_setpoint_s &pos_sp_curr);
	void		control_manual_altitude(const hrt_abstime &now, const Vector2d &curr_pos, const Vector2f &ground_speed);
	void		control_manual_position(const hrt_abstime &now, const Vector2d &curr_pos, const Vector2f &ground_speed);

	float		get_tecs_pitch();
	float		get_tecs_thrust();

	float		get_demanded_airspeed();
	float		calculate_target_airspeed(float airspeed_demand, const Vector2f &ground_speed);

	void		reset_takeoff_state(bool force = false);
	void		reset_landing_state();
	Vector2f 	get_nav_speed_2d(const Vector2f &ground_speed);
	void		set_control_mode_current(const hrt_abstime &now, bool pos_sp_curr_valid);

	void publishOrbitStatus(const position_setpoint_s pos_sp);

	/*
	 * Call TECS : a wrapper function to call the TECS implementation
	 */
	void tecs_update_pitch_throttle(const hrt_abstime &now, float alt_sp, float airspeed_sp,
					float pitch_min_rad, float pitch_max_rad,
					float throttle_min, float throttle_max, float throttle_cruise,
					bool climbout_mode, float climbout_pitch_min_rad,
					uint8_t mode = tecs_status_s::TECS_MODE_NORMAL, float hgt_rate_sp = NAN);

	DEFINE_PARAMETERS(

		(ParamFloat<px4::params::FW_AIRSPD_MAX>) _param_fw_airspd_max,
		(ParamFloat<px4::params::FW_AIRSPD_MIN>) _param_fw_airspd_min,
		(ParamFloat<px4::params::FW_AIRSPD_TRIM>) _param_fw_airspd_trim,
		(ParamFloat<px4::params::FW_AIRSPD_STALL>) _param_fw_airspd_stall,

		(ParamFloat<px4::params::FW_CLMBOUT_DIFF>) _param_fw_clmbout_diff,

		(ParamFloat<px4::params::FW_GND_SPD_MIN>) _param_fw_gnd_spd_min,

		(ParamFloat<px4::params::FW_L1_DAMPING>) _param_fw_l1_damping,
		(ParamFloat<px4::params::FW_L1_PERIOD>) _param_fw_l1_period,
		(ParamFloat<px4::params::FW_L1_R_SLEW_MAX>) _param_fw_l1_r_slew_max,
		(ParamFloat<px4::params::FW_R_LIM>) _param_fw_r_lim,

		(ParamFloat<px4::params::FW_LND_AIRSPD_SC>) _param_fw_lnd_airspd_sc,
		(ParamFloat<px4::params::FW_LND_ANG>) _param_fw_lnd_ang,
		(ParamFloat<px4::params::FW_LND_FL_PMAX>) _param_fw_lnd_fl_pmax,
		(ParamFloat<px4::params::FW_LND_FL_PMIN>) _param_fw_lnd_fl_pmin,
		(ParamFloat<px4::params::FW_LND_FLALT>) _param_fw_lnd_flalt,
		(ParamFloat<px4::params::FW_LND_HHDIST>) _param_fw_lnd_hhdist,
		(ParamFloat<px4::params::FW_LND_HVIRT>) _param_fw_lnd_hvirt,
		(ParamFloat<px4::params::FW_LND_THRTC_SC>) _param_fw_thrtc_sc,
		(ParamFloat<px4::params::FW_LND_TLALT>) _param_fw_lnd_tlalt,
		(ParamBool<px4::params::FW_LND_EARLYCFG>) _param_fw_lnd_earlycfg,
		(ParamBool<px4::params::FW_LND_USETER>) _param_fw_lnd_useter,

		(ParamFloat<px4::params::FW_P_LIM_MAX>) _param_fw_p_lim_max,
		(ParamFloat<px4::params::FW_P_LIM_MIN>) _param_fw_p_lim_min,

		(ParamFloat<px4::params::FW_T_CLMB_MAX>) _param_fw_t_clmb_max,
		(ParamFloat<px4::params::FW_T_HRATE_FF>) _param_fw_t_hrate_ff,
		(ParamFloat<px4::params::FW_T_ALT_TC>) _param_fw_t_h_error_tc,
		(ParamFloat<px4::params::FW_T_I_GAIN_THR>) _param_fw_t_I_gain_thr,
		(ParamFloat<px4::params::FW_T_I_GAIN_PIT>) _param_fw_t_I_gain_pit,
		(ParamFloat<px4::params::FW_T_PTCH_DAMP>) _param_fw_t_ptch_damp,
		(ParamFloat<px4::params::FW_T_RLL2THR>) _param_fw_t_rll2thr,
		(ParamFloat<px4::params::FW_T_SINK_MAX>) _param_fw_t_sink_max,
		(ParamFloat<px4::params::FW_T_SINK_MIN>) _param_fw_t_sink_min,
		(ParamFloat<px4::params::FW_T_SPD_OMEGA>) _param_fw_t_spd_omega,
		(ParamFloat<px4::params::FW_T_SPDWEIGHT>) _param_fw_t_spdweight,
		(ParamFloat<px4::params::FW_T_TAS_TC>) _param_fw_t_tas_error_tc,
		(ParamFloat<px4::params::FW_T_THR_DAMP>) _param_fw_t_thr_damp,
		(ParamFloat<px4::params::FW_T_VERT_ACC>) _param_fw_t_vert_acc,
		(ParamFloat<px4::params::FW_T_STE_R_TC>) _param_ste_rate_time_const,
		(ParamFloat<px4::params::FW_T_TAS_R_TC>) _param_tas_rate_time_const,
		(ParamFloat<px4::params::FW_T_SEB_R_FF>) _param_seb_rate_ff,
		(ParamFloat<px4::params::FW_T_CLMB_R_SP>) _param_climbrate_target,
		(ParamFloat<px4::params::FW_T_SINK_R_SP>) _param_sinkrate_target,

		(ParamFloat<px4::params::FW_THR_ALT_SCL>) _param_fw_thr_alt_scl,
		(ParamFloat<px4::params::FW_THR_CRUISE>) _param_fw_thr_cruise,
		(ParamFloat<px4::params::FW_THR_IDLE>) _param_fw_thr_idle,
		(ParamFloat<px4::params::FW_THR_LND_MAX>) _param_fw_thr_lnd_max,
		(ParamFloat<px4::params::FW_THR_MAX>) _param_fw_thr_max,
		(ParamFloat<px4::params::FW_THR_MIN>) _param_fw_thr_min,
		(ParamFloat<px4::params::FW_THR_SLEW_MAX>) _param_fw_thr_slew_max,

		(ParamBool<px4::params::FW_POSCTL_INV_ST>) _param_fw_posctl_inv_st,


		(ParamInt<px4::params::FW_GPSF_LT>) _param_nav_gpsf_lt,
		(ParamFloat<px4::params::FW_GPSF_R>) _param_nav_gpsf_r,

		// external parameters
		(ParamInt<px4::params::FW_ARSP_MODE>) _param_fw_arsp_mode,

		(ParamFloat<px4::params::FW_PSP_OFF>) _param_fw_psp_off,
		(ParamFloat<px4::params::FW_MAN_P_MAX>) _param_fw_man_p_max,
		(ParamFloat<px4::params::FW_MAN_R_MAX>) _param_fw_man_r_max,

		(ParamFloat<px4::params::NAV_LOITER_RAD>) _param_nav_loiter_rad,

		(ParamFloat<px4::params::FW_TKO_PITCH_MIN>) _takeoff_pitch_min

	)

};",1,587 2000 2001 58 777 2002 60 2000 62 44 777 2003 44 777 2004 321 2005 123 777 58 2000 40 569 2006 61 655 41 59 126 2000 40 41 2007 59 306 809 704 2008 40 704 2009 44 582 42 2010 91 93 41 59 306 809 704 2011 40 704 2009 44 582 42 2010 91 93 41 59 306 809 704 2012 40 601 582 42 2013 61 753 41 59 569 2014 40 41 59 773 58 865 2015 40 41 2007 59 2016 2017 123 753 125 59 2018 321 2019 2020 123 823 44 2021 40 2022 41 125 59 2018 321 2023 2024 123 2025 40 2026 41 44 1501 125 59 2018 321 2027 2028 123 2029 40 2030 41 125 59 2018 321 2027 2031 123 2032 40 2033 41 125 59 2018 321 2027 2034 123 2035 40 2036 41 125 59 2018 321 2027 2037 123 2038 40 2039 41 125 59 2018 321 2027 2040 123 2041 40 2042 41 125 59 2018 321 2027 2043 123 2044 40 2045 41 125 59 2018 321 2027 2046 123 2047 40 2048 41 125 59 2018 321 2027 2049 123 2050 40 2051 41 125 59 2018 321 2027 2052 123 2053 40 2054 41 125 59 2018 321 2027 2055 123 2056 40 2057 41 125 59 2018 321 2027 2058 123 2059 40 2060 41 125 59 2018 321 2027 2061 123 2062 40 2063 41 125 59 2018 321 2064 60 2065 62 2066 59 2018 321 2064 60 2067 62 2068 123 2069 40 2070 41 125 59 331 2018 321 2064 60 2071 62 2072 123 2073 40 2074 41 125 59 331 2018 321 2064 60 2075 62 2076 123 2077 40 2078 41 125 59 331 2018 321 2079 60 2080 62 2081 123 2082 40 2083 41 125 59 2084 2085 123 125 59 331 2086 2087 123 125 59 331 2065 2088 123 125 59 331 2089 2090 123 125 59 331 2091 2092 123 125 59 331 2093 2094 123 125 59 331 625 2095 123 1500 125 59 625 2096 123 1500 125 59 660 2097 123 1500 125 59 2098 2099 59 331 2100 2101 123 125 59 660 2102 123 2103 125 59 660 2104 123 1500 125 59 331 660 2105 123 1500 125 59 331 569 2106 123 655 125 59 331 569 2107 123 655 125 59 331 660 2108 123 2109 125 59 2110 2111 123 125 59 331 2110 2112 123 125 59 331 2113 2114 123 1500 125 59 331 569 2115 123 829 125 59 305 569 2116 123 655 125 59 569 2117 123 655 125 59 569 2118 123 655 125 59 569 2119 123 655 125 59 569 2120 123 655 125 59 569 2121 123 655 125 59 2122 2123 59 2113 2124 123 1500 125 59 331 660 2125 123 1500 125 59 331 2113 2126 123 1500 125 59 331 660 2127 123 1500 125 59 331 660 2128 123 1500 125 59 331 660 2129 123 1500 125 59 660 2130 123 1500 125 59 331 569 2131 123 655 125 59 331 2113 2132 123 1500 125 59 331 305 2133 2134 59 2135 2136 123 2137 125 59 2113 2138 123 1500 125 59 2139 2140 59 569 2141 123 655 125 59 331 305 569 2142 123 655 125 59 331 2113 2143 123 1500 125 59 331 660 2144 123 1500 125 59 660 2145 123 1501 125 59 660 2146 123 1500 125 59 660 2147 123 1500 125 59 660 2148 123 1500 125 59 2149 321 2150 2151 123 125 59 2149 321 2150 2152 123 125 59 569 2153 123 829 125 59 331 569 2154 123 655 125 59 2113 2155 123 1500 125 59 660 2156 123 1500 125 59 569 2157 123 655 125 59 569 2158 123 655 125 59 2149 321 2159 2160 123 40 625 41 2161 44 40 625 41 2161 125 59 330 2162 2163 123 1500 125 59 331 2162 2164 123 1500 125 59 331 660 2165 123 1500 125 59 660 2166 123 1500 125 59 2113 2167 123 1500 125 59 2168 2169 59 2170 2171 59 2162 2172 123 1500 125 59 640 2173 123 2174 44 2175 44 2176 44 2177 44 2178 44 2179 125 2180 123 2181 125 59 331 2182 2183 123 2184 125 59 660 2185 123 2186 125 59 330 704 2187 40 41 59 330 865 2188 40 41 59 865 2189 40 41 59 865 2190 40 41 59 865 2191 40 41 59 865 2192 40 41 59 865 2193 40 41 59 865 2194 40 41 59 865 2195 40 41 59 865 2196 40 41 59 865 2197 40 41 59 865 2198 40 569 2199 41 59 306 865 2200 40 660 2201 44 2110 38 2202 44 2110 38 2203 44 569 2204 41 59 306 660 2205 40 660 2206 41 59 660 2207 40 41 59 306 569 2208 40 41 59 306 865 2209 40 660 2210 41 59 2162 2211 40 601 2162 2212 44 601 2110 38 2213 41 59 865 2214 40 601 2113 38 2215 44 601 2159 38 2216 44 601 2217 38 2218 44 601 2110 38 2219 44 601 2110 38 2213 44 601 2110 38 2220 41 59 865 2221 40 601 2113 38 2215 41 59 865 2222 40 601 2113 38 2215 41 59 865 2223 40 601 2113 38 2215 44 601 2159 38 2216 44 601 2217 38 2218 44 601 2110 38 2219 44 601 2110 38 2213 41 59 865 2224 40 601 2113 38 2215 44 601 2159 38 2216 44 601 2217 38 2218 44 601 2110 38 2219 44 601 2110 38 2213 44 601 2110 38 2220 41 59 865 2225 40 601 2113 38 2215 44 601 660 2210 44 601 2159 38 2216 44 601 2217 38 2218 44 601 2110 38 2219 44 601 2110 38 2213 41 59 865 2226 40 601 2113 38 2215 44 601 2159 38 2216 44 601 2217 38 2218 44 601 2110 38 2219 44 601 2110 38 2213 41 59 865 2227 40 601 2113 38 2215 44 601 2159 38 2216 44 601 2217 38 2218 41 59 865 2228 40 601 2113 38 2215 44 601 2159 38 2216 44 601 2217 38 2218 41 59 660 2229 40 41 59 660 2230 40 41 59 660 2231 40 41 59 660 2232 40 660 2233 44 601 2217 38 2218 41 59 865 2234 40 569 2235 61 655 41 59 865 2236 40 41 59 2217 2237 40 601 2217 38 2218 41 59 865 2238 40 601 2113 38 2215 44 569 2239 41 59 865 2240 40 601 2110 2241 41 59 305 865 2242 40 601 2113 38 2215 44 660 2243 44 660 2244 44 660 2245 44 660 2246 44 660 2247 44 660 2248 44 660 2249 44 569 2250 44 660 2251 44 2162 2252 61 2075 321 2253 44 660 2254 61 2255 41 59 2256 40 40 2257 60 2004 321 2258 321 2259 62 41 2260 44 40 2257 60 2004 321 2258 321 2261 62 41 2262 44 40 2257 60 2004 321 2258 321 2263 62 41 2264 44 40 2257 60 2004 321 2258 321 2265 62 41 2266 44 40 2257 60 2004 321 2258 321 2267 62 41 2268 44 40 2257 60 2004 321 2258 321 2269 62 41 2270 44 40 2257 60 2004 321 2258 321 2271 62 41 2272 44 40 2257 60 2004 321 2258 321 2273 62 41 2274 44 40 2257 60 2004 321 2258 321 2275 62 41 2276 44 40 2257 60 2004 321 2258 321 2277 62 41 2278 44 40 2257 60 2004 321 2258 321 2279 62 41 2280 44 40 2257 60 2004 321 2258 321 2281 62 41 2282 44 40 2257 60 2004 321 2258 321 2283 62 41 2284 44 40 2257 60 2004 321 2258 321 2285 62 41 2286 44 40 2257 60 2004 321 2258 321 2287 62 41 2288 44 40 2257 60 2004 321 2258 321 2289 62 41 2290 44 40 2257 60 2004 321 2258 321 2291 62 41 2292 44 40 2257 60 2004 321 2258 321 2293 62 41 2294 44 40 2257 60 2004 321 2258 321 2295 62 41 2296 44 40 2297 60 2004 321 2258 321 2298 62 41 2299 44 40 2297 60 2004 321 2258 321 2300 62 41 2301 44 40 2257 60 2004 321 2258 321 2302 62 41 2303 44 40 2257 60 2004 321 2258 321 2304 62 41 2305 44 40 2257 60 2004 321 2258 321 2306 62 41 2307 44 40 2257 60 2004 321 2258 321 2308 62 41 2309 44 40 2257 60 2004 321 2258 321 2310 62 41 2311 44 40 2257 60 2004 321 2258 321 2312 62 41 2313 44 40 2257 60 2004 321 2258 321 2314 62 41 2315 44 40 2257 60 2004 321 2258 321 2316 62 41 2317 44 40 2257 60 2004 321 2258 321 2318 62 41 2319 44 40 2257 60 2004 321 2258 321 2320 62 41 2321 44 40 2257 60 2004 321 2258 321 2322 62 41 2323 44 40 2257 60 2004 321 2258 321 2324 62 41 2325 44 40 2257 60 2004 321 2258 321 2326 62 41 2327 44 40 2257 60 2004 321 2258 321 2328 62 41 2329 44 40 2257 60 2004 321 2258 321 2330 62 41 2331 44 40 2257 60 2004 321 2258 321 2332 62 41 2333 44 40 2257 60 2004 321 2258 321 2334 62 41 2335 44 40 2257 60 2004 321 2258 321 2336 62 41 2337 44 40 2257 60 2004 321 2258 321 2338 62 41 2339 44 40 2257 60 2004 321 2258 321 2340 62 41 2341 44 40 2257 60 2004 321 2258 321 2342 62 41 2343 44 40 2257 60 2004 321 2258 321 2344 62 41 2345 44 40 2257 60 2004 321 2258 321 2346 62 41 2347 44 40 2257 60 2004 321 2258 321 2348 62 41 2349 44 40 2257 60 2004 321 2258 321 2350 62 41 2351 44 40 2257 60 2004 321 2258 321 2352 62 41 2353 44 40 2257 60 2004 321 2258 321 2354 62 41 2355 44 40 2257 60 2004 321 2258 321 2356 62 41 2357 44 40 2297 60 2004 321 2258 321 2358 62 41 2359 44 40 2360 60 2004 321 2258 321 2361 62 41 2362 44 40 2257 60 2004 321 2258 321 2363 62 41 2364 44 330 40 2360 60 2004 321 2258 321 2365 62 41 2366 44 40 2257 60 2004 321 2258 321 2367 62 41 2368 44 40 2257 60 2004 321 2258 321 2369 62 41 2370 44 40 2257 60 2004 321 2258 321 2371 62 41 2372 44 40 2257 60 2004 321 2258 321 2373 62 41 2374 44 40 2257 60 2004 321 2258 321 2375 62 41 2376 41 125 59 ,"{'AvgLine': 54, 'CountLine': 2525, 'CountStmt': 735, 'MaxNesting': 6, 'AvgLineCode': 36, 'AvgEssential': 1, 'AvgLineBlank': 10, 'CountStmtExe': 410, 'MaxEssential': 3, 'SumEssential': 44, 'AvgCyclomatic': 5, 'CountLineCode': 1668, 'CountStmtDecl': 320, 'MaxCyclomatic': 33, 'SumCyclomatic': 251, 'AltAvgLineCode': 36, 'AvgLineComment': 8, 'CountClassBase': 2, 'CountLineBlank': 503, 'CountStmtEmpty': 17, 'AltAvgLineBlank': 10, 'CountDeclMethod': 45, 'AltCountLineCode': 1668, 'CountLineCodeExe': 340, 'CountLineComment': 415, 'AltAvgLineComment': 8, 'AltCountLineBlank': 503, 'CountClassCoupled': 21, 'CountClassDerived': 0, 'CountLineCodeDecl': 181, 'CountLineInactive': 0, 'CountDeclMethodAll': 79, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.25', 'AltCountLineComment': 415, 'AvgCyclomaticStrict': 6, 'MaxCyclomaticStrict': 39, 'SumCyclomaticStrict': 267, 'CountDeclClassMethod': 3, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 5, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 15, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 33, 'PercentLackOfCohesion': 98, 'SumCyclomaticModified': 246, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 29, 'CountDeclInstanceMethod': 44, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 147, 'CountDeclInstanceVariablePublic': 92, 'CountDeclInstanceVariablePrivate': 55, 'CountDeclInstanceVariableProtected': 0}"
98654,C++,"class VRTMDArraySourceFromArray final: public VRTMDArraySource
{
    const VRTMDArray* m_poDstArray = nullptr;
    bool m_bRelativeToVRTSet = false;
    bool m_bRelativeToVRT = false;
    std::string m_osFilename{};
    std::string m_osArray{};
    std::string m_osBand{};
    std::vector<int> m_anTransposedAxis{};
    std::string m_osViewExpr{};
    std::vector<GUInt64> m_anSrcOffset{};
    mutable std::vector<GUInt64> m_anCount{};
    std::vector<GUInt64> m_anStep{};
    std::vector<GUInt64> m_anDstOffset{};

    VRTMDArraySourceFromArray(const VRTMDArraySourceFromArray&) = delete;
    VRTMDArraySourceFromArray& operator=(const VRTMDArraySourceFromArray&) = delete;

public:
    VRTMDArraySourceFromArray(const VRTMDArray* poDstArray,
                              bool bRelativeToVRTSet,
                              bool bRelativeToVRT,
                              const std::string& osFilename,
                              const std::string& osArray,
                              const std::string& osBand,
                              std::vector<int>&& anTransposedAxis,
                              const std::string& osViewExpr,
                              std::vector<GUInt64>&& anSrcOffset,
                              std::vector<GUInt64>&& anCount,
                              std::vector<GUInt64>&& anStep,
                              std::vector<GUInt64>&& anDstOffset):
        m_poDstArray(poDstArray),
        m_bRelativeToVRTSet(bRelativeToVRTSet),
        m_bRelativeToVRT(bRelativeToVRT),
        m_osFilename(osFilename),
        m_osArray(osArray),
        m_osBand(osBand),
        m_anTransposedAxis(std::move(anTransposedAxis)),
        m_osViewExpr(osViewExpr),
        m_anSrcOffset(std::move(anSrcOffset)),
        m_anCount(std::move(anCount)),
        m_anStep(std::move(anStep)),
        m_anDstOffset(std::move(anDstOffset))
    {
    }

    ~VRTMDArraySourceFromArray() override;

    static std::unique_ptr<VRTMDArraySourceFromArray> Create(
                                                const VRTMDArray* poDstArray,
                                                const CPLXMLNode* psNode);

    bool Read(const GUInt64* arrayStartIdx,
                      const size_t* count,
                      const GInt64* arrayStep,
                      const GPtrDiff_t* bufferStride,
                      const GDALExtendedDataType& bufferDataType,
                      void* pDstBuffer) const override;

    void Serialize(CPLXMLNode* psParent, const char* pszVRTPath) const override;
};",1,587 2000 2001 58 777 2002 123 601 2003 42 2004 61 753 59 569 2005 61 655 59 569 2006 61 655 59 2007 321 2008 2009 123 125 59 2007 321 2008 2010 123 125 59 2007 321 2008 2011 123 125 59 2007 321 2012 60 704 62 2013 123 125 59 2007 321 2008 2014 123 125 59 2007 321 2012 60 2015 62 2016 123 125 59 740 2007 321 2012 60 2015 62 2017 123 125 59 2007 321 2012 60 2015 62 2018 123 125 59 2007 321 2012 60 2015 62 2019 123 125 59 2000 40 601 2000 38 41 61 619 59 2000 38 758 61 40 601 2000 38 41 61 619 59 777 58 2000 40 601 2003 42 2020 44 569 2021 44 569 2022 44 601 2007 321 2008 38 2023 44 601 2007 321 2008 38 2024 44 601 2007 321 2008 38 2025 44 2007 321 2012 60 704 62 307 2026 44 601 2007 321 2008 38 2027 44 2007 321 2012 60 2015 62 307 2028 44 2007 321 2012 60 2015 62 307 2029 44 2007 321 2012 60 2015 62 307 2030 44 2007 321 2012 60 2015 62 307 2031 41 58 2004 40 2020 41 44 2005 40 2021 41 44 2006 40 2022 41 44 2009 40 2023 41 44 2010 40 2024 41 44 2011 40 2025 41 44 2013 40 2007 321 2032 40 2026 41 41 44 2014 40 2027 41 44 2016 40 2007 321 2032 40 2028 41 41 44 2017 40 2007 321 2032 40 2029 41 41 44 2018 40 2007 321 2032 40 2030 41 41 44 2019 40 2007 321 2032 40 2031 41 41 123 125 126 2000 40 41 2033 59 809 2007 321 2034 60 2000 62 2035 40 601 2003 42 2020 44 601 2036 42 2037 41 59 569 2038 40 601 2015 42 2039 44 601 2040 42 2041 44 601 2042 42 2043 44 601 2044 42 2045 44 601 2046 38 2047 44 865 42 2048 41 601 2033 59 865 2049 40 2036 42 2050 44 601 582 42 2051 41 601 2033 59 125 59 ,"{'AvgLine': 106, 'CountLine': 567, 'CountStmt': 186, 'MaxNesting': 5, 'AvgLineCode': 99, 'AvgEssential': 3, 'AvgLineBlank': 4, 'CountStmtExe': 125, 'MaxEssential': 12, 'SumEssential': 16, 'AvgCyclomatic': 9, 'CountLineCode': 527, 'CountStmtDecl': 107, 'MaxCyclomatic': 24, 'SumCyclomatic': 49, 'AltAvgLineCode': 99, 'AvgLineComment': 2, 'CountClassBase': 1, 'CountLineBlank': 30, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 4, 'CountDeclMethod': 7, 'AltCountLineCode': 527, 'CountLineCodeExe': 142, 'CountLineComment': 11, 'AltAvgLineComment': 2, 'AltCountLineBlank': 30, 'CountClassCoupled': 11, 'CountClassDerived': 0, 'CountLineCodeDecl': 135, 'CountLineInactive': 0, 'CountDeclMethodAll': 10, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.02', 'AltCountLineComment': 11, 'AvgCyclomaticStrict': 10, 'MaxCyclomaticStrict': 26, 'SumCyclomaticStrict': 51, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 9, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 5, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 24, 'PercentLackOfCohesion': 76, 'SumCyclomaticModified': 49, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 12, 'CountDeclInstanceVariablePublic': 5, 'CountDeclInstanceVariablePrivate': 7, 'CountDeclInstanceVariableProtected': 0}"
118461,C++,"class ToxCall : public QObject
{
    Q_OBJECT

protected:
    ToxCall() = delete;
    ToxCall(bool VideoEnabled, CoreAV& av, IAudioControl& audio);
    ~ToxCall();

public:
    ToxCall(const ToxCall& other) = delete;
    ToxCall(ToxCall&& other) = delete;

    ToxCall& operator=(const ToxCall& other) = delete;
    ToxCall& operator=(ToxCall&& other) = delete;

    bool isActive() const;
    void setActive(bool value);

    bool getMuteVol() const;
    void setMuteVol(bool value);

    bool getMuteMic() const;
    void setMuteMic(bool value);

    bool getVideoEnabled() const;
    void setVideoEnabled(bool value);

    bool getNullVideoBitrate() const;
    void setNullVideoBitrate(bool value);

    CoreVideoSource* getVideoSource() const;

protected:
    bool active{false};
    CoreAV* av{nullptr};
    // audio
    IAudioControl& audio;
    bool muteMic{false};
    bool muteVol{false};
    // video
    CoreVideoSource* videoSource{nullptr};
    QMetaObject::Connection videoInConn;
    bool videoEnabled{false};
    bool nullVideoBitrate{false};
    std::unique_ptr<IAudioSource> audioSource;
};",1,587 2000 58 777 2001 123 2002 775 58 2000 40 41 61 619 59 2000 40 569 2003 44 2004 38 2005 44 2006 38 2007 41 59 126 2000 40 41 59 777 58 2000 40 601 2000 38 2008 41 61 619 59 2000 40 2000 307 2008 41 61 619 59 2000 38 758 61 40 601 2000 38 2008 41 61 619 59 2000 38 758 61 40 2000 307 2008 41 61 619 59 569 2009 40 41 601 59 865 2010 40 569 2011 41 59 569 2012 40 41 601 59 865 2013 40 569 2011 41 59 569 2014 40 41 601 59 865 2015 40 569 2011 41 59 569 2016 40 41 601 59 865 2017 40 569 2011 41 59 569 2018 40 41 601 59 865 2019 40 569 2011 41 59 2020 42 2021 40 41 601 59 775 58 569 2022 123 655 125 59 2004 42 2005 123 753 125 59 330 2006 38 2007 59 569 2023 123 655 125 59 569 2024 123 655 125 59 330 2020 42 2025 123 753 125 59 2026 321 2027 2028 59 569 2029 123 655 125 59 569 2030 123 655 125 59 2031 321 2032 60 2033 62 2034 59 125 59 ,"{'AvgLine': 4, 'CountLine': 104, 'CountStmt': 39, 'MaxNesting': 1, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 12, 'MaxEssential': 1, 'SumEssential': 13, 'AvgCyclomatic': 1, 'CountLineCode': 92, 'CountStmtDecl': 27, 'MaxCyclomatic': 2, 'SumCyclomatic': 14, 'AltAvgLineCode': 4, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 10, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 0, 'CountDeclMethod': 17, 'AltCountLineCode': 92, 'CountLineCodeExe': 15, 'CountLineComment': 2, 'AltAvgLineComment': 0, 'AltCountLineBlank': 10, 'CountClassCoupled': 3, 'CountClassDerived': 2, 'CountLineCodeDecl': 14, 'CountLineInactive': 0, 'CountDeclMethodAll': 17, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.02', 'AltCountLineComment': 2, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 14, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 6, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 15, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 91, 'SumCyclomaticModified': 14, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 17, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 10, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 8}"
117691,C++,"class PX4Gyroscope
{
public:
	PX4Gyroscope(uint32_t device_id, enum Rotation rotation = ROTATION_NONE);
	~PX4Gyroscope();

	uint32_t get_device_id() const { return _device_id; }

	int32_t get_max_rate_hz() const { return math::constrain(_imu_gyro_rate_max, static_cast<int32_t>(100), static_cast<int32_t>(4000)); }

	void set_device_id(uint32_t device_id) { _device_id = device_id; }
	void set_device_type(uint8_t devtype);
	void set_error_count(uint32_t error_count) { _error_count = error_count; }
	void increase_error_count() { _error_count++; }
	void set_range(float range) { _range = range; }
	void set_scale(float scale);
	void set_temperature(float temperature) { _temperature = temperature; }

	void update(const hrt_abstime &timestamp_sample, float x, float y, float z);

	void updateFIFO(sensor_gyro_fifo_s &sample);

	int get_instance() { return _sensor_pub.get_instance(); };

private:
	uORB::PublicationMulti<sensor_gyro_s> _sensor_pub{ORB_ID(sensor_gyro)};
	uORB::PublicationMulti<sensor_gyro_fifo_s>  _sensor_fifo_pub{ORB_ID(sensor_gyro_fifo)};

	uint32_t		_device_id{0};
	const enum Rotation	_rotation;

	int32_t			_imu_gyro_rate_max{0};

	float			_range{math::radians(2000.f)};
	float			_scale{1.f};
	float			_temperature{NAN};

	uint32_t		_error_count{0};

	int16_t			_last_sample[3] {};
};",1,587 2000 123 777 58 2000 40 2001 2002 44 640 2003 2004 61 2005 41 59 126 2000 40 41 59 2001 2006 40 41 601 123 792 2007 59 125 2008 2009 40 41 601 123 792 2010 321 2011 40 2012 44 811 60 2008 62 40 1503 41 44 811 60 2008 62 40 1505 41 41 59 125 865 2013 40 2001 2002 41 123 2014 61 2002 59 125 865 2015 40 2016 2017 41 59 865 2018 40 2001 2019 41 123 2020 61 2019 59 125 865 2021 40 41 123 2022 349 59 125 865 2023 40 660 2024 41 123 2025 61 2024 59 125 865 2026 40 660 2027 41 59 865 2028 40 660 2029 41 123 2030 61 2029 59 125 865 2031 40 601 2032 38 2033 44 660 2034 44 660 2035 44 660 2036 41 59 865 2037 40 2038 38 2039 41 59 704 2040 40 41 123 792 2041 46 2040 40 41 59 125 59 773 58 2042 321 2043 60 2044 62 2045 123 2046 40 2047 41 125 59 2042 321 2043 60 2038 62 2048 123 2049 40 2050 41 125 59 2001 2051 123 1500 125 59 601 640 2003 2052 59 2008 2053 123 1500 125 59 660 2054 123 2055 321 2056 40 1505 41 125 59 660 2057 123 1501 125 59 660 2058 123 2059 125 59 2001 2060 123 1500 125 59 2061 2062 91 1502 93 123 125 59 125 59 ,"{'AvgLine': 7, 'CountLine': 136, 'CountStmt': 50, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 16, 'MaxEssential': 1, 'SumEssential': 14, 'AvgCyclomatic': 1, 'CountLineCode': 99, 'CountStmtDecl': 37, 'MaxCyclomatic': 3, 'SumCyclomatic': 17, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 28, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 14, 'AltCountLineCode': 99, 'CountLineCodeExe': 17, 'CountLineComment': 9, 'AltAvgLineComment': 0, 'AltCountLineBlank': 28, 'CountClassCoupled': 0, 'CountClassDerived': 0, 'CountLineCodeDecl': 23, 'CountLineInactive': 0, 'CountDeclMethodAll': 14, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 9, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 17, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 14, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 90, 'SumCyclomaticModified': 17, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 14, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 10, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 8, 'CountDeclInstanceVariableProtected': 0}"
98595,C++,"class CPL_DLL RawDataset : public GDALPamDataset
{
    friend class RawRasterBand;

  protected:
    CPLErr IRasterIO( GDALRWFlag, int, int, int, int,
                      void *, int, int, GDALDataType,
                      int, int *,
                      GSpacing nPixelSpace, GSpacing nLineSpace,
                      GSpacing nBandSpace,
                      GDALRasterIOExtraArg* psExtraArg ) override;
  public:
                 RawDataset();
         virtual ~RawDataset() = 0;

    bool GetRawBinaryLayout(GDALDataset::RawBinaryLayout&) override;

  private:
    CPL_DISALLOW_COPY_ASSIGN(RawDataset)
};",1,587 2000 2001 58 777 2002 123 667 587 2003 59 775 58 2004 2005 40 2006 44 704 44 704 44 704 44 704 44 865 42 44 704 44 704 44 2007 44 704 44 704 42 44 2008 2009 44 2008 2010 44 2008 2011 44 2012 42 2013 41 2014 59 777 58 2001 40 41 59 864 126 2001 40 41 61 1500 59 569 2015 40 2016 321 2017 38 41 2014 59 773 58 2018 40 2001 41 125 59 ,"{'AvgLine': 39, 'CountLine': 179, 'CountStmt': 65, 'MaxNesting': 4, 'AvgLineCode': 35, 'AvgEssential': 4, 'AvgLineBlank': 3, 'CountStmtExe': 48, 'MaxEssential': 8, 'SumEssential': 17, 'AvgCyclomatic': 5, 'CountLineCode': 157, 'CountStmtDecl': 22, 'MaxCyclomatic': 12, 'SumCyclomatic': 21, 'AltAvgLineCode': 35, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 17, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 3, 'CountDeclMethod': 6, 'AltCountLineCode': 157, 'CountLineCodeExe': 71, 'CountLineComment': 5, 'AltAvgLineComment': 1, 'AltCountLineBlank': 17, 'CountClassCoupled': 4, 'CountClassDerived': 36, 'CountLineCodeDecl': 31, 'CountLineInactive': 0, 'CountDeclMethodAll': 192, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.03', 'AltCountLineComment': 5, 'AvgCyclomaticStrict': 6, 'MaxCyclomaticStrict': 13, 'SumCyclomaticStrict': 27, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 0, 'AvgCyclomaticModified': 5, 'CountDeclMethodFriend': 40, 'CountDeclMethodPublic': 3, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 12, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 21, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 0, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
118572,C++,"class ChatLineStorage
{

    struct IdxInfo
    {
        size_t linePos;
        QDateTime timestamp;
    };
    using Lines_t = std::vector<ChatLine::Ptr>;
    using DateLineMap_t = std::map<ChatLine::Ptr, QDateTime>;
    using IdxInfoMap_t = std::map<ChatLogIdx, IdxInfo>;

public:
    // Types to conform with other containers
    using size_type = Lines_t::size_type;
    using reference = Lines_t::reference;
    using const_reference = Lines_t::const_reference;
    using const_iterator = Lines_t::const_iterator;
    using iterator = Lines_t::iterator;


public:
    iterator insertChatMessage(ChatLogIdx idx, QDateTime timestamp, ChatLine::Ptr line);
    iterator insertDateLine(QDateTime timestamp, ChatLine::Ptr line);

    ChatLogIdx firstIdx() const { return idxInfoMap.begin()->first; }

    ChatLogIdx lastIdx() const { return idxInfoMap.rbegin()->first; }

    bool contains(ChatLogIdx idx) const { return idxInfoMap.find(idx) != idxInfoMap.end(); }

    bool contains(QDateTime timestamp) const;

    iterator find(ChatLogIdx idx);
    iterator find(ChatLine::Ptr line);

    const_reference operator[](size_type idx) const { return lines[idx]; }

    const_reference operator[](ChatLogIdx idx) const { return lines[idxInfoMap.at(idx).linePos]; }

    size_type size() const { return lines.size(); }

    iterator begin() { return lines.begin(); }
    iterator end() { return lines.end(); }

    bool empty() const { return lines.empty(); }

    bool hasIndexedMessage() const { return !idxInfoMap.empty(); }

    void clear()
    {
        idxInfoMap.clear();
        dateMap.clear();
        return lines.clear();
    }

    reference front() { return lines.front(); }
    reference back() { return lines.back(); }

    void erase(ChatLogIdx idx);
    iterator erase(iterator it);

private:
    iterator equivalentLineIterator(IdxInfoMap_t::iterator it);

    IdxInfoMap_t::iterator equivalentInfoIterator(iterator it);

    IdxInfoMap_t::iterator infoIteratorForIdx(ChatLogIdx idx);

    iterator adjustItForDate(iterator it, QDateTime timestamp);

    void incrementLinePosAfter(IdxInfoMap_t::iterator it);
    void decrementLinePosAfter(IdxInfoMap_t::iterator it);
    bool shouldRemovePreviousLine(iterator prevIt, iterator it);

    std::vector<ChatLine::Ptr> lines;
    std::map<ChatLine::Ptr, QDateTime> dateMap;
    IdxInfoMap_t idxInfoMap;
};",1,587 2000 123 816 2001 123 2002 2003 59 2004 2005 59 125 59 860 2006 61 2007 321 2008 60 2009 321 2010 62 59 860 2011 61 2007 321 2012 60 2009 321 2010 44 2013 62 59 860 2014 61 2007 321 2012 60 2015 44 2001 62 59 777 58 330 860 2016 61 2006 321 2016 59 860 2017 61 2006 321 2017 59 860 2018 61 2006 321 2018 59 860 2019 61 2006 321 2019 59 860 2020 61 2006 321 2020 59 777 58 2020 2021 40 2015 2022 44 2013 2023 44 2009 321 2010 2024 41 59 2020 2025 40 2013 2023 44 2009 321 2010 2024 41 59 2015 2026 40 41 601 123 792 2027 46 2028 40 41 354 2029 59 125 2015 2030 40 41 601 123 792 2031 46 2032 40 41 354 2033 59 125 569 2034 40 2015 2022 41 601 123 792 2035 46 2036 40 2022 41 340 2035 46 2037 40 41 59 125 569 2034 40 2013 2023 41 601 59 2020 2038 40 2015 2022 41 59 2020 2038 40 2009 321 2010 2024 41 59 2018 758 91 93 40 2016 2022 41 601 123 792 2039 91 2022 93 59 125 2018 758 91 93 40 2015 2022 41 601 123 792 2040 91 2041 46 2042 40 2022 41 46 2043 93 59 125 2016 2044 40 41 601 123 792 2045 46 2044 40 41 59 125 2020 2046 40 41 123 792 2047 46 2046 40 41 59 125 2020 2048 40 41 123 792 2049 46 2048 40 41 59 125 569 2050 40 41 601 123 792 2051 46 2050 40 41 59 125 569 2052 40 41 601 123 792 33 2053 46 2050 40 41 59 125 865 2054 40 41 123 2055 46 2054 40 41 59 2056 46 2054 40 41 59 792 2057 46 2054 40 41 59 125 2017 2058 40 41 123 792 2059 46 2058 40 41 59 125 2017 2060 40 41 123 792 2061 46 2060 40 41 59 125 865 2062 40 2015 2022 41 59 2020 2062 40 2020 2063 41 59 773 58 2020 2064 40 2014 321 2020 2063 41 59 2014 321 2020 2065 40 2020 2063 41 59 2014 321 2020 2066 40 2015 2022 41 59 2020 2067 40 2020 2063 44 2013 2023 41 59 865 2068 40 2014 321 2020 2063 41 59 865 2069 40 2014 321 2020 2063 41 59 569 2070 40 2020 2071 44 2020 2063 41 59 2007 321 2008 60 2009 321 2010 62 2072 59 2007 321 2012 60 2009 321 2010 44 2013 62 2073 59 2014 2074 59 125 59 ,"{'AvgLine': 7, 'CountLine': 265, 'CountStmt': 54, 'MaxNesting': 1, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 4, 'MaxEssential': 1, 'SumEssential': 27, 'AvgCyclomatic': 1, 'CountLineCode': 190, 'CountStmtDecl': 50, 'MaxCyclomatic': 2, 'SumCyclomatic': 30, 'AltAvgLineCode': 5, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 52, 'CountStmtEmpty': 0, 'AltAvgLineBlank': 1, 'CountDeclMethod': 27, 'AltCountLineCode': 190, 'CountLineCodeExe': 2, 'CountLineComment': 27, 'AltAvgLineComment': 0, 'AltCountLineBlank': 52, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 29, 'CountLineInactive': 0, 'CountDeclMethodAll': 27, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.14', 'AltCountLineComment': 27, 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 30, 'CountDeclClassMethod': 0, 'CountDeclMethodConst': 9, 'AvgCyclomaticModified': 1, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 27, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 30, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 27, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 3, 'CountDeclInstanceVariablePublic': 3, 'CountDeclInstanceVariablePrivate': 0, 'CountDeclInstanceVariableProtected': 0}"
99693,C++,"class RS2Dataset final: public GDALPamDataset
{
    CPLXMLNode *psProduct;

    int           nGCPCount;
    GDAL_GCP      *pasGCPList;
    char          *pszGCPProjection;
    char        **papszSubDatasets;
    char          *pszProjection;
    double      adfGeoTransform[6];
    bool        bHaveGeoTransform;

    char        **papszExtraFiles;

  protected:
    virtual int         CloseDependentDatasets() override;

  public:
            RS2Dataset();
    virtual ~RS2Dataset();

    virtual int    GetGCPCount() override;
    virtual const char *_GetGCPProjection() override;
    const OGRSpatialReference* GetGCPSpatialRef() const override {
        return GetGCPSpatialRefFromOldGetGCPProjection();
    }
    virtual const GDAL_GCP *GetGCPs() override;

    virtual const char *_GetProjectionRef(void) override;
    const OGRSpatialReference* GetSpatialRef() const override {
        return GetSpatialRefFromOldGetProjectionRef();
    }
    virtual CPLErr GetGeoTransform( double * ) override;

    virtual char      **GetMetadataDomainList() override;
    virtual char **GetMetadata( const char * pszDomain = """" ) override;
    virtual char **GetFileList(void) override;

    static GDALDataset *Open( GDALOpenInfo * );
    static int Identify( GDALOpenInfo * );

    CPLXMLNode *GetProduct() { return psProduct; }
};",1,587 2000 2001 58 777 2002 123 2003 42 2004 59 704 2005 59 2006 42 2007 59 582 42 2008 59 582 42 42 2009 59 582 42 2010 59 625 2011 91 1502 93 59 569 2012 59 582 42 42 2013 59 775 58 864 704 2014 40 41 2015 59 777 58 2000 40 41 59 864 126 2000 40 41 59 864 704 2016 40 41 2015 59 864 601 582 42 2017 40 41 2015 59 601 2018 42 2019 40 41 601 2015 123 792 2020 40 41 59 125 864 601 2006 42 2021 40 41 2015 59 864 601 582 42 2022 40 865 41 2015 59 601 2018 42 2023 40 41 601 2015 123 792 2024 40 41 59 125 864 2025 2026 40 625 42 41 2015 59 864 582 42 42 2027 40 41 2015 59 864 582 42 42 2028 40 601 582 42 2029 61 362 41 2015 59 864 582 42 42 2030 40 865 41 2015 59 809 2031 42 2032 40 2033 42 41 59 809 704 2034 40 2033 42 41 59 2003 42 2035 40 41 123 792 2004 59 125 125 59 ,"{'AvgLine': 58, 'CountLine': 966, 'CountStmt': 433, 'MaxNesting': 4, 'AvgLineCode': 43, 'AvgEssential': 2, 'AvgLineBlank': 8, 'CountStmtExe': 384, 'MaxEssential': 20, 'SumEssential': 41, 'AvgCyclomatic': 5, 'CountLineCode': 727, 'CountStmtDecl': 119, 'MaxCyclomatic': 67, 'SumCyclomatic': 93, 'AltAvgLineCode': 44, 'AvgLineComment': 6, 'CountClassBase': 1, 'CountLineBlank': 137, 'CountStmtEmpty': 1, 'AltAvgLineBlank': 8, 'CountDeclMethod': 16, 'AltCountLineCode': 733, 'CountLineCodeExe': 818, 'CountLineComment': 96, 'AltAvgLineComment': 6, 'AltCountLineBlank': 137, 'CountClassCoupled': 9, 'CountClassDerived': 0, 'CountLineCodeDecl': 231, 'CountLineInactive': 4, 'CountDeclMethodAll': 202, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.13', 'AltCountLineComment': 96, 'AvgCyclomaticStrict': 7, 'MaxCyclomaticStrict': 89, 'SumCyclomaticStrict': 119, 'CountDeclClassMethod': 2, 'CountDeclMethodConst': 2, 'AvgCyclomaticModified': 5, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 15, 'CountLinePreprocessor': 2, 'MaxCyclomaticModified': 62, 'PercentLackOfCohesion': 79, 'SumCyclomaticModified': 88, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 16, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 9, 'CountDeclInstanceVariablePublic': 0, 'CountDeclInstanceVariablePrivate': 9, 'CountDeclInstanceVariableProtected': 0}"
117663,C++,"class Gyroscope
{
public:
	static constexpr int MAX_SENSOR_COUNT = 4;

	static constexpr uint8_t DEFAULT_PRIORITY = 50;
	static constexpr uint8_t DEFAULT_EXTERNAL_PRIORITY = 25;

	static constexpr const char *SensorString() { return ""GYRO""; }

	Gyroscope();
	explicit Gyroscope(uint32_t device_id, bool external = false);

	~Gyroscope() = default;

	void PrintStatus();

	void set_calibration_index(uint8_t calibration_index) { _calibration_index = calibration_index; }
	void set_device_id(uint32_t device_id, bool external = false);
	void set_external(bool external = true);
	bool set_offset(const matrix::Vector3f &offset);
	void set_rotation(Rotation rotation);
	void set_temperature(float temperature) { _temperature = temperature; };

	uint8_t calibration_count() const { return _calibration_count; }
	uint32_t device_id() const { return _device_id; }
	bool enabled() const { return (_priority > 0); }
	bool external() const { return _external; }
	const matrix::Vector3f &offset() const { return _offset; }
	const int32_t &priority() const { return _priority; }
	const matrix::Dcmf &rotation() const { return _rotation; }
	const Rotation &rotation_enum() const { return _rotation_enum; }
	const matrix::Vector3f &thermal_offset() const { return _thermal_offset; }

	// apply offsets and scale
	// rotate corrected measurements from sensor to body frame
	inline matrix::Vector3f Correct(const matrix::Vector3f &data) const
	{
		return _rotation * matrix::Vector3f{data - _thermal_offset - _offset};
	}

	inline matrix::Vector3f Uncorrect(const matrix::Vector3f &corrected_data) const
	{
		return (_rotation.I() * corrected_data) + _thermal_offset + _offset;
	}

	// Compute sensor offset from bias (board frame)
	matrix::Vector3f BiasCorrectedSensorOffset(const matrix::Vector3f &bias) const
	{
		return (_rotation.I() * bias) + _thermal_offset + _offset;
	}

	bool ParametersSave();
	void ParametersUpdate();

	void Reset();

	void SensorCorrectionsUpdate(bool force = false);

private:
	static constexpr float TEMPERATURE_INVALID = -1000.f;

	uORB::Subscription _sensor_correction_sub{ORB_ID(sensor_correction)};

	Rotation _rotation_enum{ROTATION_NONE};

	matrix::Dcmf _rotation;
	matrix::Vector3f _offset;
	matrix::Vector3f _thermal_offset;
	float _temperature{NAN};

	int8_t _calibration_index{-1};
	uint32_t _device_id{0};
	int32_t _priority{-1};

	bool _external{false};

	uint8_t _calibration_count{0};
};",1,587 2000 123 777 58 809 603 704 2001 61 1502 59 809 603 2002 2003 61 1503 59 809 603 2002 2004 61 1503 59 809 603 601 582 42 2005 40 41 123 792 362 59 125 2000 40 41 59 648 2000 40 2006 2007 44 569 2008 61 655 41 59 126 2000 40 41 61 613 59 865 2009 40 41 59 865 2010 40 2002 2011 41 123 2012 61 2011 59 125 865 2013 40 2006 2007 44 569 2008 61 655 41 59 865 2014 40 569 2008 61 829 41 59 569 2015 40 601 2016 321 2017 38 2018 41 59 865 2019 40 2020 2021 41 59 865 2022 40 660 2023 41 123 2024 61 2023 59 125 59 2002 2025 40 41 601 123 792 2026 59 125 2006 2007 40 41 601 123 792 2027 59 125 569 2028 40 41 601 123 792 40 2029 62 1500 41 59 125 569 2008 40 41 601 123 792 2030 59 125 601 2016 321 2017 38 2018 40 41 601 123 792 2031 59 125 601 2032 38 2033 40 41 601 123 792 2034 59 125 601 2016 321 2035 38 2021 40 41 601 123 792 2036 59 125 601 2020 38 2037 40 41 601 123 792 2038 59 125 601 2016 321 2017 38 2039 40 41 601 123 792 2040 59 125 330 330 700 2016 321 2017 2041 40 601 2016 321 2017 38 2042 41 601 123 792 2043 42 2016 321 2017 123 2042 45 2044 45 2045 125 59 125 700 2016 321 2017 2046 40 601 2016 321 2017 38 2047 41 601 123 792 40 2048 46 2049 40 41 42 2047 41 43 2050 43 2051 59 125 330 2016 321 2017 2052 40 601 2016 321 2017 38 2053 41 601 123 792 40 2054 46 2055 40 41 42 2053 41 43 2056 43 2057 59 125 569 2058 40 41 59 865 2059 40 41 59 865 2060 40 41 59 865 2061 40 569 2062 61 655 41 59 773 58 809 603 660 2063 61 45 1504 59 2064 321 2065 2066 123 2067 40 2068 41 125 59 2020 2069 123 2070 125 59 2016 321 2035 2071 59 2016 321 2017 2072 59 2016 321 2017 2073 59 660 2074 123 2075 125 59 2076 2077 123 45 1501 125 59 2006 2078 123 1500 125 59 2032 2079 123 45 1501 125 59 569 2080 123 655 125 59 2002 2081 123 1500 125 59 125 59 ,"{'AvgLine': 9, 'CountLine': 301, 'CountStmt': 153, 'MaxNesting': 5, 'AvgLineCode': 7, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 103, 'MaxEssential': 10, 'SumEssential': 37, 'AvgCyclomatic': 2, 'CountLineCode': 223, 'CountStmtDecl': 51, 'MaxCyclomatic': 12, 'SumCyclomatic': 63, 'AltAvgLineCode': 7, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 58, 'CountStmtEmpty': 4, 'AltAvgLineBlank': 1, 'CountDeclMethod': 27, 'AltCountLineCode': 223, 'CountLineCodeExe': 102, 'CountLineComment': 20, 'AltAvgLineComment': 0, 'AltCountLineBlank': 58, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 33, 'CountLineInactive': 0, 'CountDeclMethodAll': 27, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.09', 'AltCountLineComment': 20, 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 14, 'SumCyclomaticStrict': 74, 'CountDeclClassMethod': 1, 'CountDeclMethodConst': 12, 'AvgCyclomaticModified': 2, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 27, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 12, 'PercentLackOfCohesion': 87, 'SumCyclomaticModified': 60, 'CountDeclClassVariable': 4, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 27, 'CountDeclMethodProtected': 0, 'CountDeclInstanceVariable': 11, 'CountDeclInstanceVariablePublic': 2, 'CountDeclInstanceVariablePrivate': 9, 'CountDeclInstanceVariableProtected': 0}"
98563,C++,"class CPL_DLL OGRFeature
{
  private:

    GIntBig              nFID;
    OGRFeatureDefn      *poDefn;
    OGRGeometry        **papoGeometries;
    OGRField            *pauFields;
    char                *m_pszNativeData;
    char                *m_pszNativeMediaType;

    bool                SetFieldInternal( int i, OGRField * puValue );

  protected:
//! @cond Doxygen_Suppress
    mutable char        *m_pszStyleString;
    mutable OGRStyleTable *m_poStyleTable;
    mutable char        *m_pszTmpFieldValue;
//! @endcond

    bool                CopySelfTo( OGRFeature *poNew ) const;

  public:
    explicit            OGRFeature( OGRFeatureDefn * );
    virtual            ~OGRFeature();

    /** Field value. */
    class CPL_DLL FieldValue
    {
        friend class OGRFeature;
        struct Private;
        std::unique_ptr<Private> m_poPrivate;

        FieldValue(OGRFeature* poFeature, int iFieldIndex);
        FieldValue(const OGRFeature* poFeature, int iFieldIndex);
        FieldValue(const FieldValue& oOther) = delete;

      public:
//! @cond Doxygen_Suppress
        ~FieldValue();
//! @endcond

        /** Set a field value from another one. */
        FieldValue& operator= (const FieldValue& oOther);
        /** Set an integer value to the field. */
        FieldValue& operator= (int nVal);
        /** Set an integer value to the field. */
        FieldValue& operator= (GIntBig nVal);
        /** Set a real value to the field. */
        FieldValue& operator= (double  dfVal);
        /** Set a string value to the field. */
        FieldValue& operator= (const char *pszVal);
        /** Set a string value to the field. */
        FieldValue& operator= (const std::string& osVal);
        /** Set an array of integer to the field. */
        FieldValue& operator= (const std::vector<int>& oArray);
        /** Set an array of big integer to the field. */
        FieldValue& operator= (const std::vector<GIntBig>& oArray);
        /** Set an array of double to the field. */
        FieldValue& operator= (const std::vector<double>& oArray);
        /** Set an array of strings to the field. */
        FieldValue& operator= (const std::vector<std::string>& oArray);
        /** Set an array of strings to the field. */
        FieldValue& operator= (CSLConstList papszValues);
        /** Set a null value to the field. */
        void SetNull();
        /** Unset the field. */
        void clear();
        /** Unset the field. */
        void Unset() { clear(); }
        /** Set date time value/ */
        void SetDateTime(int nYear, int nMonth, int nDay,
                         int nHour=0, int nMinute=0, float fSecond=0.f,
                         int nTZFlag = 0 );

        /** Return field index. */
        int GetIndex() const;
        /** Return field definition. */
        const OGRFieldDefn* GetDefn() const;
        /** Return field name. */
        const char* GetName() const { return GetDefn()->GetNameRef(); }
        /** Return field type. */
        OGRFieldType GetType() const { return GetDefn()->GetType(); }
        /** Return field subtype. */
        OGRFieldSubType GetSubType() const { return GetDefn()->GetSubType(); }

        /** Return whether the field value is unset/empty. */
        // cppcheck-suppress functionStatic
        bool empty() const { return IsUnset(); }

        /** Return whether the field value is unset/empty. */
        // cppcheck-suppress functionStatic
        bool IsUnset() const;

        /** Return whether the field value is null. */
        // cppcheck-suppress functionStatic
        bool IsNull() const;

        /** Return the raw field value */
        const OGRField *GetRawValue() const;

        /** Return the integer value.
            * Only use that method if and only if GetType() == OFTInteger.
            */
        // cppcheck-suppress functionStatic
        int GetInteger() const  { return GetRawValue()->Integer; }

        /** Return the 64-bit integer value.
            * Only use that method if and only if GetType() == OFTInteger64.
            */
        // cppcheck-suppress functionStatic
        GIntBig GetInteger64() const  { return GetRawValue()->Integer64; }

        /** Return the double value.
            * Only use that method if and only if GetType() == OFTReal.
            */
        // cppcheck-suppress functionStatic
        double GetDouble() const  { return GetRawValue()->Real; }

        /** Return the string value.
            * Only use that method if and only if GetType() == OFTString.
            */
        // cppcheck-suppress functionStatic
        const char* GetString() const { return GetRawValue()->String; }

        /** Return the date/time/datetime value. */
        bool GetDateTime( int *pnYear, int *pnMonth,
                            int *pnDay,
                            int *pnHour, int *pnMinute,
                            float *pfSecond,
                            int *pnTZFlag ) const;

        /** Return the field value as integer, with potential conversion */
        operator int () const { return GetAsInteger(); }
        /** Return the field value as 64-bit integer, with potential conversion */
        operator GIntBig() const { return GetAsInteger64(); }
        /** Return the field value as double, with potential conversion */
        operator double () const { return GetAsDouble(); }
        /** Return the field value as string, with potential conversion */
        operator const char*() const { return GetAsString(); }
        /** Return the field value as integer list, with potential conversion */
        operator const std::vector<int>& () const { return GetAsIntegerList(); }
        /** Return the field value as 64-bit integer list, with potential conversion */
        operator const std::vector<GIntBig>& () const { return GetAsInteger64List(); }
        /** Return the field value as double list, with potential conversion */
        operator const std::vector<double>& () const { return GetAsDoubleList(); }
        /** Return the field value as string list, with potential conversion */
        operator const std::vector<std::string>& () const { return GetAsStringList(); }
        /** Return the field value as string list, with potential conversion */
        operator CSLConstList () const;

        /** Return the field value as integer, with potential conversion */
        int GetAsInteger() const;
        /** Return the field value as 64-bit integer, with potential conversion */
        GIntBig GetAsInteger64() const;
        /** Return the field value as double, with potential conversion */
        double GetAsDouble() const;
        /** Return the field value as string, with potential conversion */
        const char* GetAsString() const;
        /** Return the field value as integer list, with potential conversion */
        const std::vector<int>& GetAsIntegerList() const;
        /** Return the field value as 64-bit integer list, with potential conversion */
        const std::vector<GIntBig>& GetAsInteger64List() const;
        /** Return the field value as double list, with potential conversion */
        const std::vector<double>& GetAsDoubleList() const;
        /** Return the field value as string list, with potential conversion */
        const std::vector<std::string>& GetAsStringList() const;
    };

    /** Field value iterator class. */
    class CPL_DLL ConstFieldIterator
    {
        friend class OGRFeature;
        struct Private;
        std::unique_ptr<Private> m_poPrivate;

        ConstFieldIterator(const OGRFeature* poSelf, int nPos);

      public:
//! @cond Doxygen_Suppress
        ConstFieldIterator(ConstFieldIterator&& oOther) noexcept; // declared but not defined. Needed for gcc 5.4 at least
        ~ConstFieldIterator();
        const FieldValue& operator*() const;
        ConstFieldIterator& operator++();
        bool operator!=(const ConstFieldIterator& it) const;
//! @endcond
    };

    /** Return begin of field value iterator.
     *
     * Using this iterator for standard range-based loops is safe, but
     * due to implementation limitations, you shouldn't try to access
     * (dereference) more than one iterator step at a time, since you will get
     * a reference to the same object (FieldValue) at each iteration step.
     *
     * <pre>
     * for( auto&& oField: poFeature )
     * {
     *      std::cout << oField.GetIndex() << "","" << oField.GetName()<< "": "" << oField.GetAsString() << std::endl;
     * }
     * </pre>
     *
     * @since GDAL 2.3
     */
    ConstFieldIterator begin() const;
    /** Return end of field value iterator. */
    ConstFieldIterator end() const;

    const FieldValue operator[](int iField) const;
    FieldValue operator[](int iField);

    /** Exception raised by operator[](const char*) when a field is not found. */
    class FieldNotFoundException: public std::exception {};

    const FieldValue operator[](const char* pszFieldName) const;
    FieldValue operator[](const char* pszFieldName);

    OGRFeatureDefn     *GetDefnRef() { return poDefn; }
    const OGRFeatureDefn     *GetDefnRef() const { return poDefn; }

    OGRErr              SetGeometryDirectly( OGRGeometry * );
    OGRErr              SetGeometry( const OGRGeometry * );
    OGRGeometry        *GetGeometryRef();
    const OGRGeometry  *GetGeometryRef() const;
    OGRGeometry        *StealGeometry() CPL_WARN_UNUSED_RESULT;

    int                 GetGeomFieldCount() const
                                { return poDefn->GetGeomFieldCount(); }
    OGRGeomFieldDefn   *GetGeomFieldDefnRef( int iField )
                                { return poDefn->GetGeomFieldDefn(iField); }
    const OGRGeomFieldDefn   *GetGeomFieldDefnRef( int iField ) const
                                { return poDefn->GetGeomFieldDefn(iField); }
    int                 GetGeomFieldIndex( const char * pszName ) const
                                { return poDefn->GetGeomFieldIndex(pszName); }

    OGRGeometry*        GetGeomFieldRef( int iField );
    const OGRGeometry*  GetGeomFieldRef( int iField ) const;
    OGRGeometry*        StealGeometry( int iField );
    OGRGeometry*        GetGeomFieldRef( const char* pszFName );
    const OGRGeometry*  GetGeomFieldRef( const char* pszFName ) const;
    OGRErr              SetGeomFieldDirectly( int iField, OGRGeometry * );
    OGRErr              SetGeomField( int iField, const OGRGeometry * );

    OGRFeature         *Clone() const CPL_WARN_UNUSED_RESULT;
    virtual OGRBoolean  Equal( const OGRFeature * poFeature ) const;

    int                 GetFieldCount() const
        { return poDefn->GetFieldCount(); }
    const OGRFieldDefn *GetFieldDefnRef( int iField ) const
                                      { return poDefn->GetFieldDefn(iField); }
    OGRFieldDefn       *GetFieldDefnRef( int iField )
                                      { return poDefn->GetFieldDefn(iField); }
    int                 GetFieldIndex( const char * pszName ) const
                                      { return poDefn->GetFieldIndex(pszName); }

    int                 IsFieldSet( int iField ) const;

    void                UnsetField( int iField );

    bool                IsFieldNull( int iField ) const;

    void                SetFieldNull( int iField );

    bool                IsFieldSetAndNotNull( int iField ) const;

    OGRField           *GetRawFieldRef( int i ) { return pauFields + i; }
    const OGRField     *GetRawFieldRef( int i ) const { return pauFields + i; }

    int                 GetFieldAsInteger( int i ) const;
    GIntBig             GetFieldAsInteger64( int i ) const;
    double              GetFieldAsDouble( int i ) const;
    const char         *GetFieldAsString( int i ) const;
    const int          *GetFieldAsIntegerList( int i, int *pnCount ) const;
    const GIntBig      *GetFieldAsInteger64List( int i, int *pnCount ) const;
    const double       *GetFieldAsDoubleList( int i, int *pnCount ) const;
    char              **GetFieldAsStringList( int i ) const;
    GByte              *GetFieldAsBinary( int i, int *pnCount ) const;
    int                 GetFieldAsDateTime( int i,
                                            int *pnYear, int *pnMonth,
                                            int *pnDay,
                                            int *pnHour, int *pnMinute,
                                            int *pnSecond,
                                            int *pnTZFlag ) const;
    int                 GetFieldAsDateTime( int i,
                                            int *pnYear, int *pnMonth,
                                            int *pnDay,
                                            int *pnHour, int *pnMinute,
                                            float *pfSecond,
                                            int *pnTZFlag ) const;
    char               *GetFieldAsSerializedJSon( int i ) const;

    int                 GetFieldAsInteger( const char *pszFName )  const
                      { return GetFieldAsInteger( GetFieldIndex(pszFName) ); }
    GIntBig             GetFieldAsInteger64( const char *pszFName )  const
                      { return GetFieldAsInteger64( GetFieldIndex(pszFName) ); }
    double              GetFieldAsDouble( const char *pszFName )  const
                      { return GetFieldAsDouble( GetFieldIndex(pszFName) ); }
    const char         *GetFieldAsString( const char *pszFName )  const
                      { return GetFieldAsString( GetFieldIndex(pszFName) ); }
    const int          *GetFieldAsIntegerList( const char *pszFName,
                                               int *pnCount )  const
                      { return GetFieldAsIntegerList( GetFieldIndex(pszFName),
                                                      pnCount ); }
    const GIntBig      *GetFieldAsInteger64List( const char *pszFName,
                                               int *pnCount )  const
                      { return GetFieldAsInteger64List( GetFieldIndex(pszFName),
                                                      pnCount ); }
    const double       *GetFieldAsDoubleList( const char *pszFName,
                                              int *pnCount )  const
                      { return GetFieldAsDoubleList( GetFieldIndex(pszFName),
                                                     pnCount ); }
    char              **GetFieldAsStringList( const char *pszFName )  const
                      { return GetFieldAsStringList(GetFieldIndex(pszFName)); }

    void                SetField( int i, int nValue );
    void                SetField( int i, GIntBig nValue );
    void                SetField( int i, double dfValue );
    void                SetField( int i, const char * pszValue );
    void                SetField( int i, int nCount, const int * panValues );
    void                SetField( int i, int nCount,
                                  const GIntBig * panValues );
    void                SetField( int i, int nCount, const double * padfValues );
    void                SetField( int i, const char * const * papszValues );
    void                SetField( int i, OGRField * puValue );
    void                SetField( int i, int nCount, const void * pabyBinary );
    void                SetField( int i, int nYear, int nMonth, int nDay,
                                  int nHour=0, int nMinute=0, float fSecond=0.f,
                                  int nTZFlag = 0 );

    void                SetField( const char *pszFName, int nValue )
                           { SetField( GetFieldIndex(pszFName), nValue ); }
    void                SetField( const char *pszFName, GIntBig nValue )
                           { SetField( GetFieldIndex(pszFName), nValue ); }
    void                SetField( const char *pszFName, double dfValue )
                           { SetField( GetFieldIndex(pszFName), dfValue ); }
    void                SetField( const char *pszFName, const char * pszValue )
                           { SetField( GetFieldIndex(pszFName), pszValue ); }
    void                SetField( const char *pszFName, int nCount,
                                  const int * panValues )
                         { SetField(GetFieldIndex(pszFName),nCount,panValues); }
    void                SetField( const char *pszFName, int nCount,
                                  const GIntBig * panValues )
                         { SetField(GetFieldIndex(pszFName),nCount,panValues); }
    void                SetField( const char *pszFName, int nCount,
                                  const double * padfValues )
                         {SetField(GetFieldIndex(pszFName),nCount,padfValues); }
    void                SetField( const char *pszFName, const char * const * papszValues )
                           { SetField( GetFieldIndex(pszFName), papszValues); }
    void                SetField( const char *pszFName, OGRField * puValue )
                           { SetField( GetFieldIndex(pszFName), puValue ); }
    void                SetField( const char *pszFName,
                                  int nYear, int nMonth, int nDay,
                                  int nHour=0, int nMinute=0, float fSecond=0.f,
                                  int nTZFlag = 0 )
                           { SetField( GetFieldIndex(pszFName),
                                       nYear, nMonth, nDay,
                                       nHour, nMinute, fSecond, nTZFlag ); }

    GIntBig             GetFID() const { return nFID; }
    virtual OGRErr      SetFID( GIntBig nFIDIn );

    void                DumpReadable( FILE *, char** papszOptions = nullptr ) const;

    OGRErr              SetFrom( const OGRFeature *, int = TRUE );
    OGRErr              SetFrom( const OGRFeature *, const int *, int = TRUE );
    OGRErr              SetFieldsFrom( const OGRFeature *, const int *, int = TRUE );

//! @cond Doxygen_Suppress
    OGRErr              RemapFields( OGRFeatureDefn *poNewDefn,
                                     const int *panRemapSource );
    void                AppendField();
    OGRErr              RemapGeomFields( OGRFeatureDefn *poNewDefn,
                                         const int *panRemapSource );
//! @endcond

    int                 Validate( int nValidateFlags,
                                  int bEmitError ) const;
    void                FillUnsetWithDefault( int bNotNullableOnly,
                                              char** papszOptions );

    virtual const char *GetStyleString() const;
    virtual void        SetStyleString( const char * );
    virtual void        SetStyleStringDirectly( char * );

    /** Return style table.
     * @return style table.
     */
    virtual OGRStyleTable *GetStyleTable() const { return m_poStyleTable; } /* f.i.x.m.e: add a const qualifier for return type */
    virtual void        SetStyleTable( OGRStyleTable *poStyleTable );
    virtual void        SetStyleTableDirectly( OGRStyleTable *poStyleTable );

    const char         *GetNativeData() const { return m_pszNativeData; }
    const char         *GetNativeMediaType() const
        { return m_pszNativeMediaType; }
    void                SetNativeData( const char* pszNativeData );
    void                SetNativeMediaType( const char* pszNativeMediaType );

    static OGRFeature  *CreateFeature( OGRFeatureDefn * );
    static void         DestroyFeature( OGRFeature * );

    /** Convert a OGRFeature* to a OGRFeatureH.
     * @since GDAL 2.3
     */
    static inline OGRFeatureH ToHandle(OGRFeature* poFeature)
        { return reinterpret_cast<OGRFeatureH>(poFeature); }

    /** Convert a OGRFeatureH to a OGRFeature*.
     * @since GDAL 2.3
     */
    static inline OGRFeature* FromHandle(OGRFeatureH hFeature)
        { return reinterpret_cast<OGRFeature*>(hFeature); }

  private:
    CPL_DISALLOW_COPY_ASSIGN(OGRFeature)
};",1,587 2000 2001 123 773 58 2002 2003 59 2004 42 2005 59 2006 42 42 2007 59 2008 42 2009 59 582 42 2010 59 582 42 2011 59 569 2012 40 704 2013 44 2008 42 2014 41 59 775 58 330 740 582 42 2015 59 740 2016 42 2017 59 740 582 42 2018 59 330 569 2019 40 2001 42 2020 41 601 59 777 58 648 2001 40 2004 42 41 59 864 126 2001 40 41 59 306 587 2000 2021 123 667 587 2001 59 816 2022 59 2023 321 2024 60 2022 62 2025 59 2021 40 2001 42 2026 44 704 2027 41 59 2021 40 601 2001 42 2026 44 704 2027 41 59 2021 40 601 2021 38 2028 41 61 619 59 777 58 330 126 2021 40 41 59 330 306 2021 38 758 61 40 601 2021 38 2028 41 59 306 2021 38 758 61 40 704 2029 41 59 306 2021 38 758 61 40 2002 2029 41 59 306 2021 38 758 61 40 625 2030 41 59 306 2021 38 758 61 40 601 582 42 2031 41 59 306 2021 38 758 61 40 601 2023 321 2032 38 2033 41 59 306 2021 38 758 61 40 601 2023 321 2034 60 704 62 38 2035 41 59 306 2021 38 758 61 40 601 2023 321 2034 60 2002 62 38 2035 41 59 306 2021 38 758 61 40 601 2023 321 2034 60 625 62 38 2035 41 59 306 2021 38 758 61 40 601 2023 321 2034 60 2023 321 2032 62 38 2035 41 59 306 2021 38 758 61 40 2036 2037 41 59 306 865 2038 40 41 59 306 865 2039 40 41 59 306 865 2040 40 41 123 2039 40 41 59 125 306 865 2041 40 704 2042 44 704 2043 44 704 2044 44 704 2045 61 1500 44 704 2046 61 1500 44 660 2047 61 1500 44 704 2048 61 1500 41 59 306 704 2049 40 41 601 59 306 601 2050 42 2051 40 41 601 59 306 601 582 42 2052 40 41 601 123 792 2051 40 41 354 2053 40 41 59 125 306 2054 2055 40 41 601 123 792 2051 40 41 354 2055 40 41 59 125 306 2056 2057 40 41 601 123 792 2051 40 41 354 2057 40 41 59 125 306 330 569 2058 40 41 601 123 792 2059 40 41 59 125 306 330 569 2060 40 41 601 59 306 330 569 2061 40 41 601 59 306 601 2008 42 2062 40 41 601 59 306 330 704 2063 40 41 601 123 792 2062 40 41 354 2064 59 125 306 330 2002 2065 40 41 601 123 792 2062 40 41 354 2066 59 125 306 330 625 2067 40 41 601 123 792 2062 40 41 354 2068 59 125 306 330 601 582 42 2069 40 41 601 123 792 2062 40 41 354 2070 59 125 306 569 2071 40 704 42 2072 44 704 42 2073 44 704 42 2074 44 704 42 2075 44 704 42 2076 44 660 42 2077 44 704 42 2078 41 601 59 306 758 704 40 41 601 123 792 2079 40 41 59 125 306 758 2002 40 41 601 123 792 2080 40 41 59 125 306 758 625 40 41 601 123 792 2081 40 41 59 125 306 758 601 582 42 40 41 601 123 792 2082 40 41 59 125 306 758 601 2023 321 2034 60 704 62 38 40 41 601 123 792 2083 40 41 59 125 306 758 601 2023 321 2034 60 2002 62 38 40 41 601 123 792 2084 40 41 59 125 306 758 601 2023 321 2034 60 625 62 38 40 41 601 123 792 2085 40 41 59 125 306 758 601 2023 321 2034 60 2023 321 2032 62 38 40 41 601 123 792 2086 40 41 59 125 306 758 2036 40 41 601 59 306 704 2087 40 41 601 59 306 2002 2088 40 41 601 59 306 625 2089 40 41 601 59 306 601 582 42 2090 40 41 601 59 306 601 2023 321 2034 60 704 62 38 2091 40 41 601 59 306 601 2023 321 2034 60 2002 62 38 2092 40 41 601 59 306 601 2023 321 2034 60 625 62 38 2093 40 41 601 59 306 601 2023 321 2034 60 2023 321 2032 62 38 2094 40 41 601 59 125 59 306 587 2000 2095 123 667 587 2001 59 816 2096 59 2097 321 2098 60 2096 62 2099 59 2095 40 601 2001 42 2100 44 704 2101 41 59 777 58 330 2095 40 2095 307 2102 41 748 59 330 126 2095 40 41 59 601 2021 38 758 42 40 41 601 59 2095 38 758 349 40 41 59 569 758 340 40 601 2095 38 2103 41 601 59 330 125 59 306 2095 2104 40 41 601 59 306 2095 2105 40 41 601 59 601 2021 758 91 93 40 704 2106 41 601 59 2021 758 91 93 40 704 2106 41 59 306 587 2107 58 777 2108 321 2109 123 125 59 601 2021 758 91 93 40 601 582 42 2110 41 601 59 2021 758 91 93 40 601 582 42 2110 41 59 2004 42 2111 40 41 123 792 2005 59 125 601 2004 42 2111 40 41 601 123 792 2005 59 125 2112 2113 40 2006 42 41 59 2112 2114 40 601 2006 42 41 59 2006 42 2115 40 41 59 601 2006 42 2115 40 41 601 59 2006 42 2116 40 41 2117 59 704 2118 40 41 601 123 792 2005 354 2118 40 41 59 125 2119 42 2120 40 704 2106 41 123 792 2005 354 2121 40 2106 41 59 125 601 2119 42 2120 40 704 2106 41 601 123 792 2005 354 2122 40 2106 41 59 125 704 2123 40 601 582 42 2124 41 601 123 792 2005 354 2123 40 2124 41 59 125 2006 42 2125 40 704 2106 41 59 601 2006 42 2125 40 704 2106 41 601 59 2006 42 2116 40 704 2106 41 59 2006 42 2125 40 601 582 42 2126 41 59 601 2006 42 2125 40 601 582 42 2126 41 601 59 2112 2127 40 704 2106 44 2006 42 41 59 2112 2128 40 704 2106 44 601 2006 42 41 59 2001 42 2129 40 41 601 2117 59 864 2130 2131 40 601 2001 42 2132 41 601 59 704 2133 40 41 601 123 792 2005 354 2133 40 41 59 125 601 2134 42 2135 40 704 2106 41 601 123 792 2005 354 2136 40 2106 41 59 125 2134 42 2135 40 704 2106 41 123 792 2005 354 2137 40 2106 41 59 125 704 2138 40 601 582 42 2124 41 601 123 792 2005 354 2138 40 2124 41 59 125 704 2139 40 704 2106 41 601 59 865 2140 40 704 2106 41 59 569 2141 40 704 2106 41 601 59 865 2142 40 704 2106 41 59 569 2143 40 704 2106 41 601 59 2008 42 2144 40 704 2013 41 123 792 2009 43 2013 59 125 601 2008 42 2144 40 704 2013 41 601 123 792 2009 43 2013 59 125 704 2145 40 704 2013 41 601 59 2002 2146 40 704 2013 41 601 59 625 2147 40 704 2013 41 601 59 601 582 42 2148 40 704 2013 41 601 59 601 704 42 2149 40 704 2013 44 704 42 2150 41 601 59 601 2002 42 2151 40 704 2013 44 704 42 2150 41 601 59 601 625 42 2152 40 704 2013 44 704 42 2150 41 601 59 582 42 42 2153 40 704 2013 41 601 59 2154 42 2155 40 704 2013 44 704 42 2150 41 601 59 704 2156 40 704 2013 44 704 42 2157 44 704 42 2158 44 704 42 2159 44 704 42 2160 44 704 42 2161 44 704 42 2162 44 704 42 2163 41 601 59 704 2156 40 704 2013 44 704 42 2157 44 704 42 2158 44 704 42 2159 44 704 42 2160 44 704 42 2161 44 660 42 2164 44 704 42 2163 41 601 59 582 42 2165 40 704 2013 41 601 59 704 2145 40 601 582 42 2126 41 601 123 792 2145 40 2138 40 2126 41 41 59 125 2002 2146 40 601 582 42 2126 41 601 123 792 2146 40 2138 40 2126 41 41 59 125 625 2147 40 601 582 42 2126 41 601 123 792 2147 40 2138 40 2126 41 41 59 125 601 582 42 2148 40 601 582 42 2126 41 601 123 792 2148 40 2138 40 2126 41 41 59 125 601 704 42 2149 40 601 582 42 2126 44 704 42 2150 41 601 123 792 2149 40 2138 40 2126 41 44 2150 41 59 125 601 2002 42 2151 40 601 582 42 2126 44 704 42 2150 41 601 123 792 2151 40 2138 40 2126 41 44 2150 41 59 125 601 625 42 2152 40 601 582 42 2126 44 704 42 2150 41 601 123 792 2152 40 2138 40 2126 41 44 2150 41 59 125 582 42 42 2153 40 601 582 42 2126 41 601 123 792 2153 40 2138 40 2126 41 41 59 125 865 2166 40 704 2013 44 704 2167 41 59 865 2166 40 704 2013 44 2002 2167 41 59 865 2166 40 704 2013 44 625 2168 41 59 865 2166 40 704 2013 44 601 582 42 2169 41 59 865 2166 40 704 2013 44 704 2170 44 601 704 42 2171 41 59 865 2166 40 704 2013 44 704 2170 44 601 2002 42 2171 41 59 865 2166 40 704 2013 44 704 2170 44 601 625 42 2172 41 59 865 2166 40 704 2013 44 601 582 42 601 42 2173 41 59 865 2166 40 704 2013 44 2008 42 2014 41 59 865 2166 40 704 2013 44 704 2170 44 601 865 42 2174 41 59 865 2166 40 704 2013 44 704 2175 44 704 2176 44 704 2177 44 704 2178 61 1500 44 704 2179 61 1500 44 660 2180 61 1500 44 704 2181 61 1500 41 59 865 2166 40 601 582 42 2126 44 704 2167 41 123 2166 40 2138 40 2126 41 44 2167 41 59 125 865 2166 40 601 582 42 2126 44 2002 2167 41 123 2166 40 2138 40 2126 41 44 2167 41 59 125 865 2166 40 601 582 42 2126 44 625 2168 41 123 2166 40 2138 40 2126 41 44 2168 41 59 125 865 2166 40 601 582 42 2126 44 601 582 42 2169 41 123 2166 40 2138 40 2126 41 44 2169 41 59 125 865 2166 40 601 582 42 2126 44 704 2170 44 601 704 42 2171 41 123 2166 40 2138 40 2126 41 44 2170 44 2171 41 59 125 865 2166 40 601 582 42 2126 44 704 2170 44 601 2002 42 2171 41 123 2166 40 2138 40 2126 41 44 2170 44 2171 41 59 125 865 2166 40 601 582 42 2126 44 704 2170 44 601 625 42 2172 41 123 2166 40 2138 40 2126 41 44 2170 44 2172 41 59 125 865 2166 40 601 582 42 2126 44 601 582 42 601 42 2173 41 123 2166 40 2138 40 2126 41 44 2173 41 59 125 865 2166 40 601 582 42 2126 44 2008 42 2014 41 123 2166 40 2138 40 2126 41 44 2014 41 59 125 865 2166 40 601 582 42 2126 44 704 2175 44 704 2176 44 704 2177 44 704 2178 61 1500 44 704 2179 61 1500 44 660 2180 61 1500 44 704 2181 61 1500 41 123 2166 40 2138 40 2126 41 44 2175 44 2176 44 2177 44 2178 44 2179 44 2180 44 2181 41 59 125 2002 2182 40 41 601 123 792 2003 59 125 864 2112 2183 40 2002 2184 41 59 865 2185 40 2186 42 44 582 42 42 2187 61 753 41 601 59 2112 2188 40 601 2001 42 44 704 61 2189 41 59 2112 2188 40 601 2001 42 44 601 704 42 44 704 61 2189 41 59 2112 2190 40 601 2001 42 44 601 704 42 44 704 61 2189 41 59 330 2112 2191 40 2004 42 2192 44 601 704 42 2193 41 59 865 2194 40 41 59 2112 2195 40 2004 42 2192 44 601 704 42 2193 41 59 330 704 2196 40 704 2197 44 704 2198 41 601 59 865 2199 40 704 2200 44 582 42 42 2187 41 59 864 601 582 42 2201 40 41 601 59 864 865 2202 40 601 582 42 41 59 864 865 2203 40 582 42 41 59 306 864 2016 42 2204 40 41 601 123 792 2017 59 125 305 864 865 2205 40 2016 42 2206 41 59 864 865 2207 40 2016 42 2206 41 59 601 582 42 2208 40 41 601 123 792 2010 59 125 601 582 42 2209 40 41 601 123 792 2011 59 125 865 2210 40 601 582 42 2211 41 59 865 2212 40 601 582 42 2213 41 59 809 2001 42 2214 40 2004 42 41 59 809 865 2215 40 2001 42 41 59 306 809 700 2216 2217 40 2001 42 2132 41 123 792 786 60 2216 62 40 2132 41 59 125 306 809 700 2001 42 2218 40 2216 2219 41 123 792 786 60 2001 42 62 40 2219 41 59 125 773 58 2220 40 2001 41 125 59 ,"{'AvgLine': 28, 'CountLine': 3419, 'CountStmt': 1594, 'MaxNesting': 6, 'AvgLineCode': 25, 'AvgEssential': 3, 'AvgLineBlank': 3, 'CountStmtExe': 1369, 'MaxEssential': 42, 'SumEssential': 348, 'AvgCyclomatic': 5, 'CountLineCode': 2877, 'CountStmtDecl': 448, 'MaxCyclomatic': 46, 'SumCyclomatic': 586, 'AltAvgLineCode': 25, 'AvgLineComment': 0, 'CountClassBase': 0, 'CountLineBlank': 386, 'CountStmtEmpty': 4, 'AltAvgLineBlank': 3, 'CountDeclMethod': 109, 'AltCountLineCode': 2877, 'CountLineCodeExe': 2097, 'CountLineComment': 158, 'AltAvgLineComment': 0, 'AltCountLineBlank': 386, 'CountClassCoupled': 16, 'CountClassDerived': 2, 'CountLineCodeDecl': 482, 'CountLineInactive': 0, 'CountDeclMethodAll': 109, 'MaxInheritanceTree': 0, 'RatioCommentToCode': '0.05', 'AltCountLineComment': 158, 'AvgCyclomaticStrict': 6, 'MaxCyclomaticStrict': 66, 'SumCyclomaticStrict': 703, 'CountDeclClassMethod': 4, 'CountDeclMethodConst': 48, 'AvgCyclomaticModified': 5, 'CountDeclMethodFriend': 0, 'CountDeclMethodPublic': 105, 'CountLinePreprocessor': 0, 'MaxCyclomaticModified': 43, 'PercentLackOfCohesion': 87, 'SumCyclomaticModified': 540, 'CountDeclClassVariable': 0, 'CountDeclMethodPrivate': 3, 'CountDeclInstanceMethod': 105, 'CountDeclMethodProtected': 1, 'CountDeclInstanceVariable': 9, 'CountDeclInstanceVariablePublic': 1, 'CountDeclInstanceVariablePrivate': 5, 'CountDeclInstanceVariableProtected': 3}"
