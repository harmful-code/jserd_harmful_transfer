id,language,text,smell,tokens,metrics
2613,Java,"    private static final class FutureInventory {

        /**
         * The time that we initially expected the inventory to be provided, in milliseconds
         */
        private final long time;

        /**
         * The amount of slots in the inventory
         */
        private final int slots;

        /**
         * The type of inventory
         */
        private final String type;

        /**
         * The position of the inventory container
         */
        private final BlockPos pos;

        private FutureInventory(long time, int slots, String type, BlockPos pos) {
            this.time = time;
            this.slots = slots;
            this.type = type;
            this.pos = pos;
            // betterblockpos has censoring
            System.out.println(""Future inventory created "" + time + "" "" + slots + "" "" + type + "" "" + BetterBlockPos.from(pos));
        }
    }",0,773 809 657 587 2000 123 306 773 657 726 2001 59 306 773 657 704 2002 59 306 773 657 2003 2004 59 306 773 657 2005 2006 59 773 2000 40 726 2001 44 704 2002 44 2003 2004 44 2005 2006 41 123 823 46 2001 61 2001 59 823 46 2002 61 2002 59 823 46 2004 61 2004 59 823 46 2006 61 2006 59 330 2007 46 2008 46 2009 40 362 43 2001 43 362 43 2002 43 362 43 2004 43 362 43 2010 46 2011 40 2006 41 41 59 125 125 ,"{'AvgLine': 8, 'CountLine': 34, 'CountStmt': 11, 'MaxNesting': 0, 'AvgLineCode': 7, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 5, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 1, 'CountLineCode': 13, 'CountStmtDecl': 6, 'MaxCyclomatic': 1, 'SumCyclomatic': 1, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 5, 'CountSemicolon': 9, 'CountDeclMethod': 1, 'CountLineCodeExe': 5, 'CountLineComment': 16, 'CountClassCoupled': 3, 'CountClassDerived': 0, 'CountLineCodeDecl': 6, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '1.23', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 1, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 0, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 1, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 1, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 3, 'CountDeclInstanceVariable': 4, 'PercentLackOfCohesionModified': 0}"
4130,Java,"@Getter
@EqualsAndHashCode(callSuper = true)
public class BlindVoteStateBlock extends StateBlock<BlindVoteStateHash> {
    public BlindVoteStateBlock(BlindVoteStateHash myBlindVoteStateHash) {
        super(myBlindVoteStateHash);
    }

    public int getNumBlindVotes() {
        return myStateHash.getNumBlindVotes();
    }
}",0,64 2000 64 2001 40 2002 61 2003 41 777 587 2004 650 2005 60 2006 62 123 777 2004 40 2006 2007 41 123 818 40 2007 41 59 125 777 704 2008 40 41 123 792 2009 46 2008 40 41 59 125 125 ,"{'AvgLine': 3, 'CountLine': 11, 'CountStmt': 5, 'MaxNesting': 0, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 10, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 1, 'CountSemicolon': 2, 'CountDeclMethod': 2, 'CountLineCodeExe': 2, 'CountLineComment': 0, 'CountClassCoupled': 3, 'CountClassDerived': 0, 'CountLineCodeDecl': 5, 'CountDeclMethodAll': 8, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 2, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 3, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2858,Java,"@Slf4j
@Singleton
public class FxmlViewLoader implements ViewLoader {

    private final ViewFactory viewFactory;
    private final ResourceBundle resourceBundle;

    @Inject
    public FxmlViewLoader(ViewFactory viewFactory, ResourceBundle resourceBundle) {
        this.viewFactory = viewFactory;
        this.resourceBundle = resourceBundle;
    }

    @SuppressWarnings(""unchecked"")
    public View load(Class<? extends View> viewClass) {
        FxmlView fxmlView = viewClass.getAnnotation(FxmlView.class);

        final Class<? extends FxmlView.PathConvention> convention;
        final Class<? extends FxmlView.PathConvention> defaultConvention =
                (Class<? extends FxmlView.PathConvention>) getDefaultValue(FxmlView.class, ""convention"");

        final String specifiedLocation;
        final String defaultLocation = (String) getDefaultValue(FxmlView.class, ""location"");

        if (fxmlView == null) {
            convention = defaultConvention;
            specifiedLocation = defaultLocation;
        } else {
            convention = fxmlView.convention();
            specifiedLocation = fxmlView.location();
        }

        if (convention == null || specifiedLocation == null)
            throw new IllegalStateException(""Convention and location should never be null."");


        try {
            final String resolvedLocation;
            if (specifiedLocation.equals(defaultLocation))
                resolvedLocation = convention.newInstance().apply(viewClass);
            else
                resolvedLocation = specifiedLocation;

            URL fxmlUrl = viewClass.getClassLoader().getResource(resolvedLocation);
            if (fxmlUrl == null)
                throw new ViewfxException(
                        ""Failed to load view class [%s] because FXML file at [%s] could not be loaded "" +
                                ""as a classpath resource. Does it exist?"", viewClass, specifiedLocation);

            return loadFromFxml(fxmlUrl);
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new ViewfxException(ex, ""Failed to load view from class %s"", viewClass);
        }
    }

    private View loadFromFxml(URL fxmlUrl) {
        checkNotNull(fxmlUrl, ""FXML URL must not be null"");
        try {
            FXMLLoader loader = new FXMLLoader(fxmlUrl, resourceBundle);
            loader.setControllerFactory(viewFactory);
            loader.load();
            Object controller = loader.getController();
            if (controller == null)
                throw new ViewfxException(""Failed to load view from FXML file at [%s]. "" +
                        ""Does it declare an fx:controller attribute?"", fxmlUrl);
            if (!(controller instanceof View))
                throw new ViewfxException(""Controller of type [%s] loaded from FXML file at [%s] "" +
                        ""does not implement [%s] as expected."", controller.getClass(), fxmlUrl, View.class);
            return (View) controller;
        } catch (IOException ex) {
            Throwable cause = ex.getCause();
            if (cause != null) {
                cause.printStackTrace();
                log.error(cause.toString());
                // We want to show stackTrace in error popup
                String stackTrace = Utilities.toTruncatedString(Joiner.on(""\n"").join(cause.getStackTrace()), 800, false);
                throw new ViewfxException(cause, ""%s at loading view class\nStack trace:\n%s"",
                        cause.getClass().getSimpleName(), stackTrace);
            } else {
                throw new ViewfxException(ex, ""Failed to load view from FXML file at [%s]"", fxmlUrl);
            }
        }
    }

    /**
     * Copied and adapted from Spring Framework v4.3.6's AnnotationUtils#defaultValue
     * method in order to make it possible to drop Bisq's dependency on Spring altogether.
     */
    @SuppressWarnings(""SameParameterValue"")
    private static Object getDefaultValue(Class<? extends Annotation> annotationType, String attributeName) {
        if (annotationType == null || attributeName == null || attributeName.length() == 0) {
            return null;
        }
        try {
            return annotationType.getDeclaredMethod(attributeName).getDefaultValue();
        } catch (Exception ex) {
            return null;
        }
    }
}",0,64 2000 64 2001 777 587 2002 693 2003 123 773 657 2004 2005 59 773 657 2006 2007 59 64 2008 777 2002 40 2004 2005 44 2006 2007 41 123 823 46 2005 61 2005 59 823 46 2007 61 2007 59 125 64 2009 40 362 41 777 2010 2011 40 2012 60 63 650 2010 62 2013 41 123 2014 2015 61 2013 46 2016 40 2014 46 587 41 59 657 2012 60 63 650 2014 46 2017 62 2018 59 657 2012 60 63 650 2014 46 2017 62 2019 61 40 2012 60 63 650 2014 46 2017 62 41 2020 40 2014 46 587 44 362 41 59 657 2021 2022 59 657 2021 2023 61 40 2021 41 2020 40 2014 46 587 44 362 41 59 688 40 2015 323 2024 41 123 2018 61 2019 59 2022 61 2023 59 125 630 123 2018 61 2015 46 2018 40 41 59 2022 61 2015 46 2025 40 41 59 125 688 40 2018 323 2024 309 2022 323 2024 41 825 744 2026 40 362 41 59 830 123 657 2021 2027 59 688 40 2022 46 2028 40 2023 41 41 2027 61 2018 46 2029 40 41 46 2030 40 2013 41 59 630 2027 61 2022 59 2031 2032 61 2013 46 2033 40 41 46 2034 40 2027 41 59 688 40 2032 323 2024 41 825 744 2035 40 362 43 362 44 2013 44 2022 41 59 792 2036 40 2032 41 59 125 580 40 2037 124 2038 2039 41 123 825 744 2040 40 2039 44 362 44 2013 41 59 125 125 773 2010 2041 40 2042 2043 41 123 2044 40 2043 44 362 41 59 830 123 2045 2046 61 744 2045 40 2043 44 2007 41 59 2046 46 2047 40 2005 41 59 2046 46 2011 40 41 59 2048 2049 61 2046 46 2050 40 41 59 688 40 2049 323 2051 41 825 744 2052 40 362 43 362 44 2043 41 59 688 40 33 40 2049 702 2010 41 41 825 744 2052 40 362 43 362 44 2049 46 2053 40 41 44 2043 44 2010 46 587 41 59 792 40 2010 41 2049 59 125 580 40 2054 2055 41 123 2056 2057 61 2055 46 2058 40 41 59 688 40 2057 340 2059 41 123 2057 46 2060 40 41 59 2061 46 2062 40 2057 46 2063 40 41 41 59 330 2064 2065 61 2066 46 2067 40 2068 46 2069 40 362 41 46 2070 40 2057 46 2071 40 41 41 44 1504 44 2072 41 59 825 744 2073 40 2057 44 362 44 2057 46 2074 40 41 46 2075 40 41 44 2065 41 59 125 630 123 825 744 2076 40 2055 44 362 44 2043 41 59 125 125 125 306 64 2009 40 362 41 773 809 2077 2078 40 2012 60 63 650 2079 62 2080 44 2081 2082 41 123 688 40 2080 323 2083 309 2082 323 2083 309 2082 46 2084 40 41 323 1500 41 123 792 2083 59 125 830 123 792 2080 46 2085 40 2082 41 46 2078 40 41 59 125 580 40 2086 2087 41 123 792 2083 59 125 125 125 ,"{'AvgLine': 22, 'CountLine': 100, 'CountStmt': 54, 'MaxNesting': 2, 'AvgLineCode': 19, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 44, 'MaxEssential': 3, 'SumEssential': 6, 'AvgCyclomatic': 3, 'CountLineCode': 82, 'CountStmtDecl': 18, 'MaxCyclomatic': 6, 'SumCyclomatic': 15, 'AvgLineComment': 1, 'CountClassBase': 2, 'CountLineBlank': 13, 'CountSemicolon': 38, 'CountDeclMethod': 4, 'CountLineCodeExe': 55, 'CountLineComment': 5, 'CountClassCoupled': 21, 'CountClassDerived': 0, 'CountLineCodeDecl': 24, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.06', 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 7, 'SumCyclomaticStrict': 18, 'CountDeclClassMethod': 1, 'AvgCyclomaticModified': 3, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 50, 'SumCyclomaticModified': 15, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 3, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 21, 'CountDeclInstanceVariable': 2, 'PercentLackOfCohesionModified': 25}"
2813,Java,"@Slf4j
public abstract class Metric extends Configurable implements Runnable {

    private static final String INTERVAL = ""run.interval"";
    private static ScheduledExecutorService executor;
    protected final Reporter reporter;
    private ScheduledFuture<?> scheduler;

    /**
     * disable execution
     */
    private void disable() {
        if (scheduler != null)
            scheduler.cancel(false);
    }

    /**
     * enable execution
     */
    private void enable() {
        scheduler = executor.scheduleWithFixedDelay(this, new Random().nextInt(60),
                Long.parseLong(configuration.getProperty(INTERVAL)), TimeUnit.SECONDS);
    }

    /**
     * Constructor.
     */
    protected Metric(Reporter reporter) {

        this.reporter = reporter;

        setName(this.getClass().getSimpleName());

        if (executor == null) {
            executor = new ScheduledThreadPoolExecutor(6);
        }
    }

    boolean enabled() {
        if (scheduler != null)
            return !scheduler.isCancelled();
        else
            return false;
    }

    @Override
    public void configure(final Properties properties) {
        synchronized (this) {
            log.info(""{} (re)loading config..."", getName());
            super.configure(properties);
            reporter.configure(properties);

            Version.setBaseCryptoNetworkId(Integer.parseInt(properties.getProperty(""System."" + BASE_CURRENCY_NETWORK, ""1""))); // defaults to BTC_TESTNET

            // decide whether to enable or disable the task
            if (configuration.isEmpty() || !configuration.getProperty(""enabled"", ""false"").equals(""true"")
                    || !configuration.containsKey(INTERVAL)) {
                disable();

                // some informative log output
                if (configuration.isEmpty())
                    log.error(""{} is not configured at all. Will not run."", getName());
                else if (!configuration.getProperty(""enabled"", ""false"").equals(""true""))
                    log.info(""{} is deactivated. Will not run."", getName());
                else if (!configuration.containsKey(INTERVAL))
                    log.error(""{} is missing mandatory '"" + INTERVAL + ""' property. Will not run."", getName());
                else
                    log.error(""{} is mis-configured. Will not run."", getName());
            } else if (!enabled() && configuration.getProperty(""enabled"", ""false"").equals(""true"")) {
                // check if this Metric got activated after being disabled.
                // if so, resume execution
                enable();
                log.info(""{} got activated. Starting up."", getName());
            }
        }
    }

    @Override
    public void run() {
        try {
            Thread.currentThread().setName(""Metric: "" + getName());

            // execute all the things
            synchronized (this) {
                log.info(""{} started"", getName());
                execute();
                log.info(""{} done"", getName());
            }
        } catch (Throwable e) {
            log.error(""A metric misbehaved!"", e);
        }
    }

    /**
     * Gets scheduled repeatedly.
     */
    protected abstract void execute();

    /**
     * initiate an orderly shutdown on all metrics. Blocks until all metrics are
     * shut down or after one minute.
     */
    public static void haltAllMetrics() {
        Utilities.shutdownAndAwaitTermination(executor, 2, TimeUnit.MINUTES);
    }
}",0,64 2000 777 539 587 2001 650 2002 693 2003 123 773 809 657 2004 2005 61 362 59 773 809 2006 2007 59 775 657 2008 2009 59 773 2010 60 63 62 2011 59 306 773 865 2012 40 41 123 688 40 2011 340 2013 41 2011 46 2014 40 2015 41 59 125 306 773 865 2016 40 41 123 2011 61 2007 46 2017 40 823 44 744 2018 40 41 46 2019 40 1503 41 44 2020 46 2021 40 2022 46 2023 40 2005 41 41 44 2024 46 2025 41 59 125 306 775 2001 40 2008 2009 41 123 823 46 2009 61 2009 59 2026 40 823 46 2027 40 41 46 2028 40 41 41 59 688 40 2007 323 2029 41 123 2007 61 744 2030 40 1502 41 59 125 125 570 2031 40 41 123 688 40 2011 340 2032 41 792 33 2011 46 2033 40 41 59 630 792 2034 59 125 64 2035 777 865 2036 40 657 2037 2038 41 123 821 40 823 41 123 2039 46 2040 40 362 44 2041 40 41 41 59 818 46 2036 40 2038 41 59 2009 46 2036 40 2038 41 59 2042 46 2043 40 2044 46 2045 40 2038 46 2046 40 362 43 2047 44 362 41 41 41 59 330 330 688 40 2048 46 2049 40 41 309 33 2048 46 2046 40 362 44 362 41 46 2050 40 362 41 309 33 2048 46 2051 40 2005 41 41 123 2012 40 41 59 330 688 40 2048 46 2049 40 41 41 2039 46 2052 40 362 44 2041 40 41 41 59 630 688 40 33 2048 46 2046 40 362 44 362 41 46 2050 40 362 41 41 2039 46 2040 40 362 44 2041 40 41 41 59 630 688 40 33 2048 46 2051 40 2005 41 41 2039 46 2052 40 362 43 2005 43 362 44 2041 40 41 41 59 630 2039 46 2052 40 362 44 2041 40 41 41 59 125 630 688 40 33 2031 40 41 307 2048 46 2046 40 362 44 362 41 46 2050 40 362 41 41 123 330 330 2016 40 41 59 2039 46 2040 40 362 44 2041 40 41 41 59 125 125 125 64 2035 777 865 2053 40 41 123 830 123 2054 46 2055 40 41 46 2056 40 362 43 2057 40 41 41 59 330 821 40 823 41 123 2058 46 2059 40 362 44 2057 40 41 41 59 2060 40 41 59 2058 46 2059 40 362 44 2057 40 41 41 59 125 125 580 40 2061 2062 41 123 2063 46 2064 40 362 44 2062 41 59 125 125 306 775 539 865 2065 40 41 59 306 777 809 865 2066 40 41 123 2067 46 2068 40 2007 44 1502 44 2069 46 2070 41 59 125 125 ,"{'AvgLine': 12, 'CountLine': 114, 'CountStmt': 48, 'MaxNesting': 2, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 35, 'MaxEssential': 1, 'SumEssential': 7, 'AvgCyclomatic': 2, 'CountLineCode': 69, 'CountStmtDecl': 13, 'MaxCyclomatic': 6, 'SumCyclomatic': 16, 'AvgLineComment': 2, 'CountClassBase': 2, 'CountLineBlank': 16, 'CountSemicolon': 29, 'CountDeclMethod': 8, 'CountLineCodeExe': 41, 'CountLineComment': 30, 'CountClassCoupled': 14, 'CountClassDerived': 8, 'CountLineCodeDecl': 16, 'CountDeclMethodAll': 11, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.43', 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 9, 'SumCyclomaticStrict': 19, 'CountDeclClassMethod': 1, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 3, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 61, 'SumCyclomaticModified': 16, 'CountDeclClassVariable': 2, 'CountDeclMethodDefault': 1, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 2, 'CountClassCoupledModified': 14, 'CountDeclInstanceVariable': 2, 'PercentLackOfCohesionModified': 52}"
2814,Java,"public class OnionParser {

    public static NodeAddress getNodeAddress(final String current) throws MalformedURLException {
        String nodeAddress = current.trim();
        if (!nodeAddress.startsWith(""http://""))
            nodeAddress = ""http://"" + nodeAddress;
        URL tmp = new URL(nodeAddress);
        return new NodeAddress(tmp.getHost(), tmp.getPort() > 0 ? tmp.getPort() : 80);
    }

    public static String prettyPrint(final NodeAddress host) {
        return host.getHostNameWithoutPostFix();
    }

    public static String prettyPrint(String host) throws MalformedURLException {
        return prettyPrint(getNodeAddress(host));
    }
}",0,777 587 2000 123 777 809 2001 2002 40 657 2003 2004 41 826 2005 123 2003 2006 61 2004 46 2007 40 41 59 688 40 33 2006 46 2008 40 362 41 41 2006 61 362 43 2006 59 2009 2010 61 744 2009 40 2006 41 59 792 744 2001 40 2010 46 2011 40 41 44 2010 46 2012 40 41 62 1500 63 2010 46 2012 40 41 58 1503 41 59 125 777 809 2003 2013 40 657 2001 2014 41 123 792 2014 46 2015 40 41 59 125 777 809 2003 2013 40 2003 2014 41 826 2005 123 792 2013 40 2002 40 2014 41 41 59 125 125 ,"{'AvgLine': 4, 'CountLine': 23, 'CountStmt': 11, 'MaxNesting': 1, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 7, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 1, 'CountLineCode': 15, 'CountStmtDecl': 6, 'MaxCyclomatic': 3, 'SumCyclomatic': 5, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountSemicolon': 6, 'CountDeclMethod': 3, 'CountLineCodeExe': 7, 'CountLineComment': 7, 'CountClassCoupled': 4, 'CountClassDerived': 0, 'CountLineCodeDecl': 6, 'CountDeclMethodAll': 3, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.47', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 5, 'CountDeclClassMethod': 3, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 3, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 5, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 0, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 4, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2948,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final Dispute item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    Button button = getRegularIconButton(MaterialDesignIcon.INFORMATION_OUTLINE);
                                    JFXBadge badge = new JFXBadge(new Label(""""), Pos.BASELINE_RIGHT);
                                    badge.setPosition(Pos.TOP_RIGHT);
                                    badge.setVisible(item.isNew());
                                    badge.setText(""New"");
                                    badge.getStyleClass().add(""new"");
                                    newBadgeByDispute.put(item.getId(), badge);
                                    HBox hBox = new HBox(button, badge);
                                    setGraphic(hBox);
                                    button.setOnAction(e -> {
                                        tableView.getSelectionModel().select(this.getIndex());
                                        onOpenContract(item);
                                        item.setDisputeSeen(senderFlag());
                                        badge.setVisible(item.isNew());
                                    });
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };",0,792 744 2000 60 62 40 41 123 64 2001 777 865 2002 40 657 2003 2004 44 570 2005 41 123 818 46 2002 40 2004 44 2005 41 59 688 40 2004 340 2006 307 33 2005 41 123 2007 2008 61 2009 40 2010 46 2011 41 59 2012 2013 61 744 2012 40 744 2014 40 362 41 44 2015 46 2016 41 59 2013 46 2017 40 2015 46 2018 41 59 2013 46 2019 40 2004 46 2020 40 41 41 59 2013 46 2021 40 362 41 59 2013 46 2022 40 41 46 2023 40 362 41 59 2024 46 2025 40 2004 46 2026 40 41 44 2013 41 59 2027 2028 61 744 2027 40 2008 44 2013 41 59 2029 40 2028 41 59 2008 46 2030 40 2031 45 62 123 2032 46 2033 40 41 46 2034 40 823 46 2035 40 41 41 59 2036 40 2004 41 59 2004 46 2037 40 2038 40 41 41 59 2013 46 2019 40 2004 46 2020 40 41 41 59 125 41 59 125 630 123 2039 40 2006 41 59 125 125 125 59 ,"{'AvgLine': 23, 'CountLine': 24, 'CountStmt': 18, 'MaxNesting': 1, 'AvgLineCode': 23, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 17, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 2, 'CountLineCode': 24, 'CountStmtDecl': 4, 'MaxCyclomatic': 2, 'SumCyclomatic': 3, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 0, 'CountSemicolon': 16, 'CountDeclMethod': 1, 'CountLineCodeExe': 22, 'CountLineComment': 0, 'CountClassCoupled': 10, 'CountClassDerived': 0, 'CountLineCodeDecl': 3, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 4, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 1, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 3, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 1, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 10, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2843,Java,"@Disabled
@Slf4j
@TestMethodOrder(OrderAnnotation.class)
public class BtcTxFeeRateTest extends MethodTest {

    @BeforeAll
    public static void setUp() {
        startSupportingApps(false,
                true,
                bitcoind,
                seednode,
                alicedaemon);
    }

    @Test
    @Order(1)
    public void testGetTxFeeRate(final TestInfo testInfo) {
        var txFeeRateInfo = TxFeeRateInfo.fromProto(aliceClient.getTxFeeRate());
        log.debug(""{} -> Fee rate with no preference: {}"", testName(testInfo), txFeeRateInfo);

        assertFalse(txFeeRateInfo.isUseCustomTxFeeRate());
        assertTrue(txFeeRateInfo.getFeeServiceRate() > 0);
    }

    @Test
    @Order(2)
    public void testSetInvalidTxFeeRateShouldThrowException(final TestInfo testInfo) {
        var currentTxFeeRateInfo = TxFeeRateInfo.fromProto(aliceClient.getTxFeeRate());
        Throwable exception = assertThrows(StatusRuntimeException.class, () -> aliceClient.setTxFeeRate(1));
        String expectedExceptionMessage =
                format(""UNKNOWN: tx fee rate preference must be >= %d sats/byte"",
                        currentTxFeeRateInfo.getMinFeeServiceRate());
        assertEquals(expectedExceptionMessage, exception.getMessage());
    }

    @Test
    @Order(3)
    public void testSetValidTxFeeRate(final TestInfo testInfo) {
        var currentTxFeeRateInfo = TxFeeRateInfo.fromProto(aliceClient.getTxFeeRate());
        var customFeeRate = currentTxFeeRateInfo.getMinFeeServiceRate() + 5;
        var txFeeRateInfo = TxFeeRateInfo.fromProto(aliceClient.setTxFeeRate(customFeeRate));
        log.debug(""{} -> Fee rates with custom preference: {}"", testName(testInfo), txFeeRateInfo);

        assertTrue(txFeeRateInfo.isUseCustomTxFeeRate());
        assertEquals(customFeeRate, txFeeRateInfo.getCustomTxFeeRate());
        assertTrue(txFeeRateInfo.getFeeServiceRate() > 0);
    }

    @Test
    @Order(4)
    public void testUnsetTxFeeRate(final TestInfo testInfo) {
        var txFeeRateInfo = TxFeeRateInfo.fromProto(aliceClient.unsetTxFeeRate());
        log.debug(""{} -> Fee rate with no preference: {}"", testName(testInfo), txFeeRateInfo);

        assertFalse(txFeeRateInfo.isUseCustomTxFeeRate());
        assertTrue(txFeeRateInfo.getFeeServiceRate() > 0);
    }

    @AfterAll
    public static void tearDown() {
        tearDownScaffold();
    }
}",0,64 2000 64 2001 64 2002 40 2003 46 587 41 777 587 2004 650 2005 123 64 2006 777 809 865 2007 40 41 123 2008 40 2009 44 2010 44 2011 44 2012 44 2013 41 59 125 64 2014 64 2015 40 1501 41 777 865 2016 40 657 2017 2018 41 123 2019 2020 61 2021 46 2022 40 2023 46 2024 40 41 41 59 2025 46 2026 40 362 44 2027 40 2018 41 44 2020 41 59 2028 40 2020 46 2029 40 41 41 59 2030 40 2020 46 2031 40 41 62 1500 41 59 125 64 2014 64 2015 40 1502 41 777 865 2032 40 657 2017 2018 41 123 2033 2034 61 2035 46 2036 40 2037 46 2038 40 41 41 59 2039 2040 61 2041 40 2042 46 587 44 40 41 45 62 2037 46 2043 40 1501 41 41 59 2044 2045 61 2046 40 362 44 2034 46 2047 40 41 41 59 2048 40 2045 44 2040 46 2049 40 41 41 59 125 64 2014 64 2015 40 1502 41 777 865 2050 40 657 2017 2018 41 123 2051 2052 61 2053 46 2054 40 2055 46 2056 40 41 41 59 2051 2057 61 2052 46 2058 40 41 43 1502 59 2051 2059 61 2053 46 2054 40 2055 46 2060 40 2057 41 41 59 2061 46 2062 40 362 44 2063 40 2018 41 44 2059 41 59 2064 40 2059 46 2065 40 41 41 59 2066 40 2057 44 2059 46 2067 40 41 41 59 2064 40 2059 46 2068 40 41 62 1500 41 59 125 64 2014 64 2015 40 1502 41 777 865 2069 40 657 2017 2018 41 123 2070 2071 61 2072 46 2073 40 2074 46 2075 40 41 41 59 2076 46 2077 40 362 44 2078 40 2018 41 44 2071 41 59 2079 40 2071 46 2080 40 41 41 59 2081 40 2071 46 2082 40 41 62 1500 41 59 125 64 2083 777 809 865 2084 40 41 123 2085 40 41 59 125 125 ,"{'AvgLine': 8, 'CountLine': 63, 'CountStmt': 28, 'MaxNesting': 0, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 21, 'MaxEssential': 1, 'SumEssential': 7, 'AvgCyclomatic': 1, 'CountLineCode': 54, 'CountStmtDecl': 15, 'MaxCyclomatic': 1, 'SumCyclomatic': 7, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 9, 'CountSemicolon': 21, 'CountDeclMethod': 6, 'CountLineCodeExe': 26, 'CountLineComment': 0, 'CountClassCoupled': 15, 'CountClassDerived': 0, 'CountLineCodeDecl': 29, 'CountDeclMethodAll': 26, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 7, 'CountDeclClassMethod': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 6, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 7, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 15, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2848,Java,"@EqualsAndHashCode(callSuper = true)
@ToString
@Getter
public final class FiatCurrency extends TradeCurrency {
    // http://boschista.deviantart.com/journal/Cool-ASCII-Symbols-214218618
    private final static String PREFIX = ""★ "";

    private final Currency currency;

    public FiatCurrency(String currencyCode) {
        this(Currency.getInstance(currencyCode), getLocale());
    }

    @SuppressWarnings(""WeakerAccess"")
    public FiatCurrency(Currency currency) {
        this(currency, getLocale());
    }

    @SuppressWarnings(""WeakerAccess"")
    public FiatCurrency(Currency currency, Locale locale) {
        super(currency.getCurrencyCode(), currency.getDisplayName(locale));
        this.currency = currency;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // PROTO BUFFER
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public Message toProtoMessage() {
        protobuf.Currency.Builder currencyBuilder = protobuf.Currency.newBuilder().setCurrencyCode(currency.getCurrencyCode());
        protobuf.FiatCurrency.Builder fiatCurrencyBuilder = protobuf.FiatCurrency.newBuilder().setCurrency(currencyBuilder);
        return getTradeCurrencyBuilder()
                .setFiatCurrency(fiatCurrencyBuilder)
                .build();
    }

    public static FiatCurrency fromProto(protobuf.TradeCurrency proto) {
        return new FiatCurrency(proto.getCode());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    private static Locale getLocale() {
        return GlobalSettings.getLocale();
    }

    @Override
    public String getDisplayPrefix() {
        return PREFIX;
    }

}",0,64 2000 40 2001 61 2002 41 64 2003 64 2004 777 657 587 2005 650 2006 123 330 773 657 809 2007 2008 61 362 59 773 657 2009 2010 59 777 2005 40 2007 2011 41 123 823 40 2009 46 2012 40 2011 41 44 2013 40 41 41 59 125 64 2014 40 362 41 777 2005 40 2009 2010 41 123 823 40 2010 44 2015 40 41 41 59 125 64 2014 40 362 41 777 2005 40 2009 2010 44 2016 2017 41 123 818 40 2010 46 2018 40 41 44 2010 46 2019 40 2017 41 41 59 823 46 2010 61 2010 59 125 331 330 331 64 2020 777 2021 2022 40 41 123 2023 46 2009 46 2024 2025 61 2023 46 2009 46 2026 40 41 46 2027 40 2010 46 2028 40 41 41 59 2023 46 2005 46 2024 2029 61 2023 46 2005 46 2026 40 41 46 2030 40 2025 41 59 792 2031 40 41 46 2032 40 2029 41 46 2033 40 41 59 125 777 809 2005 2034 40 2035 46 2006 2036 41 123 792 744 2005 40 2036 46 2037 40 41 41 59 125 331 330 331 773 809 2016 2038 40 41 123 792 2039 46 2038 40 41 59 125 64 2020 777 2007 2040 40 41 123 792 2008 59 125 125 ,"{'AvgLine': 4, 'CountLine': 57, 'CountStmt': 20, 'MaxNesting': 0, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 10, 'MaxEssential': 1, 'SumEssential': 7, 'AvgCyclomatic': 1, 'CountLineCode': 37, 'CountStmtDecl': 12, 'MaxCyclomatic': 1, 'SumCyclomatic': 7, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 13, 'CountSemicolon': 12, 'CountDeclMethod': 7, 'CountLineCodeExe': 13, 'CountLineComment': 7, 'CountClassCoupled': 13, 'CountClassDerived': 0, 'CountLineCodeDecl': 19, 'CountDeclMethodAll': 14, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.19', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 7, 'CountDeclClassMethod': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 6, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 71, 'SumCyclomaticModified': 7, 'CountDeclClassVariable': 1, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 13, 'CountDeclInstanceVariable': 1, 'PercentLackOfCohesionModified': 42}"
2740,Java,"@Getter
public class Checkpoint {
    final int height;
    final byte[] hash;
    @Setter
    boolean passed;

    public Checkpoint(int height, byte[] hash) {
        this.height = height;
        this.hash = hash;
    }

    @Override
    public String toString() {
        return ""Checkpoint {"" +
                ""\n     height="" + height +
                "",\n     hash="" + Utilities.bytesAsHexString(hash) +
                ""\n}"";
    }

}",0,64 2000 777 587 2001 123 657 704 2002 59 657 574 91 93 2003 59 64 2004 570 2005 59 777 2001 40 704 2002 44 574 91 93 2003 41 123 823 46 2002 61 2002 59 823 46 2003 61 2003 59 125 64 2006 777 2007 2008 40 41 123 792 362 43 362 43 2002 43 362 43 2009 46 2010 40 2003 41 43 362 59 125 125 ,"{'AvgLine': 5, 'CountLine': 21, 'CountStmt': 9, 'MaxNesting': 0, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 3, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 18, 'CountStmtDecl': 6, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountSemicolon': 6, 'CountDeclMethod': 2, 'CountLineCodeExe': 6, 'CountLineComment': 0, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 9, 'CountDeclMethodAll': 2, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 33, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 2, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 5, 'CountDeclInstanceVariable': 3, 'PercentLackOfCohesionModified': 33}"
3046,Java,"            BroadcastHandler.Listener listener = new BroadcastHandler.Listener() {
                @Override
                public void onSufficientlyBroadcast(List<Broadcaster.BroadcastRequest> broadcastRequests) {
                    broadcastRequests.stream()
                            .filter(broadcastRequest -> broadcastRequest.getMessage() instanceof AddDataMessage)
                            .filter(broadcastRequest -> {
                                AddDataMessage addDataMessage = (AddDataMessage) broadcastRequest.getMessage();
                                return addDataMessage.getProtectedStorageEntry().equals(protectedMailboxStorageEntry);
                            })
                            .forEach(e -> sendMailboxMessageListener.onStoredInMailbox());
                }

                @Override
                public void onNotSufficientlyBroadcast(int numOfCompletedBroadcasts, int numOfFailedBroadcast) {
                    sendMailboxMessageListener.onFault(""Message was not sufficiently broadcast.\n"" +
                            ""numOfCompletedBroadcasts: "" + numOfCompletedBroadcasts + "".\n"" +
                            ""numOfFailedBroadcast="" + numOfFailedBroadcast);
                }
            };",0,2000 46 2001 2002 61 744 2000 46 2001 40 41 123 64 2003 777 865 2004 40 2005 60 2006 46 2007 62 2008 41 123 2008 46 2009 40 41 46 2010 40 2011 45 62 2011 46 2012 40 41 702 2013 41 46 2010 40 2011 45 62 123 2013 2014 61 40 2013 41 2011 46 2012 40 41 59 792 2014 46 2015 40 41 46 2016 40 2017 41 59 125 41 46 2018 40 2019 45 62 2020 46 2021 40 41 41 59 125 64 2003 777 865 2022 40 704 2023 44 704 2024 41 123 2025 46 2026 40 362 43 362 43 2023 43 362 43 362 43 2024 41 59 125 125 59 ,"{'AvgLine': 8, 'CountLine': 18, 'CountStmt': 6, 'MaxNesting': 0, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 4, 'MaxEssential': 1, 'SumEssential': 5, 'AvgCyclomatic': 1, 'CountLineCode': 17, 'CountStmtDecl': 3, 'MaxCyclomatic': 1, 'SumCyclomatic': 5, 'AvgLineComment': 0, 'CountClassBase': 2, 'CountLineBlank': 1, 'CountSemicolon': 4, 'CountDeclMethod': 2, 'CountLineCodeExe': 15, 'CountLineComment': 0, 'CountClassCoupled': 5, 'CountClassDerived': 0, 'CountLineCodeDecl': 2, 'CountDeclMethodAll': 2, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 5, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 5, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 2, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 5, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2538,Java,"public final class PlayerUpdateEvent {

    /**
     * The state of the event
     */
    private final EventState state;

    public PlayerUpdateEvent(EventState state) {
        this.state = state;
    }

    /**
     * @return The state of the event
     */
    public final EventState getState() {
        return this.state;
    }
}",0,777 657 587 2000 123 306 773 657 2001 2002 59 777 2000 40 2001 2002 41 123 823 46 2002 61 2002 59 125 306 777 657 2001 2003 40 41 123 792 823 46 2002 59 125 125 ,"{'AvgLine': 4, 'CountLine': 22, 'CountStmt': 6, 'MaxNesting': 0, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 2, 'MaxEssential': 1, 'SumEssential': 2, 'AvgCyclomatic': 1, 'CountLineCode': 9, 'CountStmtDecl': 4, 'MaxCyclomatic': 1, 'SumCyclomatic': 2, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountSemicolon': 3, 'CountDeclMethod': 2, 'CountLineCodeExe': 2, 'CountLineComment': 10, 'CountClassCoupled': 1, 'CountClassDerived': 0, 'CountLineCodeDecl': 4, 'CountDeclMethodAll': 2, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '1.11', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 2, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 1, 'CountDeclInstanceVariable': 1, 'PercentLackOfCohesionModified': 0}"
2818,Java,"public class HeliumTest extends AbstractAssetTest {

    public HeliumTest() {
        super(new Helium());
    }

    @Test
    public void testValidAddresses() {
        assertValidAddress(""SPSXRJSwzGKxSiYXePf1vnkk4v9WKVLhZp"");
        assertValidAddress(""SbzXDLmMfWDJZ1wEikUVAMbAzM2UnaSt4g"");
        assertValidAddress(""Sd14293Zhxxur2Pim7NkjxPGVaJTjGR5qY"");
    }

    @Test
    public void testInvalidAddresses() {
        assertInvalidAddress(""1PSXRJSwzGKxSiYXePf1vnkk4v9WKVLhZp"");
        assertInvalidAddress(""SPSXRJSwzGKxSiYXePf1vnkk4v9WKVLhZpp"");
        assertInvalidAddress(""SPSSPSSPSGKxSiYXePf1vnkk4v9WKVLhZp"");
    }
}",0,777 587 2000 650 2001 123 777 2000 40 41 123 818 40 744 2002 40 41 41 59 125 64 2003 777 865 2004 40 41 123 2005 40 362 41 59 2005 40 362 41 59 2005 40 362 41 59 125 64 2003 777 865 2006 40 41 123 2007 40 362 41 59 2007 40 362 41 59 2007 40 362 41 59 125 125 ,"{'AvgLine': 5, 'CountLine': 20, 'CountStmt': 11, 'MaxNesting': 0, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 7, 'MaxEssential': 1, 'SumEssential': 3, 'AvgCyclomatic': 1, 'CountLineCode': 17, 'CountStmtDecl': 4, 'MaxCyclomatic': 1, 'SumCyclomatic': 3, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 3, 'CountSemicolon': 7, 'CountDeclMethod': 3, 'CountLineCodeExe': 7, 'CountLineComment': 0, 'CountClassCoupled': 2, 'CountClassDerived': 0, 'CountLineCodeDecl': 6, 'CountDeclMethodAll': 11, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 3, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 3, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 3, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 3, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 2, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2760,Java,"@SuppressWarnings(""ALL"")
@Disabled
@Slf4j
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class EditOfferTest extends AbstractOfferTest {

    // Some test fixtures to reduce duplication.
    private static final Map<String, PaymentAccount> paymentAcctCache = new HashMap<>();
    private static final String RUBLE = ""RUB"";
    private static final long AMOUNT = 10000000L;

    @Test
    @Order(1)
    public void testOfferDisableAndEnable() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""DE"");
        OfferInfo originalOffer = createMktPricedOfferForEdit(BUY.name(),
                EUR,
                paymentAcct.getId(),
                0.0,
                NO_TRIGGER_PRICE);
        log.debug(""Original EUR offer:\n{}"", toOfferTable.apply(originalOffer));
        assertFalse(originalOffer.getIsActivated()); // Not activated until prep is done.
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        originalOffer = aliceClient.getMyOffer(originalOffer.getId());
        assertTrue(originalOffer.getIsActivated());
        // Disable offer
        aliceClient.editOfferActivationState(originalOffer.getId(), DEACTIVATE_OFFER);
        genBtcBlocksThenWait(1, 1500); // Wait for offer book removal.
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited EUR offer:\n{}"", toOfferTable.apply(editedOffer));
        assertFalse(editedOffer.getIsActivated());
        // Re-enable offer
        aliceClient.editOfferActivationState(editedOffer.getId(), ACTIVATE_OFFER);
        genBtcBlocksThenWait(1, 1500); // Wait for offer book re-entry.
        editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited EUR offer:\n{}"", toOfferTable.apply(editedOffer));
        assertTrue(editedOffer.getIsActivated());

        doSanityCheck(originalOffer, editedOffer);
    }

    @Test
    @Order(2)
    public void testEditTriggerPrice() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""FI"");
        OfferInfo originalOffer = createMktPricedOfferForEdit(SELL.name(),
                EUR,
                paymentAcct.getId(),
                0.0,
                NO_TRIGGER_PRICE);
        log.debug(""Original EUR offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        originalOffer = aliceClient.getMyOffer(originalOffer.getId());
        assertEquals(0 /*no trigger price*/, originalOffer.getTriggerPrice());

        // Edit the offer's trigger price, nothing else.
        var mktPrice = aliceClient.getBtcPrice(EUR);
        var delta = 5_000.00;
        var newTriggerPriceAsLong = calcPriceAsLong.apply(mktPrice, delta);

        aliceClient.editOfferTriggerPrice(originalOffer.getId(), newTriggerPriceAsLong);
        sleep(2_500); // Wait for offer book re-entry.
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited EUR offer:\n{}"", toOfferTable.apply(editedOffer));
        assertEquals(newTriggerPriceAsLong, editedOffer.getTriggerPrice());
        assertTrue(editedOffer.getUseMarketBasedPrice());

        doSanityCheck(originalOffer, editedOffer);
    }

    @Test
    @Order(3)
    public void testSetTriggerPriceToNegativeValueShouldThrowException() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""FI"");
        var originalOffer = createMktPricedOfferForEdit(SELL.name(),
                EUR,
                paymentAcct.getId(),
                0.0,
                NO_TRIGGER_PRICE);
        log.debug(""Original EUR offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        // Edit the offer's trigger price, set to -1, check error.
        Throwable exception = assertThrows(StatusRuntimeException.class, () ->
                aliceClient.editOfferTriggerPrice(originalOffer.getId(), -1L));
        String expectedExceptionMessage =
                format(""UNKNOWN: programmer error: cannot set trigger price to a negative value in offer with id '%s'"",
                        originalOffer.getId());
        assertEquals(expectedExceptionMessage, exception.getMessage());
    }

    @Test
    @Order(4)
    public void testEditMktPriceMargin() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""US"");
        var originalMktPriceMargin = new BigDecimal(""0.1"").doubleValue();
        var originalOffer = createMktPricedOfferForEdit(SELL.name(),
                USD,
                paymentAcct.getId(),
                originalMktPriceMargin,
                NO_TRIGGER_PRICE);
        log.debug(""Original USD offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        assertEquals(scaledDownMktPriceMargin.apply(originalMktPriceMargin), originalOffer.getMarketPriceMargin());
        // Edit the offer's price margin, nothing else.
        var newMktPriceMargin = new BigDecimal(""0.5"").doubleValue();
        aliceClient.editOfferPriceMargin(originalOffer.getId(), newMktPriceMargin);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited USD offer:\n{}"", toOfferTable.apply(editedOffer));
        assertEquals(scaledDownMktPriceMargin.apply(newMktPriceMargin), editedOffer.getMarketPriceMargin());

        doSanityCheck(originalOffer, editedOffer);
    }

    @Test
    @Order(5)
    public void testEditFixedPrice() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""RU"");
        double mktPriceAsDouble = aliceClient.getBtcPrice(RUBLE);
        String fixedPriceAsString = calcPriceAsString.apply(mktPriceAsDouble, 200_000.0000);
        var originalOffer = createFixedPricedOfferForEdit(BUY.name(),
                RUBLE,
                paymentAcct.getId(),
                fixedPriceAsString);
        log.debug(""Original RUB offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        // Edit the offer's fixed price, nothing else.
        String editedFixedPriceAsString = calcPriceAsString.apply(mktPriceAsDouble, 100_000.0000);
        aliceClient.editOfferFixedPrice(originalOffer.getId(), editedFixedPriceAsString);
        // Wait for edited offer to be removed from offer-book, edited, and re-published.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited RUB offer:\n{}"", toOfferTable.apply(editedOffer));
        var expectedNewFixedPrice = scaledUpFiatOfferPrice.apply(new BigDecimal(editedFixedPriceAsString));
        assertEquals(expectedNewFixedPrice, editedOffer.getPrice());
        assertFalse(editedOffer.getUseMarketBasedPrice());

        doSanityCheck(originalOffer, editedOffer);
    }

    @Test
    @Order(6)
    public void testEditFixedPriceAndDeactivation() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""RU"");
        double mktPriceAsDouble = aliceClient.getBtcPrice(RUBLE);
        String fixedPriceAsString = calcPriceAsString.apply(mktPriceAsDouble, 200_000.0000);
        var originalOffer = createFixedPricedOfferForEdit(BUY.name(),
                RUBLE,
                paymentAcct.getId(),
                fixedPriceAsString);
        log.debug(""Original RUB offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        // Edit the offer's fixed price and deactivate it.
        String editedFixedPriceAsString = calcPriceAsString.apply(mktPriceAsDouble, 100_000.0000);
        aliceClient.editOffer(originalOffer.getId(),
                editedFixedPriceAsString,
                originalOffer.getUseMarketBasedPrice(),
                0.0,
                NO_TRIGGER_PRICE,
                DEACTIVATE_OFFER,
                FIXED_PRICE_AND_ACTIVATION_STATE);
        // Wait for edited offer to be removed from offer-book, edited, and re-published.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited RUB offer:\n{}"", toOfferTable.apply(editedOffer));
        var expectedNewFixedPrice = scaledUpFiatOfferPrice.apply(new BigDecimal(editedFixedPriceAsString));
        assertEquals(expectedNewFixedPrice, editedOffer.getPrice());
        assertFalse(editedOffer.getIsActivated());

        doSanityCheck(originalOffer, editedOffer);
    }

    @Test
    @Order(7)
    public void testEditMktPriceMarginAndDeactivation() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""US"");

        var originalMktPriceMargin = new BigDecimal(""0.0"").doubleValue();
        OfferInfo originalOffer = createMktPricedOfferForEdit(SELL.name(),
                USD,
                paymentAcct.getId(),
                originalMktPriceMargin,
                0);
        log.debug(""Original USD offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        originalOffer = aliceClient.getMyOffer(originalOffer.getId());
        assertEquals(scaledDownMktPriceMargin.apply(originalMktPriceMargin), originalOffer.getMarketPriceMargin());

        // Edit the offer's price margin and trigger price, and deactivate it.
        var newMktPriceMargin = new BigDecimal(""1.50"").doubleValue();
        aliceClient.editOffer(originalOffer.getId(),
                ""0.00"",
                originalOffer.getUseMarketBasedPrice(),
                newMktPriceMargin,
                0,
                DEACTIVATE_OFFER,
                MKT_PRICE_MARGIN_AND_ACTIVATION_STATE);
        // Wait for edited offer to be removed from offer-book, edited, and re-published.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited USD offer:\n{}"", toOfferTable.apply(editedOffer));
        assertEquals(scaledDownMktPriceMargin.apply(newMktPriceMargin), editedOffer.getMarketPriceMargin());
        assertEquals(0, editedOffer.getTriggerPrice());
        assertFalse(editedOffer.getIsActivated());

        doSanityCheck(originalOffer, editedOffer);
    }

    @Test
    @Order(8)
    public void testEditMktPriceMarginAndTriggerPriceAndDeactivation() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""US"");
        var originalMktPriceMargin = new BigDecimal(""0.0"").doubleValue();
        var mktPriceAsDouble = aliceClient.getBtcPrice(USD);
        var originalTriggerPriceAsLong = calcPriceAsLong.apply(mktPriceAsDouble, -5_000.0000);
        OfferInfo originalOffer = createMktPricedOfferForEdit(SELL.name(),
                USD,
                paymentAcct.getId(),
                originalMktPriceMargin,
                originalTriggerPriceAsLong);
        log.debug(""Original USD offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        originalOffer = aliceClient.getMyOffer(originalOffer.getId());
        assertEquals(scaledDownMktPriceMargin.apply(originalMktPriceMargin), originalOffer.getMarketPriceMargin());
        assertEquals(originalTriggerPriceAsLong, originalOffer.getTriggerPrice());

        // Edit the offer's price margin and trigger price, and deactivate it.
        var newMktPriceMargin = new BigDecimal(""0.1"").doubleValue();
        var newTriggerPriceAsLong = calcPriceAsLong.apply(mktPriceAsDouble, -2_000.0000);
        aliceClient.editOffer(originalOffer.getId(),
                ""0.00"",
                originalOffer.getUseMarketBasedPrice(),
                newMktPriceMargin,
                newTriggerPriceAsLong,
                DEACTIVATE_OFFER,
                MKT_PRICE_MARGIN_AND_TRIGGER_PRICE_AND_ACTIVATION_STATE);
        // Wait for edited offer to be removed from offer-book, edited, and re-published.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited USD offer:\n{}"", toOfferTable.apply(editedOffer));
        assertEquals(scaledDownMktPriceMargin.apply(newMktPriceMargin), editedOffer.getMarketPriceMargin());
        assertEquals(newTriggerPriceAsLong, editedOffer.getTriggerPrice());
        assertFalse(editedOffer.getIsActivated());

        doSanityCheck(originalOffer, editedOffer);
    }

    @Test
    @Order(9)
    public void testEditingFixedPriceInMktPriceMarginBasedOfferShouldThrowException() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""US"");
        var originalMktPriceMargin = new BigDecimal(""0.0"").doubleValue();
        var originalOffer = createMktPricedOfferForEdit(SELL.name(),
                USD,
                paymentAcct.getId(),
                originalMktPriceMargin,
                NO_TRIGGER_PRICE);
        log.debug(""Original USD offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        // Try to edit both the fixed price and mkt price margin.
        var newMktPriceMargin = new BigDecimal(""0.25"").doubleValue();
        var newFixedPrice = ""50000.0000"";
        Throwable exception = assertThrows(StatusRuntimeException.class, () ->
                aliceClient.editOffer(originalOffer.getId(),
                        newFixedPrice,
                        originalOffer.getUseMarketBasedPrice(),
                        newMktPriceMargin,
                        NO_TRIGGER_PRICE,
                        ACTIVATE_OFFER,
                        MKT_PRICE_MARGIN_ONLY));
        String expectedExceptionMessage =
                format(""UNKNOWN: programmer error: cannot set fixed price (%s) in""
                                + "" mkt price margin based offer with id '%s'"",
                        newFixedPrice,
                        originalOffer.getId());
        assertEquals(expectedExceptionMessage, exception.getMessage());
    }

    @Test
    @Order(10)
    public void testEditingTriggerPriceInFixedPriceOfferShouldThrowException() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""RU"");
        double mktPriceAsDouble = aliceClient.getBtcPrice(RUBLE);
        String fixedPriceAsString = calcPriceAsString.apply(mktPriceAsDouble, 200_000.0000);
        var originalOffer = createFixedPricedOfferForEdit(BUY.name(),
                RUBLE,
                paymentAcct.getId(),
                fixedPriceAsString);
        log.debug(""Original RUB offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        long newTriggerPrice = 1000000L;
        Throwable exception = assertThrows(StatusRuntimeException.class, () ->
                aliceClient.editOfferTriggerPrice(originalOffer.getId(), newTriggerPrice));
        String expectedExceptionMessage =
                format(""UNKNOWN: programmer error: cannot set a trigger price (%s) in""
                                + "" fixed price offer with id '%s'"",
                        newTriggerPrice,
                        originalOffer.getId());
        assertEquals(expectedExceptionMessage, exception.getMessage());
    }

    @Test
    @Order(11)
    public void testChangeFixedPriceOfferToPriceMarginBasedOfferWithTriggerPrice() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""MX"");
        double mktPriceAsDouble = aliceClient.getBtcPrice(""MXN"");
        String fixedPriceAsString = calcPriceAsString.apply(mktPriceAsDouble, 0.00);
        var originalOffer = createFixedPricedOfferForEdit(BUY.name(),
                ""MXN"",
                paymentAcct.getId(),
                fixedPriceAsString);
        log.debug(""Original MXN offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.

        // Change the offer to mkt price based and set a trigger price.
        var newMktPriceMargin = new BigDecimal(""0.05"").doubleValue();
        var delta = 200_000.0000; // trigger price on buy offer is 200K above mkt price
        var newTriggerPriceAsLong = calcPriceAsLong.apply(mktPriceAsDouble, delta);
        aliceClient.editOffer(originalOffer.getId(),
                ""0.00"",
                true,
                newMktPriceMargin,
                newTriggerPriceAsLong,
                ACTIVATE_OFFER,
                MKT_PRICE_MARGIN_AND_TRIGGER_PRICE);
        // Wait for edited offer to be removed from offer-book, edited, and re-published.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited MXN offer:\n{}"", toOfferTable.apply(editedOffer));
        assertTrue(editedOffer.getUseMarketBasedPrice());
        assertEquals(scaledDownMktPriceMargin.apply(newMktPriceMargin), editedOffer.getMarketPriceMargin());
        assertEquals(newTriggerPriceAsLong, editedOffer.getTriggerPrice());
        assertTrue(editedOffer.getIsActivated());

        doSanityCheck(originalOffer, editedOffer);
    }

    @Test
    @Order(12)
    public void testChangePriceMarginBasedOfferToFixedPriceOfferAndDeactivateIt() {
        PaymentAccount paymentAcct = getOrCreatePaymentAccount(""GB"");
        double mktPriceAsDouble = aliceClient.getBtcPrice(""GBP"");
        var originalMktPriceMargin = new BigDecimal(""0.25"").doubleValue();
        var delta = 1_000.0000; // trigger price on sell offer is 1K below mkt price
        var originalTriggerPriceAsLong = calcPriceAsLong.apply(mktPriceAsDouble, delta);
        var originalOffer = createMktPricedOfferForEdit(SELL.name(),
                ""GBP"",
                paymentAcct.getId(),
                originalMktPriceMargin,
                originalTriggerPriceAsLong);
        log.debug(""Original GBP offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.

        String fixedPriceAsString = calcPriceAsString.apply(mktPriceAsDouble, 0.00);
        aliceClient.editOffer(originalOffer.getId(),
                fixedPriceAsString,
                false,
                0.00,
                0,
                DEACTIVATE_OFFER,
                FIXED_PRICE_AND_ACTIVATION_STATE);
        // Wait for edited offer to be removed from offer-book, edited, and re-published.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited GBP offer:\n{}"", toOfferTable.apply(editedOffer));
        assertEquals(scaledUpFiatOfferPrice.apply(new BigDecimal(fixedPriceAsString)), editedOffer.getPrice());
        assertFalse(editedOffer.getUseMarketBasedPrice());
        assertEquals(0.00, editedOffer.getMarketPriceMargin());
        assertEquals(0, editedOffer.getTriggerPrice());
        assertFalse(editedOffer.getIsActivated());
    }

    @Test
    @Order(13)
    public void testChangeFixedPricedBsqOfferToPriceMarginBasedOfferShouldThrowException() {
        var originalOffer = aliceClient.createFixedPricedOffer(BUY.name(),
                BSQ,
                100_000_000L,
                100_000_000L,
                ""0.00005"",   // FIXED PRICE IN BTC (satoshis) FOR 1 BSQ
                getDefaultBuyerSecurityDepositAsPercent(),
                alicesLegacyBsqAcct.getId(),
                BSQ);
        log.debug(""Original BSQ offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        Throwable exception = assertThrows(StatusRuntimeException.class, () ->
                aliceClient.editOffer(originalOffer.getId(),
                        ""0.00"",
                        true,
                        0.1,
                        0,
                        ACTIVATE_OFFER,
                        MKT_PRICE_MARGIN_ONLY));
        String expectedExceptionMessage = format(""UNKNOWN: cannot set mkt price margin or""
                        + "" trigger price on fixed price altcoin offer with id '%s'"",
                originalOffer.getId());
        assertEquals(expectedExceptionMessage, exception.getMessage());
    }

    @Test
    @Order(14)
    public void testEditTriggerPriceOnFixedPriceBsqOfferShouldThrowException() {
        var originalOffer = aliceClient.createFixedPricedOffer(BUY.name(),
                BSQ,
                100_000_000L,
                100_000_000L,
                ""0.00005"",   // FIXED PRICE IN BTC (satoshis) FOR 1 BSQ
                getDefaultBuyerSecurityDepositAsPercent(),
                alicesLegacyBsqAcct.getId(),
                BSQ);
        log.debug(""Original BSQ offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        var newTriggerPriceAsLong = calcPriceAsLong.apply(0.00005, 0.00);
        Throwable exception = assertThrows(StatusRuntimeException.class, () ->
                aliceClient.editOffer(originalOffer.getId(),
                        ""0.00"",
                        false,
                        0.1,
                        newTriggerPriceAsLong,
                        ACTIVATE_OFFER,
                        TRIGGER_PRICE_ONLY));
        String expectedExceptionMessage = format(""UNKNOWN: cannot set mkt price margin or""
                        + "" trigger price on fixed price altcoin offer with id '%s'"",
                originalOffer.getId());
        assertEquals(expectedExceptionMessage, exception.getMessage());
    }

    @Test
    @Order(15)
    public void testEditFixedPriceOnBsqOffer() {
        String fixedPriceAsString = ""0.00005""; // FIXED PRICE IN BTC (satoshis) FOR 1 BSQ
        var originalOffer = aliceClient.createFixedPricedOffer(BUY.name(),
                BSQ,
                100_000_000L,
                100_000_000L,
                fixedPriceAsString,
                getDefaultBuyerSecurityDepositAsPercent(),
                alicesLegacyBsqAcct.getId(),
                BSQ);
        log.debug(""Original BSQ offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        String newFixedPriceAsString = ""0.00003111"";
        aliceClient.editOffer(originalOffer.getId(),
                newFixedPriceAsString,
                false,
                0.0,
                0,
                ACTIVATE_OFFER,
                FIXED_PRICE_ONLY);
        // Wait for edited offer to be edited and removed from offer-book.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited BSQ offer:\n{}"", toOfferTable.apply(editedOffer));
        assertEquals(scaledUpAltcoinOfferPrice.apply(newFixedPriceAsString), editedOffer.getPrice());
        assertTrue(editedOffer.getIsActivated());
        assertFalse(editedOffer.getUseMarketBasedPrice());
        assertEquals(0.00, editedOffer.getMarketPriceMargin());
        assertEquals(0, editedOffer.getTriggerPrice());
    }

    @Test
    @Order(16)
    public void testDisableBsqOffer() {
        String fixedPriceAsString = ""0.00005""; // FIXED PRICE IN BTC (satoshis) FOR 1 BSQ
        var originalOffer = aliceClient.createFixedPricedOffer(BUY.name(),
                BSQ,
                100_000_000L,
                100_000_000L,
                fixedPriceAsString,
                getDefaultBuyerSecurityDepositAsPercent(),
                alicesLegacyBsqAcct.getId(),
                BSQ);
        log.debug(""Original BSQ offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        aliceClient.editOffer(originalOffer.getId(),
                fixedPriceAsString,
                false,
                0.0,
                0,
                DEACTIVATE_OFFER,
                ACTIVATION_STATE_ONLY);
        // Wait for edited offer to be removed from offer-book.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited BSQ offer:\n{}"", toOfferTable.apply(editedOffer));
        assertFalse(editedOffer.getIsActivated());
        assertEquals(scaledUpAltcoinOfferPrice.apply(fixedPriceAsString), editedOffer.getPrice());
        assertFalse(editedOffer.getUseMarketBasedPrice());
        assertEquals(0.00, editedOffer.getMarketPriceMargin());
        assertEquals(0, editedOffer.getTriggerPrice());
    }

    @Test
    @Order(17)
    public void testEditFixedPriceAndDisableBsqOffer() {
        String fixedPriceAsString = ""0.00005""; // FIXED PRICE IN BTC (satoshis) FOR 1 BSQ
        var originalOffer = aliceClient.createFixedPricedOffer(BUY.name(),
                BSQ,
                100_000_000L,
                100_000_000L,
                fixedPriceAsString,
                getDefaultBuyerSecurityDepositAsPercent(),
                alicesLegacyBsqAcct.getId(),
                BSQ);
        log.debug(""Original BSQ offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        String newFixedPriceAsString = ""0.000045"";
        aliceClient.editOffer(originalOffer.getId(),
                newFixedPriceAsString,
                false,
                0.0,
                0,
                DEACTIVATE_OFFER,
                FIXED_PRICE_AND_ACTIVATION_STATE);
        // Wait for edited offer to be edited and removed from offer-book.
        genBtcBlocksThenWait(1, 2_500);
        OfferInfo editedOffer = aliceClient.getMyOffer(originalOffer.getId());
        log.debug(""Edited BSQ offer:\n{}"", toOfferTable.apply(editedOffer));
        assertFalse(editedOffer.getIsActivated());
        assertEquals(scaledUpAltcoinOfferPrice.apply(newFixedPriceAsString), editedOffer.getPrice());
        assertFalse(editedOffer.getUseMarketBasedPrice());
        assertEquals(0.00, editedOffer.getMarketPriceMargin());
        assertEquals(0, editedOffer.getTriggerPrice());
    }

    @Test
    @Order(18)
    public void testEditBsqSwapOfferShouldThrowException() {
        var originalOffer = aliceClient.createBsqSwapOffer(SELL.name(),
                1_250_000L,
                750_000L,
                ""0.00005"");
        log.debug(""BsqSwap Buy BSQ (Buy BTC) offer:\n{}"", originalOffer);
        var newOfferId = originalOffer.getId();
        assertNotEquals("""", newOfferId);
        assertEquals(SELL.name(), originalOffer.getDirection());
        assertEquals(5_000, originalOffer.getPrice());
        assertEquals(1_250_000L, originalOffer.getAmount());
        assertEquals(750_000L, originalOffer.getMinAmount());
        assertEquals(BSQ, originalOffer.getBaseCurrencyCode());
        assertEquals(BTC, originalOffer.getCounterCurrencyCode());

        log.debug(""Original BsqSwap offer:\n{}"", toOfferTable.apply(originalOffer));
        genBtcBlocksThenWait(1, 2_500); // Wait for offer book entry.
        var newFixedPrice = ""0.000055"";
        Throwable exception = assertThrows(StatusRuntimeException.class, () ->
                aliceClient.editOffer(originalOffer.getId(),
                        newFixedPrice,
                        false,
                        0.0,
                        0,
                        ACTIVATE_OFFER,
                        TRIGGER_PRICE_ONLY));
        String expectedExceptionMessage = format(""UNKNOWN: cannot edit bsq swap offer with id '%s'"",
                originalOffer.getId());
        assertEquals(expectedExceptionMessage, exception.getMessage());
    }

    private OfferInfo createMktPricedOfferForEdit(String direction,
                                                  String currencyCode,
                                                  String paymentAccountId,
                                                  double marketPriceMargin,
                                                  long triggerPrice) {
        return aliceClient.createMarketBasedPricedOffer(direction,
                currencyCode,
                AMOUNT,
                AMOUNT,
                marketPriceMargin,
                getDefaultBuyerSecurityDepositAsPercent(),
                paymentAccountId,
                BSQ,
                triggerPrice);
    }

    private OfferInfo createFixedPricedOfferForEdit(String direction,
                                                    String currencyCode,
                                                    String paymentAccountId,
                                                    String priceAsString) {
        return aliceClient.createFixedPricedOffer(direction,
                currencyCode,
                AMOUNT,
                AMOUNT,
                priceAsString,
                getDefaultBuyerSecurityDepositAsPercent(),
                paymentAccountId,
                BSQ);
    }

    private void doSanityCheck(OfferInfo originalOffer, OfferInfo editedOffer) {
        // Assert some of the immutable offer fields are unchanged.
        assertEquals(originalOffer.getDirection(), editedOffer.getDirection());
        assertEquals(originalOffer.getAmount(), editedOffer.getAmount());
        assertEquals(originalOffer.getMinAmount(), editedOffer.getMinAmount());
        assertEquals(originalOffer.getTxFee(), editedOffer.getTxFee());
        assertEquals(originalOffer.getMakerFee(), editedOffer.getMakerFee());
        assertEquals(originalOffer.getPaymentAccountId(), editedOffer.getPaymentAccountId());
        assertEquals(originalOffer.getDate(), editedOffer.getDate());
        if (originalOffer.getDirection().equals(BUY.name()))
            assertEquals(originalOffer.getBuyerSecurityDeposit(), editedOffer.getBuyerSecurityDeposit());
        else
            assertEquals(originalOffer.getSellerSecurityDeposit(), editedOffer.getSellerSecurityDeposit());
    }

    private PaymentAccount getOrCreatePaymentAccount(String countryCode) {
        if (paymentAcctCache.containsKey(countryCode)) {
            return paymentAcctCache.get(countryCode);
        } else {
            PaymentAccount paymentAcct = createDummyF2FAccount(aliceClient, countryCode);
            paymentAcctCache.put(countryCode, paymentAcct);
            return paymentAcct;
        }
    }

    @AfterAll
    public static void clearPaymentAcctCache() {
        paymentAcctCache.clear();
    }
}",0,64 2000 40 362 41 64 2001 64 2002 64 2003 40 2004 46 2005 46 587 41 777 587 2006 650 2007 123 330 773 809 657 2008 60 2009 44 2010 62 2011 61 744 2012 60 62 40 41 59 773 809 657 2009 2013 61 362 59 773 809 657 726 2014 61 1508 59 64 2015 64 2016 40 1501 41 777 865 2017 40 41 123 2010 2018 61 2019 40 362 41 59 2020 2021 61 2022 40 2023 46 2024 40 41 44 2025 44 2018 46 2026 40 41 44 1500 44 2027 41 59 2028 46 2029 40 362 44 2030 46 2031 40 2021 41 41 59 2032 40 2021 46 2033 40 41 41 59 330 2034 40 1501 44 1502 41 59 330 2021 61 2035 46 2036 40 2021 46 2026 40 41 41 59 2037 40 2021 46 2033 40 41 41 59 330 2035 46 2038 40 2021 46 2026 40 41 44 2039 41 59 2034 40 1501 44 1505 41 59 330 2020 2040 61 2035 46 2036 40 2021 46 2026 40 41 41 59 2028 46 2029 40 362 44 2030 46 2031 40 2040 41 41 59 2032 40 2040 46 2033 40 41 41 59 330 2035 46 2038 40 2040 46 2026 40 41 44 2041 41 59 2034 40 1501 44 1505 41 59 330 2040 61 2035 46 2036 40 2021 46 2026 40 41 41 59 2028 46 2029 40 362 44 2030 46 2031 40 2040 41 41 59 2037 40 2040 46 2033 40 41 41 59 2042 40 2021 44 2040 41 59 125 64 2015 64 2016 40 1502 41 777 865 2043 40 41 123 2010 2044 61 2045 40 362 41 59 2046 2047 61 2048 40 2049 46 2050 40 41 44 2051 44 2044 46 2052 40 41 44 1500 44 2053 41 59 2054 46 2055 40 362 44 2056 46 2057 40 2047 41 41 59 2058 40 1501 44 1502 41 59 330 2047 61 2059 46 2060 40 2047 46 2052 40 41 41 59 2061 40 1500 305 44 2047 46 2062 40 41 41 59 330 2063 2064 61 2059 46 2065 40 2051 41 59 2063 2066 61 1502 59 2063 2067 61 2068 46 2057 40 2064 44 2066 41 59 2059 46 2069 40 2047 46 2052 40 41 44 2067 41 59 2070 40 1502 41 59 330 2046 2071 61 2059 46 2060 40 2047 46 2052 40 41 41 59 2054 46 2055 40 362 44 2056 46 2057 40 2071 41 41 59 2061 40 2067 44 2071 46 2062 40 41 41 59 2072 40 2071 46 2073 40 41 41 59 2074 40 2047 44 2071 41 59 125 64 2015 64 2016 40 1502 41 777 865 2075 40 41 123 2010 2076 61 2077 40 362 41 59 2078 2079 61 2080 40 2081 46 2082 40 41 44 2083 44 2076 46 2084 40 41 44 1500 44 2085 41 59 2086 46 2087 40 362 44 2088 46 2089 40 2079 41 41 59 2090 40 1501 44 1502 41 59 330 330 2091 2092 61 2093 40 2094 46 587 44 40 41 45 62 2095 46 2096 40 2079 46 2084 40 41 44 45 1501 41 41 59 2009 2097 61 2098 40 362 44 2079 46 2084 40 41 41 59 2099 40 2097 44 2092 46 2100 40 41 41 59 125 64 2015 64 2016 40 1502 41 777 865 2101 40 41 123 2010 2102 61 2103 40 362 41 59 2104 2105 61 744 2106 40 362 41 46 2107 40 41 59 2104 2108 61 2109 40 2110 46 2111 40 41 44 2112 44 2102 46 2113 40 41 44 2105 44 2114 41 59 2115 46 2116 40 362 44 2117 46 2118 40 2108 41 41 59 2119 40 1501 44 1502 41 59 330 2120 40 2121 46 2118 40 2105 41 44 2108 46 2122 40 41 41 59 330 2104 2123 61 744 2106 40 362 41 46 2107 40 41 59 2124 46 2125 40 2108 46 2113 40 41 44 2123 41 59 2126 2127 61 2124 46 2128 40 2108 46 2113 40 41 41 59 2115 46 2116 40 362 44 2117 46 2118 40 2127 41 41 59 2120 40 2121 46 2118 40 2123 41 44 2127 46 2122 40 41 41 59 2129 40 2108 44 2127 41 59 125 64 2015 64 2016 40 1502 41 777 865 2130 40 41 123 2010 2131 61 2132 40 362 41 59 625 2133 61 2134 46 2135 40 2013 41 59 2009 2136 61 2137 46 2138 40 2133 44 1504 41 59 2139 2140 61 2141 40 2142 46 2143 40 41 44 2013 44 2131 46 2144 40 41 44 2136 41 59 2145 46 2146 40 362 44 2147 46 2138 40 2140 41 41 59 2148 40 1501 44 1502 41 59 330 330 2009 2149 61 2137 46 2138 40 2133 44 1503 41 59 2134 46 2150 40 2140 46 2144 40 41 44 2149 41 59 330 2148 40 1501 44 1502 41 59 2151 2152 61 2134 46 2153 40 2140 46 2144 40 41 41 59 2145 46 2146 40 362 44 2147 46 2138 40 2152 41 41 59 2139 2154 61 2155 46 2138 40 744 2156 40 2149 41 41 59 2157 40 2154 44 2152 46 2158 40 41 41 59 2159 40 2152 46 2160 40 41 41 59 2161 40 2140 44 2152 41 59 125 64 2015 64 2016 40 1502 41 777 865 2162 40 41 123 2010 2163 61 2164 40 362 41 59 625 2165 61 2166 46 2167 40 2013 41 59 2009 2168 61 2169 46 2170 40 2165 44 1504 41 59 2171 2172 61 2173 40 2174 46 2175 40 41 44 2013 44 2163 46 2176 40 41 44 2168 41 59 2177 46 2178 40 362 44 2179 46 2170 40 2172 41 41 59 2180 40 1501 44 1502 41 59 330 330 2009 2181 61 2169 46 2170 40 2165 44 1503 41 59 2166 46 2182 40 2172 46 2176 40 41 44 2181 44 2172 46 2183 40 41 44 1500 44 2184 44 2185 44 2186 41 59 330 2180 40 1501 44 1502 41 59 2187 2188 61 2166 46 2189 40 2172 46 2176 40 41 41 59 2177 46 2178 40 362 44 2179 46 2170 40 2188 41 41 59 2171 2190 61 2191 46 2170 40 744 2192 40 2181 41 41 59 2193 40 2190 44 2188 46 2194 40 41 41 59 2195 40 2188 46 2196 40 41 41 59 2197 40 2172 44 2188 41 59 125 64 2015 64 2016 40 1502 41 777 865 2198 40 41 123 2010 2199 61 2200 40 362 41 59 2201 2202 61 744 2203 40 362 41 46 2204 40 41 59 2205 2206 61 2207 40 2208 46 2209 40 41 44 2210 44 2199 46 2211 40 41 44 2202 44 1500 41 59 2212 46 2213 40 362 44 2214 46 2215 40 2206 41 41 59 2216 40 1501 44 1502 41 59 330 2206 61 2217 46 2218 40 2206 46 2211 40 41 41 59 2219 40 2220 46 2215 40 2202 41 44 2206 46 2221 40 41 41 59 330 2201 2222 61 744 2203 40 362 41 46 2204 40 41 59 2217 46 2223 40 2206 46 2211 40 41 44 362 44 2206 46 2224 40 41 44 2222 44 1500 44 2225 44 2226 41 59 330 2216 40 1501 44 1502 41 59 2205 2227 61 2217 46 2218 40 2206 46 2211 40 41 41 59 2212 46 2213 40 362 44 2214 46 2215 40 2227 41 41 59 2219 40 2220 46 2215 40 2222 41 44 2227 46 2221 40 41 41 59 2219 40 1500 44 2227 46 2228 40 41 41 59 2229 40 2227 46 2230 40 41 41 59 2231 40 2206 44 2227 41 59 125 64 2015 64 2016 40 1502 41 777 865 2232 40 41 123 2010 2233 61 2234 40 362 41 59 2235 2236 61 744 2237 40 362 41 46 2238 40 41 59 2235 2239 61 2240 46 2241 40 2242 41 59 2235 2243 61 2244 46 2245 40 2239 44 45 1502 41 59 2246 2247 61 2248 40 2249 46 2250 40 41 44 2242 44 2233 46 2251 40 41 44 2236 44 2243 41 59 2252 46 2253 40 362 44 2254 46 2245 40 2247 41 41 59 2255 40 1501 44 1502 41 59 330 2247 61 2240 46 2256 40 2247 46 2251 40 41 41 59 2257 40 2258 46 2245 40 2236 41 44 2247 46 2259 40 41 41 59 2257 40 2243 44 2247 46 2260 40 41 41 59 330 2235 2261 61 744 2237 40 362 41 46 2238 40 41 59 2235 2262 61 2244 46 2245 40 2239 44 45 1502 41 59 2240 46 2263 40 2247 46 2251 40 41 44 362 44 2247 46 2264 40 41 44 2261 44 2262 44 2265 44 2266 41 59 330 2255 40 1501 44 1502 41 59 2246 2267 61 2240 46 2256 40 2247 46 2251 40 41 41 59 2252 46 2253 40 362 44 2254 46 2245 40 2267 41 41 59 2257 40 2258 46 2245 40 2261 41 44 2267 46 2259 40 41 41 59 2257 40 2262 44 2267 46 2260 40 41 41 59 2268 40 2267 46 2269 40 41 41 59 2270 40 2247 44 2267 41 59 125 64 2015 64 2016 40 1502 41 777 865 2271 40 41 123 2010 2272 61 2273 40 362 41 59 2274 2275 61 744 2276 40 362 41 46 2277 40 41 59 2274 2278 61 2279 40 2280 46 2281 40 41 44 2282 44 2272 46 2283 40 41 44 2275 44 2284 41 59 2285 46 2286 40 362 44 2287 46 2288 40 2278 41 41 59 2289 40 1501 44 1502 41 59 330 330 2274 2290 61 744 2276 40 362 41 46 2277 40 41 59 2274 2291 61 362 59 2292 2293 61 2294 40 2295 46 587 44 40 41 45 62 2296 46 2297 40 2278 46 2283 40 41 44 2291 44 2278 46 2298 40 41 44 2290 44 2284 44 2299 44 2300 41 41 59 2009 2301 61 2302 40 362 43 362 44 2291 44 2278 46 2283 40 41 41 59 2303 40 2301 44 2293 46 2304 40 41 41 59 125 64 2015 64 2016 40 1502 41 777 865 2305 40 41 123 2010 2306 61 2307 40 362 41 59 625 2308 61 2309 46 2310 40 2013 41 59 2009 2311 61 2312 46 2313 40 2308 44 1504 41 59 2314 2315 61 2316 40 2317 46 2318 40 41 44 2013 44 2306 46 2319 40 41 44 2311 41 59 2320 46 2321 40 362 44 2322 46 2313 40 2315 41 41 59 2323 40 1501 44 1502 41 59 330 726 2324 61 1507 59 2325 2326 61 2327 40 2328 46 587 44 40 41 45 62 2309 46 2329 40 2315 46 2319 40 41 44 2324 41 41 59 2009 2330 61 2331 40 362 43 362 44 2324 44 2315 46 2319 40 41 41 59 2332 40 2330 44 2326 46 2333 40 41 41 59 125 64 2015 64 2016 40 1503 41 777 865 2334 40 41 123 2010 2335 61 2336 40 362 41 59 625 2337 61 2338 46 2339 40 362 41 59 2009 2340 61 2341 46 2342 40 2337 44 1500 41 59 2343 2344 61 2345 40 2346 46 2347 40 41 44 362 44 2335 46 2348 40 41 44 2340 41 59 2349 46 2350 40 362 44 2351 46 2342 40 2344 41 41 59 2352 40 1501 44 1502 41 59 330 330 2343 2353 61 744 2354 40 362 41 46 2355 40 41 59 2343 2356 61 1504 59 330 2343 2357 61 2358 46 2342 40 2337 44 2356 41 59 2338 46 2359 40 2344 46 2348 40 41 44 362 44 2360 44 2353 44 2357 44 2361 44 2362 41 59 330 2352 40 1501 44 1502 41 59 2363 2364 61 2338 46 2365 40 2344 46 2348 40 41 41 59 2349 46 2350 40 362 44 2351 46 2342 40 2364 41 41 59 2366 40 2364 46 2367 40 41 41 59 2368 40 2369 46 2342 40 2353 41 44 2364 46 2370 40 41 41 59 2368 40 2357 44 2364 46 2371 40 41 41 59 2366 40 2364 46 2372 40 41 41 59 2373 40 2344 44 2364 41 59 125 64 2015 64 2016 40 1503 41 777 865 2374 40 41 123 2010 2375 61 2376 40 362 41 59 625 2377 61 2378 46 2379 40 362 41 59 2380 2381 61 744 2382 40 362 41 46 2383 40 41 59 2380 2384 61 1501 59 330 2380 2385 61 2386 46 2387 40 2377 44 2384 41 59 2380 2388 61 2389 40 2390 46 2391 40 41 44 362 44 2375 46 2392 40 41 44 2381 44 2385 41 59 2393 46 2394 40 362 44 2395 46 2387 40 2388 41 41 59 2396 40 1501 44 1502 41 59 330 2009 2397 61 2398 46 2387 40 2377 44 1500 41 59 2378 46 2399 40 2388 46 2392 40 41 44 2397 44 2400 44 1500 44 1500 44 2401 44 2402 41 59 330 2396 40 1501 44 1502 41 59 2403 2404 61 2378 46 2405 40 2388 46 2392 40 41 41 59 2393 46 2394 40 362 44 2395 46 2387 40 2404 41 41 59 2406 40 2407 46 2387 40 744 2382 40 2397 41 41 44 2404 46 2408 40 41 41 59 2409 40 2404 46 2410 40 41 41 59 2406 40 1500 44 2404 46 2411 40 41 41 59 2406 40 1500 44 2404 46 2412 40 41 41 59 2409 40 2404 46 2413 40 41 41 59 125 64 2015 64 2016 40 1503 41 777 865 2414 40 41 123 2415 2416 61 2417 46 2418 40 2419 46 2420 40 41 44 2421 44 1503 44 1503 44 362 44 330 2422 40 41 44 2423 46 2424 40 41 44 2421 41 59 2425 46 2426 40 362 44 2427 46 2428 40 2416 41 41 59 2429 40 1501 44 1502 41 59 330 2430 2431 61 2432 40 2433 46 587 44 40 41 45 62 2417 46 2434 40 2416 46 2424 40 41 44 362 44 2435 44 1500 44 1500 44 2436 44 2437 41 41 59 2009 2438 61 2439 40 362 43 362 44 2416 46 2424 40 41 41 59 2440 40 2438 44 2431 46 2441 40 41 41 59 125 64 2015 64 2016 40 1503 41 777 865 2442 40 41 123 2443 2444 61 2445 46 2446 40 2447 46 2448 40 41 44 2449 44 1503 44 1503 44 362 44 330 2450 40 41 44 2451 46 2452 40 41 44 2449 41 59 2453 46 2454 40 362 44 2455 46 2456 40 2444 41 41 59 2457 40 1501 44 1502 41 59 330 2443 2458 61 2459 46 2456 40 1500 44 1500 41 59 2460 2461 61 2462 40 2463 46 587 44 40 41 45 62 2445 46 2464 40 2444 46 2452 40 41 44 362 44 2465 44 1500 44 2458 44 2466 44 2467 41 41 59 2009 2468 61 2469 40 362 43 362 44 2444 46 2452 40 41 41 59 2470 40 2468 44 2461 46 2471 40 41 41 59 125 64 2015 64 2016 40 1503 41 777 865 2472 40 41 123 2009 2473 61 362 59 330 2474 2475 61 2476 46 2477 40 2478 46 2479 40 41 44 2480 44 1503 44 1503 44 2473 44 2481 40 41 44 2482 46 2483 40 41 44 2480 41 59 2484 46 2485 40 362 44 2486 46 2487 40 2475 41 41 59 2488 40 1501 44 1502 41 59 330 2009 2489 61 362 59 2476 46 2490 40 2475 46 2483 40 41 44 2489 44 2491 44 1500 44 1500 44 2492 44 2493 41 59 330 2488 40 1501 44 1502 41 59 2494 2495 61 2476 46 2496 40 2475 46 2483 40 41 41 59 2484 46 2485 40 362 44 2486 46 2487 40 2495 41 41 59 2497 40 2498 46 2487 40 2489 41 44 2495 46 2499 40 41 41 59 2500 40 2495 46 2501 40 41 41 59 2502 40 2495 46 2503 40 41 41 59 2497 40 1500 44 2495 46 2504 40 41 41 59 2497 40 1500 44 2495 46 2505 40 41 41 59 125 64 2015 64 2016 40 1503 41 777 865 2506 40 41 123 2009 2507 61 362 59 330 2508 2509 61 2510 46 2511 40 2512 46 2513 40 41 44 2514 44 1503 44 1503 44 2507 44 2515 40 41 44 2516 46 2517 40 41 44 2514 41 59 2518 46 2519 40 362 44 2520 46 2521 40 2509 41 41 59 2522 40 1501 44 1502 41 59 330 2510 46 2523 40 2509 46 2517 40 41 44 2507 44 2524 44 1500 44 1500 44 2525 44 2526 41 59 330 2522 40 1501 44 1502 41 59 2527 2528 61 2510 46 2529 40 2509 46 2517 40 41 41 59 2518 46 2519 40 362 44 2520 46 2521 40 2528 41 41 59 2530 40 2528 46 2531 40 41 41 59 2532 40 2533 46 2521 40 2507 41 44 2528 46 2534 40 41 41 59 2530 40 2528 46 2535 40 41 41 59 2532 40 1500 44 2528 46 2536 40 41 41 59 2532 40 1500 44 2528 46 2537 40 41 41 59 125 64 2015 64 2016 40 1503 41 777 865 2538 40 41 123 2009 2539 61 362 59 330 2540 2541 61 2542 46 2543 40 2544 46 2545 40 41 44 2546 44 1503 44 1503 44 2539 44 2547 40 41 44 2548 46 2549 40 41 44 2546 41 59 2550 46 2551 40 362 44 2552 46 2553 40 2541 41 41 59 2554 40 1501 44 1502 41 59 330 2009 2555 61 362 59 2542 46 2556 40 2541 46 2549 40 41 44 2555 44 2557 44 1500 44 1500 44 2558 44 2559 41 59 330 2554 40 1501 44 1502 41 59 2560 2561 61 2542 46 2562 40 2541 46 2549 40 41 41 59 2550 46 2551 40 362 44 2552 46 2553 40 2561 41 41 59 2563 40 2561 46 2564 40 41 41 59 2565 40 2566 46 2553 40 2555 41 44 2561 46 2567 40 41 41 59 2563 40 2561 46 2568 40 41 41 59 2565 40 1500 44 2561 46 2569 40 41 41 59 2565 40 1500 44 2561 46 2570 40 41 41 59 125 64 2015 64 2016 40 1503 41 777 865 2571 40 41 123 2572 2573 61 2574 46 2575 40 2576 46 2577 40 41 44 1501 44 1504 44 362 41 59 2578 46 2579 40 362 44 2573 41 59 2572 2580 61 2573 46 2581 40 41 59 2582 40 362 44 2580 41 59 2583 40 2576 46 2577 40 41 44 2573 46 2584 40 41 41 59 2583 40 1502 44 2573 46 2585 40 41 41 59 2583 40 1501 44 2573 46 2586 40 41 41 59 2583 40 1504 44 2573 46 2587 40 41 41 59 2583 40 2588 44 2573 46 2589 40 41 41 59 2583 40 2590 44 2573 46 2591 40 41 41 59 2578 46 2579 40 362 44 2592 46 2593 40 2573 41 41 59 2594 40 1501 44 1502 41 59 330 2572 2595 61 362 59 2596 2597 61 2598 40 2599 46 587 44 40 41 45 62 2574 46 2600 40 2573 46 2581 40 41 44 2595 44 2601 44 1500 44 1500 44 2602 44 2603 41 41 59 2009 2604 61 2605 40 362 44 2573 46 2581 40 41 41 59 2583 40 2604 44 2597 46 2606 40 41 41 59 125 773 2607 2608 40 2009 2609 44 2009 2610 44 2009 2611 44 625 2612 44 726 2613 41 123 792 2614 46 2615 40 2609 44 2610 44 2014 44 2014 44 2612 44 2616 40 41 44 2611 44 2617 44 2613 41 59 125 773 2607 2618 40 2009 2609 44 2009 2610 44 2009 2611 44 2009 2619 41 123 792 2620 46 2621 40 2609 44 2610 44 2014 44 2014 44 2619 44 2622 40 41 44 2611 44 2623 41 59 125 773 865 2624 40 2607 2625 44 2607 2626 41 123 330 2627 40 2625 46 2628 40 41 44 2626 46 2628 40 41 41 59 2627 40 2625 46 2629 40 41 44 2626 46 2629 40 41 41 59 2627 40 2625 46 2630 40 41 44 2626 46 2630 40 41 41 59 2627 40 2625 46 2631 40 41 44 2626 46 2631 40 41 41 59 2627 40 2625 46 2632 40 41 44 2626 46 2632 40 41 41 59 2627 40 2625 46 2633 40 41 44 2626 46 2633 40 41 41 59 2627 40 2625 46 2634 40 41 44 2626 46 2634 40 41 41 59 688 40 2625 46 2628 40 41 46 2635 40 2636 46 2637 40 41 41 41 2627 40 2625 46 2638 40 41 44 2626 46 2638 40 41 41 59 630 2627 40 2625 46 2639 40 41 44 2626 46 2639 40 41 41 59 125 773 2010 2640 40 2009 2641 41 123 688 40 2011 46 2642 40 2641 41 41 123 792 2011 46 2643 40 2641 41 59 125 630 123 2010 2644 61 2645 40 2646 44 2641 41 59 2011 46 2647 40 2641 44 2644 41 59 792 2644 59 125 125 64 2648 777 809 865 2649 40 41 123 2011 46 2650 40 41 59 125 125 ,"{'AvgLine': 25, 'CountLine': 617, 'CountStmt': 290, 'MaxNesting': 1, 'AvgLineCode': 23, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 253, 'MaxEssential': 1, 'SumEssential': 29, 'AvgCyclomatic': 1, 'CountLineCode': 555, 'CountStmtDecl': 126, 'MaxCyclomatic': 2, 'SumCyclomatic': 31, 'AvgLineComment': 2, 'CountClassBase': 1, 'CountLineBlank': 40, 'CountSemicolon': 264, 'CountDeclMethod': 23, 'CountLineCodeExe': 455, 'CountLineComment': 52, 'CountClassCoupled': 18, 'CountClassDerived': 0, 'CountLineCodeDecl': 204, 'CountDeclMethodAll': 55, 'MaxInheritanceTree': 4, 'RatioCommentToCode': '0.09', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 31, 'CountDeclClassMethod': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 19, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 31, 'CountDeclClassVariable': 3, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 4, 'CountDeclInstanceMethod': 22, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 18, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2890,Java,"public class JsonUtil {
    public static String objectToJson(Object object) {
        GsonBuilder gsonBuilder = new GsonBuilder()
                .setExclusionStrategies(new AnnotationExclusionStrategy())
                .setPrettyPrinting();
        if (object instanceof Contract || object instanceof OfferPayload) {
            gsonBuilder.registerTypeAdapter(OfferPayload.class,
                    new OfferPayload.JsonSerializer());
        }
        return gsonBuilder.create().toJson(object);
    }

    private static class AnnotationExclusionStrategy implements ExclusionStrategy {
        @Override
        public boolean shouldSkipField(FieldAttributes f) {
            return f.getAnnotation(JsonExclude.class) != null;
        }

        @Override
        public boolean shouldSkipClass(Class<?> clazz) {
            return false;
        }
    }
}",0,777 587 2000 123 777 809 2001 2002 40 2003 2004 41 123 2005 2006 61 744 2005 40 41 46 2007 40 744 2008 40 41 41 46 2009 40 41 59 688 40 2004 702 2010 309 2004 702 2011 41 123 2006 46 2012 40 2011 46 587 44 744 2011 46 2013 40 41 41 59 125 792 2006 46 2014 40 41 46 2015 40 2004 41 59 125 773 809 587 2016 693 2017 123 64 2018 777 570 2019 40 2020 2021 41 123 792 2021 46 2022 40 2023 46 587 41 340 2024 59 125 64 2018 777 570 2025 40 2026 60 63 62 2027 41 123 792 2028 59 125 125 125 ,"{'AvgLine': 10, 'CountLine': 24, 'CountStmt': 11, 'MaxNesting': 1, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 6, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 2, 'CountLineCode': 22, 'CountStmtDecl': 6, 'MaxCyclomatic': 2, 'SumCyclomatic': 2, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 2, 'CountSemicolon': 5, 'CountDeclMethod': 1, 'CountLineCodeExe': 9, 'CountLineComment': 0, 'CountClassCoupled': 6, 'CountClassDerived': 0, 'CountLineCodeDecl': 9, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 3, 'CountDeclClassMethod': 1, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 1, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 0, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 6, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2919,Java,"@Slf4j
public class BitcoinDaemon extends AbstractLinuxProcess implements LinuxProcess {

    public BitcoinDaemon(ApiTestConfig config) {
        super(""bitcoind"", config);
    }

    @Override
    public void start() throws InterruptedException, IOException {

        // If the bitcoind binary is dynamically linked to berkeley db libs, export the
        // configured berkeley-db lib path.  If statically linked, the berkeley db lib
        // path will not be exported.
        String berkeleyDbLibPathExport = config.berkeleyDbLibPath.equals(EMPTY) ? EMPTY
                : ""export LD_LIBRARY_PATH="" + config.berkeleyDbLibPath + ""; "";

        String bitcoindCmd = berkeleyDbLibPathExport
                + config.bitcoinPath + ""/bitcoind""
                + "" -datadir="" + config.bitcoinDatadir
                + "" -daemon""
                + "" -regtest=1""
                + "" -server=1""
                + "" -txindex=1""
                + "" -peerbloomfilters=1""
                + "" -debug=net""
                + "" -fallbackfee=0.0002""
                + "" -rpcport="" + config.bitcoinRpcPort
                + "" -rpcuser="" + config.bitcoinRpcUser
                + "" -rpcpassword="" + config.bitcoinRpcPassword
                + "" -blocknotify="" + ""\"""" + config.bitcoinDatadir + ""/blocknotify"" + "" %s\"""";

        BashCommand cmd = new BashCommand(bitcoindCmd).run();
        log.info(""Starting ...\n$ {}"", cmd.getCommand());

        if (cmd.getExitStatus() != 0) {
            startupExceptions.add(new IllegalStateException(
                    format(""Error starting bitcoind%nstatus: %d%nerror msg: %s"",
                            cmd.getExitStatus(), cmd.getError())));
            return;
        }

        pid = BashCommand.getPid(""bitcoind"");
        if (!isAlive(pid))
            throw new IllegalStateException(""Error starting regtest bitcoind daemon:\n"" + cmd.getCommand());

        log.info(""Running with pid {}"", pid);
        log.info(""Log {}"", config.bitcoinDatadir + ""/regtest/debug.log"");
    }

    @Override
    public long getPid() {
        return this.pid;
    }

    @Override
    public void shutdown() {
        try {
            log.info(""Shutting down bitcoind daemon..."");

            if (!isAlive(pid)) {
                this.shutdownExceptions.add(new IllegalStateException(""Bitcoind already shut down.""));
                return;
            }

            if (new BashCommand(""kill -15 "" + pid).run().getExitStatus() != 0) {
                this.shutdownExceptions.add(new IllegalStateException(""Could not shut down bitcoind; probably already stopped.""));
                return;
            }

            MILLISECONDS.sleep(2500); // allow it time to shutdown

            if (isAlive(pid)) {
                this.shutdownExceptions.add(new IllegalStateException(
                        format(""Could not kill bitcoind process with pid %d."", pid)));
                return;
            }

            log.info(""Stopped"");
        } catch (InterruptedException ignored) {
            // empty
        } catch (IOException e) {
            this.shutdownExceptions.add(new IllegalStateException(""Error shutting down bitcoind."", e));
        }
    }
}",0,64 2000 777 587 2001 650 2002 693 2003 123 777 2001 40 2004 2005 41 123 818 40 362 44 2005 41 59 125 64 2006 777 865 2007 40 41 826 2008 44 2009 123 330 330 330 2010 2011 61 2005 46 2012 46 2013 40 2014 41 63 2014 58 362 43 2005 46 2012 43 362 59 2010 2015 61 2011 43 2005 46 2016 43 362 43 362 43 2005 46 2017 43 362 43 362 43 362 43 362 43 362 43 362 43 362 43 362 43 2005 46 2018 43 362 43 2005 46 2019 43 362 43 2005 46 2020 43 362 43 362 43 2005 46 2017 43 362 43 362 59 2021 2022 61 744 2021 40 2015 41 46 2023 40 41 59 2024 46 2025 40 362 44 2022 46 2026 40 41 41 59 688 40 2022 46 2027 40 41 340 1500 41 123 2028 46 2029 40 744 2030 40 2031 40 362 44 2022 46 2027 40 41 44 2022 46 2032 40 41 41 41 41 59 792 59 125 2033 61 2021 46 2034 40 362 41 59 688 40 33 2035 40 2033 41 41 825 744 2036 40 362 43 2022 46 2026 40 41 41 59 2024 46 2025 40 362 44 2033 41 59 2024 46 2025 40 362 44 2005 46 2017 43 362 41 59 125 64 2006 777 726 2037 40 41 123 792 823 46 2038 59 125 64 2006 777 865 2039 40 41 123 830 123 2040 46 2041 40 362 41 59 688 40 33 2042 40 2043 41 41 123 823 46 2044 46 2045 40 744 2046 40 362 41 41 59 792 59 125 688 40 744 2047 40 362 43 2043 41 46 2048 40 41 46 2049 40 41 340 1500 41 123 823 46 2050 46 2051 40 744 2052 40 362 41 41 59 792 59 125 2053 46 2054 40 1505 41 59 330 688 40 2042 40 2043 41 41 123 823 46 2055 46 2056 40 744 2057 40 2058 40 362 44 2043 41 41 41 59 792 59 125 2040 46 2041 40 362 41 59 125 580 40 2008 2059 41 123 330 125 580 40 2009 2060 41 123 823 46 2061 46 2062 40 744 2063 40 362 44 2060 41 41 59 125 125 125 ,"{'AvgLine': 19, 'CountLine': 85, 'CountStmt': 33, 'MaxNesting': 2, 'AvgLineCode': 15, 'AvgEssential': 2, 'AvgLineBlank': 2, 'CountStmtExe': 27, 'MaxEssential': 6, 'SumEssential': 9, 'AvgCyclomatic': 3, 'CountLineCode': 66, 'CountStmtDecl': 8, 'MaxCyclomatic': 6, 'SumCyclomatic': 12, 'AvgLineComment': 1, 'CountClassBase': 2, 'CountLineBlank': 15, 'CountSemicolon': 22, 'CountDeclMethod': 4, 'CountLineCodeExe': 47, 'CountLineComment': 5, 'CountClassCoupled': 8, 'CountClassDerived': 0, 'CountLineCodeDecl': 14, 'CountDeclMethodAll': 14, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.08', 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 12, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 3, 'CountDeclMethodPublic': 4, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 12, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 4, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 8, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2952,Java,"                        return new TableCell<>() {
                            @Override
                            public void updateItem(final Dispute item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setText(CurrencyUtil.getCurrencyPair(item.getContract().getOfferPayload().getCurrencyCode()));
                                else
                                    setText("""");
                            }
                        };",0,792 744 2000 60 62 40 41 123 64 2001 777 865 2002 40 657 2003 2004 44 570 2005 41 123 818 46 2002 40 2004 44 2005 41 59 688 40 2004 340 2006 307 33 2005 41 2007 40 2008 46 2009 40 2004 46 2010 40 41 46 2011 40 41 46 2012 40 41 41 41 59 630 2007 40 362 41 59 125 125 59 ,"{'AvgLine': 8, 'CountLine': 9, 'CountStmt': 5, 'MaxNesting': 1, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 4, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 2, 'CountLineCode': 9, 'CountStmtDecl': 1, 'MaxCyclomatic': 2, 'SumCyclomatic': 2, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 0, 'CountSemicolon': 3, 'CountDeclMethod': 1, 'CountLineCodeExe': 8, 'CountLineComment': 0, 'CountClassCoupled': 3, 'CountClassDerived': 0, 'CountLineCodeDecl': 0, 'CountDeclMethodAll': 1, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 3, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 1, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 1, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 3, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2808,Java,"@EqualsAndHashCode(callSuper = true)
public final class FasterPaymentsAccount extends PaymentAccount {
    public FasterPaymentsAccount() {
        super(PaymentMethod.FASTER_PAYMENTS);
        setSingleTradeCurrency(new FiatCurrency(""GBP""));
    }

    @Override
    protected PaymentAccountPayload createPayload() {
        return new FasterPaymentsAccountPayload(paymentMethod.getId(), id);
    }

    public void setHolderName(String value) {
        ((FasterPaymentsAccountPayload) paymentAccountPayload).setHolderName(value);
    }

    public String getHolderName() {
        return ((FasterPaymentsAccountPayload) paymentAccountPayload).getHolderName();
    }

    public void setSortCode(String value) {
        ((FasterPaymentsAccountPayload) paymentAccountPayload).setSortCode(value);
    }

    public String getSortCode() {
        return ((FasterPaymentsAccountPayload) paymentAccountPayload).getSortCode();
    }

    public void setAccountNr(String value) {
        ((FasterPaymentsAccountPayload) paymentAccountPayload).setAccountNr(value);
    }

    public String getAccountNr() {
        return ((FasterPaymentsAccountPayload) paymentAccountPayload).getAccountNr();
    }
}",0,64 2000 40 2001 61 2002 41 777 657 587 2003 650 2004 123 777 2003 40 41 123 818 40 2005 46 2006 41 59 2007 40 744 2008 40 362 41 41 59 125 64 2009 775 2010 2011 40 41 123 792 744 2012 40 2013 46 2014 40 41 44 2015 41 59 125 777 865 2016 40 2017 2018 41 123 40 40 2019 41 2020 41 46 2016 40 2018 41 59 125 777 2017 2021 40 41 123 792 40 40 2022 41 2023 41 46 2021 40 41 59 125 777 865 2024 40 2017 2018 41 123 40 40 2025 41 2026 41 46 2024 40 2018 41 59 125 777 2017 2027 40 41 123 792 40 40 2028 41 2029 41 46 2027 40 41 59 125 777 865 2030 40 2017 2018 41 123 40 40 2031 41 2032 41 46 2030 40 2018 41 59 125 777 2017 2033 40 41 123 792 40 40 2034 41 2035 41 46 2033 40 41 59 125 125 ,"{'AvgLine': 3, 'CountLine': 36, 'CountStmt': 18, 'MaxNesting': 0, 'AvgLineCode': 3, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 9, 'MaxEssential': 1, 'SumEssential': 8, 'AvgCyclomatic': 1, 'CountLineCode': 29, 'CountStmtDecl': 9, 'MaxCyclomatic': 1, 'SumCyclomatic': 8, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 7, 'CountSemicolon': 9, 'CountDeclMethod': 8, 'CountLineCodeExe': 9, 'CountLineComment': 0, 'CountClassCoupled': 7, 'CountClassDerived': 0, 'CountLineCodeDecl': 11, 'CountDeclMethodAll': 33, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 8, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 7, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 8, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 8, 'CountDeclMethodProtected': 1, 'CountClassCoupledModified': 7, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2841,Java,"@Disabled
@Slf4j
@TestMethodOrder(OrderAnnotation.class)
public class BsqWalletTest extends MethodTest {

    private static final String SEND_BSQ_AMOUNT = ""25000.50"";

    @BeforeAll
    public static void setUp() {
        startSupportingApps(true,
                false,
                bitcoind,
                seednode,
                arbdaemon,
                alicedaemon,
                bobdaemon);
    }


    @Test
    @Order(1)
    public void testGetUnusedBsqAddress() {
        String addressString = aliceClient.getUnusedBsqAddress();
        assertFalse(addressString.isEmpty());
        assertTrue(addressString.startsWith(""B""));
        Address address = Address.fromString(NetworkParameters.fromID(ID_REGTEST), addressString.substring(1));
        NetworkParameters networkParameters = address.getParameters();
        String addressNetwork = networkParameters.getPaymentProtocolId();
        assertTrue(addressNetwork.equals(PAYMENT_PROTOCOL_ID_REGTEST));
    }

    @Test
    @Order(2)
    public void testInitialBsqBalances(final TestInfo testInfo) {
        BsqBalanceInfo alicesBsqBalances = aliceClient.getBsqBalances();
        log.debug(""{} -> Alice's BSQ Initial Balances -> \n{}"",
                testName(testInfo),
                new TableBuilder(BSQ_BALANCE_TBL, alicesBsqBalances).build());
        verifyBsqBalances(ALICES_INITIAL_BSQ_BALANCES, alicesBsqBalances);

        BsqBalanceInfo bobsBsqBalances = bobClient.getBsqBalances();
        log.debug(""{} -> Bob's BSQ Initial Balances -> \n{}"",
                testName(testInfo),
                new TableBuilder(BSQ_BALANCE_TBL, bobsBsqBalances).build());
        verifyBsqBalances(BOBS_INITIAL_BSQ_BALANCES, bobsBsqBalances);
    }

    @Test
    @Order(3)
    public void testSendBsqAndCheckBalancesBeforeGeneratingBtcBlock(final TestInfo testInfo) {
        String bobsBsqAddress = bobClient.getUnusedBsqAddress();
        aliceClient.sendBsq(bobsBsqAddress, SEND_BSQ_AMOUNT, ""100"");
        sleep(2000);

        BsqBalanceInfo alicesBsqBalances = aliceClient.getBsqBalances();
        BsqBalanceInfo bobsBsqBalances = waitForNonZeroBsqUnverifiedBalance(bobClient);

        log.debug(""BSQ Balances Before BTC Block Gen..."");
        printBobAndAliceBsqBalances(testInfo,
                bobsBsqBalances,
                alicesBsqBalances,
                alicedaemon);

        verifyBsqBalances(bsqBalanceModel(150000000,
                        2500050,
                        0,
                        0,
                        0,
                        0),
                bobsBsqBalances);

        verifyBsqBalances(bsqBalanceModel(97499950,
                        97499950,
                        97499950,
                        0,
                        0,
                        0),
                alicesBsqBalances);
    }

    @Test
    @Order(4)
    public void testBalancesAfterSendingBsqAndGeneratingBtcBlock(final TestInfo testInfo) {
        // There is a wallet persist delay;  we have to
        // wait for both wallets to be saved to disk.
        genBtcBlocksThenWait(1, 4000);

        BsqBalanceInfo alicesBsqBalances = aliceClient.getBalances().getBsq();
        BsqBalanceInfo bobsBsqBalances = waitForBsqNewAvailableConfirmedBalance(bobClient, 150000000);

        log.debug(""See Available Confirmed BSQ Balances..."");
        printBobAndAliceBsqBalances(testInfo,
                bobsBsqBalances,
                alicesBsqBalances,
                alicedaemon);

        verifyBsqBalances(bsqBalanceModel(152500050,
                        0,
                        0,
                        0,
                        0,
                        0),
                bobsBsqBalances);

        verifyBsqBalances(bsqBalanceModel(97499950,
                        0,
                        0,
                        0,
                        0,
                        0),
                alicesBsqBalances);
    }

    @AfterAll
    public static void tearDown() {
        tearDownScaffold();
    }

    private BsqBalanceInfo waitForNonZeroBsqUnverifiedBalance(GrpcClient grpcClient) {
        // A BSQ recipient needs to wait for her daemon to detect a new tx.
        // Loop here until her unverifiedBalance != 0, or give up after 15 seconds.
        // A slow test is preferred over a flaky test.
        BsqBalanceInfo bsqBalance = grpcClient.getBsqBalances();
        for (int numRequests = 1; numRequests <= 15 && bsqBalance.getUnverifiedBalance() == 0; numRequests++) {
            sleep(1000);
            bsqBalance = grpcClient.getBsqBalances();
        }
        return bsqBalance;
    }

    private BsqBalanceInfo waitForBsqNewAvailableConfirmedBalance(GrpcClient grpcClient,
                                                                  long staleBalance) {
        BsqBalanceInfo bsqBalance = grpcClient.getBsqBalances();
        for (int numRequests = 1;
             numRequests <= 15 && bsqBalance.getAvailableConfirmedBalance() == staleBalance;
             numRequests++) {
            sleep(1000);
            bsqBalance = grpcClient.getBsqBalances();
        }
        return bsqBalance;
    }

    @SuppressWarnings(""SameParameterValue"")
    private void printBobAndAliceBsqBalances(final TestInfo testInfo,
                                             BsqBalanceInfo bobsBsqBalances,
                                             BsqBalanceInfo alicesBsqBalances,
                                             BisqAppConfig senderApp) {
        log.debug(""{} -> Bob's BSQ Balances After {} {} BSQ-> \n{}"",
                testName(testInfo),
                senderApp.equals(bobdaemon) ? ""Sending"" : ""Receiving"",
                SEND_BSQ_AMOUNT,
                new TableBuilder(BSQ_BALANCE_TBL, bobsBsqBalances).build());

        log.debug(""{} -> Alice's Balances After {} {} BSQ-> \n{}"",
                testName(testInfo),
                senderApp.equals(alicedaemon) ? ""Sending"" : ""Receiving"",
                SEND_BSQ_AMOUNT,
                new TableBuilder(BSQ_BALANCE_TBL, alicesBsqBalances).build());
    }
}",0,64 2000 64 2001 64 2002 40 2003 46 587 41 777 587 2004 650 2005 123 773 809 657 2006 2007 61 362 59 64 2008 777 809 865 2009 40 41 123 2010 40 2011 44 2012 44 2013 44 2014 44 2015 44 2016 44 2017 41 59 125 64 2018 64 2019 40 1501 41 777 865 2020 40 41 123 2006 2021 61 2022 46 2023 40 41 59 2024 40 2021 46 2025 40 41 41 59 2026 40 2021 46 2027 40 362 41 41 59 2028 2029 61 2028 46 2030 40 2031 46 2032 40 2033 41 44 2021 46 2034 40 1501 41 41 59 2031 2035 61 2029 46 2036 40 41 59 2006 2037 61 2035 46 2038 40 41 59 2026 40 2037 46 2039 40 2040 41 41 59 125 64 2018 64 2019 40 1502 41 777 865 2041 40 657 2042 2043 41 123 2044 2045 61 2046 46 2047 40 41 59 2048 46 2049 40 362 44 2050 40 2043 41 44 744 2051 40 2052 44 2045 41 46 2053 40 41 41 59 2054 40 2055 44 2045 41 59 2044 2056 61 2057 46 2047 40 41 59 2048 46 2049 40 362 44 2050 40 2043 41 44 744 2051 40 2052 44 2056 41 46 2053 40 41 41 59 2054 40 2058 44 2056 41 59 125 64 2018 64 2019 40 1502 41 777 865 2059 40 657 2042 2043 41 123 2006 2060 61 2061 46 2062 40 41 59 2063 46 2064 40 2060 44 2007 44 362 41 59 2065 40 1505 41 59 2066 2067 61 2063 46 2068 40 41 59 2066 2069 61 2070 40 2061 41 59 2071 46 2072 40 362 41 59 2073 40 2043 44 2069 44 2067 44 2074 41 59 2075 40 2076 40 1510 44 1508 44 1500 44 1500 44 1500 44 1500 41 44 2069 41 59 2075 40 2076 40 1509 44 1509 44 1509 44 1500 44 1500 44 1500 41 44 2067 41 59 125 64 2018 64 2019 40 1502 41 777 865 2077 40 657 2042 2043 41 123 330 330 2078 40 1501 44 1505 41 59 2079 2080 61 2081 46 2082 40 41 46 2083 40 41 59 2079 2084 61 2085 40 2086 44 1510 41 59 2087 46 2088 40 362 41 59 2089 40 2043 44 2084 44 2080 44 2090 41 59 2091 40 2092 40 1510 44 1500 44 1500 44 1500 44 1500 44 1500 41 44 2084 41 59 2091 40 2092 40 1509 44 1500 44 1500 44 1500 44 1500 44 1500 41 44 2080 41 59 125 64 2093 777 809 865 2094 40 41 123 2095 40 41 59 125 773 2096 2097 40 2098 2099 41 123 330 330 330 2096 2100 61 2099 46 2101 40 41 59 664 40 704 2102 61 1501 59 2102 329 1503 307 2100 46 2103 40 41 323 1500 59 2102 349 41 123 2104 40 1504 41 59 2100 61 2099 46 2101 40 41 59 125 792 2100 59 125 773 2096 2105 40 2098 2099 44 726 2106 41 123 2096 2107 61 2099 46 2108 40 41 59 664 40 704 2109 61 1501 59 2109 329 1503 307 2107 46 2110 40 41 323 2106 59 2109 349 41 123 2111 40 1504 41 59 2107 61 2099 46 2108 40 41 59 125 792 2107 59 125 64 2112 40 362 41 773 865 2113 40 657 2042 2043 44 2096 2114 44 2096 2115 44 2116 2117 41 123 2118 46 2119 40 362 44 2120 40 2043 41 44 2117 46 2121 40 2122 41 63 362 58 362 44 2007 44 744 2123 40 2124 44 2114 41 46 2125 40 41 41 59 2118 46 2119 40 362 44 2120 40 2043 41 44 2117 46 2121 40 2126 41 63 362 58 362 44 2007 44 744 2123 40 2124 44 2115 41 46 2125 40 41 41 59 125 125 ,"{'AvgLine': 15, 'CountLine': 160, 'CountStmt': 58, 'MaxNesting': 1, 'AvgLineCode': 14, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 45, 'MaxEssential': 1, 'SumEssential': 9, 'AvgCyclomatic': 1, 'CountLineCode': 134, 'CountStmtDecl': 26, 'MaxCyclomatic': 3, 'SumCyclomatic': 13, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 21, 'CountSemicolon': 46, 'CountDeclMethod': 9, 'CountLineCodeExe': 94, 'CountLineComment': 5, 'CountClassCoupled': 18, 'CountClassDerived': 0, 'CountLineCodeDecl': 42, 'CountDeclMethodAll': 29, 'MaxInheritanceTree': 3, 'RatioCommentToCode': '0.04', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 15, 'CountDeclClassMethod': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 6, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 13, 'CountDeclClassVariable': 1, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 3, 'CountDeclInstanceMethod': 7, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 18, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2745,Java,"@Slf4j
public class BsqSwapCalculation {
    private static final int MIN_SELLERS_TX_SIZE = 104;

    // Estimated size in case we do not have enough funds to calculate it from wallet inputs.
    // We use 3 non segwit inputs. 5 + 3*149 + 62 = 514
    public static final int ESTIMATED_V_BYTES = 514;

    // Buyer
    public static Coin getBuyersBsqInputValue(BsqSwapTrade trade, long buyersTradeFee) {
        return getBuyersBsqInputValue(trade.getBsqTradeAmount(), buyersTradeFee);
    }

    public static Coin getBuyersBsqInputValue(long bsqTradeAmount, long buyersTradeFee) {
        return Coin.valueOf(bsqTradeAmount + buyersTradeFee);
    }

    public static Coin getBuyersBtcPayoutValue(BsqSwapTrade trade, int buyersVBytesSize, long buyerTradeFee) {
        return getBuyersBtcPayoutValue(trade.getAmountAsLong(), trade.getTxFeePerVbyte(), buyersVBytesSize, buyerTradeFee);
    }

    public static Coin getBuyersBtcPayoutValue(long btcTradeAmount,
                                               long txFeePerVbyte,
                                               int buyersVBytesSize,
                                               long buyerTradeFee) {
        long buyersTxFee = getAdjustedTxFee(txFeePerVbyte, buyersVBytesSize, buyerTradeFee);
        return getBuyersBtcPayoutValue(btcTradeAmount, buyersTxFee);
    }

    public static Coin getBuyersBtcPayoutValue(BsqWalletService bsqWalletService,
                                               Coin bsqTradeAmount,
                                               Coin btcTradeAmount,
                                               long txFeePerVbyte,
                                               long buyerTradeFee) throws InsufficientBsqException {
        Tuple2<List<RawTransactionInput>, Coin> inputsAndChange = getBuyersBsqInputsAndChange(bsqWalletService, bsqTradeAmount.getValue(), buyerTradeFee);
        int buyersVBytesSize = BsqSwapCalculation.getVBytesSize(inputsAndChange.first, inputsAndChange.second.getValue());
        long buyersTxFee = getAdjustedTxFee(txFeePerVbyte, buyersVBytesSize, buyerTradeFee);
        return getBuyersBtcPayoutValue(btcTradeAmount.getValue(), buyersTxFee);
    }

    public static Tuple2<List<RawTransactionInput>, Coin> getBuyersBsqInputsAndChange(BsqWalletService bsqWalletService,
                                                                                      long amount,
                                                                                      long buyersTradeFee)
            throws InsufficientBsqException {
        Coin required = getBuyersBsqInputValue(amount, buyersTradeFee);
        return bsqWalletService.getBuyersBsqInputsForBsqSwapTx(required);
    }

    public static Coin getEstimatedBuyersBtcPayoutValue(Coin btcTradeAmount,
                                                        long txFeePerVbyte,
                                                        long buyerTradeFee) {
        // Use estimated size. This is used in case the wallet has not enough fund so we cannot calculate the exact
        // amount but we still want to provide some estimated value.
        long buyersTxFee = getAdjustedTxFee(txFeePerVbyte, ESTIMATED_V_BYTES, buyerTradeFee);
        return getBuyersBtcPayoutValue(btcTradeAmount.getValue(), buyersTxFee);
    }

    private static Coin getBuyersBtcPayoutValue(long btcTradeAmount, long buyerTxFee) {
        return Coin.valueOf(btcTradeAmount - buyerTxFee);
    }

    // Seller
    public static Coin getSellersBtcInputValue(BsqSwapTrade trade, int sellersTxSize, long sellersTradeFee) {
        return getSellersBtcInputValue(trade.getAmountAsLong(), trade.getTxFeePerVbyte(), sellersTxSize, sellersTradeFee);
    }

    public static Coin getSellersBtcInputValue(long btcTradeAmount,
                                               long txFeePerVbyte,
                                               int sellersVBytesSize,
                                               long sellersTradeFee) {
        long sellersTxFee = getAdjustedTxFee(txFeePerVbyte, sellersVBytesSize, sellersTradeFee);
        return getSellersBtcInputValue(btcTradeAmount, sellersTxFee);
    }

    public static Coin getSellersBtcInputValue(BtcWalletService btcWalletService,
                                               Coin btcTradeAmount,
                                               long txFeePerVbyte,
                                               long sellersTradeFee) throws InsufficientMoneyException {
        Tuple2<List<RawTransactionInput>, Coin> inputsAndChange = getSellersBtcInputsAndChange(btcWalletService,
                btcTradeAmount.getValue(),
                txFeePerVbyte,
                sellersTradeFee);
        int sellersVBytesSize = getVBytesSize(inputsAndChange.first, inputsAndChange.second.getValue());
        long sellersTxFee = getAdjustedTxFee(txFeePerVbyte, sellersVBytesSize, sellersTradeFee);
        return getSellersBtcInputValue(btcTradeAmount.getValue(), sellersTxFee);
    }

    public static Coin getEstimatedSellersBtcInputValue(Coin btcTradeAmount,
                                                        long txFeePerVbyte,
                                                        long sellersTradeFee) {
        // Use estimated size. This is used in case the wallet has not enough fund so we cannot calculate the exact
        // amount but we still want to provide some estimated value.
        long sellersTxFee = getAdjustedTxFee(txFeePerVbyte, ESTIMATED_V_BYTES, sellersTradeFee);
        return getSellersBtcInputValue(btcTradeAmount.getValue(), sellersTxFee);
    }

    public static Coin getSellersBtcInputValue(long btcTradeAmount, long sellerTxFee) {
        return Coin.valueOf(btcTradeAmount + sellerTxFee);
    }

    public static Coin getSellersBsqPayoutValue(BsqSwapTrade trade, long sellerTradeFee) {
        return getSellersBsqPayoutValue(trade.getBsqTradeAmount(), sellerTradeFee);
    }

    public static Coin getSellersBsqPayoutValue(long bsqTradeAmount, long sellerTradeFee) {
        return Coin.valueOf(bsqTradeAmount - sellerTradeFee);
    }

    // Tx fee estimation
    public static Tuple2<List<RawTransactionInput>, Coin> getSellersBtcInputsAndChange(BtcWalletService btcWalletService,
                                                                                       long amount,
                                                                                       long txFeePerVbyte,
                                                                                       long sellersTradeFee)
            throws InsufficientMoneyException {
        // Figure out how large out tx will be
        int iterations = 0;
        Tuple2<List<RawTransactionInput>, Coin> inputsAndChange;
        Coin previous = null;

        // At first we try with min. tx size
        int sellersTxSize = MIN_SELLERS_TX_SIZE;
        Coin change = Coin.ZERO;
        Coin required = getSellersBtcInputValue(amount, txFeePerVbyte, sellersTxSize, sellersTradeFee);

        // We do a first calculation here to get the size of the inputs (segwit or not) and we adjust the sellersTxSize
        // so that we avoid to get into dangling states.
        inputsAndChange = btcWalletService.getInputsAndChange(required);
        sellersTxSize = getVBytesSize(inputsAndChange.first, 0);
        required = getSellersBtcInputValue(amount, txFeePerVbyte, sellersTxSize, sellersTradeFee);

        // As fee calculation is not deterministic it could be that we toggle between a too small and too large
        // inputs. We would take the latest result before we break iteration. Worst case is that we under- or
        // overpay a bit. As fee rate is anyway an estimation we ignore that imperfection.
        while (iterations < 10 && !required.equals(previous)) {
            inputsAndChange = btcWalletService.getInputsAndChange(required);
            previous = required;

            // We calculate more exact tx size based on resulted inputs and change
            change = inputsAndChange.second;
            if (Restrictions.isDust(change)) {
                log.warn(""We got a change below dust. We ignore that and use it as miner fee."");
                change = Coin.ZERO;
            }

            sellersTxSize = getVBytesSize(inputsAndChange.first, change.getValue());
            required = getSellersBtcInputValue(amount, txFeePerVbyte, sellersTxSize, sellersTradeFee);

            iterations++;
        }

        checkNotNull(inputsAndChange);

        return new Tuple2<>(inputsAndChange.first, change);
    }

    // Tx fee

    // See https://bitcoin.stackexchange.com/questions/87275/how-to-calculate-segwit-transaction-fee-in-bytes
    public static int getVBytesSize(List<RawTransactionInput> inputs, long change) {
        int size = 5; // Half of base tx size (10)
        size += inputs.stream()
                .mapToLong(input -> input.isSegwit() ? 68 : 149)
                .sum();
        size += change > 0 ? 62 : 31;
        return size;
    }

    public static long getAdjustedTxFee(BsqSwapTrade trade, int vBytes, long tradeFee) {
        return getAdjustedTxFee(trade.getTxFeePerVbyte(), vBytes, tradeFee);
    }

    public static long getAdjustedTxFee(long txFeePerVbyte, int vBytes, long tradeFee) {
        return txFeePerVbyte * vBytes - tradeFee;
    }

    // Convert BTC trade amount to BSQ amount
    public static Coin getBsqTradeAmount(Volume volume) {
        // We treat BSQ as altcoin with smallest unit exponent 8 but we use 2 instead.
        // To avoid a larger refactoring of the monetary domain we just hack in the conversion here
        // by removing the last 6 digits.
        return Coin.valueOf(MathUtils.roundDoubleToLong(MathUtils.scaleDownByPowerOf10(volume.getValue(), 6)));
    }
}",0,64 2000 777 587 2001 123 773 809 657 704 2002 61 1504 59 330 330 777 809 657 704 2003 61 1504 59 330 777 809 2004 2005 40 2006 2007 44 726 2008 41 123 792 2005 40 2007 46 2009 40 41 44 2008 41 59 125 777 809 2004 2005 40 726 2010 44 726 2008 41 123 792 2004 46 2011 40 2010 43 2008 41 59 125 777 809 2004 2012 40 2006 2007 44 704 2013 44 726 2014 41 123 792 2012 40 2007 46 2015 40 41 44 2007 46 2016 40 41 44 2013 44 2014 41 59 125 777 809 2004 2012 40 726 2017 44 726 2018 44 704 2013 44 726 2014 41 123 726 2019 61 2020 40 2018 44 2013 44 2014 41 59 792 2012 40 2017 44 2019 41 59 125 777 809 2004 2012 40 2021 2022 44 2004 2010 44 2004 2017 44 726 2018 44 726 2014 41 826 2023 123 2024 60 2025 60 2026 62 44 2004 62 2027 61 2028 40 2022 44 2010 46 2029 40 41 44 2014 41 59 704 2013 61 2001 46 2030 40 2027 46 2031 44 2027 46 2032 46 2029 40 41 41 59 726 2033 61 2034 40 2018 44 2013 44 2014 41 59 792 2012 40 2017 46 2029 40 41 44 2033 41 59 125 777 809 2035 60 2036 60 2037 62 44 2004 62 2038 40 2021 2022 44 726 2039 44 726 2008 41 826 2023 123 2004 2040 61 2005 40 2039 44 2008 41 59 792 2022 46 2041 40 2040 41 59 125 777 809 2004 2042 40 2004 2017 44 726 2018 44 726 2014 41 123 330 330 726 2043 61 2044 40 2018 44 2003 44 2014 41 59 792 2012 40 2017 46 2045 40 41 44 2043 41 59 125 773 809 2004 2012 40 726 2017 44 726 2046 41 123 792 2004 46 2047 40 2017 45 2046 41 59 125 330 777 809 2004 2048 40 2006 2007 44 704 2049 44 726 2050 41 123 792 2048 40 2007 46 2051 40 41 44 2007 46 2052 40 41 44 2049 44 2050 41 59 125 777 809 2004 2048 40 726 2017 44 726 2018 44 704 2053 44 726 2050 41 123 726 2054 61 2055 40 2018 44 2053 44 2050 41 59 792 2048 40 2017 44 2054 41 59 125 777 809 2004 2048 40 2056 2057 44 2004 2017 44 726 2018 44 726 2050 41 826 2058 123 2035 60 2036 60 2037 62 44 2004 62 2059 61 2060 40 2057 44 2017 46 2061 40 41 44 2018 44 2050 41 59 704 2053 61 2062 40 2059 46 2063 44 2059 46 2064 46 2061 40 41 41 59 726 2065 61 2066 40 2018 44 2053 44 2050 41 59 792 2048 40 2017 46 2061 40 41 44 2065 41 59 125 777 809 2004 2067 40 2004 2017 44 726 2018 44 726 2050 41 123 330 330 726 2068 61 2069 40 2018 44 2003 44 2050 41 59 792 2048 40 2017 46 2070 40 41 44 2068 41 59 125 777 809 2004 2048 40 726 2017 44 726 2071 41 123 792 2004 46 2072 40 2017 43 2071 41 59 125 777 809 2004 2073 40 2006 2007 44 726 2074 41 123 792 2073 40 2007 46 2075 40 41 44 2074 41 59 125 777 809 2004 2073 40 726 2010 44 726 2074 41 123 792 2004 46 2076 40 2010 45 2074 41 59 125 330 777 809 2035 60 2036 60 2037 62 44 2004 62 2077 40 2056 2057 44 726 2039 44 726 2018 44 726 2050 41 826 2058 123 330 704 2078 61 1500 59 2035 60 2036 60 2037 62 44 2004 62 2079 59 2004 2080 61 2081 59 330 704 2049 61 2002 59 2004 2082 61 2004 46 2083 59 2004 2084 61 2048 40 2039 44 2018 44 2049 44 2050 41 59 330 330 2079 61 2057 46 2085 40 2084 41 59 2049 61 2086 40 2079 46 2087 44 1500 41 59 2084 61 2048 40 2039 44 2018 44 2049 44 2050 41 59 330 330 330 870 40 2078 60 1502 307 33 2084 46 2088 40 2080 41 41 123 2079 61 2057 46 2085 40 2084 41 59 2080 61 2084 59 330 2082 61 2079 46 2089 59 688 40 2090 46 2091 40 2082 41 41 123 2092 46 2093 40 362 41 59 2082 61 2004 46 2083 59 125 2049 61 2086 40 2079 46 2087 44 2082 46 2094 40 41 41 59 2084 61 2048 40 2039 44 2018 44 2049 44 2050 41 59 2078 349 59 125 2095 40 2079 41 59 792 744 2035 60 62 40 2079 46 2087 44 2082 41 59 125 330 330 777 809 704 2096 40 2036 60 2037 62 2097 44 726 2098 41 123 704 2099 61 1502 59 330 2099 348 2097 46 2100 40 41 46 2101 40 2102 45 62 2102 46 2103 40 41 63 1503 58 1504 41 46 2104 40 41 59 2099 348 2098 62 1500 63 1503 58 1503 59 792 2099 59 125 777 809 726 2105 40 2006 2007 44 704 2106 44 726 2107 41 123 792 2105 40 2007 46 2108 40 41 44 2106 44 2107 41 59 125 777 809 726 2105 40 726 2018 44 704 2106 44 726 2107 41 123 792 2018 42 2106 45 2107 59 125 330 777 809 2004 2109 40 2110 2111 41 123 330 330 330 792 2004 46 2112 40 2113 46 2114 40 2113 46 2115 40 2111 46 2116 40 41 44 1502 41 41 41 59 125 125 ,"{'AvgLine': 7, 'CountLine': 206, 'CountStmt': 77, 'MaxNesting': 2, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 48, 'MaxEssential': 1, 'SumEssential': 21, 'AvgCyclomatic': 1, 'CountLineCode': 130, 'CountStmtDecl': 41, 'MaxCyclomatic': 3, 'SumCyclomatic': 25, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 30, 'CountSemicolon': 54, 'CountDeclMethod': 20, 'CountLineCodeExe': 60, 'CountLineComment': 47, 'CountClassCoupled': 11, 'CountClassDerived': 0, 'CountLineCodeDecl': 67, 'CountDeclMethodAll': 20, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.36', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 4, 'SumCyclomaticStrict': 26, 'CountDeclClassMethod': 20, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 19, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 25, 'CountDeclClassVariable': 2, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 0, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 11, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2734,Java,"abstract class AbstractTableBuilder {

    protected final TableType tableType;
    protected final List<?> protos;

    AbstractTableBuilder(TableType tableType, List<?> protos) {
        this.tableType = tableType;
        this.protos = protos;
        if (protos.isEmpty())
            throw new IllegalArgumentException(""cannot build a table without rows"");
    }

    public abstract Table build();

    protected final Predicate<OfferInfo> isFiatOffer = (o) -> o.getBaseCurrencyCode().equals(""BTC"");
}",0,539 587 2000 123 775 657 2001 2002 59 775 657 2003 60 63 62 2004 59 2000 40 2001 2002 44 2003 60 63 62 2004 41 123 823 46 2002 61 2002 59 823 46 2004 61 2004 59 688 40 2004 46 2005 40 41 41 825 744 2006 40 362 41 59 125 777 539 2007 2008 40 41 59 775 657 2009 60 2010 62 2011 61 40 2012 41 45 62 2012 46 2013 40 41 46 2014 40 362 41 59 125 ,"{'AvgLine': 6, 'CountLine': 19, 'CountStmt': 10, 'MaxNesting': 1, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 4, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 2, 'CountLineCode': 12, 'CountStmtDecl': 6, 'MaxCyclomatic': 2, 'SumCyclomatic': 2, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 4, 'CountSemicolon': 7, 'CountDeclMethod': 2, 'CountLineCodeExe': 5, 'CountLineComment': 3, 'CountClassCoupled': 5, 'CountClassDerived': 9, 'CountLineCodeDecl': 6, 'CountDeclMethodAll': 3, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.25', 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 1, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 33, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 1, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 2, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 5, 'CountDeclInstanceVariable': 3, 'PercentLackOfCohesionModified': 33}"
2823,Java,"@Value
public class MeritList implements Proto, ConsensusCritical, ImmutableDaoStateModel {
    private final List<Merit> list;

    ///////////////////////////////////////////////////////////////////////////////////////////
    // PROTO BUFFER
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public protobuf.MeritList toProtoMessage() {
        return getBuilder().build();
    }

    public protobuf.MeritList.Builder getBuilder() {
        return protobuf.MeritList.newBuilder()
                .addAllMerit(getList().stream()
                        .map(Merit::toProtoMessage)
                        .collect(Collectors.toList()));
    }

    public static MeritList fromProto(protobuf.MeritList proto) {
        return new MeritList(new ArrayList<>(proto.getMeritList().stream()
                .map(Merit::fromProto)
                .collect(Collectors.toList())));
    }

    public static MeritList getMeritListFromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return MeritList.fromProto(protobuf.MeritList.parseFrom(bytes));
    }
}",0,64 2000 777 587 2001 693 2002 44 2003 44 2004 123 773 657 2005 60 2006 62 2007 59 331 330 331 64 2008 777 2009 46 2001 2010 40 41 123 792 2011 40 41 46 2012 40 41 59 125 777 2009 46 2001 46 2013 2014 40 41 123 792 2009 46 2001 46 2015 40 41 46 2016 40 2017 40 41 46 2018 40 41 46 2019 40 2006 58 58 2010 41 46 2020 40 2021 46 2022 40 41 41 41 59 125 777 809 2001 2023 40 2009 46 2001 2024 41 123 792 744 2001 40 744 2025 60 62 40 2024 46 2026 40 41 46 2027 40 41 46 2028 40 2006 58 58 2023 41 46 2029 40 2030 46 2031 40 41 41 41 41 59 125 777 809 2001 2032 40 574 91 93 2033 41 826 2034 123 792 2001 46 2023 40 2009 46 2001 46 2035 40 2033 41 41 59 125 125 ,"{'AvgLine': 4, 'CountLine': 30, 'CountStmt': 10, 'MaxNesting': 0, 'AvgLineCode': 4, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 4, 'MaxEssential': 1, 'SumEssential': 4, 'AvgCyclomatic': 1, 'CountLineCode': 22, 'CountStmtDecl': 6, 'MaxCyclomatic': 1, 'SumCyclomatic': 4, 'AvgLineComment': 0, 'CountClassBase': 4, 'CountLineBlank': 5, 'CountSemicolon': 5, 'CountDeclMethod': 4, 'CountLineCodeExe': 9, 'CountLineComment': 3, 'CountClassCoupled': 9, 'CountClassDerived': 0, 'CountLineCodeDecl': 8, 'CountDeclMethodAll': 4, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.14', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 1, 'SumCyclomaticStrict': 4, 'CountDeclClassMethod': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 4, 'MaxCyclomaticModified': 1, 'PercentLackOfCohesion': 100, 'SumCyclomaticModified': 4, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 2, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 9, 'CountDeclInstanceVariable': 1, 'PercentLackOfCohesionModified': 100}"
2517,Java,"        SUGARCANE(Blocks.REEDS, null) {
            @Override
            public boolean readyToHarvest(World world, BlockPos pos, IBlockState state) {
                if (Baritone.settings().replantCrops.value) {
                    return world.getBlockState(pos.down()).getBlock() instanceof BlockReed;
                }
                return true;
            }
        },",0,2000 40 2001 46 2002 44 2003 41 123 64 2004 777 570 2005 40 2006 2007 44 2008 2009 44 2010 2011 41 123 688 40 2012 46 2013 40 41 46 2014 46 2015 41 123 792 2007 46 2016 40 2009 46 2017 40 41 41 46 2018 40 41 702 2019 59 125 792 2020 59 125 125 44 ,"{'AvgLine': 7, 'CountLine': 8, 'CountStmt': 4, 'MaxNesting': 1, 'AvgLineCode': 7, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 3, 'MaxEssential': 1, 'SumEssential': 1, 'AvgCyclomatic': 2, 'CountLineCode': 8, 'CountStmtDecl': 1, 'MaxCyclomatic': 2, 'SumCyclomatic': 2, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 0, 'CountSemicolon': 2, 'CountDeclMethod': 1, 'CountLineCodeExe': 3, 'CountLineComment': 0, 'CountClassCoupled': 8, 'CountClassDerived': 0, 'CountLineCodeDecl': 3, 'CountDeclMethodAll': 9, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 2, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 1, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 2, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 1, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 8, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2631,Java,"public class MovementPillar extends Movement {

    public MovementPillar(IBaritone baritone, BetterBlockPos start, BetterBlockPos end) {
        super(baritone, start, end, new BetterBlockPos[]{start.up(2)}, start);
    }

    @Override
    public double calculateCost(CalculationContext context) {
        return cost(context, src.x, src.y, src.z);
    }

    @Override
    protected Set<BetterBlockPos> calculateValidPositions() {
        return ImmutableSet.of(src, dest);
    }

    public static double cost(CalculationContext context, int x, int y, int z) {
        IBlockState fromState = context.get(x, y, z);
        Block from = fromState.getBlock();
        boolean ladder = from == Blocks.LADDER || from == Blocks.VINE;
        IBlockState fromDown = context.get(x, y - 1, z);
        if (!ladder) {
            if (fromDown.getBlock() == Blocks.LADDER || fromDown.getBlock() == Blocks.VINE) {
                return COST_INF; // can't pillar from a ladder or vine onto something that isn't also climbable
            }
            if (fromDown.getBlock() instanceof BlockSlab && !((BlockSlab) fromDown.getBlock()).isDouble() && fromDown.getValue(BlockSlab.HALF) == BlockSlab.EnumBlockHalf.BOTTOM) {
                return COST_INF; // can't pillar up from a bottom slab onto a non ladder
            }
        }
        if (from == Blocks.VINE && !hasAgainst(context, x, y, z)) { // TODO this vine can't be climbed, but we could place a pillar still since vines are replacable, no? perhaps the pillar jump would be impossible because of the slowdown actually.
            return COST_INF;
        }
        IBlockState toBreak = context.get(x, y + 2, z);
        Block toBreakBlock = toBreak.getBlock();
        if (toBreakBlock instanceof BlockFenceGate) { // see issue #172
            return COST_INF;
        }
        Block srcUp = null;
        if (MovementHelper.isWater(toBreakBlock) && MovementHelper.isWater(from)) { // TODO should this also be allowed if toBreakBlock is air?
            srcUp = context.get(x, y + 1, z).getBlock();
            if (MovementHelper.isWater(srcUp)) {
                return LADDER_UP_ONE_COST; // allow ascending pillars of water, but only if we're already in one
            }
        }
        double placeCost = 0;
        if (!ladder) {
            // we need to place a block where we started to jump on it
            placeCost = context.costOfPlacingAt(x, y, z, fromState);
            if (placeCost >= COST_INF) {
                return COST_INF;
            }
            if (fromDown.getBlock() == Blocks.AIR) {
                placeCost += 0.1; // slightly (1/200th of a second) penalize pillaring on what's currently air
            }
        }
        if (from instanceof BlockLiquid || (fromDown.getBlock() instanceof BlockLiquid && context.assumeWalkOnWater)) {
            // otherwise, if we're standing in water, we cannot pillar
            // if we're standing on water and assumeWalkOnWater is true, we cannot pillar
            // if we're standing on water and assumeWalkOnWater is false, we must have ascended to here, or sneak backplaced, so it is possible to pillar again
            return COST_INF;
        }
        double hardness = MovementHelper.getMiningDurationTicks(context, x, y + 2, z, toBreak, true);
        if (hardness >= COST_INF) {
            return COST_INF;
        }
        if (hardness != 0) {
            if (toBreakBlock == Blocks.LADDER || toBreakBlock == Blocks.VINE) {
                hardness = 0; // we won't actually need to break the ladder / vine because we're going to use it
            } else {
                IBlockState check = context.get(x, y + 3, z); // the block on top of the one we're going to break, could it fall on us?
                if (check.getBlock() instanceof BlockFalling) {
                    // see MovementAscend's identical check for breaking a falling block above our head
                    if (srcUp == null) {
                        srcUp = context.get(x, y + 1, z).getBlock();
                    }
                    if (!(toBreakBlock instanceof BlockFalling) || !(srcUp instanceof BlockFalling)) {
                        return COST_INF;
                    }
                }
                // this is commented because it may have had a purpose, but it's very unclear what it was. it's from the minebot era.
                //if (!MovementHelper.canWalkOn(chkPos, check) || MovementHelper.canWalkThrough(chkPos, check)) {//if the block above where we want to break is not a full block, don't do it
                // TODO why does canWalkThrough mean this action is COST_INF?
                // BlockFalling makes sense, and !canWalkOn deals with weird cases like if it were lava
                // but I don't understand why canWalkThrough makes it impossible
                //    return COST_INF;
                //}
            }
        }
        if (ladder) {
            return LADDER_UP_ONE_COST + hardness * 5;
        } else {
            return JUMP_ONE_BLOCK_COST + placeCost + context.jumpPenalty + hardness;
        }
    }

    public static boolean hasAgainst(CalculationContext context, int x, int y, int z) {
        return context.get(x + 1, y, z).isBlockNormalCube() ||
                context.get(x - 1, y, z).isBlockNormalCube() ||
                context.get(x, y, z + 1).isBlockNormalCube() ||
                context.get(x, y, z - 1).isBlockNormalCube();
    }

    public static BlockPos getAgainst(CalculationContext context, BetterBlockPos vine) {
        if (context.get(vine.north()).isBlockNormalCube()) {
            return vine.north();
        }
        if (context.get(vine.south()).isBlockNormalCube()) {
            return vine.south();
        }
        if (context.get(vine.east()).isBlockNormalCube()) {
            return vine.east();
        }
        if (context.get(vine.west()).isBlockNormalCube()) {
            return vine.west();
        }
        return null;
    }

    @Override
    public MovementState updateState(MovementState state) {
        super.updateState(state);
        if (state.getStatus() != MovementStatus.RUNNING) {
            return state;
        }

        if (ctx.playerFeet().y < src.y) {
            return state.setStatus(MovementStatus.UNREACHABLE);
        }

        IBlockState fromDown = BlockStateInterface.get(ctx, src);
        if (MovementHelper.isWater(fromDown.getBlock()) && MovementHelper.isWater(ctx, dest)) {
            // stay centered while swimming up a water column
            state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest), ctx.playerRotations()), false));
            Vec3d destCenter = VecUtils.getBlockPosCenter(dest);
            if (Math.abs(ctx.player().posX - destCenter.x) > 0.2 || Math.abs(ctx.player().posZ - destCenter.z) > 0.2) {
                state.setInput(Input.MOVE_FORWARD, true);
            }
            if (ctx.playerFeet().equals(dest)) {
                return state.setStatus(MovementStatus.SUCCESS);
            }
            return state;
        }
        boolean ladder = fromDown.getBlock() == Blocks.LADDER || fromDown.getBlock() == Blocks.VINE;
        boolean vine = fromDown.getBlock() == Blocks.VINE;
        Rotation rotation = RotationUtils.calcRotationFromVec3d(ctx.playerHead(),
                VecUtils.getBlockPosCenter(positionToPlace),
                new Rotation(ctx.player().rotationYaw, ctx.player().rotationPitch));
        if (!ladder) {
            state.setTarget(new MovementState.MovementTarget(new Rotation(ctx.player().rotationYaw, rotation.getPitch()), true));
        }

        boolean blockIsThere = MovementHelper.canWalkOn(ctx, src) || ladder;
        if (ladder) {
            BlockPos against = vine ? getAgainst(new CalculationContext(baritone), src) : src.offset(fromDown.getValue(BlockLadder.FACING).getOpposite());
            if (against == null) {
                logDirect(""Unable to climb vines. Consider disabling allowVines."");
                return state.setStatus(MovementStatus.UNREACHABLE);
            }

            if (ctx.playerFeet().equals(against.up()) || ctx.playerFeet().equals(dest)) {
                return state.setStatus(MovementStatus.SUCCESS);
            }
            if (MovementHelper.isBottomSlab(BlockStateInterface.get(ctx, src.down()))) {
                state.setInput(Input.JUMP, true);
            }
            /*
            if (thePlayer.getPosition0().getX() != from.getX() || thePlayer.getPosition0().getZ() != from.getZ()) {
                Baritone.moveTowardsBlock(from);
            }
             */

            MovementHelper.moveTowards(ctx, state, against);
            return state;
        } else {
            // Get ready to place a throwaway block
            if (!((Baritone) baritone).getInventoryBehavior().selectThrowawayForLocation(true, src.x, src.y, src.z)) {
                return state.setStatus(MovementStatus.UNREACHABLE);
            }


            state.setInput(Input.SNEAK, ctx.player().posY > dest.getY() || ctx.player().posY < src.getY() + 0.2D); // delay placement by 1 tick for ncp compatibility
            // since (lower down) we only right click once player.isSneaking, and that happens the tick after we request to sneak

            double diffX = ctx.player().posX - (dest.getX() + 0.5);
            double diffZ = ctx.player().posZ - (dest.getZ() + 0.5);
            double dist = Math.sqrt(diffX * diffX + diffZ * diffZ);
            double flatMotion = Math.sqrt(ctx.player().motionX * ctx.player().motionX + ctx.player().motionZ * ctx.player().motionZ);
            if (dist > 0.17) {//why 0.17? because it seemed like a good number, that's why
                //[explanation added after baritone port lol] also because it needs to be less than 0.2 because of the 0.3 sneak limit
                //and 0.17 is reasonably less than 0.2

                // If it's been more than forty ticks of trying to jump and we aren't done yet, go forward, maybe we are stuck
                state.setInput(Input.MOVE_FORWARD, true);

                // revise our target to both yaw and pitch if we're going to be moving forward
                state.setTarget(new MovementState.MovementTarget(rotation, true));
            } else if (flatMotion < 0.05) {
                // If our Y coordinate is above our goal, stop jumping
                state.setInput(Input.JUMP, ctx.player().posY < dest.getY());
            }


            if (!blockIsThere) {
                IBlockState frState = BlockStateInterface.get(ctx, src);
                Block fr = frState.getBlock();
                // TODO: Evaluate usage of getMaterial().isReplaceable()
                if (!(fr instanceof BlockAir || frState.getMaterial().isReplaceable())) {
                    RotationUtils.reachable(ctx.player(), src, ctx.playerController().getBlockReachDistance())
                            .map(rot -> new MovementState.MovementTarget(rot, true))
                            .ifPresent(state::setTarget);
                    state.setInput(Input.JUMP, false); // breaking is like 5x slower when you're jumping
                    state.setInput(Input.CLICK_LEFT, true);
                    blockIsThere = false;
                } else if (ctx.player().isSneaking() && (Objects.equals(src.down(), ctx.objectMouseOver().getBlockPos()) || Objects.equals(src, ctx.objectMouseOver().getBlockPos())) && ctx.player().posY > dest.getY() + 0.1) {
                    state.setInput(Input.CLICK_RIGHT, true);
                }
            }
        }

        // If we are at our goal and the block below us is placed
        if (ctx.playerFeet().equals(dest) && blockIsThere) {
            return state.setStatus(MovementStatus.SUCCESS);
        }

        return state;
    }

    @Override
    protected boolean prepared(MovementState state) {
        if (ctx.playerFeet().equals(src) || ctx.playerFeet().equals(src.down())) {
            Block block = BlockStateInterface.getBlock(ctx, src.down());
            if (block == Blocks.LADDER || block == Blocks.VINE) {
                state.setInput(Input.SNEAK, true);
            }
        }
        if (MovementHelper.isWater(ctx, dest.up())) {
            return true;
        }
        return super.prepared(state);
    }
}",1,777 587 2000 650 2001 123 777 2000 40 2002 2003 44 2004 2005 44 2004 2006 41 123 818 40 2003 44 2005 44 2006 44 744 2004 91 93 123 2005 46 2007 40 1502 41 125 44 2005 41 59 125 64 2008 777 625 2009 40 2010 2011 41 123 792 2012 40 2011 44 2013 46 2014 44 2013 46 2015 44 2013 46 2016 41 59 125 64 2008 775 2017 60 2004 62 2018 40 41 123 792 2019 46 2020 40 2021 44 2022 41 59 125 777 809 625 2023 40 2010 2011 44 704 2024 44 704 2025 44 704 2026 41 123 2027 2028 61 2011 46 2029 40 2024 44 2025 44 2026 41 59 2030 2031 61 2028 46 2032 40 41 59 570 2033 61 2031 323 2034 46 2035 309 2031 323 2034 46 2036 59 2027 2037 61 2011 46 2029 40 2024 44 2025 45 1501 44 2026 41 59 688 40 33 2033 41 123 688 40 2037 46 2032 40 41 323 2034 46 2035 309 2037 46 2032 40 41 323 2034 46 2036 41 123 792 2038 59 330 125 688 40 2037 46 2032 40 41 702 2039 307 33 40 40 2039 41 2037 46 2032 40 41 41 46 2040 40 41 307 2037 46 2041 40 2039 46 2042 41 323 2039 46 2043 46 2044 41 123 792 2045 59 330 125 125 688 40 2031 323 2034 46 2036 307 33 2046 40 2011 44 2024 44 2025 44 2026 41 41 123 330 792 2047 59 125 2027 2048 61 2011 46 2029 40 2024 44 2025 43 1502 44 2026 41 59 2030 2049 61 2048 46 2032 40 41 59 688 40 2049 702 2050 41 123 330 792 2051 59 125 2030 2052 61 2053 59 688 40 2054 46 2055 40 2049 41 307 2054 46 2055 40 2031 41 41 123 330 2052 61 2011 46 2029 40 2024 44 2025 43 1501 44 2026 41 46 2032 40 41 59 688 40 2054 46 2055 40 2052 41 41 123 792 2056 59 330 125 125 625 2057 61 1500 59 688 40 33 2033 41 123 330 2057 61 2011 46 2058 40 2024 44 2025 44 2026 44 2028 41 59 688 40 2057 325 2059 41 123 792 2059 59 125 688 40 2037 46 2032 40 41 323 2034 46 2060 41 123 2057 348 1500 59 330 125 125 688 40 2031 702 2061 309 40 2037 46 2032 40 41 702 2061 307 2011 46 2062 41 41 123 330 330 330 792 2063 59 125 625 2064 61 2054 46 2065 40 2011 44 2024 44 2025 43 1502 44 2026 44 2048 44 2066 41 59 688 40 2064 325 2067 41 123 792 2067 59 125 688 40 2064 340 1500 41 123 688 40 2049 323 2034 46 2035 309 2049 323 2034 46 2036 41 123 2064 61 1500 59 330 125 630 123 2027 2068 61 2011 46 2029 40 2024 44 2025 43 1502 44 2026 41 59 330 688 40 2068 46 2032 40 41 702 2069 41 123 330 688 40 2052 323 2053 41 123 2052 61 2011 46 2029 40 2024 44 2025 43 1501 44 2026 41 46 2032 40 41 59 125 688 40 33 40 2049 702 2069 41 309 33 40 2052 702 2069 41 41 123 792 2067 59 125 125 330 330 330 330 330 330 330 125 125 688 40 2033 41 123 792 2070 43 2064 42 1502 59 125 630 123 792 2071 43 2057 43 2011 46 2072 43 2064 59 125 125 777 809 570 2073 40 2010 2011 44 704 2024 44 704 2025 44 704 2026 41 123 792 2011 46 2074 40 2024 43 1501 44 2025 44 2026 41 46 2075 40 41 309 2011 46 2074 40 2024 45 1501 44 2025 44 2026 41 46 2075 40 41 309 2011 46 2074 40 2024 44 2025 44 2026 43 1501 41 46 2075 40 41 309 2011 46 2074 40 2024 44 2025 44 2026 45 1501 41 46 2075 40 41 59 125 777 809 2076 2077 40 2010 2011 44 2004 2078 41 123 688 40 2011 46 2079 40 2078 46 2080 40 41 41 46 2081 40 41 41 123 792 2078 46 2080 40 41 59 125 688 40 2011 46 2079 40 2078 46 2082 40 41 41 46 2081 40 41 41 123 792 2078 46 2082 40 41 59 125 688 40 2011 46 2079 40 2078 46 2083 40 41 41 46 2081 40 41 41 123 792 2078 46 2083 40 41 59 125 688 40 2011 46 2079 40 2078 46 2084 40 41 41 46 2081 40 41 41 123 792 2078 46 2084 40 41 59 125 792 2085 59 125 64 2008 777 2086 2087 40 2086 2088 41 123 818 46 2087 40 2088 41 59 688 40 2088 46 2089 40 41 340 2090 46 2091 41 123 792 2088 59 125 688 40 2092 46 2093 40 41 46 2025 60 2094 46 2025 41 123 792 2088 46 2095 40 2090 46 2096 41 59 125 2097 2098 61 2099 46 2100 40 2092 44 2094 41 59 688 40 2101 46 2102 40 2098 46 2103 40 41 41 307 2101 46 2102 40 2092 44 2104 41 41 123 330 2088 46 2105 40 744 2086 46 2106 40 2107 46 2108 40 2092 46 2109 40 41 44 2110 46 2111 40 2104 41 44 2092 46 2112 40 41 41 44 2113 41 41 59 2114 2115 61 2110 46 2111 40 2104 41 59 688 40 2116 46 2117 40 2092 46 2118 40 41 46 2119 45 2115 46 2024 41 62 1500 309 2116 46 2117 40 2092 46 2118 40 41 46 2120 45 2115 46 2026 41 62 1500 41 123 2088 46 2121 40 2122 46 2123 44 2124 41 59 125 688 40 2092 46 2093 40 41 46 2125 40 2104 41 41 123 792 2088 46 2126 40 2090 46 2127 41 59 125 792 2088 59 125 570 2128 61 2098 46 2103 40 41 323 2129 46 2130 309 2098 46 2103 40 41 323 2129 46 2131 59 570 2078 61 2098 46 2103 40 41 323 2129 46 2131 59 2132 2133 61 2134 46 2135 40 2092 46 2136 40 41 44 2137 46 2138 40 2139 41 44 744 2132 40 2092 46 2140 40 41 46 2141 44 2092 46 2140 40 41 46 2142 41 41 59 688 40 33 2128 41 123 2088 46 2143 40 744 2086 46 2144 40 744 2132 40 2092 46 2140 40 41 46 2141 44 2133 46 2145 40 41 41 44 2146 41 41 59 125 570 2147 61 2101 46 2148 40 2092 44 2094 41 309 2128 59 688 40 2128 41 123 2076 2149 61 2078 63 2077 40 744 2010 40 2003 41 44 2094 41 58 2094 46 2150 40 2098 46 2151 40 2152 46 2153 41 46 2154 40 41 41 59 688 40 2149 323 2155 41 123 2156 40 362 41 59 792 2088 46 2157 40 2090 46 2158 41 59 125 688 40 2092 46 2093 40 41 46 2159 40 2149 46 2160 40 41 41 309 2092 46 2093 40 41 46 2159 40 2104 41 41 123 792 2088 46 2161 40 2090 46 2162 41 59 125 688 40 2101 46 2163 40 2099 46 2100 40 2092 44 2094 46 2164 40 41 41 41 41 123 2088 46 2165 40 2166 46 2167 44 2168 41 59 125 305 2101 46 2169 40 2092 44 2088 44 2149 41 59 792 2088 59 125 630 123 330 688 40 33 40 40 2170 41 2003 41 46 2171 40 41 46 2172 40 2173 44 2094 46 2024 44 2094 46 2025 44 2094 46 2026 41 41 123 792 2088 46 2174 40 2090 46 2175 41 59 125 2088 46 2176 40 2177 46 2178 44 2092 46 2140 40 41 46 2179 62 2104 46 2180 40 41 309 2092 46 2140 40 41 46 2179 60 2094 46 2180 40 41 43 1500 41 59 330 330 625 2181 61 2092 46 2140 40 41 46 2182 45 40 2104 46 2183 40 41 43 1500 41 59 625 2184 61 2092 46 2140 40 41 46 2185 45 40 2104 46 2186 40 41 43 1500 41 59 625 2187 61 2188 46 2189 40 2181 42 2181 43 2184 42 2184 41 59 625 2190 61 2188 46 2189 40 2092 46 2140 40 41 46 2191 42 2092 46 2140 40 41 46 2191 43 2092 46 2140 40 41 46 2192 42 2092 46 2140 40 41 46 2192 41 59 688 40 2187 62 1500 41 123 330 330 330 330 2088 46 2176 40 2177 46 2193 44 2173 41 59 330 2088 46 2194 40 744 2086 46 2195 40 2133 44 2173 41 41 59 125 630 688 40 2190 60 1500 41 123 330 2088 46 2176 40 2177 46 2196 44 2092 46 2140 40 41 46 2179 60 2104 46 2180 40 41 41 59 125 688 40 33 2147 41 123 2097 2197 61 2099 46 2100 40 2092 44 2094 41 59 2198 2199 61 2197 46 2103 40 41 59 330 688 40 33 40 2199 702 2200 309 2197 46 2201 40 41 46 2202 40 41 41 41 123 2134 46 2203 40 2092 46 2140 40 41 44 2094 44 2092 46 2204 40 41 46 2205 40 41 41 46 2206 40 2207 45 62 744 2086 46 2208 40 2207 44 2173 41 41 46 2209 40 2088 58 58 2210 41 59 2088 46 2176 40 2177 46 2211 44 2212 41 59 330 2088 46 2176 40 2177 46 2213 44 2173 41 59 2147 61 2212 59 125 630 688 40 2092 46 2140 40 41 46 2214 40 41 307 40 2215 46 2216 40 2094 46 2217 40 41 44 2092 46 2218 40 41 46 2219 40 41 41 309 2215 46 2216 40 2094 44 2092 46 2218 40 41 46 2219 40 41 41 41 307 2092 46 2140 40 41 46 2179 62 2104 46 2180 40 41 43 1500 41 123 2088 46 2176 40 2177 46 2220 44 2173 41 59 125 125 125 330 688 40 2092 46 2093 40 41 46 2221 40 2104 41 307 2147 41 123 792 2088 46 2222 40 2090 46 2223 41 59 125 792 2088 59 125 64 2008 775 570 2224 40 2086 2088 41 123 688 40 2225 46 2226 40 41 46 2227 40 2228 41 309 2225 46 2226 40 41 46 2227 40 2228 46 2229 40 41 41 41 123 2230 2231 61 2232 46 2233 40 2225 44 2228 46 2229 40 41 41 59 688 40 2231 323 2234 46 2235 309 2231 323 2234 46 2236 41 123 2088 46 2237 40 2238 46 2239 44 2240 41 59 125 125 688 40 2241 46 2242 40 2225 44 2243 46 2244 40 41 41 41 123 792 2245 59 125 792 818 46 2224 40 2088 41 59 125 125 ,"{'AvgLine': 28, 'CountLine': 241, 'CountStmt': 129, 'MaxNesting': 4, 'AvgLineCode': 23, 'AvgEssential': 4, 'AvgLineBlank': 1, 'CountStmtExe': 117, 'MaxEssential': 17, 'SumEssential': 38, 'AvgCyclomatic': 6, 'CountLineCode': 192, 'CountStmtDecl': 33, 'MaxCyclomatic': 19, 'SumCyclomatic': 52, 'AvgLineComment': 4, 'CountClassBase': 1, 'CountLineBlank': 22, 'CountSemicolon': 78, 'CountDeclMethod': 8, 'CountLineCodeExe': 130, 'CountLineComment': 39, 'CountClassCoupled': 29, 'CountClassDerived': 0, 'CountLineCodeDecl': 38, 'CountDeclMethodAll': 34, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.20', 'AvgCyclomaticStrict': 9, 'MaxCyclomaticStrict': 30, 'SumCyclomaticStrict': 78, 'CountDeclClassMethod': 3, 'AvgCyclomaticModified': 6, 'CountDeclMethodPublic': 6, 'MaxCyclomaticModified': 19, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 52, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 2, 'CountClassCoupledModified': 29, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
3555,Java,"@Slf4j
public class TradeDataValidation {

    public static void validateDonationAddress(String addressAsString, DaoFacade daoFacade)
            throws AddressException {
        validateDonationAddress(null, addressAsString, daoFacade);
    }

    public static void validateNodeAddress(Dispute dispute, NodeAddress nodeAddress, Config config)
            throws NodeAddressException {
        if (!config.useLocalhostForP2P && !RegexValidatorFactory.onionAddressRegexValidator().validate(nodeAddress.getFullAddress()).isValid) {
            String msg = ""Node address "" + nodeAddress.getFullAddress() + "" at dispute with trade ID "" +
                    dispute.getShortTradeId() + "" is not a valid address"";
            log.error(msg);
            throw new NodeAddressException(dispute, msg);
        }
    }

    public static void validateDonationAddress(@Nullable Dispute dispute, String addressAsString, DaoFacade daoFacade)
            throws AddressException {

        if (addressAsString == null) {
            log.debug(""address is null at validateDonationAddress. This is expected in case of an not updated trader."");
            return;
        }

        Set<String> allPastParamValues = daoFacade.getAllDonationAddresses();
        if (!allPastParamValues.contains(addressAsString)) {
            String errorMsg = ""Donation address is not a valid DAO donation address."" +
                    ""\nAddress used in the dispute: "" + addressAsString +
                    ""\nAll DAO param donation addresses:"" + allPastParamValues;
            log.error(errorMsg);
            throw new AddressException(dispute, errorMsg);
        }
    }

    public static void testIfAnyDisputeTriedReplay(List<Dispute> disputeList,
                                                   Consumer<DisputeReplayException> exceptionHandler) {
        var tuple = getTestReplayHashMaps(disputeList);
        Map<String, Set<String>> disputesPerTradeId = tuple.first;
        Map<String, Set<String>> disputesPerDelayedPayoutTxId = tuple.second;
        Map<String, Set<String>> disputesPerDepositTxId = tuple.third;

        disputeList.forEach(disputeToTest -> {
            try {
                testIfDisputeTriesReplay(disputeToTest,
                        disputesPerTradeId,
                        disputesPerDelayedPayoutTxId,
                        disputesPerDepositTxId);

            } catch (DisputeReplayException e) {
                exceptionHandler.accept(e);
            }
        });
    }


    public static void testIfDisputeTriesReplay(Dispute dispute,
                                                List<Dispute> disputeList) throws DisputeReplayException {
        var tuple = TradeDataValidation.getTestReplayHashMaps(disputeList);
        Map<String, Set<String>> disputesPerTradeId = tuple.first;
        Map<String, Set<String>> disputesPerDelayedPayoutTxId = tuple.second;
        Map<String, Set<String>> disputesPerDepositTxId = tuple.third;

        testIfDisputeTriesReplay(dispute,
                disputesPerTradeId,
                disputesPerDelayedPayoutTxId,
                disputesPerDepositTxId);
    }


    private static Tuple3<Map<String, Set<String>>, Map<String, Set<String>>, Map<String, Set<String>>> getTestReplayHashMaps(
            List<Dispute> disputeList) {
        Map<String, Set<String>> disputesPerTradeId = new HashMap<>();
        Map<String, Set<String>> disputesPerDelayedPayoutTxId = new HashMap<>();
        Map<String, Set<String>> disputesPerDepositTxId = new HashMap<>();
        disputeList.forEach(dispute -> {
            String uid = dispute.getUid();

            String tradeId = dispute.getTradeId();
            disputesPerTradeId.putIfAbsent(tradeId, new HashSet<>());
            Set<String> set = disputesPerTradeId.get(tradeId);
            set.add(uid);

            String delayedPayoutTxId = dispute.getDelayedPayoutTxId();
            if (delayedPayoutTxId != null) {
                disputesPerDelayedPayoutTxId.putIfAbsent(delayedPayoutTxId, new HashSet<>());
                set = disputesPerDelayedPayoutTxId.get(delayedPayoutTxId);
                set.add(uid);
            }

            String depositTxId = dispute.getDepositTxId();
            if (depositTxId != null) {
                disputesPerDepositTxId.putIfAbsent(depositTxId, new HashSet<>());
                set = disputesPerDepositTxId.get(depositTxId);
                set.add(uid);
            }
        });

        return new Tuple3<>(disputesPerTradeId, disputesPerDelayedPayoutTxId, disputesPerDepositTxId);
    }

    private static void testIfDisputeTriesReplay(Dispute disputeToTest,
                                                 Map<String, Set<String>> disputesPerTradeId,
                                                 Map<String, Set<String>> disputesPerDelayedPayoutTxId,
                                                 Map<String, Set<String>> disputesPerDepositTxId)
            throws DisputeReplayException {

        try {
            String disputeToTestTradeId = disputeToTest.getTradeId();
            String disputeToTestDelayedPayoutTxId = disputeToTest.getDelayedPayoutTxId();
            String disputeToTestDepositTxId = disputeToTest.getDepositTxId();
            String disputeToTestUid = disputeToTest.getUid();

            // For pre v1.4.0 we do not get the delayed payout tx sent in mediation cases but in refund agent case we do.
            // So until all users have updated to 1.4.0 we only check in refund agent case. With 1.4.0 we send the
            // delayed payout tx also in mediation cases and that if check can be removed.
            if (disputeToTest.getSupportType() == SupportType.REFUND) {
                checkNotNull(disputeToTestDelayedPayoutTxId,
                        ""Delayed payout transaction ID is null. "" +
                                ""Trade ID: "" + disputeToTestTradeId);
            }
            checkNotNull(disputeToTestDepositTxId,
                    ""depositTxId must not be null. Trade ID: "" + disputeToTestTradeId);
            checkNotNull(disputeToTestUid,
                    ""agentsUid must not be null. Trade ID: "" + disputeToTestTradeId);

            Set<String> disputesPerTradeIdItems = disputesPerTradeId.get(disputeToTestTradeId);
            checkArgument(disputesPerTradeIdItems != null && disputesPerTradeIdItems.size() <= 2,
                    ""We found more then 2 disputes with the same trade ID. "" +
                            ""Trade ID: "" + disputeToTestTradeId);
            if (!disputesPerDelayedPayoutTxId.isEmpty()) {
                Set<String> disputesPerDelayedPayoutTxIdItems = disputesPerDelayedPayoutTxId.get(disputeToTestDelayedPayoutTxId);
                checkArgument(disputesPerDelayedPayoutTxIdItems != null && disputesPerDelayedPayoutTxIdItems.size() <= 2,
                        ""We found more then 2 disputes with the same delayedPayoutTxId. "" +
                                ""Trade ID: "" + disputeToTestTradeId);
            }
            if (!disputesPerDepositTxId.isEmpty()) {
                Set<String> disputesPerDepositTxIdItems = disputesPerDepositTxId.get(disputeToTestDepositTxId);
                checkArgument(disputesPerDepositTxIdItems != null && disputesPerDepositTxIdItems.size() <= 2,
                        ""We found more then 2 disputes with the same depositTxId. "" +
                                ""Trade ID: "" + disputeToTestTradeId);
            }
        } catch (IllegalArgumentException e) {
            throw new DisputeReplayException(disputeToTest, e.getMessage());
        } catch (NullPointerException e) {
            log.error(""NullPointerException at testIfDisputeTriesReplay: "" +
                            ""disputeToTest={}, disputesPerTradeId={}, disputesPerDelayedPayoutTxId={}, "" +
                            ""disputesPerDepositTxId={}"",
                    disputeToTest, disputesPerTradeId, disputesPerDelayedPayoutTxId, disputesPerDepositTxId);
            throw new DisputeReplayException(disputeToTest, e.toString() + "" at dispute "" + disputeToTest.toString());
        }
    }

    public static void validateDelayedPayoutTx(Trade trade,
                                               Transaction delayedPayoutTx,
                                               DaoFacade daoFacade,
                                               BtcWalletService btcWalletService)
            throws AddressException, MissingTxException,
            InvalidTxException, InvalidLockTimeException, InvalidAmountException {
        validateDelayedPayoutTx(trade,
                delayedPayoutTx,
                null,
                daoFacade,
                btcWalletService,
                null);
    }

    public static void validateDelayedPayoutTx(Trade trade,
                                               Transaction delayedPayoutTx,
                                               @Nullable Dispute dispute,
                                               DaoFacade daoFacade,
                                               BtcWalletService btcWalletService)
            throws AddressException, MissingTxException,
            InvalidTxException, InvalidLockTimeException, InvalidAmountException {
        validateDelayedPayoutTx(trade,
                delayedPayoutTx,
                dispute,
                daoFacade,
                btcWalletService,
                null);
    }

    public static void validateDelayedPayoutTx(Trade trade,
                                               Transaction delayedPayoutTx,
                                               DaoFacade daoFacade,
                                               BtcWalletService btcWalletService,
                                               @Nullable Consumer<String> addressConsumer)
            throws AddressException, MissingTxException,
            InvalidTxException, InvalidLockTimeException, InvalidAmountException {
        validateDelayedPayoutTx(trade,
                delayedPayoutTx,
                null,
                daoFacade,
                btcWalletService,
                addressConsumer);
    }

    public static void validateDelayedPayoutTx(Trade trade,
                                               Transaction delayedPayoutTx,
                                               @Nullable Dispute dispute,
                                               DaoFacade daoFacade,
                                               BtcWalletService btcWalletService,
                                               @Nullable Consumer<String> addressConsumer)
            throws AddressException, MissingTxException,
            InvalidTxException, InvalidLockTimeException, InvalidAmountException {
        String errorMsg;
        if (delayedPayoutTx == null) {
            errorMsg = ""DelayedPayoutTx must not be null"";
            log.error(errorMsg);
            throw new MissingTxException(""DelayedPayoutTx must not be null"");
        }

        // Validate tx structure
        if (delayedPayoutTx.getInputs().size() != 1) {
            errorMsg = ""Number of delayedPayoutTx inputs must be 1"";
            log.error(errorMsg);
            log.error(delayedPayoutTx.toString());
            throw new InvalidTxException(errorMsg);
        }

        if (delayedPayoutTx.getOutputs().size() != 1) {
            errorMsg = ""Number of delayedPayoutTx outputs must be 1"";
            log.error(errorMsg);
            log.error(delayedPayoutTx.toString());
            throw new InvalidTxException(errorMsg);
        }

        // connectedOutput is null and input.getValue() is null at that point as the tx is not committed to the wallet
        // yet. So we cannot check that the input matches but we did the amount check earlier in the trade protocol.

        // Validate lock time
        if (delayedPayoutTx.getLockTime() != trade.getLockTime()) {
            errorMsg = ""delayedPayoutTx.getLockTime() must match trade.getLockTime()"";
            log.error(errorMsg);
            log.error(delayedPayoutTx.toString());
            throw new InvalidLockTimeException(errorMsg);
        }

        // Validate seq num
        if (delayedPayoutTx.getInput(0).getSequenceNumber() != TransactionInput.NO_SEQUENCE - 1) {
            errorMsg = ""Sequence number must be 0xFFFFFFFE"";
            log.error(errorMsg);
            log.error(delayedPayoutTx.toString());
            throw new InvalidLockTimeException(errorMsg);
        }

        // Check amount
        TransactionOutput output = delayedPayoutTx.getOutput(0);
        Offer offer = checkNotNull(trade.getOffer());
        Coin msOutputAmount = offer.getBuyerSecurityDeposit()
                .add(offer.getSellerSecurityDeposit())
                .add(checkNotNull(trade.getAmount()));

        if (!output.getValue().equals(msOutputAmount)) {
            errorMsg = ""Output value of deposit tx and delayed payout tx is not matching. Output: "" + output + "" / msOutputAmount: "" + msOutputAmount;
            log.error(errorMsg);
            log.error(delayedPayoutTx.toString());
            throw new InvalidAmountException(errorMsg);
        }

        NetworkParameters params = btcWalletService.getParams();
        Address address = output.getScriptPubKey().getToAddress(params);
        if (address == null) {
            errorMsg = ""Donation address cannot be resolved (not of type P2PK nor P2SH nor P2WH). Output: "" + output;
            log.error(errorMsg);
            log.error(delayedPayoutTx.toString());
            throw new AddressException(dispute, errorMsg);
        }

        String addressAsString = address.toString();
        if (addressConsumer != null) {
            addressConsumer.accept(addressAsString);
        }

        validateDonationAddress(addressAsString, daoFacade);

        if (dispute != null) {
            // Verify that address in the dispute matches the one in the trade.
            String donationAddressOfDelayedPayoutTx = dispute.getDonationAddressOfDelayedPayoutTx();
            // Old clients don't have it set yet. Can be removed after a forced update
            if (donationAddressOfDelayedPayoutTx != null) {
                checkArgument(addressAsString.equals(donationAddressOfDelayedPayoutTx),
                        ""donationAddressOfDelayedPayoutTx from dispute does not match address from delayed payout tx"");
            }
        }
    }

    public static void validatePayoutTxInput(Transaction depositTx,
                                             Transaction delayedPayoutTx)
            throws InvalidInputException {
        TransactionInput input = delayedPayoutTx.getInput(0);
        checkNotNull(input, ""delayedPayoutTx.getInput(0) must not be null"");
        // input.getConnectedOutput() is null as the tx is not committed at that point

        TransactionOutPoint outpoint = input.getOutpoint();
        if (!outpoint.getHash().toString().equals(depositTx.getTxId().toString()) || outpoint.getIndex() != 0) {
            throw new InvalidInputException(""Input of delayed payout transaction does not point to output of deposit tx.\n"" +
                    ""Delayed payout tx="" + delayedPayoutTx + ""\n"" +
                    ""Deposit tx="" + depositTx);
        }
    }

    public static void validateDepositInputs(Trade trade) throws InvalidTxException {
        // assumption: deposit tx always has 2 inputs, the maker and taker
        if (trade == null || trade.getDepositTx() == null || trade.getDepositTx().getInputs().size() != 2) {
            throw new InvalidTxException(""Deposit transaction is null or has unexpected input count"");
        }
        Transaction depositTx = trade.getDepositTx();
        String txIdInput0 = depositTx.getInput(0).getOutpoint().getHash().toString();
        String txIdInput1 = depositTx.getInput(1).getOutpoint().getHash().toString();
        String contractMakerTxId = trade.getContract().getOfferPayload().getOfferFeePaymentTxId();
        String contractTakerTxId = trade.getContract().getTakerFeeTxID();
        boolean makerFirstMatch = contractMakerTxId.equalsIgnoreCase(txIdInput0) && contractTakerTxId.equalsIgnoreCase(txIdInput1);
        boolean takerFirstMatch = contractMakerTxId.equalsIgnoreCase(txIdInput1) && contractTakerTxId.equalsIgnoreCase(txIdInput0);
        if (!makerFirstMatch && !takerFirstMatch) {
            String errMsg = ""Maker/Taker txId in contract does not match deposit tx input"";
            log.error(errMsg +
                ""\nContract Maker tx="" + contractMakerTxId + "" Contract Taker tx="" + contractTakerTxId +
                ""\nDeposit Input0="" + txIdInput0 + "" Deposit Input1="" + txIdInput1);
            throw new InvalidTxException(errMsg);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Exceptions
    ///////////////////////////////////////////////////////////////////////////////////////////

    public static class ValidationException extends Exception {
        @Nullable
        @Getter
        private final Dispute dispute;

        ValidationException(String msg) {
            this(null, msg);
        }

        ValidationException(@Nullable Dispute dispute, String msg) {
            super(msg);
            this.dispute = dispute;
        }
    }

    public static class AddressException extends ValidationException {
        AddressException(@Nullable Dispute dispute, String msg) {
            super(dispute, msg);
        }
    }

    public static class MissingTxException extends ValidationException {
        MissingTxException(String msg) {
            super(msg);
        }
    }

    public static class InvalidTxException extends ValidationException {
        InvalidTxException(String msg) {
            super(msg);
        }
    }

    public static class InvalidAmountException extends ValidationException {
        InvalidAmountException(String msg) {
            super(msg);
        }
    }

    public static class InvalidLockTimeException extends ValidationException {
        InvalidLockTimeException(String msg) {
            super(msg);
        }
    }

    public static class InvalidInputException extends ValidationException {
        InvalidInputException(String msg) {
            super(msg);
        }
    }

    public static class DisputeReplayException extends ValidationException {
        DisputeReplayException(Dispute dispute, String msg) {
            super(dispute, msg);
        }
    }

    public static class NodeAddressException extends ValidationException {
        NodeAddressException(Dispute dispute, String msg) {
            super(dispute, msg);
        }
    }
}",1,64 2000 777 587 2001 123 777 809 865 2002 40 2003 2004 44 2005 2006 41 826 2007 123 2002 40 2008 44 2004 44 2006 41 59 125 777 809 865 2009 40 2010 2011 44 2012 2013 44 2014 2015 41 826 2016 123 688 40 33 2015 46 2017 307 33 2018 46 2019 40 41 46 2020 40 2013 46 2021 40 41 41 46 2022 41 123 2003 2023 61 362 43 2013 46 2021 40 41 43 362 43 2011 46 2024 40 41 43 362 59 2025 46 2026 40 2023 41 59 825 744 2016 40 2011 44 2023 41 59 125 125 777 809 865 2002 40 64 2027 2010 2011 44 2003 2004 44 2005 2006 41 826 2007 123 688 40 2004 323 2028 41 123 2029 46 2030 40 362 41 59 792 59 125 2031 60 2003 62 2032 61 2006 46 2033 40 41 59 688 40 33 2032 46 2034 40 2004 41 41 123 2003 2035 61 362 43 362 43 2004 43 362 43 2032 59 2036 46 2037 40 2035 41 59 825 744 2007 40 2011 44 2035 41 59 125 125 777 809 865 2038 40 2039 60 2010 62 2040 44 2041 60 2042 62 2043 41 123 2044 2045 61 2046 40 2040 41 59 2047 60 2003 44 2048 60 2003 356 2049 61 2045 46 2050 59 2047 60 2003 44 2048 60 2003 356 2051 61 2045 46 2052 59 2047 60 2003 44 2048 60 2003 356 2053 61 2045 46 2054 59 2040 46 2055 40 2056 45 62 123 830 123 2057 40 2056 44 2049 44 2051 44 2053 41 59 125 580 40 2042 2058 41 123 2043 46 2059 40 2058 41 59 125 125 41 59 125 777 809 865 2060 40 2010 2011 44 2039 60 2010 62 2040 41 826 2042 123 2061 2062 61 2001 46 2063 40 2040 41 59 2064 60 2003 44 2065 60 2003 356 2066 61 2062 46 2067 59 2064 60 2003 44 2065 60 2003 356 2068 61 2062 46 2069 59 2064 60 2003 44 2065 60 2003 356 2070 61 2062 46 2071 59 2060 40 2011 44 2066 44 2068 44 2070 41 59 125 773 809 2072 60 2073 60 2003 44 2074 60 2003 356 44 2073 60 2003 44 2074 60 2003 356 44 2073 60 2003 44 2074 60 2003 359 2075 40 2039 60 2010 62 2040 41 123 2073 60 2003 44 2074 60 2003 356 2076 61 744 2077 60 62 40 41 59 2073 60 2003 44 2074 60 2003 356 2078 61 744 2077 60 62 40 41 59 2073 60 2003 44 2074 60 2003 356 2079 61 744 2077 60 62 40 41 59 2040 46 2080 40 2011 45 62 123 2003 2081 61 2011 46 2082 40 41 59 2003 2083 61 2011 46 2084 40 41 59 2076 46 2085 40 2083 44 744 2086 60 62 40 41 41 59 2074 60 2003 62 2087 61 2076 46 2088 40 2083 41 59 2087 46 2089 40 2081 41 59 2003 2090 61 2011 46 2091 40 41 59 688 40 2090 340 2092 41 123 2078 46 2085 40 2090 44 744 2086 60 62 40 41 41 59 2087 61 2078 46 2088 40 2090 41 59 2087 46 2089 40 2081 41 59 125 2003 2093 61 2011 46 2094 40 41 59 688 40 2093 340 2092 41 123 2079 46 2085 40 2093 44 744 2086 60 62 40 41 41 59 2087 61 2079 46 2088 40 2093 41 59 2087 46 2089 40 2081 41 59 125 125 41 59 792 744 2072 60 62 40 2076 44 2078 44 2079 41 59 125 773 809 865 2060 40 2010 2095 44 2073 60 2003 44 2074 60 2003 356 2096 44 2073 60 2003 44 2074 60 2003 356 2097 44 2073 60 2003 44 2074 60 2003 356 2098 41 826 2042 123 830 123 2003 2099 61 2095 46 2100 40 41 59 2003 2101 61 2095 46 2102 40 41 59 2003 2103 61 2095 46 2104 40 41 59 2003 2105 61 2095 46 2106 40 41 59 330 330 330 688 40 2095 46 2107 40 41 323 2108 46 2109 41 123 2110 40 2101 44 362 43 362 43 2099 41 59 125 2111 40 2103 44 362 43 2099 41 59 2111 40 2105 44 362 43 2099 41 59 2074 60 2003 62 2112 61 2096 46 2113 40 2099 41 59 2114 40 2112 340 2115 307 2112 46 2116 40 41 329 1502 44 362 43 362 43 2099 41 59 688 40 33 2097 46 2117 40 41 41 123 2074 60 2003 62 2118 61 2097 46 2113 40 2101 41 59 2114 40 2118 340 2115 307 2118 46 2116 40 41 329 1502 44 362 43 362 43 2099 41 59 125 688 40 33 2098 46 2117 40 41 41 123 2074 60 2003 62 2119 61 2098 46 2113 40 2103 41 59 2114 40 2119 340 2115 307 2119 46 2116 40 41 329 1502 44 362 43 362 43 2099 41 59 125 125 580 40 2120 2121 41 123 825 744 2042 40 2095 44 2121 46 2122 40 41 41 59 125 580 40 2123 2121 41 123 2124 46 2125 40 362 43 362 43 362 44 2095 44 2096 44 2097 44 2098 41 59 825 744 2042 40 2095 44 2121 46 2126 40 41 43 362 43 2095 46 2126 40 41 41 59 125 125 777 809 865 2127 40 2128 2129 44 2130 2131 44 2005 2006 44 2132 2133 41 826 2007 44 2134 44 2135 44 2136 44 2137 123 2127 40 2129 44 2131 44 2138 44 2006 44 2133 44 2138 41 59 125 777 809 865 2127 40 2128 2129 44 2130 2131 44 64 2027 2010 2011 44 2005 2006 44 2132 2133 41 826 2007 44 2134 44 2135 44 2136 44 2137 123 2127 40 2129 44 2131 44 2011 44 2006 44 2133 44 2139 41 59 125 777 809 865 2127 40 2128 2129 44 2130 2131 44 2005 2006 44 2132 2133 44 64 2027 2041 60 2003 62 2140 41 826 2007 44 2134 44 2135 44 2136 44 2137 123 2127 40 2129 44 2131 44 2141 44 2006 44 2133 44 2140 41 59 125 777 809 865 2127 40 2128 2129 44 2130 2131 44 64 2027 2010 2011 44 2005 2006 44 2132 2133 44 64 2027 2041 60 2003 62 2140 41 826 2007 44 2134 44 2135 44 2136 44 2137 123 2003 2142 59 688 40 2131 323 2143 41 123 2142 61 362 59 2144 46 2145 40 2142 41 59 825 744 2134 40 362 41 59 125 330 688 40 2131 46 2146 40 41 46 2147 40 41 340 1501 41 123 2142 61 362 59 2148 46 2149 40 2142 41 59 2148 46 2149 40 2131 46 2150 40 41 41 59 825 744 2135 40 2142 41 59 125 688 40 2131 46 2151 40 41 46 2147 40 41 340 1501 41 123 2142 61 362 59 2152 46 2153 40 2142 41 59 2152 46 2153 40 2131 46 2154 40 41 41 59 825 744 2135 40 2142 41 59 125 330 330 330 688 40 2131 46 2155 40 41 340 2129 46 2155 40 41 41 123 2142 61 362 59 2156 46 2157 40 2142 41 59 2156 46 2157 40 2131 46 2158 40 41 41 59 825 744 2136 40 2142 41 59 125 330 688 40 2131 46 2159 40 1500 41 46 2160 40 41 340 2161 46 2162 45 1501 41 123 2142 61 362 59 2163 46 2164 40 2142 41 59 2163 46 2164 40 2131 46 2165 40 41 41 59 825 744 2136 40 2142 41 59 125 330 2166 2167 61 2131 46 2168 40 1500 41 59 2169 2170 61 2171 40 2129 46 2172 40 41 41 59 2173 2174 61 2170 46 2175 40 41 46 2176 40 2170 46 2177 40 41 41 46 2176 40 2171 40 2129 46 2178 40 41 41 41 59 688 40 33 2167 46 2179 40 41 46 2180 40 2174 41 41 123 2142 61 362 43 2167 43 362 43 2174 59 2181 46 2182 40 2142 41 59 2181 46 2182 40 2131 46 2183 40 41 41 59 825 744 2137 40 2142 41 59 125 2184 2185 61 2133 46 2186 40 41 59 2187 2188 61 2167 46 2189 40 41 46 2190 40 2185 41 59 688 40 2188 323 2143 41 123 2142 61 362 43 2167 59 2191 46 2192 40 2142 41 59 2191 46 2192 40 2131 46 2193 40 41 41 59 825 744 2007 40 2011 44 2142 41 59 125 2003 2004 61 2188 46 2194 40 41 59 688 40 2140 340 2143 41 123 2140 46 2195 40 2004 41 59 125 2002 40 2004 44 2006 41 59 688 40 2011 340 2143 41 123 330 2003 2196 61 2011 46 2197 40 41 59 330 688 40 2196 340 2143 41 123 2198 40 2004 46 2180 40 2196 41 44 362 41 59 125 125 125 777 809 865 2199 40 2130 2200 44 2130 2131 41 826 2201 123 2202 2203 61 2131 46 2204 40 1500 41 59 2205 40 2203 44 362 41 59 330 2206 2207 61 2203 46 2208 40 41 59 688 40 33 2207 46 2209 40 41 46 2210 40 41 46 2211 40 2200 46 2212 40 41 46 2210 40 41 41 309 2207 46 2213 40 41 340 1500 41 123 825 744 2201 40 362 43 362 43 2131 43 362 43 362 43 2200 41 59 125 125 777 809 865 2214 40 2128 2129 41 826 2135 123 330 688 40 2129 323 2215 309 2129 46 2216 40 41 323 2215 309 2129 46 2216 40 41 46 2217 40 41 46 2218 40 41 340 1502 41 123 825 744 2135 40 362 41 59 125 2130 2200 61 2129 46 2216 40 41 59 2003 2219 61 2200 46 2220 40 1500 41 46 2221 40 41 46 2222 40 41 46 2223 40 41 59 2003 2224 61 2200 46 2220 40 1501 41 46 2221 40 41 46 2222 40 41 46 2223 40 41 59 2003 2225 61 2129 46 2226 40 41 46 2227 40 41 46 2228 40 41 59 2003 2229 61 2129 46 2226 40 41 46 2230 40 41 59 570 2231 61 2225 46 2232 40 2219 41 307 2229 46 2232 40 2224 41 59 570 2233 61 2225 46 2232 40 2224 41 307 2229 46 2232 40 2219 41 59 688 40 33 2231 307 33 2233 41 123 2003 2234 61 362 59 2235 46 2236 40 2234 43 362 43 2225 43 362 43 2229 43 362 43 2219 43 362 43 2224 41 59 825 744 2135 40 2234 41 59 125 125 331 330 331 777 809 587 2237 650 2238 123 64 2027 64 2239 773 657 2010 2011 59 2237 40 2003 2240 41 123 823 40 2241 44 2240 41 59 125 2237 40 64 2027 2010 2011 44 2003 2240 41 123 818 40 2240 41 59 823 46 2011 61 2011 59 125 125 777 809 587 2007 650 2237 123 2007 40 64 2027 2010 2011 44 2003 2242 41 123 818 40 2011 44 2242 41 59 125 125 777 809 587 2134 650 2237 123 2134 40 2003 2243 41 123 818 40 2243 41 59 125 125 777 809 587 2135 650 2237 123 2135 40 2003 2244 41 123 818 40 2244 41 59 125 125 777 809 587 2137 650 2237 123 2137 40 2003 2245 41 123 818 40 2245 41 59 125 125 777 809 587 2136 650 2237 123 2136 40 2003 2246 41 123 818 40 2246 41 59 125 125 777 809 587 2201 650 2237 123 2201 40 2003 2247 41 123 818 40 2247 41 59 125 125 777 809 587 2042 650 2237 123 2042 40 2010 2011 44 2003 2248 41 123 818 40 2011 44 2248 41 59 125 125 777 809 587 2016 650 2237 123 2016 40 2010 2011 44 2003 2249 41 123 818 40 2011 44 2249 41 59 125 125 125 ,"{'AvgLine': 23, 'CountLine': 392, 'CountStmt': 180, 'MaxNesting': 2, 'AvgLineCode': 20, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 137, 'MaxEssential': 1, 'SumEssential': 15, 'AvgCyclomatic': 2, 'CountLineCode': 324, 'CountStmtDecl': 78, 'MaxCyclomatic': 11, 'SumCyclomatic': 39, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 52, 'CountSemicolon': 124, 'CountDeclMethod': 13, 'CountLineCodeExe': 194, 'CountLineComment': 16, 'CountClassCoupled': 34, 'CountClassDerived': 0, 'CountLineCodeDecl': 120, 'CountDeclMethodAll': 13, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.05', 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 11, 'SumCyclomaticStrict': 49, 'CountDeclClassMethod': 13, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 11, 'MaxCyclomaticModified': 11, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 39, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 0, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 34, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
2798,Java,"@Slf4j
public abstract class Trade extends TradeModel {

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Enums
    ///////////////////////////////////////////////////////////////////////////////////////////

    public enum State implements TradeState {
        // #################### Phase PREPARATION
        // When trade protocol starts no funds are on stake
        PREPARATION(Phase.INIT),

        // At first part maker/taker have different roles
        // taker perspective
        // #################### Phase TAKER_FEE_PUBLISHED
        TAKER_PUBLISHED_TAKER_FEE_TX(Phase.TAKER_FEE_PUBLISHED),

        // PUBLISH_DEPOSIT_TX_REQUEST
        // maker perspective
        MAKER_SENT_PUBLISH_DEPOSIT_TX_REQUEST(Phase.TAKER_FEE_PUBLISHED),
        MAKER_SAW_ARRIVED_PUBLISH_DEPOSIT_TX_REQUEST(Phase.TAKER_FEE_PUBLISHED),
        MAKER_STORED_IN_MAILBOX_PUBLISH_DEPOSIT_TX_REQUEST(Phase.TAKER_FEE_PUBLISHED), //not a mailbox msg, not used...
        MAKER_SEND_FAILED_PUBLISH_DEPOSIT_TX_REQUEST(Phase.TAKER_FEE_PUBLISHED),

        // taker perspective
        TAKER_RECEIVED_PUBLISH_DEPOSIT_TX_REQUEST(Phase.TAKER_FEE_PUBLISHED), // Not used anymore


        // #################### Phase DEPOSIT_PUBLISHED
        // We changes order in trade protocol of publishing deposit tx and sending it to the peer.
        // Now we send it first to the peer and only if that succeeds we publish it to avoid likelihood of
        // failed trades. We do not want to change the order of the enum though so we keep it here as it was originally.
        SELLER_PUBLISHED_DEPOSIT_TX(Phase.DEPOSIT_PUBLISHED),


        // DEPOSIT_TX_PUBLISHED_MSG
        // seller perspective
        @Deprecated SELLER_SENT_DEPOSIT_TX_PUBLISHED_MSG(Phase.DEPOSIT_PUBLISHED),
        @Deprecated SELLER_SAW_ARRIVED_DEPOSIT_TX_PUBLISHED_MSG(Phase.DEPOSIT_PUBLISHED),
        @Deprecated SELLER_STORED_IN_MAILBOX_DEPOSIT_TX_PUBLISHED_MSG(Phase.DEPOSIT_PUBLISHED),
        @Deprecated SELLER_SEND_FAILED_DEPOSIT_TX_PUBLISHED_MSG(Phase.DEPOSIT_PUBLISHED),

        // buyer perspective
        BUYER_RECEIVED_DEPOSIT_TX_PUBLISHED_MSG(Phase.DEPOSIT_PUBLISHED),

        // Alternatively the buyer could have seen the deposit tx earlier before he received the DEPOSIT_TX_PUBLISHED_MSG
        BUYER_SAW_DEPOSIT_TX_IN_NETWORK(Phase.DEPOSIT_PUBLISHED),


        // #################### Phase DEPOSIT_CONFIRMED
        DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN(Phase.DEPOSIT_CONFIRMED),


        // #################### Phase FIAT_SENT
        BUYER_CONFIRMED_IN_UI_FIAT_PAYMENT_INITIATED(Phase.FIAT_SENT),
        BUYER_SENT_FIAT_PAYMENT_INITIATED_MSG(Phase.FIAT_SENT),
        BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG(Phase.FIAT_SENT),
        BUYER_STORED_IN_MAILBOX_FIAT_PAYMENT_INITIATED_MSG(Phase.FIAT_SENT),
        BUYER_SEND_FAILED_FIAT_PAYMENT_INITIATED_MSG(Phase.FIAT_SENT),

        SELLER_RECEIVED_FIAT_PAYMENT_INITIATED_MSG(Phase.FIAT_SENT),

        // #################### Phase FIAT_RECEIVED
        // note that this state can also be triggered by auto confirmation feature
        SELLER_CONFIRMED_IN_UI_FIAT_PAYMENT_RECEIPT(Phase.FIAT_RECEIVED),

        // #################### Phase PAYOUT_PUBLISHED
        SELLER_PUBLISHED_PAYOUT_TX(Phase.PAYOUT_PUBLISHED),

        SELLER_SENT_PAYOUT_TX_PUBLISHED_MSG(Phase.PAYOUT_PUBLISHED),
        SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG(Phase.PAYOUT_PUBLISHED),
        SELLER_STORED_IN_MAILBOX_PAYOUT_TX_PUBLISHED_MSG(Phase.PAYOUT_PUBLISHED),
        SELLER_SEND_FAILED_PAYOUT_TX_PUBLISHED_MSG(Phase.PAYOUT_PUBLISHED),

        BUYER_RECEIVED_PAYOUT_TX_PUBLISHED_MSG(Phase.PAYOUT_PUBLISHED),
        // Alternatively the maker could have seen the payout tx earlier before he received the PAYOUT_TX_PUBLISHED_MSG
        BUYER_SAW_PAYOUT_TX_IN_NETWORK(Phase.PAYOUT_PUBLISHED),

        // #################### Phase WITHDRAWN
        WITHDRAW_COMPLETED(Phase.WITHDRAWN);

        public Phase getTradePhase() {
            return phase;
        }

        private final Phase phase;

        State(Phase phase) {
            this.phase = phase;
        }

        public static Trade.State fromProto(protobuf.Trade.State state) {
            return ProtoUtil.enumFromProto(Trade.State.class, state.name());
        }

        public static protobuf.Trade.State toProtoMessage(Trade.State state) {
            return protobuf.Trade.State.valueOf(state.name());
        }


        // We allow a state change only if the phase is the next phase or if we do not change the phase by the
        // state change (e.g. detail change inside the same phase)
        public boolean isValidTransitionTo(State newState) {
            Phase newPhase = newState.getTradePhase();
            Phase currentPhase = this.getTradePhase();
            return currentPhase.isValidTransitionTo(newPhase) || newPhase.equals(currentPhase);
        }
    }

    public enum Phase implements TradePhase {
        INIT,
        TAKER_FEE_PUBLISHED,
        DEPOSIT_PUBLISHED,
        DEPOSIT_CONFIRMED,
        FIAT_SENT,
        FIAT_RECEIVED,
        PAYOUT_PUBLISHED,
        WITHDRAWN;

        public static Trade.Phase fromProto(protobuf.Trade.Phase phase) {
            return ProtoUtil.enumFromProto(Trade.Phase.class, phase.name());
        }

        public static protobuf.Trade.Phase toProtoMessage(Phase phase) {
            return protobuf.Trade.Phase.valueOf(phase.name());
        }

        // We allow a phase change only if the phase a future phase (we cannot limit it to next phase as we have cases where
        // we skip a phase as it is only relevant to one role -> states and phases need a redesign ;-( )
        public boolean isValidTransitionTo(Trade.Phase newPhase) {
            // this is current phase
            return newPhase.ordinal() > this.ordinal();
        }
    }

    public enum DisputeState {
        NO_DISPUTE,
        // arbitration
        DISPUTE_REQUESTED,
        DISPUTE_STARTED_BY_PEER,
        DISPUTE_CLOSED,

        // mediation
        MEDIATION_REQUESTED,
        MEDIATION_STARTED_BY_PEER,
        MEDIATION_CLOSED,

        // refund
        REFUND_REQUESTED,
        REFUND_REQUEST_STARTED_BY_PEER,
        REFUND_REQUEST_CLOSED;

        public static Trade.DisputeState fromProto(protobuf.Trade.DisputeState disputeState) {
            return ProtoUtil.enumFromProto(Trade.DisputeState.class, disputeState.name());
        }

        public static protobuf.Trade.DisputeState toProtoMessage(Trade.DisputeState disputeState) {
            return protobuf.Trade.DisputeState.valueOf(disputeState.name());
        }

        public boolean isNotDisputed() {
            return this == Trade.DisputeState.NO_DISPUTE;
        }

        public boolean isMediated() {
            return this == Trade.DisputeState.MEDIATION_REQUESTED ||
                    this == Trade.DisputeState.MEDIATION_STARTED_BY_PEER ||
                    this == Trade.DisputeState.MEDIATION_CLOSED;
        }

        public boolean isArbitrated() {
            return this == Trade.DisputeState.DISPUTE_REQUESTED ||
                    this == Trade.DisputeState.DISPUTE_STARTED_BY_PEER ||
                    this == Trade.DisputeState.DISPUTE_CLOSED ||
                    this == Trade.DisputeState.REFUND_REQUESTED ||
                    this == Trade.DisputeState.REFUND_REQUEST_STARTED_BY_PEER ||
                    this == Trade.DisputeState.REFUND_REQUEST_CLOSED;
        }
    }

    public enum TradePeriodState {
        FIRST_HALF,
        SECOND_HALF,
        TRADE_PERIOD_OVER;

        public static Trade.TradePeriodState fromProto(protobuf.Trade.TradePeriodState tradePeriodState) {
            return ProtoUtil.enumFromProto(Trade.TradePeriodState.class, tradePeriodState.name());
        }

        public static protobuf.Trade.TradePeriodState toProtoMessage(Trade.TradePeriodState tradePeriodState) {
            return protobuf.Trade.TradePeriodState.valueOf(tradePeriodState.name());
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Fields
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Persistable
    // Immutable
    @Getter
    private final ProcessModel processModel;
    @Getter
    private final boolean isCurrencyForTakerFeeBtc;
    @Getter
    private final long tradeTxFeeAsLong;
    @Getter
    private final long takerFeeAsLong;

    //  Mutable
    @Nullable
    @Getter
    @Setter
    private String takerFeeTxId;
    @Nullable
    @Getter
    @Setter
    private String depositTxId;
    @Nullable
    @Getter
    @Setter
    private String payoutTxId;
    @Setter
    private long amountAsLong;
    @Setter
    private long priceAsLong;
    private State state = State.PREPARATION;
    @Getter
    private DisputeState disputeState = DisputeState.NO_DISPUTE;
    @Getter
    private TradePeriodState tradePeriodState = TradePeriodState.FIRST_HALF;
    @Nullable
    @Getter
    @Setter
    private Contract contract;
    @Nullable
    @Getter
    @Setter
    private String contractAsJson;
    @Nullable
    @Getter
    @Setter
    private byte[] contractHash;
    @Nullable
    @Getter
    @Setter
    private String takerContractSignature;
    @Nullable
    @Getter
    @Setter
    private String makerContractSignature;
    @Nullable
    @Getter
    @Setter
    private NodeAddress arbitratorNodeAddress;
    @Nullable
    @Setter
    private byte[] arbitratorBtcPubKey;
    @Nullable
    @Getter
    @Setter
    private PubKeyRing arbitratorPubKeyRing;
    @Nullable
    @Getter
    @Setter
    private NodeAddress mediatorNodeAddress;
    @Nullable
    @Getter
    @Setter
    private PubKeyRing mediatorPubKeyRing;
    @Nullable
    @Getter
    @Setter
    private String takerPaymentAccountId;

    @Getter
    @Setter
    @Nullable
    private String counterCurrencyTxId;
    @Getter
    private final ObservableList<ChatMessage> chatMessages = FXCollections.observableArrayList();

    // Transient
    // Immutable
    @Getter
    transient final protected Coin tradeTxFee; // is takers tx fee and the tx fee used for all the trade txs.
    transient final private Coin takerFee;
    @Getter
    transient final private BtcWalletService btcWalletService;

    transient final private ObjectProperty<State> stateProperty = new SimpleObjectProperty<>(state);
    transient final private ObjectProperty<Phase> statePhaseProperty = new SimpleObjectProperty<>(state.phase);
    transient final private ObjectProperty<DisputeState> disputeStateProperty = new SimpleObjectProperty<>(disputeState);
    transient final private ObjectProperty<TradePeriodState> tradePeriodStateProperty = new SimpleObjectProperty<>(tradePeriodState);

    //  Mutable
    @Nullable
    transient private Transaction depositTx;
    @Getter
    transient private boolean isInitialized;

    // Added in v1.2.0
    @Nullable
    transient private Transaction delayedPayoutTx;

    @Nullable
    transient private Transaction payoutTx;
    @Nullable
    transient private Coin amount;

    transient private ObjectProperty<Coin> amountProperty;
    transient private ObjectProperty<Volume> volumeProperty;

    // Added in v1.1.6
    @Getter
    @Nullable
    private MediationResultState mediationResultState = MediationResultState.UNDEFINED_MEDIATION_RESULT;
    transient final private ObjectProperty<MediationResultState> mediationResultStateProperty = new SimpleObjectProperty<>(mediationResultState);

    // Added in v1.2.0
    @Getter
    @Setter
    private long lockTime;
    @Nullable
    @Getter
    @Setter
    private byte[] delayedPayoutTxBytes;
    @Nullable
    @Getter
    @Setter
    private NodeAddress refundAgentNodeAddress;
    @Nullable
    @Getter
    @Setter
    private PubKeyRing refundAgentPubKeyRing;
    @Getter
    @Nullable
    private RefundResultState refundResultState = RefundResultState.UNDEFINED_REFUND_RESULT;
    transient final private ObjectProperty<RefundResultState> refundResultStateProperty = new SimpleObjectProperty<>(refundResultState);

    // Added at v1.3.8
    // We use that for the XMR txKey but want to keep it generic to be flexible for other payment methods or assets.
    @Getter
    @Setter
    private String counterCurrencyExtraData;

    // Added at v1.3.8
    // Generic tx proof result. We persist name if AssetTxProofResult enum. Other fields in the enum are not persisted
    // as they are not very relevant as historical data (e.g. number of confirmations)
    @Nullable
    @Getter
    private AssetTxProofResult assetTxProofResult;
    // ObjectProperty with AssetTxProofResult does not notify changeListeners. Probably because AssetTxProofResult is
    // an enum and enum does not support EqualsAndHashCode. Alternatively we could add a addListener and removeListener
    // method and a listener interface, but the IntegerProperty seems to be less boilerplate.
    @Getter
    transient final private IntegerProperty assetTxProofResultUpdateProperty = new SimpleIntegerProperty();


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, initialization
    ///////////////////////////////////////////////////////////////////////////////////////////

    // maker
    protected Trade(Offer offer,
                    Coin tradeTxFee,
                    Coin takerFee,
                    boolean isCurrencyForTakerFeeBtc,
                    @Nullable NodeAddress arbitratorNodeAddress,
                    @Nullable NodeAddress mediatorNodeAddress,
                    @Nullable NodeAddress refundAgentNodeAddress,
                    BtcWalletService btcWalletService,
                    ProcessModel processModel,
                    String uid) {
        super(uid, offer);
        this.tradeTxFee = tradeTxFee;
        this.takerFee = takerFee;
        this.isCurrencyForTakerFeeBtc = isCurrencyForTakerFeeBtc;
        this.arbitratorNodeAddress = arbitratorNodeAddress;
        this.mediatorNodeAddress = mediatorNodeAddress;
        this.refundAgentNodeAddress = refundAgentNodeAddress;
        this.btcWalletService = btcWalletService;
        this.processModel = processModel;

        tradeTxFeeAsLong = tradeTxFee.value;
        takerFeeAsLong = takerFee.value;
    }


    // taker
    @SuppressWarnings(""NullableProblems"")
    protected Trade(Offer offer,
                    Coin amount,
                    Coin txFee,
                    Coin takerFee,
                    boolean isCurrencyForTakerFeeBtc,
                    long priceAsLong,
                    NodeAddress tradingPeerNodeAddress,
                    @Nullable NodeAddress arbitratorNodeAddress,
                    @Nullable NodeAddress mediatorNodeAddress,
                    @Nullable NodeAddress refundAgentNodeAddress,
                    BtcWalletService btcWalletService,
                    ProcessModel processModel,
                    String uid) {

        this(offer,
                txFee,
                takerFee,
                isCurrencyForTakerFeeBtc,
                arbitratorNodeAddress,
                mediatorNodeAddress,
                refundAgentNodeAddress,
                btcWalletService,
                processModel,
                uid);
        this.priceAsLong = priceAsLong;

        setTradingPeerNodeAddress(tradingPeerNodeAddress);
        setAmount(amount);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // PROTO BUFFER
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public Message toProtoMessage() {
        protobuf.Trade.Builder builder = protobuf.Trade.newBuilder()
                .setOffer(offer.toProtoMessage())
                .setIsCurrencyForTakerFeeBtc(isCurrencyForTakerFeeBtc)
                .setTxFeeAsLong(tradeTxFeeAsLong)
                .setTakerFeeAsLong(takerFeeAsLong)
                .setTakeOfferDate(takeOfferDate)
                .setProcessModel(processModel.toProtoMessage())
                .setTradeAmountAsLong(amountAsLong)
                .setTradePrice(priceAsLong)
                .setState(Trade.State.toProtoMessage(state))
                .setDisputeState(Trade.DisputeState.toProtoMessage(disputeState))
                .setTradePeriodState(Trade.TradePeriodState.toProtoMessage(tradePeriodState))
                .addAllChatMessage(chatMessages.stream()
                        .map(msg -> msg.toProtoNetworkEnvelope().getChatMessage())
                        .collect(Collectors.toList()))
                .setLockTime(lockTime)
                .setUid(uid);

        Optional.ofNullable(takerFeeTxId).ifPresent(builder::setTakerFeeTxId);
        Optional.ofNullable(depositTxId).ifPresent(builder::setDepositTxId);
        Optional.ofNullable(payoutTxId).ifPresent(builder::setPayoutTxId);
        Optional.ofNullable(tradingPeerNodeAddress).ifPresent(e -> builder.setTradingPeerNodeAddress(tradingPeerNodeAddress.toProtoMessage()));
        Optional.ofNullable(contract).ifPresent(e -> builder.setContract(contract.toProtoMessage()));
        Optional.ofNullable(contractAsJson).ifPresent(builder::setContractAsJson);
        Optional.ofNullable(contractHash).ifPresent(e -> builder.setContractHash(ByteString.copyFrom(contractHash)));
        Optional.ofNullable(takerContractSignature).ifPresent(builder::setTakerContractSignature);
        Optional.ofNullable(makerContractSignature).ifPresent(builder::setMakerContractSignature);
        Optional.ofNullable(arbitratorNodeAddress).ifPresent(e -> builder.setArbitratorNodeAddress(arbitratorNodeAddress.toProtoMessage()));
        Optional.ofNullable(mediatorNodeAddress).ifPresent(e -> builder.setMediatorNodeAddress(mediatorNodeAddress.toProtoMessage()));
        Optional.ofNullable(refundAgentNodeAddress).ifPresent(e -> builder.setRefundAgentNodeAddress(refundAgentNodeAddress.toProtoMessage()));
        Optional.ofNullable(arbitratorBtcPubKey).ifPresent(e -> builder.setArbitratorBtcPubKey(ByteString.copyFrom(arbitratorBtcPubKey)));
        Optional.ofNullable(takerPaymentAccountId).ifPresent(builder::setTakerPaymentAccountId);
        Optional.ofNullable(errorMessage).ifPresent(builder::setErrorMessage);
        Optional.ofNullable(arbitratorPubKeyRing).ifPresent(e -> builder.setArbitratorPubKeyRing(arbitratorPubKeyRing.toProtoMessage()));
        Optional.ofNullable(mediatorPubKeyRing).ifPresent(e -> builder.setMediatorPubKeyRing(mediatorPubKeyRing.toProtoMessage()));
        Optional.ofNullable(refundAgentPubKeyRing).ifPresent(e -> builder.setRefundAgentPubKeyRing(refundAgentPubKeyRing.toProtoMessage()));
        Optional.ofNullable(counterCurrencyTxId).ifPresent(e -> builder.setCounterCurrencyTxId(counterCurrencyTxId));
        Optional.ofNullable(mediationResultState).ifPresent(e -> builder.setMediationResultState(MediationResultState.toProtoMessage(mediationResultState)));
        Optional.ofNullable(refundResultState).ifPresent(e -> builder.setRefundResultState(RefundResultState.toProtoMessage(refundResultState)));
        Optional.ofNullable(delayedPayoutTxBytes).ifPresent(e -> builder.setDelayedPayoutTxBytes(ByteString.copyFrom(delayedPayoutTxBytes)));
        Optional.ofNullable(counterCurrencyExtraData).ifPresent(e -> builder.setCounterCurrencyExtraData(counterCurrencyExtraData));
        Optional.ofNullable(assetTxProofResult).ifPresent(e -> builder.setAssetTxProofResult(assetTxProofResult.name()));

        return builder.build();
    }

    public static Trade fromProto(Trade trade, protobuf.Trade proto, CoreProtoResolver coreProtoResolver) {
        trade.setTakeOfferDate(proto.getTakeOfferDate());
        trade.setState(State.fromProto(proto.getState()));
        trade.setDisputeState(DisputeState.fromProto(proto.getDisputeState()));
        trade.setTradePeriodState(TradePeriodState.fromProto(proto.getTradePeriodState()));
        trade.setTakerFeeTxId(ProtoUtil.stringOrNullFromProto(proto.getTakerFeeTxId()));
        trade.setDepositTxId(ProtoUtil.stringOrNullFromProto(proto.getDepositTxId()));
        trade.setPayoutTxId(ProtoUtil.stringOrNullFromProto(proto.getPayoutTxId()));
        trade.setContract(proto.hasContract() ? Contract.fromProto(proto.getContract(), coreProtoResolver) : null);
        trade.setContractAsJson(ProtoUtil.stringOrNullFromProto(proto.getContractAsJson()));
        trade.setContractHash(ProtoUtil.byteArrayOrNullFromProto(proto.getContractHash()));
        trade.setTakerContractSignature(ProtoUtil.stringOrNullFromProto(proto.getTakerContractSignature()));
        trade.setMakerContractSignature(ProtoUtil.stringOrNullFromProto(proto.getMakerContractSignature()));
        trade.setArbitratorNodeAddress(proto.hasArbitratorNodeAddress() ? NodeAddress.fromProto(proto.getArbitratorNodeAddress()) : null);
        trade.setMediatorNodeAddress(proto.hasMediatorNodeAddress() ? NodeAddress.fromProto(proto.getMediatorNodeAddress()) : null);
        trade.setRefundAgentNodeAddress(proto.hasRefundAgentNodeAddress() ? NodeAddress.fromProto(proto.getRefundAgentNodeAddress()) : null);
        trade.setArbitratorBtcPubKey(ProtoUtil.byteArrayOrNullFromProto(proto.getArbitratorBtcPubKey()));
        trade.setTakerPaymentAccountId(ProtoUtil.stringOrNullFromProto(proto.getTakerPaymentAccountId()));
        trade.setErrorMessage(ProtoUtil.stringOrNullFromProto(proto.getErrorMessage()));
        trade.setArbitratorPubKeyRing(proto.hasArbitratorPubKeyRing() ? PubKeyRing.fromProto(proto.getArbitratorPubKeyRing()) : null);
        trade.setMediatorPubKeyRing(proto.hasMediatorPubKeyRing() ? PubKeyRing.fromProto(proto.getMediatorPubKeyRing()) : null);
        trade.setRefundAgentPubKeyRing(proto.hasRefundAgentPubKeyRing() ? PubKeyRing.fromProto(proto.getRefundAgentPubKeyRing()) : null);
        trade.setCounterCurrencyTxId(proto.getCounterCurrencyTxId().isEmpty() ? null : proto.getCounterCurrencyTxId());
        trade.setMediationResultState(MediationResultState.fromProto(proto.getMediationResultState()));
        trade.setRefundResultState(RefundResultState.fromProto(proto.getRefundResultState()));
        trade.setDelayedPayoutTxBytes(ProtoUtil.byteArrayOrNullFromProto(proto.getDelayedPayoutTxBytes()));
        trade.setLockTime(proto.getLockTime());
        trade.setCounterCurrencyExtraData(ProtoUtil.stringOrNullFromProto(proto.getCounterCurrencyExtraData()));

        AssetTxProofResult persistedAssetTxProofResult = ProtoUtil.enumFromProto(AssetTxProofResult.class, proto.getAssetTxProofResult());
        // We do not want to show the user the last pending state when he starts up the app again, so we clear it.
        if (persistedAssetTxProofResult == AssetTxProofResult.PENDING) {
            persistedAssetTxProofResult = null;
        }
        trade.setAssetTxProofResult(persistedAssetTxProofResult);

        trade.chatMessages.addAll(proto.getChatMessageList().stream()
                .map(ChatMessage::fromPayloadProto)
                .collect(Collectors.toList()));

        return trade;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void initialize(Provider serviceProvider) {
        serviceProvider.getArbitratorManager().getDisputeAgentByNodeAddress(arbitratorNodeAddress).ifPresent(arbitrator -> {
            arbitratorBtcPubKey = arbitrator.getBtcPubKey();
            arbitratorPubKeyRing = arbitrator.getPubKeyRing();
        });

        serviceProvider.getMediatorManager().getDisputeAgentByNodeAddress(mediatorNodeAddress)
                .ifPresent(mediator -> mediatorPubKeyRing = mediator.getPubKeyRing());

        serviceProvider.getRefundAgentManager().getDisputeAgentByNodeAddress(refundAgentNodeAddress)
                .ifPresent(refundAgent -> refundAgentPubKeyRing = refundAgent.getPubKeyRing());

        isInitialized = true;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    // The deserialized tx has not actual confidence data, so we need to get the fresh one from the wallet.
    public void updateDepositTxFromWallet() {
        if (getDepositTx() != null)
            applyDepositTx(processModel.getTradeWalletService().getWalletTx(getDepositTx().getTxId()));
    }

    public void applyDepositTx(Transaction tx) {
        this.depositTx = tx;
        depositTxId = depositTx.getTxId().toString();
        setupConfidenceListener();
    }

    @Nullable
    public Transaction getDepositTx() {
        if (depositTx == null) {
            depositTx = depositTxId != null ? btcWalletService.getTransaction(depositTxId) : null;
        }
        return depositTx;
    }

    public void applyDelayedPayoutTx(Transaction delayedPayoutTx) {
        this.delayedPayoutTx = delayedPayoutTx;
        this.delayedPayoutTxBytes = delayedPayoutTx.bitcoinSerialize();
    }

    public void applyDelayedPayoutTxBytes(byte[] delayedPayoutTxBytes) {
        this.delayedPayoutTxBytes = delayedPayoutTxBytes;
    }

    @Nullable
    public Transaction getDelayedPayoutTx() {
        return getDelayedPayoutTx(processModel.getBtcWalletService());
    }

    // If called from a not initialized trade (or a closed or failed trade)
    // we need to pass the btcWalletService
    @Nullable
    public Transaction getDelayedPayoutTx(BtcWalletService btcWalletService) {
        if (delayedPayoutTx == null) {
            if (btcWalletService == null) {
                log.warn(""btcWalletService is null. You might call that method before the tradeManager has "" +
                        ""initialized all trades"");
                return null;
            }

            if (delayedPayoutTxBytes == null) {
                log.warn(""delayedPayoutTxBytes are null"");
                return null;
            }

            delayedPayoutTx = btcWalletService.getTxFromSerializedTx(delayedPayoutTxBytes);
        }
        return delayedPayoutTx;
    }

    public void addAndPersistChatMessage(ChatMessage chatMessage) {
        if (!chatMessages.contains(chatMessage)) {
            chatMessages.add(chatMessage);
        } else {
            log.error(""Trade ChatMessage already exists"");
        }
    }

    public boolean mediationResultAppliedPenaltyToSeller() {
        // If mediated payout is same or more then normal payout we enable otherwise a penalty was applied
        // by mediators and we keep the confirm disabled to avoid that the seller can complete the trade
        // without the penalty.
        long payoutAmountFromMediation = processModel.getSellerPayoutAmountFromMediation();
        long normalPayoutAmount = offer.getSellerSecurityDeposit().value;
        return payoutAmountFromMediation < normalPayoutAmount;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // TradeModel implementation
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onComplete() {
    }

    @Override
    public State getTradeState() {
        return state;
    }

    @Override
    public Phase getTradePhase() {
        return state.getTradePhase();
    }

    @Override
    public ProtocolModel<TradingPeer> getTradeProtocolModel() {
        return processModel;
    }

    @Override
    public boolean isCompleted() {
        return isWithdrawn();
    }

    @Override
    public long getAmountAsLong() {
        return amountAsLong;
    }

    @Override
    public Coin getAmount() {
        if (amount == null)
            amount = Coin.valueOf(amountAsLong);
        return amount;
    }

    @Nullable
    @Override
    public Volume getVolume() {
        try {
            if (getAmount() != null && getPrice() != null) {
                Volume volumeByAmount = getPrice().getVolumeByAmount(getAmount());
                if (offer != null) {
                    if (offer.getPaymentMethod().getId().equals(PaymentMethod.HAL_CASH_ID))
                        volumeByAmount = VolumeUtil.getAdjustedVolumeForHalCash(volumeByAmount);
                    else if (CurrencyUtil.isFiatCurrency(offer.getCurrencyCode()))
                        volumeByAmount = VolumeUtil.getRoundedFiatVolume(volumeByAmount);
                }
                return volumeByAmount;
            } else {
                return null;
            }
        } catch (Throwable ignore) {
            return null;
        }
    }

    @Override
    public Price getPrice() {
        return Price.valueOf(offer.getCurrencyCode(), priceAsLong);
    }

    // getTxFee() is implemented in concrete classes
    // Maker use fee from offer, taker use this.txFee

    @Override
    public Coin getTakerFee() {
        return takerFee;
    }

    @Override
    public Coin getMakerFee() {
        return offer.getMakerFee();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Abstract
    ///////////////////////////////////////////////////////////////////////////////////////////

    public abstract Coin getPayoutAmount();

    public abstract boolean confirmPermitted();

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Setters
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void setStateIfValidTransitionTo(State newState) {
        if (state.isValidTransitionTo(newState)) {
            setState(newState);
        } else {
            log.warn(""State change is not getting applied because it would cause an invalid transition. "" +
                    ""Trade state={}, intended state={}"", state, newState);
        }
    }

    public void setState(State state) {
        if (isInitialized) {
            // We don't want to log at startup the setState calls from all persisted trades
            log.info(""Set new state at {} (id={}): {}"", this.getClass().getSimpleName(), getShortId(), state);
        }
        if (state.getTradePhase().ordinal() < this.state.getTradePhase().ordinal()) {
            String message = ""We got a state change to a previous phase.\n"" +
                    ""Old state is: "" + this.state + "". New state is: "" + state;
            log.warn(message);
        }

        this.state = state;
        stateProperty.set(state);
        statePhaseProperty.set(state.getTradePhase());
    }

    public void setDisputeState(DisputeState disputeState) {
        this.disputeState = disputeState;
        disputeStateProperty.set(disputeState);
    }

    public void setMediationResultState(MediationResultState mediationResultState) {
        this.mediationResultState = mediationResultState;
        mediationResultStateProperty.set(mediationResultState);
    }

    public void setRefundResultState(RefundResultState refundResultState) {
        this.refundResultState = refundResultState;
        refundResultStateProperty.set(refundResultState);
    }

    public void setTradePeriodState(TradePeriodState tradePeriodState) {
        this.tradePeriodState = tradePeriodState;
        tradePeriodStateProperty.set(tradePeriodState);
    }

    public void setAmount(Coin amount) {
        this.amount = amount;
        amountAsLong = amount.value;
        getAmountProperty().set(amount);
        getVolumeProperty().set(getVolume());
    }

    public void setPayoutTx(Transaction payoutTx) {
        this.payoutTx = payoutTx;
        payoutTxId = payoutTx.getTxId().toString();
    }

    public void setAssetTxProofResult(@Nullable AssetTxProofResult assetTxProofResult) {
        this.assetTxProofResult = assetTxProofResult;
        assetTxProofResultUpdateProperty.set(assetTxProofResultUpdateProperty.get() + 1);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Getter
    ///////////////////////////////////////////////////////////////////////////////////////////


    public Date getHalfTradePeriodDate() {
        return new Date(getTradeStartTime() + getMaxTradePeriod() / 2);
    }

    public Date getMaxTradePeriodDate() {
        return new Date(getTradeStartTime() + getMaxTradePeriod());
    }

    private long getMaxTradePeriod() {
        return offer.getPaymentMethod().getMaxTradePeriod();
    }

    private long getTradeStartTime() {
        long now = System.currentTimeMillis();
        long startTime;
        Transaction depositTx = getDepositTx();
        if (depositTx != null && getDate() != null) {
            if (depositTx.getConfidence().getDepthInBlocks() > 0) {
                final long tradeTime = getDate().getTime();
                // Use tx.getIncludedInBestChainAt() when available, otherwise use tx.getUpdateTime()
                long blockTime = depositTx.getIncludedInBestChainAt() != null
                        ? depositTx.getIncludedInBestChainAt().getTime()
                        : depositTx.getUpdateTime().getTime();
                // If block date is in future (Date in Bitcoin blocks can be off by +/- 2 hours) we use our current date.
                // If block date is earlier than our trade date we use our trade date.
                if (blockTime > now)
                    startTime = now;
                else
                    startTime = Math.max(blockTime, tradeTime);

                log.debug(""We set the start for the trade period to {}. Trade started at: {}. Block got mined at: {}"",
                        new Date(startTime), new Date(tradeTime), new Date(blockTime));
            } else {
                log.debug(""depositTx not confirmed yet. We don't start counting remaining trade period yet. txId={}"",
                        depositTx.getTxId().toString());
                startTime = now;
            }
        } else {
            startTime = now;
        }
        return startTime;
    }

    public boolean hasFailed() {
        return errorMessageProperty().get() != null;
    }

    public boolean isInPreparation() {
        return getTradePhase().ordinal() == Phase.INIT.ordinal();
    }

    public boolean isTakerFeePublished() {
        return getTradePhase().ordinal() >= Phase.TAKER_FEE_PUBLISHED.ordinal();
    }

    public boolean isDepositPublished() {
        return getTradePhase().ordinal() >= Phase.DEPOSIT_PUBLISHED.ordinal();
    }

    public boolean isFundsLockedIn() {
        // If no deposit tx was confirmed we have no funds locked in
        if (!isDepositConfirmed()) {
            return false;
        }

        // If we have the payout tx published (non disputed case) we have no funds locked in. Here we might have more
        // complex cases where users open a mediation but continue the trade to finalize it without mediated payout.
        // The trade state handles that but does not handle mediated payouts or refund agents payouts.
        if (isPayoutPublished()) {
            return false;
        }

        // Legacy arbitration is not handled anymore as not used anymore.

        // In mediation case we check for the mediationResultState. As there are multiple sub-states we use ordinal.
        if (disputeState == DisputeState.MEDIATION_CLOSED) {
            if (mediationResultState != null &&
                    mediationResultState.ordinal() >= MediationResultState.PAYOUT_TX_PUBLISHED.ordinal()) {
                return false;
            }
        }

        // In refund agent case the funds are spent anyway with the time locked payout. We do not consider that as
        // locked in funds.
        return disputeState != DisputeState.REFUND_REQUESTED &&
                disputeState != DisputeState.REFUND_REQUEST_STARTED_BY_PEER &&
                disputeState != DisputeState.REFUND_REQUEST_CLOSED;
    }

    public boolean isDepositConfirmed() {
        return getTradePhase().ordinal() >= Phase.DEPOSIT_CONFIRMED.ordinal();
    }

    public boolean isFiatSent() {
        return getTradePhase().ordinal() >= Phase.FIAT_SENT.ordinal();
    }

    public boolean isFiatReceived() {
        return getTradePhase().ordinal() >= Phase.FIAT_RECEIVED.ordinal();
    }

    public boolean isPayoutPublished() {
        return getTradePhase().ordinal() >= Phase.PAYOUT_PUBLISHED.ordinal() || isWithdrawn();
    }

    public boolean isWithdrawn() {
        return getTradePhase().ordinal() == Phase.WITHDRAWN.ordinal();
    }

    public ReadOnlyObjectProperty<State> stateProperty() {
        return stateProperty;
    }

    public ReadOnlyObjectProperty<Phase> statePhaseProperty() {
        return statePhaseProperty;
    }

    public ReadOnlyObjectProperty<DisputeState> disputeStateProperty() {
        return disputeStateProperty;
    }

    public ReadOnlyObjectProperty<MediationResultState> mediationResultStateProperty() {
        return mediationResultStateProperty;
    }

    public ReadOnlyObjectProperty<RefundResultState> refundResultStateProperty() {
        return refundResultStateProperty;
    }

    public ReadOnlyObjectProperty<TradePeriodState> tradePeriodStateProperty() {
        return tradePeriodStateProperty;
    }

    public ReadOnlyObjectProperty<Coin> amountProperty() {
        return amountProperty;
    }

    public ReadOnlyObjectProperty<Volume> volumeProperty() {
        return volumeProperty;
    }


    @Nullable
    public Transaction getPayoutTx() {
        if (payoutTx == null)
            payoutTx = payoutTxId != null ? btcWalletService.getTransaction(payoutTxId) : null;
        return payoutTx;
    }

    public boolean hasErrorMessage() {
        return getErrorMessage() != null && !getErrorMessage().isEmpty();
    }

    public boolean isTxChainInvalid() {
        return offer.getOfferFeePaymentTxId() == null ||
                getTakerFeeTxId() == null ||
                getDepositTxId() == null ||
                getDepositTx() == null ||
                getDelayedPayoutTxBytes() == null;
    }

    public byte[] getArbitratorBtcPubKey() {
        // In case we are already in a trade the arbitrator can have been revoked and we still can complete the trade
        // Only new trades cannot start without any arbitrator
        if (arbitratorBtcPubKey == null) {
            Arbitrator arbitrator = processModel.getUser().getAcceptedArbitratorByAddress(arbitratorNodeAddress);
            checkNotNull(arbitrator, ""arbitrator must not be null"");
            arbitratorBtcPubKey = arbitrator.getBtcPubKey();
        }

        checkNotNull(arbitratorBtcPubKey, ""ArbitratorPubKey must not be null"");
        return arbitratorBtcPubKey;
    }

    public boolean isBsqSwap() {
        return offer != null && offer.isBsqSwapOffer();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    // lazy initialization
    private ObjectProperty<Coin> getAmountProperty() {
        if (amountProperty == null)
            amountProperty = getAmount() != null ? new SimpleObjectProperty<>(getAmount()) : new SimpleObjectProperty<>();

        return amountProperty;
    }

    // lazy initialization
    private ObjectProperty<Volume> getVolumeProperty() {
        if (volumeProperty == null)
            volumeProperty = getVolume() != null ? new SimpleObjectProperty<>(getVolume()) : new SimpleObjectProperty<>();
        return volumeProperty;
    }

    private void setupConfidenceListener() {
        if (getDepositTx() != null) {
            TransactionConfidence transactionConfidence = getDepositTx().getConfidence();
            if (transactionConfidence.getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING) {
                setConfirmedState();
            } else {
                ListenableFuture<TransactionConfidence> future = transactionConfidence.getDepthFuture(1);
                Futures.addCallback(future, new FutureCallback<>() {
                    @Override
                    public void onSuccess(TransactionConfidence result) {
                        setConfirmedState();
                    }

                    @Override
                    public void onFailure(@NotNull Throwable t) {
                        t.printStackTrace();
                        log.error(t.getMessage());
                        throw new RuntimeException(t);
                    }
                }, MoreExecutors.directExecutor());
            }
        } else {
            log.error(""depositTx == null. That must not happen."");
        }
    }

    private void setConfirmedState() {
        // we only apply the state if we are not already further in the process
        if (!isDepositConfirmed()) {
            // As setState is called here from the trade itself we cannot trigger a requestPersistence call.
            // But as we get setupConfidenceListener called at startup anyway there is no issue if it would not be
            // persisted in case the shutdown routine did not persist the trade.
            setState(State.DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN);
        }
    }

    @Override
    public String toString() {
        return ""Trade{"" +
                ""\n     offer="" + offer +
                "",\n     isCurrencyForTakerFeeBtc="" + isCurrencyForTakerFeeBtc +
                "",\n     tradeTxFeeAsLong="" + tradeTxFeeAsLong +
                "",\n     takerFeeAsLong="" + takerFeeAsLong +
                "",\n     takeOfferDate="" + takeOfferDate +
                "",\n     processModel="" + processModel +
                "",\n     takerFeeTxId='"" + takerFeeTxId + '\'' +
                "",\n     depositTxId='"" + depositTxId + '\'' +
                "",\n     payoutTxId='"" + payoutTxId + '\'' +
                "",\n     tradeAmountAsLong="" + amountAsLong +
                "",\n     tradePrice="" + priceAsLong +
                "",\n     tradingPeerNodeAddress="" + tradingPeerNodeAddress +
                "",\n     state="" + state +
                "",\n     disputeState="" + disputeState +
                "",\n     tradePeriodState="" + tradePeriodState +
                "",\n     contract="" + contract +
                "",\n     contractAsJson='"" + contractAsJson + '\'' +
                "",\n     contractHash="" + Utilities.bytesAsHexString(contractHash) +
                "",\n     takerContractSignature='"" + takerContractSignature + '\'' +
                "",\n     makerContractSignature='"" + makerContractSignature + '\'' +
                "",\n     arbitratorNodeAddress="" + arbitratorNodeAddress +
                "",\n     arbitratorBtcPubKey="" + Utilities.bytesAsHexString(arbitratorBtcPubKey) +
                "",\n     arbitratorPubKeyRing="" + arbitratorPubKeyRing +
                "",\n     mediatorNodeAddress="" + mediatorNodeAddress +
                "",\n     mediatorPubKeyRing="" + mediatorPubKeyRing +
                "",\n     takerPaymentAccountId='"" + takerPaymentAccountId + '\'' +
                "",\n     errorMessage='"" + errorMessage + '\'' +
                "",\n     counterCurrencyTxId='"" + counterCurrencyTxId + '\'' +
                "",\n     counterCurrencyExtraData='"" + counterCurrencyExtraData + '\'' +
                "",\n     assetTxProofResult='"" + assetTxProofResult + '\'' +
                "",\n     chatMessages="" + chatMessages +
                "",\n     tradeTxFee="" + tradeTxFee +
                "",\n     takerFee="" + takerFee +
                "",\n     btcWalletService="" + btcWalletService +
                "",\n     stateProperty="" + stateProperty +
                "",\n     statePhaseProperty="" + statePhaseProperty +
                "",\n     disputeStateProperty="" + disputeStateProperty +
                "",\n     tradePeriodStateProperty="" + tradePeriodStateProperty +
                "",\n     depositTx="" + depositTx +
                "",\n     delayedPayoutTx="" + delayedPayoutTx +
                "",\n     payoutTx="" + payoutTx +
                "",\n     tradeAmount="" + amount +
                "",\n     tradeAmountProperty="" + amountProperty +
                "",\n     tradeVolumeProperty="" + volumeProperty +
                "",\n     mediationResultState="" + mediationResultState +
                "",\n     mediationResultStateProperty="" + mediationResultStateProperty +
                "",\n     lockTime="" + lockTime +
                "",\n     delayedPayoutTxBytes="" + Utilities.bytesAsHexString(delayedPayoutTxBytes) +
                "",\n     refundAgentNodeAddress="" + refundAgentNodeAddress +
                "",\n     refundAgentPubKeyRing="" + refundAgentPubKeyRing +
                "",\n     refundResultState="" + refundResultState +
                "",\n     refundResultStateProperty="" + refundResultStateProperty +
                ""\n}"";
    }
}",1,64 2000 777 539 587 2001 650 2002 123 331 330 331 777 640 2003 693 2004 123 330 330 2005 40 2006 46 2007 41 44 330 330 330 2008 40 2006 46 2009 41 44 330 330 2010 40 2006 46 2009 41 44 2011 40 2006 46 2009 41 44 2012 40 2006 46 2009 41 44 330 2013 40 2006 46 2009 41 44 330 2014 40 2006 46 2009 41 44 330 330 330 330 330 2015 40 2006 46 2016 41 44 330 330 64 2017 2018 40 2006 46 2016 41 44 64 2017 2019 40 2006 46 2016 41 44 64 2017 2020 40 2006 46 2016 41 44 64 2017 2021 40 2006 46 2016 41 44 330 2022 40 2006 46 2016 41 44 330 2023 40 2006 46 2016 41 44 330 2024 40 2006 46 2025 41 44 330 2026 40 2006 46 2027 41 44 2028 40 2006 46 2027 41 44 2029 40 2006 46 2027 41 44 2030 40 2006 46 2027 41 44 2031 40 2006 46 2027 41 44 2032 40 2006 46 2027 41 44 330 330 2033 40 2006 46 2034 41 44 330 2035 40 2006 46 2036 41 44 2037 40 2006 46 2036 41 44 2038 40 2006 46 2036 41 44 2039 40 2006 46 2036 41 44 2040 40 2006 46 2036 41 44 2041 40 2006 46 2036 41 44 330 2042 40 2006 46 2036 41 44 330 2043 40 2006 46 2044 41 59 777 2006 2045 40 41 123 792 2046 59 125 773 657 2006 2047 59 2003 40 2006 2047 41 123 823 46 2047 61 2047 59 125 777 809 2001 46 2003 2048 40 2049 46 2001 46 2003 2050 41 123 792 2051 46 2052 40 2001 46 2003 46 587 44 2050 46 2053 40 41 41 59 125 777 809 2049 46 2001 46 2003 2054 40 2001 46 2003 2050 41 123 792 2049 46 2001 46 2003 46 2055 40 2050 46 2056 40 41 41 59 125 330 330 777 570 2057 40 2003 2058 41 123 2006 2059 61 2058 46 2045 40 41 59 2006 2060 61 823 46 2045 40 41 59 792 2060 46 2057 40 2059 41 309 2059 46 2061 40 2060 41 59 125 125 777 640 2062 693 2063 123 2064 44 2065 44 2066 44 2067 44 2068 44 2069 44 2070 44 2071 59 777 809 2001 46 2062 2072 40 2073 46 2001 46 2062 2074 41 123 792 2075 46 2076 40 2001 46 2062 46 587 44 2074 46 2077 40 41 41 59 125 777 809 2073 46 2001 46 2062 2078 40 2062 2074 41 123 792 2073 46 2001 46 2062 46 2079 40 2074 46 2080 40 41 41 59 125 330 330 777 570 2081 40 2001 46 2062 2082 41 123 330 792 2082 46 2083 40 41 62 823 46 2083 40 41 59 125 125 777 640 2084 123 2085 44 330 2086 44 2087 44 2088 44 330 2089 44 2090 44 2091 44 330 2092 44 2093 44 2094 59 777 809 2001 46 2084 2095 40 2096 46 2001 46 2084 2097 41 123 792 2098 46 2099 40 2001 46 2084 46 587 44 2097 46 2100 40 41 41 59 125 777 809 2096 46 2001 46 2084 2101 40 2001 46 2084 2097 41 123 792 2096 46 2001 46 2084 46 2102 40 2097 46 2103 40 41 41 59 125 777 570 2104 40 41 123 792 823 323 2001 46 2084 46 2085 59 125 777 570 2105 40 41 123 792 823 323 2001 46 2084 46 2089 309 823 323 2001 46 2084 46 2090 309 823 323 2001 46 2084 46 2091 59 125 777 570 2106 40 41 123 792 823 323 2001 46 2084 46 2086 309 823 323 2001 46 2084 46 2087 309 823 323 2001 46 2084 46 2088 309 823 323 2001 46 2084 46 2092 309 823 323 2001 46 2084 46 2093 309 823 323 2001 46 2084 46 2094 59 125 125 777 640 2107 123 2108 44 2109 44 2110 59 777 809 2001 46 2107 2111 40 2112 46 2001 46 2107 2113 41 123 792 2114 46 2115 40 2001 46 2107 46 587 44 2113 46 2116 40 41 41 59 125 777 809 2112 46 2001 46 2107 2117 40 2001 46 2107 2113 41 123 792 2112 46 2001 46 2107 46 2118 40 2113 46 2119 40 41 41 59 125 125 331 330 331 330 330 64 2120 773 657 2121 2122 59 64 2120 773 657 570 2123 59 64 2120 773 657 726 2124 59 64 2120 773 657 726 2125 59 330 64 2126 64 2120 64 2127 773 2128 2129 59 64 2126 64 2120 64 2127 773 2128 2130 59 64 2126 64 2120 64 2127 773 2128 2131 59 64 2127 773 726 2132 59 64 2127 773 726 2133 59 773 2003 2134 61 2003 46 2135 59 64 2120 773 2084 2136 61 2084 46 2137 59 64 2120 773 2107 2138 61 2107 46 2139 59 64 2126 64 2120 64 2127 773 2140 2141 59 64 2126 64 2120 64 2127 773 2128 2142 59 64 2126 64 2120 64 2127 773 574 91 93 2143 59 64 2126 64 2120 64 2127 773 2128 2144 59 64 2126 64 2120 64 2127 773 2128 2145 59 64 2126 64 2120 64 2127 773 2146 2147 59 64 2126 64 2127 773 574 91 93 2148 59 64 2126 64 2120 64 2127 773 2149 2150 59 64 2126 64 2120 64 2127 773 2146 2151 59 64 2126 64 2120 64 2127 773 2149 2152 59 64 2126 64 2120 64 2127 773 2128 2153 59 64 2120 64 2127 64 2126 773 2128 2154 59 64 2120 773 657 2155 60 2156 62 2157 61 2158 46 2159 40 41 59 330 330 64 2120 828 657 775 2160 2161 59 330 828 657 773 2160 2162 59 64 2120 828 657 773 2163 2164 59 828 657 773 2165 60 2003 62 2166 61 744 2167 60 62 40 2134 41 59 828 657 773 2165 60 2062 62 2168 61 744 2167 60 62 40 2134 46 2169 41 59 828 657 773 2165 60 2084 62 2170 61 744 2167 60 62 40 2136 41 59 828 657 773 2165 60 2107 62 2171 61 744 2167 60 62 40 2138 41 59 330 64 2126 828 773 2172 2173 59 64 2120 828 773 570 2174 59 330 64 2126 828 773 2172 2175 59 64 2126 828 773 2172 2176 59 64 2126 828 773 2160 2177 59 828 773 2165 60 2160 62 2178 59 828 773 2165 60 2179 62 2180 59 330 64 2120 64 2126 773 2181 2182 61 2181 46 2183 59 828 657 773 2165 60 2181 62 2184 61 744 2167 60 62 40 2182 41 59 330 64 2120 64 2127 773 726 2185 59 64 2126 64 2120 64 2127 773 574 91 93 2186 59 64 2126 64 2120 64 2127 773 2146 2187 59 64 2126 64 2120 64 2127 773 2149 2188 59 64 2120 64 2126 773 2189 2190 61 2189 46 2191 59 828 657 773 2165 60 2189 62 2192 61 744 2167 60 62 40 2190 41 59 330 330 64 2120 64 2127 773 2128 2193 59 330 330 330 64 2126 64 2120 773 2194 2195 59 330 330 330 64 2120 828 657 773 2196 2197 61 744 2198 40 41 59 331 330 331 330 775 2001 40 2199 2200 44 2160 2161 44 2160 2162 44 570 2123 44 64 2126 2146 2147 44 64 2126 2146 2151 44 64 2126 2146 2187 44 2163 2164 44 2121 2122 44 2128 2201 41 123 818 40 2201 44 2200 41 59 823 46 2161 61 2161 59 823 46 2162 61 2162 59 823 46 2123 61 2123 59 823 46 2147 61 2147 59 823 46 2151 61 2151 59 823 46 2187 61 2187 59 823 46 2164 61 2164 59 823 46 2122 61 2122 59 2124 61 2161 46 2202 59 2125 61 2162 46 2202 59 125 330 64 2203 40 362 41 775 2001 40 2199 2200 44 2160 2177 44 2160 2204 44 2160 2162 44 570 2123 44 726 2133 44 2146 2205 44 64 2126 2146 2147 44 64 2126 2146 2151 44 64 2126 2146 2187 44 2163 2164 44 2121 2122 44 2128 2201 41 123 823 40 2200 44 2204 44 2162 44 2123 44 2147 44 2151 44 2187 44 2164 44 2122 44 2201 41 59 823 46 2133 61 2133 59 2206 40 2205 41 59 2207 40 2177 41 59 125 331 330 331 64 2208 777 2209 2210 40 41 123 2211 46 2001 46 2212 2213 61 2211 46 2001 46 2214 40 41 46 2215 40 2200 46 2210 40 41 41 46 2216 40 2123 41 46 2217 40 2124 41 46 2218 40 2125 41 46 2219 40 2220 41 46 2221 40 2122 46 2210 40 41 41 46 2222 40 2132 41 46 2223 40 2133 41 46 2224 40 2001 46 2003 46 2210 40 2134 41 41 46 2225 40 2001 46 2084 46 2210 40 2136 41 41 46 2226 40 2001 46 2107 46 2210 40 2138 41 41 46 2227 40 2157 46 2228 40 41 46 2229 40 2230 45 62 2230 46 2231 40 41 46 2232 40 41 41 46 2233 40 2234 46 2235 40 41 41 41 46 2236 40 2185 41 46 2237 40 2201 41 59 2238 46 2239 40 2129 41 46 2240 40 2213 58 58 2241 41 59 2238 46 2239 40 2130 41 46 2240 40 2213 58 58 2242 41 59 2238 46 2239 40 2131 41 46 2240 40 2213 58 58 2243 41 59 2238 46 2239 40 2205 41 46 2240 40 2244 45 62 2213 46 2245 40 2205 46 2210 40 41 41 41 59 2238 46 2239 40 2141 41 46 2240 40 2244 45 62 2213 46 2246 40 2141 46 2210 40 41 41 41 59 2238 46 2239 40 2142 41 46 2240 40 2213 58 58 2247 41 59 2238 46 2239 40 2143 41 46 2240 40 2244 45 62 2213 46 2248 40 2249 46 2250 40 2143 41 41 41 59 2238 46 2239 40 2144 41 46 2240 40 2213 58 58 2251 41 59 2238 46 2239 40 2145 41 46 2240 40 2213 58 58 2252 41 59 2238 46 2239 40 2147 41 46 2240 40 2244 45 62 2213 46 2253 40 2147 46 2210 40 41 41 41 59 2238 46 2239 40 2151 41 46 2240 40 2244 45 62 2213 46 2254 40 2151 46 2210 40 41 41 41 59 2238 46 2239 40 2187 41 46 2240 40 2244 45 62 2213 46 2255 40 2187 46 2210 40 41 41 41 59 2238 46 2239 40 2148 41 46 2240 40 2244 45 62 2213 46 2256 40 2249 46 2250 40 2148 41 41 41 59 2238 46 2239 40 2153 41 46 2240 40 2213 58 58 2257 41 59 2238 46 2239 40 2258 41 46 2240 40 2213 58 58 2259 41 59 2238 46 2239 40 2150 41 46 2240 40 2244 45 62 2213 46 2260 40 2150 46 2210 40 41 41 41 59 2238 46 2239 40 2152 41 46 2240 40 2244 45 62 2213 46 2261 40 2152 46 2210 40 41 41 41 59 2238 46 2239 40 2188 41 46 2240 40 2244 45 62 2213 46 2262 40 2188 46 2210 40 41 41 41 59 2238 46 2239 40 2154 41 46 2240 40 2244 45 62 2213 46 2263 40 2154 41 41 59 2238 46 2239 40 2182 41 46 2240 40 2244 45 62 2213 46 2264 40 2181 46 2210 40 2182 41 41 41 59 2238 46 2239 40 2190 41 46 2240 40 2244 45 62 2213 46 2265 40 2189 46 2210 40 2190 41 41 41 59 2238 46 2239 40 2186 41 46 2240 40 2244 45 62 2213 46 2266 40 2249 46 2250 40 2186 41 41 41 59 2238 46 2239 40 2193 41 46 2240 40 2244 45 62 2213 46 2267 40 2193 41 41 59 2238 46 2239 40 2195 41 46 2240 40 2244 45 62 2213 46 2268 40 2195 46 2269 40 41 41 41 59 792 2213 46 2270 40 41 59 125 777 809 2001 2271 40 2001 2272 44 2273 46 2001 2274 44 2275 2276 41 123 2272 46 2277 40 2274 46 2278 40 41 41 59 2272 46 2279 40 2003 46 2271 40 2274 46 2280 40 41 41 41 59 2272 46 2281 40 2084 46 2271 40 2274 46 2282 40 41 41 41 59 2272 46 2283 40 2107 46 2271 40 2274 46 2284 40 41 41 41 59 2272 46 2285 40 2286 46 2287 40 2274 46 2288 40 41 41 41 59 2272 46 2289 40 2286 46 2287 40 2274 46 2290 40 41 41 41 59 2272 46 2291 40 2286 46 2287 40 2274 46 2292 40 41 41 41 59 2272 46 2293 40 2274 46 2294 40 41 63 2140 46 2271 40 2274 46 2295 40 41 44 2276 41 58 2296 41 59 2272 46 2297 40 2286 46 2287 40 2274 46 2298 40 41 41 41 59 2272 46 2299 40 2286 46 2300 40 2274 46 2301 40 41 41 41 59 2272 46 2302 40 2286 46 2287 40 2274 46 2303 40 41 41 41 59 2272 46 2304 40 2286 46 2287 40 2274 46 2305 40 41 41 41 59 2272 46 2306 40 2274 46 2307 40 41 63 2146 46 2271 40 2274 46 2308 40 41 41 58 2296 41 59 2272 46 2309 40 2274 46 2310 40 41 63 2146 46 2271 40 2274 46 2311 40 41 41 58 2296 41 59 2272 46 2312 40 2274 46 2313 40 41 63 2146 46 2271 40 2274 46 2314 40 41 41 58 2296 41 59 2272 46 2315 40 2286 46 2300 40 2274 46 2316 40 41 41 41 59 2272 46 2317 40 2286 46 2287 40 2274 46 2318 40 41 41 41 59 2272 46 2319 40 2286 46 2287 40 2274 46 2320 40 41 41 41 59 2272 46 2321 40 2274 46 2322 40 41 63 2149 46 2271 40 2274 46 2323 40 41 41 58 2296 41 59 2272 46 2324 40 2274 46 2325 40 41 63 2149 46 2271 40 2274 46 2326 40 41 41 58 2296 41 59 2272 46 2327 40 2274 46 2328 40 41 63 2149 46 2271 40 2274 46 2329 40 41 41 58 2296 41 59 2272 46 2330 40 2274 46 2331 40 41 46 2332 40 41 63 2296 58 2274 46 2331 40 41 41 59 2272 46 2333 40 2181 46 2271 40 2274 46 2334 40 41 41 41 59 2272 46 2335 40 2189 46 2271 40 2274 46 2336 40 41 41 41 59 2272 46 2337 40 2286 46 2300 40 2274 46 2338 40 41 41 41 59 2272 46 2339 40 2274 46 2340 40 41 41 59 2272 46 2341 40 2286 46 2287 40 2274 46 2342 40 41 41 41 59 2194 2343 61 2286 46 2344 40 2194 46 587 44 2274 46 2345 40 41 41 59 330 688 40 2343 323 2194 46 2346 41 123 2343 61 2296 59 125 2272 46 2347 40 2343 41 59 2272 46 2157 46 2348 40 2274 46 2349 40 41 46 2350 40 41 46 2351 40 2156 58 58 2352 41 46 2353 40 2354 46 2355 40 41 41 41 59 792 2272 59 125 331 330 331 777 865 2356 40 2357 2358 41 123 2358 46 2359 40 41 46 2360 40 2147 41 46 2361 40 2362 45 62 123 2148 61 2362 46 2363 40 41 59 2150 61 2362 46 2364 40 41 59 125 41 59 2358 46 2365 40 41 46 2360 40 2151 41 46 2361 40 2366 45 62 2152 61 2366 46 2367 40 41 41 59 2358 46 2368 40 41 46 2360 40 2187 41 46 2361 40 2369 45 62 2188 61 2369 46 2367 40 41 41 59 2174 61 2370 59 125 331 330 331 330 777 865 2371 40 41 123 688 40 2372 40 41 340 2373 41 2374 40 2122 46 2375 40 41 46 2376 40 2372 40 41 46 2377 40 41 41 41 59 125 777 865 2378 40 2172 2379 41 123 823 46 2173 61 2379 59 2130 61 2173 46 2380 40 41 46 2381 40 41 59 2382 40 41 59 125 64 2126 777 2172 2383 40 41 123 688 40 2173 323 2384 41 123 2173 61 2130 340 2384 63 2164 46 2385 40 2130 41 58 2384 59 125 792 2173 59 125 777 865 2386 40 2172 2175 41 123 823 46 2175 61 2175 59 823 46 2186 61 2175 46 2387 40 41 59 125 777 865 2388 40 574 91 93 2186 41 123 823 46 2186 61 2186 59 125 64 2126 777 2172 2389 40 41 123 792 2389 40 2122 46 2390 40 41 41 59 125 330 330 64 2126 777 2172 2389 40 2163 2164 41 123 688 40 2175 323 2391 41 123 688 40 2164 323 2391 41 123 2392 46 2393 40 362 43 362 41 59 792 2391 59 125 688 40 2186 323 2391 41 123 2394 46 2395 40 362 41 59 792 2391 59 125 2175 61 2164 46 2396 40 2186 41 59 125 792 2175 59 125 777 865 2397 40 2156 2398 41 123 688 40 33 2157 46 2399 40 2398 41 41 123 2157 46 2400 40 2398 41 59 125 630 123 2401 46 2402 40 362 41 59 125 125 777 570 2403 40 41 123 330 330 330 726 2404 61 2122 46 2405 40 41 59 726 2406 61 2200 46 2407 40 41 46 2408 59 792 2404 60 2406 59 125 331 330 331 64 2208 777 865 2409 40 41 123 125 64 2208 777 2003 2410 40 41 123 792 2134 59 125 64 2208 777 2062 2411 40 41 123 792 2134 46 2411 40 41 59 125 64 2208 777 2412 60 2413 62 2414 40 41 123 792 2122 59 125 64 2208 777 570 2415 40 41 123 792 2416 40 41 59 125 64 2208 777 726 2417 40 41 123 792 2132 59 125 64 2208 777 2160 2418 40 41 123 688 40 2177 323 2419 41 2177 61 2160 46 2420 40 2132 41 59 792 2177 59 125 64 2126 64 2208 777 2179 2421 40 41 123 830 123 688 40 2418 40 41 340 2422 307 2423 40 41 340 2422 41 123 2179 2424 61 2423 40 41 46 2425 40 2418 40 41 41 59 688 40 2200 340 2422 41 123 688 40 2200 46 2426 40 41 46 2427 40 41 46 2428 40 2429 46 2430 41 41 2424 61 2431 46 2432 40 2424 41 59 630 688 40 2433 46 2434 40 2200 46 2435 40 41 41 41 2424 61 2431 46 2436 40 2424 41 59 125 792 2424 59 125 630 123 792 2422 59 125 125 580 40 2437 2438 41 123 792 2439 59 125 125 64 2208 777 2440 2441 40 41 123 792 2440 46 2442 40 2200 46 2443 40 41 44 2133 41 59 125 330 330 64 2208 777 2160 2444 40 41 123 792 2162 59 125 64 2208 777 2160 2445 40 41 123 792 2200 46 2445 40 41 59 125 331 330 331 777 539 2160 2446 40 41 59 777 539 570 2447 40 41 59 331 330 331 777 865 2448 40 2003 2449 41 123 688 40 2134 46 2450 40 2449 41 41 123 2451 40 2449 41 59 125 630 123 2452 46 2453 40 362 43 362 44 2134 44 2449 41 59 125 125 777 865 2454 40 2003 2134 41 123 688 40 2174 41 123 330 2455 46 2456 40 362 44 823 46 2457 40 41 46 2458 40 41 44 2459 40 41 44 2134 41 59 125 688 40 2134 46 2411 40 41 46 2460 40 41 60 823 46 2134 46 2411 40 41 46 2460 40 41 41 123 2128 2461 61 362 43 362 43 823 46 2134 43 362 43 2134 59 2462 46 2463 40 2461 41 59 125 823 46 2134 61 2134 59 2166 46 2464 40 2134 41 59 2168 46 2464 40 2134 46 2411 40 41 41 59 125 777 865 2465 40 2084 2136 41 123 823 46 2136 61 2136 59 2170 46 2466 40 2136 41 59 125 777 865 2467 40 2181 2182 41 123 823 46 2182 61 2182 59 2184 46 2468 40 2182 41 59 125 777 865 2469 40 2189 2190 41 123 823 46 2190 61 2190 59 2192 46 2470 40 2190 41 59 125 777 865 2471 40 2107 2138 41 123 823 46 2138 61 2138 59 2171 46 2472 40 2138 41 59 125 777 865 2473 40 2160 2177 41 123 823 46 2177 61 2177 59 2132 61 2177 46 2474 59 2475 40 41 46 2476 40 2177 41 59 2477 40 41 46 2476 40 2421 40 41 41 59 125 777 865 2478 40 2172 2176 41 123 823 46 2176 61 2176 59 2131 61 2176 46 2479 40 41 46 2480 40 41 59 125 777 865 2481 40 64 2126 2194 2195 41 123 823 46 2195 61 2195 59 2197 46 2482 40 2197 46 2483 40 41 43 1501 41 59 125 331 330 331 777 2484 2485 40 41 123 792 744 2484 40 2486 40 41 43 2487 40 41 47 1502 41 59 125 777 2484 2488 40 41 123 792 744 2484 40 2489 40 41 43 2490 40 41 41 59 125 773 726 2491 40 41 123 792 2200 46 2492 40 41 46 2491 40 41 59 125 773 726 2493 40 41 123 726 2494 61 2495 46 2496 40 41 59 726 2497 59 2172 2173 61 2383 40 41 59 688 40 2173 340 2498 307 2499 40 41 340 2498 41 123 688 40 2173 46 2500 40 41 46 2501 40 41 62 1500 41 123 657 726 2502 61 2499 40 41 46 2503 40 41 59 330 726 2504 61 2173 46 2505 40 41 340 2498 63 2173 46 2505 40 41 46 2503 40 41 58 2173 46 2506 40 41 46 2503 40 41 59 330 330 688 40 2504 62 2494 41 2497 61 2494 59 630 2497 61 2507 46 2508 40 2504 44 2502 41 59 2509 46 2510 40 362 44 744 2484 40 2497 41 44 744 2484 40 2502 41 44 744 2484 40 2504 41 41 59 125 630 123 2511 46 2512 40 362 44 2173 46 2513 40 41 46 2514 40 41 41 59 2497 61 2494 59 125 125 630 123 2497 61 2494 59 125 792 2497 59 125 777 570 2515 40 41 123 792 2516 40 41 46 2517 40 41 340 2518 59 125 777 570 2519 40 41 123 792 2411 40 41 46 2520 40 41 323 2062 46 2521 46 2520 40 41 59 125 777 570 2522 40 41 123 792 2411 40 41 46 2523 40 41 325 2062 46 2524 46 2523 40 41 59 125 777 570 2525 40 41 123 792 2411 40 41 46 2526 40 41 325 2062 46 2527 46 2526 40 41 59 125 777 570 2528 40 41 123 330 688 40 33 2529 40 41 41 123 792 2530 59 125 330 330 330 688 40 2531 40 41 41 123 792 2532 59 125 330 330 688 40 2136 323 2084 46 2533 41 123 688 40 2182 340 2534 307 2182 46 2535 40 41 325 2181 46 2536 46 2535 40 41 41 123 792 2537 59 125 125 330 330 792 2136 340 2084 46 2538 307 2136 340 2084 46 2539 307 2136 340 2084 46 2540 59 125 777 570 2541 40 41 123 792 2411 40 41 46 2542 40 41 325 2062 46 2543 46 2542 40 41 59 125 777 570 2544 40 41 123 792 2411 40 41 46 2545 40 41 325 2062 46 2546 46 2545 40 41 59 125 777 570 2547 40 41 123 792 2411 40 41 46 2548 40 41 325 2062 46 2549 46 2548 40 41 59 125 777 570 2550 40 41 123 792 2411 40 41 46 2551 40 41 325 2062 46 2552 46 2551 40 41 309 2553 40 41 59 125 777 570 2554 40 41 123 792 2411 40 41 46 2555 40 41 323 2062 46 2556 46 2555 40 41 59 125 777 2557 60 2003 62 2166 40 41 123 792 2166 59 125 777 2557 60 2062 62 2168 40 41 123 792 2168 59 125 777 2557 60 2084 62 2170 40 41 123 792 2170 59 125 777 2557 60 2181 62 2184 40 41 123 792 2184 59 125 777 2557 60 2189 62 2192 40 41 123 792 2192 59 125 777 2557 60 2107 62 2171 40 41 123 792 2171 59 125 777 2557 60 2160 62 2178 40 41 123 792 2178 59 125 777 2557 60 2179 62 2180 40 41 123 792 2180 59 125 64 2126 777 2172 2558 40 41 123 688 40 2176 323 2559 41 2176 61 2131 340 2559 63 2164 46 2560 40 2131 41 58 2559 59 792 2176 59 125 777 570 2561 40 41 123 792 2562 40 41 340 2563 307 33 2562 40 41 46 2564 40 41 59 125 777 570 2565 40 41 123 792 2200 46 2566 40 41 323 2567 309 2568 40 41 323 2567 309 2569 40 41 323 2567 309 2383 40 41 323 2567 309 2570 40 41 323 2567 59 125 777 574 91 93 2571 40 41 123 330 330 688 40 2148 323 2572 41 123 2573 2574 61 2122 46 2575 40 41 46 2576 40 2147 41 59 2577 40 2574 44 362 41 59 2148 61 2574 46 2578 40 41 59 125 2579 40 2148 44 362 41 59 792 2148 59 125 777 570 2580 40 41 123 792 2200 340 2581 307 2200 46 2582 40 41 59 125 331 330 331 330 773 2165 60 2160 62 2583 40 41 123 688 40 2178 323 2584 41 2178 61 2418 40 41 340 2584 63 744 2167 60 62 40 2418 40 41 41 58 744 2167 60 62 40 41 59 792 2178 59 125 330 773 2165 60 2179 62 2585 40 41 123 688 40 2180 323 2586 41 2180 61 2421 40 41 340 2586 63 744 2167 60 62 40 2421 40 41 41 58 744 2167 60 62 40 41 59 792 2180 59 125 773 865 2587 40 41 123 688 40 2383 40 41 340 2588 41 123 2589 2590 61 2383 40 41 46 2591 40 41 59 688 40 2590 46 2592 40 41 323 2589 46 2593 46 2594 41 123 2595 40 41 59 125 630 123 2596 60 2589 62 2597 61 2590 46 2598 40 1501 41 59 2599 46 2600 40 2597 44 744 2601 60 62 40 41 123 64 2208 777 865 2602 40 2589 2603 41 123 2604 40 41 59 125 64 2208 777 865 2605 40 64 2606 2607 2608 41 123 2608 46 2609 40 41 59 2610 46 2611 40 2608 46 2612 40 41 41 59 825 744 2613 40 2608 41 59 125 125 44 2614 46 2615 40 41 41 59 125 125 630 123 2616 46 2617 40 362 41 59 125 125 773 865 2618 40 41 123 330 688 40 33 2541 40 41 41 123 330 330 330 2454 40 2003 46 2619 41 59 125 125 64 2208 777 2128 2620 40 41 123 792 362 43 362 43 2200 43 362 43 2123 43 362 43 2124 43 362 43 2125 43 362 43 2621 43 362 43 2122 43 362 43 2129 43 314 43 362 43 2130 43 314 43 362 43 2131 43 314 43 362 43 2132 43 362 43 2133 43 362 43 2205 43 362 43 2134 43 362 43 2136 43 362 43 2138 43 362 43 2141 43 362 43 2142 43 314 43 362 43 2622 46 2623 40 2143 41 43 362 43 2144 43 314 43 362 43 2145 43 314 43 362 43 2147 43 362 43 2622 46 2623 40 2148 41 43 362 43 2150 43 362 43 2151 43 362 43 2152 43 362 43 2153 43 314 43 362 43 2624 43 314 43 362 43 2154 43 314 43 362 43 2193 43 314 43 362 43 2195 43 314 43 362 43 2157 43 362 43 2161 43 362 43 2162 43 362 43 2164 43 362 43 2166 43 362 43 2168 43 362 43 2170 43 362 43 2171 43 362 43 2173 43 362 43 2175 43 362 43 2176 43 362 43 2177 43 362 43 2178 43 362 43 2180 43 362 43 2182 43 362 43 2184 43 362 43 2185 43 362 43 2622 46 2623 40 2186 41 43 362 43 2187 43 362 43 2188 43 362 43 2190 43 362 43 2192 43 362 59 125 125 ,"{'AvgLine': 8, 'CountLine': 1072, 'CountStmt': 389, 'MaxNesting': 4, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 254, 'MaxEssential': 5, 'SumEssential': 95, 'AvgCyclomatic': 1, 'CountLineCode': 787, 'CountStmtDecl': 157, 'MaxCyclomatic': 10, 'SumCyclomatic': 129, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 169, 'CountSemicolon': 275, 'CountDeclMethod': 68, 'CountLineCodeExe': 378, 'CountLineComment': 119, 'CountClassCoupled': 54, 'CountClassDerived': 2, 'CountLineCodeDecl': 330, 'CountDeclMethodAll': 88, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.15', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 141, 'CountDeclClassMethod': 1, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 60, 'MaxCyclomaticModified': 10, 'PercentLackOfCohesion': 95, 'SumCyclomaticModified': 129, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 6, 'CountDeclInstanceMethod': 67, 'CountDeclMethodProtected': 2, 'CountClassCoupledModified': 54, 'CountDeclInstanceVariable': 50, 'PercentLackOfCohesionModified': 92}"
3402,Java,"@Slf4j
public abstract class ChartView<T extends ChartViewModel<? extends ChartDataModel>> extends ActivatableViewAndModel<VBox, T> {
    private Pane center;
    private SplitPane timelineNavigation;
    protected NumberAxis xAxis, yAxis;
    protected LineChart<Number, Number> chart;
    private HBox timelineLabels, legendBox2;
    private final ToggleGroup timeIntervalToggleGroup = new ToggleGroup();

    protected final Set<XYChart.Series<Number, Number>> activeSeries = new HashSet<>();
    protected final Map<String, Integer> seriesIndexMap = new HashMap<>();
    protected final Map<String, AutoTooltipSlideToggleButton> legendToggleBySeriesName = new HashMap<>();
    private final List<Node> dividerNodes = new ArrayList<>();
    private final List<Tooltip> dividerNodesTooltips = new ArrayList<>();
    private ChangeListener<Number> widthListener;
    private ChangeListener<Toggle> timeIntervalChangeListener;
    private ListChangeListener<Node> nodeListChangeListener;
    private int maxSeriesSize;
    private boolean centerPanePressed;
    private double x;

    @Setter
    protected boolean isRadioButtonBehaviour;
    @Setter
    private int maxDataPointsForShowingSymbols = 100;
    private ChangeListener<Number> yAxisWidthListener;
    private EventHandler<MouseEvent> dividerMouseDraggedEventHandler;
    private final StringProperty fromProperty = new SimpleStringProperty();
    private final StringProperty toProperty = new SimpleStringProperty();


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    public ChartView(T model) {
        super(model);

        root = new VBox();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void initialize() {
        // We need to call prepareInitialize as we are not using FXMLLoader
        prepareInitialize();

        maxSeriesSize = 0;
        centerPanePressed = false;
        x = 0;

        // Series
        createSeries();

        // Time interval
        HBox timeIntervalBox = getTimeIntervalBox();

        // chart
        xAxis = getXAxis();
        yAxis = getYAxis();
        chart = getChart();

        // Timeline navigation
        addTimelineNavigation();

        // Legend
        HBox legendBox1 = initLegendsAndGetLegendBox(getSeriesForLegend1());

        Collection<XYChart.Series<Number, Number>> seriesForLegend2 = getSeriesForLegend2();
        if (seriesForLegend2 != null && !seriesForLegend2.isEmpty()) {
            legendBox2 = initLegendsAndGetLegendBox(seriesForLegend2);
        }

        // Set active series/legends
        defineAndAddActiveSeries();

        // Put all together
        VBox timelineNavigationBox = new VBox();
        double paddingLeft = 15;
        double paddingRight = 89;
        // Y-axis width depends on data so we register a listener to get correct value
        yAxisWidthListener = (observable, oldValue, newValue) -> {
            double width = newValue.doubleValue();
            if (width > 0) {
                double rightPadding = width + 14;
                VBox.setMargin(timeIntervalBox, new Insets(0, rightPadding, 0, paddingLeft));
                VBox.setMargin(timelineNavigation, new Insets(0, rightPadding, 0, paddingLeft));
                VBox.setMargin(timelineLabels, new Insets(0, rightPadding, 0, paddingLeft));
                VBox.setMargin(legendBox1, new Insets(10, rightPadding, 0, paddingLeft));
                if (legendBox2 != null) {
                    VBox.setMargin(legendBox2, new Insets(-20, rightPadding, 0, paddingLeft));
                }

                if (model.getDividerPositions()[0] == 0 && model.getDividerPositions()[1] == 1) {
                    resetTimeNavigation();
                }
            }
        };

        VBox.setMargin(timeIntervalBox, new Insets(0, paddingRight, 0, paddingLeft));
        VBox.setMargin(timelineNavigation, new Insets(0, paddingRight, 0, paddingLeft));
        VBox.setMargin(timelineLabels, new Insets(0, paddingRight, 0, paddingLeft));
        VBox.setMargin(legendBox1, new Insets(0, paddingRight, 0, paddingLeft));
        timelineNavigationBox.getChildren().addAll(timelineNavigation, timelineLabels, legendBox1);
        if (legendBox2 != null) {
            VBox.setMargin(legendBox2, new Insets(-20, paddingRight, 0, paddingLeft));
            timelineNavigationBox.getChildren().add(legendBox2);
        }
        root.getChildren().addAll(timeIntervalBox, chart, timelineNavigationBox);

        // Listeners
        widthListener = (observable, oldValue, newValue) -> {
            timelineNavigation.setDividerPosition(0, model.getDividerPositions()[0]);
            timelineNavigation.setDividerPosition(1, model.getDividerPositions()[1]);
        };

        timeIntervalChangeListener = (observable, oldValue, newValue) -> {
            if (newValue != null) {
                onTimeIntervalChanged(newValue);
            }
        };

        nodeListChangeListener = c -> {
            while (c.next()) {
                if (c.wasAdded()) {
                    c.getAddedSubList().stream()
                            .filter(node -> node instanceof Text)
                            .forEach(node -> node.getStyleClass().add(""axis-tick-mark-text-node""));
                }
            }
        };
    }

    @Override
    public void activate() {
        timelineNavigation.setDividerPositions(model.getDividerPositions()[0], model.getDividerPositions()[1]);

        TemporalAdjuster temporalAdjuster = model.getTemporalAdjuster();
        applyTemporalAdjuster(temporalAdjuster);
        findTimeIntervalToggleByTemporalAdjuster(temporalAdjuster).ifPresent(timeIntervalToggleGroup::selectToggle);

        defineAndAddActiveSeries();
        initBoundsForTimelineNavigation();

        // Apply listeners and handlers
        root.widthProperty().addListener(widthListener);
        xAxis.getChildrenUnmodifiable().addListener(nodeListChangeListener);
        yAxis.widthProperty().addListener(yAxisWidthListener);
        timeIntervalToggleGroup.selectedToggleProperty().addListener(timeIntervalChangeListener);

        timelineNavigation.setOnMousePressed(this::onMousePressedSplitPane);
        timelineNavigation.setOnMouseDragged(this::onMouseDragged);
        center.setOnMousePressed(this::onMousePressedCenter);
        center.setOnMouseReleased(this::onMouseReleasedCenter);

        addLegendToggleActionHandlers(getSeriesForLegend1());
        addLegendToggleActionHandlers(getSeriesForLegend2());
        addActionHandlersToDividers();
    }

    @Override
    public void deactivate() {
        root.widthProperty().removeListener(widthListener);
        xAxis.getChildrenUnmodifiable().removeListener(nodeListChangeListener);
        yAxis.widthProperty().removeListener(yAxisWidthListener);
        timeIntervalToggleGroup.selectedToggleProperty().removeListener(timeIntervalChangeListener);

        timelineNavigation.setOnMousePressed(null);
        timelineNavigation.setOnMouseDragged(null);
        center.setOnMousePressed(null);
        center.setOnMouseReleased(null);

        removeLegendToggleActionHandlers(getSeriesForLegend1());
        removeLegendToggleActionHandlers(getSeriesForLegend2());
        removeActionHandlersToDividers();

        // clear data, reset states. We keep timeInterval state though
        activeSeries.clear();
        chart.getData().clear();
        legendToggleBySeriesName.values().forEach(e -> e.setSelected(false));
        dividerNodes.clear();
        dividerNodesTooltips.clear();
        model.invalidateCache();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // TimeInterval/TemporalAdjuster
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected HBox getTimeIntervalBox() {
        ToggleButton year = getTimeIntervalToggleButton(Res.get(""time.year""), TemporalAdjusterModel.Interval.YEAR,
                timeIntervalToggleGroup, ""toggle-left"");
        ToggleButton month = getTimeIntervalToggleButton(Res.get(""time.month""), TemporalAdjusterModel.Interval.MONTH,
                timeIntervalToggleGroup, ""toggle-center"");
        ToggleButton week = getTimeIntervalToggleButton(Res.get(""time.week""), TemporalAdjusterModel.Interval.WEEK,
                timeIntervalToggleGroup, ""toggle-center"");
        ToggleButton day = getTimeIntervalToggleButton(Res.get(""time.day""), TemporalAdjusterModel.Interval.DAY,
                timeIntervalToggleGroup, ""toggle-center"");
        HBox toggleBox = new HBox();
        toggleBox.setSpacing(0);
        toggleBox.setAlignment(Pos.CENTER_LEFT);
        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        toggleBox.getChildren().addAll(spacer, year, month, week, day);
        return toggleBox;
    }

    private ToggleButton getTimeIntervalToggleButton(String label,
                                                     TemporalAdjusterModel.Interval interval,
                                                     ToggleGroup toggleGroup,
                                                     String style) {
        ToggleButton toggleButton = new AutoTooltipToggleButton(label);
        toggleButton.setUserData(interval);
        toggleButton.setToggleGroup(toggleGroup);
        toggleButton.setId(style);
        return toggleButton;
    }

    protected void applyTemporalAdjuster(TemporalAdjuster temporalAdjuster) {
        model.applyTemporalAdjuster(temporalAdjuster);
        findTimeIntervalToggleByTemporalAdjuster(temporalAdjuster)
                .map(e -> (TemporalAdjusterModel.Interval) e.getUserData())
                .ifPresent(model::setDateFormatPattern);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Chart
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected NumberAxis getXAxis() {
        NumberAxis xAxis = new NumberAxis();
        xAxis.setForceZeroInRange(false);
        xAxis.setAutoRanging(true);
        xAxis.setTickLabelFormatter(model.getTimeAxisStringConverter());
        return xAxis;
    }

    protected NumberAxis getYAxis() {
        NumberAxis yAxis = new NumberAxis();
        yAxis.setForceZeroInRange(true);
        yAxis.setSide(Side.RIGHT);
        yAxis.setTickLabelFormatter(model.getYAxisStringConverter());
        return yAxis;
    }

    // Add implementation if update of the y axis is required at series change
    protected void onSetYAxisFormatter(XYChart.Series<Number, Number> series) {
    }

    protected LineChart<Number, Number> getChart() {
        LineChart<Number, Number> chart = new LineChart<>(xAxis, yAxis);
        chart.setAnimated(false);
        chart.setLegendVisible(false);
        chart.setMinHeight(200);
        chart.setId(""charts-dao"");
        return chart;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Legend
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected HBox initLegendsAndGetLegendBox(Collection<XYChart.Series<Number, Number>> collection) {
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        collection.forEach(series -> {
            AutoTooltipSlideToggleButton toggle = new AutoTooltipSlideToggleButton();
            toggle.setMinWidth(200);
            toggle.setAlignment(Pos.TOP_LEFT);
            String seriesId = getSeriesId(series);
            legendToggleBySeriesName.put(seriesId, toggle);
            toggle.setText(seriesId);
            toggle.setId(""charts-legend-toggle"" + seriesIndexMap.get(seriesId));
            toggle.setSelected(false);
            hBox.getChildren().add(toggle);
        });
        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        hBox.getChildren().add(spacer);
        return hBox;
    }

    private void addLegendToggleActionHandlers(@Nullable Collection<XYChart.Series<Number, Number>> collection) {
        if (collection != null) {
            collection.forEach(series ->
                    legendToggleBySeriesName.get(getSeriesId(series)).setOnAction(e -> onSelectLegendToggle(series)));
        }
    }

    private void removeLegendToggleActionHandlers(@Nullable Collection<XYChart.Series<Number, Number>> collection) {
        if (collection != null) {
            collection.forEach(series ->
                    legendToggleBySeriesName.get(getSeriesId(series)).setOnAction(null));
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Timeline navigation
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void addTimelineNavigation() {
        Pane left = new Pane();
        center = new Pane();
        center.setId(""chart-navigation-center-pane"");
        Pane right = new Pane();
        timelineNavigation = new SplitPane(left, center, right);
        timelineNavigation.setDividerPositions(model.getDividerPositions()[0], model.getDividerPositions()[1]);
        timelineNavigation.setMinHeight(25);
        timelineLabels = new HBox();
    }

    // After initial chart data are created we apply the text from the x-axis ticks to our timeline navigation.
    protected void applyTimeLineNavigationLabels() {
        timelineLabels.getChildren().clear();
        ObservableList<Axis.TickMark<Number>> tickMarks = xAxis.getTickMarks();
        int size = tickMarks.size();
        for (int i = 0; i < size; i++) {
            Axis.TickMark<Number> tickMark = tickMarks.get(i);
            Number xValue = tickMark.getValue();
            String xValueString;
            if (xAxis.getTickLabelFormatter() != null) {
                xValueString = xAxis.getTickLabelFormatter().toString(xValue);
            } else {
                xValueString = String.valueOf(xValue);
            }
            Label label = new Label(xValueString);
            label.setMinHeight(30);
            label.setId(""chart-navigation-label"");
            Region spacer = new Region();
            HBox.setHgrow(spacer, Priority.ALWAYS);
            if (i < size - 1) {
                timelineLabels.getChildren().addAll(label, spacer);
            } else {
                // After last label we don't add a spacer
                timelineLabels.getChildren().add(label);
            }
        }
    }

    private void onMousePressedSplitPane(MouseEvent e) {
        x = e.getX();
        applyFromToDates();
        showDividerTooltips();
    }

    private void onMousePressedCenter(MouseEvent e) {
        centerPanePressed = true;
        applyFromToDates();
        showDividerTooltips();
    }

    private void onMouseReleasedCenter(MouseEvent e) {
        centerPanePressed = false;
        onTimelineChanged();
        hideDividerTooltips();
    }

    private void onMouseDragged(MouseEvent e) {
        if (centerPanePressed) {
            double newX = e.getX();
            double width = timelineNavigation.getWidth();
            double relativeDelta = (x - newX) / width;
            double leftPos = timelineNavigation.getDividerPositions()[0] - relativeDelta;
            double rightPos = timelineNavigation.getDividerPositions()[1] - relativeDelta;

            // Model might limit application of new values if we hit a boundary
            model.onTimelineMouseDrag(leftPos, rightPos);
            timelineNavigation.setDividerPositions(model.getDividerPositions()[0], model.getDividerPositions()[1]);
            x = newX;

            applyFromToDates();
            showDividerTooltips();
        }
    }

    private void addActionHandlersToDividers() {
        // No API access to dividers ;-( only via css lookup hack (https://stackoverflow.com/questions/40707295/how-to-add-listener-to-divider-position?rq=1)
        // Need to be done after added to scene and call requestLayout and applyCss. We keep it in a list atm
        // and set action handler in activate.
        timelineNavigation.requestLayout();
        timelineNavigation.applyCss();
        dividerMouseDraggedEventHandler = event -> {
            applyFromToDates();
            showDividerTooltips();
        };

        for (Node node : timelineNavigation.lookupAll("".split-pane-divider"")) {
            dividerNodes.add(node);
            node.setOnMouseReleased(e -> {
                hideDividerTooltips();
                onTimelineChanged();
            });
            node.addEventHandler(MouseEvent.MOUSE_DRAGGED, dividerMouseDraggedEventHandler);

            Tooltip tooltip = new Tooltip("""");
            dividerNodesTooltips.add(tooltip);
            tooltip.setShowDelay(Duration.millis(300));
            tooltip.setShowDuration(Duration.seconds(3));
            tooltip.textProperty().bind(dividerNodes.size() == 1 ? fromProperty : toProperty);
            Tooltip.install(node, tooltip);
        }
    }

    private void removeActionHandlersToDividers() {
        dividerNodes.forEach(node -> {
            node.setOnMouseReleased(null);
            node.removeEventHandler(MouseEvent.MOUSE_DRAGGED, dividerMouseDraggedEventHandler);
        });
        for (int i = 0; i < dividerNodesTooltips.size(); i++) {
            Tooltip tooltip = dividerNodesTooltips.get(i);
            tooltip.textProperty().unbind();
            Tooltip.uninstall(dividerNodes.get(i), tooltip);
        }
    }

    private void resetTimeNavigation() {
        timelineNavigation.setDividerPositions(0d, 1d);
        model.onTimelineNavigationChanged(0, 1);
    }

    private void showDividerTooltips() {
        showDividerTooltip(0);
        showDividerTooltip(1);
    }

    private void hideDividerTooltips() {
        dividerNodesTooltips.forEach(PopupWindow::hide);
    }

    private void showDividerTooltip(int index) {
        Node divider = dividerNodes.get(index);
        Bounds bounds = divider.localToScene(divider.getBoundsInLocal());
        Tooltip tooltip = dividerNodesTooltips.get(index);
        double xOffset = index == 0 ? -90 : 10;
        Stage stage = (Stage) root.getScene().getWindow();
        tooltip.show(stage, stage.getX() + bounds.getMaxX() + xOffset,
                stage.getY() + bounds.getMaxY() - 40);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Series
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected abstract void createSeries();

    protected abstract Collection<XYChart.Series<Number, Number>> getSeriesForLegend1();

    // If a second legend is used this has to be overridden
    protected Collection<XYChart.Series<Number, Number>> getSeriesForLegend2() {
        return null;
    }

    protected abstract void defineAndAddActiveSeries();

    protected void activateSeries(XYChart.Series<Number, Number> series) {
        if (activeSeries.contains(series)) {
            return;
        }

        chart.getData().add(series);
        activeSeries.add(series);
        legendToggleBySeriesName.get(getSeriesId(series)).setSelected(true);
        applyDataAndUpdate();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Data
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected abstract CompletableFuture<Boolean> applyData();

    private void applyDataAndUpdate() {
        long ts = System.currentTimeMillis();
        applyData().whenComplete((r, t) -> {
            log.debug(""applyData took {}"", System.currentTimeMillis() - ts);
            long ts2 = System.currentTimeMillis();
            updateChartAfterDataChange();
            log.debug(""updateChartAfterDataChange took {}"", System.currentTimeMillis() - ts2);

            onDataApplied();
        });
    }

    /**
     * Implementations define which series will be used for setBoundsForTimelineNavigation
     */
    protected abstract void initBoundsForTimelineNavigation();

    /**
     * @param   data The series data which determines the min/max x values for the time line navigation.
     *               If not applicable initBoundsForTimelineNavigation requires custom implementation.
     */
    protected void setBoundsForTimelineNavigation(ObservableList<XYChart.Data<Number, Number>> data) {
        model.initBounds(data);
        xAxis.setLowerBound(model.getLowerBound().doubleValue());
        xAxis.setUpperBound(model.getUpperBound().doubleValue());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Handlers triggering a data/chart update
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void onTimeIntervalChanged(Toggle newValue) {
        TemporalAdjusterModel.Interval interval = (TemporalAdjusterModel.Interval) newValue.getUserData();
        applyTemporalAdjuster(interval.getAdjuster());
        model.invalidateCache();
        applyDataAndUpdate();
    }

    private void onTimelineChanged() {
        updateTimeLinePositions();

        model.invalidateCache();
        applyDataAndUpdate();
    }

    private void updateTimeLinePositions() {
        double leftPos = timelineNavigation.getDividerPositions()[0];
        double rightPos = timelineNavigation.getDividerPositions()[1];
        model.onTimelineNavigationChanged(leftPos, rightPos);
        // We need to update as model might have adjusted the values
        timelineNavigation.setDividerPositions(model.getDividerPositions()[0], model.getDividerPositions()[1]);
        fromProperty.set(model.getTimeAxisStringConverter().toString(model.getFromDate()).replace(""\n"", "" ""));
        toProperty.set(model.getTimeAxisStringConverter().toString(model.getToDate()).replace(""\n"", "" ""));
    }

    private void applyFromToDates() {
        double leftPos = timelineNavigation.getDividerPositions()[0];
        double rightPos = timelineNavigation.getDividerPositions()[1];
        model.applyFromToDates(leftPos, rightPos);
        fromProperty.set(model.getTimeAxisStringConverter().toString(model.getFromDate()).replace(""\n"", "" ""));
        toProperty.set(model.getTimeAxisStringConverter().toString(model.getToDate()).replace(""\n"", "" ""));
    }

    private void onSelectLegendToggle(XYChart.Series<Number, Number> series) {
        boolean isSelected = legendToggleBySeriesName.get(getSeriesId(series)).isSelected();
        // If we have set that flag we deselect all other toggles
        if (isRadioButtonBehaviour) {
            new ArrayList<>(chart.getData()).stream() // We need to copy to a new list to avoid ConcurrentModificationException
                    .filter(activeSeries::contains)
                    .forEach(seriesToRemove -> {
                        chart.getData().remove(seriesToRemove);
                        String seriesId = getSeriesId(seriesToRemove);
                        activeSeries.remove(seriesToRemove);
                        legendToggleBySeriesName.get(seriesId).setSelected(false);
                    });
        }

        if (isSelected) {
            chart.getData().add(series);
            activeSeries.add(series);
            applyDataAndUpdate();

            if (isRadioButtonBehaviour) {
                // We support different y-axis formats only if isRadioButtonBehaviour is set, otherwise we would get
                // mixed data on y-axis
                onSetYAxisFormatter(series);
            }
        } else if (!isRadioButtonBehaviour) { // if isRadioButtonBehaviour we have removed it already via the code above
            chart.getData().remove(series);
            activeSeries.remove(series);
            updateChartAfterDataChange();
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Chart update after data change
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Update of the chart data can be triggered by:
    // 1. activate()
    // 2. TimeInterval toggle change
    // 3. Timeline navigation change
    // 4. Legend/series toggle change

    // Timeline navigation and legend/series toggles get reset at activate.
    // Time interval toggle keeps its state at screen changes.
    protected void updateChartAfterDataChange() {
        // If a series got no data points after update we need to clear it from the chart
        cleanupDanglingSeries();

        // Hides symbols if too many data points are created
        updateSymbolsVisibility();

        // When series gets added/removed the JavaFx charts framework would try to apply styles by the index of
        // addition, but we want to use a static color assignment which is synced with the legend color.
        applySeriesStyles();

        // Set tooltip on symbols
        applyTooltip();
    }

    private void cleanupDanglingSeries() {
        List<XYChart.Series<Number, Number>> activeSeriesList = new ArrayList<>(activeSeries);
        activeSeriesList.forEach(series -> {
            ObservableList<XYChart.Series<Number, Number>> seriesOnChart = chart.getData();
            if (series.getData().isEmpty()) {
                seriesOnChart.remove(series);
            } else if (!seriesOnChart.contains(series)) {
                seriesOnChart.add(series);
            }
        });
    }

    private void updateSymbolsVisibility() {
        maxDataPointsForShowingSymbols = 100;
        long numDataPoints = chart.getData().stream()
                .map(XYChart.Series::getData)
                .mapToLong(List::size)
                .max()
                .orElse(0);
        boolean prevValue = chart.getCreateSymbols();
        boolean newValue = numDataPoints < maxDataPointsForShowingSymbols;
        if (prevValue != newValue) {
            chart.setCreateSymbols(newValue);
        }
    }

    // The chart framework assigns the colored depending on the order it got added, but want to keep colors
    // the same so they match with the legend toggle.
    private void applySeriesStyles() {
        for (int index = 0; index < chart.getData().size(); index++) {
            XYChart.Series<Number, Number> series = chart.getData().get(index);
            int staticIndex = seriesIndexMap.get(getSeriesId(series));
            Set<Node> lines = getNodesForStyle(series.getNode(), "".default-color%d.chart-series-line"");
            Stream<Node> symbols = series.getData().stream().map(XYChart.Data::getNode)
                    .flatMap(node -> getNodesForStyle(node, "".default-color%d.chart-line-symbol"").stream());
            Stream.concat(lines.stream(), symbols).forEach(node -> {
                removeStyles(node);
                node.getStyleClass().add(""default-color"" + staticIndex);
            });
        }
    }

    private void applyTooltip() {
        chart.getData().forEach(series -> {
            series.getData().forEach(data -> {
                Node node = data.getNode();
                if (node == null) {
                    return;
                }
                String xValue = model.getTooltipDateConverter(data.getXValue());
                String yValue = model.getYAxisStringConverter().toString(data.getYValue());
                Tooltip.install(node, new Tooltip(Res.get(""dao.factsAndFigures.supply.chart.tradeFee.toolTip"", yValue, xValue)));
            });
        });
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void removeStyles(Node node) {
        for (int i = 0; i < getMaxSeriesSize(); i++) {
            node.getStyleClass().remove(""default-color"" + i);
        }
    }

    private Set<Node> getNodesForStyle(Node node, String style) {
        Set<Node> result = new HashSet<>();
        if (node != null) {
            for (int i = 0; i < getMaxSeriesSize(); i++) {
                result.addAll(node.lookupAll(String.format(style, i)));
            }
        }
        return result;
    }

    private int getMaxSeriesSize() {
        maxSeriesSize = Math.max(maxSeriesSize, chart.getData().size());
        return maxSeriesSize;
    }

    private Optional<Toggle> findTimeIntervalToggleByTemporalAdjuster(TemporalAdjuster adjuster) {
        return timeIntervalToggleGroup.getToggles().stream()
                .filter(toggle -> ((TemporalAdjusterModel.Interval) toggle.getUserData()).getAdjuster().equals(adjuster))
                .findAny();
    }

    // We use the name as id as there is no other suitable data inside series
    protected String getSeriesId(XYChart.Series<Number, Number> series) {
        return series.getName();
    }

    protected void mapToUserThread(Runnable command) {
        UserThread.execute(command);
    }

    protected void onDataApplied() {
        // Once we have data applied we need to call initBoundsForTimelineNavigation again
        if (model.upperBound.longValue() == 0) {
            initBoundsForTimelineNavigation();
        }
    }
}",1,64 2000 777 539 587 2001 60 2002 650 2003 60 63 650 2004 356 650 2005 60 2006 44 2002 62 123 773 2007 2008 59 773 2009 2010 59 775 2011 2012 44 2013 59 775 2014 60 2015 44 2015 62 2016 59 773 2017 2018 44 2019 59 773 657 2020 2021 61 744 2020 40 41 59 775 657 2022 60 2023 46 2024 60 2015 44 2015 356 2025 61 744 2026 60 62 40 41 59 775 657 2027 60 2028 44 2029 62 2030 61 744 2031 60 62 40 41 59 775 657 2027 60 2028 44 2032 62 2033 61 744 2031 60 62 40 41 59 773 657 2034 60 2035 62 2036 61 744 2037 60 62 40 41 59 773 657 2034 60 2038 62 2039 61 744 2037 60 62 40 41 59 773 2040 60 2015 62 2041 59 773 2040 60 2042 62 2043 59 773 2044 60 2035 62 2045 59 773 704 2046 59 773 570 2047 59 773 625 2048 59 64 2049 775 570 2050 59 64 2049 773 704 2051 61 1503 59 773 2040 60 2015 62 2052 59 773 2053 60 2054 62 2055 59 773 657 2056 2057 61 744 2058 40 41 59 773 657 2056 2059 61 744 2058 40 41 59 331 330 331 777 2001 40 2002 2060 41 123 818 40 2060 41 59 2061 61 744 2006 40 41 59 125 331 330 331 64 2062 777 865 2063 40 41 123 330 2064 40 41 59 2046 61 1500 59 2047 61 2065 59 2048 61 1500 59 330 2066 40 41 59 330 2017 2067 61 2068 40 41 59 330 2012 61 2069 40 41 59 2013 61 2070 40 41 59 2016 61 2071 40 41 59 330 2072 40 41 59 330 2017 2073 61 2074 40 2075 40 41 41 59 2076 60 2023 46 2024 60 2015 44 2015 356 2077 61 2078 40 41 59 688 40 2077 340 2079 307 33 2077 46 2080 40 41 41 123 2019 61 2074 40 2077 41 59 125 330 2081 40 41 59 330 2006 2082 61 744 2006 40 41 59 625 2083 61 1503 59 625 2084 61 1503 59 330 2052 61 40 2085 44 2086 44 2087 41 45 62 123 625 2088 61 2087 46 2089 40 41 59 688 40 2088 62 1500 41 123 625 2090 61 2088 43 1503 59 2006 46 2091 40 2067 44 744 2092 40 1500 44 2090 44 1500 44 2083 41 41 59 2006 46 2091 40 2010 44 744 2092 40 1500 44 2090 44 1500 44 2083 41 41 59 2006 46 2091 40 2018 44 744 2092 40 1500 44 2090 44 1500 44 2083 41 41 59 2006 46 2091 40 2073 44 744 2092 40 1502 44 2090 44 1500 44 2083 41 41 59 688 40 2019 340 2079 41 123 2006 46 2091 40 2019 44 744 2092 40 45 1503 44 2090 44 1500 44 2083 41 41 59 125 688 40 2060 46 2093 40 41 91 1500 93 323 1500 307 2060 46 2093 40 41 91 1501 93 323 1501 41 123 2094 40 41 59 125 125 125 59 2006 46 2095 40 2067 44 744 2096 40 1500 44 2084 44 1500 44 2083 41 41 59 2006 46 2095 40 2010 44 744 2096 40 1500 44 2084 44 1500 44 2083 41 41 59 2006 46 2095 40 2018 44 744 2096 40 1500 44 2084 44 1500 44 2083 41 41 59 2006 46 2095 40 2073 44 744 2096 40 1500 44 2084 44 1500 44 2083 41 41 59 2082 46 2097 40 41 46 2098 40 2010 44 2018 44 2073 41 59 688 40 2019 340 2079 41 123 2006 46 2095 40 2019 44 744 2096 40 45 1503 44 2084 44 1500 44 2083 41 41 59 2082 46 2097 40 41 46 2099 40 2019 41 59 125 2100 46 2097 40 41 46 2098 40 2067 44 2016 44 2082 41 59 330 2041 61 40 2085 44 2086 44 2087 41 45 62 123 2010 46 2101 40 1500 44 2060 46 2102 40 41 91 1500 93 41 59 2010 46 2101 40 1501 44 2060 46 2102 40 41 91 1501 93 41 59 125 59 2043 61 40 2085 44 2086 44 2087 41 45 62 123 688 40 2087 340 2079 41 123 2103 40 2087 41 59 125 125 59 2045 61 2104 45 62 123 870 40 2104 46 2105 40 41 41 123 688 40 2104 46 2106 40 41 41 123 2104 46 2107 40 41 46 2108 40 41 46 2109 40 2110 45 62 2110 702 2111 41 46 2112 40 2110 45 62 2110 46 2113 40 41 46 2114 40 362 41 41 59 125 125 125 59 125 64 2062 777 865 2115 40 41 123 2010 46 2116 40 2060 46 2117 40 41 91 1500 93 44 2060 46 2117 40 41 91 1501 93 41 59 2118 2119 61 2060 46 2120 40 41 59 2121 40 2119 41 59 2122 40 2119 41 46 2123 40 2021 58 58 2124 41 59 2125 40 41 59 2126 40 41 59 330 2127 46 2128 40 41 46 2129 40 2041 41 59 2012 46 2130 40 41 46 2129 40 2045 41 59 2013 46 2128 40 41 46 2129 40 2052 41 59 2021 46 2131 40 41 46 2129 40 2043 41 59 2010 46 2132 40 823 58 58 2133 41 59 2010 46 2134 40 823 58 58 2135 41 59 2008 46 2132 40 823 58 58 2136 41 59 2008 46 2137 40 823 58 58 2138 41 59 2139 40 2140 40 41 41 59 2139 40 2141 40 41 41 59 2142 40 41 59 125 64 2062 777 865 2143 40 41 123 2144 46 2145 40 41 46 2146 40 2041 41 59 2012 46 2147 40 41 46 2146 40 2045 41 59 2013 46 2145 40 41 46 2146 40 2052 41 59 2021 46 2148 40 41 46 2146 40 2043 41 59 2010 46 2149 40 2150 41 59 2010 46 2151 40 2150 41 59 2008 46 2149 40 2150 41 59 2008 46 2152 40 2150 41 59 2153 40 2154 40 41 41 59 2153 40 2155 40 41 41 59 2156 40 41 59 330 2025 46 2157 40 41 59 2016 46 2158 40 41 46 2157 40 41 59 2033 46 2159 40 41 46 2160 40 2161 45 62 2161 46 2162 40 2163 41 41 59 2036 46 2157 40 41 59 2039 46 2157 40 41 59 2060 46 2164 40 41 59 125 331 330 331 775 2017 2165 40 41 123 2166 2167 61 2168 40 2169 46 2170 40 362 41 44 2171 46 2172 46 2173 44 2021 44 362 41 59 2166 2174 61 2168 40 2169 46 2170 40 362 41 44 2171 46 2172 46 2175 44 2021 44 362 41 59 2166 2176 61 2168 40 2169 46 2170 40 362 41 44 2171 46 2172 46 2177 44 2021 44 362 41 59 2166 2178 61 2168 40 2169 46 2170 40 362 41 44 2171 46 2172 46 2179 44 2021 44 362 41 59 2017 2180 61 744 2017 40 41 59 2180 46 2181 40 1500 41 59 2180 46 2182 40 2183 46 2184 41 59 2185 2186 61 744 2185 40 41 59 2017 46 2187 40 2186 44 2188 46 2189 41 59 2180 46 2190 40 41 46 2191 40 2186 44 2167 44 2174 44 2176 44 2178 41 59 792 2180 59 125 773 2192 2193 40 2028 2194 44 2195 46 2196 2197 44 2020 2198 44 2028 2199 41 123 2192 2200 61 744 2201 40 2194 41 59 2200 46 2202 40 2197 41 59 2200 46 2203 40 2198 41 59 2200 46 2204 40 2199 41 59 792 2200 59 125 775 865 2205 40 2206 2207 41 123 2060 46 2205 40 2207 41 59 2208 40 2207 41 46 2209 40 2210 45 62 40 2195 46 2196 41 2210 46 2211 40 41 41 46 2212 40 2060 58 58 2213 41 59 125 331 330 331 775 2011 2214 40 41 123 2011 2012 61 744 2011 40 41 59 2012 46 2215 40 2216 41 59 2012 46 2217 40 2218 41 59 2012 46 2219 40 2060 46 2220 40 41 41 59 792 2012 59 125 775 2011 2221 40 41 123 2011 2013 61 744 2011 40 41 59 2013 46 2222 40 2223 41 59 2013 46 2224 40 2225 46 2226 41 59 2013 46 2227 40 2060 46 2228 40 41 41 59 792 2013 59 125 330 775 865 2229 40 2023 46 2024 60 2015 44 2015 62 2230 41 123 125 775 2014 60 2015 44 2015 62 2231 40 41 123 2014 60 2015 44 2015 62 2016 61 744 2014 60 62 40 2012 44 2013 41 59 2016 46 2232 40 2233 41 59 2016 46 2234 40 2233 41 59 2016 46 2235 40 1504 41 59 2016 46 2236 40 362 41 59 792 2016 59 125 331 330 331 775 2017 2237 40 2238 60 2023 46 2024 60 2015 44 2015 356 2239 41 123 2017 2240 61 744 2017 40 41 59 2240 46 2241 40 1502 41 59 2239 46 2242 40 2230 45 62 123 2032 2243 61 744 2032 40 41 59 2243 46 2244 40 1504 41 59 2243 46 2245 40 2246 46 2247 41 59 2028 2248 61 2249 40 2230 41 59 2033 46 2250 40 2248 44 2243 41 59 2243 46 2251 40 2248 41 59 2243 46 2252 40 362 43 2030 46 2253 40 2248 41 41 59 2243 46 2254 40 2255 41 59 2240 46 2256 40 41 46 2257 40 2243 41 59 125 41 59 2258 2259 61 744 2258 40 41 59 2017 46 2260 40 2259 44 2261 46 2262 41 59 2240 46 2263 40 41 46 2264 40 2259 41 59 792 2240 59 125 773 865 2265 40 64 2266 2238 60 2023 46 2024 60 2015 44 2015 356 2239 41 123 688 40 2239 340 2267 41 123 2239 46 2268 40 2230 45 62 2033 46 2269 40 2270 40 2230 41 41 46 2271 40 2272 45 62 2273 40 2230 41 41 41 59 125 125 773 865 2274 40 64 2266 2238 60 2023 46 2024 60 2015 44 2015 356 2239 41 123 688 40 2239 340 2275 41 123 2239 46 2276 40 2230 45 62 2033 46 2277 40 2278 40 2230 41 41 46 2279 40 2275 41 41 59 125 125 331 330 331 773 865 2280 40 41 123 2007 2281 61 744 2007 40 41 59 2008 61 744 2007 40 41 59 2008 46 2282 40 362 41 59 2007 2283 61 744 2007 40 41 59 2010 61 744 2009 40 2281 44 2008 44 2283 41 59 2010 46 2284 40 2060 46 2285 40 41 91 1500 93 44 2060 46 2285 40 41 91 1501 93 41 59 2010 46 2286 40 1503 41 59 2018 61 744 2017 40 41 59 125 330 775 865 2287 40 41 123 2018 46 2288 40 41 46 2289 40 41 59 2290 60 2291 46 2292 60 2015 356 2293 61 2012 46 2294 40 41 59 704 2295 61 2293 46 2295 40 41 59 664 40 704 2296 61 1500 59 2296 60 2295 59 2296 349 41 123 2291 46 2292 60 2015 62 2297 61 2293 46 2298 40 2296 41 59 2015 2299 61 2297 46 2300 40 41 59 2028 2301 59 688 40 2012 46 2302 40 41 340 2303 41 123 2301 61 2012 46 2302 40 41 46 2304 40 2299 41 59 125 630 123 2301 61 2028 46 2305 40 2299 41 59 125 2306 2194 61 744 2306 40 2301 41 59 2194 46 2307 40 1503 41 59 2194 46 2308 40 362 41 59 2309 2310 61 744 2309 40 41 59 2017 46 2311 40 2310 44 2312 46 2313 41 59 688 40 2296 60 2295 45 1501 41 123 2018 46 2288 40 41 46 2314 40 2194 44 2310 41 59 125 630 123 330 2018 46 2288 40 41 46 2315 40 2194 41 59 125 125 125 773 865 2316 40 2054 2317 41 123 2048 61 2317 46 2318 40 41 59 2319 40 41 59 2320 40 41 59 125 773 865 2321 40 2054 2317 41 123 2047 61 2322 59 2323 40 41 59 2324 40 41 59 125 773 865 2325 40 2054 2317 41 123 2047 61 2326 59 2327 40 41 59 2328 40 41 59 125 773 865 2329 40 2054 2317 41 123 688 40 2047 41 123 625 2330 61 2317 46 2331 40 41 59 625 2332 61 2010 46 2333 40 41 59 625 2334 61 40 2048 45 2330 41 47 2332 59 625 2335 61 2010 46 2336 40 41 91 1500 93 45 2334 59 625 2337 61 2010 46 2336 40 41 91 1501 93 45 2334 59 330 2060 46 2338 40 2335 44 2337 41 59 2010 46 2339 40 2060 46 2336 40 41 91 1500 93 44 2060 46 2336 40 41 91 1501 93 41 59 2048 61 2330 59 2340 40 41 59 2341 40 41 59 125 125 773 865 2342 40 41 123 330 330 330 2010 46 2343 40 41 59 2010 46 2344 40 41 59 2055 61 2345 45 62 123 2346 40 41 59 2347 40 41 59 125 59 664 40 2035 2348 58 2010 46 2349 40 362 41 41 123 2036 46 2350 40 2348 41 59 2348 46 2351 40 2317 45 62 123 2352 40 41 59 2353 40 41 59 125 41 59 2348 46 2354 40 2054 46 2355 44 2055 41 59 2038 2356 61 744 2038 40 362 41 59 2039 46 2350 40 2356 41 59 2356 46 2357 40 2358 46 2359 40 1504 41 41 59 2356 46 2360 40 2358 46 2361 40 1502 41 41 59 2356 46 2362 40 41 46 2363 40 2036 46 2364 40 41 323 1501 63 2057 58 2059 41 59 2038 46 2365 40 2348 44 2356 41 59 125 125 773 865 2366 40 41 123 2036 46 2367 40 2368 45 62 123 2368 46 2369 40 2370 41 59 2368 46 2371 40 2054 46 2372 44 2055 41 59 125 41 59 664 40 704 2373 61 1500 59 2373 60 2039 46 2374 40 41 59 2373 349 41 123 2038 2375 61 2039 46 2376 40 2373 41 59 2375 46 2377 40 41 46 2378 40 41 59 2038 46 2379 40 2036 46 2376 40 2373 41 44 2375 41 59 125 125 773 865 2380 40 41 123 2010 46 2381 40 1500 44 1501 41 59 2060 46 2382 40 1500 44 1501 41 59 125 773 865 2383 40 41 123 2384 40 1500 41 59 2384 40 1501 41 59 125 773 865 2385 40 41 123 2039 46 2386 40 2387 58 58 2388 41 59 125 773 865 2389 40 704 2390 41 123 2035 2391 61 2036 46 2392 40 2390 41 59 2393 2394 61 2391 46 2395 40 2391 46 2396 40 41 41 59 2038 2397 61 2039 46 2392 40 2390 41 59 625 2398 61 2390 323 1500 63 45 1503 58 1502 59 2399 2400 61 40 2399 41 2401 46 2402 40 41 46 2403 40 41 59 2397 46 2404 40 2400 44 2400 46 2405 40 41 43 2394 46 2406 40 41 43 2398 44 2400 46 2407 40 41 43 2394 46 2408 40 41 45 1503 41 59 125 331 330 331 775 539 865 2409 40 41 59 775 539 2238 60 2023 46 2024 60 2015 44 2015 356 2410 40 41 59 330 775 2238 60 2023 46 2024 60 2015 44 2015 356 2411 40 41 123 792 2412 59 125 775 539 865 2413 40 41 59 775 865 2414 40 2023 46 2024 60 2015 44 2015 62 2230 41 123 688 40 2025 46 2415 40 2230 41 41 123 792 59 125 2016 46 2416 40 41 46 2417 40 2230 41 59 2025 46 2417 40 2230 41 59 2033 46 2418 40 2419 40 2230 41 41 46 2420 40 2421 41 59 2422 40 41 59 125 331 330 331 775 539 2423 60 2424 62 2425 40 41 59 773 865 2426 40 41 123 726 2427 61 2428 46 2429 40 41 59 2425 40 41 46 2430 40 40 2431 44 2432 41 45 62 123 2433 46 2434 40 362 44 2428 46 2429 40 41 45 2427 41 59 726 2435 61 2428 46 2429 40 41 59 2436 40 41 59 2433 46 2434 40 362 44 2428 46 2429 40 41 45 2435 41 59 2437 40 41 59 125 41 59 125 306 775 539 865 2438 40 41 59 306 775 865 2439 40 2440 60 2023 46 2441 60 2015 44 2015 356 2442 41 123 2060 46 2443 40 2442 41 59 2012 46 2444 40 2060 46 2445 40 41 46 2446 40 41 41 59 2012 46 2447 40 2060 46 2448 40 41 46 2446 40 41 41 59 125 331 330 331 773 865 2449 40 2042 2450 41 123 2195 46 2196 2197 61 40 2195 46 2196 41 2450 46 2451 40 41 59 2205 40 2197 46 2452 40 41 41 59 2060 46 2453 40 41 59 2426 40 41 59 125 773 865 2454 40 41 123 2455 40 41 59 2060 46 2456 40 41 59 2426 40 41 59 125 773 865 2457 40 41 123 625 2458 61 2010 46 2459 40 41 91 1500 93 59 625 2460 61 2010 46 2459 40 41 91 1501 93 59 2060 46 2461 40 2458 44 2460 41 59 330 2010 46 2462 40 2060 46 2459 40 41 91 1500 93 44 2060 46 2459 40 41 91 1501 93 41 59 2057 46 2463 40 2060 46 2464 40 41 46 2465 40 2060 46 2466 40 41 41 46 2467 40 362 44 362 41 41 59 2059 46 2463 40 2060 46 2464 40 41 46 2465 40 2060 46 2468 40 41 41 46 2467 40 362 44 362 41 41 59 125 773 865 2469 40 41 123 625 2470 61 2010 46 2471 40 41 91 1500 93 59 625 2472 61 2010 46 2471 40 41 91 1501 93 59 2060 46 2469 40 2470 44 2472 41 59 2057 46 2473 40 2060 46 2474 40 41 46 2475 40 2060 46 2476 40 41 41 46 2477 40 362 44 362 41 41 59 2059 46 2473 40 2060 46 2474 40 41 46 2475 40 2060 46 2478 40 41 41 46 2477 40 362 44 362 41 41 59 125 773 865 2479 40 2023 46 2024 60 2015 44 2015 62 2230 41 123 570 2480 61 2033 46 2481 40 2482 40 2230 41 41 46 2480 40 41 59 330 688 40 2050 41 123 744 2037 60 62 40 2016 46 2483 40 41 41 46 2484 40 41 330 46 2485 40 2025 58 58 2486 41 46 2487 40 2488 45 62 123 2016 46 2483 40 41 46 2489 40 2488 41 59 2028 2490 61 2482 40 2488 41 59 2025 46 2489 40 2488 41 59 2033 46 2481 40 2490 41 46 2491 40 2492 41 59 125 41 59 125 688 40 2480 41 123 2016 46 2493 40 41 46 2494 40 2230 41 59 2025 46 2494 40 2230 41 59 2426 40 41 59 688 40 2050 41 123 330 330 2229 40 2230 41 59 125 125 630 688 40 33 2050 41 123 330 2016 46 2495 40 41 46 2496 40 2230 41 59 2025 46 2496 40 2230 41 59 2497 40 41 59 125 125 331 330 331 330 330 330 330 330 330 330 775 865 2498 40 41 123 330 2499 40 41 59 330 2500 40 41 59 330 330 2501 40 41 59 330 2502 40 41 59 125 773 865 2503 40 41 123 2034 60 2023 46 2024 60 2015 44 2015 356 2504 61 744 2037 60 62 40 2025 41 59 2504 46 2505 40 2230 45 62 123 2440 60 2023 46 2024 60 2015 44 2015 356 2506 61 2016 46 2507 40 41 59 688 40 2230 46 2507 40 41 46 2508 40 41 41 123 2506 46 2509 40 2230 41 59 125 630 688 40 33 2506 46 2510 40 2230 41 41 123 2506 46 2511 40 2230 41 59 125 125 41 59 125 773 865 2512 40 41 123 2051 61 1503 59 726 2513 61 2016 46 2514 40 41 46 2515 40 41 46 2516 40 2023 46 2024 58 58 2514 41 46 2517 40 2034 58 58 2518 41 46 2519 40 41 46 2520 40 1500 41 59 570 2521 61 2016 46 2522 40 41 59 570 2450 61 2513 60 2051 59 688 40 2521 340 2450 41 123 2016 46 2523 40 2450 41 59 125 125 330 330 773 865 2524 40 41 123 664 40 704 2390 61 1500 59 2390 60 2016 46 2525 40 41 46 2526 40 41 59 2390 349 41 123 2023 46 2024 60 2015 44 2015 62 2230 61 2016 46 2525 40 41 46 2527 40 2390 41 59 704 2528 61 2030 46 2527 40 2529 40 2230 41 41 59 2022 60 2035 62 2530 61 2531 40 2230 46 2532 40 41 44 362 41 59 2533 60 2035 62 2534 61 2230 46 2525 40 41 46 2535 40 41 46 2536 40 2023 46 2441 58 58 2532 41 46 2537 40 2538 45 62 2531 40 2538 44 362 41 46 2535 40 41 41 59 2533 46 2539 40 2530 46 2535 40 41 44 2534 41 46 2540 40 2538 45 62 123 2541 40 2538 41 59 2538 46 2542 40 41 46 2543 40 362 43 2528 41 59 125 41 59 125 125 773 865 2544 40 41 123 2016 46 2545 40 41 46 2546 40 2230 45 62 123 2230 46 2545 40 41 46 2546 40 2442 45 62 123 2035 2547 61 2442 46 2548 40 41 59 688 40 2547 323 2549 41 123 792 59 125 2028 2550 61 2060 46 2551 40 2442 46 2552 40 41 41 59 2028 2553 61 2060 46 2554 40 41 46 2555 40 2442 46 2556 40 41 41 59 2038 46 2557 40 2547 44 744 2038 40 2558 46 2559 40 362 44 2553 44 2550 41 41 41 59 125 41 59 125 41 59 125 331 330 331 773 865 2560 40 2035 2561 41 123 664 40 704 2562 61 1500 59 2562 60 2563 40 41 59 2562 349 41 123 2561 46 2564 40 41 46 2565 40 362 43 2562 41 59 125 125 773 2022 60 2035 62 2566 40 2035 2561 44 2028 2199 41 123 2022 60 2035 62 2567 61 744 2026 60 62 40 41 59 688 40 2561 340 2568 41 123 664 40 704 2569 61 1500 59 2569 60 2570 40 41 59 2569 349 41 123 2567 46 2571 40 2561 46 2572 40 2028 46 2573 40 2199 44 2569 41 41 41 59 125 125 792 2567 59 125 773 704 2574 40 41 123 2046 61 2575 46 2576 40 2046 44 2016 46 2577 40 41 46 2578 40 41 41 59 792 2046 59 125 773 2579 60 2042 62 2580 40 2206 2581 41 123 792 2021 46 2582 40 41 46 2583 40 41 46 2584 40 2585 45 62 40 40 2195 46 2196 41 2585 46 2586 40 41 41 46 2587 40 41 46 2588 40 2581 41 41 46 2589 40 41 59 125 330 775 2028 2590 40 2023 46 2024 60 2015 44 2015 62 2230 41 123 792 2230 46 2591 40 41 59 125 775 865 2592 40 2593 2594 41 123 2595 46 2596 40 2594 41 59 125 775 865 2597 40 41 123 330 688 40 2060 46 2598 46 2599 40 41 323 1500 41 123 2438 40 41 59 125 125 125 ,"{'AvgLine': 11, 'CountLine': 706, 'CountStmt': 406, 'MaxNesting': 2, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 325, 'MaxEssential': 1, 'SumEssential': 66, 'AvgCyclomatic': 1, 'CountLineCode': 516, 'CountStmtDecl': 148, 'MaxCyclomatic': 5, 'SumCyclomatic': 97, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 110, 'CountSemicolon': 327, 'CountDeclMethod': 52, 'CountLineCodeExe': 363, 'CountLineComment': 82, 'CountClassCoupled': 55, 'CountClassDerived': 3, 'CountLineCodeDecl': 157, 'CountDeclMethodAll': 67, 'MaxInheritanceTree': 5, 'RatioCommentToCode': '0.16', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 5, 'SumCyclomaticStrict': 99, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 4, 'MaxCyclomaticModified': 5, 'PercentLackOfCohesion': 92, 'SumCyclomaticModified': 97, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 28, 'CountDeclInstanceMethod': 52, 'CountDeclMethodProtected': 20, 'CountClassCoupledModified': 55, 'CountDeclInstanceVariable': 25, 'PercentLackOfCohesionModified': 88}"
2512,Java,"public final class InventoryBehavior extends Behavior {

    public InventoryBehavior(Baritone baritone) {
        super(baritone);
    }

    @Override
    public void onTick(TickEvent event) {
        if (!Baritone.settings().allowInventory.value) {
            return;
        }
        if (event.getType() == TickEvent.Type.OUT) {
            return;
        }
        if (ctx.player().openContainer != ctx.player().inventoryContainer) {
            // we have a crafting table or a chest or something open
            return;
        }
        if (firstValidThrowaway() >= 9) { // aka there are none on the hotbar, but there are some in main inventory
            swapWithHotBar(firstValidThrowaway(), 8);
        }
        int pick = bestToolAgainst(Blocks.STONE, ItemPickaxe.class);
        if (pick >= 9) {
            swapWithHotBar(pick, 0);
        }
    }

    public void attemptToPutOnHotbar(int inMainInvy, Predicate<Integer> disallowedHotbar) {
        OptionalInt destination = getTempHotbarSlot(disallowedHotbar);
        if (destination.isPresent()) {
            swapWithHotBar(inMainInvy, destination.getAsInt());
        }
    }

    public OptionalInt getTempHotbarSlot(Predicate<Integer> disallowedHotbar) {
        // we're using 0 and 8 for pickaxe and throwaway
        ArrayList<Integer> candidates = new ArrayList<>();
        for (int i = 1; i < 8; i++) {
            if (ctx.player().inventory.mainInventory.get(i).isEmpty() && !disallowedHotbar.test(i)) {
                candidates.add(i);
            }
        }
        if (candidates.isEmpty()) {
            for (int i = 1; i < 8; i++) {
                if (!disallowedHotbar.test(i)) {
                    candidates.add(i);
                }
            }
        }
        if (candidates.isEmpty()) {
            return OptionalInt.empty();
        }
        return OptionalInt.of(candidates.get(new Random().nextInt(candidates.size())));
    }

    private void swapWithHotBar(int inInventory, int inHotbar) {
        ctx.playerController().windowClick(ctx.player().inventoryContainer.windowId, inInventory < 9 ? inInventory + 36 : inInventory, inHotbar, ClickType.SWAP, ctx.player());
    }

    private int firstValidThrowaway() { // TODO offhand idk
        NonNullList<ItemStack> invy = ctx.player().inventory.mainInventory;
        for (int i = 0; i < invy.size(); i++) {
            if (Baritone.settings().acceptableThrowawayItems.value.contains(invy.get(i).getItem())) {
                return i;
            }
        }
        return -1;
    }

    private int bestToolAgainst(Block against, Class<? extends ItemTool> cla$$) {
        NonNullList<ItemStack> invy = ctx.player().inventory.mainInventory;
        int bestInd = -1;
        double bestSpeed = -1;
        for (int i = 0; i < invy.size(); i++) {
            ItemStack stack = invy.get(i);
            if (stack.isEmpty()) {
                continue;
            }
            if (Baritone.settings().itemSaver.value && (stack.getItemDamage() + Baritone.settings().itemSaverThreshold.value) >= stack.getMaxDamage() && stack.getMaxDamage() > 1) {
                continue;
            }
            if (cla$$.isInstance(stack.getItem())) {
                double speed = ToolSet.calculateSpeedVsBlock(stack, against.getDefaultState()); // takes into account enchants
                if (speed > bestSpeed) {
                    bestSpeed = speed;
                    bestInd = i;
                }
            }
        }
        return bestInd;
    }

    public boolean hasGenericThrowaway() {
        for (Item item : Baritone.settings().acceptableThrowawayItems.value) {
            if (throwaway(false, stack -> item.equals(stack.getItem()))) {
                return true;
            }
        }
        return false;
    }

    public boolean selectThrowawayForLocation(boolean select, int x, int y, int z) {
        IBlockState maybe = baritone.getBuilderProcess().placeAt(x, y, z, baritone.bsi.get0(x, y, z));
        if (maybe != null && throwaway(select, stack -> stack.getItem() instanceof ItemBlock && maybe.equals(((ItemBlock) stack.getItem()).getBlock().getStateForPlacement(ctx.world(), ctx.playerFeet(), EnumFacing.UP, (float) ctx.player().posX, (float) ctx.player().posY, (float) ctx.player().posZ, stack.getItem().getMetadata(stack.getMetadata()), ctx.player())))) {
            return true; // gotem
        }
        if (maybe != null && throwaway(select, stack -> stack.getItem() instanceof ItemBlock && ((ItemBlock) stack.getItem()).getBlock().equals(maybe.getBlock()))) {
            return true;
        }
        for (Item item : Baritone.settings().acceptableThrowawayItems.value) {
            if (throwaway(select, stack -> item.equals(stack.getItem()))) {
                return true;
            }
        }
        return false;
    }

    public boolean throwaway(boolean select, Predicate<? super ItemStack> desired) {
        return throwaway(select, desired, Baritone.settings().allowInventory.value);
    }

    public boolean throwaway(boolean select, Predicate<? super ItemStack> desired, boolean allowInventory) {
        EntityPlayerSP p = ctx.player();
        NonNullList<ItemStack> inv = p.inventory.mainInventory;
        for (int i = 0; i < 9; i++) {
            ItemStack item = inv.get(i);
            // this usage of settings() is okay because it's only called once during pathing
            // (while creating the CalculationContext at the very beginning)
            // and then it's called during execution
            // since this function is never called during cost calculation, we don't need to migrate
            // acceptableThrowawayItems to the CalculationContext
            if (desired.test(item)) {
                if (select) {
                    p.inventory.currentItem = i;
                }
                return true;
            }
        }
        if (desired.test(p.inventory.offHandInventory.get(0))) {
            // main hand takes precedence over off hand
            // that means that if we have block A selected in main hand and block B in off hand, right clicking places block B
            // we've already checked above ^ and the main hand can't possible have an acceptablethrowawayitem
            // so we need to select in the main hand something that doesn't right click
            // so not a shovel, not a hoe, not a block, etc
            for (int i = 0; i < 9; i++) {
                ItemStack item = inv.get(i);
                if (item.isEmpty() || item.getItem() instanceof ItemPickaxe) {
                    if (select) {
                        p.inventory.currentItem = i;
                    }
                    return true;
                }
            }
        }

        if (allowInventory) {
            for (int i = 9; i < 36; i++) {
                if (desired.test(inv.get(i))) {
                    swapWithHotBar(i, 7);
                    if (select) {
                        p.inventory.currentItem = 7;
                    }
                    return true;
                }
            }
        }

        return false;
    }
}",1,777 657 587 2000 650 2001 123 777 2000 40 2002 2003 41 123 818 40 2003 41 59 125 64 2004 777 865 2005 40 2006 2007 41 123 688 40 33 2002 46 2008 40 41 46 2009 46 2010 41 123 792 59 125 688 40 2007 46 2011 40 41 323 2006 46 2012 46 2013 41 123 792 59 125 688 40 2014 46 2015 40 41 46 2016 340 2014 46 2015 40 41 46 2017 41 123 330 792 59 125 688 40 2018 40 41 325 1502 41 123 330 2019 40 2018 40 41 44 1502 41 59 125 704 2020 61 2021 40 2022 46 2023 44 2024 46 587 41 59 688 40 2020 325 1502 41 123 2025 40 2020 44 1500 41 59 125 125 777 865 2026 40 704 2027 44 2028 60 2029 62 2030 41 123 2031 2032 61 2033 40 2030 41 59 688 40 2032 46 2034 40 41 41 123 2035 40 2027 44 2032 46 2036 40 41 41 59 125 125 777 2037 2038 40 2028 60 2029 62 2030 41 123 330 2039 60 2029 62 2040 61 744 2039 60 62 40 41 59 664 40 704 2041 61 1501 59 2041 60 1502 59 2041 349 41 123 688 40 2042 46 2043 40 41 46 2044 46 2045 46 2046 40 2041 41 46 2047 40 41 307 33 2030 46 2048 40 2041 41 41 123 2040 46 2049 40 2041 41 59 125 125 688 40 2040 46 2050 40 41 41 123 664 40 704 2041 61 1501 59 2041 60 1502 59 2041 349 41 123 688 40 33 2030 46 2051 40 2041 41 41 123 2040 46 2052 40 2041 41 59 125 125 125 688 40 2040 46 2050 40 41 41 123 792 2037 46 2053 40 41 59 125 792 2037 46 2054 40 2040 46 2055 40 744 2056 40 41 46 2057 40 2040 46 2058 40 41 41 41 41 59 125 773 865 2059 40 704 2060 44 704 2061 41 123 2062 46 2063 40 41 46 2064 40 2062 46 2065 40 41 46 2066 46 2067 44 2060 60 1502 63 2060 43 1503 58 2060 44 2061 44 2068 46 2069 44 2062 46 2065 40 41 41 59 125 773 704 2070 40 41 123 330 2071 60 2072 62 2073 61 2074 46 2075 40 41 46 2076 46 2077 59 664 40 704 2078 61 1500 59 2078 60 2073 46 2079 40 41 59 2078 349 41 123 688 40 2002 46 2080 40 41 46 2081 46 2082 46 2083 40 2073 46 2084 40 2078 41 46 2085 40 41 41 41 123 792 2078 59 125 125 792 45 1501 59 125 773 704 2086 40 2087 2088 44 2089 60 63 650 2090 62 2091 36 36 41 123 2092 60 2093 62 2094 61 2095 46 2096 40 41 46 2097 46 2098 59 704 2099 61 45 1501 59 625 2100 61 45 1501 59 664 40 704 2101 61 1500 59 2101 60 2094 46 2102 40 41 59 2101 349 41 123 2093 2103 61 2094 46 2104 40 2101 41 59 688 40 2103 46 2105 40 41 41 123 605 59 125 688 40 2002 46 2106 40 41 46 2107 46 2108 307 40 2103 46 2109 40 41 43 2002 46 2106 40 41 46 2110 46 2108 41 325 2103 46 2111 40 41 307 2103 46 2111 40 41 62 1501 41 123 605 59 125 688 40 2091 36 36 46 2112 40 2103 46 2113 40 41 41 41 123 625 2114 61 2115 46 2116 40 2103 44 2088 46 2117 40 41 41 59 330 688 40 2114 62 2100 41 123 2100 61 2114 59 2099 61 2101 59 125 125 125 792 2099 59 125 777 570 2118 40 41 123 664 40 2119 2120 58 2002 46 2121 40 41 46 2122 46 2123 41 123 688 40 2124 40 2125 44 2126 45 62 2120 46 2127 40 2126 46 2128 40 41 41 41 41 123 792 2129 59 125 125 792 2130 59 125 777 570 2131 40 570 2132 44 704 2133 44 704 2134 44 704 2135 41 123 2136 2137 61 2003 46 2138 40 41 46 2139 40 2133 44 2134 44 2135 44 2003 46 2140 46 2141 40 2133 44 2134 44 2135 41 41 59 688 40 2137 340 2142 307 2143 40 2132 44 2144 45 62 2144 46 2145 40 41 702 2146 307 2137 46 2147 40 40 40 2146 41 2144 46 2145 40 41 41 46 2148 40 41 46 2149 40 2150 46 2151 40 41 44 2150 46 2152 40 41 44 2153 46 2154 44 40 660 41 2150 46 2155 40 41 46 2156 44 40 660 41 2150 46 2155 40 41 46 2157 44 40 660 41 2150 46 2155 40 41 46 2158 44 2144 46 2145 40 41 46 2159 40 2144 46 2159 40 41 41 44 2150 46 2155 40 41 41 41 41 41 123 792 2160 59 330 125 688 40 2137 340 2142 307 2143 40 2132 44 2144 45 62 2144 46 2145 40 41 702 2146 307 40 40 2146 41 2144 46 2145 40 41 41 46 2148 40 41 46 2147 40 2137 46 2148 40 41 41 41 41 123 792 2161 59 125 664 40 2162 2163 58 2002 46 2164 40 41 46 2165 46 2166 41 123 688 40 2143 40 2132 44 2144 45 62 2163 46 2147 40 2144 46 2145 40 41 41 41 41 123 792 2167 59 125 125 792 2168 59 125 777 570 2169 40 570 2132 44 2028 60 63 818 2170 62 2171 41 123 792 2169 40 2132 44 2171 44 2002 46 2172 40 41 46 2173 46 2174 41 59 125 777 570 2169 40 570 2132 44 2028 60 63 818 2170 62 2171 44 570 2175 41 123 2176 2177 61 2178 46 2179 40 41 59 2180 60 2170 62 2181 61 2177 46 2182 46 2183 59 664 40 704 2184 61 1500 59 2184 60 1502 59 2184 349 41 123 2170 2185 61 2181 46 2186 40 2184 41 59 330 330 330 330 330 688 40 2171 46 2187 40 2185 41 41 123 688 40 2132 41 123 2177 46 2182 46 2188 61 2184 59 125 792 2189 59 125 125 688 40 2171 46 2190 40 2177 46 2182 46 2191 46 2192 40 1500 41 41 41 123 330 330 330 330 330 664 40 704 2184 61 1500 59 2184 60 1502 59 2184 349 41 123 2170 2193 61 2181 46 2192 40 2184 41 59 688 40 2193 46 2194 40 41 309 2193 46 2195 40 41 702 2196 41 123 688 40 2132 41 123 2177 46 2182 46 2197 61 2184 59 125 792 2198 59 125 125 125 688 40 2175 41 123 664 40 704 2184 61 1502 59 2184 60 1503 59 2184 349 41 123 688 40 2171 46 2190 40 2181 46 2192 40 2184 41 41 41 123 2059 40 2184 44 1502 41 59 688 40 2132 41 123 2177 46 2182 46 2199 61 1502 59 125 792 2200 59 125 125 125 792 2201 59 125 125 ,"{'AvgLine': 14, 'CountLine': 170, 'CountStmt': 112, 'MaxNesting': 4, 'AvgLineCode': 13, 'AvgEssential': 3, 'AvgLineBlank': 0, 'CountStmtExe': 88, 'MaxEssential': 9, 'SumEssential': 37, 'AvgCyclomatic': 4, 'CountLineCode': 145, 'CountStmtDecl': 35, 'MaxCyclomatic': 12, 'SumCyclomatic': 52, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 13, 'CountSemicolon': 62, 'CountDeclMethod': 11, 'CountLineCodeExe': 84, 'CountLineComment': 16, 'CountClassCoupled': 26, 'CountClassDerived': 0, 'CountLineCodeDecl': 27, 'CountDeclMethodAll': 12, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.11', 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 13, 'SumCyclomaticStrict': 60, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 4, 'CountDeclMethodPublic': 8, 'MaxCyclomaticModified': 12, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 52, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 3, 'CountDeclInstanceMethod': 11, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 26, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
26170,Java,"public final class Formulas {
    public static final byte SHIELD_DEFENSE_FAILED = 0; // no shield defense
    public static final byte SHIELD_DEFENSE_SUCCEED = 1; // normal shield defense
    public static final byte SHIELD_DEFENSE_PERFECT_BLOCK = 2; // perfect block
    public static final int SKILL_LAUNCH_TIME = 500; // The time to pass after the skill launching until the skill to affect targets. In milliseconds
    /**
     * Regeneration Task period.
     */
    private static final int HP_REGENERATE_PERIOD = 3000; // 3 secsEa
    private static final byte MELEE_ATTACK_RANGE = 40;

    /**
     * Return the period between 2 regeneration task (3s for Creature, 5 min for Door).
     */
    public static int getRegeneratePeriod(Creature cha) {
        return isDoor(cha) ? HP_REGENERATE_PERIOD * 100 : HP_REGENERATE_PERIOD;
    }

    public static double calcBlowDamage(Creature attacker, Creature target, Skill skill, double power) {
        double defence = target.getPDef();

        switch (calcShldUse(attacker, target)) {
            case SHIELD_DEFENSE_SUCCEED -> defence += target.getShldDef();
            case SHIELD_DEFENSE_PERFECT_BLOCK -> {
                return 1;
            }
        }

        // Critical
        final var position = Position.getPosition(attacker, target);
        final var criticalMod = attacker.getStats().getValue(Stat.CRITICAL_DAMAGE, 1);
        final var criticalPositionMod = attacker.getStats().getPositionTypeValue(Stat.CRITICAL_DAMAGE, position);
        final var criticalVulnMod = target.getStats().getValue(Stat.DEFENCE_CRITICAL_DAMAGE, 1);
        final var criticalAddMod = attacker.getStats().getValue(Stat.CRITICAL_DAMAGE_ADD, 0);
        final var criticalAddVuln = target.getStats().getValue(Stat.DEFENCE_CRITICAL_DAMAGE_ADD, 0);

        // Trait, elements
        final var weaponTraitMod = calcWeaponTraitBonus(attacker, target);
        final var generalTraitMod = calcGeneralTraitBonus(attacker, target, skill.getTrait(), true);
        final var weaknessMod = calcWeaknessBonus(attacker, target, skill.getTrait());
        final var attributeMod = calcAttributeBonus(attacker, target, skill);
        final var randomMod = attacker.getRandomDamageMultiplier();
        final var pvpPveMod = calculatePvpPveBonus(attacker, target, skill);

        // Initial damage
        final var ssmod = attacker.chargedShotBonus(ShotType.SOULSHOTS); // + 0.04 for dual weapon?
        final var cdMult = criticalMod * (((criticalPositionMod - 1) / 2) + 1) * (((criticalVulnMod - 1) / 2) + 1);
        final var cdPatk = criticalAddMod - criticalAddVuln;
        final var positionMod = position == Position.BACK ? 0.2 : position == Position.SIDE ? 0.05 : 0;

        // ........................_____________________________Initial Damage____________________________...___________Position Additional Damage___________..._CriticalAdd_
        // ATTACK CALCULATION 77 * [(skillpower+patk) * 0.666 * cdbonus * cdPosBonusHalf * cdVulnHalf * ss + isBack0.2Side0.05 * (skillpower+patk*ss) * random + 6 * cd_patk] / pdef
        // ````````````````````````^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^```^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^```^^^^^^^^^^^^
        final var baseMod = (77 * (((power + attacker.getPAtk()) * 0.666) + (positionMod * (power + attacker.getPAtk()) * randomMod) + (6 * cdPatk))) / defence;
        return baseMod * ssmod * cdMult * weaponTraitMod * generalTraitMod * weaknessMod * attributeMod * randomMod * pvpPveMod;
    }

    public static double calcMagicDam(Creature attacker, Creature target, Skill skill, double mAtk, double power, double mDef, boolean mcrit) {

        var shotsBonus = skill.useSpiritShot() ? attacker.chargedShotBonus(ShotType.SPIRITSHOTS) : 1;
        final double critMod = mcrit ? calcCritDamage(attacker, target, skill) : 1; // TODO not really a proper way... find how it works then implement. // damage += attacker.getStat().getValue(Stats.MAGIC_CRIT_DMG_ADD, 0);

        // Trait, elements
        final double generalTraitMod = calcGeneralTraitBonus(attacker, target, skill.getTrait(), true);
        final double weaknessMod = calcWeaknessBonus(attacker, target, skill.getTrait());
        final double attributeMod = calcAttributeBonus(attacker, target, skill);
        final double randomMod = attacker.getRandomDamageMultiplier();
        final double pvpPveMod = calculatePvpPveBonus(attacker, target, skill);

        // MDAM Formula.
        double damage = ( (77 *  attacker.getStats().getValue(Stat.MAGICAL_SKILL_POWER, power)  * Math.sqrt(mAtk) ) / mDef) * shotsBonus;

        // Failure calculation
        if (CharacterSettings.magicFailureAllowed() && !calcMagicSuccess(attacker, target)) {
            if (isPlayer(attacker)) {
                if (calcMagicSuccess(attacker, target)) {
                    if (skill.hasAnyEffectType(EffectType.HP_DRAIN)) {
                        attacker.sendPacket(SystemMessageId.DRAIN_WAS_ONLY_50_SUCCESSFUL);
                    } else {
                        attacker.sendPacket(SystemMessageId.YOUR_ATTACK_HAS_FAILED);
                    }
                    damage /= 2;
                } else {
                    final SystemMessage sm = getSystemMessage(SystemMessageId.C1_HAS_RESISTED_YOUR_S2);
                    sm.addString(target.getName());
                    sm.addSkillName(skill);
                    attacker.sendPacket(sm);
                    damage = 1;
                }
            }

            if (isPlayer(target)) {
                final SystemMessage sm = (skill.hasAnyEffectType(EffectType.HP_DRAIN)) ? getSystemMessage(SystemMessageId.YOU_RESISTED_C1_S_DRAIN) : getSystemMessage(SystemMessageId.YOU_RESISTED_C1_S_MAGIC);
                sm.addString(attacker.getName());
                target.sendPacket(sm);
            }
        }

        return damage * critMod * generalTraitMod * weaknessMod * attributeMod * randomMod * pvpPveMod;
    }

    /**
     * Returns true in case of critical hit
     */
    public static boolean calcCrit(double rate, Creature activeChar, Creature target, Skill skill) {
        // Skill critical rate is calculated up to the first decimal, thats why multiply by 10 and compare to 1000.
        if (skill != null) {
            // Magic Critical Rate
            if (skill.isMagic()) {
                rate += activeChar.getStats().getValue(Stat.MAGIC_CRITICAL_RATE);
                if ((target == null) || !skill.isBad()) {
                    return Math.min(rate, 320) > Rnd.get(1000);
                }

                double finalRate = target.getStats().getValue(Stat.DEFENCE_MAGIC_CRITICAL_RATE, rate) + target.getStats().getValue(Stat.DEFENCE_MAGIC_CRITICAL_RATE_ADD, 0);
                if ((activeChar.getLevel() >= 78) && (target.getLevel() >= 78)) {
                    finalRate += Math.sqrt(activeChar.getLevel()) + ((activeChar.getLevel() - target.getLevel()) / 25.);
                    return Math.min(finalRate, 320) > Rnd.get(1000);
                }

                return Math.min(finalRate, 200) > Rnd.get(1000);
            }

            // Physical skill critical rate
            final double statBonus;

            // There is a chance that activeChar has altered base stat for skill critical.
            byte skillCritRateStat = (byte) activeChar.getStats().getValue(Stat.STAT_BONUS_SKILL_CRITICAL);
            if ((skillCritRateStat >= 0) && (skillCritRateStat < BaseStats.values().length)) {
                // Best tested
                statBonus = BaseStats.values()[skillCritRateStat].calcBonus(activeChar);
            } else {
                // Default base stat used for skill critical formula is STR.
                statBonus = BaseStats.STR.calcBonus(activeChar);
            }

            final double rateBonus = activeChar.getStats().getValue(Stat.CRITICAL_RATE_SKILL, 1);
            double finalRate = rate * statBonus * rateBonus * 10;
            return finalRate > Rnd.get(1000);
        }

        // Autoattack critical rate.
        // Even though, visible critical rate is capped to 500, you can reach higher than 50% chance with position and level modifiers.
        // TODO: Find retail-like calculation for criticalRateMod.
        final double criticalRateMod = (target.getStats().getValue(Stat.DEFENCE_CRITICAL_RATE, rate) + target.getStats().getValue(Stat.DEFENCE_CRITICAL_RATE_ADD, 0)) / 10;
        final double criticalLocBonus = calcCriticalPositionBonus(activeChar, target);
        final double criticalHeightBonus = calcCriticalHeightBonus(activeChar, target);
        rate = criticalLocBonus * criticalRateMod * criticalHeightBonus;

        // Autoattack critical depends on level difference at high levels as well.
        if ((activeChar.getLevel() >= 78) || (target.getLevel() >= 78)) {
            rate += (Math.sqrt(activeChar.getLevel()) * (activeChar.getLevel() - target.getLevel()) * 0.125);
        }

        // Autoattack critical rate is limited between 3%-97%.
        rate = CommonUtil.constrain(rate, 3, 97);

        return rate > Rnd.get(100);
    }

    /**
     * Gets the default (10% for side, 30% for back) positional critical rate bonus and multiplies it by any buffs that give positional critical rate bonus.
     *
     * @param creature the attacker.
     * @param target     the target.
     * @return a multiplier representing the positional critical rate bonus. Autoattacks for example get this bonus on top of the already capped critical rate of 500.
     */
    public static double calcCriticalPositionBonus(Creature creature, Creature target) {
        return switch (Position.getPosition(creature, target)) {
            case SIDE -> 1.1 * creature.getStats().getPositionTypeValue(Stat.CRITICAL_RATE, Position.SIDE);
            case BACK -> 1.3 * creature.getStats().getPositionTypeValue(Stat.CRITICAL_RATE, Position.BACK);
            default -> creature.getStats().getPositionTypeValue(Stat.CRITICAL_RATE, Position.FRONT);
        };
    }

    public static double calcCriticalHeightBonus(ILocational from, ILocational target) {
        return ((((CommonUtil.constrain(from.getZ() - target.getZ(), -25, 25) * 4) / 5d) + 10) / 100) + 1;
    }

    /**
     * @param skill    {@code skill} to be used in the calculation, else calculation will result for autoattack.
     * @return regular critical damage bonus. Positional bonus is excluded!
     */
    public static double calcCritDamage(Creature attacker, Creature target, Skill skill) {
        final double criticalDamage;
        final double defenceCriticalDamage;

        if (skill != null) {
            if (skill.isMagic()) {
                // Magic critical damage.
                criticalDamage = attacker.getStats().getValue(Stat.MAGIC_CRITICAL_DAMAGE, 1);
                defenceCriticalDamage = target.getStats().getValue(Stat.DEFENCE_MAGIC_CRITICAL_DAMAGE, 1);
            } else {
                criticalDamage = attacker.getStats().getValue(Stat.CRITICAL_DAMAGE_SKILL, 1);
                defenceCriticalDamage = target.getStats().getValue(Stat.DEFENCE_CRITICAL_DAMAGE_SKILL, 1);
            }
        } else {
            // Autoattack critical damage.
            criticalDamage = attacker.getStats().getValue(Stat.CRITICAL_DAMAGE, 1) * attacker.getStats().getPositionTypeValue(Stat.CRITICAL_DAMAGE, Position.getPosition(attacker, target));
            defenceCriticalDamage = target.getStats().getValue(Stat.DEFENCE_CRITICAL_DAMAGE, 1);
        }

        return Math.max(1, 2 + (criticalDamage - defenceCriticalDamage));
    }

    /**
     * @param skill    {@code skill} to be used in the calculation, else calculation will result for autoattack.
     * @return critical damage additional bonus, not multiplier!
     */
    public static double calcCritDamageAdd(Creature attacker, Creature target, Skill skill) {
        final double criticalDamageAdd;
        final double defenceCriticalDamageAdd;

        if (skill != null) {
            if (skill.isMagic()) {
                // Magic critical damage.
                criticalDamageAdd = attacker.getStats().getValue(Stat.MAGIC_CRITICAL_DAMAGE_ADD, 0);
                defenceCriticalDamageAdd = target.getStats().getValue(Stat.DEFENCE_MAGIC_CRITICAL_DAMAGE_ADD, 0);
            } else {
                criticalDamageAdd = attacker.getStats().getValue(Stat.CRITICAL_DAMAGE_SKILL_ADD, 0);
                defenceCriticalDamageAdd = target.getStats().getValue(Stat.DEFENCE_CRITICAL_DAMAGE_SKILL_ADD, 0);
            }
        } else {
            // Autoattack critical damage.
            criticalDamageAdd = attacker.getStats().getValue(Stat.CRITICAL_DAMAGE_ADD, 0);
            defenceCriticalDamageAdd = target.getStats().getValue(Stat.DEFENCE_CRITICAL_DAMAGE_ADD, 0);
        }

        return criticalDamageAdd + defenceCriticalDamageAdd;
    }

    /**
     * @return true in case when ATTACK is canceled due to hit
     */
    public static boolean calcAtkBreak(Creature target, double dmg) {
        if (target.isChanneling() || target.isRaid() || target.isHpBlocked()) {
            return false;
        }

        double init = 0;

        if (CharacterSettings.breakCast() && target.isCastingNow(SkillCaster::canAbortCast)) {
            init = 15;
        } else if (CharacterSettings.breakBowAttack() && target.isAttackingNow()) {
            final Weapon wpn = target.getActiveWeaponItem();
            if (nonNull(wpn) && wpn.getItemType() == WeaponType.BOW) {
                init = 15;
            }
        }

        if (init <= 0) {
            return false; // No attack break
        }

        // Chance of break is higher with higher dmg
        init += Math.sqrt(13 * dmg);

        // Chance is affected by target MEN
        init -= ((BaseStats.MEN.calcBonus(target) * 100) - 100);

        // Calculate all modifiers for ATTACK_CANCEL
        double rate = target.getStats().getValue(Stat.ATTACK_CANCEL, init);

        // Adjust the rate to be between 1 and 99
        rate = max(Math.min(rate, 99), 1);

        return Rnd.chance(rate);
    }

    public static int calcAtkSpd(Creature attacker, Skill skill) {
        if (skill.isMagic()) {
            return (int) (((double)skill.getCoolTime() / attacker.getMAtkSpd()) * 333);
        }
        return (int) (((double)skill.getCoolTime() / attacker.getPAtkSpd()) * 300);
    }

    public static double calcAtkSpdMultiplier(Creature creature) {
        double armorBonus = 1; // EquipedArmorSpeedByCrystal TODO: Implement me!
        double dexBonus = BaseStats.DEX.calcBonus(creature);
        double weaponAttackSpeed = Stat.weaponBaseValue(creature, Stat.PHYSICAL_ATTACK_SPEED) / armorBonus; // unk868
        double attackSpeedPerBonus = creature.getStats().getMul(Stat.PHYSICAL_ATTACK_SPEED);
        double attackSpeedDiffBonus = creature.getStats().getAdd(Stat.PHYSICAL_ATTACK_SPEED);
        return (dexBonus * (weaponAttackSpeed / 333) * attackSpeedPerBonus) + (attackSpeedDiffBonus / 333);
    }

    public static double calcMAtkSpdMultiplier(Creature creature) {
        final double armorBonus = 1; // TODO: Implement me!
        final double witBonus = BaseStats.WIT.calcBonus(creature);
        final double castingSpeedPerBonus = creature.getStats().getMul(Stat.MAGIC_ATTACK_SPEED);
        final double castingSpeedDiffBonus = creature.getStats().getAdd(Stat.MAGIC_ATTACK_SPEED);
        return ((1 / armorBonus) * witBonus * castingSpeedPerBonus) + (castingSpeedDiffBonus / 333);
    }

    /**
     * @return factor divisor for skill hit time and cancel time.
     */
    public static double calcSkillTimeFactor(Creature creature, Skill skill) {
        if (skill.isChanneling() || skill.getSkillType() == SkillType.STATIC) {
            return 1.0d;
        }

        double factor;
        if (skill.getSkillType() == SkillType.MAGIC) {
            final double spiritshotHitTime = creature.isChargedShot(ShotType.SPIRITSHOTS) ? 0.4 : 0; // TODO: Implement proper values
            // matkspdmul + (matkspdmul * spiritshot_hit_time)
            factor = creature.getStats().getMAttackSpeedMultiplier() + (creature.getStats().getMAttackSpeedMultiplier() * spiritshotHitTime);
        } else {
            factor = creature.getAttackSpeedMultiplier();
        }

        if (creature instanceof Npc npc ) {
            double npcFactor = npc.getTemplate().getHitTimeFactorSkill();
            if (npcFactor > 0) {
                factor /= npcFactor;
            }
        }
        return max(0.01, factor);
    }

    public static double calcSkillCancelTime(Creature creature, Skill skill) {
        return max((skill.getHitCancelTime() * 1000) / calcSkillTimeFactor(creature, skill), SKILL_LAUNCH_TIME);
    }

    /**
     * Formula based on http://l2p.l2wh.com/nonskillattacks.html
     *
     * @return {@code true} if hit missed (target evaded), {@code false} otherwise.
     */
    public static boolean calcHitMiss(Creature attacker, Creature target) {
        int chance = (80 + (2 * (attacker.getAccuracy() - target.getEvasionRate()))) * 10;

        chance = (int) (chance * HitConditionBonusData.getInstance().getConditionBonus(attacker, target));

        chance = max(chance, 200);
        chance = Math.min(chance, 980);

        return chance < Rnd.get(1000);
    }

    /**
     * Returns:<br>
     * 0 = shield defense doesn't succeed<br>
     * 1 = shield defense succeed<br>
     * 2 = perfect block<br>
     */
    public static byte calcShldUse(Creature attacker, Creature target, boolean sendSysMsg) {
        final ItemTemplate item = target.getSecondaryWeaponItem();
        if (!(item instanceof Armor) || (((Armor) item).getItemType() == ArmorType.SIGIL)) {
            return 0;
        }

        double shldRate = target.getStats().getValue(Stat.SHIELD_DEFENCE_RATE) * BaseStats.DEX.calcBonus(target);

        // if attacker use bow and target wear shield, shield block rate is multiplied by 1.3 (30%)
        if (attacker.getAttackType().isRanged()) {
            shldRate *= 1.3;
        }

        final int degreeside = target.isAffected(EffectFlag.PHYSICAL_SHIELD_ANGLE_ALL) ? 360 : 120;
        if ((degreeside < 360) && (abs(target.calculateDirectionTo(attacker) - convertHeadingToDegree(target.getHeading())) > (degreeside / 2.))) {
            return 0;
        }

        byte shldSuccess = SHIELD_DEFENSE_FAILED;

        // Check shield success
        if (shldRate > Rnd.get(100)) {
            // If shield succeed, check perfect block.
            if (((100 - (2 * BaseStats.DEX.calcBonus(target))) < Rnd.get(100))) {
                shldSuccess = SHIELD_DEFENSE_PERFECT_BLOCK;
            } else {
                shldSuccess = SHIELD_DEFENSE_SUCCEED;
            }
        }

        if (sendSysMsg && isPlayer(target)) {
            final Player enemy = target.getActingPlayer();

            if (shldSuccess == SHIELD_DEFENSE_SUCCEED) {
                enemy.sendPacket(SystemMessageId.YOUR_SHIELD_DEFENSE_HAS_SUCCEEDED);
            } else if (shldSuccess == SHIELD_DEFENSE_PERFECT_BLOCK) {
                enemy.sendPacket(SystemMessageId.YOUR_EXCELLENT_SHIELD_DEFENSE_WAS_A_SUCCESS);
            }
        }

        return shldSuccess;
    }

    public static byte calcShldUse(Creature attacker, Creature target) {
        return calcShldUse(attacker, target, true);
    }

    public static boolean calcMagicAffected(Creature actor, Creature target, Skill skill) {
        // TODO: CHECK/FIX THIS FORMULA UP!!
        double defence = 0;
        if (skill.isActive() && skill.isBad()) {
            defence = target.getMDef();
        }

        final double attack = 2 * actor.getMAtk() * calcGeneralTraitBonus(actor, target, skill.getTrait(), false);
        double d = (attack - defence) / (attack + defence);

        if (skill.isDebuff()) {
            if (target.getAbnormalShieldBlocks() > 0) {
                target.decrementAbnormalShieldBlocks();
                return false;
            }
        }

        d += 0.5 * Rnd.nextGaussian();
        return d > 0;
    }

    /**
     * Calculates the effect landing success.<br>
     *
     * @param attacker the attacker
     * @param target   the target
     * @param skill    the skill
     * @return {@code true} if the effect lands
     */
    public static boolean calcEffectSuccess(Creature attacker, Creature target, Skill skill) {
        if (isDoor(target) || (target instanceof SiegeFlag) || (target instanceof StaticWorldObject)) {
            return false;
        }

        if (skill.isDebuff() && calcDebuffResist(attacker, target, skill)) {
            attacker.sendPacket(getSystemMessage(SystemMessageId.C1_HAS_RESISTED_YOUR_S2).addString(target.getName()).addSkillName(skill));
            return false;
        }

        final int activateRate = skill.getActivateRate();
        if (activateRate <= 0 || activateRate >= 100) {
            return true;
        }

        int magicLevel = skill.getMagicLevel();
        if (magicLevel <= -1) {
            magicLevel = attacker.getLevel() + 3;
        }

        final double targetBasicProperty = getAbnormalResist(skill.getBasicProperty(), target);
        final double baseMod = ((((((magicLevel - target.getLevel()) + 3) * skill.getLevelBonusRate()) + activateRate) + 30.0) - targetBasicProperty);
        final double elementMod = calcAttributeBonus(attacker, target, skill);
        final double traitMod = calcGeneralTraitBonus(attacker, target, skill.getTrait(), false);
        final double basicPropertyResist = getBasicPropertyResistBonus(skill.getBasicProperty(), target);
        final double buffDebuffMod = skill.isDebuff() ?  2d - target.getStats().getValue(Stat.RESIST_ABNORMAL_DEBUFF, 1) : 1;
        final double rate = baseMod * elementMod * traitMod * buffDebuffMod;
        final double finalRate = traitMod > 0 ? rate * basicPropertyResist : 0;

        if (!Rnd.chance(finalRate)) {
            if(target != attacker) {
                attacker.sendPacket(getSystemMessage(SystemMessageId.C1_HAS_RESISTED_YOUR_S2).addString(target.getName()).addSkillName(skill));
            }
            return false;
        }
        return true;
    }

    private static boolean calcDebuffResist(Creature attacker, Creature target, Skill skill) {
        boolean resisted = target.isCastingNow(s -> s.getSkill().getAbnormalResists().contains(skill.getAbnormalType()));
        if (!resisted) {
            if (target.getAbnormalShieldBlocks() > 0) {
                target.decrementAbnormalShieldBlocks();
                resisted = true;
            }
        }

        if (!resisted) {
            final double sphericBarrierRange = target.getStats().getValue(Stat.SPHERIC_BARRIER_RANGE, 0);
            if (sphericBarrierRange > 0) {
                resisted = !MathUtil.isInsideRadius3D(attacker, target, (int) sphericBarrierRange);
            }
        }
        return resisted;
    }

    public static boolean calcMagicSuccess(Creature attacker, Creature target) {
        final int mAccDiff = attacker.getMagicAccuracy() - target.getMagicEvasionRate();
        int mAccModifier = 100;
        if (mAccDiff > -20) {
            mAccModifier = 2;
        } else if (mAccDiff > -25) {
            mAccModifier = 30;
        } else if (mAccDiff > -30) {
            mAccModifier = 60;
        } else if (mAccDiff > -35) {
            mAccModifier = 90;
        }

        double chanceModifier = 1;
        if (isAttackable(target) && !target.isRaid() && !target.isRaidMinion()  && (attacker.getActingPlayer() != null) && ((target.getLevel() - attacker.getActingPlayer().getLevel()) >= 3)) {
            final int levelDiff = target.getLevel() - attacker.getActingPlayer().getLevel() - 2;
            chanceModifier = NpcSettings.pveSkillChancePenaltyOf(levelDiff);
        }
        // general magic resist
        final double resModifier = target.getStats().getValue(Stat.MAGIC_SUCCESS_RES, 1);
        final int rate = 100 - Math.round((float) (mAccModifier * chanceModifier * resModifier));

        return (Rnd.get(100) < rate);
    }

    public static double calcManaDam(Creature attacker, Creature target, Skill skill, double power, boolean mcrit, double critLimit) {
        // Formula: (SQR(M.Atk)*Power*(Target Max MP/97))/M.Def
        double mAtk = attacker.getMAtk();
        double mDef = target.getMDef();
        final double mp = target.getMaxMp();

        switch (calcShldUse(attacker, target)) {
            case SHIELD_DEFENSE_SUCCEED -> mDef += target.getShldDef();
            case SHIELD_DEFENSE_PERFECT_BLOCK -> {
                return 1;
            }
        }

        mAtk *= skill.useSpiritShot() ? attacker.chargedShotBonus(ShotType.SPIRITSHOTS) : 1;

        double damage = (Math.sqrt(mAtk) * power * (mp / 97)) / mDef;
        damage *= calcGeneralTraitBonus(attacker, target, skill.getTrait(), false);
        damage *= calculatePvpPveBonus(attacker, target, skill);

        // Failure calculation
        if (CharacterSettings.magicFailureAllowed() && !calcMagicSuccess(attacker, target)) {
            if (isPlayer(attacker)) {
                final SystemMessage sm = getSystemMessage(SystemMessageId.DAMAGE_IS_DECREASED_BECAUSE_C1_RESISTED_C2_S_MAGIC);
                sm.addString(target.getName());
                sm.addString(attacker.getName());
                attacker.sendPacket(sm);
                damage /= 2;
            }

            if (isPlayer(target)) {
                final SystemMessage sm2 = getSystemMessage(SystemMessageId.C1_WEAKLY_RESISTED_C2_S_MAGIC);
                sm2.addString(target.getName());
                sm2.addString(attacker.getName());
                target.sendPacket(sm2);
            }
        }

        if (mcrit) {
            damage *= 3;
            damage = Math.min(damage, critLimit);
            attacker.sendPacket(SystemMessageId.M_CRITICAL);
        }
        return damage;
    }

    public static double calculateSkillResurrectRestorePercent(double baseRestorePercent, Creature caster) {
        if ((baseRestorePercent == 0) || (baseRestorePercent == 100)) {
            return baseRestorePercent;
        }

        double restorePercent = baseRestorePercent * BaseStats.WIT.calcBonus(caster);
        if ((restorePercent - baseRestorePercent) > 20.0) {
            restorePercent += 20.0;
        }

        restorePercent = max(restorePercent, baseRestorePercent);
        restorePercent = Math.min(restorePercent, 90.0);

        return restorePercent;
    }

    public static boolean calcPhysicalFailure(Creature activeChar, Creature target) {
        if (target instanceof Player || target instanceof Summon)
            return false;
        if ((target.getLevel() - activeChar.getActingPlayer().getLevel()) >= 11 ) {
            if (isPlayer(activeChar)) {
                final SystemMessage sm = getSystemMessage(SystemMessageId.YOUR_ATTACK_HAS_FAILED);
                sm.addString(target.getName());
                sm.addString(activeChar.getName());
                activeChar.sendPacket(sm);
            }
            return true;
        }
        return false;
    }

    public static boolean calcPhysicalSkillEvasion(Creature activeChar, Creature target, Skill skill) {
        if (calcPhysicalFailure(activeChar, target))
            return true;
        if (Rnd.get(100) < target.getStats().getSkillEvasionTypeValue(skill.getSkillType())) {
            if (isPlayer(activeChar)) {
                final SystemMessage sm = getSystemMessage(SystemMessageId.C1_DODGED_THE_ATTACK);
                sm.addString(target.getName());
                activeChar.getActingPlayer().sendPacket(sm);
            }
            if (isPlayer(target)) {
                final SystemMessage sm = getSystemMessage(SystemMessageId.YOU_HAVE_DODGED_C1_S_ATTACK);
                sm.addString(activeChar.getName());
                target.getActingPlayer().sendPacket(sm);
            }
            return true;
        }
        return false;
    }

    public static boolean calcSkillMastery(Creature actor) {
        // Static Skills and Item skills  are not affected by Skill Mastery.
        if (!isPlayer(actor)) {
            return false;
        }

        final int val = (int) actor.getStats().getAdd(Stat.SKILL_CRITICAL, -1);

        if (val == -1) {
            return false;
        }

        final double chance = BaseStats.values()[val].calcBonus(actor) * actor.getStats().getValue(Stat.SKILL_CRITICAL_PROBABILITY, 1);

        return Rnd.chance(chance);
    }

    /**
     * Calculates the attribute bonus with the following formula: <BR>
     * diff > 0, so AttBonus = 1,025 + sqrt[(diff^3) / 2] * 0,0001, cannot be above 1,25! <BR>
     * diff < 0, so AttBonus = 0,975 - sqrt[(diff^3) / 2] * 0,0001, cannot be below 0,75! <BR>
     * diff == 0, so AttBonus = 1<br>
     * It has been tested that physical skills do get affected by attack attribute even<br>
     * if they don't have any attribute. In that case only the biggest attack attribute is taken.
     *
     * @param skill    Can be {@code null} if there is no skill used for the attack.
     * @return The attribute bonus
     */
    public static double calcAttributeBonus(Creature attacker, Creature target, Skill skill) {
        int attack_attribute;
        int defence_attribute;

        if ((skill != null) && (skill.getAttributeType() != AttributeType.NONE)) {
            attack_attribute = attacker.getAttackElementValue(skill.getAttributeType()) + skill.getAttributeValue();
            defence_attribute = target.getDefenseElementValue(skill.getAttributeType());
        } else {
            attack_attribute = attacker.getAttackElementValue(attacker.getAttackElement());
            defence_attribute = target.getDefenseElementValue(attacker.getAttackElement());
        }

        final int diff = attack_attribute - defence_attribute;
        if (diff > 0) {
            return Math.min(1.025 + (Math.sqrt(Math.pow(diff, 3) / 2) * 0.0001), 1.25);
        } else if (diff < 0) {
            return max(0.975 - (Math.sqrt(Math.pow(-diff, 3) / 2) * 0.0001), 0.75);
        }

        return 1;
    }

    public static void calcCounterAttack(Creature attacker, Creature target, Skill skill) {
        // Only melee skills can be reflected
        if (skill.isMagic() || (skill.getCastRange() > MELEE_ATTACK_RANGE)) {
            return;
        }

        final double chance = target.getStats().getValue(Stat.VENGEANCE_SKILL_PHYSICAL_DAMAGE, 0);
        if (Rnd.get(100) < chance) {
            if (isPlayer(target)) {
                final SystemMessage sm = getSystemMessage(SystemMessageId.YOU_COUNTERED_C1_S_ATTACK);
                sm.addString(attacker.getName());
                target.sendPacket(sm);
            }
            if (isPlayer(attacker)) {
                final SystemMessage sm = getSystemMessage(SystemMessageId.C1_IS_PERFORMING_A_COUNTERATTACK);
                sm.addString(target.getName());
                attacker.sendPacket(sm);
            }

            double counterdmg = ((target.getPAtk() * 873.) / attacker.getPDef()); // Old: (((target.getPAtk(attacker) * 10.0) * 70.0) / attacker.getPDef(target));
            counterdmg *= calcWeaponTraitBonus(attacker, target);
            counterdmg *= calcGeneralTraitBonus(attacker, target, skill.getTrait(), true);
            counterdmg *= calcAttributeBonus(attacker, target, skill);

            attacker.reduceCurrentHp(counterdmg, target, skill, DamageType.ATTACK);
        }
    }

    /**
     * Calculate buff/debuff reflection.
     *
     * @return {@code true} if reflect, {@code false} otherwise.
     */
    public static boolean calcBuffDebuffReflection(Creature target, Skill skill) {
        if (!skill.isDebuff() || skill.getActivateRate() == -1) {
            return false;
        }
        return Rnd.chance(target.getStats().getValue(skill.isMagic() ? Stat.REFLECT_SKILL_MAGIC : Stat.REFLECT_SKILL_PHYSIC, 0));
    }

    /**
     * Calculate damage caused by falling
     */
    public static double calcFallDam(Creature cha, int fallHeight) {
        if (fallHeight <= 0) {
            return 0;
        }
        return cha.getStats().getValue(Stat.FALL, (fallHeight * cha.getMaxHp()) / 1000.0);
    }

    /**
     * Basic chance formula:<br>
     * <ul>
     * <li>chance = weapon_critical * dex_bonus * crit_height_bonus * crit_pos_bonus * effect_bonus * fatal_blow_rate</li>
     * <li>weapon_critical = (12 for daggers)</li>
     * <li>dex_bonus = dex modifier bonus for current dex (Seems unused in GOD, so its not used in formula).</li>
     * <li>crit_height_bonus = (z_diff * 4 / 5 + 10) / 100 + 1 or alternatively (z_diff * 0.008) + 1.1. Be aware of z_diff constraint of -25 to 25.</li>
     * <li>crit_pos_bonus = crit_pos(front = 1, side = 1.1, back = 1.3) * p_critical_rate_position_bonus</li>
     * <li>effect_bonus = (p2 + 100) / 100, p2 - 2nd param of effect. Blow chance of effect.</li>
     * </ul>
     * Chance cannot be higher than 80%.
     */
    public static boolean calcBlowSuccess(Creature activeChar, Creature target, Skill skill, double chanceBoost) {
        if(skill.getActivateRate() == -1) {
            return true;
        }
        final Weapon weapon = activeChar.getActiveWeaponItem();
        final double weaponCritical = weapon != null ? weapon.getStats(Stat.CRITICAL_RATE, activeChar.getTemplate().getBaseCritRate()) : activeChar.getTemplate().getBaseCritRate();
        double dexBonus = BaseStats.DEX.calcBonus(activeChar);
        final double critHeightBonus = calcCriticalHeightBonus(activeChar, target);
        final double criticalPosition = calcCriticalPositionBonus(activeChar, target); // 30% chance from back, 10% chance from side. Include buffs that give positional crit rate.
        final double chanceBoostMod = (100 + chanceBoost) / 100;
        final double blowRateMod = activeChar.getStats().getValue(Stat.BLOW_RATE, 1);

        final double rate = criticalPosition * critHeightBonus * weaponCritical * chanceBoostMod * blowRateMod * dexBonus;

        // Blow rate is capped at 80%
        return Rnd.get(100) < Math.min(rate, 80);
    }

    public static List<BuffInfo> calcCancelStealEffects(Creature target, Skill skill, DispelSlotType slot, int rate, int max) {
        final List<BuffInfo> canceled = new ArrayList<>(max);
        switch (slot) {
            case BUFF -> {
                final int cancelMagicLvl = skill.getMagicLevel();
                target.getEffectList().forEachBuffOrDance(canceled::add, b -> calcBuffCancelSuccess(target, rate, cancelMagicLvl, b), max);
            }
            case DEBUFF -> target.getEffectList().forEachDebuff(canceled::add, b -> b.getSkill().canBeDispelled() && Rnd.chance(rate), max);
        }
        return canceled;
    }

    private static boolean calcBuffCancelSuccess(Creature target, int rate, int cancelMagicLvl, BuffInfo info) {
        return info.getSkill().canBeStolen() && (rate >= 100 || calcCancelSuccess(info, cancelMagicLvl, rate, target));
    }

    public static boolean calcCancelSuccess(BuffInfo info, int cancelMagicLvl, int rate, Creature target) {
        final var resist =  2d - target.getStats().getValue(Stat.RESIST_DISPEL_BUFF, 1);
        final int chance = (int) (rate + ((cancelMagicLvl - info.getSkill().getMagicLevel()) * 2) + ((info.getAbnormalTime() / 120) * resist));
        return Rnd.get(100) < CommonUtil.constrain(chance, 25, 75); // TODO: i_dispel_by_slot_probability min = 40, max = 95.
    }

    /**
     * Calculates the abnormal time for an effect.<br>
     * The abnormal time is taken from the skill definition, and it's global for all effects present in the skills.
     *
     * @param caster the caster
     * @param skill  the skill
     * @return the time that the effect will last
     */
    public static int calcEffectAbnormalTime(Creature caster, Skill skill) {
        int time = (skill == null) || skill.isPassive() || skill.isToggle() ? -1 : skill.getAbnormalTime();

        // If the skill is a mastery skill, the effect will last twice the default time.
        if ((skill != null) && calcSkillMastery(caster)) {
            time *= 2;
        }

        return time;
    }

    /**
     * Calculate Probability in following effects:<br>
     * TargetCancel,<br>
     * TargetMeProbability,<br>
     * SkillTurning,<br>
     * Betray,<br>
     * Bluff,<br>
     * DeleteHate,<br>
     * RandomizeHate,<br>
     * DeleteHateOfMe,<br>
     * TransferHate,<br>
     * Confuse<br>
     * Compelling,<br>
     * Knockback<br>
     * Pull<br>
     *
     * @param baseChance chance from effect parameter
     * @return chance for effect to succeed
     */
    public static boolean calcProbability(double baseChance, Creature attacker, Creature target, Skill skill) {
        // Skills without set probability should only test against trait invulnerability.
        if (Double.isNaN(baseChance)) {
            return calcGeneralTraitBonus(attacker, target, skill.getTrait(), true) > 0;
        }

        // Outdated formula: return Rnd.get(100) < ((((((skill.getMagicLevel() + baseChance) - target.getLevel()) + 30) - target.getINT()) * calcAttributeBonus(attacker, target, skill)) * calcGeneralTraitBonus(attacker, target, skill.getTraitType(), false));
        // TODO: Find more retail-like formula
        return Rnd.get(100) < (((((skill.getMagicLevel() + baseChance) - target.getLevel()) - getAbnormalResist(skill.getBasicProperty(), target)) * calcAttributeBonus(attacker, target, skill)) * calcGeneralTraitBonus(attacker, target, skill.getTrait(), false));
    }

    /**
     * Calculates karma lost upon death.
     * @return the amount of karma player has loosed.
     */
    public static int calculateKarmaLost(Player player, double finalExp) {
        final double karmaLooseMul = KarmaData.getInstance().getMultiplier(player.getLevel());
        if (finalExp > 0) // Received exp
        {
            finalExp /= RateSettings.karmaLost();
        }
        return (int) ((abs(finalExp) / karmaLooseMul) / 30);
    }

    /**
     * Calculates karma gain upon playable kill.</br>
     * Updated to High Five on 10.09.2014 by Zealar tested in retail.
     * @return karma points that will be added to the player.
     */
    public static int calculateKarmaGain(int pkCount, boolean isSummon) {
        int result = 43200;

        if (isSummon) {
            result = (int) ((((pkCount * 0.375) + 1) * 60) * 4) - 150;

            if (result > 10800) {
                return 10800;
            }
        }

        if (pkCount < 99) {
            result = (int) ((((pkCount * 0.5) + 1) * 60) * 12);
        } else if (pkCount < 180) {
            result = (int) ((((pkCount * 0.125) + 37.75) * 60) * 12);
        }

        return result;
    }

    public static double calcGeneralTraitBonus(Creature attacker, Creature target, TraitType traitType, boolean ignoreResistance) {
        if (traitType == TraitType.NONE) {
            return 1.0;
        }

        if (target.getStats().isInvulnerableTrait(traitType)) {
            return 0;
        }

        if (traitType.getType() == 2) {
            if (!attacker.getStats().hasAttackTrait(traitType) || !target.getStats().hasDefenceTrait(traitType)) {
                return 1.0;
            }
        } else if (traitType.getType() == 3) {
            if (ignoreResistance) {
                return 1.0;
            }
        } else {
            return 1.0;
        }

        return max(attacker.getStats().getAttackTrait(traitType) - target.getStats().getDefenceTrait(traitType), 0.05);
    }

    public static double calcWeaknessBonus(Creature attacker, Creature target, TraitType traitType)
    {
        double result = 1;
        for (TraitType trait : TraitType.getAllWeakness())
        {
            if ((traitType != trait) && target.getStats().hasDefenceTrait(trait) && attacker.getStats().hasAttackTrait(trait) && !target.getStats().isInvulnerableTrait(traitType))
            {
                result *= max(attacker.getStats().getAttackTrait(trait) - target.getStats().getDefenceTrait(trait), 0.05);
            }
        }
        return result;
    }

    public static double calcWeaponTraitBonus(Creature attacker, Creature target) {
        return max(0, 1.0 - target.getStats().getDefenceTrait(attacker.getAttackType().getTraitType()));
    }

    public static double calcAttackTraitBonus(Creature attacker, Creature target) {
        final double weaponTraitBonus = calcWeaponTraitBonus(attacker, target);
        if (weaponTraitBonus == 0) {
            return 0;
        }

        double weaknessBonus = 1.0;
        for (TraitType traitType : TraitType.values()) {
            if (traitType.getType() == 2) {
                weaknessBonus *= calcGeneralTraitBonus(attacker, target, traitType, true);
                if (weaknessBonus == 0) {
                    return 0;
                }
            }
        }

        return max(weaponTraitBonus * weaknessBonus, 0.05);
    }

    public static double getBasicPropertyResistBonus(BasicProperty basicProperty, Creature target) {
        if ((basicProperty == BasicProperty.NONE) || !target.hasBasicPropertyResist()) {
            return 1.0;
        }

        final BasicPropertyResist resist = target.getBasicPropertyResist(basicProperty);
        return switch (resist.getResistLevel()) {
            case 0 -> 1.0;
            case 1 -> 0.6;
            case 2 -> 0.3;
            default -> 0;
        };
    }

    /**
     * Calculated damage caused by ATTACK of attacker on target.
     *
     * @param attacker player or NPC that makes ATTACK
     * @param target   player or NPC, target of ATTACK
     * @param crit     if the ATTACK have critical success
     * @param ss       if weapon item was charged by soulshot
     */
    public static double calcAutoAttackDamage(Creature attacker, Creature target, byte shld, boolean crit, boolean ss) {
        // DEFENCE CALCULATION (pDef + sDef)
        double defence = target.getPDef();

        if (shld == SHIELD_DEFENSE_SUCCEED) {
            defence += target.getShldDef();
        } else if (shld == SHIELD_DEFENSE_PERFECT_BLOCK) {
            return 1.;
        }

        final Weapon weapon = attacker.getActiveWeaponItem();
        final boolean isRanged = (weapon != null) && weapon.getItemType().isRanged();

        final double cAtk = crit ? calcCritDamage(attacker, target, null) : 1;
        final double cAtkAdd = crit ? calcCritDamageAdd(attacker, target, null) : 0;
        final double critMod = crit ? (isRanged ? 0.5 : 1) : 0;
        final double ssBonus = ss ? attacker.chargedShotBonus(ShotType.SOULSHOTS) : 1;
        final double random_damage = attacker.getRandomDamageMultiplier();
        final double proxBonus = (attacker.isInFrontOf(target) ? 0 : (attacker.isBehind(target) ? 0.2 : 0.05)) * attacker.getPAtk();
        double attack = (attacker.getPAtk() * random_damage) + proxBonus;

        // ....................______________Critical Section___________________...._______Non-Critical Section______
        // ATTACK CALCULATION (((pAtk * cAtk * ss + cAtkAdd) * crit) * weaponMod) + (pAtk (1 - crit) * ss * weaponMod)
        // ````````````````````^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^````^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        attack = ((((attack * cAtk * ssBonus) + cAtkAdd) * critMod) * (isRanged ? 154 : 77)) + (attack * (1 - critMod) * ssBonus * (isRanged ? 154 : 77));

        // DAMAGE CALCULATION (ATTACK / DEFENCE) * trait bonus * attr bonus * pvp bonus * pve bonus
        double damage = attack / defence;
        damage *= calcAttackTraitBonus(attacker, target);
        damage *= calcAttributeBonus(attacker, target, null);
        damage *= calculatePvpPveBonus(attacker, target, null);

        damage = max(0, damage);

        return damage;
    }

    public static double getAbnormalResist(BasicProperty basicProperty, Creature target) {
        return switch (basicProperty) {
            case PHYSIC -> target.getStats().getValue(Stat.ABNORMAL_RESIST_PHYSICAL);
            case MAGIC -> target.getStats().getValue(Stat.ABNORMAL_RESIST_MAGICAL);
            default -> 0;
        };
    }

    public static double calcPveDamagePenalty(Creature attacker, Creature target) {
        if (isAttackable(target) && attacker.getActingPlayer() != null && target.getLevel() - attacker.getActingPlayer().getLevel() > 1) {
            final int levelDiff = target.getLevel() - attacker.getActingPlayer().getLevel() - 1;
            return NpcSettings.pveDamagePenaltyOf(levelDiff);
        }
        return 1.0;
    }

    /**
     * Calculates if the specified creature can get its stun effect removed due to damage taken.
     *
     * @param creature the character to be checked
     * @return {@code true} if character should get its stun effects removed, {@code false} otherwise.
     */
    public static boolean calcStunBreak(Creature creature) {
        // Check if target is stunned and break it with 14% chance. (retail is 14% and 35% on crit?)
        if (CharacterSettings.breakStun() && creature.hasBlockActions() && Rnd.chance(14)) {
            // Any stun that has double duration due to skill mastery, doesn't get removed until its time reaches the usual abnormal time.
            return creature.getEffectList().hasAbnormalType(AbnormalType.STUN, info -> info.getTime() <= info.getSkill().getAbnormalTime());
        }
        return false;
    }

    public static boolean calcRealTargetBreak() {
        return Rnd.chance(3);
    }

    /**
     * @param totalAttackTime the time needed to make a full attack.
     * @param attackType      the weapon type used for attack.
     * @param twoHanded       if the weapon is two handed.
     * @param secondHit       calculates the second hit for dual attacks.
     * @return the time required from the start of the attack until you hit the target.
     */
    public static int calculateTimeToHit(int totalAttackTime, WeaponType attackType, boolean twoHanded, boolean secondHit) {
        // Gracia Final Retail confirmed:
        // Time to damage (1 hand, 1 hit): TotalBasicAttackTime * 0.644
        // Time to damage (2 hand, 1 hit): TotalBasicAttackTime * 0.735
        // Time to damage (2 hand, 2 hit): TotalBasicAttackTime * 0.2726 and TotalBasicAttackTime * 0.6
        // Time to damage (bow/xbow): TotalBasicAttackTime * 0.978

        // Measured July 2016 by Nik.
        // Due to retail packet delay, we are unable to gather too accurate results. Therefore the below formulas are based on original Gracia Final values.
        // Any original values that appear higher than tested have been replaced with the tested values, because even with packet delay its obvious they are wrong.
        // All other original values are compared with the test results and differences are considered to be too insignificant and mostly caused due to packet delay.
        return switch (attackType) {
            case BOW, CROSSBOW, TWO_HAND_CROSSBOW -> (int) (totalAttackTime * 0.6);
            case DUAL_BLUNT, DUAL_DAGGER, DUAL, FIST -> {
                if (secondHit) {
                    yield  (int) (totalAttackTime * 0.6);
                }

                yield (int) (totalAttackTime * 0.2726);
            }
            default -> {
                if (twoHanded) {
                    yield  (int) (totalAttackTime * 0.735);
                }

                yield (int) (totalAttackTime * 0.644);
            }
        };
    }

    public static int calculateTimeBetweenAttacks(Creature creature, Weapon weapon) {
        var reuse = calculateWeaponReuse(creature, weapon);
        return (int) ((500000 + (333 * reuse)) / creature.getStats().getPAtkSpd());
    }

    private static double calculateWeaponReuse(Creature creature, Weapon weapon) {
        if (weapon == null) {
            return 0;
        }

        var defaultWeaponType = weapon.getItemType();
        var weaponType = creature.getTransformation().map(Transform::attackType).orElse(defaultWeaponType);

        int reuse = weaponType.isRanged() ?  weapon.getReuseDelay() : 0;
        return reuse * creature.getStats().getWeaponReuseModifier();
    }

    public static double calculatePvpPveBonus(Creature attacker, Creature target, Skill skill) {
        if (isPlayable(attacker) && isPlayable(target)) {
            return calculatePvPBonus(attacker, target, skill);
        }
        if (isAttackable(target) || isAttackable(attacker)) {
            return calculatePvEBonus(attacker, target, skill);
        }

        return 1;
    }

    private static double calculatePvEBonus(Creature attacker, Creature target, Skill skill) {
        double pveAttack;
        final double pveDefense;
        final double pveRaidDefense;
        final double pveRaidAttack;
        final double pvePenalty = calcPveDamagePenalty(attacker, target);

        if (skill != null) {
            if (skill.isMagic()) {
                pveAttack = attacker.getStats().getValue(Stat.PVE_MAGICAL_SKILL_DAMAGE, 1);
                pveDefense = target.getStats().getValue(Stat.PVE_MAGICAL_SKILL_DEFENCE, 1);
                pveRaidDefense = attacker.isRaid() ? target.getStats().getValue(Stat.PVE_RAID_MAGICAL_SKILL_DEFENCE, 1) : 1;
                pveRaidAttack = attacker.isRaid() ? attacker.getStats().getValue(Stat.PVE_RAID_MAGICAL_SKILL_DAMAGE, 1) : 1;
            } else {
                pveAttack = attacker.getStats().getValue(Stat.PVE_PHYSICAL_SKILL_DAMAGE, 1);
                pveDefense = target.getStats().getValue(Stat.PVE_PHYSICAL_SKILL_DEFENCE, 1);
                pveRaidAttack = attacker.isRaid() ? attacker.getStats().getValue(Stat.PVE_RAID_PHYSICAL_SKILL_DAMAGE, 1) : 1;
                pveRaidDefense = attacker.isRaid() ? target.getStats().getValue(Stat.PVE_RAID_PHYSICAL_SKILL_DEFENCE, 1) : 1;
            }
        } else {
            pveAttack = attacker.getStats().getValue(Stat.PVE_PHYSICAL_ATTACK_DAMAGE, 1);
            pveDefense = target.getStats().getValue(Stat.PVE_PHYSICAL_ATTACK_DEFENCE, 1);
            pveRaidAttack = attacker.isRaid() ? attacker.getStats().getValue(Stat.PVE_RAID_PHYSICAL_ATTACK_DAMAGE, 1) : 1;
            pveRaidDefense = attacker.isRaid() ? target.getStats().getValue(Stat.PVE_RAID_PHYSICAL_ATTACK_DEFENCE, 1) : 1;
        }
        return Math.max(0.05, (1 + ((pveAttack * pveRaidAttack) - (pveDefense * pveRaidDefense))) * pvePenalty);
    }

    private static double calculatePvPBonus(Creature attacker, Creature target, Skill skill) {
        double pvpAttack;
        final double pvpDefense;
        if (skill != null) {
            if (skill.isMagic()) {
                pvpAttack = attacker.getStats().getValue(Stat.PVP_MAGICAL_SKILL_DAMAGE, 1);
                pvpDefense = target.getStats().getValue(Stat.PVP_MAGICAL_SKILL_DEFENCE, 1);
            } else {
                pvpAttack = attacker.getStats().getValue(Stat.PVP_PHYSICAL_SKILL_DAMAGE, 1);
                pvpDefense = target.getStats().getValue(Stat.PVP_PHYSICAL_SKILL_DEFENCE, 1);
            }
        } else {
            pvpAttack = attacker.getStats().getValue(Stat.PVP_PHYSICAL_ATTACK_DAMAGE, 1);
            pvpDefense = target.getStats().getValue(Stat.PVP_PHYSICAL_ATTACK_DEFENCE, 1);
        }
        return max(0.05, 1 + (pvpAttack - pvpDefense));
    }

    public static double calcSpiritElementalDamage(Creature attacker, Creature target, double baseDamage) {
        // TODO find retail calc
        if(isPlayer(attacker)) {
            var attackerPlayer = attacker.getActingPlayer();
            ElementalType type = ElementalType.of(attackerPlayer.getActiveElementalSpiritType());

            var elementalDamage = 0;

            if(ElementalType.NONE == type) {
                return elementalDamage;
            }

            var critRate = attackerPlayer.getElementalSpiritCriticRate();
            var isCrit = Math.min(critRate * 10, 380) > Rnd.get(1000);
            var critDamage = attackerPlayer.getElementalSpiritCriticDamage();
            var attack = attackerPlayer.getActiveElementalSpiritAttack() - target.getElementalSpiritDefenseOf(type) + Rnd.get(-2, 6);
            if(isPlayer(target)) {
                return calcSpiritElementalPvPDamage(attack, critDamage, isCrit, baseDamage);
            }
            return calcSpiritElementalPvEDamage(type, target.getElementalSpiritType(), attack, critDamage, isCrit, baseDamage);
        }

        return 0;
    }

    private static double calcSpiritElementalPvPDamage(double attack, double critDamage, boolean isCrit, double baseDamage) {
        var damage = min(max(0, (attack * 1.3 + baseDamage * 0.03 * attack ) / log(max(attack, 5))), 2295);
        if(isCrit) {
            damage *= 1 + (Rnd.get(13, 20) + critDamage) / 100;
        }
        return damage;
    }

    private static double calcSpiritElementalPvEDamage(ElementalType attackerType, ElementalType targetType, double attack, double critDamage, boolean isCrit, double baseDamage) {
        double damage = abs(attack * 0.8);
        double bonus;

       if(attackerType.isSuperior(targetType)) {
            damage *= 1.3;
            bonus = 1.3;
        } else if(targetType == attackerType) {
            bonus = 1.1;
        } else {
            damage *= 1.1;
            bonus = 1.1;
        }

        if(isCrit) {
           damage += abs((40 + (9.2 + attack * 0.048 ) * critDamage) * bonus + Rnd.get(-10, 30)) ;
        }

        return ((damage + baseDamage) * bonus) / log(20 + baseDamage + damage);
    }

}",1,777 657 587 2000 123 777 809 657 574 2001 61 1500 59 330 777 809 657 574 2002 61 1501 59 330 777 809 657 574 2003 61 1502 59 330 777 809 657 704 2004 61 1504 59 330 306 773 809 657 704 2005 61 1505 59 330 773 809 657 574 2006 61 1503 59 306 777 809 704 2007 40 2008 2009 41 123 792 2010 40 2009 41 63 2005 42 1503 58 2005 59 125 777 809 625 2011 40 2008 2012 44 2008 2013 44 2014 2015 44 625 2016 41 123 625 2017 61 2013 46 2018 40 41 59 819 40 2019 40 2012 44 2013 41 41 123 579 2002 45 62 2017 348 2013 46 2020 40 41 59 579 2003 45 62 123 792 1501 59 125 125 330 657 2021 2022 61 2023 46 2024 40 2012 44 2013 41 59 657 2021 2025 61 2012 46 2026 40 41 46 2027 40 2028 46 2029 44 1501 41 59 657 2021 2030 61 2012 46 2026 40 41 46 2031 40 2028 46 2029 44 2022 41 59 657 2021 2032 61 2013 46 2026 40 41 46 2027 40 2028 46 2033 44 1501 41 59 657 2021 2034 61 2012 46 2026 40 41 46 2027 40 2028 46 2035 44 1500 41 59 657 2021 2036 61 2013 46 2026 40 41 46 2027 40 2028 46 2037 44 1500 41 59 330 657 2021 2038 61 2039 40 2012 44 2013 41 59 657 2021 2040 61 2041 40 2012 44 2013 44 2015 46 2042 40 41 44 2043 41 59 657 2021 2044 61 2045 40 2012 44 2013 44 2015 46 2042 40 41 41 59 657 2021 2046 61 2047 40 2012 44 2013 44 2015 41 59 657 2021 2048 61 2012 46 2049 40 41 59 657 2021 2050 61 2051 40 2012 44 2013 44 2015 41 59 330 657 2021 2052 61 2012 46 2053 40 2054 46 2055 41 59 330 657 2021 2056 61 2025 42 40 40 40 2030 45 1501 41 47 1502 41 43 1501 41 42 40 40 40 2032 45 1501 41 47 1502 41 43 1501 41 59 657 2021 2057 61 2034 45 2036 59 657 2021 2058 61 2022 323 2023 46 2059 63 1500 58 2022 323 2023 46 2060 63 1500 58 1500 59 330 330 330 657 2021 2061 61 40 1503 42 40 40 40 2016 43 2012 46 2062 40 41 41 42 1500 41 43 40 2058 42 40 2016 43 2012 46 2062 40 41 41 42 2048 41 43 40 1502 42 2057 41 41 41 47 2017 59 792 2061 42 2052 42 2056 42 2038 42 2040 42 2044 42 2046 42 2048 42 2050 59 125 777 809 625 2063 40 2008 2012 44 2008 2013 44 2014 2015 44 625 2064 44 625 2016 44 625 2065 44 570 2066 41 123 2067 2068 61 2015 46 2069 40 41 63 2012 46 2070 40 2071 46 2072 41 58 1501 59 657 625 2073 61 2066 63 2074 40 2012 44 2013 44 2015 41 58 1501 59 330 330 657 625 2075 61 2076 40 2012 44 2013 44 2015 46 2077 40 41 44 2078 41 59 657 625 2079 61 2080 40 2012 44 2013 44 2015 46 2077 40 41 41 59 657 625 2081 61 2082 40 2012 44 2013 44 2015 41 59 657 625 2083 61 2012 46 2084 40 41 59 657 625 2085 61 2086 40 2012 44 2013 44 2015 41 59 330 625 2087 61 40 40 1503 42 2012 46 2088 40 41 46 2089 40 2090 46 2091 44 2016 41 42 2092 46 2093 40 2064 41 41 47 2065 41 42 2068 59 330 688 40 2094 46 2095 40 41 307 33 2096 40 2012 44 2013 41 41 123 688 40 2097 40 2012 41 41 123 688 40 2096 40 2012 44 2013 41 41 123 688 40 2015 46 2098 40 2099 46 2100 41 41 123 2012 46 2101 40 2102 46 2103 41 59 125 630 123 2012 46 2104 40 2105 46 2106 41 59 125 2087 316 1502 59 125 630 123 657 2107 2108 61 2109 40 2110 46 2111 41 59 2108 46 2112 40 2013 46 2113 40 41 41 59 2108 46 2114 40 2015 41 59 2012 46 2115 40 2108 41 59 2087 61 1501 59 125 125 688 40 2097 40 2013 41 41 123 657 2116 2117 61 40 2015 46 2118 40 2119 46 2120 41 41 63 2121 40 2122 46 2123 41 58 2121 40 2122 46 2124 41 59 2117 46 2125 40 2012 46 2126 40 41 41 59 2013 46 2127 40 2117 41 59 125 125 792 2087 42 2073 42 2075 42 2079 42 2081 42 2083 42 2085 59 125 306 777 809 570 2128 40 625 2129 44 2008 2130 44 2008 2013 44 2014 2015 41 123 330 688 40 2015 340 2131 41 123 330 688 40 2015 46 2132 40 41 41 123 2129 348 2130 46 2133 40 41 46 2134 40 2135 46 2136 41 59 688 40 40 2013 323 2131 41 309 33 2015 46 2137 40 41 41 123 792 2138 46 2139 40 2129 44 1504 41 62 2140 46 2141 40 1504 41 59 125 625 2142 61 2013 46 2133 40 41 46 2134 40 2135 46 2143 44 2129 41 43 2013 46 2133 40 41 46 2134 40 2135 46 2144 44 1500 41 59 688 40 40 2130 46 2145 40 41 325 1503 41 307 40 2013 46 2145 40 41 325 1503 41 41 123 2142 348 2146 46 2147 40 2130 46 2145 40 41 41 43 40 40 2130 46 2145 40 41 45 2013 46 2145 40 41 41 47 1503 41 59 792 2146 46 2148 40 2142 44 1504 41 62 2149 46 2150 40 1504 41 59 125 792 2151 46 2152 40 2142 44 1504 41 62 2153 46 2154 40 1504 41 59 125 330 657 625 2155 59 330 574 2156 61 40 574 41 2130 46 2157 40 41 46 2158 40 2159 46 2160 41 59 688 40 40 2156 325 1500 41 307 40 2156 60 2161 46 2162 40 41 46 2163 41 41 123 330 2155 61 2161 46 2162 40 41 91 2156 93 46 2164 40 2130 41 59 125 630 123 330 2155 61 2161 46 2165 46 2166 40 2130 41 59 125 657 625 2167 61 2130 46 2157 40 41 46 2158 40 2159 46 2168 44 1501 41 59 625 2169 61 2129 42 2155 42 2167 42 1502 59 792 2169 62 2170 46 2171 40 1504 41 59 125 330 330 330 657 625 2172 61 40 2013 46 2173 40 41 46 2174 40 2175 46 2176 44 2129 41 43 2013 46 2173 40 41 46 2174 40 2175 46 2177 44 1500 41 41 47 1502 59 657 625 2178 61 2179 40 2130 44 2013 41 59 657 625 2180 61 2181 40 2130 44 2013 41 59 2129 61 2178 42 2172 42 2180 59 330 688 40 40 2130 46 2182 40 41 325 1503 41 309 40 2013 46 2182 40 41 325 1503 41 41 123 2129 348 40 2183 46 2184 40 2130 46 2182 40 41 41 42 40 2130 46 2182 40 41 45 2013 46 2182 40 41 41 42 1500 41 59 125 330 2129 61 2185 46 2186 40 2129 44 1502 44 1503 41 59 792 2129 62 2187 46 2188 40 1503 41 59 125 306 777 809 625 2189 40 2008 2190 44 2008 2013 41 123 792 819 40 2191 46 2192 40 2190 44 2013 41 41 123 579 2193 45 62 1502 42 2190 46 2194 40 41 46 2195 40 2196 46 2197 44 2191 46 2193 41 59 579 2198 45 62 1502 42 2190 46 2194 40 41 46 2195 40 2196 46 2197 44 2191 46 2198 41 59 613 45 62 2190 46 2194 40 41 46 2195 40 2196 46 2197 44 2191 46 2199 41 59 125 59 125 777 809 625 2200 40 2201 2202 44 2201 2013 41 123 792 40 40 40 40 2203 46 2204 40 2202 46 2205 40 41 45 2013 46 2205 40 41 44 45 1503 44 1503 41 42 1502 41 47 1502 41 43 1502 41 47 1503 41 43 1501 59 125 306 777 809 625 2206 40 2008 2012 44 2008 2013 44 2014 2015 41 123 657 625 2207 59 657 625 2208 59 688 40 2015 340 2209 41 123 688 40 2015 46 2210 40 41 41 123 330 2207 61 2012 46 2211 40 41 46 2212 40 2213 46 2214 44 1501 41 59 2208 61 2013 46 2211 40 41 46 2212 40 2213 46 2215 44 1501 41 59 125 630 123 2207 61 2012 46 2216 40 41 46 2217 40 2218 46 2219 44 1501 41 59 2208 61 2013 46 2216 40 41 46 2217 40 2218 46 2220 44 1501 41 59 125 125 630 123 330 2207 61 2012 46 2221 40 41 46 2222 40 2223 46 2224 44 1501 41 42 2012 46 2221 40 41 46 2225 40 2223 46 2224 44 2226 46 2227 40 2012 44 2013 41 41 59 2208 61 2013 46 2221 40 41 46 2222 40 2223 46 2228 44 1501 41 59 125 792 2229 46 2230 40 1501 44 1502 43 40 2207 45 2208 41 41 59 125 306 777 809 625 2231 40 2008 2012 44 2008 2013 44 2014 2015 41 123 657 625 2232 59 657 625 2233 59 688 40 2015 340 2234 41 123 688 40 2015 46 2235 40 41 41 123 330 2232 61 2012 46 2236 40 41 46 2237 40 2238 46 2239 44 1500 41 59 2233 61 2013 46 2236 40 41 46 2237 40 2238 46 2240 44 1500 41 59 125 630 123 2232 61 2012 46 2241 40 41 46 2242 40 2243 46 2244 44 1500 41 59 2233 61 2013 46 2241 40 41 46 2242 40 2243 46 2245 44 1500 41 59 125 125 630 123 330 2232 61 2012 46 2246 40 41 46 2247 40 2248 46 2249 44 1500 41 59 2233 61 2013 46 2246 40 41 46 2247 40 2248 46 2250 44 1500 41 59 125 792 2232 43 2233 59 125 306 777 809 570 2251 40 2008 2013 44 625 2252 41 123 688 40 2013 46 2253 40 41 309 2013 46 2254 40 41 309 2013 46 2255 40 41 41 123 792 2256 59 125 625 2257 61 1500 59 688 40 2258 46 2259 40 41 307 2013 46 2260 40 2261 58 58 2262 41 41 123 2257 61 1503 59 125 630 688 40 2258 46 2263 40 41 307 2013 46 2264 40 41 41 123 657 2265 2266 61 2013 46 2267 40 41 59 688 40 2268 40 2266 41 307 2266 46 2269 40 41 323 2270 46 2271 41 123 2257 61 1503 59 125 125 688 40 2257 329 1500 41 123 792 2272 59 330 125 330 2257 348 2273 46 2274 40 1503 42 2252 41 59 330 2257 337 40 40 2275 46 2276 46 2277 40 2013 41 42 1503 41 45 1503 41 59 330 625 2129 61 2013 46 2278 40 41 46 2279 40 2280 46 2281 44 2257 41 59 330 2129 61 2282 40 2273 46 2283 40 2129 44 1503 41 44 1501 41 59 792 2284 46 2285 40 2129 41 59 125 777 809 704 2286 40 2008 2012 44 2014 2015 41 123 688 40 2015 46 2287 40 41 41 123 792 40 704 41 40 40 40 625 41 2015 46 2288 40 41 47 2012 46 2289 40 41 41 42 1504 41 59 125 792 40 704 41 40 40 40 625 41 2015 46 2290 40 41 47 2012 46 2291 40 41 41 42 1504 41 59 125 777 809 625 2292 40 2008 2190 41 123 625 2293 61 1501 59 330 625 2294 61 2295 46 2296 46 2297 40 2190 41 59 625 2298 61 2299 46 2300 40 2190 44 2299 46 2301 41 47 2293 59 330 625 2302 61 2190 46 2303 40 41 46 2304 40 2299 46 2301 41 59 625 2305 61 2190 46 2303 40 41 46 2306 40 2299 46 2301 41 59 792 40 2294 42 40 2298 47 1504 41 42 2302 41 43 40 2305 47 1504 41 59 125 777 809 625 2307 40 2008 2190 41 123 657 625 2308 61 1501 59 330 657 625 2309 61 2310 46 2311 46 2312 40 2190 41 59 657 625 2313 61 2190 46 2314 40 41 46 2315 40 2316 46 2317 41 59 657 625 2318 61 2190 46 2314 40 41 46 2319 40 2316 46 2317 41 59 792 40 40 1501 47 2308 41 42 2309 42 2313 41 43 40 2318 47 1504 41 59 125 306 777 809 625 2320 40 2008 2190 44 2014 2015 41 123 688 40 2015 46 2321 40 41 309 2015 46 2322 40 41 323 2323 46 2324 41 123 792 1501 59 125 625 2325 59 688 40 2015 46 2322 40 41 323 2323 46 2326 41 123 657 625 2327 61 2190 46 2328 40 2329 46 2330 41 63 1500 58 1500 59 330 330 2325 61 2190 46 2331 40 41 46 2332 40 41 43 40 2190 46 2331 40 41 46 2332 40 41 42 2327 41 59 125 630 123 2325 61 2190 46 2333 40 41 59 125 688 40 2190 702 2334 2335 41 123 625 2336 61 2335 46 2337 40 41 46 2338 40 41 59 688 40 2336 62 1500 41 123 2325 316 2336 59 125 125 792 2339 40 1500 44 2325 41 59 125 777 809 625 2340 40 2008 2190 44 2014 2015 41 123 792 2341 40 40 2015 46 2342 40 41 42 1504 41 47 2320 40 2190 44 2015 41 44 2004 41 59 125 306 777 809 570 2343 40 2008 2012 44 2008 2013 41 123 704 2344 61 40 1503 43 40 1502 42 40 2012 46 2345 40 41 45 2013 46 2346 40 41 41 41 41 42 1502 59 2344 61 40 704 41 40 2344 42 2347 46 2348 40 41 46 2349 40 2012 44 2013 41 41 59 2344 61 2350 40 2344 44 1504 41 59 2344 61 2351 46 2352 40 2344 44 1504 41 59 792 2344 60 2353 46 2354 40 1504 41 59 125 306 777 809 574 2355 40 2008 2012 44 2008 2013 44 570 2356 41 123 657 2357 2358 61 2013 46 2359 40 41 59 688 40 33 40 2358 702 2360 41 309 40 40 40 2360 41 2358 41 46 2361 40 41 323 2362 46 2363 41 41 123 792 1500 59 125 625 2364 61 2013 46 2365 40 41 46 2366 40 2367 46 2368 41 42 2369 46 2370 46 2371 40 2013 41 59 330 688 40 2012 46 2372 40 41 46 2373 40 41 41 123 2364 363 1502 59 125 657 704 2374 61 2013 46 2375 40 2376 46 2377 41 63 1504 58 1504 59 688 40 40 2374 60 1504 41 307 40 2378 40 2013 46 2379 40 2012 41 45 2380 40 2013 46 2381 40 41 41 41 62 40 2374 47 1502 41 41 41 123 792 1500 59 125 574 2382 61 2001 59 330 688 40 2364 62 2383 46 2384 40 1503 41 41 123 330 688 40 40 40 1503 45 40 1502 42 2369 46 2370 46 2371 40 2013 41 41 41 60 2383 46 2384 40 1503 41 41 41 123 2382 61 2003 59 125 630 123 2382 61 2002 59 125 125 688 40 2356 307 2385 40 2013 41 41 123 657 2386 2387 61 2013 46 2388 40 41 59 688 40 2382 323 2002 41 123 2387 46 2389 40 2390 46 2391 41 59 125 630 688 40 2382 323 2003 41 123 2387 46 2392 40 2393 46 2394 41 59 125 125 792 2382 59 125 777 809 574 2355 40 2008 2012 44 2008 2013 41 123 792 2355 40 2012 44 2013 44 2395 41 59 125 777 809 570 2396 40 2008 2397 44 2008 2013 44 2014 2015 41 123 330 625 2398 61 1500 59 688 40 2015 46 2399 40 41 307 2015 46 2400 40 41 41 123 2398 61 2013 46 2401 40 41 59 125 657 625 2402 61 1502 42 2397 46 2403 40 41 42 2404 40 2397 44 2013 44 2015 46 2405 40 41 44 2406 41 59 625 2407 61 40 2402 45 2398 41 47 40 2402 43 2398 41 59 688 40 2015 46 2408 40 41 41 123 688 40 2013 46 2409 40 41 62 1500 41 123 2013 46 2410 40 41 59 792 2406 59 125 125 2407 348 1500 42 2411 46 2412 40 41 59 792 2407 62 1500 59 125 306 777 809 570 2413 40 2008 2012 44 2008 2013 44 2014 2015 41 123 688 40 2414 40 2013 41 309 40 2013 702 2415 41 309 40 2013 702 2416 41 41 123 792 2417 59 125 688 40 2015 46 2418 40 41 307 2419 40 2012 44 2013 44 2015 41 41 123 2012 46 2420 40 2421 40 2422 46 2423 41 46 2424 40 2013 46 2425 40 41 41 46 2426 40 2015 41 41 59 792 2427 59 125 657 704 2428 61 2015 46 2429 40 41 59 688 40 2428 329 1500 309 2428 325 1503 41 123 792 2430 59 125 704 2431 61 2015 46 2432 40 41 59 688 40 2431 329 45 1501 41 123 2431 61 2012 46 2433 40 41 43 1502 59 125 657 625 2434 61 2435 40 2015 46 2436 40 41 44 2013 41 59 657 625 2437 61 40 40 40 40 40 40 2431 45 2013 46 2438 40 41 41 43 1502 41 42 2015 46 2439 40 41 41 43 2428 41 43 1503 41 45 2434 41 59 657 625 2440 61 2441 40 2012 44 2013 44 2015 41 59 657 625 2442 61 2443 40 2012 44 2013 44 2015 46 2444 40 41 44 2445 41 59 657 625 2446 61 2447 40 2015 46 2436 40 41 44 2013 41 59 657 625 2448 61 2015 46 2418 40 41 63 1502 45 2013 46 2449 40 41 46 2450 40 2451 46 2452 44 1501 41 58 1501 59 657 625 2129 61 2437 42 2440 42 2442 42 2448 59 657 625 2453 61 2442 62 1500 63 2129 42 2446 58 1500 59 688 40 33 2454 46 2455 40 2453 41 41 123 688 40 2013 340 2012 41 123 2012 46 2456 40 2457 40 2458 46 2459 41 46 2460 40 2013 46 2461 40 41 41 46 2462 40 2015 41 41 59 125 792 2445 59 125 792 2463 59 125 773 809 570 2464 40 2008 2012 44 2008 2013 44 2014 2015 41 123 570 2465 61 2013 46 2466 40 2467 45 62 2467 46 2468 40 41 46 2469 40 41 46 2470 40 2015 46 2471 40 41 41 41 59 688 40 33 2465 41 123 688 40 2013 46 2472 40 41 62 1500 41 123 2013 46 2473 40 41 59 2465 61 2474 59 125 125 688 40 33 2465 41 123 657 625 2475 61 2013 46 2476 40 41 46 2477 40 2478 46 2479 44 1500 41 59 688 40 2475 62 1500 41 123 2465 61 33 2480 46 2481 40 2012 44 2013 44 40 704 41 2475 41 59 125 125 792 2465 59 125 777 809 570 2482 40 2008 2012 44 2008 2013 41 123 657 704 2483 61 2012 46 2484 40 41 45 2013 46 2485 40 41 59 704 2486 61 1503 59 688 40 2483 62 45 1503 41 123 2486 61 1502 59 125 630 688 40 2483 62 45 1503 41 123 2486 61 1503 59 125 630 688 40 2483 62 45 1503 41 123 2486 61 1503 59 125 630 688 40 2483 62 45 1503 41 123 2486 61 1503 59 125 625 2487 61 1501 59 688 40 2488 40 2013 41 307 33 2013 46 2489 40 41 307 33 2013 46 2490 40 41 307 40 2012 46 2491 40 41 340 2492 41 307 40 40 2013 46 2493 40 41 45 2012 46 2491 40 41 46 2493 40 41 41 325 1502 41 41 123 657 704 2494 61 2013 46 2493 40 41 45 2012 46 2491 40 41 46 2493 40 41 45 1502 59 2487 61 2495 46 2496 40 2494 41 59 125 330 657 625 2497 61 2013 46 2498 40 41 46 2499 40 2500 46 2501 44 1501 41 59 657 704 2129 61 1503 45 2502 46 2503 40 40 660 41 40 2486 42 2487 42 2497 41 41 59 792 40 2504 46 2505 40 1503 41 60 2129 41 59 125 777 809 625 2506 40 2008 2012 44 2008 2013 44 2014 2015 44 625 2016 44 570 2066 44 625 2507 41 123 330 625 2064 61 2012 46 2508 40 41 59 625 2065 61 2013 46 2509 40 41 59 657 625 2510 61 2013 46 2511 40 41 59 819 40 2355 40 2012 44 2013 41 41 123 579 2002 45 62 2065 348 2013 46 2512 40 41 59 579 2003 45 62 123 792 1501 59 125 125 2064 363 2015 46 2513 40 41 63 2012 46 2514 40 2515 46 2516 41 58 1501 59 625 2517 61 40 2518 46 2519 40 2064 41 42 2016 42 40 2510 47 1503 41 41 47 2065 59 2517 363 2520 40 2012 44 2013 44 2015 46 2521 40 41 44 2522 41 59 2517 363 2523 40 2012 44 2013 44 2015 41 59 330 688 40 2524 46 2525 40 41 307 33 2482 40 2012 44 2013 41 41 123 688 40 2526 40 2012 41 41 123 657 2527 2528 61 2529 40 2530 46 2531 41 59 2528 46 2532 40 2013 46 2533 40 41 41 59 2528 46 2532 40 2012 46 2533 40 41 41 59 2012 46 2534 40 2528 41 59 2517 316 1502 59 125 688 40 2526 40 2013 41 41 123 657 2535 2536 61 2537 40 2538 46 2539 41 59 2536 46 2540 40 2013 46 2541 40 41 41 59 2536 46 2540 40 2012 46 2541 40 41 41 59 2013 46 2542 40 2536 41 59 125 125 688 40 2066 41 123 2517 363 1502 59 2517 61 2518 46 2543 40 2517 44 2507 41 59 2012 46 2544 40 2545 46 2546 41 59 125 792 2517 59 125 777 809 625 2547 40 625 2548 44 2008 2549 41 123 688 40 40 2548 323 1500 41 309 40 2548 323 1503 41 41 123 792 2548 59 125 625 2550 61 2548 42 2551 46 2552 46 2553 40 2549 41 59 688 40 40 2550 45 2548 41 62 1503 41 123 2550 348 1503 59 125 2550 61 2554 40 2550 44 2548 41 59 2550 61 2555 46 2556 40 2550 44 1503 41 59 792 2550 59 125 777 809 570 2557 40 2008 2130 44 2008 2013 41 123 688 40 2013 702 2558 309 2013 702 2559 41 792 2560 59 688 40 40 2013 46 2561 40 41 45 2130 46 2562 40 41 46 2561 40 41 41 325 1503 41 123 688 40 2563 40 2130 41 41 123 657 2564 2565 61 2566 40 2567 46 2568 41 59 2565 46 2569 40 2013 46 2570 40 41 41 59 2565 46 2569 40 2130 46 2570 40 41 41 59 2130 46 2571 40 2565 41 59 125 792 2572 59 125 792 2560 59 125 777 809 570 2573 40 2008 2130 44 2008 2013 44 2014 2015 41 123 688 40 2557 40 2130 44 2013 41 41 792 2574 59 688 40 2575 46 2576 40 1503 41 60 2013 46 2577 40 41 46 2578 40 2015 46 2579 40 41 41 41 123 688 40 2580 40 2130 41 41 123 657 2581 2582 61 2583 40 2584 46 2585 41 59 2582 46 2586 40 2013 46 2587 40 41 41 59 2130 46 2588 40 41 46 2589 40 2582 41 59 125 688 40 2580 40 2013 41 41 123 657 2590 2591 61 2592 40 2593 46 2594 41 59 2591 46 2595 40 2130 46 2596 40 41 41 59 2013 46 2597 40 41 46 2598 40 2591 41 59 125 792 2574 59 125 792 2599 59 125 777 809 570 2600 40 2008 2397 41 123 330 688 40 33 2601 40 2397 41 41 123 792 2602 59 125 657 704 2603 61 40 704 41 2397 46 2604 40 41 46 2605 40 2606 46 2607 44 45 1501 41 59 688 40 2603 323 45 1501 41 123 792 2608 59 125 657 625 2609 61 2610 46 2611 40 41 91 2603 93 46 2612 40 2397 41 42 2397 46 2604 40 41 46 2613 40 2606 46 2614 44 1501 41 59 792 2615 46 2609 40 2609 41 59 125 306 777 809 625 2616 40 2008 2012 44 2008 2013 44 2014 2015 41 123 704 2617 59 704 2618 59 688 40 40 2015 340 2619 41 307 40 2015 46 2620 40 41 340 2621 46 2622 41 41 123 2617 61 2012 46 2623 40 2015 46 2620 40 41 41 43 2015 46 2624 40 41 59 2618 61 2013 46 2625 40 2015 46 2620 40 41 41 59 125 630 123 2617 61 2012 46 2626 40 2012 46 2627 40 41 41 59 2618 61 2013 46 2628 40 2012 46 2627 40 41 41 59 125 657 704 2629 61 2617 45 2618 59 688 40 2629 62 1500 41 123 792 2630 46 2631 40 1502 43 40 2630 46 2632 40 2630 46 2633 40 2629 44 1502 41 47 1502 41 42 1500 41 44 1502 41 59 125 630 688 40 2629 60 1500 41 123 792 2634 40 1500 45 40 2635 46 2636 40 2635 46 2637 40 45 2629 44 1502 41 47 1502 41 42 1500 41 44 1500 41 59 125 792 1501 59 125 777 809 865 2638 40 2008 2012 44 2008 2013 44 2014 2015 41 123 330 688 40 2015 46 2639 40 41 309 40 2015 46 2640 40 41 62 2006 41 41 123 792 59 125 657 625 2641 61 2013 46 2642 40 41 46 2643 40 2644 46 2645 44 1500 41 59 688 40 2646 46 2647 40 1503 41 60 2641 41 123 688 40 2648 40 2013 41 41 123 657 2649 2650 61 2651 40 2652 46 2653 41 59 2650 46 2654 40 2012 46 2655 40 41 41 59 2013 46 2656 40 2650 41 59 125 688 40 2648 40 2012 41 41 123 657 2657 2658 61 2659 40 2660 46 2661 41 59 2658 46 2662 40 2013 46 2663 40 41 41 59 2012 46 2664 40 2658 41 59 125 625 2665 61 40 40 2013 46 2666 40 41 42 1504 41 47 2012 46 2667 40 41 41 59 330 2665 363 2668 40 2012 44 2013 41 59 2665 363 2669 40 2012 44 2013 44 2015 46 2670 40 41 44 2671 41 59 2665 363 2616 40 2012 44 2013 44 2015 41 59 2012 46 2672 40 2665 44 2013 44 2015 44 2673 46 2674 41 59 125 125 306 777 809 570 2675 40 2008 2013 44 2014 2015 41 123 688 40 33 2015 46 2676 40 41 309 2015 46 2677 40 41 323 45 1501 41 123 792 2678 59 125 792 2679 46 2680 40 2013 46 2681 40 41 46 2682 40 2015 46 2683 40 41 63 2684 46 2685 58 2684 46 2686 44 1500 41 41 59 125 306 777 809 625 2687 40 2008 2009 44 704 2688 41 123 688 40 2688 329 1500 41 123 792 1500 59 125 792 2009 46 2689 40 41 46 2690 40 2691 46 2692 44 40 2688 42 2009 46 2693 40 41 41 47 1504 41 59 125 306 777 809 570 2694 40 2008 2130 44 2008 2013 44 2014 2015 44 625 2695 41 123 688 40 2015 46 2696 40 41 323 45 1501 41 123 792 2697 59 125 657 2698 2699 61 2130 46 2700 40 41 59 657 625 2701 61 2699 340 2702 63 2699 46 2703 40 2704 46 2705 44 2130 46 2706 40 41 46 2707 40 41 41 58 2130 46 2706 40 41 46 2707 40 41 59 625 2708 61 2709 46 2710 46 2711 40 2130 41 59 657 625 2712 61 2200 40 2130 44 2013 41 59 657 625 2713 61 2189 40 2130 44 2013 41 59 330 657 625 2714 61 40 1503 43 2695 41 47 1503 59 657 625 2715 61 2130 46 2703 40 41 46 2716 40 2704 46 2717 44 1501 41 59 657 625 2129 61 2713 42 2712 42 2701 42 2714 42 2715 42 2708 59 330 792 2718 46 2719 40 1503 41 60 2720 46 2721 40 2129 44 1503 41 59 125 777 809 2722 60 2723 62 2724 40 2008 2013 44 2014 2015 44 2725 2726 44 704 2129 44 704 2727 41 123 657 2722 60 2723 62 2728 61 744 2729 60 62 40 2727 41 59 819 40 2726 41 123 579 2730 45 62 123 657 704 2731 61 2015 46 2732 40 41 59 2013 46 2733 40 41 46 2734 40 2728 58 58 2735 44 2736 45 62 2737 40 2013 44 2129 44 2731 44 2736 41 44 2727 41 59 125 579 2738 45 62 2013 46 2739 40 41 46 2740 40 2728 58 58 2741 44 2742 45 62 2742 46 2743 40 41 46 2744 40 41 307 2745 46 2746 40 2129 41 44 2727 41 59 125 792 2728 59 125 773 809 570 2747 40 2008 2013 44 704 2129 44 704 2748 44 2723 2749 41 123 792 2749 46 2750 40 41 46 2751 40 41 307 40 2129 325 1503 309 2752 40 2749 44 2748 44 2129 44 2013 41 41 59 125 777 809 570 2753 40 2723 2749 44 704 2748 44 704 2129 44 2008 2013 41 123 657 2754 2755 61 1502 45 2013 46 2756 40 41 46 2757 40 2758 46 2759 44 1501 41 59 657 704 2760 61 40 704 41 40 2129 43 40 40 2748 45 2749 46 2761 40 41 46 2762 40 41 41 42 1502 41 43 40 40 2749 46 2763 40 41 47 1504 41 42 2755 41 41 59 792 2764 46 2765 40 1503 41 60 2766 46 2767 40 2760 44 1503 44 1503 41 59 330 125 306 777 809 704 2768 40 2008 2549 44 2014 2015 41 123 704 2769 61 40 2015 323 2770 41 309 2015 46 2771 40 41 309 2015 46 2772 40 41 63 45 1501 58 2015 46 2773 40 41 59 330 688 40 40 2015 340 2770 41 307 2600 40 2549 41 41 123 2769 363 1502 59 125 792 2769 59 125 306 777 809 570 2774 40 625 2775 44 2008 2012 44 2008 2013 44 2014 2015 41 123 330 688 40 2776 46 2777 40 2775 41 41 123 792 2778 40 2012 44 2013 44 2015 46 2779 40 41 44 2780 41 62 1500 59 125 330 330 792 2781 46 2782 40 1503 41 60 40 40 40 40 40 2015 46 2783 40 41 43 2775 41 45 2013 46 2784 40 41 41 45 2785 40 2015 46 2786 40 41 44 2013 41 41 42 2616 40 2012 44 2013 44 2015 41 41 42 2787 40 2012 44 2013 44 2015 46 2788 40 41 44 2789 41 41 59 125 306 777 809 704 2790 40 2791 2792 44 625 2793 41 123 657 625 2794 61 2795 46 2796 40 41 46 2797 40 2792 46 2798 40 41 41 59 688 40 2793 62 1500 41 330 123 2793 316 2799 46 2800 40 41 59 125 792 40 704 41 40 40 2801 40 2793 41 47 2794 41 47 1503 41 59 125 306 777 809 704 2802 40 704 2803 44 570 2804 41 123 704 2805 61 1506 59 688 40 2804 41 123 2805 61 40 704 41 40 40 40 40 2803 42 1500 41 43 1501 41 42 1503 41 42 1502 41 45 1504 59 688 40 2805 62 1506 41 123 792 1506 59 125 125 688 40 2803 60 1503 41 123 2805 61 40 704 41 40 40 40 40 2803 42 1500 41 43 1501 41 42 1503 41 42 1503 41 59 125 630 688 40 2803 60 1504 41 123 2805 61 40 704 41 40 40 40 40 2803 42 1500 41 43 1503 41 42 1503 41 42 1503 41 59 125 792 2805 59 125 777 809 625 2806 40 2008 2012 44 2008 2013 44 2807 2808 44 570 2809 41 123 688 40 2808 323 2807 46 2810 41 123 792 1501 59 125 688 40 2013 46 2811 40 41 46 2812 40 2808 41 41 123 792 1500 59 125 688 40 2808 46 2813 40 41 323 1502 41 123 688 40 33 2012 46 2811 40 41 46 2814 40 2808 41 309 33 2013 46 2811 40 41 46 2815 40 2808 41 41 123 792 1501 59 125 125 630 688 40 2808 46 2813 40 41 323 1502 41 123 688 40 2809 41 123 792 1501 59 125 125 630 123 792 1501 59 125 792 2727 40 2012 46 2811 40 41 46 2816 40 2808 41 45 2013 46 2811 40 41 46 2817 40 2808 41 44 1500 41 59 125 777 809 625 2818 40 2008 2012 44 2008 2013 44 2807 2808 41 123 625 2819 61 1501 59 664 40 2807 2820 58 2807 46 2821 40 41 41 123 688 40 40 2808 340 2820 41 307 2013 46 2822 40 41 46 2823 40 2820 41 307 2012 46 2822 40 41 46 2824 40 2820 41 307 33 2013 46 2822 40 41 46 2825 40 2808 41 41 123 2819 363 2727 40 2012 46 2822 40 41 46 2826 40 2820 41 45 2013 46 2822 40 41 46 2827 40 2820 41 44 1500 41 59 125 125 792 2819 59 125 777 809 625 2828 40 2008 2012 44 2008 2013 41 123 792 2727 40 1500 44 1501 45 2013 46 2829 40 41 46 2830 40 2012 46 2831 40 41 46 2832 40 41 41 41 59 125 777 809 625 2833 40 2008 2012 44 2008 2013 41 123 657 625 2834 61 2828 40 2012 44 2013 41 59 688 40 2834 323 1500 41 123 792 1500 59 125 625 2835 61 1501 59 664 40 2807 2808 58 2807 46 2836 40 41 41 123 688 40 2808 46 2837 40 41 323 1502 41 123 2835 363 2806 40 2012 44 2013 44 2808 44 2838 41 59 688 40 2835 323 1500 41 123 792 1500 59 125 125 125 792 2727 40 2834 42 2835 44 1500 41 59 125 777 809 625 2839 40 2840 2841 44 2008 2013 41 123 688 40 40 2841 323 2840 46 2842 41 309 33 2013 46 2843 40 41 41 123 792 1501 59 125 657 2844 2845 61 2013 46 2846 40 2841 41 59 792 819 40 2845 46 2847 40 41 41 123 579 1500 45 62 1501 59 579 1501 45 62 1500 59 579 1502 45 62 1500 59 613 45 62 1500 59 125 59 125 306 777 809 625 2848 40 2008 2012 44 2008 2013 44 574 2849 44 570 2850 44 570 2851 41 123 330 625 2852 61 2013 46 2853 40 41 59 688 40 2849 323 2002 41 123 2852 348 2013 46 2854 40 41 59 125 630 688 40 2849 323 2003 41 123 792 1501 59 125 657 2855 2856 61 2012 46 2857 40 41 59 657 570 2858 61 40 2856 340 2859 41 307 2856 46 2860 40 41 46 2858 40 41 59 657 625 2861 61 2850 63 2206 40 2012 44 2013 44 2859 41 58 1501 59 657 625 2862 61 2850 63 2231 40 2012 44 2013 44 2859 41 58 1500 59 657 625 2863 61 2850 63 40 2858 63 1500 58 1501 41 58 1500 59 657 625 2864 61 2851 63 2012 46 2865 40 2866 46 2867 41 58 1501 59 657 625 2868 61 2012 46 2869 40 41 59 657 625 2870 61 40 2012 46 2871 40 2013 41 63 1500 58 40 2012 46 2872 40 2013 41 63 1500 58 1500 41 41 42 2012 46 2873 40 41 59 625 2874 61 40 2012 46 2873 40 41 42 2868 41 43 2870 59 330 330 330 2874 61 40 40 40 40 2874 42 2861 42 2864 41 43 2862 41 42 2863 41 42 40 2858 63 1504 58 1503 41 41 43 40 2874 42 40 1501 45 2863 41 42 2864 42 40 2858 63 1504 58 1503 41 41 59 330 625 2875 61 2874 47 2852 59 2875 363 2833 40 2012 44 2013 41 59 2875 363 2616 40 2012 44 2013 44 2859 41 59 2875 363 2876 40 2012 44 2013 44 2859 41 59 2875 61 2727 40 1500 44 2875 41 59 792 2875 59 125 777 809 625 2877 40 2840 2841 44 2008 2013 41 123 792 819 40 2841 41 123 579 2878 45 62 2013 46 2879 40 41 46 2880 40 2881 46 2882 41 59 579 2883 45 62 2013 46 2879 40 41 46 2880 40 2881 46 2884 41 59 613 45 62 1500 59 125 59 125 777 809 625 2885 40 2008 2012 44 2008 2013 41 123 688 40 2886 40 2013 41 307 2012 46 2887 40 41 340 2888 307 2013 46 2889 40 41 45 2012 46 2887 40 41 46 2889 40 41 62 1501 41 123 657 704 2890 61 2013 46 2889 40 41 45 2012 46 2887 40 41 46 2889 40 41 45 1501 59 792 2891 46 2892 40 2890 41 59 125 792 1501 59 125 306 777 809 570 2893 40 2008 2190 41 123 330 688 40 2894 46 2895 40 41 307 2190 46 2896 40 41 307 2897 46 2898 40 1503 41 41 123 330 792 2190 46 2899 40 41 46 2900 40 2901 46 2902 44 2749 45 62 2749 46 2903 40 41 329 2749 46 2904 40 41 46 2905 40 41 41 59 125 792 2906 59 125 777 809 570 2907 40 41 123 792 2908 46 2909 40 1502 41 59 125 306 777 809 704 2910 40 704 2911 44 2912 2913 44 570 2914 44 570 2915 41 123 330 330 330 330 330 330 330 330 330 792 819 40 2913 41 123 579 2916 44 2917 44 2918 45 62 40 704 41 40 2911 42 1500 41 59 579 2919 44 2920 44 2921 44 2922 45 62 123 688 40 2915 41 123 2923 40 704 41 40 2911 42 1500 41 59 125 2924 40 704 41 40 2911 42 1500 41 59 125 613 45 62 123 688 40 2914 41 123 2925 40 704 41 40 2911 42 1500 41 59 125 2926 40 704 41 40 2911 42 1500 41 59 125 125 59 125 777 809 704 2927 40 2008 2190 44 2928 2929 41 123 2930 2931 61 2932 40 2190 44 2929 41 59 792 40 704 41 40 40 1507 43 40 1504 42 2931 41 41 47 2190 46 2933 40 41 46 2934 40 41 41 59 125 773 809 625 2935 40 2008 2190 44 2928 2929 41 123 688 40 2929 323 2936 41 123 792 1500 59 125 2937 2938 61 2929 46 2939 40 41 59 2937 2940 61 2190 46 2941 40 41 46 2942 40 2943 58 58 2913 41 46 2944 40 2938 41 59 704 2945 61 2940 46 2946 40 41 63 2929 46 2947 40 41 58 1500 59 792 2945 42 2190 46 2948 40 41 46 2949 40 41 59 125 777 809 625 2950 40 2008 2012 44 2008 2013 44 2014 2015 41 123 688 40 2951 40 2012 41 307 2951 40 2013 41 41 123 792 2952 40 2012 44 2013 44 2015 41 59 125 688 40 2953 40 2013 41 309 2953 40 2012 41 41 123 792 2954 40 2012 44 2013 44 2015 41 59 125 792 1501 59 125 773 809 625 2955 40 2008 2012 44 2008 2013 44 2014 2015 41 123 625 2956 59 657 625 2957 59 657 625 2958 59 657 625 2959 59 657 625 2960 61 2885 40 2012 44 2013 41 59 688 40 2015 340 2961 41 123 688 40 2015 46 2962 40 41 41 123 2956 61 2012 46 2963 40 41 46 2964 40 2965 46 2966 44 1501 41 59 2957 61 2013 46 2963 40 41 46 2964 40 2965 46 2967 44 1501 41 59 2958 61 2012 46 2968 40 41 63 2013 46 2963 40 41 46 2964 40 2965 46 2969 44 1501 41 58 1501 59 2959 61 2012 46 2968 40 41 63 2012 46 2963 40 41 46 2964 40 2965 46 2970 44 1501 41 58 1501 59 125 630 123 2956 61 2012 46 2971 40 41 46 2972 40 2973 46 2974 44 1501 41 59 2957 61 2013 46 2971 40 41 46 2972 40 2973 46 2975 44 1501 41 59 2959 61 2012 46 2976 40 41 63 2012 46 2971 40 41 46 2972 40 2973 46 2977 44 1501 41 58 1501 59 2958 61 2012 46 2976 40 41 63 2013 46 2971 40 41 46 2972 40 2973 46 2978 44 1501 41 58 1501 59 125 125 630 123 2956 61 2012 46 2979 40 41 46 2980 40 2981 46 2982 44 1501 41 59 2957 61 2013 46 2979 40 41 46 2980 40 2981 46 2983 44 1501 41 59 2959 61 2012 46 2984 40 41 63 2012 46 2979 40 41 46 2980 40 2981 46 2985 44 1501 41 58 1501 59 2958 61 2012 46 2984 40 41 63 2013 46 2979 40 41 46 2980 40 2981 46 2986 44 1501 41 58 1501 59 125 792 2987 46 2727 40 1500 44 40 1501 43 40 40 2956 42 2959 41 45 40 2957 42 2958 41 41 41 42 2960 41 59 125 773 809 625 2988 40 2008 2012 44 2008 2013 44 2014 2015 41 123 625 2989 59 657 625 2990 59 688 40 2015 340 2991 41 123 688 40 2015 46 2992 40 41 41 123 2989 61 2012 46 2993 40 41 46 2994 40 2995 46 2996 44 1501 41 59 2990 61 2013 46 2993 40 41 46 2994 40 2995 46 2997 44 1501 41 59 125 630 123 2989 61 2012 46 2998 40 41 46 2999 40 3000 46 3001 44 1501 41 59 2990 61 2013 46 2998 40 41 46 2999 40 3000 46 3002 44 1501 41 59 125 125 630 123 2989 61 2012 46 3003 40 41 46 3004 40 3005 46 3006 44 1501 41 59 2990 61 2013 46 3003 40 41 46 3004 40 3005 46 3007 44 1501 41 59 125 792 2727 40 1500 44 1501 43 40 2989 45 2990 41 41 59 125 777 809 625 3008 40 2008 2012 44 2008 2013 44 625 3009 41 123 330 688 40 3010 40 2012 41 41 123 3011 3012 61 2012 46 3013 40 41 59 3014 3015 61 3014 46 3016 40 3012 46 3017 40 41 41 59 3011 3018 61 1500 59 688 40 3014 46 3019 323 3015 41 123 792 3018 59 125 3011 3020 61 3012 46 3021 40 41 59 3011 3022 61 3023 46 3024 40 3020 42 1502 44 1504 41 62 3025 46 3026 40 1504 41 59 3011 3027 61 3012 46 3028 40 41 59 3011 3029 61 3012 46 3030 40 41 45 2013 46 3031 40 3015 41 43 3025 46 3026 40 45 1502 44 1502 41 59 688 40 3010 40 2013 41 41 123 792 3032 40 3029 44 3027 44 3022 44 3009 41 59 125 792 3033 40 3015 44 2013 46 3034 40 41 44 3029 44 3027 44 3022 44 3009 41 59 125 792 1500 59 125 773 809 625 3035 40 625 3036 44 625 3037 44 570 3038 44 625 3009 41 123 3039 3040 61 3041 40 2727 40 1500 44 40 3036 42 1502 43 3009 42 1500 42 3036 41 47 3042 40 2727 40 3036 44 1502 41 41 41 44 1505 41 59 688 40 3038 41 123 3040 363 1501 43 40 3043 46 3044 40 1503 44 1503 41 43 3037 41 47 1503 59 125 792 3040 59 125 773 809 625 3045 40 3046 3047 44 3046 3048 44 625 3036 44 625 3037 44 570 3038 44 625 3009 41 123 625 3049 61 3050 40 3036 42 1500 41 59 625 3051 59 688 40 3047 46 3052 40 3048 41 41 123 3049 363 1502 59 3051 61 1502 59 125 630 688 40 3048 323 3047 41 123 3051 61 1502 59 125 630 123 3049 363 1502 59 3051 61 1502 59 125 688 40 3038 41 123 3049 348 3050 40 40 1503 43 40 1502 43 3036 42 1500 41 42 3037 41 42 3051 43 3053 46 3054 40 45 1502 44 1503 41 41 59 125 792 40 40 3049 43 3009 41 42 3051 41 47 3055 40 1503 43 3009 43 3049 41 59 125 125 ,"{'AvgLine': 19, 'CountLine': 1159, 'CountStmt': 579, 'MaxNesting': 4, 'AvgLineCode': 13, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 475, 'MaxEssential': 7, 'SumEssential': 108, 'AvgCyclomatic': 3, 'CountLineCode': 790, 'CountStmtDecl': 219, 'MaxCyclomatic': 12, 'SumCyclomatic': 213, 'AvgLineComment': 3, 'CountClassBase': 1, 'CountLineBlank': 169, 'CountSemicolon': 400, 'CountDeclMethod': 57, 'CountLineCodeExe': 543, 'CountLineComment': 216, 'CountClassCoupled': 50, 'CountClassDerived': 0, 'CountLineCodeDecl': 217, 'CountDeclMethodAll': 57, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.27', 'AvgCyclomaticStrict': 4, 'MaxCyclomaticStrict': 13, 'SumCyclomaticStrict': 260, 'CountDeclClassMethod': 57, 'AvgCyclomaticModified': 3, 'CountDeclMethodPublic': 50, 'MaxCyclomaticModified': 12, 'PercentLackOfCohesion': 0, 'SumCyclomaticModified': 210, 'CountDeclClassVariable': 6, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 7, 'CountDeclInstanceMethod': 0, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 50, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 0}"
3543,Java,"@Slf4j
class XmrTxProofRequestsPerTrade implements AssetTxProofRequestsPerTrade {
    @Getter
    private final Trade trade;
    private final AutoConfirmSettings autoConfirmSettings;
    private final MediationManager mediationManager;
    private final FilterManager filterManager;
    private final RefundManager refundManager;
    private final Socks5ProxyProvider socks5ProxyProvider;

    private int numRequiredSuccessResults;
    private final Set<XmrTxProofRequest> requests = new HashSet<>();

    private int numSuccessResults;
    private ChangeListener<Trade.State> tradeStateListener;
    private AutoConfirmSettings.Listener autoConfirmSettingsListener;
    private ListChangeListener<Dispute> mediationListener, refundListener;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    XmrTxProofRequestsPerTrade(Socks5ProxyProvider socks5ProxyProvider,
                               Trade trade,
                               AutoConfirmSettings autoConfirmSettings,
                               MediationManager mediationManager,
                               FilterManager filterManager,
                               RefundManager refundManager) {
        this.socks5ProxyProvider = socks5ProxyProvider;
        this.trade = trade;
        this.autoConfirmSettings = autoConfirmSettings;
        this.mediationManager = mediationManager;
        this.filterManager = filterManager;
        this.refundManager = refundManager;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void requestFromAllServices(Consumer<AssetTxProofResult> resultHandler, FaultHandler faultHandler) {
        // isTradeAmountAboveLimit
        if (isTradeAmountAboveLimit(trade)) {
            callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.TRADE_LIMIT_EXCEEDED);
            return;
        }

        // isPayoutPublished
        if (trade.isPayoutPublished()) {
            callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.PAYOUT_TX_ALREADY_PUBLISHED);
            return;
        }

        // IsEnabled()
        // We will stop all our services if the user changes the enable state in the AutoConfirmSettings
        if (!autoConfirmSettings.isEnabled()) {
            callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.FEATURE_DISABLED);
            return;
        }
        addSettingsListener(resultHandler);

        // TradeState
        setupTradeStateListener(resultHandler);
        // We checked initially for current trade state so no need to check again here

        // Check if mediation dispute and add listener
        ObservableList<Dispute> mediationDisputes = mediationManager.getDisputesAsObservableList();
        if (isDisputed(mediationDisputes)) {
            callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.DISPUTE_OPENED);
            return;
        }
        setupMediationListener(resultHandler, mediationDisputes);

        // Check if arbitration dispute and add listener
        ObservableList<Dispute> refundDisputes = refundManager.getDisputesAsObservableList();
        if (isDisputed(refundDisputes)) {
            callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.DISPUTE_OPENED);
            return;
        }
        setupArbitrationListener(resultHandler, refundDisputes);

        // All good so we start
        callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.REQUESTS_STARTED);

        // We set serviceAddresses at request time. If user changes AutoConfirmSettings after request has started
        // it will have no impact on serviceAddresses and numRequiredSuccessResults.
        // Though numRequiredConfirmations can be changed during request process and will be read from
        // autoConfirmSettings at result parsing.
        List<String> serviceAddresses = autoConfirmSettings.getServiceAddresses();
        numRequiredSuccessResults = serviceAddresses.size();

        for (String serviceAddress : serviceAddresses) {
            if (filterManager.isAutoConfExplorerBanned(serviceAddress)) {
                log.warn(""Filtered out auto-confirmation address: {}"", serviceAddress);
                continue;  // #4683: filter for auto-confirm explorers
            }
            XmrTxProofModel model = new XmrTxProofModel(trade, serviceAddress, autoConfirmSettings);
            XmrTxProofRequest request = new XmrTxProofRequest(socks5ProxyProvider, model);

            log.info(""{} created"", request);
            requests.add(request);

            request.requestFromService(result -> {
                        // If we ever received an error or failed result we terminate and do not process any
                        // future result anymore to avoid that we overwrite out state with success.
                        if (wasTerminated()) {
                            return;
                        }

                        AssetTxProofResult assetTxProofResult;
                        if (trade.isPayoutPublished()) {
                            assetTxProofResult = AssetTxProofResult.PAYOUT_TX_ALREADY_PUBLISHED;
                            callResultHandlerAndMaybeTerminate(resultHandler, assetTxProofResult);
                            return;
                        }

                        switch (result) {
                            case PENDING:
                                // We expect repeated PENDING results with different details
                                assetTxProofResult = getAssetTxProofResultForPending(result);
                                break;
                            case SUCCESS:
                                numSuccessResults++;
                                if (numSuccessResults < numRequiredSuccessResults) {
                                    // Request is success but not all have completed yet.
                                    int remaining = numRequiredSuccessResults - numSuccessResults;
                                    log.info(""{} succeeded. We have {} remaining request(s) open."",
                                            request, remaining);
                                    assetTxProofResult = getAssetTxProofResultForPending(result);
                                } else {
                                    // All our services have returned a SUCCESS result so we
                                    // have completed on the service level.
                                    log.info(""All {} tx proof requests for trade {} have been successful."",
                                            numRequiredSuccessResults, trade.getShortId());
                                    XmrTxProofRequest.Detail detail = result.getDetail();
                                    assetTxProofResult = AssetTxProofResult.COMPLETED
                                            .numSuccessResults(numSuccessResults)
                                            .numRequiredSuccessResults(numRequiredSuccessResults)
                                            .numConfirmations(detail != null ? detail.getNumConfirmations() : 0)
                                            .numRequiredConfirmations(autoConfirmSettings.getRequiredConfirmations());
                                }
                                break;
                            case FAILED:
                                log.warn(""{} failed. "" +
                                                ""This might not mean that the XMR transfer was invalid but you have to check yourself "" +
                                                ""if the XMR transfer was correct. {}"",
                                        request, result);

                                assetTxProofResult = AssetTxProofResult.FAILED;
                                break;
                            case ERROR:
                            default:
                                log.warn(""{} resulted in an error. "" +
                                                ""This might not mean that the XMR transfer was invalid but can be a network or "" +
                                                ""service problem. {}"",
                                        request, result);

                                assetTxProofResult = AssetTxProofResult.ERROR;
                                break;
                        }

                        callResultHandlerAndMaybeTerminate(resultHandler, assetTxProofResult);
                    },
                    faultHandler);
        }
    }

    private boolean wasTerminated() {
        return requests.isEmpty();
    }

    private void addSettingsListener(Consumer<AssetTxProofResult> resultHandler) {
        autoConfirmSettingsListener = () -> {
            if (!autoConfirmSettings.isEnabled()) {
                callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.FEATURE_DISABLED);
            }
        };
        autoConfirmSettings.addListener(autoConfirmSettingsListener);
    }

    private void setupTradeStateListener(Consumer<AssetTxProofResult> resultHandler) {
        tradeStateListener = (observable, oldValue, newValue) -> {
            if (trade.isPayoutPublished()) {
                callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.PAYOUT_TX_ALREADY_PUBLISHED);
            }
        };
        trade.stateProperty().addListener(tradeStateListener);
    }

    private void setupArbitrationListener(Consumer<AssetTxProofResult> resultHandler,
                                          ObservableList<Dispute> refundDisputes) {
        refundListener = c -> {
            c.next();
            if (c.wasAdded() && isDisputed(c.getAddedSubList())) {
                callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.DISPUTE_OPENED);
            }
        };
        refundDisputes.addListener(refundListener);
    }

    private void setupMediationListener(Consumer<AssetTxProofResult> resultHandler,
                                        ObservableList<Dispute> mediationDisputes) {
        mediationListener = c -> {
            c.next();
            if (c.wasAdded() && isDisputed(c.getAddedSubList())) {
                callResultHandlerAndMaybeTerminate(resultHandler, AssetTxProofResult.DISPUTE_OPENED);
            }
        };
        mediationDisputes.addListener(mediationListener);
    }

    @Override
    public void terminate() {
        requests.forEach(XmrTxProofRequest::terminate);
        requests.clear();

        if (tradeStateListener != null) {
            trade.stateProperty().removeListener(tradeStateListener);
        }

        if (autoConfirmSettingsListener != null) {
            autoConfirmSettings.removeListener(autoConfirmSettingsListener);
        }

        if (mediationListener != null) {
            mediationManager.getDisputesAsObservableList().removeListener(mediationListener);
        }

        if (refundListener != null) {
            refundManager.getDisputesAsObservableList().removeListener(refundListener);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void callResultHandlerAndMaybeTerminate(Consumer<AssetTxProofResult> resultHandler,
                                                    AssetTxProofResult assetTxProofResult) {
        resultHandler.accept(assetTxProofResult);
        if (assetTxProofResult.isTerminal()) {
            terminate();
        }
    }

    private AssetTxProofResult getAssetTxProofResultForPending(XmrTxProofRequest.Result result) {
        XmrTxProofRequest.Detail detail = result.getDetail();
        int numConfirmations = detail != null ? detail.getNumConfirmations() : 0;
        log.info(""{} returned with numConfirmations {}"",
                result, numConfirmations);

        String detailString = """";
        if (XmrTxProofRequest.Detail.PENDING_CONFIRMATIONS == detail) {
            detailString = Res.get(""portfolio.pending.autoConf.state.confirmations"",
                    numConfirmations, autoConfirmSettings.getRequiredConfirmations());

        } else if (XmrTxProofRequest.Detail.TX_NOT_FOUND == detail) {
            detailString = Res.get(""portfolio.pending.autoConf.state.txNotFound"");
        }

        return AssetTxProofResult.PENDING
                .numSuccessResults(numSuccessResults)
                .numRequiredSuccessResults(numRequiredSuccessResults)
                .numConfirmations(detail != null ? detail.getNumConfirmations() : 0)
                .numRequiredConfirmations(autoConfirmSettings.getRequiredConfirmations())
                .details(detailString);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Validation
    ///////////////////////////////////////////////////////////////////////////////////////////

    private boolean isTradeAmountAboveLimit(Trade trade) {
        Coin tradeAmount = trade.getAmount();
        Coin tradeLimit = Coin.valueOf(autoConfirmSettings.getTradeLimit());
        if (tradeAmount != null && tradeAmount.isGreaterThan(tradeLimit)) {
            log.warn(""Trade amount {} is higher than limit from auto-conf setting {}."",
                    tradeAmount.toFriendlyString(), tradeLimit.toFriendlyString());
            return true;
        }
        return false;
    }

    private boolean isDisputed(List<? extends Dispute> disputes) {
        return disputes.stream().anyMatch(e -> e.getTradeId().equals(trade.getId()));
    }
}",1,64 2000 587 2001 693 2002 123 64 2003 773 657 2004 2005 59 773 657 2006 2007 59 773 657 2008 2009 59 773 657 2010 2011 59 773 657 2012 2013 59 773 657 2014 2015 59 773 704 2016 59 773 657 2017 60 2018 62 2019 61 744 2020 60 62 40 41 59 773 704 2021 59 773 2022 60 2004 46 2023 62 2024 59 773 2006 46 2025 2026 59 773 2027 60 2028 62 2029 44 2030 59 331 330 331 2001 40 2014 2015 44 2004 2005 44 2006 2007 44 2008 2009 44 2010 2011 44 2012 2013 41 123 823 46 2015 61 2015 59 823 46 2005 61 2005 59 823 46 2007 61 2007 59 823 46 2009 61 2009 59 823 46 2011 61 2011 59 823 46 2013 61 2013 59 125 331 330 331 64 2031 777 865 2032 40 2033 60 2034 62 2035 44 2036 2037 41 123 330 688 40 2038 40 2005 41 41 123 2039 40 2035 44 2034 46 2040 41 59 792 59 125 330 688 40 2005 46 2041 40 41 41 123 2042 40 2035 44 2034 46 2043 41 59 792 59 125 330 330 688 40 33 2007 46 2044 40 41 41 123 2045 40 2035 44 2034 46 2046 41 59 792 59 125 2047 40 2035 41 59 330 2048 40 2035 41 59 330 330 2049 60 2028 62 2050 61 2009 46 2051 40 41 59 688 40 2052 40 2050 41 41 123 2053 40 2035 44 2034 46 2054 41 59 792 59 125 2055 40 2035 44 2050 41 59 330 2049 60 2028 62 2056 61 2013 46 2051 40 41 59 688 40 2052 40 2056 41 41 123 2057 40 2035 44 2034 46 2058 41 59 792 59 125 2059 40 2035 44 2056 41 59 330 2060 40 2035 44 2034 46 2061 41 59 330 330 330 330 2062 60 2063 62 2064 61 2007 46 2065 40 41 59 2016 61 2064 46 2066 40 41 59 664 40 2063 2067 58 2064 41 123 688 40 2011 46 2068 40 2067 41 41 123 2069 46 2070 40 362 44 2067 41 59 605 59 330 125 2071 2072 61 744 2071 40 2005 44 2067 44 2007 41 59 2018 2073 61 744 2018 40 2015 44 2072 41 59 2074 46 2075 40 362 44 2073 41 59 2019 46 2076 40 2073 41 59 2073 46 2077 40 2078 45 62 123 330 330 688 40 2079 40 41 41 123 792 59 125 2034 2080 59 688 40 2005 46 2041 40 41 41 123 2080 61 2034 46 2081 59 2060 40 2035 44 2080 41 59 792 59 125 819 40 2078 41 123 579 2082 58 330 2080 61 2083 40 2078 41 59 572 59 579 2084 58 2021 349 59 688 40 2021 60 2016 41 123 330 704 2085 61 2016 45 2021 59 2074 46 2075 40 362 44 2073 44 2085 41 59 2080 61 2083 40 2078 41 59 125 630 123 330 330 2074 46 2075 40 362 44 2016 44 2005 46 2086 40 41 41 59 2018 46 2087 2088 61 2078 46 2089 40 41 59 2080 61 2034 46 2090 46 2021 40 2021 41 46 2016 40 2016 41 46 2091 40 2088 340 2092 63 2088 46 2093 40 41 58 1500 41 46 2094 40 2007 46 2095 40 41 41 59 125 572 59 579 2096 58 2074 46 2097 40 362 43 362 43 362 44 2073 44 2078 41 59 2080 61 2034 46 2096 59 572 59 579 2098 58 613 58 2074 46 2097 40 362 43 362 43 362 44 2073 44 2078 41 59 2080 61 2034 46 2098 59 572 59 125 2060 40 2035 44 2080 41 59 125 44 2037 41 59 125 125 773 570 2099 40 41 123 792 2019 46 2100 40 41 59 125 773 865 2101 40 2033 60 2034 62 2035 41 123 2026 61 40 41 45 62 123 688 40 33 2007 46 2102 40 41 41 123 2103 40 2035 44 2034 46 2104 41 59 125 125 59 2007 46 2105 40 2026 41 59 125 773 865 2106 40 2033 60 2034 62 2035 41 123 2024 61 40 2107 44 2108 44 2109 41 45 62 123 688 40 2005 46 2110 40 41 41 123 2111 40 2035 44 2034 46 2112 41 59 125 125 59 2005 46 2113 40 41 46 2114 40 2024 41 59 125 773 865 2115 40 2033 60 2034 62 2035 44 2116 60 2028 62 2117 41 123 2030 61 2118 45 62 123 2118 46 2119 40 41 59 688 40 2118 46 2120 40 41 307 2121 40 2118 46 2122 40 41 41 41 123 2123 40 2035 44 2034 46 2124 41 59 125 125 59 2117 46 2125 40 2030 41 59 125 773 865 2126 40 2033 60 2034 62 2035 44 2116 60 2028 62 2127 41 123 2029 61 2128 45 62 123 2128 46 2129 40 41 59 688 40 2128 46 2130 40 41 307 2131 40 2128 46 2132 40 41 41 41 123 2133 40 2035 44 2034 46 2134 41 59 125 125 59 2127 46 2135 40 2029 41 59 125 64 2031 777 865 2136 40 41 123 2019 46 2137 40 2018 58 58 2136 41 59 2019 46 2138 40 41 59 688 40 2024 340 2139 41 123 2005 46 2140 40 41 46 2141 40 2024 41 59 125 688 40 2026 340 2139 41 123 2007 46 2142 40 2026 41 59 125 688 40 2029 340 2139 41 123 2009 46 2143 40 41 46 2144 40 2029 41 59 125 688 40 2030 340 2139 41 123 2013 46 2145 40 41 46 2146 40 2030 41 59 125 125 331 330 331 773 865 2147 40 2033 60 2034 62 2035 44 2034 2148 41 123 2035 46 2149 40 2148 41 59 688 40 2148 46 2150 40 41 41 123 2136 40 41 59 125 125 773 2034 2151 40 2018 46 2152 2153 41 123 2018 46 2154 2155 61 2153 46 2156 40 41 59 704 2157 61 2155 340 2158 63 2155 46 2159 40 41 58 1500 59 2160 46 2161 40 362 44 2153 44 2157 41 59 2162 2163 61 362 59 688 40 2018 46 2154 46 2164 323 2155 41 123 2163 61 2165 46 2166 40 362 44 2157 44 2007 46 2167 40 41 41 59 125 630 688 40 2018 46 2154 46 2168 323 2155 41 123 2163 61 2169 46 2170 40 362 41 59 125 792 2034 46 2171 46 2021 40 2021 41 46 2016 40 2016 41 46 2157 40 2155 340 2158 63 2155 46 2159 40 41 58 1500 41 46 2172 40 2007 46 2173 40 41 41 46 2174 40 2163 41 59 125 331 330 331 773 570 2175 40 2004 2005 41 123 2176 2177 61 2005 46 2178 40 41 59 2176 2179 61 2176 46 2180 40 2007 46 2181 40 41 41 59 688 40 2177 340 2182 307 2177 46 2183 40 2179 41 41 123 2184 46 2185 40 362 44 2177 46 2186 40 41 44 2179 46 2186 40 41 41 59 792 2187 59 125 792 2188 59 125 773 570 2189 40 2190 60 63 650 2028 62 2191 41 123 792 2191 46 2192 40 41 46 2193 40 2194 45 62 2194 46 2195 40 41 46 2196 40 2005 46 2197 40 41 41 41 59 125 125 ,"{'AvgLine': 20, 'CountLine': 295, 'CountStmt': 139, 'MaxNesting': 3, 'AvgLineCode': 16, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 111, 'MaxEssential': 8, 'SumEssential': 27, 'AvgCyclomatic': 2, 'CountLineCode': 217, 'CountStmtDecl': 39, 'MaxCyclomatic': 8, 'SumCyclomatic': 47, 'AvgLineComment': 1, 'CountClassBase': 2, 'CountLineBlank': 44, 'CountSemicolon': 102, 'CountDeclMethod': 12, 'CountLineCodeExe': 145, 'CountLineComment': 35, 'CountClassCoupled': 28, 'CountClassDerived': 0, 'CountLineCodeDecl': 50, 'CountDeclMethodAll': 12, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.16', 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 50, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 8, 'PercentLackOfCohesion': 78, 'SumCyclomaticModified': 44, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 1, 'CountDeclMethodPrivate': 9, 'CountDeclInstanceMethod': 12, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 28, 'CountDeclInstanceVariable': 13, 'PercentLackOfCohesionModified': 69}"
3208,Java,"@Slf4j
public final class PeerManager implements ConnectionListener, PersistedDataHost {

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Static
    ///////////////////////////////////////////////////////////////////////////////////////////

    private static final long CHECK_MAX_CONN_DELAY_SEC = 10;
    // Use a long delay as the bootstrapping peer might need a while until it knows its onion address
    private static final long REMOVE_ANONYMOUS_PEER_SEC = 240;

    private static final int MAX_REPORTED_PEERS = 1000;
    private static final int MAX_PERSISTED_PEERS = 500;
    // max age for reported peers is 14 days
    private static final long MAX_AGE = TimeUnit.DAYS.toMillis(14);
    // Age of what we consider connected peers still as live peers
    private static final long MAX_AGE_LIVE_PEERS = TimeUnit.MINUTES.toMillis(30);
    private static final boolean PRINT_REPORTED_PEERS_DETAILS = true;
    private Timer printStatisticsTimer;
    private boolean shutDownRequested;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Listener
    ///////////////////////////////////////////////////////////////////////////////////////////

    public interface Listener {
        void onAllConnectionsLost();

        void onNewConnectionAfterAllConnectionsLost();

        void onAwakeFromStandby();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Instance fields
    ///////////////////////////////////////////////////////////////////////////////////////////

    private final NetworkNode networkNode;
    private final ClockWatcher clockWatcher;
    private final Set<NodeAddress> seedNodeAddresses;
    private final PersistenceManager<PeerList> persistenceManager;
    private final ClockWatcher.Listener clockWatcherListener;
    private final List<Listener> listeners = new CopyOnWriteArrayList<>();

    // Persistable peerList
    private final PeerList peerList = new PeerList();
    // Peers we got reported from other peers
    @Getter
    private final Set<Peer> reportedPeers = new HashSet<>();
    // Most recent peers with activity date of last 30 min.
    private final Set<Peer> latestLivePeers = new HashSet<>();

    private Timer checkMaxConnectionsTimer;
    private boolean stopped;
    private boolean lostAllConnections;
    private int maxConnections;

    @Getter
    private int minConnections;
    private int outBoundPeerTrigger;
    private int initialDataExchangeTrigger;
    private int maxConnectionsAbsolute;
    @Getter
    private int peakNumConnections;
    @Getter
    private int numAllConnectionsLostEvents;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public PeerManager(NetworkNode networkNode,
                       SeedNodeRepository seedNodeRepository,
                       ClockWatcher clockWatcher,
                       PersistenceManager<PeerList> persistenceManager,
                       @Named(Config.MAX_CONNECTIONS) int maxConnections) {
        this.networkNode = networkNode;
        this.seedNodeAddresses = new HashSet<>(seedNodeRepository.getSeedNodeAddresses());
        this.clockWatcher = clockWatcher;
        this.persistenceManager = persistenceManager;

        this.persistenceManager.initialize(peerList, PersistenceManager.Source.PRIVATE_LOW_PRIO);
        this.networkNode.addConnectionListener(this);

        setConnectionLimits(maxConnections);

        // we check if app was idle for more then 5 sec.
        clockWatcherListener = new ClockWatcher.Listener() {
            @Override
            public void onSecondTick() {
            }

            @Override
            public void onMinuteTick() {
            }

            @Override
            public void onAwakeFromStandby(long missedMs) {
                // We got probably stopped set to true when we got a longer interruption (e.g. lost all connections),
                // now we get awake again, so set stopped to false.
                stopped = false;
                listeners.forEach(Listener::onAwakeFromStandby);
            }
        };
        clockWatcher.addListener(clockWatcherListener);

        printStatisticsTimer = UserThread.runPeriodically(this::printStatistics, TimeUnit.MINUTES.toSeconds(5));
    }

    public void shutDown() {
        shutDownRequested = true;

        networkNode.removeConnectionListener(this);
        clockWatcher.removeListener(clockWatcherListener);

        stopCheckMaxConnectionsTimer();

        if (printStatisticsTimer != null) {
            printStatisticsTimer.stop();
            printStatisticsTimer = null;
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // PersistedDataHost implementation
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void readPersisted(Runnable completeHandler) {
        persistenceManager.readPersisted(persisted -> {
                    peerList.setAll(persisted.getSet());
                    completeHandler.run();
                },
                completeHandler);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // ConnectionListener implementation
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onConnection(Connection connection) {
        connection.getConnectionState().setSeedNode(isSeedNode(connection));

        doHouseKeeping();

        if (lostAllConnections) {
            lostAllConnections = false;
            stopped = false;
            log.info(""\n------------------------------------------------------------\n"" +
                    ""Established a new connection from/to {} after all connections lost.\n"" +
                    ""------------------------------------------------------------"", connection.getPeersNodeAddressOptional());
            listeners.forEach(Listener::onNewConnectionAfterAllConnectionsLost);
        }
        connection.getPeersNodeAddressOptional()
                .flatMap(this::findPeer)
                .ifPresent(Peer::onConnection);
    }

    @Override
    public void onDisconnect(CloseConnectionReason closeConnectionReason, Connection connection) {
        log.info(""onDisconnect called: nodeAddress={}, closeConnectionReason={}"",
                connection.getPeersNodeAddressOptional(), closeConnectionReason);
        handleConnectionFault(connection);

        boolean previousLostAllConnections = lostAllConnections;
        lostAllConnections = networkNode.getAllConnections().isEmpty();

        if (lostAllConnections) {
            stopped = true;

            if (!shutDownRequested) {
                if (!previousLostAllConnections) {
                    // If we enter to 'All connections lost' we count the event.
                    numAllConnectionsLostEvents++;
                }

                log.warn(""\n------------------------------------------------------------\n"" +
                        ""All connections lost\n"" +
                        ""------------------------------------------------------------"");

                listeners.forEach(Listener::onAllConnectionsLost);
            }
        }
        maybeRemoveBannedPeer(closeConnectionReason, connection);
    }

    @Override
    public void onError(Throwable throwable) {
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Connection
    ///////////////////////////////////////////////////////////////////////////////////////////

    public boolean hasSufficientConnections() {
        return networkNode.getConfirmedConnections().size() >= minConnections;
    }

    // Checks if that connection has the peers node address
    public boolean isConfirmed(NodeAddress nodeAddress) {
        return networkNode.getNodeAddressesOfConfirmedConnections().contains(nodeAddress);
    }

    public void handleConnectionFault(Connection connection) {
        connection.getPeersNodeAddressOptional().ifPresent(nodeAddress -> handleConnectionFault(nodeAddress, connection));
    }

    public void handleConnectionFault(NodeAddress nodeAddress) {
        handleConnectionFault(nodeAddress, null);
    }

    public void handleConnectionFault(NodeAddress nodeAddress, @Nullable Connection connection) {
        boolean doRemovePersistedPeer = false;
        removeReportedPeer(nodeAddress);
        Optional<Peer> persistedPeerOptional = findPersistedPeer(nodeAddress);
        if (persistedPeerOptional.isPresent()) {
            Peer persistedPeer = persistedPeerOptional.get();
            persistedPeer.onDisconnect();
            doRemovePersistedPeer = persistedPeer.tooManyFailedConnectionAttempts();
        }
        boolean ruleViolation = connection != null && connection.getRuleViolation() != null;
        doRemovePersistedPeer = doRemovePersistedPeer || ruleViolation;

        if (doRemovePersistedPeer)
            removePersistedPeer(nodeAddress);
        else
            removeTooOldPersistedPeers();
    }

    public boolean isSeedNode(Connection connection) {
        return connection.getPeersNodeAddressOptional().isPresent() &&
                isSeedNode(connection.getPeersNodeAddressOptional().get());
    }

    public boolean isSelf(NodeAddress nodeAddress) {
        return nodeAddress.equals(networkNode.getNodeAddress());
    }

    private boolean isSeedNode(Peer peer) {
        return seedNodeAddresses.contains(peer.getNodeAddress());
    }

    public boolean isSeedNode(NodeAddress nodeAddress) {
        return seedNodeAddresses.contains(nodeAddress);
    }

    public boolean isPeerBanned(CloseConnectionReason closeConnectionReason, Connection connection) {
        return closeConnectionReason == CloseConnectionReason.PEER_BANNED &&
                connection.getPeersNodeAddressOptional().isPresent();
    }

    private void maybeRemoveBannedPeer(CloseConnectionReason closeConnectionReason, Connection connection) {
        if (connection.getPeersNodeAddressOptional().isPresent() && isPeerBanned(closeConnectionReason, connection)) {
            NodeAddress nodeAddress = connection.getPeersNodeAddressOptional().get();
            seedNodeAddresses.remove(nodeAddress);
            removePersistedPeer(nodeAddress);
            removeReportedPeer(nodeAddress);
        }
    }

    public void maybeResetNumAllConnectionsLostEvents() {
        if (!networkNode.getAllConnections().isEmpty()) {
            numAllConnectionsLostEvents = 0;
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Peer
    ///////////////////////////////////////////////////////////////////////////////////////////

    @SuppressWarnings(""unused"")
    public Optional<Peer> findPeer(NodeAddress peersNodeAddress) {
        return getAllPeers().stream()
                .filter(peer -> peer.getNodeAddress().equals(peersNodeAddress))
                .findAny();
    }

    public Set<Peer> getAllPeers() {
        Set<Peer> allPeers = new HashSet<>(getLivePeers());
        allPeers.addAll(getPersistedPeers());
        allPeers.addAll(reportedPeers);
        return allPeers;
    }

    public Collection<Peer> getPersistedPeers() {
        return peerList.getSet();
    }

    public void addToReportedPeers(Set<Peer> reportedPeersToAdd,
                                   Connection connection,
                                   Capabilities capabilities) {
        applyCapabilities(connection, capabilities);

        Set<Peer> peers = reportedPeersToAdd.stream()
                .filter(peer -> !isSelf(peer.getNodeAddress()))
                .collect(Collectors.toSet());

        printNewReportedPeers(peers);

        // We check if the reported msg is not violating our rules
        if (peers.size() <= (MAX_REPORTED_PEERS + maxConnectionsAbsolute + 10)) {
            reportedPeers.addAll(peers);
            purgeReportedPeersIfExceeds();

            getPersistedPeers().addAll(peers);
            purgePersistedPeersIfExceeds();
            requestPersistence();

            printReportedPeers();
        } else {
            // If a node is trying to send too many list we treat it as rule violation.
            // Reported list include the connected list. We use the max value and give some extra headroom.
            // Will trigger a shutdown after 2nd time sending too much
            connection.reportInvalidRequest(RuleViolation.TOO_MANY_REPORTED_PEERS_SENT);
        }
    }

    // Delivers the live peers from the last 30 min (MAX_AGE_LIVE_PEERS)
    // We include older peers to avoid risks for network partitioning
    public Set<Peer> getLivePeers() {
        return getLivePeers(null);
    }

    public Set<Peer> getLivePeers(@Nullable NodeAddress excludedNodeAddress) {
        int oldNumLatestLivePeers = latestLivePeers.size();

        Set<Peer> peers = new HashSet<>(latestLivePeers);
        Set<Peer> currentLivePeers = getConnectedReportedPeers().stream()
                .filter(e -> !isSeedNode(e))
                .filter(e -> !e.getNodeAddress().equals(excludedNodeAddress))
                .collect(Collectors.toSet());
        peers.addAll(currentLivePeers);

        long maxAge = new Date().getTime() - MAX_AGE_LIVE_PEERS;
        latestLivePeers.clear();
        Set<Peer> recentPeers = peers.stream()
                .filter(peer -> peer.getDateAsLong() > maxAge)
                .collect(Collectors.toSet());
        latestLivePeers.addAll(recentPeers);

        if (oldNumLatestLivePeers != latestLivePeers.size())
            log.info(""Num of latestLivePeers={}"", latestLivePeers.size());
        return latestLivePeers;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Capabilities
    ///////////////////////////////////////////////////////////////////////////////////////////

    public boolean peerHasCapability(NodeAddress peersNodeAddress, Capability capability) {
        return findPeersCapabilities(peersNodeAddress)
                .map(capabilities -> capabilities.contains(capability))
                .orElse(false);
    }

    public Optional<Capabilities> findPeersCapabilities(NodeAddress nodeAddress) {
        // We look up first our connections as that is our own data. If not found there we look up the peers which
        // include reported peers.
        Optional<Capabilities> optionalCapabilities = networkNode.findPeersCapabilities(nodeAddress);
        if (optionalCapabilities.isPresent() && !optionalCapabilities.get().isEmpty()) {
            return optionalCapabilities;
        }

        // Reported peers are not trusted data. We could get capabilities which miss the
        // peers real capability or we could get maliciously altered capabilities telling us the peer supports a
        // capability which is in fact not supported. This could lead to connection loss as we might send data not
        // recognized by the peer. As we register a listener on connection if we don't have set the capability from our
        // own sources we would get it fixed as soon we have a connection with that peer, rendering such an attack
        // inefficient.
        // Also this risk is only for not updated peers, so in case that would be abused for an
        // attack all users have a strong incentive to update ;-).
        return getAllPeers().stream()
                .filter(peer -> peer.getNodeAddress().equals(nodeAddress))
                .findAny()
                .map(Peer::getCapabilities);
    }

    private void applyCapabilities(Connection connection, Capabilities newCapabilities) {
        if (newCapabilities == null || newCapabilities.isEmpty()) {
            return;
        }

        connection.getPeersNodeAddressOptional().ifPresent(nodeAddress -> {
            getAllPeers().stream()
                    .filter(peer -> peer.getNodeAddress().equals(nodeAddress))
                    .filter(peer -> peer.getCapabilities().hasLess(newCapabilities))
                    .forEach(peer -> peer.setCapabilities(newCapabilities));
        });
        requestPersistence();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Housekeeping
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void doHouseKeeping() {
        if (checkMaxConnectionsTimer == null) {
            printConnectedPeers();
            checkMaxConnectionsTimer = UserThread.runAfter(() -> {
                stopCheckMaxConnectionsTimer();
                if (!stopped) {
                    Set<Connection> allConnections = new HashSet<>(networkNode.getAllConnections());
                    int size = allConnections.size();
                    peakNumConnections = Math.max(peakNumConnections, size);

                    removeAnonymousPeers();
                    removeTooOldReportedPeers();
                    removeTooOldPersistedPeers();
                    checkMaxConnections();
                } else {
                    log.debug(""We have stopped already. We ignore that checkMaxConnectionsTimer.run call."");
                }
            }, CHECK_MAX_CONN_DELAY_SEC);
        }
    }

    @VisibleForTesting
    boolean checkMaxConnections() {
        Set<Connection> allConnections = new HashSet<>(networkNode.getAllConnections());
        int size = allConnections.size();
        log.info(""We have {} connections open. Our limit is {}"", size, maxConnections);

        if (size <= maxConnections) {
            log.debug(""We have not exceeded the maxConnections limit of {} "" +
                    ""so don't need to close any connections."", size);
            return false;
        }

        log.info(""We have too many connections open. "" +
                ""Lets try first to remove the inbound connections of type PEER."");
        List<Connection> candidates = allConnections.stream()
                .filter(e -> e instanceof InboundConnection)
                .filter(e -> e.getConnectionState().getPeerType() == PeerType.PEER)
                .sorted(Comparator.comparingLong(o -> o.getStatistic().getLastActivityTimestamp()))
                .collect(Collectors.toList());

        if (candidates.isEmpty()) {
            log.info(""No candidates found. We check if we exceed our "" +
                    ""outBoundPeerTrigger of {}"", outBoundPeerTrigger);
            if (size <= outBoundPeerTrigger) {
                log.info(""We have not exceeded outBoundPeerTrigger of {} "" +
                        ""so don't need to close any connections"", outBoundPeerTrigger);
                return false;
            }

            log.info(""We have exceeded outBoundPeerTrigger of {}. "" +
                    ""Lets try to remove outbound connection of type PEER."", outBoundPeerTrigger);
            candidates = allConnections.stream()
                    .filter(e -> e.getConnectionState().getPeerType() == PeerType.PEER)
                    .sorted(Comparator.comparingLong(o -> o.getStatistic().getLastActivityTimestamp()))
                    .collect(Collectors.toList());

            if (candidates.isEmpty()) {
                log.info(""No candidates found. We check if we exceed our "" +
                        ""initialDataExchangeTrigger of {}"", initialDataExchangeTrigger);
                if (size <= initialDataExchangeTrigger) {
                    log.info(""We have not exceeded initialDataExchangeTrigger of {} "" +
                            ""so don't need to close any connections"", initialDataExchangeTrigger);
                    return false;
                }

                log.info(""We have exceeded initialDataExchangeTrigger of {} "" +
                        ""Lets try to remove the oldest INITIAL_DATA_EXCHANGE connection."", initialDataExchangeTrigger);
                candidates = allConnections.stream()
                        .filter(e -> e.getConnectionState().getPeerType() == PeerType.INITIAL_DATA_EXCHANGE)
                        .sorted(Comparator.comparingLong(o -> o.getConnectionState().getLastInitialDataMsgTimeStamp()))
                        .collect(Collectors.toList());

                if (candidates.isEmpty()) {
                    log.info(""No candidates found. We check if we exceed our "" +
                            ""maxConnectionsAbsolute limit of {}"", maxConnectionsAbsolute);
                    if (size <= maxConnectionsAbsolute) {
                        log.info(""We have not exceeded maxConnectionsAbsolute limit of {} "" +
                                ""so don't need to close any connections"", maxConnectionsAbsolute);
                        return false;
                    }

                    log.info(""We reached abs. max. connections. Lets try to remove ANY connection."");
                    candidates = allConnections.stream()
                            .sorted(Comparator.comparingLong(o -> o.getStatistic().getLastActivityTimestamp()))
                            .collect(Collectors.toList());
                }
            }
        }

        if (!candidates.isEmpty()) {
            Connection connection = candidates.remove(0);
            log.info(""checkMaxConnections: Num candidates for shut down={}. We close oldest connection to peer {}"",
                    candidates.size(), connection.getPeersNodeAddressOptional());
            if (!connection.isStopped()) {
                connection.shutDown(CloseConnectionReason.TOO_MANY_CONNECTIONS_OPEN,
                        () -> UserThread.runAfter(this::checkMaxConnections, 100, TimeUnit.MILLISECONDS));
                return true;
            }
        }

        log.info(""No candidates found to remove. "" +
                ""size={}, allConnections={}"", size, allConnections);
        return false;
    }

    private void removeAnonymousPeers() {
        networkNode.getAllConnections().stream()
                .filter(connection -> !connection.hasPeersNodeAddress())
                .filter(connection -> connection.getConnectionState().getPeerType() == PeerType.PEER)
                .forEach(connection -> UserThread.runAfter(() -> { // todo we keep a potentially dead connection in memory for too long...
                    // We give 240 seconds delay and check again if still no address is set
                    // Keep the delay long as we don't want to disconnect a peer in case we are a seed node just
                    // because he needs longer for the HS publishing
                    if (!connection.isStopped() && !connection.hasPeersNodeAddress()) {
                        log.info(""removeAnonymousPeers: We close the connection as the peer address is still unknown. "" +
                                ""Peer: {}"", connection.getPeersNodeAddressOptional());
                        connection.shutDown(CloseConnectionReason.UNKNOWN_PEER_ADDRESS);
                    }
                }, REMOVE_ANONYMOUS_PEER_SEC));
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Reported peers
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void removeReportedPeer(Peer reportedPeer) {
        reportedPeers.remove(reportedPeer);
        printReportedPeers();
    }

    private void removeReportedPeer(NodeAddress nodeAddress) {
        List<Peer> reportedPeersClone = new ArrayList<>(reportedPeers);
        reportedPeersClone.stream()
                .filter(e -> e.getNodeAddress().equals(nodeAddress))
                .findAny()
                .ifPresent(this::removeReportedPeer);
    }

    private void removeTooOldReportedPeers() {
        List<Peer> reportedPeersClone = new ArrayList<>(reportedPeers);
        Set<Peer> reportedPeersToRemove = reportedPeersClone.stream()
                .filter(reportedPeer -> new Date().getTime() - reportedPeer.getDate().getTime() > MAX_AGE)
                .collect(Collectors.toSet());
        reportedPeersToRemove.forEach(this::removeReportedPeer);
    }


    private void purgeReportedPeersIfExceeds() {
        int size = reportedPeers.size();
        if (size > MAX_REPORTED_PEERS) {
            log.info(""We have already {} reported peers which exceeds our limit of {}."" +
                    ""We remove random peers from the reported peers list."", size, MAX_REPORTED_PEERS);
            int diff = size - MAX_REPORTED_PEERS;
            List<Peer> list = new ArrayList<>(reportedPeers);
            // we don't use sorting by lastActivityDate to keep it more random
            for (int i = 0; i < diff; i++) {
                if (!list.isEmpty()) {
                    Peer toRemove = list.remove(new Random().nextInt(list.size()));
                    removeReportedPeer(toRemove);
                }
            }
        } else {
            log.trace(""No need to purge reported peers.\n\tWe don't have more then {} reported peers yet."", MAX_REPORTED_PEERS);
        }
    }

    private void printReportedPeers() {
        if (!reportedPeers.isEmpty()) {
            if (PRINT_REPORTED_PEERS_DETAILS) {
                StringBuilder result = new StringBuilder(""\n\n------------------------------------------------------------\n"" +
                        ""Collected reported peers:"");
                List<Peer> reportedPeersClone = new ArrayList<>(reportedPeers);
                reportedPeersClone.forEach(e -> result.append(""\n"").append(e));
                result.append(""\n------------------------------------------------------------\n"");
                log.trace(result.toString());
            }
            log.debug(""Number of reported peers: {}"", reportedPeers.size());
        }
    }

    private void printNewReportedPeers(Set<Peer> reportedPeers) {
        if (PRINT_REPORTED_PEERS_DETAILS) {
            StringBuilder result = new StringBuilder(""We received new reportedPeers:"");
            List<Peer> reportedPeersClone = new ArrayList<>(reportedPeers);
            reportedPeersClone.forEach(e -> result.append(""\n\t"").append(e));
            log.trace(result.toString());
        }
        log.debug(""Number of new arrived reported peers: {}"", reportedPeers.size());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    //  Persisted peers
    ///////////////////////////////////////////////////////////////////////////////////////////

    private boolean removePersistedPeer(Peer persistedPeer) {
        if (getPersistedPeers().contains(persistedPeer)) {
            getPersistedPeers().remove(persistedPeer);
            requestPersistence();
            return true;
        } else {
            return false;
        }
    }

    private void requestPersistence() {
        persistenceManager.requestPersistence();
    }

    @SuppressWarnings(""UnusedReturnValue"")
    private boolean removePersistedPeer(NodeAddress nodeAddress) {
        Optional<Peer> optionalPersistedPeer = findPersistedPeer(nodeAddress);
        return optionalPersistedPeer.isPresent() && removePersistedPeer(optionalPersistedPeer.get());
    }

    private Optional<Peer> findPersistedPeer(NodeAddress nodeAddress) {
        return getPersistedPeers().stream()
                .filter(e -> e.getNodeAddress().equals(nodeAddress))
                .findAny();
    }

    private void removeTooOldPersistedPeers() {
        Set<Peer> persistedPeersToRemove = getPersistedPeers().stream()
                .filter(reportedPeer -> new Date().getTime() - reportedPeer.getDate().getTime() > MAX_AGE)
                .collect(Collectors.toSet());
        persistedPeersToRemove.forEach(this::removePersistedPeer);
    }

    private void purgePersistedPeersIfExceeds() {
        int size = getPersistedPeers().size();
        int limit = MAX_PERSISTED_PEERS;
        if (size > limit) {
            log.trace(""We have already {} persisted peers which exceeds our limit of {}."" +
                    ""We remove random peers from the persisted peers list."", size, limit);
            int diff = size - limit;
            List<Peer> list = new ArrayList<>(getPersistedPeers());
            // we don't use sorting by lastActivityDate to avoid attack vectors and keep it more random
            for (int i = 0; i < diff; i++) {
                if (!list.isEmpty()) {
                    Peer toRemove = list.remove(new Random().nextInt(list.size()));
                    removePersistedPeer(toRemove);
                }
            }
        } else {
            log.trace(""No need to purge persisted peers.\n\tWe don't have more then {} persisted peers yet."", MAX_PERSISTED_PEERS);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    ///////////////////////////////////////////////////////////////////////////////////////////

    public int getMaxConnections() {
        return maxConnections;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Listeners
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void addListener(Listener listener) {
        listeners.add(listener);
    }

    public void removeListener(Listener listener) {
        listeners.remove(listener);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    //  Private misc
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Modify this to change the relationships between connection limits.
    // maxConnections default 12
    private void setConnectionLimits(int maxConnections) {
        this.maxConnections = maxConnections;                                                     // app node 12; seedNode 20
        minConnections = Math.max(1, (int) Math.round(maxConnections * 0.7));                     // app node  8; seedNode 14
        outBoundPeerTrigger = Math.max(4, (int) Math.round(maxConnections * 1.3));                // app node 16; seedNode 26
        initialDataExchangeTrigger = Math.max(8, (int) Math.round(maxConnections * 1.7));         // app node 20; seedNode 34
        maxConnectionsAbsolute = Math.max(12, (int) Math.round(maxConnections * 2.5));            // app node 30; seedNode 50
    }

    private Set<Peer> getConnectedReportedPeers() {
        // networkNode.getConfirmedConnections includes:
        // filter(connection -> connection.getPeersNodeAddressOptional().isPresent())
        return networkNode.getConfirmedConnections().stream()
                .map((Connection connection) -> {
                    Capabilities supportedCapabilities = new Capabilities(connection.getCapabilities());
                    // If we have a new connection the supportedCapabilities is empty.
                    // We lookup if we have already stored the supportedCapabilities at the persisted or reported peers
                    // and if so we use that.
                    Optional<NodeAddress> peersNodeAddressOptional = connection.getPeersNodeAddressOptional();
                    checkArgument(peersNodeAddressOptional.isPresent()); // getConfirmedConnections delivers only connections where we know the address
                    NodeAddress peersNodeAddress = peersNodeAddressOptional.get();
                    boolean capabilitiesNotFoundInConnection = supportedCapabilities.isEmpty();
                    if (capabilitiesNotFoundInConnection) {
                        // If not found in connection we look up if we got the Capabilities set from any of the
                        // reported or persisted peers
                        Set<Peer> persistedAndReported = new HashSet<>(getPersistedPeers());
                        persistedAndReported.addAll(getReportedPeers());
                        Optional<Peer> candidate = persistedAndReported.stream()
                                .filter(peer -> peer.getNodeAddress().equals(peersNodeAddress))
                                .filter(peer -> !peer.getCapabilities().isEmpty())
                                .findAny();
                        if (candidate.isPresent()) {
                            supportedCapabilities = new Capabilities(candidate.get().getCapabilities());
                        }
                    }
                    Peer peer = new Peer(peersNodeAddress, supportedCapabilities);

                    // If we did not found the capability from our own connection we add a listener,
                    // so once we get a connection with that peer and exchange a message containing the capabilities
                    // we get set the capabilities.
                    if (capabilitiesNotFoundInConnection) {
                        connection.addWeakCapabilitiesListener(peer);
                    }
                    return peer;
                })
                .collect(Collectors.toSet());
    }

    private void stopCheckMaxConnectionsTimer() {
        if (checkMaxConnectionsTimer != null) {
            checkMaxConnectionsTimer.stop();
            checkMaxConnectionsTimer = null;
        }
    }

    private void printStatistics() {
        String ls = System.lineSeparator();
        StringBuilder sb = new StringBuilder(""Connection statistics: "" + ls);
        AtomicInteger counter = new AtomicInteger();
        networkNode.getAllConnections().stream()
                .sorted(Comparator.comparingLong(o -> o.getConnectionStatistics().getConnectionCreationTimeStamp()))
                .forEach(e -> sb.append(ls).append(""Connection "")
                        .append(counter.incrementAndGet()).append(ls)
                        .append(e.getConnectionStatistics().getInfo()).append(ls));
        log.info(sb.toString());
    }

    private void printConnectedPeers() {
        if (!networkNode.getConfirmedConnections().isEmpty()) {
            StringBuilder result = new StringBuilder(""\n\n------------------------------------------------------------\n"" +
                    ""Connected peers for node "" + networkNode.getNodeAddress() + "":"");
            networkNode.getConfirmedConnections().forEach(e -> result.append(""\n"")
                    .append(e.getPeersNodeAddressOptional()).append("" "").append(e.getConnectionState().getPeerType()));
            result.append(""\n------------------------------------------------------------\n"");
            log.debug(result.toString());
        }
    }
}",1,64 2000 777 657 587 2001 693 2002 44 2003 123 331 330 331 773 809 657 726 2004 61 1502 59 330 773 809 657 726 2005 61 1504 59 773 809 657 704 2006 61 1504 59 773 809 657 704 2007 61 1504 59 330 773 809 657 726 2008 61 2009 46 2010 46 2011 40 1503 41 59 330 773 809 657 726 2012 61 2009 46 2013 46 2011 40 1503 41 59 773 809 657 570 2014 61 2015 59 773 2016 2017 59 773 570 2018 59 331 330 331 777 709 2019 123 865 2020 40 41 59 865 2021 40 41 59 865 2022 40 41 59 125 331 330 331 773 657 2023 2024 59 773 657 2025 2026 59 773 657 2027 60 2028 62 2029 59 773 657 2030 60 2031 62 2032 59 773 657 2025 46 2019 2033 59 773 657 2034 60 2019 62 2035 61 744 2036 60 62 40 41 59 330 773 657 2031 2037 61 744 2031 40 41 59 330 64 2038 773 657 2027 60 2039 62 2040 61 744 2041 60 62 40 41 59 330 773 657 2027 60 2039 62 2042 61 744 2041 60 62 40 41 59 773 2016 2043 59 773 570 2044 59 773 570 2045 59 773 704 2046 59 64 2038 773 704 2047 59 773 704 2048 59 773 704 2049 59 773 704 2050 59 64 2038 773 704 2051 59 64 2038 773 704 2052 59 331 330 331 64 2053 777 2001 40 2023 2024 44 2054 2055 44 2025 2026 44 2030 60 2031 62 2032 44 64 2056 40 2057 46 2058 41 704 2046 41 123 823 46 2024 61 2024 59 823 46 2029 61 744 2041 60 62 40 2055 46 2059 40 41 41 59 823 46 2026 61 2026 59 823 46 2032 61 2032 59 823 46 2032 46 2060 40 2037 44 2030 46 2061 46 2062 41 59 823 46 2024 46 2063 40 823 41 59 2064 40 2046 41 59 330 2033 61 744 2025 46 2019 40 41 123 64 2065 777 865 2066 40 41 123 125 64 2065 777 865 2067 40 41 123 125 64 2065 777 865 2068 40 726 2069 41 123 330 330 2044 61 2070 59 2035 46 2071 40 2019 58 58 2068 41 59 125 125 59 2026 46 2072 40 2033 41 59 2017 61 2073 46 2074 40 823 58 58 2075 44 2009 46 2013 46 2076 40 1502 41 41 59 125 777 865 2077 40 41 123 2018 61 2015 59 2024 46 2078 40 823 41 59 2026 46 2079 40 2033 41 59 2080 40 41 59 688 40 2017 340 2081 41 123 2017 46 2082 40 41 59 2017 61 2081 59 125 125 331 330 331 64 2083 777 865 2084 40 2085 2086 41 123 2032 46 2084 40 2087 45 62 123 2037 46 2088 40 2087 46 2089 40 41 41 59 2086 46 2090 40 41 59 125 44 2086 41 59 125 331 330 331 64 2083 777 865 2091 40 2092 2093 41 123 2093 46 2094 40 41 46 2095 40 2096 40 2093 41 41 59 2097 40 41 59 688 40 2045 41 123 2045 61 2098 59 2044 61 2098 59 2099 46 2100 40 362 43 362 43 362 44 2093 46 2101 40 41 41 59 2035 46 2102 40 2019 58 58 2103 41 59 125 2093 46 2104 40 41 46 2105 40 823 58 58 2106 41 46 2107 40 2039 58 58 2091 41 59 125 64 2083 777 865 2108 40 2109 2110 44 2092 2093 41 123 2111 46 2112 40 362 44 2093 46 2113 40 41 44 2110 41 59 2114 40 2093 41 59 570 2115 61 2045 59 2045 61 2024 46 2116 40 41 46 2117 40 41 59 688 40 2045 41 123 2044 61 2015 59 688 40 33 2018 41 123 688 40 33 2115 41 123 330 2052 349 59 125 2111 46 2118 40 362 43 362 43 362 41 59 2035 46 2119 40 2019 58 58 2120 41 59 125 125 2121 40 2110 44 2093 41 59 125 64 2083 777 865 2122 40 2123 2124 41 123 125 331 330 331 777 570 2125 40 41 123 792 2024 46 2126 40 41 46 2127 40 41 325 2047 59 125 330 777 570 2128 40 2028 2129 41 123 792 2024 46 2130 40 41 46 2131 40 2129 41 59 125 777 865 2132 40 2092 2093 41 123 2093 46 2133 40 41 46 2134 40 2129 45 62 2132 40 2129 44 2093 41 41 59 125 777 865 2132 40 2028 2129 41 123 2132 40 2129 44 2135 41 59 125 777 865 2132 40 2028 2129 44 64 2136 2092 2093 41 123 570 2137 61 2138 59 2139 40 2129 41 59 2140 60 2039 62 2141 61 2142 40 2129 41 59 688 40 2141 46 2143 40 41 41 123 2039 2144 61 2141 46 2145 40 41 59 2144 46 2108 40 41 59 2137 61 2144 46 2146 40 41 59 125 570 2147 61 2093 340 2148 307 2093 46 2149 40 41 340 2148 59 2137 61 2137 309 2147 59 688 40 2137 41 2150 40 2129 41 59 630 2151 40 41 59 125 777 570 2152 40 2092 2093 41 123 792 2093 46 2153 40 41 46 2154 40 41 307 2152 40 2093 46 2153 40 41 46 2155 40 41 41 59 125 777 570 2156 40 2028 2129 41 123 792 2129 46 2157 40 2024 46 2158 40 41 41 59 125 773 570 2152 40 2039 2159 41 123 792 2029 46 2160 40 2159 46 2161 40 41 41 59 125 777 570 2152 40 2028 2129 41 123 792 2029 46 2162 40 2129 41 59 125 777 570 2163 40 2109 2110 44 2092 2093 41 123 792 2110 323 2109 46 2164 307 2093 46 2165 40 41 46 2166 40 41 59 125 773 865 2167 40 2109 2110 44 2092 2093 41 123 688 40 2093 46 2168 40 41 46 2169 40 41 307 2163 40 2110 44 2093 41 41 123 2028 2129 61 2093 46 2168 40 41 46 2170 40 41 59 2029 46 2171 40 2129 41 59 2172 40 2129 41 59 2173 40 2129 41 59 125 125 777 865 2174 40 41 123 688 40 33 2024 46 2175 40 41 46 2176 40 41 41 123 2052 61 1500 59 125 125 331 330 331 64 2177 40 362 41 777 2178 60 2039 62 2179 40 2028 2180 41 123 792 2181 40 41 46 2182 40 41 46 2183 40 2159 45 62 2159 46 2184 40 41 46 2185 40 2180 41 41 46 2186 40 41 59 125 777 2027 60 2039 62 2187 40 41 123 2027 60 2039 62 2188 61 744 2041 60 62 40 2189 40 41 41 59 2188 46 2190 40 2191 40 41 41 59 2188 46 2190 40 2040 41 59 792 2188 59 125 777 2192 60 2039 62 2193 40 41 123 792 2037 46 2194 40 41 59 125 777 865 2195 40 2027 60 2039 62 2196 44 2092 2093 44 2197 2198 41 123 2199 40 2093 44 2198 41 59 2027 60 2039 62 2200 61 2196 46 2201 40 41 46 2202 40 2159 45 62 33 2156 40 2159 46 2203 40 41 41 41 46 2204 40 2205 46 2206 40 41 41 59 2207 40 2200 41 59 330 688 40 2200 46 2208 40 41 329 40 2006 43 2050 43 1502 41 41 123 2040 46 2209 40 2200 41 59 2210 40 41 59 2193 40 41 46 2209 40 2200 41 59 2211 40 41 59 2212 40 41 59 2213 40 41 59 125 630 123 330 330 330 2093 46 2214 40 2215 46 2216 41 59 125 125 330 330 777 2027 60 2039 62 2217 40 41 123 792 2217 40 2218 41 59 125 777 2027 60 2039 62 2217 40 64 2136 2028 2219 41 123 704 2220 61 2042 46 2221 40 41 59 2027 60 2039 62 2222 61 744 2041 60 62 40 2042 41 59 2027 60 2039 62 2223 61 2224 40 41 46 2225 40 41 46 2226 40 2227 45 62 33 2152 40 2227 41 41 46 2226 40 2227 45 62 33 2227 46 2228 40 41 46 2229 40 2219 41 41 46 2230 40 2231 46 2232 40 41 41 59 2222 46 2233 40 2223 41 59 726 2234 61 744 2235 40 41 46 2236 40 41 45 2012 59 2042 46 2237 40 41 59 2027 60 2039 62 2238 61 2222 46 2225 40 41 46 2226 40 2159 45 62 2159 46 2239 40 41 62 2234 41 46 2230 40 2231 46 2232 40 41 41 59 2042 46 2233 40 2238 41 59 688 40 2220 340 2042 46 2221 40 41 41 2240 46 2241 40 362 44 2042 46 2221 40 41 41 59 792 2042 59 125 331 330 331 777 570 2242 40 2028 2180 44 2243 2244 41 123 792 2245 40 2180 41 46 2246 40 2198 45 62 2198 46 2247 40 2244 41 41 46 2248 40 2249 41 59 125 777 2178 60 2197 62 2250 40 2028 2129 41 123 330 330 2178 60 2197 62 2251 61 2024 46 2250 40 2129 41 59 688 40 2251 46 2252 40 41 307 33 2251 46 2253 40 41 46 2254 40 41 41 123 792 2251 59 125 330 330 330 330 330 330 330 330 792 2187 40 41 46 2255 40 41 46 2256 40 2159 45 62 2159 46 2257 40 41 46 2258 40 2129 41 41 46 2259 40 41 46 2260 40 2039 58 58 2261 41 59 125 773 865 2262 40 2092 2093 44 2197 2263 41 123 688 40 2263 323 2264 309 2263 46 2265 40 41 41 123 792 59 125 2093 46 2266 40 41 46 2267 40 2129 45 62 123 2187 40 41 46 2268 40 41 46 2269 40 2159 45 62 2159 46 2270 40 41 46 2271 40 2129 41 41 46 2269 40 2159 45 62 2159 46 2272 40 41 46 2273 40 2263 41 41 46 2274 40 2159 45 62 2159 46 2275 40 2263 41 41 59 125 41 59 2276 40 41 59 125 331 330 331 773 865 2277 40 41 123 688 40 2043 323 2278 41 123 2279 40 41 59 2043 61 2280 46 2281 40 40 41 45 62 123 2282 40 41 59 688 40 33 2044 41 123 2027 60 2092 62 2283 61 744 2041 60 62 40 2024 46 2284 40 41 41 59 704 2285 61 2283 46 2285 40 41 59 2051 61 2286 46 2287 40 2051 44 2285 41 59 2288 40 41 59 2289 40 41 59 2290 40 41 59 2291 40 41 59 125 630 123 2292 46 2293 40 362 41 59 125 125 44 2004 41 59 125 125 64 2294 570 2295 40 41 123 2027 60 2092 62 2296 61 744 2041 60 62 40 2024 46 2297 40 41 41 59 704 2298 61 2296 46 2298 40 41 59 2299 46 2300 40 362 44 2298 44 2046 41 59 688 40 2298 329 2046 41 123 2299 46 2301 40 362 43 362 44 2298 41 59 792 2302 59 125 2299 46 2300 40 362 43 362 41 59 2034 60 2092 62 2303 61 2296 46 2304 40 41 46 2305 40 2306 45 62 2306 702 2307 41 46 2305 40 2306 45 62 2306 46 2308 40 41 46 2309 40 41 323 2310 46 2311 41 46 2312 40 2313 46 2314 40 2315 45 62 2315 46 2316 40 41 46 2317 40 41 41 41 46 2318 40 2319 46 2320 40 41 41 59 688 40 2303 46 2321 40 41 41 123 2299 46 2300 40 362 43 362 44 2048 41 59 688 40 2298 329 2048 41 123 2299 46 2300 40 362 43 362 44 2048 41 59 792 2322 59 125 2299 46 2300 40 362 43 362 44 2048 41 59 2303 61 2296 46 2304 40 41 46 2305 40 2306 45 62 2306 46 2308 40 41 46 2309 40 41 323 2310 46 2311 41 46 2312 40 2313 46 2314 40 2315 45 62 2315 46 2316 40 41 46 2317 40 41 41 41 46 2318 40 2319 46 2320 40 41 41 59 688 40 2303 46 2321 40 41 41 123 2299 46 2300 40 362 43 362 44 2049 41 59 688 40 2298 329 2049 41 123 2299 46 2300 40 362 43 362 44 2049 41 59 792 2323 59 125 2299 46 2300 40 362 43 362 44 2049 41 59 2303 61 2296 46 2304 40 41 46 2305 40 2306 45 62 2306 46 2308 40 41 46 2309 40 41 323 2310 46 2324 41 46 2312 40 2313 46 2314 40 2315 45 62 2315 46 2308 40 41 46 2325 40 41 41 41 46 2318 40 2319 46 2320 40 41 41 59 688 40 2303 46 2321 40 41 41 123 2299 46 2300 40 362 43 362 44 2050 41 59 688 40 2298 329 2050 41 123 2299 46 2300 40 362 43 362 44 2050 41 59 792 2326 59 125 2299 46 2300 40 362 41 59 2303 61 2296 46 2304 40 41 46 2312 40 2313 46 2314 40 2315 45 62 2315 46 2316 40 41 46 2317 40 41 41 41 46 2318 40 2319 46 2320 40 41 41 59 125 125 125 688 40 33 2303 46 2321 40 41 41 123 2092 2093 61 2303 46 2327 40 1500 41 59 2299 46 2300 40 362 44 2303 46 2298 40 41 44 2093 46 2328 40 41 41 59 688 40 33 2093 46 2329 40 41 41 123 2093 46 2077 40 2109 46 2330 44 40 41 45 62 2331 46 2332 40 823 58 58 2295 44 1503 44 2009 46 2333 41 41 59 792 2015 59 125 125 2299 46 2300 40 362 43 362 44 2298 44 2296 41 59 792 2334 59 125 773 865 2335 40 41 123 2024 46 2336 40 41 46 2337 40 41 46 2338 40 2093 45 62 33 2093 46 2339 40 41 41 46 2338 40 2093 45 62 2093 46 2340 40 41 46 2341 40 41 323 2342 46 2343 41 46 2344 40 2093 45 62 2345 46 2346 40 40 41 45 62 123 330 330 330 330 688 40 33 2093 46 2347 40 41 307 33 2093 46 2339 40 41 41 123 2348 46 2349 40 362 43 362 44 2093 46 2350 40 41 41 59 2093 46 2077 40 2109 46 2351 41 59 125 125 44 2005 41 41 59 125 331 330 331 773 865 2352 40 2039 2353 41 123 2040 46 2354 40 2353 41 59 2355 40 41 59 125 773 865 2352 40 2028 2129 41 123 2034 60 2039 62 2356 61 744 2357 60 62 40 2040 41 59 2356 46 2358 40 41 46 2359 40 2360 45 62 2360 46 2361 40 41 46 2362 40 2129 41 41 46 2363 40 41 46 2364 40 823 58 58 2352 41 59 125 773 865 2365 40 41 123 2034 60 2039 62 2366 61 744 2367 60 62 40 2040 41 59 2027 60 2039 62 2368 61 2366 46 2369 40 41 46 2370 40 2353 45 62 744 2371 40 41 46 2372 40 41 45 2353 46 2373 40 41 46 2372 40 41 62 2008 41 46 2374 40 2375 46 2376 40 41 41 59 2368 46 2377 40 823 58 58 2352 41 59 125 773 865 2378 40 41 123 704 2379 61 2040 46 2379 40 41 59 688 40 2379 62 2006 41 123 2380 46 2381 40 362 43 362 44 2379 44 2006 41 59 704 2382 61 2379 45 2006 59 2034 60 2039 62 2383 61 744 2384 60 62 40 2040 41 59 330 664 40 704 2385 61 1500 59 2385 60 2382 59 2385 349 41 123 688 40 33 2383 46 2386 40 41 41 123 2039 2387 61 2383 46 2388 40 744 2389 40 41 46 2390 40 2383 46 2379 40 41 41 41 59 2352 40 2387 41 59 125 125 125 630 123 2391 46 2392 40 362 44 2006 41 59 125 125 773 865 2393 40 41 123 688 40 33 2040 46 2394 40 41 41 123 688 40 2014 41 123 2395 2396 61 744 2395 40 362 43 362 41 59 2034 60 2039 62 2397 61 744 2398 60 62 40 2040 41 59 2397 46 2399 40 2400 45 62 2396 46 2401 40 362 41 46 2401 40 2400 41 41 59 2396 46 2401 40 362 41 59 2402 46 2403 40 2396 46 2404 40 41 41 59 125 2405 46 2406 40 362 44 2040 46 2407 40 41 41 59 125 125 773 865 2408 40 2027 60 2039 62 2040 41 123 688 40 2014 41 123 2409 2410 61 744 2409 40 362 41 59 2034 60 2039 62 2411 61 744 2412 60 62 40 2040 41 59 2411 46 2413 40 2414 45 62 2410 46 2415 40 362 41 46 2415 40 2414 41 41 59 2416 46 2417 40 2410 46 2418 40 41 41 59 125 2419 46 2420 40 362 44 2040 46 2421 40 41 41 59 125 331 330 331 773 570 2422 40 2039 2423 41 123 688 40 2193 40 41 46 2424 40 2423 41 41 123 2193 40 41 46 2425 40 2423 41 59 2426 40 41 59 792 2015 59 125 630 123 792 2427 59 125 125 773 865 2428 40 41 123 2032 46 2428 40 41 59 125 64 2177 40 362 41 773 570 2422 40 2028 2129 41 123 2178 60 2039 62 2429 61 2430 40 2129 41 59 792 2429 46 2431 40 41 307 2422 40 2429 46 2432 40 41 41 59 125 773 2178 60 2039 62 2433 40 2028 2129 41 123 792 2193 40 41 46 2434 40 41 46 2435 40 2436 45 62 2436 46 2437 40 41 46 2438 40 2129 41 41 46 2439 40 41 59 125 773 865 2440 40 41 123 2027 60 2039 62 2441 61 2193 40 41 46 2442 40 41 46 2443 40 2353 45 62 744 2444 40 41 46 2445 40 41 45 2353 46 2446 40 41 46 2445 40 41 62 2008 41 46 2447 40 2448 46 2449 40 41 41 59 2441 46 2450 40 823 58 58 2422 41 59 125 773 865 2451 40 41 123 704 2452 61 2193 40 41 46 2452 40 41 59 704 2453 61 2007 59 688 40 2452 62 2453 41 123 2454 46 2455 40 362 43 362 44 2452 44 2453 41 59 704 2456 61 2452 45 2453 59 2034 60 2039 62 2457 61 744 2458 60 62 40 2193 40 41 41 59 330 664 40 704 2459 61 1500 59 2459 60 2456 59 2459 349 41 123 688 40 33 2457 46 2460 40 41 41 123 2039 2461 61 2457 46 2462 40 744 2463 40 41 46 2464 40 2457 46 2452 40 41 41 41 59 2422 40 2461 41 59 125 125 125 630 123 2465 46 2466 40 362 44 2007 41 59 125 125 331 330 331 777 704 2467 40 41 123 792 2046 59 125 331 330 331 777 865 2468 40 2019 2469 41 123 2035 46 2470 40 2469 41 59 125 777 865 2471 40 2019 2469 41 123 2035 46 2472 40 2469 41 59 125 331 330 331 330 330 773 865 2473 40 704 2046 41 123 823 46 2046 61 2046 59 330 2047 61 2474 46 2475 40 1501 44 40 704 41 2474 46 2476 40 2046 42 1500 41 41 59 330 2048 61 2474 46 2475 40 1502 44 40 704 41 2474 46 2476 40 2046 42 1502 41 41 59 330 2049 61 2474 46 2475 40 1502 44 40 704 41 2474 46 2476 40 2046 42 1502 41 41 59 330 2050 61 2474 46 2475 40 1503 44 40 704 41 2474 46 2476 40 2046 42 1502 41 41 59 330 125 773 2027 60 2039 62 2477 40 41 123 330 330 792 2024 46 2478 40 41 46 2479 40 41 46 2480 40 40 2092 2093 41 45 62 123 2197 2481 61 744 2197 40 2093 46 2482 40 41 41 59 330 330 330 2178 60 2028 62 2483 61 2093 46 2484 40 41 59 2485 40 2483 46 2486 40 41 41 59 330 2028 2180 61 2483 46 2487 40 41 59 570 2488 61 2481 46 2489 40 41 59 688 40 2488 41 123 330 330 2027 60 2039 62 2490 61 744 2041 60 62 40 2193 40 41 41 59 2490 46 2491 40 2492 40 41 41 59 2178 60 2039 62 2493 61 2490 46 2479 40 41 46 2494 40 2159 45 62 2159 46 2495 40 41 46 2496 40 2180 41 41 46 2494 40 2159 45 62 33 2159 46 2482 40 41 46 2489 40 41 41 46 2497 40 41 59 688 40 2493 46 2486 40 41 41 123 2481 61 744 2197 40 2493 46 2487 40 41 46 2482 40 41 41 59 125 125 2039 2159 61 744 2039 40 2180 44 2481 41 59 330 330 330 688 40 2488 41 123 2093 46 2498 40 2159 41 59 125 792 2159 59 125 41 46 2499 40 2500 46 2501 40 41 41 59 125 773 865 2502 40 41 123 688 40 2043 340 2503 41 123 2043 46 2504 40 41 59 2043 61 2503 59 125 125 773 865 2505 40 41 123 2506 2507 61 2508 46 2509 40 41 59 2510 2511 61 744 2510 40 362 43 2507 41 59 2512 2513 61 744 2512 40 41 59 2024 46 2514 40 41 46 2515 40 41 46 2516 40 2517 46 2518 40 2519 45 62 2519 46 2520 40 41 46 2521 40 41 41 41 46 2522 40 2523 45 62 2511 46 2524 40 2507 41 46 2524 40 362 41 46 2524 40 2513 46 2525 40 41 41 46 2524 40 2507 41 46 2524 40 2523 46 2520 40 41 46 2526 40 41 41 46 2524 40 2507 41 41 59 2527 46 2528 40 2511 46 2529 40 41 41 59 125 773 865 2530 40 41 123 688 40 33 2024 46 2531 40 41 46 2532 40 41 41 123 2533 2534 61 744 2533 40 362 43 362 43 2024 46 2535 40 41 43 362 41 59 2024 46 2531 40 41 46 2536 40 2537 45 62 2534 46 2538 40 362 41 46 2538 40 2537 46 2539 40 41 41 46 2538 40 362 41 46 2538 40 2537 46 2540 40 41 46 2541 40 41 41 41 59 2534 46 2538 40 362 41 59 2542 46 2543 40 2534 46 2544 40 41 41 59 125 125 125 ,"{'AvgLine': 11, 'CountLine': 762, 'CountStmt': 343, 'MaxNesting': 4, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 256, 'MaxEssential': 10, 'SumEssential': 92, 'AvgCyclomatic': 1, 'CountLineCode': 545, 'CountStmtDecl': 137, 'MaxCyclomatic': 10, 'SumCyclomatic': 122, 'AvgLineComment': 0, 'CountClassBase': 3, 'CountLineBlank': 128, 'CountSemicolon': 248, 'CountDeclMethod': 50, 'CountLineCodeExe': 361, 'CountLineComment': 96, 'CountClassCoupled': 45, 'CountClassDerived': 0, 'CountLineCodeDecl': 160, 'CountDeclMethodAll': 50, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.18', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 130, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 27, 'MaxCyclomaticModified': 10, 'PercentLackOfCohesion': 94, 'SumCyclomaticModified': 122, 'CountDeclClassVariable': 7, 'CountDeclMethodDefault': 1, 'CountDeclMethodPrivate': 22, 'CountDeclInstanceMethod': 50, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 45, 'CountDeclInstanceVariable': 21, 'PercentLackOfCohesionModified': 89}"
2465,Java,"public final class CachedWorld implements ICachedWorld, Helper {

    /**
     * The maximum number of regions in any direction from (0,0)
     */
    private static final int REGION_MAX = 30_000_000 / 512 + 1;

    /**
     * A map of all of the cached regions.
     */
    private Long2ObjectMap<CachedRegion> cachedRegions = new Long2ObjectOpenHashMap<>();

    /**
     * The directory that the cached region files are saved to
     */
    private final String directory;

    /**
     * Queue of positions to pack. Refers to the toPackMap, in that every element of this queue will be a
     * key in that map.
     */
    private final LinkedBlockingQueue<ChunkPos> toPackQueue = new LinkedBlockingQueue<>();

    /**
     * All chunk positions pending packing. This map will be updated in-place if a new update to the chunk occurs
     * while waiting in the queue for the packer thread to get to it.
     */
    private final Map<ChunkPos, Chunk> toPackMap = new ConcurrentHashMap<>();

    private final int dimension;

    CachedWorld(Path directory, int dimension) {
        if (!Files.exists(directory)) {
            try {
                Files.createDirectories(directory);
            } catch (IOException ignored) {
            }
        }
        this.directory = directory.toString();
        this.dimension = dimension;
        System.out.println(""Cached world directory: "" + directory);
        Baritone.getExecutor().execute(new PackerThread());
        Baritone.getExecutor().execute(() -> {
            try {
                Thread.sleep(30000);
                while (true) {
                    // since a region only saves if it's been modified since its last save
                    // saving every 10 minutes means that once it's time to exit
                    // we'll only have a couple regions to save
                    save();
                    Thread.sleep(600000);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }

    @Override
    public final void queueForPacking(Chunk chunk) {
        if (toPackMap.put(chunk.getPos(), chunk) == null) {
            toPackQueue.add(chunk.getPos());
        }
    }

    @Override
    public final boolean isCached(int blockX, int blockZ) {
        CachedRegion region = getRegion(blockX >> 9, blockZ >> 9);
        if (region == null) {
            return false;
        }
        return region.isCached(blockX & 511, blockZ & 511);
    }

    public final boolean regionLoaded(int blockX, int blockZ) {
        return getRegion(blockX >> 9, blockZ >> 9) != null;
    }

    @Override
    public final ArrayList<BlockPos> getLocationsOf(String block, int maximum, int centerX, int centerZ, int maxRegionDistanceSq) {
        ArrayList<BlockPos> res = new ArrayList<>();
        int centerRegionX = centerX >> 9;
        int centerRegionZ = centerZ >> 9;

        int searchRadius = 0;
        while (searchRadius <= maxRegionDistanceSq) {
            for (int xoff = -searchRadius; xoff <= searchRadius; xoff++) {
                for (int zoff = -searchRadius; zoff <= searchRadius; zoff++) {
                    int distance = xoff * xoff + zoff * zoff;
                    if (distance != searchRadius) {
                        continue;
                    }
                    int regionX = xoff + centerRegionX;
                    int regionZ = zoff + centerRegionZ;
                    CachedRegion region = getOrCreateRegion(regionX, regionZ);
                    if (region != null) {
                        // TODO: 100% verify if this or addAll is faster.
                        res.addAll(region.getLocationsOf(block));
                    }
                }
            }
            if (res.size() >= maximum) {
                return res;
            }
            searchRadius++;
        }
        return res;
    }

    private void updateCachedChunk(CachedChunk chunk) {
        CachedRegion region = getOrCreateRegion(chunk.x >> 5, chunk.z >> 5);
        region.updateCachedChunk(chunk.x & 31, chunk.z & 31, chunk);
    }

    @Override
    public final void save() {
        if (!Baritone.settings().chunkCaching.value) {
            System.out.println(""Not saving to disk; chunk caching is disabled."");
            allRegions().forEach(region -> {
                if (region != null) {
                    region.removeExpired();
                }
            }); // even if we aren't saving to disk, still delete expired old chunks from RAM
            prune();
            return;
        }
        long start = System.nanoTime() / 1000000L;
        allRegions().parallelStream().forEach(region -> {
            if (region != null) {
                region.save(this.directory);
            }
        });
        long now = System.nanoTime() / 1000000L;
        System.out.println(""World save took "" + (now - start) + ""ms"");
        prune();
    }

    /**
     * Delete regions that are too far from the player
     */
    private synchronized void prune() {
        if (!Baritone.settings().pruneRegionsFromRAM.value) {
            return;
        }
        BlockPos pruneCenter = guessPosition();
        for (CachedRegion region : allRegions()) {
            if (region == null) {
                continue;
            }
            int distX = ((region.getX() << 9) + 256) - pruneCenter.getX();
            int distZ = ((region.getZ() << 9) + 256) - pruneCenter.getZ();
            double dist = Math.sqrt(distX * distX + distZ * distZ);
            if (dist > 1024) {
                if (!Baritone.settings().censorCoordinates.value) {
                    logDebug(""Deleting cached region "" + region.getX() + "","" + region.getZ() + "" from ram"");
                }
                cachedRegions.remove(getRegionID(region.getX(), region.getZ()));
            }
        }
    }

    /**
     * If we are still in this world and dimension, return player feet, otherwise return most recently modified chunk
     */
    private BlockPos guessPosition() {
        for (IBaritone ibaritone : BaritoneAPI.getProvider().getAllBaritones()) {
            IWorldData data = ibaritone.getWorldProvider().getCurrentWorld();
            if (data != null && data.getCachedWorld() == this) {
                return ibaritone.getPlayerContext().playerFeet();
            }
        }
        CachedChunk mostRecentlyModified = null;
        for (CachedRegion region : allRegions()) {
            if (region == null) {
                continue;
            }
            CachedChunk ch = region.mostRecentlyModified();
            if (ch == null) {
                continue;
            }
            if (mostRecentlyModified == null || mostRecentlyModified.cacheTimestamp < ch.cacheTimestamp) {
                mostRecentlyModified = ch;
            }
        }
        if (mostRecentlyModified == null) {
            return new BlockPos(0, 0, 0);
        }
        return new BlockPos((mostRecentlyModified.x << 4) + 8, 0, (mostRecentlyModified.z << 4) + 8);
    }

    private synchronized List<CachedRegion> allRegions() {
        return new ArrayList<>(this.cachedRegions.values());
    }

    @Override
    public final void reloadAllFromDisk() {
        long start = System.nanoTime() / 1000000L;
        allRegions().forEach(region -> {
            if (region != null) {
                region.load(this.directory);
            }
        });
        long now = System.nanoTime() / 1000000L;
        System.out.println(""World load took "" + (now - start) + ""ms"");
    }

    @Override
    public final synchronized CachedRegion getRegion(int regionX, int regionZ) {
        return cachedRegions.get(getRegionID(regionX, regionZ));
    }

    /**
     * Returns the region at the specified region coordinates. If a
     * region is not found, then a new one is created.
     *
     * @param regionX The region X coordinate
     * @param regionZ The region Z coordinate
     * @return The region located at the specified coordinates
     */
    private synchronized CachedRegion getOrCreateRegion(int regionX, int regionZ) {
        return cachedRegions.computeIfAbsent(getRegionID(regionX, regionZ), id -> {
            CachedRegion newRegion = new CachedRegion(regionX, regionZ, dimension);
            newRegion.load(this.directory);
            return newRegion;
        });
    }

    public void tryLoadFromDisk(int regionX, int regionZ) {
        getOrCreateRegion(regionX, regionZ);
    }

    /**
     * Returns the region ID based on the region coordinates. 0 will be
     * returned if the specified region coordinates are out of bounds.
     *
     * @param regionX The region X coordinate
     * @param regionZ The region Z coordinate
     * @return The region ID
     */
    private long getRegionID(int regionX, int regionZ) {
        if (!isRegionInWorld(regionX, regionZ)) {
            return 0;
        }

        return (long) regionX & 0xFFFFFFFFL | ((long) regionZ & 0xFFFFFFFFL) << 32;
    }

    /**
     * Returns whether or not the specified region coordinates is within the world bounds.
     *
     * @param regionX The region X coordinate
     * @param regionZ The region Z coordinate
     * @return Whether or not the region is in world bounds
     */
    private boolean isRegionInWorld(int regionX, int regionZ) {
        return regionX <= REGION_MAX && regionX >= -REGION_MAX && regionZ <= REGION_MAX && regionZ >= -REGION_MAX;
    }

    private class PackerThread implements Runnable {

        public void run() {
            while (true) {
                try {
                    ChunkPos pos = toPackQueue.take();
                    Chunk chunk = toPackMap.remove(pos);
                    CachedChunk cached = ChunkPacker.pack(chunk);
                    CachedWorld.this.updateCachedChunk(cached);
                    //System.out.println(""Processed chunk at "" + chunk.x + "","" + chunk.z);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    break;
                } catch (Throwable th) {
                    // in the case of an exception, keep consuming from the queue so as not to leak memory
                    th.printStackTrace();
                }
            }
        }
    }
}",1,777 657 587 2000 693 2001 44 2002 123 306 773 809 657 704 2003 61 1503 47 1504 43 1501 59 306 773 2004 60 2005 62 2006 61 744 2007 60 62 40 41 59 306 773 657 2008 2009 59 306 773 657 2010 60 2011 62 2012 61 744 2010 60 62 40 41 59 306 773 657 2013 60 2011 44 2014 62 2015 61 744 2016 60 62 40 41 59 773 657 704 2017 59 2000 40 2018 2009 44 704 2017 41 123 688 40 33 2019 46 2020 40 2009 41 41 123 830 123 2019 46 2021 40 2009 41 59 125 580 40 2022 2023 41 123 125 125 823 46 2009 61 2009 46 2024 40 41 59 823 46 2017 61 2017 59 2025 46 2026 46 2027 40 362 43 2009 41 59 2028 46 2029 40 41 46 2030 40 744 2031 40 41 41 59 2028 46 2029 40 41 46 2030 40 40 41 45 62 123 830 123 2032 46 2033 40 1506 41 59 870 40 2034 41 123 330 330 330 2035 40 41 59 2032 46 2033 40 1507 41 59 125 125 580 40 2036 2037 41 123 2037 46 2038 40 41 59 125 125 41 59 125 64 2039 777 657 865 2040 40 2014 2041 41 123 688 40 2015 46 2042 40 2041 46 2043 40 41 44 2041 41 323 2044 41 123 2012 46 2045 40 2041 46 2043 40 41 41 59 125 125 64 2039 777 657 570 2046 40 704 2047 44 704 2048 41 123 2005 2049 61 2050 40 2047 356 1502 44 2048 356 1502 41 59 688 40 2049 323 2051 41 123 792 2052 59 125 792 2049 46 2046 40 2047 38 1504 44 2048 38 1504 41 59 125 777 657 570 2053 40 704 2047 44 704 2048 41 123 792 2054 40 2047 356 1502 44 2048 356 1502 41 340 2055 59 125 64 2039 777 657 2056 60 2057 62 2058 40 2008 2059 44 704 2060 44 704 2061 44 704 2062 44 704 2063 41 123 2056 60 2057 62 2064 61 744 2056 60 62 40 41 59 704 2065 61 2061 356 1502 59 704 2066 61 2062 356 1502 59 704 2067 61 1500 59 870 40 2067 329 2063 41 123 664 40 704 2068 61 45 2067 59 2068 329 2067 59 2068 349 41 123 664 40 704 2069 61 45 2067 59 2069 329 2067 59 2069 349 41 123 704 2070 61 2068 42 2068 43 2069 42 2069 59 688 40 2070 340 2067 41 123 605 59 125 704 2071 61 2068 43 2065 59 704 2072 61 2069 43 2066 59 2005 2073 61 2074 40 2071 44 2072 41 59 688 40 2073 340 2075 41 123 330 2064 46 2076 40 2073 46 2058 40 2059 41 41 59 125 125 125 688 40 2064 46 2077 40 41 325 2060 41 123 792 2064 59 125 2067 349 59 125 792 2064 59 125 773 865 2078 40 2079 2041 41 123 2005 2080 61 2081 40 2041 46 2082 356 1502 44 2041 46 2083 356 1502 41 59 2080 46 2078 40 2041 46 2082 38 1503 44 2041 46 2083 38 1503 44 2041 41 59 125 64 2039 777 657 865 2084 40 41 123 688 40 33 2085 46 2086 40 41 46 2087 46 2088 41 123 2089 46 2090 46 2091 40 362 41 59 2092 40 41 46 2093 40 2094 45 62 123 688 40 2094 340 2095 41 123 2094 46 2096 40 41 59 125 125 41 59 330 2097 40 41 59 792 59 125 726 2098 61 2099 46 2100 40 41 47 1507 59 2101 40 41 46 2102 40 41 46 2103 40 2104 45 62 123 688 40 2104 340 2105 41 123 2104 46 2084 40 823 46 2009 41 59 125 125 41 59 726 2106 61 2099 46 2100 40 41 47 1507 59 2099 46 2107 46 2108 40 362 43 40 2106 45 2098 41 43 362 41 59 2109 40 41 59 125 306 773 821 865 2110 40 41 123 688 40 33 2111 46 2112 40 41 46 2113 46 2114 41 123 792 59 125 2057 2115 61 2116 40 41 59 664 40 2005 2117 58 2118 40 41 41 123 688 40 2117 323 2119 41 123 605 59 125 704 2120 61 40 40 2117 46 2121 40 41 332 1502 41 43 1504 41 45 2115 46 2121 40 41 59 704 2122 61 40 40 2117 46 2123 40 41 332 1502 41 43 1504 41 45 2115 46 2123 40 41 59 625 2124 61 2125 46 2126 40 2120 42 2120 43 2122 42 2122 41 59 688 40 2124 62 1505 41 123 688 40 33 2111 46 2112 40 41 46 2127 46 2114 41 123 2128 40 362 43 2117 46 2121 40 41 43 362 43 2117 46 2123 40 41 43 362 41 59 125 2006 46 2129 40 2130 40 2117 46 2121 40 41 44 2117 46 2123 40 41 41 41 59 125 125 125 306 773 2057 2131 40 41 123 664 40 2132 2133 58 2134 46 2135 40 41 46 2136 40 41 41 123 2137 2138 61 2133 46 2139 40 41 46 2140 40 41 59 688 40 2138 340 2141 307 2138 46 2142 40 41 323 823 41 123 792 2133 46 2143 40 41 46 2144 40 41 59 125 125 2079 2145 61 2146 59 664 40 2005 2147 58 2148 40 41 41 123 688 40 2147 323 2146 41 123 605 59 125 2079 2149 61 2147 46 2145 40 41 59 688 40 2149 323 2146 41 123 605 59 125 688 40 2145 323 2146 309 2145 46 2150 60 2149 46 2150 41 123 2145 61 2149 59 125 125 688 40 2145 323 2146 41 123 792 744 2057 40 1500 44 1500 44 1500 41 59 125 792 744 2057 40 40 2145 46 2151 332 1502 41 43 1502 44 1500 44 40 2145 46 2152 332 1502 41 43 1502 41 59 125 773 821 2153 60 2005 62 2154 40 41 123 792 744 2056 60 62 40 823 46 2006 46 2155 40 41 41 59 125 64 2039 777 657 865 2156 40 41 123 726 2157 61 2158 46 2159 40 41 47 1507 59 2154 40 41 46 2160 40 2161 45 62 123 688 40 2161 340 2162 41 123 2161 46 2163 40 823 46 2009 41 59 125 125 41 59 726 2164 61 2158 46 2159 40 41 47 1507 59 2158 46 2165 46 2166 40 362 43 40 2164 45 2157 41 43 362 41 59 125 64 2039 777 657 821 2005 2167 40 704 2168 44 704 2169 41 123 792 2006 46 2170 40 2171 40 2168 44 2169 41 41 59 125 306 773 821 2005 2172 40 704 2168 44 704 2169 41 123 792 2006 46 2173 40 2174 40 2168 44 2169 41 44 2175 45 62 123 2005 2176 61 744 2005 40 2168 44 2169 44 2017 41 59 2176 46 2177 40 823 46 2009 41 59 792 2176 59 125 41 59 125 777 865 2178 40 704 2168 44 704 2169 41 123 2172 40 2168 44 2169 41 59 125 306 773 726 2179 40 704 2168 44 704 2169 41 123 688 40 33 2180 40 2168 44 2169 41 41 123 792 1500 59 125 792 40 726 41 2168 38 1511 124 40 40 726 41 2169 38 1511 41 332 1503 59 125 306 773 570 2181 40 704 2168 44 704 2169 41 123 792 2168 329 2003 307 2168 325 45 2003 307 2169 329 2003 307 2169 325 45 2003 59 125 773 587 2182 693 2183 123 777 865 2184 40 41 123 870 40 2185 41 123 830 123 2011 2186 61 2012 46 2187 40 41 59 2014 2041 61 2015 46 2188 40 2186 41 59 2079 2189 61 2190 46 2191 40 2041 41 59 2000 46 823 46 2078 40 2189 41 59 330 125 580 40 2192 2193 41 123 2193 46 2194 40 41 59 572 59 125 580 40 2195 2196 41 123 330 2196 46 2197 40 41 59 125 125 125 125 125 ,"{'AvgLine': 13, 'CountLine': 283, 'CountStmt': 143, 'MaxNesting': 4, 'AvgLineCode': 11, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 109, 'MaxEssential': 7, 'SumEssential': 35, 'AvgCyclomatic': 2, 'CountLineCode': 201, 'CountStmtDecl': 55, 'MaxCyclomatic': 8, 'SumCyclomatic': 50, 'AvgLineComment': 2, 'CountClassBase': 3, 'CountLineBlank': 26, 'CountSemicolon': 90, 'CountDeclMethod': 16, 'CountLineCodeExe': 124, 'CountLineComment': 57, 'CountClassCoupled': 27, 'CountClassDerived': 0, 'CountLineCodeDecl': 56, 'CountDeclMethodAll': 16, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.28', 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 55, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 8, 'MaxCyclomaticModified': 8, 'PercentLackOfCohesion': 90, 'SumCyclomaticModified': 50, 'CountDeclClassVariable': 1, 'CountDeclMethodDefault': 1, 'CountDeclMethodPrivate': 7, 'CountDeclInstanceMethod': 16, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 27, 'CountDeclInstanceVariable': 5, 'PercentLackOfCohesionModified': 80}"
3280,Java,"public class AutoTooltipTableColumn<S, T> extends TableColumn<S, T> {

    private Label helpIcon;
    private PopOverWrapper popoverWrapper = new PopOverWrapper();

    public AutoTooltipTableColumn(String text) {
        super();

        setTitle(text);
    }

    public AutoTooltipTableColumn(String text, String help) {

        setTitleWithHelpText(text, help);
    }

    public void setTitle(String title) {
        setGraphic(new AutoTooltipLabel(title));
    }

    public void setTitleWithHelpText(String title, String help) {
        helpIcon = new Label();
        AwesomeDude.setIcon(helpIcon, AwesomeIcon.QUESTION_SIGN, ""1em"");
        helpIcon.setOpacity(0.4);
        helpIcon.setOnMouseEntered(e -> popoverWrapper.showPopOver(() -> createInfoPopOver(help)));
        helpIcon.setOnMouseExited(e -> popoverWrapper.hidePopOver());

        final AutoTooltipLabel label = new AutoTooltipLabel(title);
        final HBox hBox = new HBox(label, helpIcon);
        hBox.setStyle(""-fx-alignment: center-left"");
        hBox.setSpacing(4);
        setGraphic(hBox);
    }

    private PopOver createInfoPopOver(String help) {
        Label helpLabel = new Label(help);
        helpLabel.setMaxWidth(300);
        helpLabel.setWrapText(true);
        return createInfoPopOver(helpLabel);
    }

    private PopOver createInfoPopOver(Node node) {
        node.getStyleClass().add(""default-text"");

        PopOver infoPopover = new PopOver(node);
        if (helpIcon.getScene() != null) {
            infoPopover.setDetachable(false);
            infoPopover.setArrowLocation(PopOver.ArrowLocation.LEFT_CENTER);

            infoPopover.show(helpIcon, -10);
        }
        return infoPopover;
    }
}",1,777 587 2000 60 2001 44 2002 62 650 2003 60 2001 44 2002 62 123 773 2004 2005 59 773 2006 2007 61 744 2006 40 41 59 777 2000 40 2008 2009 41 123 818 40 41 59 2010 40 2009 41 59 125 777 2000 40 2008 2009 44 2008 2011 41 123 2012 40 2009 44 2011 41 59 125 777 865 2013 40 2008 2014 41 123 2015 40 744 2016 40 2014 41 41 59 125 777 865 2017 40 2008 2014 44 2008 2011 41 123 2005 61 744 2004 40 41 59 2018 46 2019 40 2005 44 2020 46 2021 44 362 41 59 2005 46 2022 40 1500 41 59 2005 46 2023 40 2024 45 62 2007 46 2025 40 40 41 45 62 2026 40 2011 41 41 41 59 2005 46 2027 40 2024 45 62 2007 46 2028 40 41 41 59 657 2029 2030 61 744 2029 40 2014 41 59 657 2031 2032 61 744 2031 40 2030 44 2005 41 59 2032 46 2033 40 362 41 59 2032 46 2034 40 1502 41 59 2035 40 2032 41 59 125 773 2036 2037 40 2008 2011 41 123 2004 2038 61 744 2004 40 2011 41 59 2038 46 2039 40 1504 41 59 2038 46 2040 40 2041 41 59 792 2037 40 2038 41 59 125 773 2036 2037 40 2042 2043 41 123 2043 46 2044 40 41 46 2045 40 362 41 59 2036 2046 61 744 2036 40 2043 41 59 688 40 2005 46 2047 40 41 340 2048 41 123 2046 46 2049 40 2050 41 59 2046 46 2051 40 2036 46 2052 46 2053 41 59 2046 46 2054 40 2005 44 45 1502 41 59 125 792 2046 59 125 125 ,"{'AvgLine': 7, 'CountLine': 54, 'CountStmt': 34, 'MaxNesting': 1, 'AvgLineCode': 6, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 26, 'MaxEssential': 1, 'SumEssential': 8, 'AvgCyclomatic': 1, 'CountLineCode': 42, 'CountStmtDecl': 13, 'MaxCyclomatic': 2, 'SumCyclomatic': 9, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 12, 'CountSemicolon': 26, 'CountDeclMethod': 6, 'CountLineCodeExe': 26, 'CountLineComment': 0, 'CountClassCoupled': 10, 'CountClassDerived': 25, 'CountLineCodeDecl': 13, 'CountDeclMethodAll': 6, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 2, 'SumCyclomaticStrict': 9, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 4, 'MaxCyclomaticModified': 2, 'PercentLackOfCohesion': 83, 'SumCyclomaticModified': 9, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 2, 'CountDeclInstanceMethod': 6, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 10, 'CountDeclInstanceVariable': 2, 'PercentLackOfCohesionModified': 75}"
26372,Java,"public class AuthController {

    private static final Logger LOGGER = LoggerFactory.getLogger(AuthController.class);
    private static final Logger LOGIN_HISTORY = LoggerFactory.getLogger(""loginHistory"");
    private static final int LOGIN_TIMEOUT = 3;
    private static final Pattern USERNAME_PATTERN = Pattern.compile(usernameTemplate());
    private static final String ACCOUNT_LOGIN_FAILED = ""Account Login Failed {} : {}"";

    private final Map<String, AuthClient> authedClients = new ConcurrentHashMap<>();
    private final Map<String, FailedLoginAttempt> bruteForceProtection = new HashMap<>();
    private final BanManager banManager;
    private final int key;

    private KeyGenerator blowfishKeysGenerator;
    private ScheduledFuture<?> scheduledPurge;

    private ScrambledKeyPair[] _keyPairs;

    private AuthController() {
        banManager = BanManager.getInstance();
        try {
            load();
        } catch (GeneralSecurityException e) {
            LOGGER.error(e.getMessage(), e);
        }
        key = Rnd.nextSecureInt();
    }

    private void load() throws GeneralSecurityException {
        LOGGER.info(""Loading Auth Controller..."");
        blowfishKeysGenerator = KeyGenerator.getInstance(""Blowfish"");
        initializeScrambledKeys();
    }

    private void initializeScrambledKeys() throws GeneralSecurityException {
        var keygen = KeyPairGenerator.getInstance(""RSA"");
        var spec = new RSAKeyGenParameterSpec(1024, RSAKeyGenParameterSpec.F4);
        keygen.initialize(spec);

        _keyPairs = new ScrambledKeyPair[10];

        for (int i = 0; i < 10; i++) {
            _keyPairs[i] = new ScrambledKeyPair(keygen.generateKeyPair());
        }
        LOGGER.info(""Cached 10 KeyPairs for RSA communication"");

        testCipher((RSAPrivateKey) _keyPairs[0].getPair().getPrivate());
    }

    private void testCipher(RSAPrivateKey key) throws GeneralSecurityException {
        Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/nopadding"");
        rsaCipher.init(Cipher.DECRYPT_MODE, key);
    }

    public void registerClient(AuthClient client) {
        client.setKeyPar(getScrambledRSAKeyPair());
        var blowfishKey  = getBlowfishKey();
        client.setBlowfishKey(blowfishKey);
        client.setSessionId(Rnd.nextSecureInt());
        var cripter = new AuthCrypt();
        cripter.setKey(blowfishKey);
        client.setCrypt(cripter);

        if(isNull(scheduledPurge) || scheduledPurge.isCancelled()) {
            scheduledPurge = ThreadPool.scheduleAtFixedDelay(new PurgeThread(), LOGIN_TIMEOUT, LOGIN_TIMEOUT, TimeUnit.MINUTES);
        }
    }

    private void assignSessionKeyToClient(AuthClient client) {
        var sessionKey = new SessionKey(Rnd.nextSecureInt(), this.key, Rnd.nextSecureInt(), Rnd.nextSecureInt());
        client.setSessionKey(sessionKey);
        authedClients.put(client.getAccount().getLogin(), client);
    }

    public void removeAuthedClient(String account) {
        if(isNullOrEmpty(account)) {
            return;
        }
        authedClients.remove(account);
    }

    public void authenticate(AuthClient client, String username, String password) {
        if(!isValidUserName(username)) {
            client.close(REASON_ACCOUNT_INFO_INCORR);
            LOGIN_HISTORY.debug(""Invalid Username"");
            return;
        }

        var account = getDAO(AccountDAO.class).findById(username);
        if(nonNull(account)) {
           verifyAccountInfo(client, account, password);
        } else if(isAutoCreateAccount()) {
            createNewAccount(client, username, password);
        } else {
            LOGIN_HISTORY.debug(""Username no found"");
            client.close(REASON_ACCOUNT_INFO_INCORR);
        }
    }

    private void verifyAccountInfo(AuthClient client, Account account, String password) {
        try {
            if(hash(password).equals(account.getPassword())) {
                if(account.isBanned()) {
                    client.close(REASON_PERMANENTLY_BANNED);
                    LOGIN_HISTORY.info(ACCOUNT_LOGIN_FAILED, account.getLogin(), ""Banned Account"");
                } else if( verifyAccountInUse(account)) {
                    client.close(REASON_ACCOUNT_IN_USE);
                    LOGIN_HISTORY.info(ACCOUNT_LOGIN_FAILED, account.getLogin(), ""Account Already In Use"");
                } else {
                    processAuth(client, account);
                }
            } else {
                client.close(REASON_ACCOUNT_INFO_INCORR);
                addLoginFailed(account, password, client);
                LOGIN_HISTORY.info(ACCOUNT_LOGIN_FAILED, account.getLogin(), ""Wrong Username or Password"");
            }
        } catch (NoSuchAlgorithmException e) {
            LOGGER.error(e.getMessage(), e);
            client.close(REASON_SYSTEM_ERROR);
        }
    }

    private boolean verifyAccountInUse(Account account) {
        var result = false;
        var authedClient = authedClients.get(account.getLogin());
        if(nonNull(authedClient)) {
            authedClient.close(REASON_ACCOUNT_IN_USE);
            removeAuthedClient(account.getLogin());
            result = true;
        }

        for (var gameServer : GameServerManager.getInstance().getRegisteredGameServers().values()) {
            if(nonNull(gameServer) && gameServer.isAccountInUse(account.getLogin())) {
                gameServer.disconnectAccount(account.getLogin());
                result = true;
            }
        }
        return result;
    }

    private void processAuth(AuthClient client, Account account) {
        updateClientInfo(client, account);
        requestAccountInfo(client, account);
        if(client.getRequestedServersInfo() == 0) {
            client.sendPacket(new LoginOk());
        }
        bruteForceProtection.remove(account.getLogin());
        LOGIN_HISTORY.info(""Account Logged {}"", account.getLogin());
    }

    private void requestAccountInfo(AuthClient client, Account account) {
        var gameservers = GameServerManager.getInstance().getRegisteredGameServers().values().stream().filter(ServerInfo::isAuthed).toList();
        client.setRequestedServerInfo(gameservers.size());
        gameservers.forEach(gameServer -> gameServer.requestAccountInfo(account.getLogin()));
    }

    private void updateClientInfo(AuthClient client, Account account) {
        client.setAccount(account);
        assignSessionKeyToClient(client);
        client.setState(AUTHED_LOGIN);
        account.setLastAccess(currentTimeMillis());
        account.setLastIP(client.getHostAddress());
        getDAO(AccountDAO.class).updateAccess(account.getLogin(), account.getLastAccess(), client.getHostAddress());
    }

    private void createNewAccount(AuthClient client, String username, String password) {
        try {
            var account = new Account(username, hash(password), currentTimeMillis(), client.getHostAddress());
            getDAO(AccountDAO.class).save(account);
            processAuth(client, account);
        } catch (NoSuchAlgorithmException e) {
            LOGGER.error(e.getMessage(), e);
        }
    }

    public void addAccountCharactersInfo(int serverId, String account, int players) {
        AuthClient client = authedClients.get(account);
        if (nonNull(client)) {
            client.addCharactersOnServer(serverId, players);
            if(client.getCharactersOnServer().size() == client.getRequestedServersInfo()) {
                client.sendPacket(new LoginOk());
            }
        }
    }

    public SessionKey getKeyForAccount(String account) {
        AuthClient client = authedClients.get(account);
        if (nonNull(client)) {
            return client.getSessionKey();
        }
        return null;
    }

    public boolean isLoginPossible(AuthClient client, int serverId) {
        var gsi = GameServerManager.getInstance().getRegisteredGameServerById(serverId);
        int access = client.getAccessLevel();
        if (nonNull(gsi) && gsi.isAuthed()) {
            boolean loginOk = ((gsi.onlineAccounts() < gsi.maxAccounts()) && (gsi.status() != ServerStatus.STATUS_GM_ONLY)) || (access >= AuthServerSettings.gmMinimumLevel());

            if (loginOk && (client.getLastServer() != serverId)) {
                if(getDAO(AccountDAO.class).updateLastServer(client.getAccount().getLogin(), serverId) < 1) {
                    LOGGER.warn(""Could not set lastServer of account {} "", client.getAccount().getLogin());
                }
            }
            return loginOk;
        }
        return false;
    }

    public void setAccountAccessLevel(String login, short accessLevel) {
        if(getDAO(AccountDAO.class).updateAccessLevel(login, accessLevel) < 1) {
            LOGGER.warn(""Could not set accessLevel of account {}"", login);
        }
    }

    private void addLoginFailed(Account account, String password, AuthClient client) {
        FailedLoginAttempt failedAttempt = bruteForceProtection.get(account.getLogin());
        if(nonNull(failedAttempt)) {
            failedAttempt.increaseCounter(password);
        } else {
            failedAttempt = new FailedLoginAttempt(password);
            bruteForceProtection.put(account.getLogin(), failedAttempt);
        }

        if(failedAttempt.getCount() >= authTriesBeforeBan())  {
            LOGGER.info(""Banning {} for {} seconds due to {} invalid user/pass attempts"", client.getHostAddress(), loginBlockAfterBan(), failedAttempt.getCount());
            banManager.addBannedAdress(client.getHostAddress(), currentTimeMillis() + loginBlockAfterBan() * 1000L);
        }
    }

    private ScrambledKeyPair getScrambledRSAKeyPair() {
        return _keyPairs[Rnd.get(10)];
    }

    private byte[] getBlowfishKey() {
        return blowfishKeysGenerator.generateKey().getEncoded();
    }

    private boolean isValidUserName(String username) {
        return USERNAME_PATTERN.matcher(username).matches();
    }

    public boolean isBannedAddress(String address) {
        return banManager.isBanned(address);
    }

    public static AuthController getInstance() {
        return Singleton.INSTANCE;
    }

    public int getKey() {
        return key;
    }

    private static class Singleton {
        private static final AuthController INSTANCE = new AuthController();
    }

    private static class FailedLoginAttempt {

        private int _count = 1;
        private long _lastAttempTime;
        private String _lastPassword;

        FailedLoginAttempt(String lastPassword) {
            _lastAttempTime = currentTimeMillis();
            _lastPassword = lastPassword;
        }

        void increaseCounter(String password) {
            if (!_lastPassword.equals(password)) {
                // check if theres a long time since last wrong try
                if ((currentTimeMillis() - _lastAttempTime) < (300 * 1000)) {
                    _count++;
                } else {
                    _count = 1;

                }
                _lastPassword = password;
            }
            _lastAttempTime = currentTimeMillis();
        }

        int getCount() {
            return _count;
        }
    }

    private class PurgeThread implements Runnable{
        @Override
        public void run() {
            synchronized (authedClients) {
                var entries = authedClients.entrySet().iterator();
                while (entries.hasNext()) {
                    var entry = entries.next();
                    var client = entry.getValue();

                    if(!client.isJoinedGameSever() && client.getConnectionStartTime() + TimeUnit.MINUTES.toMillis(LOGIN_TIMEOUT) <= currentTimeMillis() || !client.isConnected()) {
                        client.close(REASON_ACCESS_FAILED_TRYA1);
                        entries.remove();
                    }
                }

                if(authedClients.isEmpty()) {
                    scheduledPurge.cancel(false);
                }
            }
        }
    }
}",1,777 587 2000 123 773 809 657 2001 2002 61 2003 46 2004 40 2000 46 587 41 59 773 809 657 2001 2005 61 2003 46 2004 40 362 41 59 773 809 657 704 2006 61 1502 59 773 809 657 2007 2008 61 2007 46 2009 40 2010 40 41 41 59 773 809 657 2011 2012 61 362 59 773 657 2013 60 2011 44 2014 62 2015 61 744 2016 60 62 40 41 59 773 657 2013 60 2011 44 2017 62 2018 61 744 2019 60 62 40 41 59 773 657 2020 2021 59 773 657 704 2022 59 773 2023 2024 59 773 2025 60 63 62 2026 59 773 2027 91 93 2028 59 773 2000 40 41 123 2021 61 2020 46 2029 40 41 59 830 123 2030 40 41 59 125 580 40 2031 2032 41 123 2002 46 2033 40 2032 46 2034 40 41 44 2032 41 59 125 2022 61 2035 46 2036 40 41 59 125 773 865 2037 40 41 826 2038 123 2002 46 2039 40 362 41 59 2024 61 2023 46 2040 40 362 41 59 2041 40 41 59 125 773 865 2042 40 41 826 2038 123 2043 2044 61 2045 46 2046 40 362 41 59 2043 2047 61 744 2048 40 1505 44 2048 46 2049 41 59 2044 46 2050 40 2047 41 59 2028 61 744 2027 91 1502 93 59 664 40 704 2051 61 1500 59 2051 60 1502 59 2051 349 41 123 2028 91 2051 93 61 744 2027 40 2044 46 2052 40 41 41 59 125 2002 46 2053 40 362 41 59 2054 40 40 2055 41 2028 91 1500 93 46 2056 40 41 46 2057 40 41 41 59 125 773 865 2058 40 2059 2022 41 826 2038 123 2060 2061 61 2060 46 2062 40 362 41 59 2061 46 2063 40 2060 46 2064 44 2022 41 59 125 777 865 2065 40 2014 2066 41 123 2066 46 2067 40 2068 40 41 41 59 2069 2070 61 2071 40 41 59 2066 46 2072 40 2070 41 59 2066 46 2073 40 2074 46 2075 40 41 41 59 2069 2076 61 744 2077 40 41 59 2076 46 2078 40 2070 41 59 2066 46 2079 40 2076 41 59 688 40 2080 40 2026 41 309 2026 46 2081 40 41 41 123 2026 61 2082 46 2083 40 744 2084 40 41 44 2006 44 2006 44 2085 46 2086 41 59 125 125 773 865 2087 40 2014 2066 41 123 2088 2089 61 744 2090 40 2091 46 2092 40 41 44 823 46 2022 44 2091 46 2092 40 41 44 2091 46 2092 40 41 41 59 2066 46 2093 40 2089 41 59 2015 46 2094 40 2066 46 2095 40 41 46 2096 40 41 44 2066 41 59 125 777 865 2097 40 2011 2098 41 123 688 40 2099 40 2098 41 41 123 792 59 125 2015 46 2100 40 2098 41 59 125 777 865 2101 40 2014 2066 44 2011 2102 44 2011 2103 41 123 688 40 33 2104 40 2102 41 41 123 2066 46 2105 40 2106 41 59 2005 46 2107 40 362 41 59 792 59 125 2108 2098 61 2109 40 2110 46 587 41 46 2111 40 2102 41 59 688 40 2112 40 2098 41 41 123 2113 40 2066 44 2098 44 2103 41 59 125 630 688 40 2114 40 41 41 123 2115 40 2066 44 2102 44 2103 41 59 125 630 123 2005 46 2116 40 362 41 59 2066 46 2117 40 2118 41 59 125 125 773 865 2119 40 2014 2066 44 2120 2098 44 2011 2103 41 123 830 123 688 40 2121 40 2103 41 46 2122 40 2098 46 2123 40 41 41 41 123 688 40 2098 46 2124 40 41 41 123 2066 46 2125 40 2126 41 59 2005 46 2127 40 2012 44 2098 46 2128 40 41 44 362 41 59 125 630 688 40 2129 40 2098 41 41 123 2066 46 2130 40 2131 41 59 2005 46 2132 40 2012 44 2098 46 2133 40 41 44 362 41 59 125 630 123 2134 40 2066 44 2098 41 59 125 125 630 123 2066 46 2135 40 2136 41 59 2137 40 2098 44 2103 44 2066 41 59 2005 46 2138 40 2012 44 2098 46 2139 40 41 44 362 41 59 125 125 580 40 2140 2141 41 123 2002 46 2142 40 2141 46 2143 40 41 44 2141 41 59 2066 46 2144 40 2145 41 59 125 125 773 570 2146 40 2120 2098 41 123 2147 2148 61 2149 59 2147 2150 61 2015 46 2151 40 2098 46 2152 40 41 41 59 688 40 2153 40 2150 41 41 123 2150 46 2154 40 2155 41 59 2097 40 2098 46 2152 40 41 41 59 2148 61 2156 59 125 664 40 2147 2157 58 2158 46 2159 40 41 46 2160 40 41 46 2161 40 41 41 123 688 40 2153 40 2157 41 307 2157 46 2162 40 2098 46 2152 40 41 41 41 123 2157 46 2163 40 2098 46 2152 40 41 41 59 2148 61 2164 59 125 125 792 2148 59 125 773 865 2165 40 2014 2066 44 2120 2098 41 123 2166 40 2066 44 2098 41 59 2167 40 2066 44 2098 41 59 688 40 2066 46 2168 40 41 323 1500 41 123 2066 46 2169 40 744 2170 40 41 41 59 125 2018 46 2171 40 2098 46 2172 40 41 41 59 2005 46 2173 40 362 44 2098 46 2172 40 41 41 59 125 773 865 2174 40 2014 2066 44 2120 2098 41 123 2175 2176 61 2177 46 2178 40 41 46 2179 40 41 46 2180 40 41 46 2181 40 41 46 2182 40 2183 58 58 2184 41 46 2185 40 41 59 2066 46 2186 40 2176 46 2187 40 41 41 59 2176 46 2188 40 2189 45 62 2189 46 2174 40 2098 46 2190 40 41 41 41 59 125 773 865 2191 40 2014 2066 44 2120 2098 41 123 2066 46 2192 40 2098 41 59 2087 40 2066 41 59 2066 46 2193 40 2194 41 59 2098 46 2195 40 2196 40 41 41 59 2098 46 2197 40 2066 46 2198 40 41 41 59 2199 40 2200 46 587 41 46 2201 40 2098 46 2202 40 41 44 2098 46 2203 40 41 44 2066 46 2198 40 41 41 59 125 773 865 2204 40 2014 2066 44 2011 2102 44 2011 2103 41 123 830 123 2205 2098 61 744 2120 40 2102 44 2206 40 2103 41 44 2207 40 41 44 2066 46 2208 40 41 41 59 2209 40 2210 46 587 41 46 2211 40 2098 41 59 2165 40 2066 44 2098 41 59 125 580 40 2212 2213 41 123 2002 46 2214 40 2213 46 2215 40 41 44 2213 41 59 125 125 777 865 2216 40 704 2217 44 2011 2098 44 704 2218 41 123 2014 2066 61 2015 46 2219 40 2098 41 59 688 40 2220 40 2066 41 41 123 2066 46 2221 40 2217 44 2218 41 59 688 40 2066 46 2222 40 41 46 2223 40 41 323 2066 46 2224 40 41 41 123 2066 46 2225 40 744 2226 40 41 41 59 125 125 125 777 2227 2228 40 2011 2098 41 123 2014 2066 61 2015 46 2229 40 2098 41 59 688 40 2230 40 2066 41 41 123 792 2066 46 2231 40 41 59 125 792 2232 59 125 777 570 2233 40 2014 2066 44 704 2217 41 123 2234 2235 61 2236 46 2237 40 41 46 2238 40 2217 41 59 704 2239 61 2066 46 2240 40 41 59 688 40 2241 40 2235 41 307 2235 46 2242 40 41 41 123 570 2243 61 40 40 2235 46 2244 40 41 60 2235 46 2245 40 41 41 307 40 2235 46 2246 40 41 340 2247 46 2248 41 41 309 40 2239 325 2249 46 2250 40 41 41 59 688 40 2243 307 40 2066 46 2251 40 41 340 2217 41 41 123 688 40 2252 40 2253 46 587 41 46 2254 40 2066 46 2255 40 41 46 2256 40 41 44 2217 41 60 1501 41 123 2002 46 2257 40 362 44 2066 46 2255 40 41 46 2256 40 41 41 59 125 125 792 2243 59 125 792 2258 59 125 777 865 2259 40 2011 2260 44 803 2261 41 123 688 40 2262 40 2263 46 587 41 46 2264 40 2260 44 2261 41 60 1501 41 123 2002 46 2265 40 362 44 2260 41 59 125 125 773 865 2266 40 2120 2098 44 2011 2103 44 2014 2066 41 123 2017 2267 61 2018 46 2268 40 2098 46 2269 40 41 41 59 688 40 2270 40 2267 41 41 123 2267 46 2271 40 2103 41 59 125 630 123 2267 61 744 2017 40 2103 41 59 2018 46 2272 40 2098 46 2269 40 41 44 2267 41 59 125 688 40 2267 46 2273 40 41 325 2274 40 41 41 123 2002 46 2275 40 362 44 2066 46 2276 40 41 44 2277 40 41 44 2267 46 2273 40 41 41 59 2021 46 2278 40 2066 46 2276 40 41 44 2279 40 41 43 2277 40 41 42 1504 41 59 125 125 773 2027 2280 40 41 123 792 2028 91 2281 46 2282 40 1502 41 93 59 125 773 574 91 93 2283 40 41 123 792 2024 46 2284 40 41 46 2285 40 41 59 125 773 570 2286 40 2011 2102 41 123 792 2008 46 2287 40 2102 41 46 2288 40 41 59 125 777 570 2289 40 2011 2290 41 123 792 2021 46 2291 40 2290 41 59 125 777 809 2000 2292 40 41 123 792 2293 46 2294 59 125 777 704 2295 40 41 123 792 2022 59 125 773 809 587 2296 123 773 809 657 2000 2297 61 744 2000 40 41 59 125 773 809 587 2017 123 773 704 2298 61 1501 59 773 726 2299 59 773 2011 2300 59 2017 40 2011 2301 41 123 2299 61 2302 40 41 59 2300 61 2301 59 125 865 2303 40 2011 2103 41 123 688 40 33 2300 46 2304 40 2103 41 41 123 330 688 40 40 2305 40 41 45 2299 41 60 40 1504 42 1504 41 41 123 2298 349 59 125 630 123 2298 61 1501 59 125 2300 61 2103 59 125 2299 61 2306 40 41 59 125 704 2307 40 41 123 792 2298 59 125 125 773 587 2308 693 2309 123 64 2310 777 865 2311 40 41 123 821 40 2015 41 123 2312 2313 61 2015 46 2314 40 41 46 2315 40 41 59 870 40 2313 46 2316 40 41 41 123 2312 2317 61 2313 46 2318 40 41 59 2312 2066 61 2317 46 2319 40 41 59 688 40 33 2066 46 2320 40 41 307 2066 46 2321 40 41 43 2322 46 2323 46 2324 40 2006 41 329 2325 40 41 309 33 2066 46 2326 40 41 41 123 2066 46 2327 40 2328 41 59 2313 46 2329 40 41 59 125 125 688 40 2015 46 2330 40 41 41 123 2026 46 2331 40 2332 41 59 125 125 125 125 125 ,"{'AvgLine': 8, 'CountLine': 313, 'CountStmt': 194, 'MaxNesting': 3, 'AvgLineCode': 8, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 148, 'MaxEssential': 1, 'SumEssential': 26, 'AvgCyclomatic': 2, 'CountLineCode': 262, 'CountStmtDecl': 71, 'MaxCyclomatic': 5, 'SumCyclomatic': 51, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 47, 'CountSemicolon': 129, 'CountDeclMethod': 25, 'CountLineCodeExe': 159, 'CountLineComment': 4, 'CountClassCoupled': 39, 'CountClassDerived': 0, 'CountLineCodeDecl': 70, 'CountDeclMethodAll': 25, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.02', 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 57, 'CountDeclClassMethod': 1, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 10, 'MaxCyclomaticModified': 5, 'PercentLackOfCohesion': 89, 'SumCyclomaticModified': 51, 'CountDeclClassVariable': 5, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 15, 'CountDeclInstanceMethod': 24, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 39, 'CountDeclInstanceVariable': 7, 'PercentLackOfCohesionModified': 78}"
5175,Java,"@FxmlView
public class TradesChartsView extends ActivatableViewAndModel<VBox, TradesChartsViewModel> {
    private static final int SHOW_ALL = 0;

    static class CurrencyStringConverter extends StringConverter<CurrencyListItem> {
        private final ComboBox<CurrencyListItem> comboBox;

        CurrencyStringConverter(ComboBox<CurrencyListItem> comboBox) {
            this.comboBox = comboBox;
        }

        @Override
        public String toString(CurrencyListItem currencyItem) {
            return currencyItem != null ? currencyItem.codeDashNameString() : """";
        }

        @Override
        public CurrencyListItem fromString(String query) {
            if (comboBox.getItems().isEmpty())
                return null;
            if (query.isEmpty())
                return specialShowAllItem();
            return comboBox.getItems().stream().
                    filter(currencyItem -> currencyItem.codeDashNameString().equals(query)).
                    findAny().orElse(null);
        }

        private CurrencyListItem specialShowAllItem() {
            return comboBox.getItems().get(0);
        }
    }

    private final User user;
    private final CoinFormatter coinFormatter;

    private VolumeChart volumeChart, volumeInUsdChart;
    private CandleStickChart priceChart;
    private AutocompleteComboBox<CurrencyListItem> currencyComboBox;
    private TableView<TradeStatistics3ListItem> tableView;
    private Hyperlink exportLink;
    private HBox toolBox;
    private Pane rootParent;
    private AnchorPane priceChartPane, volumeChartPane;
    private HBox footer;
    private AutoTooltipSlideToggleButton showVolumeAsUsdToggleButton;
    private Label nrOfTradeStatisticsLabel;
    private ToggleGroup toggleGroup;
    private SingleSelectionModel<Tab> tabPaneSelectionModel;

    private TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> priceColumn, volumeColumn, marketColumn;
    private SortedList<TradeStatistics3ListItem> sortedList = new SortedList<>(FXCollections.observableArrayList());

    private ChangeListener<Toggle> timeUnitChangeListener;
    private ChangeListener<Number> priceAxisYWidthListener;
    private ChangeListener<Number> volumeAxisYWidthListener;
    private ChangeListener<Number> selectedTabIndexListener;
    private ChangeListener<Number> parentHeightListener;
    private ChangeListener<String> priceColumnLabelListener;
    private ListChangeListener<XYChart.Data<Number, Number>> itemsChangeListener;
    private ListChangeListener<TradeStatistics3> tradeStatisticsByCurrencyListener;

    @SuppressWarnings(""FieldCanBeLocal"")
    private MonadicBinding<Void> currencySelectionBinding;
    private Subscription currencySelectionSubscriber;

    private final StringProperty priceColumnLabel = new SimpleStringProperty();
    private NumberAxis priceAxisX, priceAxisY, volumeAxisY, volumeAxisX, volumeInUsdAxisX;
    private XYChart.Series<Number, Number> priceSeries;
    private final XYChart.Series<Number, Number> volumeSeries = new XYChart.Series<>();
    private final XYChart.Series<Number, Number> volumeInUsdSeries = new XYChart.Series<>();
    private double priceAxisYWidth;
    private double volumeAxisYWidth;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, lifecycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    @SuppressWarnings(""WeakerAccess"")
    @Inject
    public TradesChartsView(TradesChartsViewModel model,
                            User user,
                            @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter coinFormatter) {
        super(model);
        this.user = user;
        this.coinFormatter = coinFormatter;
    }

    @Override
    public void initialize() {
        root.setAlignment(Pos.CENTER_LEFT);
        toolBox = getToolBox();

        createCharts();

        createTable();

        footer = new HBox();
        VBox.setVgrow(footer, Priority.ALWAYS);

        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        nrOfTradeStatisticsLabel = new AutoTooltipLabel("" ""); // set empty string for layout
        nrOfTradeStatisticsLabel.setPadding(new Insets(-2, 0, -10, 12));

        exportLink = new Hyperlink(Res.get(""shared.exportCSV""));
        exportLink.setPadding(new Insets(-2, 12, -10, 0));

        footer.getChildren().addAll(nrOfTradeStatisticsLabel, spacer, exportLink);

        root.getChildren().addAll(toolBox, priceChartPane, volumeChartPane, tableView, footer);

        timeUnitChangeListener = (observable, oldValue, newValue) -> {
            if (newValue != null) {
                model.setTickUnit((TradesChartsViewModel.TickUnit) newValue.getUserData());
                priceAxisX.setTickLabelFormatter(getTimeAxisStringConverter());
                volumeAxisX.setTickLabelFormatter(getTimeAxisStringConverter());
                volumeInUsdAxisX.setTickLabelFormatter(getTimeAxisStringConverter());
            }
        };
        priceAxisYWidthListener = (observable, oldValue, newValue) -> {
            priceAxisYWidth = (double) newValue;
            layoutChart();
        };
        volumeAxisYWidthListener = (observable, oldValue, newValue) -> {
            volumeAxisYWidth = (double) newValue;
            layoutChart();
        };
        tradeStatisticsByCurrencyListener = c -> {
            nrOfTradeStatisticsLabel.setText(Res.get(""market.trades.nrOfTrades"", model.tradeStatisticsByCurrency.size()));
            fillList();
        };
        parentHeightListener = (observable, oldValue, newValue) -> layout();

        priceColumnLabelListener = (o, oldVal, newVal) -> priceColumn.setGraphic(new AutoTooltipLabel(newVal));

        // Need to render on next frame as otherwise there are issues in the chart rendering
        itemsChangeListener = c -> UserThread.execute(this::updateChartData);

        currencySelectionBinding = EasyBind.combine(
                model.showAllTradeCurrenciesProperty, model.selectedTradeCurrencyProperty,
                (showAll, selectedTradeCurrency) -> {
                    priceChart.setVisible(!showAll);
                    priceChart.setManaged(!showAll);
                    priceColumn.setSortable(!showAll);

                    if (showAll) {
                        volumeColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.amount"")));
                        priceColumnLabel.set(Res.get(""shared.price""));
                        if (!tableView.getColumns().contains(marketColumn))
                            tableView.getColumns().add(1, marketColumn);

                        volumeChart.setPrefHeight(volumeChart.getMaxHeight());
                        volumeInUsdChart.setPrefHeight(volumeInUsdChart.getMaxHeight());
                    } else {
                        volumeChart.setPrefHeight(volumeChart.getMinHeight());
                        volumeInUsdChart.setPrefHeight(volumeInUsdChart.getMinHeight());
                        priceSeries.setName(selectedTradeCurrency.getName());
                        String code = selectedTradeCurrency.getCode();
                        volumeColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.amountWithCur"", code)));

                        priceColumnLabel.set(CurrencyUtil.getPriceWithCurrencyCode(code));

                        tableView.getColumns().remove(marketColumn);
                    }

                    layout();
                    return null;
                });
    }

    @Override
    protected void activate() {
        tabPaneSelectionModel = GUIUtil.getParentOfType(root, JFXTabPane.class).getSelectionModel();
        selectedTabIndexListener = (observable, oldValue, newValue) -> model.setSelectedTabIndex((int) newValue);
        model.setSelectedTabIndex(tabPaneSelectionModel.getSelectedIndex());
        tabPaneSelectionModel.selectedIndexProperty().addListener(selectedTabIndexListener);

        currencyComboBox.setConverter(new CurrencyStringConverter(currencyComboBox));
        currencyComboBox.getEditor().getStyleClass().add(""combo-box-editor-bold"");

        currencyComboBox.setAutocompleteItems(model.getCurrencyListItems());
        currencyComboBox.setVisibleRowCount(10);

        if (model.showAllTradeCurrenciesProperty.get())
            currencyComboBox.getSelectionModel().select(SHOW_ALL);
        else if (model.getSelectedCurrencyListItem().isPresent())
            currencyComboBox.getSelectionModel().select(model.getSelectedCurrencyListItem().get());
        currencyComboBox.getEditor().setText(new CurrencyStringConverter(currencyComboBox).toString(currencyComboBox.getSelectionModel().getSelectedItem()));

        currencyComboBox.setOnChangeConfirmed(e -> {
            if (currencyComboBox.getEditor().getText().isEmpty())
                currencyComboBox.getSelectionModel().select(SHOW_ALL);
            CurrencyListItem selectedItem = currencyComboBox.getSelectionModel().getSelectedItem();
            if (selectedItem != null) {
                model.onSetTradeCurrency(selectedItem.tradeCurrency);
            }
        });

        toggleGroup.getToggles().get(model.tickUnit.ordinal()).setSelected(true);

        model.priceItems.addListener(itemsChangeListener);
        toggleGroup.selectedToggleProperty().addListener(timeUnitChangeListener);
        priceAxisY.widthProperty().addListener(priceAxisYWidthListener);
        volumeAxisY.widthProperty().addListener(volumeAxisYWidthListener);
        model.tradeStatisticsByCurrency.addListener(tradeStatisticsByCurrencyListener);

        priceAxisY.labelProperty().bind(priceColumnLabel);
        priceColumnLabel.addListener(priceColumnLabelListener);
        currencySelectionSubscriber = currencySelectionBinding.subscribe((observable, oldValue, newValue) -> {
        });

        boolean useAnimations = model.preferences.isUseAnimations();
        priceChart.setAnimated(useAnimations);
        volumeChart.setAnimated(useAnimations);
        volumeInUsdChart.setAnimated(useAnimations);
        priceAxisX.setTickLabelFormatter(getTimeAxisStringConverter());
        volumeAxisX.setTickLabelFormatter(getTimeAxisStringConverter());
        volumeInUsdAxisX.setTickLabelFormatter(getTimeAxisStringConverter());

        nrOfTradeStatisticsLabel.setText(Res.get(""market.trades.nrOfTrades"", model.tradeStatisticsByCurrency.size()));

        exportLink.setOnAction(e -> exportToCsv());

        if (root.getParent() instanceof Pane) {
            rootParent = (Pane) root.getParent();
            rootParent.heightProperty().addListener(parentHeightListener);
        }

        user.getCookie().getAsOptionalBoolean(CookieKey.TRADE_STAT_CHART_USE_USD).ifPresent(showUsd -> {
            showVolumeAsUsdToggleButton.setSelected(showUsd);
            showVolumeAsUsd(showUsd);
        });
        showVolumeAsUsdToggleButton.setOnAction(e -> {
            boolean selected = showVolumeAsUsdToggleButton.isSelected();
            showVolumeAsUsd(selected);
            user.getCookie().putAsBoolean(CookieKey.TRADE_STAT_CHART_USE_USD, selected);
            user.requestPersistence();
        });

        layout();
    }

    @Override
    protected void deactivate() {
        tabPaneSelectionModel.selectedIndexProperty().removeListener(selectedTabIndexListener);
        model.priceItems.removeListener(itemsChangeListener);
        toggleGroup.selectedToggleProperty().removeListener(timeUnitChangeListener);
        priceAxisY.widthProperty().removeListener(priceAxisYWidthListener);
        volumeAxisY.widthProperty().removeListener(volumeAxisYWidthListener);
        model.tradeStatisticsByCurrency.removeListener(tradeStatisticsByCurrencyListener);

        priceAxisY.labelProperty().unbind();
        priceColumnLabel.removeListener(priceColumnLabelListener);

        currencySelectionSubscriber.unsubscribe();

        sortedList.comparatorProperty().unbind();

        priceSeries.getData().clear();
        priceChart.getData().clear();

        exportLink.setOnAction(null);
        showVolumeAsUsdToggleButton.setOnAction(null);

        if (rootParent != null) {
            rootParent.heightProperty().removeListener(parentHeightListener);
        }
    }

    private void showVolumeAsUsd(Boolean showUsd) {
        volumeChart.setVisible(!showUsd);
        volumeChart.setManaged(!showUsd);
        volumeInUsdChart.setVisible(showUsd);
        volumeInUsdChart.setManaged(showUsd);
    }

    private void fillList() {
        long ts = System.currentTimeMillis();
        CompletableFuture.supplyAsync(() -> {
            return model.tradeStatisticsByCurrency.stream()
                    .map(tradeStatistics -> new TradeStatistics3ListItem(tradeStatistics,
                            coinFormatter,
                            model.showAllTradeCurrenciesProperty.get()))
                    .collect(Collectors.toCollection(FXCollections::observableArrayList));
        }).whenComplete((listItems, throwable) -> {
            log.debug(""Creating listItems took {} ms"", System.currentTimeMillis() - ts);

            long ts2 = System.currentTimeMillis();
            sortedList.comparatorProperty().unbind();
            // Sorting is slow as we have > 100k items. So we prefer to do it on the non UI thread.
            sortedList = new SortedList<>(listItems);
            sortedList.comparatorProperty().bind(tableView.comparatorProperty());
            log.debug(""Created sorted list took {} ms"", System.currentTimeMillis() - ts2);
            UserThread.execute(() -> {
                // When we attach the list to the table we need to be on the UI thread.
                tableView.setItems(sortedList);
            });
        });
    }

    private void exportToCsv() {
        ObservableList<TableColumn<TradeStatistics3ListItem, ?>> tableColumns = tableView.getColumns();
        int reportColumns = tableColumns.size() + 1;

        boolean showAllTradeCurrencies = model.showAllTradeCurrenciesProperty.get();
        CSVEntryConverter<TradeStatistics3ListItem> headerConverter = item -> {
            String[] columns = new String[reportColumns];
            columns[0] = ""Epoch time in ms"";
            for (int i = 0; i < tableColumns.size(); i++) {
                columns[(i + 1)] = ((AutoTooltipLabel) tableColumns.get(i).getGraphic()).getText();
            }
            return columns;
        };

        CSVEntryConverter<TradeStatistics3ListItem> contentConverter;
        if (showAllTradeCurrencies) {
            contentConverter = item -> {
                String[] columns = new String[reportColumns];
                columns[0] = String.valueOf(item.getDateAsLong());
                columns[1] = item.getDateString();
                columns[2] = item.getMarket();
                columns[3] = item.getPriceString();
                columns[4] = item.getAmountString();
                columns[5] = item.getVolumeString();
                columns[6] = item.getPaymentMethodString();
                return columns;
            };
        } else {
            contentConverter = item -> {
                String[] columns = new String[reportColumns];
                columns[0] = String.valueOf(item.getDateAsLong());
                columns[1] = item.getDateString();
                columns[2] = item.getPriceString();
                columns[3] = item.getAmountString();
                columns[4] = item.getVolumeString();
                columns[5] = item.getPaymentMethodString();
                return columns;
            };
        }

        String details = showAllTradeCurrencies ? ""all-markets"" : model.getCurrencyCode();
        GUIUtil.exportCSV(""trade-statistics-"" + details + "".csv"", headerConverter, contentConverter,
                new TradeStatistics3ListItem(null, coinFormatter, showAllTradeCurrencies),
                sortedList,
                (Stage) root.getScene().getWindow());
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Chart
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void createCharts() {
        priceSeries = new XYChart.Series<>();

        priceAxisX = new NumberAxis(0, MAX_TICKS + 1, 1);
        priceAxisX.setTickUnit(4);
        priceAxisX.setMinorTickCount(4);
        priceAxisX.setMinorTickVisible(true);
        priceAxisX.setForceZeroInRange(false);
        priceAxisX.setTickLabelFormatter(getTimeAxisStringConverter());
        addTickMarkLabelCssClass(priceAxisX, ""axis-tick-mark-text-node"");

        priceAxisY = new NumberAxis();
        priceAxisY.setForceZeroInRange(false);
        priceAxisY.setAutoRanging(true);
        priceAxisY.setTickLabelFormatter(new StringConverter<>() {
            @Override
            public String toString(Number object) {
                String currencyCode = model.getCurrencyCode();
                double doubleValue = (double) object;

                if (CurrencyUtil.isCryptoCurrency(currencyCode)) {
                    final double value = MathUtils.scaleDownByPowerOf10(doubleValue, 8);
                    return FormattingUtils.formatRoundedDoubleWithPrecision(value, 8).replaceFirst(""0{3}$"", """");
                } else {
                    DecimalFormat df = new DecimalFormat("",###"");
                    return df.format(Double.parseDouble(FormattingUtils.formatPrice(Price.valueOf(currencyCode, MathUtils.doubleToLong(doubleValue)))));
                }
            }

            @Override
            public Number fromString(String string) {
                return null;
            }
        });

        priceChart = new CandleStickChart(priceAxisX, priceAxisY, new StringConverter<>() {
            @Override
            public String toString(Number object) {
                if (CurrencyUtil.isCryptoCurrency(model.getCurrencyCode())) {
                    final double value = MathUtils.scaleDownByPowerOf10((long) object, 8);
                    return FormattingUtils.formatRoundedDoubleWithPrecision(value, 8);
                } else {
                    return FormattingUtils.formatPrice(Price.valueOf(model.getCurrencyCode(), (long) object));
                }
            }

            @Override
            public Number fromString(String string) {
                return null;
            }
        });
        priceChart.setId(""price-chart"");
        priceChart.setMinHeight(188);
        priceChart.setPrefHeight(188);
        priceChart.setMaxHeight(300);
        priceChart.setLegendVisible(false);
        priceChart.setPadding(new Insets(0));
        priceChart.setData(FXCollections.observableArrayList(List.of(priceSeries)));

        priceChartPane = new AnchorPane();
        priceChartPane.getStyleClass().add(""chart-pane"");

        AnchorPane.setTopAnchor(priceChart, 15d);
        AnchorPane.setBottomAnchor(priceChart, 10d);
        AnchorPane.setLeftAnchor(priceChart, 0d);
        AnchorPane.setRightAnchor(priceChart, 10d);

        priceChartPane.getChildren().add(priceChart);

        volumeAxisX = new NumberAxis(0, MAX_TICKS + 1, 1);
        volumeAxisY = new NumberAxis();
        volumeChart = getVolumeChart(volumeAxisX, volumeAxisY, volumeSeries, ""BTC"");

        volumeInUsdAxisX = new NumberAxis(0, MAX_TICKS + 1, 1);
        NumberAxis volumeInUsdAxisY = new NumberAxis();
        volumeInUsdChart = getVolumeChart(volumeInUsdAxisX, volumeInUsdAxisY, volumeInUsdSeries, ""USD"");
        volumeInUsdChart.setVisible(false);
        volumeInUsdChart.setManaged(false);

        showVolumeAsUsdToggleButton = new AutoTooltipSlideToggleButton();
        showVolumeAsUsdToggleButton.setText(Res.get(""market.trades.showVolumeInUSD""));
        showVolumeAsUsdToggleButton.setPadding(new Insets(-15, 0, 0, 10));

        VBox vBox = new VBox();
        AnchorPane.setTopAnchor(vBox, 15d);
        AnchorPane.setBottomAnchor(vBox, 10d);
        AnchorPane.setLeftAnchor(vBox, 0d);
        AnchorPane.setRightAnchor(vBox, 10d);
        vBox.getChildren().addAll(showVolumeAsUsdToggleButton, volumeChart, volumeInUsdChart);

        volumeChartPane = new AnchorPane();
        volumeChartPane.getStyleClass().add(""chart-pane"");
        volumeChartPane.getChildren().add(vBox);
    }

    private VolumeChart getVolumeChart(NumberAxis axisX,
                                       NumberAxis axisY,
                                       XYChart.Series<Number, Number> series,
                                       String currency) {
        axisX.setTickUnit(4);
        axisX.setMinorTickCount(4);
        axisX.setMinorTickVisible(true);
        axisX.setForceZeroInRange(false);
        axisX.setTickLabelFormatter(getTimeAxisStringConverter());
        addTickMarkLabelCssClass(axisX, ""axis-tick-mark-text-node"");

        axisY.setForceZeroInRange(true);
        axisY.setAutoRanging(true);
        axisY.setLabel(Res.get(""shared.volumeWithCur"", currency));
        axisY.setTickLabelFormatter(new StringConverter<>() {
            @Override
            public String toString(Number volume) {
                return currency.equals(""BTC"") ?
                        coinFormatter.formatCoin(Coin.valueOf(MathUtils.doubleToLong((double) volume))) :
                        VolumeUtil.formatLargeFiatWithUnitPostFix((double) volume, ""USD"");
            }

            @Override
            public Number fromString(String string) {
                return null;
            }
        });

        StringConverter<Number> btcStringConverter = new StringConverter<>() {
            @Override
            public String toString(Number volume) {
                return coinFormatter.formatCoinWithCode(Coin.valueOf((long) volume));
            }

            @Override
            public Number fromString(String string) {
                return null;
            }
        };
        VolumeChart volumeChart = new VolumeChart(axisX, axisY, btcStringConverter);
        volumeChart.setId(""volume-chart"");
        volumeChart.setData(FXCollections.observableArrayList(List.of(series)));
        volumeChart.setMinHeight(138);
        volumeChart.setPrefHeight(138);
        volumeChart.setMaxHeight(200);
        volumeChart.setLegendVisible(false);
        volumeChart.setPadding(new Insets(0));
        return volumeChart;
    }

    private void updateChartData() {
        volumeSeries.getData().setAll(model.volumeItems);
        volumeInUsdSeries.getData().setAll(model.volumeInUsdItems);

        // At price chart we need to set the priceSeries new otherwise the lines are not rendered correctly
        // TODO should be fixed in candle chart
        priceSeries.getData().clear();
        priceSeries = new XYChart.Series<>();
        priceSeries.getData().setAll(model.priceItems);
        priceChart.getData().clear();
        priceChart.setData(FXCollections.observableArrayList(List.of(priceSeries)));
    }

    private void layoutChart() {
        UserThread.execute(() -> {
            if (volumeAxisYWidth > priceAxisYWidth) {
                priceChart.setPadding(new Insets(0, 0, 0, volumeAxisYWidth - priceAxisYWidth));
                volumeChart.setPadding(new Insets(0, 0, 0, 0));
                volumeInUsdChart.setPadding(new Insets(0, 0, 0, 0));
            } else if (volumeAxisYWidth < priceAxisYWidth) {
                priceChart.setPadding(new Insets(0, 0, 0, 0));
                volumeChart.setPadding(new Insets(0, 0, 0, priceAxisYWidth - volumeAxisYWidth));
                volumeInUsdChart.setPadding(new Insets(0, 0, 0, priceAxisYWidth - volumeAxisYWidth));
            }
        });
    }

    @NotNull
    private StringConverter<Number> getTimeAxisStringConverter() {
        return new StringConverter<>() {
            @Override
            public String toString(Number object) {
                long index = MathUtils.doubleToLong((double) object);
                // The last tick is on the chart edge, it is not well spaced with
                // the previous tick and interferes with its label.
                if (MAX_TICKS + 1 == index) return """";

                long time = model.getTimeFromTickIndex(index);
                String fmt = """";
                switch (model.tickUnit) {
                    case YEAR:
                        fmt = ""yyyy"";
                        break;
                    case MONTH:
                        fmt = ""MMMyy"";
                        break;
                    case WEEK:
                    case DAY:
                        fmt = ""dd/MMM\nyyyy"";
                        break;
                    case HOUR:
                    case MINUTE_10:
                        fmt = ""HH:mm\ndd/MMM"";
                        break;
                    default:        // nothing here
                }

                return DisplayUtils.formatDateAxis(new Date(time), fmt);
            }

            @Override
            public Number fromString(String string) {
                return null;
            }
        };
    }

    private void addTickMarkLabelCssClass(NumberAxis axis, String cssClass) {
        // grab the axis tick mark label (text object) and add a CSS class.
        axis.getChildrenUnmodifiable().addListener((ListChangeListener<Node>) c -> {
            while (c.next()) {
                if (c.wasAdded()) {
                    for (Node mark : c.getAddedSubList()) {
                        if (mark instanceof Text) {
                            mark.getStyleClass().add(cssClass);
                        }
                    }
                }
            }
        });
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // CurrencyComboBox
    ///////////////////////////////////////////////////////////////////////////////////////////

    private HBox getToolBox() {

        final Tuple3<VBox, Label, AutocompleteComboBox<CurrencyListItem>> currencyComboBoxTuple = addTopLabelAutocompleteComboBox(
                Res.get(""shared.currency""));
        currencyComboBox = currencyComboBoxTuple.third;
        currencyComboBox.setCellFactory(GUIUtil.getCurrencyListItemCellFactory(Res.get(""shared.trade""),
                Res.get(""shared.trades""), model.preferences));

        Pane spacer = new Pane();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        toggleGroup = new ToggleGroup();
        ToggleButton year = getToggleButton(Res.get(""time.year""), TradesChartsViewModel.TickUnit.YEAR, toggleGroup, ""toggle-left"");
        ToggleButton month = getToggleButton(Res.get(""time.month""), TradesChartsViewModel.TickUnit.MONTH, toggleGroup, ""toggle-center"");
        ToggleButton week = getToggleButton(Res.get(""time.week""), TradesChartsViewModel.TickUnit.WEEK, toggleGroup, ""toggle-center"");
        ToggleButton day = getToggleButton(Res.get(""time.day""), TradesChartsViewModel.TickUnit.DAY, toggleGroup, ""toggle-center"");
        ToggleButton hour = getToggleButton(Res.get(""time.hour""), TradesChartsViewModel.TickUnit.HOUR, toggleGroup, ""toggle-center"");
        ToggleButton minute10 = getToggleButton(Res.get(""time.minute10""), TradesChartsViewModel.TickUnit.MINUTE_10, toggleGroup, ""toggle-right"");

        HBox toggleBox = new HBox();
        toggleBox.setSpacing(0);
        toggleBox.setAlignment(Pos.CENTER_LEFT);
        toggleBox.getChildren().addAll(year, month, week, day, hour, minute10);

        final Tuple2<Label, VBox> topLabelWithVBox = getTopLabelWithVBox(Res.get(""shared.interval""), toggleBox);

        HBox hBox = new HBox();
        hBox.setSpacing(0);
        hBox.setAlignment(Pos.CENTER_LEFT);
        hBox.getChildren().addAll(currencyComboBoxTuple.first, spacer, topLabelWithVBox.second);
        return hBox;
    }

    private ToggleButton getToggleButton(String label,
                                         TradesChartsViewModel.TickUnit tickUnit,
                                         ToggleGroup toggleGroup,
                                         String style) {
        ToggleButton toggleButton = new AutoTooltipToggleButton(label);
        toggleButton.setUserData(tickUnit);
        toggleButton.setToggleGroup(toggleGroup);
        toggleButton.setId(style);
        return toggleButton;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Table
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void createTable() {
        tableView = new TableView<>();
        VBox.setVgrow(tableView, Priority.ALWAYS);

        // date
        TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> dateColumn = new AutoTooltipTableColumn<>(Res.get(""shared.dateTime"")) {
            {
                setMinWidth(240);
                setMaxWidth(240);
            }
        };
        dateColumn.getStyleClass().addAll(""number-column"", ""first-column"");
        dateColumn.setCellValueFactory((tradeStatistics) -> new ReadOnlyObjectWrapper<>(tradeStatistics.getValue()));
        dateColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<TradeStatistics3ListItem, TradeStatistics3ListItem> call(
                            TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final TradeStatistics3ListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null) {
                                    setText(item.getDateString());
                                } else
                                    setText("""");
                            }
                        };
                    }
                });
        dateColumn.setComparator(Comparator.comparing(TradeStatistics3ListItem::getDate));
        tableView.getColumns().add(dateColumn);

        // market
        marketColumn = new AutoTooltipTableColumn<>(Res.get(""shared.market"")) {
            {
                setMinWidth(130);
                setMaxWidth(130);
            }
        };
        marketColumn.getStyleClass().add(""number-column"");
        marketColumn.setCellValueFactory((tradeStatistics) -> new ReadOnlyObjectWrapper<>(tradeStatistics.getValue()));
        marketColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<TradeStatistics3ListItem, TradeStatistics3ListItem> call(
                            TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final TradeStatistics3ListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getMarket());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        marketColumn.setComparator(Comparator.comparing(TradeStatistics3ListItem::getMarket));
        tableView.getColumns().add(marketColumn);

        // price
        priceColumn = new TableColumn<>();
        priceColumn.getStyleClass().add(""number-column"");
        priceColumn.setCellValueFactory((tradeStatistics) -> new ReadOnlyObjectWrapper<>(tradeStatistics.getValue()));
        priceColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<TradeStatistics3ListItem, TradeStatistics3ListItem> call(
                            TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final TradeStatistics3ListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getPriceString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        priceColumn.setComparator(Comparator.comparing(TradeStatistics3ListItem::getTradePrice));
        tableView.getColumns().add(priceColumn);

        // amount
        TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> amountColumn = new AutoTooltipTableColumn<>(Res.get(""shared.amountWithCur"", Res.getBaseCurrencyCode()));
        amountColumn.getStyleClass().add(""number-column"");
        amountColumn.setCellValueFactory((tradeStatistics) -> new ReadOnlyObjectWrapper<>(tradeStatistics.getValue()));
        amountColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<TradeStatistics3ListItem, TradeStatistics3ListItem> call(
                            TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final TradeStatistics3ListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null) {
                                    setGraphic(new ColoredDecimalPlacesWithZerosText(item.getAmountString(),
                                            GUIUtil.AMOUNT_DECIMALS_WITH_ZEROS));
                                } else
                                    setGraphic(null);
                            }
                        };
                    }
                });
        amountColumn.setComparator(Comparator.comparing(TradeStatistics3ListItem::getTradeAmount));
        tableView.getColumns().add(amountColumn);

        // volume
        volumeColumn = new TableColumn<>();
        volumeColumn.getStyleClass().add(""number-column"");
        volumeColumn.setCellValueFactory((tradeStatistics) -> new ReadOnlyObjectWrapper<>(tradeStatistics.getValue()));
        volumeColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<TradeStatistics3ListItem, TradeStatistics3ListItem> call(
                            TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final TradeStatistics3ListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getVolumeString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        volumeColumn.setComparator(Comparator.comparing(TradeStatistics3ListItem::getTradeVolume));
        tableView.getColumns().add(volumeColumn);

        // paymentMethod
        TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> paymentMethodColumn = new AutoTooltipTableColumn<>(Res.get(""shared.paymentMethod""));
        paymentMethodColumn.getStyleClass().add(""number-column"");
        paymentMethodColumn.setCellValueFactory((tradeStatistics) -> new ReadOnlyObjectWrapper<>(tradeStatistics.getValue()));
        paymentMethodColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<TradeStatistics3ListItem, TradeStatistics3ListItem> call(
                            TableColumn<TradeStatistics3ListItem, TradeStatistics3ListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final TradeStatistics3ListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setText(item.getPaymentMethodString());
                                else
                                    setText("""");
                            }
                        };
                    }
                });
        paymentMethodColumn.setComparator(Comparator.comparing(TradeStatistics3ListItem::getPaymentMethodString));
        tableView.getColumns().add(paymentMethodColumn);

        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        Label placeholder = new AutoTooltipLabel(Res.get(""table.placeholder.noData""));
        placeholder.setWrapText(true);
        tableView.setPlaceholder(placeholder);
        dateColumn.setSortType(TableColumn.SortType.DESCENDING);
        tableView.getSortOrder().add(dateColumn);
    }

    private void layout() {
        double available;
        if (root.getParent() instanceof Pane) {
            available = ((Pane) root.getParent()).getHeight();
        } else {
            available = root.getHeight();
        }
        if (available == 0) {
            UserThread.execute(this::layout);
            return;
        }

        available = available - volumeChartPane.getHeight() - toolBox.getHeight() - footer.getHeight() - 60;

        if (!model.showAllTradeCurrenciesProperty.get()) {
            double priceChartPaneHeight = priceChartPane.getHeight();
            if (priceChartPaneHeight == 0) {
                UserThread.execute(this::layout);
                return;
            }
            available -= priceChartPaneHeight;
        } else {
            // If rendering is not done we get the height which is smaller than the volumeChart max Height so we
            // delay to next render frame.
            // Using runAfter does not work well as filling the table list and creating the chart can be a bit slow and
            // its hard to estimate correct delay.
            if (volumeChartPane.getHeight() < volumeChart.getMaxHeight()) {
                UserThread.execute(this::layout);
                return;
            }
        }
        tableView.setPrefHeight(available);
    }
}",1,64 2000 777 587 2001 650 2002 60 2003 44 2004 62 123 773 809 657 704 2005 61 1500 59 809 587 2006 650 2007 60 2008 62 123 773 657 2009 60 2008 62 2010 59 2006 40 2009 60 2008 62 2010 41 123 823 46 2010 61 2010 59 125 64 2011 777 2012 2013 40 2008 2014 41 123 792 2014 340 2015 63 2014 46 2016 40 41 58 362 59 125 64 2011 777 2008 2017 40 2012 2018 41 123 688 40 2010 46 2019 40 41 46 2020 40 41 41 792 2021 59 688 40 2018 46 2020 40 41 41 792 2022 40 41 59 792 2010 46 2019 40 41 46 2023 40 41 46 2024 40 2014 45 62 2014 46 2025 40 41 46 2026 40 2018 41 41 46 2027 40 41 46 2028 40 2021 41 59 125 773 2008 2029 40 41 123 792 2010 46 2030 40 41 46 2031 40 1500 41 59 125 125 773 657 2032 2033 59 773 657 2034 2035 59 773 2036 2037 44 2038 59 773 2039 2040 59 773 2041 60 2008 62 2042 59 773 2043 60 2044 62 2045 59 773 2046 2047 59 773 2048 2049 59 773 2050 2051 59 773 2052 2053 44 2054 59 773 2048 2055 59 773 2056 2057 59 773 2058 2059 59 773 2060 2061 59 773 2062 60 2063 62 2064 59 773 2065 60 2044 44 2044 62 2066 44 2067 44 2068 59 773 2069 60 2044 62 2070 61 744 2069 60 62 40 2071 46 2072 40 41 41 59 773 2073 60 2074 62 2075 59 773 2073 60 2076 62 2077 59 773 2073 60 2076 62 2078 59 773 2073 60 2076 62 2079 59 773 2073 60 2076 62 2080 59 773 2073 60 2081 62 2082 59 773 2083 60 2084 46 2085 60 2076 44 2076 356 2086 59 773 2083 60 2087 62 2088 59 64 2089 40 362 41 773 2090 60 2091 62 2092 59 773 2093 2094 59 773 657 2095 2096 61 744 2097 40 41 59 773 2098 2099 44 2100 44 2101 44 2102 44 2103 59 773 2084 46 2104 60 2076 44 2076 62 2105 59 773 657 2084 46 2104 60 2076 44 2076 62 2106 61 744 2084 46 2104 60 62 40 41 59 773 657 2084 46 2104 60 2076 44 2076 62 2107 61 744 2084 46 2104 60 62 40 41 59 773 625 2108 59 773 625 2109 59 331 330 331 64 2089 40 362 41 64 2110 777 2001 40 2004 2111 44 2032 2033 44 64 2112 40 2113 46 2114 41 2034 2035 41 123 818 40 2111 41 59 823 46 2033 61 2033 59 823 46 2035 61 2035 59 125 64 2115 777 865 2116 40 41 123 2117 46 2118 40 2119 46 2120 41 59 2049 61 2121 40 41 59 2122 40 41 59 2123 40 41 59 2055 61 744 2048 40 41 59 2003 46 2124 40 2055 44 2125 46 2126 41 59 2050 2127 61 744 2050 40 41 59 2048 46 2128 40 2127 44 2125 46 2126 41 59 2059 61 744 2129 40 362 41 59 330 2059 46 2130 40 744 2131 40 45 1502 44 1500 44 45 1502 44 1503 41 41 59 2047 61 744 2046 40 2132 46 2133 40 362 41 41 59 2047 46 2130 40 744 2131 40 45 1502 44 1503 44 45 1502 44 1500 41 41 59 2055 46 2134 40 41 46 2135 40 2059 44 2127 44 2047 41 59 2117 46 2134 40 41 46 2135 40 2049 44 2053 44 2054 44 2045 44 2055 41 59 2075 61 40 2136 44 2137 44 2138 41 45 62 123 688 40 2138 340 2139 41 123 2111 46 2140 40 40 2004 46 2141 41 2138 46 2142 40 41 41 59 2099 46 2143 40 2144 40 41 41 59 2102 46 2143 40 2144 40 41 41 59 2103 46 2143 40 2144 40 41 41 59 125 125 59 2077 61 40 2136 44 2137 44 2138 41 45 62 123 2108 61 40 625 41 2138 59 2145 40 41 59 125 59 2078 61 40 2136 44 2137 44 2138 41 45 62 123 2109 61 40 625 41 2138 59 2146 40 41 59 125 59 2088 61 2147 45 62 123 2059 46 2148 40 2132 46 2133 40 362 44 2111 46 2149 46 2150 40 41 41 41 59 2151 40 41 59 125 59 2080 61 40 2136 44 2137 44 2138 41 45 62 2152 40 41 59 2082 61 40 2153 44 2154 44 2155 41 45 62 2066 46 2156 40 744 2129 40 2155 41 41 59 330 2086 61 2147 45 62 2157 46 2158 40 823 58 58 2159 41 59 2092 61 2160 46 2161 40 2111 46 2162 44 2111 46 2163 44 40 2164 44 2165 41 45 62 123 2040 46 2166 40 33 2164 41 59 2040 46 2167 40 33 2164 41 59 2066 46 2168 40 33 2164 41 59 688 40 2164 41 123 2067 46 2156 40 744 2129 40 2132 46 2133 40 362 41 41 41 59 2096 46 2169 40 2132 46 2133 40 362 41 41 59 688 40 33 2045 46 2170 40 41 46 2171 40 2068 41 41 2045 46 2170 40 41 46 2172 40 1501 44 2068 41 59 2037 46 2173 40 2037 46 2174 40 41 41 59 2038 46 2173 40 2038 46 2174 40 41 41 59 125 630 123 2037 46 2175 40 2037 46 2176 40 41 41 59 2038 46 2175 40 2038 46 2176 40 41 41 59 2105 46 2177 40 2165 46 2178 40 41 41 59 2081 2179 61 2165 46 2180 40 41 59 2067 46 2156 40 744 2129 40 2132 46 2133 40 362 44 2179 41 41 41 59 2096 46 2181 40 2182 46 2183 40 2179 41 41 59 2045 46 2184 40 41 46 2185 40 2068 41 59 125 2152 40 41 59 792 2186 59 125 41 59 125 64 2115 775 865 2187 40 41 123 2064 61 2188 46 2189 40 2190 44 2191 46 587 41 46 2192 40 41 59 2079 61 40 2193 44 2194 44 2195 41 45 62 2111 46 2196 40 40 704 41 2195 41 59 2111 46 2196 40 2064 46 2197 40 41 41 59 2064 46 2198 40 41 46 2199 40 2079 41 59 2042 46 2200 40 744 2006 40 2042 41 41 59 2042 46 2201 40 41 46 2202 40 41 46 2203 40 362 41 59 2042 46 2204 40 2111 46 2205 40 41 41 59 2042 46 2206 40 1502 41 59 688 40 2111 46 2207 46 2208 40 41 41 2042 46 2192 40 41 46 2209 40 2005 41 59 630 688 40 2111 46 2210 40 41 46 2211 40 41 41 2042 46 2192 40 41 46 2209 40 2111 46 2210 40 41 46 2208 40 41 41 59 2042 46 2201 40 41 46 2212 40 744 2006 40 2042 41 46 2213 40 2042 46 2192 40 41 46 2214 40 41 41 41 59 2042 46 2215 40 2216 45 62 123 688 40 2042 46 2201 40 41 46 2217 40 41 46 2218 40 41 41 2042 46 2192 40 41 46 2209 40 2005 41 59 2008 2219 61 2042 46 2192 40 41 46 2214 40 41 59 688 40 2219 340 2220 41 123 2111 46 2221 40 2219 46 2222 41 59 125 125 41 59 2061 46 2223 40 41 46 2208 40 2111 46 2224 46 2225 40 41 41 46 2226 40 2227 41 59 2111 46 2228 46 2199 40 2086 41 59 2061 46 2229 40 41 46 2199 40 2075 41 59 2100 46 2230 40 41 46 2199 40 2077 41 59 2101 46 2230 40 41 46 2199 40 2078 41 59 2111 46 2231 46 2199 40 2088 41 59 2100 46 2232 40 41 46 2233 40 2096 41 59 2096 46 2199 40 2082 41 59 2094 61 2092 46 2234 40 40 2193 44 2194 44 2195 41 45 62 123 125 41 59 570 2235 61 2111 46 2236 46 2237 40 41 59 2040 46 2238 40 2235 41 59 2037 46 2238 40 2235 41 59 2038 46 2238 40 2235 41 59 2099 46 2239 40 2240 40 41 41 59 2102 46 2239 40 2240 40 41 41 59 2103 46 2239 40 2240 40 41 41 59 2059 46 2212 40 2241 46 2208 40 362 44 2111 46 2231 46 2242 40 41 41 41 59 2047 46 2243 40 2216 45 62 2244 40 41 41 59 688 40 2190 46 2245 40 41 702 2050 41 123 2051 61 40 2050 41 2190 46 2245 40 41 59 2051 46 2246 40 41 46 2199 40 2080 41 59 125 2033 46 2247 40 41 46 2248 40 2249 46 2250 41 46 2251 40 2252 45 62 123 2057 46 2226 40 2252 41 59 2253 40 2252 41 59 125 41 59 2057 46 2243 40 2216 45 62 123 570 2254 61 2057 46 2255 40 41 59 2256 40 2254 41 59 2033 46 2247 40 41 46 2257 40 2249 46 2250 44 2254 41 59 2033 46 2258 40 41 59 125 41 59 2259 40 41 59 125 64 2115 775 865 2260 40 41 123 2064 46 2261 40 41 46 2262 40 2079 41 59 2111 46 2263 46 2262 40 2086 41 59 2061 46 2264 40 41 46 2262 40 2075 41 59 2100 46 2265 40 41 46 2262 40 2077 41 59 2101 46 2265 40 41 46 2262 40 2078 41 59 2111 46 2266 46 2262 40 2088 41 59 2100 46 2267 40 41 46 2268 40 41 59 2096 46 2262 40 2082 41 59 2094 46 2269 40 41 59 2070 46 2270 40 41 46 2268 40 41 59 2105 46 2271 40 41 46 2272 40 41 59 2040 46 2271 40 41 46 2272 40 41 59 2047 46 2273 40 2274 41 59 2057 46 2273 40 2274 41 59 688 40 2051 340 2274 41 123 2051 46 2275 40 41 46 2262 40 2080 41 59 125 125 773 865 2276 40 2277 2278 41 123 2037 46 2279 40 33 2278 41 59 2037 46 2280 40 33 2278 41 59 2038 46 2279 40 2278 41 59 2038 46 2280 40 2278 41 59 125 773 865 2281 40 41 123 726 2282 61 2283 46 2284 40 41 59 2285 46 2286 40 40 41 45 62 123 792 2111 46 2287 46 2288 40 41 46 2289 40 2290 45 62 744 2044 40 2290 44 2035 44 2111 46 2291 46 2292 40 41 41 41 46 2293 40 2294 46 2295 40 2071 58 58 2072 41 41 59 125 41 46 2296 40 40 2297 44 2298 41 45 62 123 2299 46 2300 40 362 44 2283 46 2284 40 41 45 2282 41 59 726 2301 61 2283 46 2284 40 41 59 2070 46 2302 40 41 46 2303 40 41 59 330 2070 61 744 2069 60 62 40 2297 41 59 2070 46 2302 40 41 46 2304 40 2045 46 2302 40 41 41 59 2299 46 2300 40 362 44 2283 46 2284 40 41 45 2301 41 59 2305 46 2306 40 40 41 45 62 123 330 2045 46 2307 40 2070 41 59 125 41 59 125 41 59 125 773 865 2308 40 41 123 2309 60 2065 60 2044 44 63 356 2310 61 2045 46 2311 40 41 59 704 2312 61 2310 46 2313 40 41 43 1501 59 570 2314 61 2111 46 2315 46 2316 40 41 59 2317 60 2044 62 2318 61 2319 45 62 123 2081 91 93 2320 61 744 2081 91 2312 93 59 2320 91 1500 93 61 362 59 664 40 704 2321 61 1500 59 2321 60 2310 46 2313 40 41 59 2321 349 41 123 2320 91 40 2321 43 1501 41 93 61 40 40 2322 41 2310 46 2316 40 2321 41 46 2323 40 41 41 46 2324 40 41 59 125 792 2320 59 125 59 2317 60 2044 62 2325 59 688 40 2314 41 123 2325 61 2319 45 62 123 2081 91 93 2326 61 744 2081 91 2312 93 59 2326 91 1500 93 61 2081 46 2327 40 2319 46 2328 40 41 41 59 2326 91 1501 93 61 2319 46 2329 40 41 59 2326 91 1502 93 61 2319 46 2330 40 41 59 2326 91 1502 93 61 2319 46 2331 40 41 59 2326 91 1502 93 61 2319 46 2332 40 41 59 2326 91 1502 93 61 2319 46 2333 40 41 59 2326 91 1502 93 61 2319 46 2334 40 41 59 792 2326 59 125 59 125 630 123 2325 61 2319 45 62 123 2081 91 93 2335 61 744 2081 91 2312 93 59 2335 91 1500 93 61 2081 46 2336 40 2319 46 2337 40 41 41 59 2335 91 1501 93 61 2319 46 2338 40 41 59 2335 91 1502 93 61 2319 46 2339 40 41 59 2335 91 1502 93 61 2319 46 2340 40 41 59 2335 91 1502 93 61 2319 46 2341 40 41 59 2335 91 1502 93 61 2319 46 2342 40 41 59 792 2335 59 125 59 125 2081 2343 61 2314 63 362 58 2111 46 2344 40 41 59 2345 46 2346 40 362 43 2343 43 362 44 2318 44 2325 44 744 2044 40 2347 44 2035 44 2314 41 44 2070 44 40 2348 41 2349 46 2350 40 41 46 2351 40 41 41 59 125 331 330 331 773 865 2352 40 41 123 2105 61 744 2084 46 2104 60 62 40 41 59 2099 61 744 2098 40 1500 44 2353 43 1501 44 1501 41 59 2099 46 2354 40 1502 41 59 2099 46 2355 40 1502 41 59 2099 46 2356 40 2357 41 59 2099 46 2358 40 2359 41 59 2099 46 2360 40 2361 40 41 41 59 2362 40 2099 44 362 41 59 2100 61 744 2098 40 41 59 2100 46 2358 40 2359 41 59 2100 46 2363 40 2357 41 59 2100 46 2360 40 744 2007 60 62 40 41 123 64 2115 777 2081 2364 40 2076 2365 41 123 2081 2366 61 2111 46 2367 40 41 59 625 2368 61 40 625 41 2365 59 688 40 2369 46 2370 40 2366 41 41 123 657 625 2371 61 2372 46 2373 40 2368 44 1502 41 59 792 2113 46 2374 40 2371 44 1502 41 46 2375 40 362 44 362 41 59 125 630 123 2376 2377 61 744 2376 40 362 41 59 792 2377 46 2378 40 2379 46 2380 40 2113 46 2381 40 2382 46 2383 40 2366 44 2384 46 2385 40 2368 41 41 41 41 41 59 125 125 64 2115 777 2076 2386 40 2081 2387 41 123 792 2388 59 125 125 41 59 2040 61 744 2039 40 2099 44 2100 44 744 2007 60 62 40 41 123 64 2115 777 2081 2389 40 2076 2390 41 123 688 40 2391 46 2392 40 2111 46 2393 40 41 41 41 123 657 625 2394 61 2395 46 2396 40 40 726 41 2390 44 1502 41 59 792 2113 46 2397 40 2394 44 1502 41 59 125 630 123 792 2113 46 2398 40 2399 46 2400 40 2111 46 2393 40 41 44 40 726 41 2390 41 41 59 125 125 64 2115 777 2076 2401 40 2081 2402 41 123 792 2403 59 125 125 41 59 2040 46 2404 40 362 41 59 2040 46 2405 40 1504 41 59 2040 46 2406 40 1504 41 59 2040 46 2407 40 1504 41 59 2040 46 2408 40 2359 41 59 2040 46 2409 40 744 2410 40 1500 41 41 59 2040 46 2411 40 2071 46 2072 40 2412 46 2413 40 2105 41 41 41 59 2053 61 744 2052 40 41 59 2053 46 2414 40 41 46 2415 40 362 41 59 2052 46 2416 40 2040 44 1503 41 59 2052 46 2417 40 2040 44 1502 41 59 2052 46 2418 40 2040 44 1500 41 59 2052 46 2419 40 2040 44 1502 41 59 2053 46 2420 40 41 46 2415 40 2040 41 59 2102 61 744 2098 40 1500 44 2353 43 1501 44 1501 41 59 2101 61 744 2098 40 41 59 2037 61 2421 40 2102 44 2101 44 2106 44 362 41 59 2103 61 744 2098 40 1500 44 2353 43 1501 44 1501 41 59 2098 2422 61 744 2098 40 41 59 2038 61 2421 40 2103 44 2422 44 2107 44 362 41 59 2038 46 2423 40 2359 41 59 2038 46 2424 40 2359 41 59 2057 61 744 2056 40 41 59 2057 46 2425 40 2426 46 2427 40 362 41 41 59 2057 46 2409 40 744 2410 40 45 1503 44 1500 44 1500 44 1502 41 41 59 2003 2428 61 744 2003 40 41 59 2052 46 2416 40 2428 44 1503 41 59 2052 46 2417 40 2428 44 1502 41 59 2052 46 2418 40 2428 44 1500 41 59 2052 46 2419 40 2428 44 1502 41 59 2428 46 2420 40 41 46 2429 40 2057 44 2037 44 2038 41 59 2054 61 744 2052 40 41 59 2054 46 2414 40 41 46 2415 40 362 41 59 2054 46 2420 40 41 46 2415 40 2428 41 59 125 773 2036 2430 40 2098 2431 44 2098 2432 44 2084 46 2104 60 2076 44 2076 62 2433 44 2081 2434 41 123 2431 46 2435 40 1502 41 59 2431 46 2436 40 1502 41 59 2431 46 2437 40 2438 41 59 2431 46 2439 40 2440 41 59 2431 46 2441 40 2442 40 41 41 59 2443 40 2431 44 362 41 59 2432 46 2439 40 2438 41 59 2432 46 2444 40 2438 41 59 2432 46 2445 40 2446 46 2447 40 362 44 2434 41 41 59 2432 46 2441 40 744 2007 60 62 40 41 123 64 2115 777 2081 2448 40 2076 2449 41 123 792 2434 46 2450 40 362 41 63 2035 46 2451 40 2452 46 2453 40 2454 46 2455 40 40 625 41 2449 41 41 41 58 2456 46 2457 40 40 625 41 2449 44 362 41 59 125 64 2115 777 2076 2458 40 2081 2459 41 123 792 2460 59 125 125 41 59 2007 60 2076 62 2461 61 744 2007 60 62 40 41 123 64 2115 777 2081 2462 40 2076 2463 41 123 792 2035 46 2464 40 2465 46 2466 40 40 726 41 2463 41 41 59 125 64 2115 777 2076 2467 40 2081 2468 41 123 792 2469 59 125 125 59 2036 2037 61 744 2036 40 2431 44 2432 44 2461 41 59 2037 46 2470 40 362 41 59 2037 46 2471 40 2071 46 2072 40 2472 46 2473 40 2433 41 41 41 59 2037 46 2474 40 1504 41 59 2037 46 2475 40 1504 41 59 2037 46 2476 40 1504 41 59 2037 46 2477 40 2440 41 59 2037 46 2478 40 744 2479 40 1500 41 41 59 792 2037 59 125 773 865 2480 40 41 123 2106 46 2481 40 41 46 2482 40 2111 46 2483 41 59 2107 46 2481 40 41 46 2482 40 2111 46 2484 41 59 330 330 2105 46 2481 40 41 46 2485 40 41 59 2105 61 744 2084 46 2104 60 62 40 41 59 2105 46 2481 40 41 46 2482 40 2111 46 2486 41 59 2040 46 2481 40 41 46 2485 40 41 59 2040 46 2487 40 2071 46 2072 40 2488 46 2489 40 2105 41 41 41 59 125 773 865 2490 40 41 123 2491 46 2492 40 40 41 45 62 123 688 40 2109 62 2108 41 123 2040 46 2493 40 744 2494 40 1500 44 1500 44 1500 44 2109 45 2108 41 41 59 2037 46 2493 40 744 2494 40 1500 44 1500 44 1500 44 1500 41 41 59 2038 46 2493 40 744 2494 40 1500 44 1500 44 1500 44 1500 41 41 59 125 630 688 40 2109 60 2108 41 123 2040 46 2495 40 744 2496 40 1500 44 1500 44 1500 44 1500 41 41 59 2037 46 2495 40 744 2496 40 1500 44 1500 44 1500 44 2108 45 2109 41 41 59 2038 46 2495 40 744 2496 40 1500 44 1500 44 1500 44 2108 45 2109 41 41 59 125 125 41 59 125 64 2497 773 2007 60 2076 62 2498 40 41 123 792 744 2007 60 62 40 41 123 64 2115 777 2081 2499 40 2076 2500 41 123 726 2501 61 2502 46 2503 40 40 625 41 2500 41 59 330 330 688 40 2504 43 1501 323 2501 41 792 362 59 726 2505 61 2111 46 2506 40 2501 41 59 2081 2507 61 362 59 819 40 2111 46 2508 41 123 579 2509 58 2507 61 362 59 572 59 579 2510 58 2507 61 362 59 572 59 579 2511 58 579 2512 58 2507 61 362 59 572 59 579 2513 58 579 2514 58 2507 61 362 59 572 59 613 58 330 125 792 2515 46 2516 40 744 2517 40 2505 41 44 2507 41 59 125 64 2115 777 2076 2518 40 2081 2519 41 123 792 2520 59 125 125 59 125 773 865 2521 40 2098 2522 44 2081 2523 41 123 330 2522 46 2524 40 41 46 2525 40 40 2083 60 2526 62 41 2527 45 62 123 870 40 2527 46 2528 40 41 41 123 688 40 2527 46 2529 40 41 41 123 664 40 2526 2530 58 2527 46 2531 40 41 41 123 688 40 2530 702 2532 41 123 2530 46 2533 40 41 46 2534 40 2523 41 59 125 125 125 125 125 41 59 125 331 330 331 773 2048 2535 40 41 123 657 2536 60 2003 44 2058 44 2041 60 2008 356 2537 61 2538 40 2539 46 2540 40 362 41 41 59 2042 61 2537 46 2541 59 2042 46 2542 40 2543 46 2544 40 2539 46 2540 40 362 41 44 2539 46 2540 40 362 41 44 2111 46 2545 41 41 59 2050 2546 61 744 2050 40 41 59 2048 46 2547 40 2546 44 2548 46 2549 41 59 2061 61 744 2060 40 41 59 2550 2551 61 2552 40 2539 46 2540 40 362 41 44 2004 46 2553 46 2554 44 2061 44 362 41 59 2550 2555 61 2552 40 2539 46 2540 40 362 41 44 2004 46 2553 46 2556 44 2061 44 362 41 59 2550 2557 61 2552 40 2539 46 2540 40 362 41 44 2004 46 2553 46 2558 44 2061 44 362 41 59 2550 2559 61 2552 40 2539 46 2540 40 362 41 44 2004 46 2553 46 2560 44 2061 44 362 41 59 2550 2561 61 2552 40 2539 46 2540 40 362 41 44 2004 46 2553 46 2562 44 2061 44 362 41 59 2550 2563 61 2552 40 2539 46 2540 40 362 41 44 2004 46 2553 46 2564 44 2061 44 362 41 59 2048 2565 61 744 2048 40 41 59 2565 46 2566 40 1500 41 59 2565 46 2567 40 2568 46 2569 41 59 2565 46 2570 40 41 46 2571 40 2551 44 2555 44 2557 44 2559 44 2561 44 2563 41 59 657 2572 60 2058 44 2003 62 2573 61 2574 40 2539 46 2540 40 362 41 44 2565 41 59 2048 2575 61 744 2048 40 41 59 2575 46 2566 40 1500 41 59 2575 46 2567 40 2568 46 2569 41 59 2575 46 2570 40 41 46 2571 40 2537 46 2576 44 2546 44 2573 46 2577 41 59 792 2575 59 125 773 2578 2579 40 2081 2580 44 2004 46 2581 2582 44 2060 2061 44 2081 2583 41 123 2578 2584 61 744 2585 40 2580 41 59 2584 46 2586 40 2582 41 59 2584 46 2587 40 2061 41 59 2584 46 2588 40 2583 41 59 792 2584 59 125 331 330 331 773 865 2589 40 41 123 2045 61 744 2043 60 62 40 41 59 2003 46 2590 40 2045 44 2591 46 2592 41 59 330 2065 60 2044 44 2044 62 2593 61 744 2594 60 62 40 2595 46 2596 40 362 41 41 123 123 2597 40 1504 41 59 2598 40 1504 41 59 125 125 59 2593 46 2599 40 41 46 2600 40 362 44 362 41 59 2593 46 2601 40 40 2602 41 45 62 744 2603 60 62 40 2602 46 2604 40 41 41 41 59 2593 46 2605 40 744 2606 60 62 40 41 123 64 2115 777 2607 60 2044 44 2044 62 2608 40 2065 60 2044 44 2044 62 2609 41 123 792 744 2607 60 62 40 41 123 64 2115 777 865 2610 40 657 2044 2611 44 570 2612 41 123 818 46 2610 40 2611 44 2612 41 59 688 40 2611 340 2613 41 123 2614 40 2611 46 2615 40 41 41 59 125 630 2616 40 362 41 59 125 125 59 125 125 41 59 2593 46 2617 40 2618 46 2619 40 2044 58 58 2620 41 41 59 2045 46 2621 40 41 46 2622 40 2593 41 59 330 2068 61 744 2594 60 62 40 2595 46 2596 40 362 41 41 123 123 2623 40 1504 41 59 2624 40 1504 41 59 125 125 59 2068 46 2599 40 41 46 2622 40 362 41 59 2068 46 2601 40 40 2602 41 45 62 744 2603 60 62 40 2602 46 2604 40 41 41 41 59 2068 46 2605 40 744 2606 60 62 40 41 123 64 2115 777 2625 60 2044 44 2044 62 2626 40 2065 60 2044 44 2044 62 2627 41 123 792 744 2625 60 62 40 41 123 64 2115 777 865 2628 40 657 2044 2629 44 570 2630 41 123 818 46 2628 40 2629 44 2630 41 59 688 40 2629 340 2631 41 2632 40 2629 46 2633 40 41 41 59 630 2632 40 362 41 59 125 125 59 125 125 41 59 2068 46 2617 40 2618 46 2619 40 2044 58 58 2634 41 41 59 2045 46 2621 40 41 46 2622 40 2068 41 59 330 2066 61 744 2065 60 62 40 41 59 2066 46 2599 40 41 46 2622 40 362 41 59 2066 46 2601 40 40 2602 41 45 62 744 2603 60 62 40 2602 46 2604 40 41 41 41 59 2066 46 2605 40 744 2606 60 62 40 41 123 64 2115 777 2635 60 2044 44 2044 62 2636 40 2065 60 2044 44 2044 62 2637 41 123 792 744 2635 60 62 40 41 123 64 2115 777 865 2638 40 657 2044 2639 44 570 2640 41 123 818 46 2638 40 2639 44 2640 41 59 688 40 2639 340 2641 41 2642 40 2639 46 2643 40 41 41 59 630 2642 40 362 41 59 125 125 59 125 125 41 59 2066 46 2617 40 2618 46 2619 40 2044 58 58 2644 41 41 59 2045 46 2621 40 41 46 2622 40 2066 41 59 330 2065 60 2044 44 2044 62 2645 61 744 2594 60 62 40 2595 46 2596 40 362 44 2595 46 2646 40 41 41 41 59 2645 46 2599 40 41 46 2622 40 362 41 59 2645 46 2601 40 40 2602 41 45 62 744 2603 60 62 40 2602 46 2604 40 41 41 41 59 2645 46 2605 40 744 2606 60 62 40 41 123 64 2115 777 2647 60 2044 44 2044 62 2648 40 2065 60 2044 44 2044 62 2649 41 123 792 744 2647 60 62 40 41 123 64 2115 777 865 2650 40 657 2044 2651 44 570 2652 41 123 818 46 2650 40 2651 44 2652 41 59 688 40 2651 340 2653 41 123 2654 40 744 2655 40 2651 46 2656 40 41 44 2657 46 2658 41 41 59 125 630 2659 40 2653 41 59 125 125 59 125 125 41 59 2645 46 2617 40 2618 46 2619 40 2044 58 58 2660 41 41 59 2045 46 2621 40 41 46 2622 40 2645 41 59 330 2067 61 744 2065 60 62 40 41 59 2067 46 2599 40 41 46 2622 40 362 41 59 2067 46 2601 40 40 2602 41 45 62 744 2603 60 62 40 2602 46 2604 40 41 41 41 59 2067 46 2605 40 744 2606 60 62 40 41 123 64 2115 777 2661 60 2044 44 2044 62 2662 40 2065 60 2044 44 2044 62 2663 41 123 792 744 2661 60 62 40 41 123 64 2115 777 865 2664 40 657 2044 2665 44 570 2666 41 123 818 46 2664 40 2665 44 2666 41 59 688 40 2665 340 2667 41 2668 40 2665 46 2669 40 41 41 59 630 2668 40 362 41 59 125 125 59 125 125 41 59 2067 46 2617 40 2618 46 2619 40 2044 58 58 2670 41 41 59 2045 46 2621 40 41 46 2622 40 2067 41 59 330 2065 60 2044 44 2044 62 2671 61 744 2594 60 62 40 2595 46 2596 40 362 41 41 59 2671 46 2599 40 41 46 2622 40 362 41 59 2671 46 2601 40 40 2602 41 45 62 744 2603 60 62 40 2602 46 2604 40 41 41 41 59 2671 46 2605 40 744 2606 60 62 40 41 123 64 2115 777 2672 60 2044 44 2044 62 2673 40 2065 60 2044 44 2044 62 2674 41 123 792 744 2672 60 62 40 41 123 64 2115 777 865 2675 40 657 2044 2676 44 570 2677 41 123 818 46 2675 40 2676 44 2677 41 59 688 40 2676 340 2678 41 2679 40 2676 46 2680 40 41 41 59 630 2679 40 362 41 59 125 125 59 125 125 41 59 2671 46 2617 40 2618 46 2619 40 2044 58 58 2681 41 41 59 2045 46 2621 40 41 46 2622 40 2671 41 59 2045 46 2682 40 2043 46 2683 41 59 2058 2684 61 744 2685 40 2595 46 2596 40 362 41 41 59 2684 46 2686 40 2687 41 59 2045 46 2688 40 2684 41 59 2593 46 2689 40 2065 46 2690 46 2691 41 59 2045 46 2692 40 41 46 2622 40 2593 41 59 125 773 865 2693 40 41 123 625 2694 59 688 40 2695 46 2696 40 41 702 2050 41 123 2694 61 40 40 2050 41 2695 46 2696 40 41 41 46 2697 40 41 59 125 630 123 2694 61 2695 46 2698 40 41 59 125 688 40 2694 323 1500 41 123 2699 46 2700 40 823 58 58 2693 41 59 792 59 125 2694 61 2694 45 2054 46 2701 40 41 45 2049 46 2701 40 41 45 2055 46 2701 40 41 45 1503 59 688 40 33 2111 46 2702 46 2703 40 41 41 123 625 2704 61 2053 46 2701 40 41 59 688 40 2704 323 1500 41 123 2705 46 2706 40 823 58 58 2693 41 59 792 59 125 2694 337 2704 59 125 630 123 330 330 330 330 688 40 2054 46 2701 40 41 60 2037 46 2707 40 41 41 123 2708 46 2709 40 823 58 58 2693 41 59 792 59 125 125 2045 46 2710 40 2694 41 59 125 125 ,"{'AvgLine': 42, 'CountLine': 834, 'CountStmt': 505, 'MaxNesting': 4, 'AvgLineCode': 37, 'AvgEssential': 1, 'AvgLineBlank': 4, 'CountStmtExe': 418, 'MaxEssential': 5, 'SumEssential': 48, 'AvgCyclomatic': 1, 'CountLineCode': 693, 'CountStmtDecl': 129, 'MaxCyclomatic': 6, 'SumCyclomatic': 67, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 111, 'CountSemicolon': 425, 'CountDeclMethod': 17, 'CountLineCodeExe': 547, 'CountLineComment': 32, 'CountClassCoupled': 69, 'CountClassDerived': 0, 'CountLineCodeDecl': 127, 'CountDeclMethodAll': 32, 'MaxInheritanceTree': 5, 'RatioCommentToCode': '0.05', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 6, 'SumCyclomaticStrict': 67, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 86, 'SumCyclomaticModified': 67, 'CountDeclClassVariable': 1, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 13, 'CountDeclInstanceMethod': 17, 'CountDeclMethodProtected': 2, 'CountClassCoupledModified': 69, 'CountDeclInstanceVariable': 42, 'PercentLackOfCohesionModified': 83}"
3502,Java,"public class TradeDetailsWindow extends Overlay<TradeDetailsWindow> {
    protected static final Logger log = LoggerFactory.getLogger(TradeDetailsWindow.class);

    private final CoinFormatter formatter;
    private final ArbitrationManager arbitrationManager;
    private final TradeManager tradeManager;
    private final BtcWalletService btcWalletService;
    private final AccountAgeWitnessService accountAgeWitnessService;
    private Trade trade;
    private ChangeListener<Number> changeListener;
    private TextArea textArea;
    private String buyersAccountAge;
    private String sellersAccountAge;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Public API
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public TradeDetailsWindow(@Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter formatter,
                              ArbitrationManager arbitrationManager,
                              TradeManager tradeManager,
                              BtcWalletService btcWalletService,
                              AccountAgeWitnessService accountAgeWitnessService) {
        this.formatter = formatter;
        this.arbitrationManager = arbitrationManager;
        this.tradeManager = tradeManager;
        this.btcWalletService = btcWalletService;
        this.accountAgeWitnessService = accountAgeWitnessService;
        type = Type.Confirmation;
    }

    public void show(Trade trade) {
        this.trade = trade;

        rowIndex = -1;
        width = 918;
        createGridPane();
        addContent();
        display();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Protected
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    protected void cleanup() {
        if (textArea != null)
            textArea.scrollTopProperty().addListener(changeListener);
    }

    @Override
    protected void createGridPane() {
        super.createGridPane();
        gridPane.setPadding(new Insets(35, 40, 30, 40));
        gridPane.getStyleClass().add(""grid-pane"");
    }

    private void addContent() {
        Offer offer = trade.getOffer();
        Contract contract = trade.getContract();

        int rows = 5;
        addTitledGroupBg(gridPane, ++rowIndex, rows, Res.get(""tradeDetailsWindow.headline""));

        boolean myOffer = tradeManager.isMyOffer(offer);
        String fiatDirectionInfo;
        String btcDirectionInfo;
        String toReceive = "" "" + Res.get(""shared.toReceive"");
        String toSpend = "" "" + Res.get(""shared.toSpend"");
        String offerType = Res.get(""shared.offerType"");
        if (tradeManager.isBuyer(offer)) {
            addConfirmationLabelTextField(gridPane, rowIndex, offerType,
                    DisplayUtils.getDirectionForBuyer(myOffer, offer.getCurrencyCode()), Layout.TWICE_FIRST_ROW_DISTANCE);
            fiatDirectionInfo = toSpend;
            btcDirectionInfo = toReceive;
        } else {
            addConfirmationLabelTextField(gridPane, rowIndex, offerType,
                    DisplayUtils.getDirectionForSeller(myOffer, offer.getCurrencyCode()), Layout.TWICE_FIRST_ROW_DISTANCE);
            fiatDirectionInfo = toReceive;
            btcDirectionInfo = toSpend;
        }

        addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""shared.btcAmount"") + btcDirectionInfo,
                formatter.formatCoinWithCode(trade.getAmount()));
        addConfirmationLabelTextField(gridPane, ++rowIndex,
                VolumeUtil.formatVolumeLabel(offer.getCurrencyCode()) + fiatDirectionInfo,
                VolumeUtil.formatVolumeWithCode(trade.getVolume()));
        addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""shared.tradePrice""),
                FormattingUtils.formatPrice(trade.getPrice()));
        String paymentMethodText = Res.get(offer.getPaymentMethod().getId());
        addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""shared.paymentMethod""), paymentMethodText);

        // second group
        rows = 7;
        PaymentAccountPayload buyerPaymentAccountPayload = null;
        PaymentAccountPayload sellerPaymentAccountPayload = null;

        if (contract != null) {
            rows++;

            buyerPaymentAccountPayload = contract.getBuyerPaymentAccountPayload();
            sellerPaymentAccountPayload = contract.getSellerPaymentAccountPayload();
            if (buyerPaymentAccountPayload != null)
                rows++;

            if (sellerPaymentAccountPayload != null)
                rows++;

            if (buyerPaymentAccountPayload == null && sellerPaymentAccountPayload == null)
                rows++;
        }

        boolean showXmrProofResult = checkNotNull(trade.getOffer()).getCurrencyCode().equals(""XMR"") &&
                trade.getAssetTxProofResult() != null &&
                trade.getAssetTxProofResult() != AssetTxProofResult.UNDEFINED;

        if (trade.getPayoutTx() != null)
            rows++;
        boolean showDisputedTx = arbitrationManager.findOwnDispute(trade.getId()).isPresent() &&
                arbitrationManager.findOwnDispute(trade.getId()).get().getDisputePayoutTxId() != null;
        if (showDisputedTx)
            rows++;
        if (trade.hasFailed())
            rows += 2;
        if (trade.getTradingPeerNodeAddress() != null)
            rows++;
        if (showXmrProofResult)
            rows++;

        addTitledGroupBg(gridPane, ++rowIndex, rows, Res.get(""shared.details""), Layout.GROUP_DISTANCE);
        addConfirmationLabelTextField(gridPane, rowIndex, Res.get(""shared.tradeId""),
                trade.getId(), Layout.TWICE_FIRST_ROW_AND_GROUP_DISTANCE);
        addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""tradeDetailsWindow.tradeDate""),
                DisplayUtils.formatDateTime(trade.getDate()));
        String securityDeposit = Res.getWithColAndCap(""shared.buyer"") +
                "" "" +
                formatter.formatCoinWithCode(offer.getBuyerSecurityDeposit()) +
                "" / "" +
                Res.getWithColAndCap(""shared.seller"") +
                "" "" +
                formatter.formatCoinWithCode(offer.getSellerSecurityDeposit());
        addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""shared.securityDeposit""), securityDeposit);

        String txFee = Res.get(""shared.makerTxFee"", formatter.formatCoinWithCode(offer.getTxFee())) +
                "" / "" +
                Res.get(""shared.takerTxFee"", formatter.formatCoinWithCode(trade.getTradeTxFee().multiply(3)));
        addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""tradeDetailsWindow.txFee""), txFee);

        NodeAddress arbitratorNodeAddress = trade.getArbitratorNodeAddress();
        NodeAddress mediatorNodeAddress = trade.getMediatorNodeAddress();
        if (arbitratorNodeAddress != null && mediatorNodeAddress != null) {
            addConfirmationLabelTextField(gridPane, ++rowIndex,
                    Res.get(""tradeDetailsWindow.agentAddresses""),
                    arbitratorNodeAddress.getFullAddress() + "" / "" + mediatorNodeAddress.getFullAddress());
        }

        if (trade.getTradingPeerNodeAddress() != null)
            addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""tradeDetailsWindow.tradingPeersOnion""),
                    trade.getTradingPeerNodeAddress().getFullAddress());

        if (showXmrProofResult) {
            // As the window is already overloaded we replace the tradingPeersPubKeyHash field with the auto-conf state
            // if XMR is the currency
            addConfirmationLabelTextField(gridPane, ++rowIndex,
                    Res.get(""portfolio.pending.step3_seller.autoConf.status.label""),
                    GUIUtil.getProofResultAsString(trade.getAssetTxProofResult()));
        }

        if (contract != null) {
            if (buyerPaymentAccountPayload != null) {
                String paymentDetails = buyerPaymentAccountPayload.getPaymentDetails();
                long age = accountAgeWitnessService.getAccountAge(buyerPaymentAccountPayload, contract.getBuyerPubKeyRing());
                buyersAccountAge = CurrencyUtil.isFiatCurrency(offer.getCurrencyCode()) ?
                        age > -1 ? Res.get(""peerInfoIcon.tooltip.age"", DisplayUtils.formatAccountAge(age)) :
                                Res.get(""peerInfoIcon.tooltip.unknownAge"") :
                        """";

                String postFix = buyersAccountAge.isEmpty() ? """" : "" / "" + buyersAccountAge;
                addConfirmationLabelTextField(gridPane, ++rowIndex,
                        Res.get(""shared.paymentDetails"", Res.get(""shared.buyer"")),
                        paymentDetails + postFix).second.setTooltip(new Tooltip(paymentDetails + postFix));
            }
            if (sellerPaymentAccountPayload != null) {
                String paymentDetails = sellerPaymentAccountPayload.getPaymentDetails();
                long age = accountAgeWitnessService.getAccountAge(sellerPaymentAccountPayload, contract.getSellerPubKeyRing());
                sellersAccountAge = CurrencyUtil.isFiatCurrency(offer.getCurrencyCode()) ?
                        age > -1 ? Res.get(""peerInfoIcon.tooltip.age"", DisplayUtils.formatAccountAge(age)) :
                                Res.get(""peerInfoIcon.tooltip.unknownAge"") :
                        """";
                String postFix = sellersAccountAge.isEmpty() ? """" : "" / "" + sellersAccountAge;
                addConfirmationLabelTextField(gridPane, ++rowIndex,
                        Res.get(""shared.paymentDetails"", Res.get(""shared.seller"")),
                        paymentDetails + postFix).second.setTooltip(new Tooltip(paymentDetails + postFix));
            }
            if (buyerPaymentAccountPayload == null && sellerPaymentAccountPayload == null)
                addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""shared.paymentMethod""),
                        Res.get(contract.getPaymentMethodId()));
        }

        addLabelTxIdTextField(gridPane, ++rowIndex, Res.get(""shared.makerFeeTxId""), offer.getOfferFeePaymentTxId());
        addLabelTxIdTextField(gridPane, ++rowIndex, Res.get(""shared.takerFeeTxId""), trade.getTakerFeeTxId());

        String depositTxId = trade.getDepositTxId();
        Transaction depositTx = trade.getDepositTx();
        String depositTxIdFromTx = depositTx != null ? depositTx.getTxId().toString() : null;
        TxIdTextField depositTxIdTextField = addLabelTxIdTextField(gridPane, ++rowIndex,
                Res.get(""shared.depositTransactionId""), depositTxId).second;
        if (depositTxId == null || !depositTxId.equals(depositTxIdFromTx)) {
            depositTxIdTextField.getTextField().setId(""address-text-field-error"");
            log.error(""trade.getDepositTxId() and trade.getDepositTx().getTxId().toString() are not the same. "" +
                            ""trade.getDepositTxId()={}, trade.getDepositTx().getTxId().toString()={}, depositTx={}"",
                    depositTxId, depositTxIdFromTx, depositTx);
        }

        Transaction delayedPayoutTx = trade.getDelayedPayoutTx(btcWalletService);
        String delayedPayoutTxString = delayedPayoutTx != null ? delayedPayoutTx.getTxId().toString() : null;
        addLabelTxIdTextField(gridPane, ++rowIndex, Res.get(""shared.delayedPayoutTxId""), delayedPayoutTxString);

        if (trade.getPayoutTx() != null)
            addLabelTxIdTextField(gridPane, ++rowIndex, Res.get(""shared.payoutTxId""),
                    trade.getPayoutTx().getTxId().toString());
        if (showDisputedTx)
            addLabelTxIdTextField(gridPane, ++rowIndex, Res.get(""tradeDetailsWindow.disputedPayoutTxId""),
                    arbitrationManager.findOwnDispute(trade.getId()).get().getDisputePayoutTxId());

        if (trade.hasFailed()) {
            textArea = addConfirmationLabelTextArea(gridPane, ++rowIndex, Res.get(""shared.errorMessage""), """", 0).second;
            textArea.setText(trade.getErrorMessage());
            textArea.setEditable(false);
            //TODO paint red

            IntegerProperty count = new SimpleIntegerProperty(20);
            int rowHeight = 10;
            textArea.prefHeightProperty().bindBidirectional(count);
            changeListener = (ov, old, newVal) -> {
                if (newVal.intValue() > rowHeight)
                    count.setValue(count.get() + newVal.intValue() + 10);
            };
            textArea.scrollTopProperty().addListener(changeListener);
            textArea.setScrollTop(30);

            addConfirmationLabelTextField(gridPane, ++rowIndex, Res.get(""tradeDetailsWindow.tradeState""), trade.getTradePhase().name());
        }

        Tuple3<Button, Button, HBox> tuple = add2ButtonsWithBox(gridPane, ++rowIndex,
                Res.get(""tradeDetailsWindow.detailData""), Res.get(""shared.close""), 15, false);
        Button viewContractButton = tuple.first;
        viewContractButton.setMaxWidth(Region.USE_COMPUTED_SIZE);
        Button closeButton = tuple.second;
        closeButton.setMaxWidth(Region.USE_COMPUTED_SIZE);
        HBox hBox = tuple.third;
        GridPane.setColumnSpan(hBox, 2);
        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        hBox.getChildren().add(0, spacer);

        if (contract != null) {
            viewContractButton.setOnAction(e -> {
                TextArea textArea = new BisqTextArea();
                textArea.setText(trade.getContractAsJson());
                String data = ""Contract as json:\n"";
                data += trade.getContractAsJson();
                data += ""\n\nOther detail data:"";
                data += ""\n\nBuyerMultiSigPubKeyHex: "" + Utils.HEX.encode(contract.getBuyerMultiSigPubKey());
                data += ""\nSellerMultiSigPubKeyHex: "" + Utils.HEX.encode(contract.getSellerMultiSigPubKey());
                if (CurrencyUtil.isFiatCurrency(offer.getCurrencyCode())) {
                    data += ""\n\nBuyersAccountAge: "" + buyersAccountAge;
                    data += ""\nSellersAccountAge: "" + sellersAccountAge;
                }

                if (depositTx != null) {
                    String depositTxAsHex = Utils.HEX.encode(depositTx.bitcoinSerialize(true));
                    data += ""\n\nRaw deposit transaction as hex:\n"" + depositTxAsHex;
                }

                data += ""\n\nSelected mediator: "" + DisputeAgentLookupMap.getKeyBaseUserName(contract.getMediatorNodeAddress().getFullAddress());
                data += ""\nSelected arbitrator (refund agent): "" + DisputeAgentLookupMap.getKeyBaseUserName(contract.getRefundAgentNodeAddress().getFullAddress());

                textArea.setText(data);
                textArea.setPrefHeight(50);
                textArea.setEditable(false);
                textArea.setWrapText(true);
                textArea.setPrefSize(800, 600);

                Scene viewContractScene = new Scene(textArea);
                Stage viewContractStage = new Stage();
                viewContractStage.setTitle(Res.get(""shared.contract.title"", trade.getShortId()));
                viewContractStage.setScene(viewContractScene);
                if (owner == null)
                    owner = MainView.getRootContainer();
                Scene rootScene = owner.getScene();
                viewContractStage.initOwner(rootScene.getWindow());
                viewContractStage.initModality(Modality.NONE);
                viewContractStage.initStyle(StageStyle.UTILITY);
                viewContractStage.setOpacity(0);
                viewContractStage.show();

                Window window = rootScene.getWindow();
                double titleBarHeight = window.getHeight() - rootScene.getHeight();
                viewContractStage.setX(Math.round(window.getX() + (owner.getWidth() - viewContractStage.getWidth()) / 2) + 200);
                viewContractStage.setY(Math.round(window.getY() + titleBarHeight + (owner.getHeight() - viewContractStage.getHeight()) / 2) + 50);
                // Delay display to next render frame to avoid that the popup is first quickly displayed in default position
                // and after a short moment in the correct position
                UserThread.execute(() -> viewContractStage.setOpacity(1));

                viewContractScene.setOnKeyPressed(ev -> {
                    if (ev.getCode() == KeyCode.ESCAPE) {
                        ev.consume();
                        viewContractStage.hide();
                    }
                });
            });
        }

        closeButton.setOnAction(e -> {
            closeHandlerOptional.ifPresent(Runnable::run);
            hide();
        });
    }
}",1,777 587 2000 650 2001 60 2000 62 123 775 809 657 2002 2003 61 2004 46 2005 40 2000 46 587 41 59 773 657 2006 2007 59 773 657 2008 2009 59 773 657 2010 2011 59 773 657 2012 2013 59 773 657 2014 2015 59 773 2016 2017 59 773 2018 60 2019 62 2020 59 773 2021 2022 59 773 2023 2024 59 773 2023 2025 59 331 330 331 64 2026 777 2000 40 64 2027 40 2028 46 2029 41 2006 2007 44 2008 2009 44 2010 2011 44 2012 2013 44 2014 2015 41 123 823 46 2007 61 2007 59 823 46 2009 61 2009 59 823 46 2011 61 2011 59 823 46 2013 61 2013 59 823 46 2015 61 2015 59 2030 61 2031 46 2032 59 125 777 865 2033 40 2016 2017 41 123 823 46 2017 61 2017 59 2034 61 45 1501 59 2035 61 1504 59 2036 40 41 59 2037 40 41 59 2038 40 41 59 125 331 330 331 64 2039 775 865 2040 40 41 123 688 40 2022 340 2041 41 2022 46 2042 40 41 46 2043 40 2020 41 59 125 64 2039 775 865 2044 40 41 123 818 46 2044 40 41 59 2045 46 2046 40 744 2047 40 1503 44 1503 44 1503 44 1503 41 41 59 2045 46 2048 40 41 46 2049 40 362 41 59 125 773 865 2050 40 41 123 2051 2052 61 2017 46 2053 40 41 59 2054 2055 61 2017 46 2056 40 41 59 704 2057 61 1502 59 2058 40 2059 44 349 2060 44 2057 44 2061 46 2062 40 362 41 41 59 570 2063 61 2011 46 2064 40 2052 41 59 2023 2065 59 2023 2066 59 2023 2067 61 362 43 2061 46 2062 40 362 41 59 2023 2068 61 362 43 2061 46 2062 40 362 41 59 2023 2069 61 2061 46 2062 40 362 41 59 688 40 2011 46 2070 40 2052 41 41 123 2071 40 2059 44 2060 44 2069 44 2072 46 2073 40 2063 44 2052 46 2074 40 41 41 44 2075 46 2076 41 59 2065 61 2068 59 2066 61 2067 59 125 630 123 2077 40 2059 44 2060 44 2069 44 2078 46 2079 40 2063 44 2052 46 2080 40 41 41 44 2081 46 2082 41 59 2065 61 2067 59 2066 61 2068 59 125 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 43 2066 44 2007 46 2084 40 2017 46 2085 40 41 41 41 59 2083 40 2059 44 349 2060 44 2086 46 2087 40 2052 46 2088 40 41 41 43 2065 44 2086 46 2089 40 2017 46 2090 40 41 41 41 59 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2028 46 2091 40 2017 46 2092 40 41 41 41 59 2023 2093 61 2061 46 2062 40 2052 46 2094 40 41 46 2095 40 41 41 59 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2093 41 59 330 2057 61 1502 59 2096 2097 61 2098 59 2096 2099 61 2098 59 688 40 2055 340 2098 41 123 2057 349 59 2097 61 2055 46 2100 40 41 59 2099 61 2055 46 2101 40 41 59 688 40 2097 340 2098 41 2057 349 59 688 40 2099 340 2098 41 2057 349 59 688 40 2097 323 2098 307 2099 323 2098 41 2057 349 59 125 570 2102 61 2103 40 2017 46 2053 40 41 41 46 2088 40 41 46 2104 40 362 41 307 2017 46 2105 40 41 340 2098 307 2017 46 2105 40 41 340 2106 46 2107 59 688 40 2017 46 2108 40 41 340 2098 41 2057 349 59 570 2109 61 2009 46 2110 40 2017 46 2095 40 41 41 46 2111 40 41 307 2009 46 2110 40 2017 46 2095 40 41 41 46 2062 40 41 46 2112 40 41 340 2098 59 688 40 2109 41 2057 349 59 688 40 2017 46 2113 40 41 41 2057 348 1502 59 688 40 2017 46 2114 40 41 340 2098 41 2057 349 59 688 40 2102 41 2057 349 59 2058 40 2059 44 349 2060 44 2057 44 2061 46 2062 40 362 41 44 2115 46 2116 41 59 2083 40 2059 44 2060 44 2061 46 2062 40 362 41 44 2017 46 2095 40 41 44 2115 46 2117 41 59 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2118 46 2119 40 2017 46 2120 40 41 41 41 59 2023 2121 61 2061 46 2122 40 362 41 43 362 43 2007 46 2084 40 2052 46 2123 40 41 41 43 362 43 2061 46 2122 40 362 41 43 362 43 2007 46 2084 40 2052 46 2124 40 41 41 59 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2121 41 59 2023 2125 61 2061 46 2062 40 362 44 2007 46 2084 40 2052 46 2126 40 41 41 41 43 362 43 2061 46 2062 40 362 44 2007 46 2084 40 2017 46 2127 40 41 46 2128 40 1502 41 41 41 59 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2125 41 59 2129 2130 61 2017 46 2131 40 41 59 2129 2132 61 2017 46 2133 40 41 59 688 40 2130 340 2098 307 2132 340 2098 41 123 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2130 46 2134 40 41 43 362 43 2132 46 2134 40 41 41 59 125 688 40 2017 46 2114 40 41 340 2098 41 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2017 46 2114 40 41 46 2135 40 41 41 59 688 40 2102 41 123 330 330 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2136 46 2137 40 2017 46 2105 40 41 41 41 59 125 688 40 2055 340 2098 41 123 688 40 2097 340 2098 41 123 2023 2138 61 2097 46 2139 40 41 59 726 2140 61 2015 46 2141 40 2097 44 2055 46 2142 40 41 41 59 2024 61 2143 46 2144 40 2052 46 2088 40 41 41 63 2140 62 45 1501 63 2061 46 2062 40 362 44 2118 46 2145 40 2140 41 41 58 2061 46 2062 40 362 41 58 362 59 2023 2146 61 2024 46 2147 40 41 63 362 58 362 43 2024 59 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 44 2061 46 2062 40 362 41 41 44 2138 43 2146 41 46 2148 46 2149 40 744 2150 40 2138 43 2146 41 41 59 125 688 40 2099 340 2098 41 123 2023 2151 61 2099 46 2152 40 41 59 726 2153 61 2015 46 2154 40 2099 44 2055 46 2155 40 41 41 59 2025 61 2156 46 2157 40 2052 46 2088 40 41 41 63 2153 62 45 1501 63 2061 46 2062 40 362 44 2118 46 2158 40 2153 41 41 58 2061 46 2062 40 362 41 58 362 59 2023 2159 61 2025 46 2160 40 41 63 362 58 362 43 2025 59 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 44 2061 46 2062 40 362 41 41 44 2151 43 2159 41 46 2161 46 2162 40 744 2163 40 2151 43 2159 41 41 59 125 688 40 2097 323 2098 307 2099 323 2098 41 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2061 46 2062 40 2055 46 2164 40 41 41 41 59 125 2165 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2052 46 2166 40 41 41 59 2165 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2017 46 2167 40 41 41 59 2023 2168 61 2017 46 2169 40 41 59 2170 2171 61 2017 46 2172 40 41 59 2023 2173 61 2171 340 2098 63 2171 46 2174 40 41 46 2175 40 41 58 2098 59 2176 2177 61 2165 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2168 41 46 2178 59 688 40 2168 323 2098 309 33 2168 46 2104 40 2173 41 41 123 2177 46 2179 40 41 46 2180 40 362 41 59 2003 46 2181 40 362 43 362 44 2168 44 2173 44 2171 41 59 125 2170 2182 61 2017 46 2183 40 2013 41 59 2023 2184 61 2182 340 2098 63 2182 46 2174 40 41 46 2175 40 41 58 2098 59 2165 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2184 41 59 688 40 2017 46 2108 40 41 340 2098 41 2165 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2017 46 2108 40 41 46 2174 40 41 46 2175 40 41 41 59 688 40 2109 41 2165 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2009 46 2110 40 2017 46 2095 40 41 41 46 2062 40 41 46 2112 40 41 41 59 688 40 2017 46 2113 40 41 41 123 2022 61 2185 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 362 44 1500 41 46 2178 59 2022 46 2186 40 2017 46 2187 40 41 41 59 2022 46 2188 40 2189 41 59 330 2190 2191 61 744 2192 40 1503 41 59 704 2193 61 1502 59 2022 46 2194 40 41 46 2195 40 2191 41 59 2020 61 40 2196 44 2197 44 2198 41 45 62 123 688 40 2198 46 2199 40 41 62 2193 41 2191 46 2200 40 2191 46 2062 40 41 43 2198 46 2199 40 41 43 1502 41 59 125 59 2022 46 2201 40 41 46 2202 40 2020 41 59 2022 46 2203 40 1503 41 59 2083 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2017 46 2204 40 41 46 2205 40 41 41 59 125 2206 60 2207 44 2207 44 2208 62 2209 61 2210 40 2059 44 349 2060 44 2061 46 2062 40 362 41 44 2061 46 2062 40 362 41 44 1503 44 2211 41 59 2207 2212 61 2209 46 2213 59 2212 46 2214 40 2215 46 2216 41 59 2207 2217 61 2209 46 2178 59 2217 46 2214 40 2215 46 2216 41 59 2208 2218 61 2209 46 2219 59 2220 46 2221 40 2218 44 1502 41 59 2215 2222 61 744 2215 40 41 59 2208 46 2223 40 2222 44 2224 46 2225 41 59 2218 46 2226 40 41 46 2227 40 1500 44 2222 41 59 688 40 2055 340 2098 41 123 2212 46 2228 40 2229 45 62 123 2021 2022 61 744 2230 40 41 59 2022 46 2231 40 2017 46 2232 40 41 41 59 2023 2233 61 362 59 2233 348 2017 46 2232 40 41 59 2233 348 362 59 2233 348 362 43 2234 46 2235 46 2236 40 2055 46 2237 40 41 41 59 2233 348 362 43 2234 46 2235 46 2236 40 2055 46 2238 40 41 41 59 688 40 2239 46 2240 40 2052 46 2088 40 41 41 41 123 2233 348 362 43 2024 59 2233 348 362 43 2025 59 125 688 40 2171 340 2098 41 123 2023 2241 61 2234 46 2235 46 2236 40 2171 46 2242 40 2243 41 41 59 2233 348 362 43 2241 59 125 2233 348 362 43 2244 46 2245 40 2055 46 2133 40 41 46 2135 40 41 41 59 2233 348 362 43 2244 46 2245 40 2055 46 2246 40 41 46 2135 40 41 41 59 2022 46 2231 40 2233 41 59 2022 46 2247 40 1503 41 59 2022 46 2248 40 2211 41 59 2022 46 2249 40 2250 41 59 2022 46 2251 40 1504 44 1504 41 59 2252 2253 61 744 2252 40 2022 41 59 2254 2255 61 744 2254 40 41 59 2255 46 2256 40 2061 46 2062 40 362 44 2017 46 2257 40 41 41 41 59 2255 46 2258 40 2253 41 59 688 40 2259 323 2098 41 2259 61 2260 46 2261 40 41 59 2252 2262 61 2259 46 2263 40 41 59 2255 46 2264 40 2262 46 2265 40 41 41 59 2255 46 2266 40 2267 46 2268 41 59 2255 46 2269 40 2270 46 2271 41 59 2255 46 2272 40 1500 41 59 2255 46 2033 40 41 59 2273 2274 61 2262 46 2265 40 41 59 625 2275 61 2274 46 2276 40 41 45 2262 46 2276 40 41 59 2255 46 2277 40 2278 46 2279 40 2274 46 2280 40 41 43 40 2259 46 2281 40 41 45 2255 46 2281 40 41 41 47 1502 41 43 1504 41 59 2255 46 2282 40 2278 46 2279 40 2274 46 2283 40 41 43 2275 43 40 2259 46 2276 40 41 45 2255 46 2276 40 41 41 47 1502 41 43 1503 41 59 330 330 2284 46 2285 40 40 41 45 62 2255 46 2272 40 1501 41 41 59 2253 46 2286 40 2287 45 62 123 688 40 2287 46 2288 40 41 323 2289 46 2290 41 123 2287 46 2291 40 41 59 2255 46 2292 40 41 59 125 125 41 59 125 41 59 125 2217 46 2293 40 2294 45 62 123 2295 46 2296 40 2297 58 58 2298 41 59 2299 40 41 59 125 41 59 125 125 ,"{'AvgLine': 59, 'CountLine': 324, 'CountStmt': 196, 'MaxNesting': 2, 'AvgLineCode': 51, 'AvgEssential': 1, 'AvgLineBlank': 6, 'CountStmtExe': 170, 'MaxEssential': 1, 'SumEssential': 8, 'AvgCyclomatic': 7, 'CountLineCode': 268, 'CountStmtDecl': 62, 'MaxCyclomatic': 31, 'SumCyclomatic': 43, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 44, 'CountSemicolon': 162, 'CountDeclMethod': 5, 'CountLineCodeExe': 224, 'CountLineComment': 12, 'CountClassCoupled': 54, 'CountClassDerived': 0, 'CountLineCodeDecl': 75, 'CountDeclMethodAll': 74, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.04', 'AvgCyclomaticStrict': 8, 'MaxCyclomaticStrict': 38, 'SumCyclomaticStrict': 50, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 7, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 31, 'PercentLackOfCohesion': 64, 'SumCyclomaticModified': 43, 'CountDeclClassVariable': 1, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 1, 'CountDeclInstanceMethod': 5, 'CountDeclMethodProtected': 2, 'CountClassCoupledModified': 54, 'CountDeclInstanceVariable': 10, 'PercentLackOfCohesionModified': 46}"
3475,Java,"@Slf4j
@Singleton
public class BisqSetup {
    private static final String VERSION_FILE_NAME = ""version"";
    private static final String RESYNC_SPV_FILE_NAME = ""resyncSpv"";

    public interface BisqSetupListener {
        default void onInitP2pNetwork() {
        }

        default void onInitWallet() {
        }

        default void onRequestWalletPassword() {
        }

        void onSetupComplete();
    }

    private static final long STARTUP_TIMEOUT_MINUTES = 4;

    private final DomainInitialisation domainInitialisation;
    private final P2PNetworkSetup p2PNetworkSetup;
    private final WalletAppSetup walletAppSetup;
    private final WalletsManager walletsManager;
    private final WalletsSetup walletsSetup;
    private final BtcWalletService btcWalletService;
    private final P2PService p2PService;
    private final SignedWitnessStorageService signedWitnessStorageService;
    private final TradeManager tradeManager;
    private final OpenOfferManager openOfferManager;
    private final Preferences preferences;
    private final User user;
    private final AlertManager alertManager;
    private final UnconfirmedBsqChangeOutputListService unconfirmedBsqChangeOutputListService;
    private final Config config;
    private final AccountAgeWitnessService accountAgeWitnessService;
    private final CoinFormatter formatter;
    private final LocalBitcoinNode localBitcoinNode;
    private final AppStartupState appStartupState;
    private final MediationManager mediationManager;
    private final RefundManager refundManager;
    private final ArbitrationManager arbitrationManager;

    @Setter
    @Nullable
    private Consumer<Runnable> displayTacHandler;
    @Setter
    @Nullable
    private Consumer<String> chainFileLockedExceptionHandler,
            spvFileCorruptedHandler, lockedUpFundsHandler, daoErrorMessageHandler, daoWarnMessageHandler,
            filterWarningHandler, displaySecurityRecommendationHandler, displayLocalhostHandler,
            wrongOSArchitectureHandler, displaySignedByArbitratorHandler,
            displaySignedByPeerHandler, displayPeerLimitLiftedHandler, displayPeerSignerHandler,
            rejectedTxErrorMessageHandler;
    @Setter
    @Nullable
    private Consumer<Boolean> displayTorNetworkSettingsHandler;
    @Setter
    @Nullable
    private Runnable showFirstPopupIfResyncSPVRequestedHandler;
    @Setter
    @Nullable
    private Consumer<Consumer<KeyParameter>> requestWalletPasswordHandler;
    @Setter
    @Nullable
    private Consumer<Alert> displayAlertHandler;
    @Setter
    @Nullable
    private BiConsumer<Alert, String> displayUpdateHandler;
    @Setter
    @Nullable
    private Consumer<VoteResultException> voteResultExceptionHandler;
    @Setter
    @Nullable
    private Consumer<PrivateNotificationPayload> displayPrivateNotificationHandler;
    @Setter
    @Nullable
    private Runnable showPopupIfInvalidBtcConfigHandler;
    @Setter
    @Nullable
    private Consumer<List<RevolutAccount>> revolutAccountsUpdateHandler;
    @Setter
    @Nullable
    private Consumer<List<AmazonGiftCardAccount>> amazonGiftCardAccountsUpdateHandler;
    @Setter
    @Nullable
    private Runnable qubesOSInfoHandler;
    @Setter
    @Nullable
    private Runnable daoRequiresRestartHandler;
    @Setter
    @Nullable
    private Runnable torAddressUpgradeHandler;
    @Setter
    @Nullable
    private Consumer<String> downGradePreventionHandler;

    @Getter
    final BooleanProperty newVersionAvailableProperty = new SimpleBooleanProperty(false);
    private BooleanProperty p2pNetworkReady;
    private final BooleanProperty walletInitialized = new SimpleBooleanProperty();
    private boolean allBasicServicesInitialized;
    @SuppressWarnings(""FieldCanBeLocal"")
    private MonadicBinding<Boolean> p2pNetworkAndWalletInitialized;
    private final List<BisqSetupListener> bisqSetupListeners = new ArrayList<>();

    @Inject
    public BisqSetup(DomainInitialisation domainInitialisation,
                     P2PNetworkSetup p2PNetworkSetup,
                     WalletAppSetup walletAppSetup,
                     WalletsManager walletsManager,
                     WalletsSetup walletsSetup,
                     BtcWalletService btcWalletService,
                     P2PService p2PService,
                     SignedWitnessStorageService signedWitnessStorageService,
                     TradeManager tradeManager,
                     OpenOfferManager openOfferManager,
                     Preferences preferences,
                     User user,
                     AlertManager alertManager,
                     UnconfirmedBsqChangeOutputListService unconfirmedBsqChangeOutputListService,
                     Config config,
                     AccountAgeWitnessService accountAgeWitnessService,
                     @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter formatter,
                     LocalBitcoinNode localBitcoinNode,
                     AppStartupState appStartupState,
                     Socks5ProxyProvider socks5ProxyProvider,
                     MediationManager mediationManager,
                     RefundManager refundManager,
                     ArbitrationManager arbitrationManager) {
        this.domainInitialisation = domainInitialisation;
        this.p2PNetworkSetup = p2PNetworkSetup;
        this.walletAppSetup = walletAppSetup;
        this.walletsManager = walletsManager;
        this.walletsSetup = walletsSetup;
        this.btcWalletService = btcWalletService;
        this.p2PService = p2PService;
        this.signedWitnessStorageService = signedWitnessStorageService;
        this.tradeManager = tradeManager;
        this.openOfferManager = openOfferManager;
        this.preferences = preferences;
        this.user = user;
        this.alertManager = alertManager;
        this.unconfirmedBsqChangeOutputListService = unconfirmedBsqChangeOutputListService;
        this.config = config;
        this.accountAgeWitnessService = accountAgeWitnessService;
        this.formatter = formatter;
        this.localBitcoinNode = localBitcoinNode;
        this.appStartupState = appStartupState;
        this.mediationManager = mediationManager;
        this.refundManager = refundManager;
        this.arbitrationManager = arbitrationManager;

        MemPoolSpaceTxBroadcaster.init(socks5ProxyProvider, preferences, localBitcoinNode);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void displayAlertIfPresent(Alert alert, boolean openNewVersionPopup) {
        if (alert == null)
            return;

        if (alert.isSoftwareUpdateNotification()) {
            // only process if the alert version is ""newer"" than ours
            if (alert.isNewVersion(preferences)) {
                user.setDisplayedAlert(alert);          // save context to compare later
                newVersionAvailableProperty.set(true);  // shows link in footer bar
                if ((alert.canShowPopup(preferences) || openNewVersionPopup) && displayUpdateHandler != null) {
                    displayUpdateHandler.accept(alert, alert.showAgainKey());
                }
            }
        } else {
            // it is a normal message alert
            final Alert displayedAlert = user.getDisplayedAlert();
            if ((displayedAlert == null || !displayedAlert.equals(alert)) && displayAlertHandler != null)
                displayAlertHandler.accept(alert);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Main startup tasks
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void addBisqSetupListener(BisqSetupListener listener) {
        bisqSetupListeners.add(listener);
    }

    public void start() {
        // If user tried to downgrade we require a shutdown
        if (Config.baseCurrencyNetwork() == BaseCurrencyNetwork.BTC_MAINNET &&
                hasDowngraded(downGradePreventionHandler)) {
            return;
        }

        persistBisqVersion();
        maybeReSyncSPVChain();
        maybeShowTac(this::step2);
    }

    private void step2() {
        readMapsFromResources(this::step3);
        checkForCorrectOSArchitecture();
        checkIfRunningOnQubesOS();
    }

    private void step3() {
        startP2pNetworkAndWallet(this::step4);
    }

    private void step4() {
        initDomainServices();

        bisqSetupListeners.forEach(BisqSetupListener::onSetupComplete);

        // We set that after calling the setupCompleteHandler to not trigger a popup from the dev dummy accounts
        // in MainViewModel
        maybeShowSecurityRecommendation();
        maybeShowLocalhostRunningInfo();
        maybeShowAccountSigningStateInfo();
        maybeShowTorAddressUpgradeInformation();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Sub tasks
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void maybeReSyncSPVChain() {
        // We do the delete of the spv file at startup before BitcoinJ is initialized to avoid issues with locked files under Windows.
        if (getResyncSpvSemaphore()) {
            try {
                walletsSetup.reSyncSPVChain();

                // In case we had an unconfirmed change output we reset the unconfirmedBsqChangeOutputList so that
                // after a SPV resync we do not have any dangling BSQ utxos in that list which would cause an incorrect
                // BSQ balance state after the SPV resync.
                unconfirmedBsqChangeOutputListService.onSpvResync();
            } catch (IOException e) {
                log.error(e.toString());
                e.printStackTrace();
            }
        }
    }

    private void maybeShowTac(Runnable nextStep) {
        if (!preferences.isTacAcceptedV120() && !DevEnv.isDevMode()) {
            if (displayTacHandler != null)
                displayTacHandler.accept(() -> {
                    preferences.setTacAcceptedV120(true);
                    nextStep.run();
                });
        } else {
            nextStep.run();
        }
    }

    private void readMapsFromResources(Runnable completeHandler) {
        String postFix = ""_"" + config.baseCurrencyNetwork.name();
        p2PService.getP2PDataStorage().readFromResources(postFix, completeHandler);
    }

    private void startP2pNetworkAndWallet(Runnable nextStep) {
        ChangeListener<Boolean> walletInitializedListener = (observable, oldValue, newValue) -> {
            // TODO that seems to be called too often if Tor takes longer to start up...
            if (newValue && !p2pNetworkReady.get() && displayTorNetworkSettingsHandler != null)
                displayTorNetworkSettingsHandler.accept(true);
        };

        Timer startupTimeout = UserThread.runAfter(() -> {
            if (p2PNetworkSetup.p2pNetworkFailed.get() || walletsSetup.walletsSetupFailed.get()) {
                // Skip this timeout action if the p2p network or wallet setup failed
                // since an error prompt will be shown containing the error message
                return;
            }
            log.warn(""startupTimeout called"");
            if (walletsManager.areWalletsEncrypted())
                walletInitialized.addListener(walletInitializedListener);
            else if (displayTorNetworkSettingsHandler != null)
                displayTorNetworkSettingsHandler.accept(true);

            log.info(""Set log level for org.berndpruenster.netlayer classes to DEBUG to show more details for "" +
                    ""Tor network connection issues"");
            Log.setCustomLogLevel(""org.berndpruenster.netlayer"", Level.DEBUG);

        }, STARTUP_TIMEOUT_MINUTES, TimeUnit.MINUTES);

        log.info(""Init P2P network"");
        bisqSetupListeners.forEach(BisqSetupListener::onInitP2pNetwork);
        p2pNetworkReady = p2PNetworkSetup.init(this::initWallet, displayTorNetworkSettingsHandler);

        // We only init wallet service here if not using Tor for bitcoinj.
        // When using Tor, wallet init must be deferred until Tor is ready.
        // TODO encapsulate below conditional inside getUseTorForBitcoinJ
        if (!preferences.getUseTorForBitcoinJ() || localBitcoinNode.shouldBeUsed()) {
            initWallet();
        }

        // need to store it to not get garbage collected
        p2pNetworkAndWalletInitialized = EasyBind.combine(walletInitialized, p2pNetworkReady,
                (a, b) -> {
                    log.info(""walletInitialized={}, p2pNetWorkReady={}"", a, b);
                    return a && b;
                });
        p2pNetworkAndWalletInitialized.subscribe((observable, oldValue, newValue) -> {
            if (newValue) {
                startupTimeout.stop();
                walletInitialized.removeListener(walletInitializedListener);
                if (displayTorNetworkSettingsHandler != null)
                    displayTorNetworkSettingsHandler.accept(false);
                nextStep.run();
            }
        });
    }

    private void initWallet() {
        log.info(""Init wallet"");
        bisqSetupListeners.forEach(BisqSetupListener::onInitWallet);
        Runnable walletPasswordHandler = () -> {
            log.info(""Wallet password required"");
            bisqSetupListeners.forEach(BisqSetupListener::onRequestWalletPassword);
            if (p2pNetworkReady.get())
                p2PNetworkSetup.setSplashP2PNetworkAnimationVisible(true);

            if (requestWalletPasswordHandler != null) {
                requestWalletPasswordHandler.accept(aesKey -> {
                    walletsManager.setAesKey(aesKey);
                    walletsManager.maybeAddSegwitKeychains(aesKey);
                    if (getResyncSpvSemaphore()) {
                        if (showFirstPopupIfResyncSPVRequestedHandler != null)
                            showFirstPopupIfResyncSPVRequestedHandler.run();
                    } else {
                        // TODO no guarantee here that the wallet is really fully initialized
                        // We would need a new walletInitializedButNotEncrypted state to track
                        // Usually init is fast and we have our wallet initialized at that state though.
                        walletInitialized.set(true);
                    }
                });
            }
        };
        walletAppSetup.init(chainFileLockedExceptionHandler,
                spvFileCorruptedHandler,
                getResyncSpvSemaphore(),
                showFirstPopupIfResyncSPVRequestedHandler,
                showPopupIfInvalidBtcConfigHandler,
                walletPasswordHandler,
                () -> {
                    if (allBasicServicesInitialized) {
                        checkForLockedUpFunds();
                        checkForInvalidMakerFeeTxs();
                    }
                },
                () -> walletInitialized.set(true));
    }

    private void initDomainServices() {
        log.info(""initDomainServices"");

        domainInitialisation.initDomainServices(rejectedTxErrorMessageHandler,
                displayPrivateNotificationHandler,
                daoErrorMessageHandler,
                daoWarnMessageHandler,
                filterWarningHandler,
                voteResultExceptionHandler,
                revolutAccountsUpdateHandler,
                amazonGiftCardAccountsUpdateHandler,
                daoRequiresRestartHandler);

        if (walletsSetup.downloadPercentageProperty().get() == 1) {
            checkForLockedUpFunds();
            checkForInvalidMakerFeeTxs();
        }

        alertManager.alertMessageProperty().addListener((observable, oldValue, newValue) ->
                displayAlertIfPresent(newValue, false));
        displayAlertIfPresent(alertManager.alertMessageProperty().get(), false);

        allBasicServicesInitialized = true;

        appStartupState.onDomainServicesInitialized();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void checkForLockedUpFunds() {
        // We check if there are locked up funds in failed or closed trades
        try {
            Set<String> setOfAllTradeIds = tradeManager.getSetOfFailedOrClosedTradeIdsFromLockedInFunds();
            btcWalletService.getAddressEntriesForTrade().stream()
                    .filter(e -> setOfAllTradeIds.contains(e.getOfferId()) &&
                            e.getContext() == AddressEntry.Context.MULTI_SIG)
                    .forEach(e -> {
                        Coin balance = e.getCoinLockedInMultiSigAsCoin();
                        if (balance.isPositive()) {
                            String message = Res.get(""popup.warning.lockedUpFunds"",
                                    formatter.formatCoinWithCode(balance), e.getAddressString(), e.getOfferId());
                            log.warn(message);
                            if (lockedUpFundsHandler != null) {
                                lockedUpFundsHandler.accept(message);
                            }
                        }
                    });
        } catch (TradeTxException e) {
            log.warn(e.getMessage());
            if (lockedUpFundsHandler != null) {
                lockedUpFundsHandler.accept(e.getMessage());
            }
        }
    }

    private void checkForInvalidMakerFeeTxs() {
        // We check if we have open offers with no confidence object at the maker fee tx. That can happen if the
        // miner fee was too low and the transaction got removed from mempool and got out from our wallet after a
        // resync.
        openOfferManager.getObservableList().forEach(e -> {
            if (e.getOffer().isBsqSwapOffer()) {
                return;
            }
            String offerFeePaymentTxId = e.getOffer().getOfferFeePaymentTxId();
            if (btcWalletService.getConfidenceForTxId(offerFeePaymentTxId) == null) {
                String message = Res.get(""popup.warning.openOfferWithInvalidMakerFeeTx"",
                        e.getOffer().getShortId(), offerFeePaymentTxId);
                log.warn(message);
                if (lockedUpFundsHandler != null) {
                    lockedUpFundsHandler.accept(message);
                }
            }
        });
    }

    @Nullable
    public static String getLastBisqVersion() {
        File versionFile = getVersionFile();
        if (!versionFile.exists()) {
            return null;
        }
        try (Scanner scanner = new Scanner(versionFile)) {
            // We only expect 1 line
            if (scanner.hasNextLine()) {
                return scanner.nextLine();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Nullable
    public static boolean getResyncSpvSemaphore() {
        File resyncSpvSemaphore = new File(Config.appDataDir(), RESYNC_SPV_FILE_NAME);
        return resyncSpvSemaphore.exists();
    }

    public static void setResyncSpvSemaphore(boolean isResyncSpvRequested) {
        File resyncSpvSemaphore = new File(Config.appDataDir(), RESYNC_SPV_FILE_NAME);
        if (isResyncSpvRequested) {
            if (!resyncSpvSemaphore.exists()) {
                try {
                    if (!resyncSpvSemaphore.createNewFile()) {
                        log.error(""ResyncSpv file could not be created"");
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                    log.error(""ResyncSpv file could not be created. {}"", e.toString());
                }
            }
        } else {
            resyncSpvSemaphore.delete();
        }
    }


    private static File getVersionFile() {
        return new File(Config.appDataDir(), VERSION_FILE_NAME);
    }

    public static boolean hasDowngraded() {
        return hasDowngraded(getLastBisqVersion());
    }

    public static boolean hasDowngraded(String lastVersion) {
        return lastVersion != null && Version.isNewVersion(lastVersion, Version.VERSION);
    }

    public static boolean hasDowngraded(@Nullable Consumer<String> downGradePreventionHandler) {
        String lastVersion = getLastBisqVersion();
        boolean hasDowngraded = hasDowngraded(lastVersion);
        if (hasDowngraded) {
            log.error(""Downgrade from version {} to version {} is not supported"", lastVersion, Version.VERSION);
            if (downGradePreventionHandler != null) {
                downGradePreventionHandler.accept(lastVersion);
            }
        }
        return hasDowngraded;
    }

    public static void persistBisqVersion() {
        File versionFile = getVersionFile();
        if (!versionFile.exists()) {
            try {
                if (!versionFile.createNewFile()) {
                    log.error(""Version file could not be created"");
                }
            } catch (IOException e) {
                e.printStackTrace();
                log.error(""Version file could not be created. {}"", e.toString());
            }
        }

        try (FileWriter fileWriter = new FileWriter(versionFile, false)) {
            fileWriter.write(Version.VERSION);
        } catch (IOException e) {
            e.printStackTrace();
            log.error(""Writing Version failed. {}"", e.toString());
        }
    }

    private void checkForCorrectOSArchitecture() {
        if (!Utilities.isCorrectOSArchitecture() && wrongOSArchitectureHandler != null) {
            String osArchitecture = Utilities.getOSArchitecture();
            // We don't force a shutdown as the osArchitecture might in strange cases return a wrong value.
            // Needs at least more testing on different machines...
            wrongOSArchitectureHandler.accept(Res.get(""popup.warning.wrongVersion"",
                    osArchitecture,
                    Utilities.getJVMArchitecture(),
                    osArchitecture));
        }
    }

    /**
     * If Bisq is running on an OS that is virtualized under Qubes, show info popup with
     * link to the Setup Guide. The guide documents what other steps are needed, in
     * addition to installing the Linux package (qube sizing, etc)
     */
    private void checkIfRunningOnQubesOS() {
        if (Utilities.isQubesOS() && qubesOSInfoHandler != null) {
            qubesOSInfoHandler.run();
        }
    }

    private void maybeShowSecurityRecommendation() {
        String key = ""remindPasswordAndBackup"";
        user.getPaymentAccountsAsObservable().addListener((SetChangeListener<PaymentAccount>) change -> {
            if (!walletsManager.areWalletsEncrypted() && !user.isPaymentAccountImport() && preferences.showAgain(key) && change.wasAdded() &&
                    displaySecurityRecommendationHandler != null)
                displaySecurityRecommendationHandler.accept(key);
        });
    }

    private void maybeShowLocalhostRunningInfo() {
        if (Config.baseCurrencyNetwork().isMainnet()) {
            maybeTriggerDisplayHandler(""bitcoinLocalhostNode"", displayLocalhostHandler,
                    localBitcoinNode.shouldBeUsed());
        }
    }

    private void maybeShowAccountSigningStateInfo() {
        String keySignedByArbitrator = ""accountSignedByArbitrator"";
        String keySignedByPeer = ""accountSignedByPeer"";
        String keyPeerLimitedLifted = ""accountLimitLifted"";
        String keyPeerSigner = ""accountPeerSigner"";

        // check signed witness on startup
        checkSigningState(AccountAgeWitnessService.SignState.ARBITRATOR, keySignedByArbitrator, displaySignedByArbitratorHandler);
        checkSigningState(AccountAgeWitnessService.SignState.PEER_INITIAL, keySignedByPeer, displaySignedByPeerHandler);
        checkSigningState(AccountAgeWitnessService.SignState.PEER_LIMIT_LIFTED, keyPeerLimitedLifted, displayPeerLimitLiftedHandler);
        checkSigningState(AccountAgeWitnessService.SignState.PEER_SIGNER, keyPeerSigner, displayPeerSignerHandler);

        // check signed witness during runtime
        p2PService.getP2PDataStorage().addAppendOnlyDataStoreListener(
                payload -> {
                    maybeTriggerDisplayHandler(keySignedByArbitrator, displaySignedByArbitratorHandler,
                            isSignedWitnessOfMineWithState(payload, AccountAgeWitnessService.SignState.ARBITRATOR));
                    maybeTriggerDisplayHandler(keySignedByPeer, displaySignedByPeerHandler,
                            isSignedWitnessOfMineWithState(payload, AccountAgeWitnessService.SignState.PEER_INITIAL));
                    maybeTriggerDisplayHandler(keyPeerLimitedLifted, displayPeerLimitLiftedHandler,
                            isSignedWitnessOfMineWithState(payload, AccountAgeWitnessService.SignState.PEER_LIMIT_LIFTED));
                    maybeTriggerDisplayHandler(keyPeerSigner, displayPeerSignerHandler,
                            isSignedWitnessOfMineWithState(payload, AccountAgeWitnessService.SignState.PEER_SIGNER));
                });
    }

    private void checkSigningState(AccountAgeWitnessService.SignState state,
                                   String key, Consumer<String> displayHandler) {
        boolean signingStateFound = signedWitnessStorageService.getMap().values().stream()
                .anyMatch(payload -> isSignedWitnessOfMineWithState(payload, state));

        maybeTriggerDisplayHandler(key, displayHandler, signingStateFound);
    }

    private boolean isSignedWitnessOfMineWithState(PersistableNetworkPayload payload,
                                                   AccountAgeWitnessService.SignState state) {
        if (payload instanceof SignedWitness && user.getPaymentAccounts() != null) {
            // We know at this point that it is already added to the signed witness list
            // Check if new signed witness is for one of my own accounts
            return user.getPaymentAccounts().stream()
                    .filter(a -> PaymentMethod.hasChargebackRisk(a.getPaymentMethod(), a.getTradeCurrencies()))
                    .filter(a -> Arrays.equals(((SignedWitness) payload).getAccountAgeWitnessHash(),
                            accountAgeWitnessService.getMyWitness(a.getPaymentAccountPayload()).getHash()))
                    .anyMatch(a -> accountAgeWitnessService.getSignState(accountAgeWitnessService.getMyWitness(
                            a.getPaymentAccountPayload())).equals(state));
        }
        return false;
    }

    private void maybeTriggerDisplayHandler(String key, Consumer<String> displayHandler, boolean signingStateFound) {
        if (signingStateFound && preferences.showAgain(key) &&
                displayHandler != null) {
            displayHandler.accept(key);
        }
    }

    private void maybeShowTorAddressUpgradeInformation() {
        if (Config.baseCurrencyNetwork().isRegtest() ||
                Utils.isV3Address(Objects.requireNonNull(p2PService.getNetworkNode().getNodeAddress()).getHostName())) {
            return;
        }

        maybeRunTorNodeAddressUpgradeHandler();

        tradeManager.getNumPendingTrades().addListener((observable, oldValue, newValue) -> {
            long numPendingTrades = (long) newValue;
            if (numPendingTrades == 0) {
                maybeRunTorNodeAddressUpgradeHandler();
            }
        });
    }

    private void maybeRunTorNodeAddressUpgradeHandler() {
        if (mediationManager.getDisputesAsObservableList().stream().allMatch(Dispute::isClosed) &&
                refundManager.getDisputesAsObservableList().stream().allMatch(Dispute::isClosed) &&
                arbitrationManager.getDisputesAsObservableList().stream().allMatch(Dispute::isClosed) &&
                tradeManager.getNumPendingTrades().isEqualTo(0).get()) {
            Objects.requireNonNull(torAddressUpgradeHandler).run();
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Wallet
    public StringProperty getBtcInfo() {
        return walletAppSetup.getBtcInfo();
    }

    public DoubleProperty getBtcSyncProgress() {
        return walletAppSetup.getBtcSyncProgress();
    }

    public StringProperty getWalletServiceErrorMsg() {
        return walletAppSetup.getWalletServiceErrorMsg();
    }

    public StringProperty getBtcSplashSyncIconId() {
        return walletAppSetup.getBtcSplashSyncIconId();
    }

    public BooleanProperty getUseTorForBTC() {
        return walletAppSetup.getUseTorForBTC();
    }

    // P2P
    public StringProperty getP2PNetworkInfo() {
        return p2PNetworkSetup.getP2PNetworkInfo();
    }

    public BooleanProperty getSplashP2PNetworkAnimationVisible() {
        return p2PNetworkSetup.getSplashP2PNetworkAnimationVisible();
    }

    public StringProperty getP2pNetworkWarnMsg() {
        return p2PNetworkSetup.getP2pNetworkWarnMsg();
    }

    public StringProperty getP2PNetworkIconId() {
        return p2PNetworkSetup.getP2PNetworkIconId();
    }

    public BooleanProperty getUpdatedDataReceived() {
        return p2PNetworkSetup.getUpdatedDataReceived();
    }

    public StringProperty getP2pNetworkLabelId() {
        return p2PNetworkSetup.getP2pNetworkLabelId();
    }


}",1,64 2000 64 2001 777 587 2002 123 773 809 657 2003 2004 61 362 59 773 809 657 2003 2005 61 362 59 777 709 2006 123 613 865 2007 40 41 123 125 613 865 2008 40 41 123 125 613 865 2009 40 41 123 125 865 2010 40 41 59 125 773 809 657 726 2011 61 1502 59 773 657 2012 2013 59 773 657 2014 2015 59 773 657 2016 2017 59 773 657 2018 2019 59 773 657 2020 2021 59 773 657 2022 2023 59 773 657 2024 2025 59 773 657 2026 2027 59 773 657 2028 2029 59 773 657 2030 2031 59 773 657 2032 2033 59 773 657 2034 2035 59 773 657 2036 2037 59 773 657 2038 2039 59 773 657 2040 2041 59 773 657 2042 2043 59 773 657 2044 2045 59 773 657 2046 2047 59 773 657 2048 2049 59 773 657 2050 2051 59 773 657 2052 2053 59 773 657 2054 2055 59 64 2056 64 2057 773 2058 60 2059 62 2060 59 64 2056 64 2057 773 2058 60 2003 62 2061 44 2062 44 2063 44 2064 44 2065 44 2066 44 2067 44 2068 44 2069 44 2070 44 2071 44 2072 44 2073 44 2074 59 64 2056 64 2057 773 2058 60 2075 62 2076 59 64 2056 64 2057 773 2059 2077 59 64 2056 64 2057 773 2058 60 2058 60 2078 356 2079 59 64 2056 64 2057 773 2058 60 2080 62 2081 59 64 2056 64 2057 773 2082 60 2080 44 2003 62 2083 59 64 2056 64 2057 773 2058 60 2084 62 2085 59 64 2056 64 2057 773 2058 60 2086 62 2087 59 64 2056 64 2057 773 2059 2088 59 64 2056 64 2057 773 2058 60 2089 60 2090 356 2091 59 64 2056 64 2057 773 2058 60 2089 60 2092 356 2093 59 64 2056 64 2057 773 2059 2094 59 64 2056 64 2057 773 2059 2095 59 64 2056 64 2057 773 2059 2096 59 64 2056 64 2057 773 2058 60 2003 62 2097 59 64 2098 657 2099 2100 61 744 2101 40 2102 41 59 773 2099 2103 59 773 657 2099 2104 61 744 2101 40 41 59 773 570 2105 59 64 2106 40 362 41 773 2107 60 2075 62 2108 59 773 657 2089 60 2006 62 2109 61 744 2110 60 62 40 41 59 64 2111 777 2002 40 2012 2013 44 2014 2015 44 2016 2017 44 2018 2019 44 2020 2021 44 2022 2023 44 2024 2025 44 2026 2027 44 2028 2029 44 2030 2031 44 2032 2033 44 2034 2035 44 2036 2037 44 2038 2039 44 2040 2041 44 2042 2043 44 64 2112 40 2113 46 2114 41 2044 2045 44 2046 2047 44 2048 2049 44 2115 2116 44 2050 2051 44 2052 2053 44 2054 2055 41 123 823 46 2013 61 2013 59 823 46 2015 61 2015 59 823 46 2017 61 2017 59 823 46 2019 61 2019 59 823 46 2021 61 2021 59 823 46 2023 61 2023 59 823 46 2025 61 2025 59 823 46 2027 61 2027 59 823 46 2029 61 2029 59 823 46 2031 61 2031 59 823 46 2033 61 2033 59 823 46 2035 61 2035 59 823 46 2037 61 2037 59 823 46 2039 61 2039 59 823 46 2041 61 2041 59 823 46 2043 61 2043 59 823 46 2045 61 2045 59 823 46 2047 61 2047 59 823 46 2049 61 2049 59 823 46 2051 61 2051 59 823 46 2053 61 2053 59 823 46 2055 61 2055 59 2117 46 2118 40 2116 44 2033 44 2047 41 59 125 331 330 331 777 865 2119 40 2080 2120 44 570 2121 41 123 688 40 2120 323 2122 41 792 59 688 40 2120 46 2123 40 41 41 123 330 688 40 2120 46 2124 40 2033 41 41 123 2035 46 2125 40 2120 41 59 330 2100 46 2126 40 2127 41 59 330 688 40 40 2120 46 2128 40 2033 41 309 2121 41 307 2083 340 2122 41 123 2083 46 2129 40 2120 44 2120 46 2130 40 41 41 59 125 125 125 630 123 330 657 2080 2131 61 2035 46 2132 40 41 59 688 40 40 2131 323 2122 309 33 2131 46 2133 40 2120 41 41 307 2081 340 2122 41 2081 46 2134 40 2120 41 59 125 125 331 330 331 777 865 2135 40 2006 2136 41 123 2109 46 2137 40 2136 41 59 125 777 865 2138 40 41 123 330 688 40 2040 46 2139 40 41 323 2140 46 2141 307 2142 40 2097 41 41 123 792 59 125 2143 40 41 59 2144 40 41 59 2145 40 823 58 58 2146 41 59 125 773 865 2147 40 41 123 2148 40 823 58 58 2149 41 59 2150 40 41 59 2151 40 41 59 125 773 865 2152 40 41 123 2153 40 823 58 58 2154 41 59 125 773 865 2155 40 41 123 2156 40 41 59 2109 46 2157 40 2006 58 58 2158 41 59 330 330 2159 40 41 59 2160 40 41 59 2161 40 41 59 2162 40 41 59 125 331 330 331 773 865 2163 40 41 123 330 688 40 2164 40 41 41 123 830 123 2021 46 2165 40 41 59 330 330 330 2039 46 2166 40 41 59 125 580 40 2167 2168 41 123 2169 46 2170 40 2168 46 2171 40 41 41 59 2168 46 2172 40 41 59 125 125 125 773 865 2173 40 2059 2174 41 123 688 40 33 2033 46 2175 40 41 307 33 2176 46 2177 40 41 41 123 688 40 2060 340 2178 41 2060 46 2179 40 40 41 45 62 123 2033 46 2180 40 2181 41 59 2174 46 2182 40 41 59 125 41 59 125 630 123 2174 46 2183 40 41 59 125 125 773 865 2184 40 2059 2185 41 123 2003 2186 61 362 43 2041 46 2187 46 2188 40 41 59 2025 46 2189 40 41 46 2190 40 2186 44 2185 41 59 125 773 865 2191 40 2059 2174 41 123 2192 60 2075 62 2193 61 40 2194 44 2195 44 2196 41 45 62 123 330 688 40 2196 307 33 2103 46 2197 40 41 307 2076 340 2198 41 2076 46 2199 40 2200 41 59 125 59 2201 2202 61 2203 46 2204 40 40 41 45 62 123 688 40 2015 46 2205 46 2206 40 41 309 2021 46 2207 46 2206 40 41 41 123 330 330 792 59 125 2208 46 2209 40 362 41 59 688 40 2019 46 2210 40 41 41 2104 46 2211 40 2193 41 59 630 688 40 2076 340 2212 41 2076 46 2213 40 2214 41 59 2208 46 2215 40 362 43 362 41 59 2216 46 2217 40 362 44 2218 46 2219 41 59 125 44 2011 44 2220 46 2221 41 59 2222 46 2223 40 362 41 59 2109 46 2224 40 2006 58 58 2225 41 59 2103 61 2015 46 2226 40 823 58 58 2227 44 2076 41 59 330 330 330 688 40 33 2033 46 2228 40 41 309 2047 46 2229 40 41 41 123 2227 40 41 59 125 330 2108 61 2230 46 2231 40 2104 44 2103 44 40 2232 44 2233 41 45 62 123 2222 46 2223 40 362 44 2232 44 2233 41 59 792 2232 307 2233 59 125 41 59 2108 46 2234 40 40 2194 44 2195 44 2196 41 45 62 123 688 40 2196 41 123 2202 46 2235 40 41 59 2104 46 2236 40 2193 41 59 688 40 2076 340 2237 41 2076 46 2238 40 2102 41 59 2174 46 2239 40 41 59 125 125 41 59 125 773 865 2240 40 41 123 2241 46 2242 40 362 41 59 2109 46 2243 40 2006 58 58 2244 41 59 2059 2245 61 40 41 45 62 123 2241 46 2242 40 362 41 59 2109 46 2243 40 2006 58 58 2246 41 59 688 40 2103 46 2247 40 41 41 2015 46 2248 40 2249 41 59 688 40 2079 340 2250 41 123 2079 46 2251 40 2252 45 62 123 2019 46 2253 40 2252 41 59 2019 46 2254 40 2252 41 59 688 40 2255 40 41 41 123 688 40 2077 340 2250 41 2077 46 2256 40 41 59 125 630 123 330 330 330 2104 46 2257 40 2249 41 59 125 125 41 59 125 125 59 2017 46 2258 40 2061 44 2062 44 2259 40 41 44 2077 44 2088 44 2245 44 40 41 45 62 123 688 40 2105 41 123 2260 40 41 59 2261 40 41 59 125 125 44 40 41 45 62 2104 46 2262 40 2263 41 41 59 125 773 865 2264 40 41 123 2265 46 2266 40 362 41 59 2013 46 2264 40 2074 44 2087 44 2064 44 2065 44 2066 44 2085 44 2091 44 2093 44 2095 41 59 688 40 2021 46 2267 40 41 46 2268 40 41 323 1501 41 123 2269 40 41 59 2270 40 41 59 125 2037 46 2271 40 41 46 2272 40 40 2273 44 2274 44 2275 41 45 62 2119 40 2275 44 2102 41 41 59 2119 40 2037 46 2271 40 41 46 2268 40 41 44 2102 41 59 2105 61 2276 59 2049 46 2277 40 41 59 125 331 330 331 773 865 2278 40 41 123 330 830 123 2279 60 2003 62 2280 61 2029 46 2281 40 41 59 2023 46 2282 40 41 46 2283 40 41 46 2284 40 2285 45 62 2280 46 2286 40 2285 46 2287 40 41 41 307 2285 46 2288 40 41 323 2289 46 2290 46 2291 41 46 2292 40 2285 45 62 123 2293 2294 61 2285 46 2295 40 41 59 688 40 2294 46 2296 40 41 41 123 2003 2297 61 2298 46 2299 40 362 44 2045 46 2300 40 2294 41 44 2285 46 2301 40 41 44 2285 46 2287 40 41 41 59 2302 46 2303 40 2297 41 59 688 40 2063 340 2304 41 123 2063 46 2305 40 2297 41 59 125 125 125 41 59 125 580 40 2306 2307 41 123 2308 46 2309 40 2307 46 2310 40 41 41 59 688 40 2063 340 2311 41 123 2063 46 2312 40 2307 46 2310 40 41 41 59 125 125 125 773 865 2313 40 41 123 330 330 330 2031 46 2314 40 41 46 2315 40 2316 45 62 123 688 40 2316 46 2317 40 41 46 2318 40 41 41 123 792 59 125 2003 2319 61 2316 46 2317 40 41 46 2320 40 41 59 688 40 2023 46 2321 40 2319 41 323 2322 41 123 2003 2323 61 2324 46 2325 40 362 44 2316 46 2317 40 41 46 2326 40 41 44 2319 41 59 2327 46 2328 40 2323 41 59 688 40 2063 340 2322 41 123 2063 46 2329 40 2323 41 59 125 125 125 41 59 125 64 2057 777 809 2003 2330 40 41 123 2331 2332 61 2333 40 41 59 688 40 33 2332 46 2334 40 41 41 123 792 2335 59 125 830 40 2336 2337 61 744 2336 40 2332 41 41 123 330 688 40 2337 46 2338 40 41 41 123 792 2337 46 2339 40 41 59 125 125 580 40 2340 2341 41 123 2341 46 2342 40 41 59 125 792 2343 59 125 64 2057 777 809 570 2344 40 41 123 2345 2346 61 744 2345 40 2040 46 2347 40 41 44 2005 41 59 792 2346 46 2348 40 41 59 125 777 809 865 2349 40 570 2350 41 123 2351 2352 61 744 2351 40 2040 46 2353 40 41 44 2005 41 59 688 40 2350 41 123 688 40 33 2352 46 2354 40 41 41 123 830 123 688 40 33 2352 46 2355 40 41 41 123 2356 46 2357 40 362 41 59 125 125 580 40 2358 2359 41 123 2359 46 2360 40 41 59 2361 46 2362 40 362 44 2359 46 2363 40 41 41 59 125 125 125 630 123 2352 46 2364 40 41 59 125 125 773 809 2365 2366 40 41 123 792 744 2365 40 2040 46 2367 40 41 44 2004 41 59 125 777 809 570 2368 40 41 123 792 2368 40 2330 40 41 41 59 125 777 809 570 2368 40 2003 2369 41 123 792 2369 340 2370 307 2371 46 2372 40 2369 44 2371 46 2373 41 59 125 777 809 570 2368 40 64 2057 2058 60 2003 62 2097 41 123 2003 2369 61 2330 40 41 59 570 2368 61 2368 40 2369 41 59 688 40 2368 41 123 2374 46 2375 40 362 44 2369 44 2376 46 2377 41 59 688 40 2097 340 2378 41 123 2097 46 2379 40 2369 41 59 125 125 792 2368 59 125 777 809 865 2380 40 41 123 2365 2381 61 2366 40 41 59 688 40 33 2381 46 2382 40 41 41 123 830 123 688 40 33 2381 46 2383 40 41 41 123 2384 46 2385 40 362 41 59 125 125 580 40 2386 2387 41 123 2387 46 2388 40 41 59 2389 46 2390 40 362 44 2387 46 2391 40 41 41 59 125 125 830 40 2392 2393 61 744 2392 40 2381 44 2102 41 41 123 2393 46 2394 40 2395 46 2396 41 59 125 580 40 2397 2398 41 123 2398 46 2399 40 41 59 2400 46 2401 40 362 44 2398 46 2402 40 41 41 59 125 125 773 865 2403 40 41 123 688 40 33 2404 46 2405 40 41 307 2069 340 2406 41 123 2003 2407 61 2404 46 2408 40 41 59 330 330 2069 46 2409 40 2410 46 2411 40 362 44 2407 44 2404 46 2412 40 41 44 2407 41 41 59 125 125 306 773 865 2413 40 41 123 688 40 2414 46 2415 40 41 307 2094 340 2416 41 123 2094 46 2417 40 41 59 125 125 773 865 2418 40 41 123 2003 2419 61 362 59 2035 46 2420 40 41 46 2421 40 40 2422 60 2423 62 41 2424 45 62 123 688 40 33 2019 46 2425 40 41 307 33 2035 46 2426 40 41 307 2033 46 2427 40 2419 41 307 2424 46 2428 40 41 307 2067 340 2429 41 2067 46 2430 40 2419 41 59 125 41 59 125 773 865 2431 40 41 123 688 40 2040 46 2432 40 41 46 2433 40 41 41 123 2434 40 362 44 2068 44 2047 46 2435 40 41 41 59 125 125 773 865 2436 40 41 123 2003 2437 61 362 59 2003 2438 61 362 59 2003 2439 61 362 59 2003 2440 61 362 59 330 2441 40 2042 46 2442 46 2443 44 2437 44 2070 41 59 2441 40 2042 46 2442 46 2444 44 2438 44 2071 41 59 2441 40 2042 46 2442 46 2445 44 2439 44 2072 41 59 2441 40 2042 46 2442 46 2446 44 2440 44 2073 41 59 330 2025 46 2447 40 41 46 2448 40 2449 45 62 123 2450 40 2437 44 2070 44 2451 40 2449 44 2042 46 2442 46 2443 41 41 59 2450 40 2438 44 2071 44 2451 40 2449 44 2042 46 2442 46 2444 41 41 59 2450 40 2439 44 2072 44 2451 40 2449 44 2042 46 2442 46 2445 41 41 59 2450 40 2440 44 2073 44 2451 40 2449 44 2042 46 2442 46 2446 41 41 59 125 41 59 125 773 865 2452 40 2042 46 2453 2454 44 2003 2455 44 2058 60 2003 62 2456 41 123 570 2457 61 2027 46 2458 40 41 46 2459 40 41 46 2460 40 41 46 2461 40 2462 45 62 2463 40 2462 44 2454 41 41 59 2464 40 2455 44 2456 44 2457 41 59 125 773 570 2465 40 2466 2467 44 2042 46 2453 2454 41 123 688 40 2467 702 2468 307 2035 46 2469 40 41 340 2470 41 123 330 330 792 2035 46 2469 40 41 46 2471 40 41 46 2472 40 2473 45 62 2474 46 2475 40 2473 46 2476 40 41 44 2473 46 2477 40 41 41 41 46 2472 40 2473 45 62 2478 46 2479 40 40 40 2468 41 2467 41 46 2480 40 41 44 2043 46 2481 40 2473 46 2482 40 41 41 46 2483 40 41 41 41 46 2484 40 2473 45 62 2043 46 2485 40 2043 46 2481 40 2473 46 2482 40 41 41 41 46 2479 40 2454 41 41 59 125 792 2102 59 125 773 865 2486 40 2003 2455 44 2058 60 2003 62 2456 44 570 2487 41 123 688 40 2487 307 2033 46 2488 40 2455 41 307 2456 340 2489 41 123 2456 46 2490 40 2455 41 59 125 125 773 865 2491 40 41 123 688 40 2040 46 2492 40 41 46 2493 40 41 309 2494 46 2495 40 2496 46 2497 40 2025 46 2498 40 41 46 2499 40 41 41 46 2500 40 41 41 41 123 792 59 125 2501 40 41 59 2029 46 2502 40 41 46 2503 40 40 2504 44 2505 44 2506 41 45 62 123 726 2507 61 40 726 41 2506 59 688 40 2507 323 1500 41 123 2501 40 41 59 125 125 41 59 125 773 865 2508 40 41 123 688 40 2051 46 2509 40 41 46 2510 40 41 46 2511 40 2512 58 58 2513 41 307 2053 46 2509 40 41 46 2510 40 41 46 2511 40 2512 58 58 2513 41 307 2055 46 2509 40 41 46 2510 40 41 46 2511 40 2512 58 58 2513 41 307 2029 46 2514 40 41 46 2515 40 1500 41 46 2516 40 41 41 123 2517 46 2518 40 2096 41 46 2519 40 41 59 125 125 331 330 331 330 777 2520 2521 40 41 123 792 2017 46 2521 40 41 59 125 777 2522 2523 40 41 123 792 2017 46 2523 40 41 59 125 777 2520 2524 40 41 123 792 2017 46 2524 40 41 59 125 777 2520 2525 40 41 123 792 2017 46 2525 40 41 59 125 777 2099 2526 40 41 123 792 2017 46 2526 40 41 59 125 330 777 2520 2527 40 41 123 792 2015 46 2527 40 41 59 125 777 2099 2528 40 41 123 792 2015 46 2528 40 41 59 125 777 2520 2529 40 41 123 792 2015 46 2529 40 41 59 125 777 2520 2530 40 41 123 792 2015 46 2530 40 41 59 125 777 2099 2531 40 41 123 792 2015 46 2531 40 41 59 125 777 2520 2532 40 41 123 792 2015 46 2532 40 41 59 125 125 ,"{'AvgLine': 11, 'CountLine': 696, 'CountStmt': 329, 'MaxNesting': 4, 'AvgLineCode': 10, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 227, 'MaxEssential': 4, 'SumEssential': 66, 'AvgCyclomatic': 1, 'CountLineCode': 556, 'CountStmtDecl': 121, 'MaxCyclomatic': 6, 'SumCyclomatic': 113, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 88, 'CountSemicolon': 228, 'CountDeclMethod': 44, 'CountLineCodeExe': 304, 'CountLineComment': 54, 'CountClassCoupled': 82, 'CountClassDerived': 0, 'CountLineCodeDecl': 195, 'CountDeclMethodAll': 44, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.10', 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 10, 'SumCyclomaticStrict': 139, 'CountDeclClassMethod': 8, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 22, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 96, 'SumCyclomaticModified': 113, 'CountDeclClassVariable': 3, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 22, 'CountDeclInstanceMethod': 36, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 82, 'CountDeclInstanceVariable': 57, 'PercentLackOfCohesionModified': 87}"
2584,Java,"public final class GetToBlockProcess extends BaritoneProcessHelper implements IGetToBlockProcess {

    private BlockOptionalMeta gettingTo;
    private List<BlockPos> knownLocations;
    private List<BlockPos> blacklist; // locations we failed to calc to
    private BlockPos start;

    private int tickCount = 0;
    private int arrivalTickCount = 0;

    public GetToBlockProcess(Baritone baritone) {
        super(baritone);
    }

    @Override
    public void getToBlock(BlockOptionalMeta block) {
        onLostControl();
        gettingTo = block;
        start = ctx.playerFeet();
        blacklist = new ArrayList<>();
        arrivalTickCount = 0;
        rescan(new ArrayList<>(), new GetToBlockCalculationContext(false));
    }

    @Override
    public boolean isActive() {
        return gettingTo != null;
    }

    @Override
    public synchronized PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
        if (knownLocations == null) {
            rescan(new ArrayList<>(), new GetToBlockCalculationContext(false));
        }
        if (knownLocations.isEmpty()) {
            if (Baritone.settings().exploreForBlocks.value && !calcFailed) {
                return new PathingCommand(new GoalRunAway(1, start) {
                    @Override
                    public boolean isInGoal(int x, int y, int z) {
                        return false;
                    }

                    @Override
                    public double heuristic() {
                        return Double.NEGATIVE_INFINITY;
                    }
                }, PathingCommandType.FORCE_REVALIDATE_GOAL_AND_PATH);
            }
            logDirect(""No known locations of "" + gettingTo + "", canceling GetToBlock"");
            if (isSafeToCancel) {
                onLostControl();
            }
            return new PathingCommand(null, PathingCommandType.CANCEL_AND_SET_GOAL);
        }
        Goal goal = new GoalComposite(knownLocations.stream().map(this::createGoal).toArray(Goal[]::new));
        if (calcFailed) {
            if (Baritone.settings().blacklistClosestOnFailure.value) {
                logDirect(""Unable to find any path to "" + gettingTo + "", blacklisting presumably unreachable closest instances..."");
                blacklistClosest();
                return onTick(false, isSafeToCancel); // gamer moment
            } else {
                logDirect(""Unable to find any path to "" + gettingTo + "", canceling GetToBlock"");
                if (isSafeToCancel) {
                    onLostControl();
                }
                return new PathingCommand(goal, PathingCommandType.CANCEL_AND_SET_GOAL);
            }
        }
        int mineGoalUpdateInterval = Baritone.settings().mineGoalUpdateInterval.value;
        if (mineGoalUpdateInterval != 0 && tickCount++ % mineGoalUpdateInterval == 0) { // big brain
            List<BlockPos> current = new ArrayList<>(knownLocations);
            CalculationContext context = new GetToBlockCalculationContext(true);
            Baritone.getExecutor().execute(() -> rescan(current, context));
        }
        if (goal.isInGoal(ctx.playerFeet()) && goal.isInGoal(baritone.getPathingBehavior().pathStart()) && isSafeToCancel) {
            // we're there
            if (rightClickOnArrival(gettingTo.getBlock())) {
                if (rightClick()) {
                    onLostControl();
                    return new PathingCommand(null, PathingCommandType.CANCEL_AND_SET_GOAL);
                }
            } else {
                onLostControl();
                return new PathingCommand(null, PathingCommandType.CANCEL_AND_SET_GOAL);
            }
        }
        return new PathingCommand(goal, PathingCommandType.REVALIDATE_GOAL_AND_PATH);
    }

    // blacklist the closest block and its adjacent blocks
    public synchronized boolean blacklistClosest() {
        List<BlockPos> newBlacklist = new ArrayList<>();
        knownLocations.stream().min(Comparator.comparingDouble(ctx.player()::getDistanceSq)).ifPresent(newBlacklist::add);
        outer:
        while (true) {
            for (BlockPos known : knownLocations) {
                for (BlockPos blacklist : newBlacklist) {
                    if (areAdjacent(known, blacklist)) { // directly adjacent
                        newBlacklist.add(known);
                        knownLocations.remove(known);
                        continue outer;
                    }
                }
            }
            // i can't do break; (codacy gets mad), and i can't do if(true){break}; (codacy gets mad)
            // so i will do this
            switch (newBlacklist.size()) {
                default:
                    break outer;
            }
        }
        logDebug(""Blacklisting unreachable locations "" + newBlacklist);
        blacklist.addAll(newBlacklist);
        return !newBlacklist.isEmpty();
    }

    // this is to signal to MineProcess that we don't care about the allowBreak setting
    // it is NOT to be used to actually calculate a path
    public class GetToBlockCalculationContext extends CalculationContext {

        public GetToBlockCalculationContext(boolean forUseOnAnotherThread) {
            super(GetToBlockProcess.super.baritone, forUseOnAnotherThread);
        }

        @Override
        public double breakCostMultiplierAt(int x, int y, int z, IBlockState current) {
            return 1;
        }
    }

    // safer than direct double comparison from distanceSq
    private boolean areAdjacent(BlockPos posA, BlockPos posB) {
        int diffX = Math.abs(posA.getX() - posB.getX());
        int diffY = Math.abs(posA.getY() - posB.getY());
        int diffZ = Math.abs(posA.getZ() - posB.getZ());
        return (diffX + diffY + diffZ) == 1;
    }

    @Override
    public synchronized void onLostControl() {
        gettingTo = null;
        knownLocations = null;
        start = null;
        blacklist = null;
        baritone.getInputOverrideHandler().clearAllKeys();
    }

    @Override
    public String displayName0() {
        if (knownLocations.isEmpty()) {
            return ""Exploring randomly to find "" + gettingTo + "", no known locations"";
        }
        return ""Get To "" + gettingTo + "", "" + knownLocations.size() + "" known locations"";
    }

    private synchronized void rescan(List<BlockPos> known, CalculationContext context) {
        List<BlockPos> positions = MineProcess.searchWorld(context, new BlockOptionalMetaLookup(gettingTo), 64, known, blacklist, Collections.emptyList());
        positions.removeIf(blacklist::contains);
        knownLocations = positions;
    }

    private Goal createGoal(BlockPos pos) {
        if (walkIntoInsteadOfAdjacent(gettingTo.getBlock())) {
            return new GoalTwoBlocks(pos);
        }
        if (blockOnTopMustBeRemoved(gettingTo.getBlock()) && baritone.bsi.get0(pos.up()).isBlockNormalCube()) {
            return new GoalBlock(pos.up());
        }
        return new GoalGetToBlock(pos);
    }

    private boolean rightClick() {
        for (BlockPos pos : knownLocations) {
            Optional<Rotation> reachable = RotationUtils.reachable(ctx.player(), pos, ctx.playerController().getBlockReachDistance());
            if (reachable.isPresent()) {
                baritone.getLookBehavior().updateTarget(reachable.get(), true);
                if (knownLocations.contains(ctx.getSelectedBlock().orElse(null))) {
                    baritone.getInputOverrideHandler().setInputForceState(Input.CLICK_RIGHT, true); // TODO find some way to right click even if we're in an ESC menu
                    System.out.println(ctx.player().openContainer);
                    if (!(ctx.player().openContainer instanceof ContainerPlayer)) {
                        return true;
                    }
                }
                if (arrivalTickCount++ > 20) {
                    logDirect(""Right click timed out"");
                    return true;
                }
                return false; // trying to right click, will do it next tick or so
            }
        }
        logDirect(""Arrived but failed to right click open"");
        return true;
    }

    private boolean walkIntoInsteadOfAdjacent(Block block) {
        if (!Baritone.settings().enterPortal.value) {
            return false;
        }
        return block == Blocks.PORTAL;
    }

    private boolean rightClickOnArrival(Block block) {
        if (!Baritone.settings().rightClickContainerOnArrival.value) {
            return false;
        }
        return block == Blocks.CRAFTING_TABLE || block == Blocks.FURNACE || block == Blocks.LIT_FURNACE || block == Blocks.ENDER_CHEST || block == Blocks.CHEST || block == Blocks.TRAPPED_CHEST;
    }

    private boolean blockOnTopMustBeRemoved(Block block) {
        if (!rightClickOnArrival(block)) { // only if we plan to actually open it on arrival
            return false;
        }
        // only these chests; you can open a crafting table or furnace even with a block on top
        return block == Blocks.ENDER_CHEST || block == Blocks.CHEST || block == Blocks.TRAPPED_CHEST;
    }
}",1,777 657 587 2000 650 2001 693 2002 123 773 2003 2004 59 773 2005 60 2006 62 2007 59 773 2005 60 2006 62 2008 59 330 773 2006 2009 59 773 704 2010 61 1500 59 773 704 2011 61 1500 59 777 2000 40 2012 2013 41 123 818 40 2013 41 59 125 64 2014 777 865 2015 40 2003 2016 41 123 2017 40 41 59 2004 61 2016 59 2009 61 2018 46 2019 40 41 59 2008 61 744 2020 60 62 40 41 59 2011 61 1500 59 2021 40 744 2020 60 62 40 41 44 744 2022 40 2023 41 41 59 125 64 2014 777 570 2024 40 41 123 792 2004 340 2025 59 125 64 2014 777 821 2026 2027 40 570 2028 44 570 2029 41 123 688 40 2007 323 2030 41 123 2031 40 744 2032 60 62 40 41 44 744 2033 40 2034 41 41 59 125 688 40 2007 46 2035 40 41 41 123 688 40 2012 46 2036 40 41 46 2037 46 2038 307 33 2028 41 123 792 744 2026 40 744 2039 40 1501 44 2009 41 123 64 2014 777 570 2040 40 704 2041 44 704 2042 44 704 2043 41 123 792 2044 59 125 64 2014 777 625 2045 40 41 123 792 2046 46 2047 59 125 125 44 2048 46 2049 41 59 125 2050 40 362 43 2004 43 362 41 59 688 40 2029 41 123 2051 40 41 59 125 792 744 2026 40 2030 44 2052 46 2053 41 59 125 2054 2055 61 744 2056 40 2007 46 2057 40 41 46 2058 40 823 58 58 2059 41 46 2060 40 2054 91 93 58 58 744 41 41 59 688 40 2028 41 123 688 40 2012 46 2061 40 41 46 2062 46 2063 41 123 2064 40 362 43 2004 43 362 41 59 2065 40 41 59 792 2027 40 2066 44 2029 41 59 330 125 630 123 2067 40 362 43 2004 43 362 41 59 688 40 2029 41 123 2068 40 41 59 125 792 744 2026 40 2055 44 2069 46 2070 41 59 125 125 704 2071 61 2012 46 2072 40 41 46 2071 46 2073 59 688 40 2071 340 1500 307 2010 349 37 2071 323 1500 41 123 330 2005 60 2006 62 2074 61 744 2075 60 62 40 2007 41 59 2076 2077 61 744 2078 40 2079 41 59 2012 46 2080 40 41 46 2081 40 40 41 45 62 2082 40 2074 44 2077 41 41 59 125 688 40 2055 46 2083 40 2084 46 2085 40 41 41 307 2055 46 2083 40 2013 46 2086 40 41 46 2087 40 41 41 307 2029 41 123 330 688 40 2088 40 2004 46 2089 40 41 41 41 123 688 40 2090 40 41 41 123 2091 40 41 59 792 744 2026 40 2030 44 2092 46 2093 41 59 125 125 630 123 2094 40 41 59 792 744 2026 40 2030 44 2095 46 2096 41 59 125 125 792 744 2026 40 2055 44 2097 46 2098 41 59 125 330 777 821 570 2099 40 41 123 2005 60 2006 62 2100 61 744 2101 60 62 40 41 59 2007 46 2102 40 41 46 2103 40 2104 46 2105 40 2106 46 2107 40 41 58 58 2108 41 41 46 2109 40 2100 58 58 2110 41 59 2111 58 870 40 2112 41 123 664 40 2006 2113 58 2007 41 123 664 40 2006 2008 58 2100 41 123 688 40 2114 40 2113 44 2008 41 41 123 330 2100 46 2110 40 2113 41 59 2007 46 2115 40 2113 41 59 605 2111 59 125 125 125 330 330 819 40 2100 46 2116 40 41 41 123 613 58 572 2111 59 125 125 2117 40 362 43 2100 41 59 2008 46 2118 40 2100 41 59 792 33 2100 46 2119 40 41 59 125 330 330 777 587 2120 650 2121 123 777 2120 40 570 2122 41 123 818 40 2000 46 818 46 2013 44 2122 41 59 125 64 2014 777 625 2123 40 704 2124 44 704 2125 44 704 2126 44 2127 2128 41 123 792 1501 59 125 125 330 773 570 2129 40 2006 2130 44 2006 2131 41 123 704 2132 61 2133 46 2134 40 2130 46 2135 40 41 45 2131 46 2135 40 41 41 59 704 2136 61 2133 46 2134 40 2130 46 2137 40 41 45 2131 46 2137 40 41 41 59 704 2138 61 2133 46 2134 40 2130 46 2139 40 41 45 2131 46 2139 40 41 41 59 792 40 2132 43 2136 43 2138 41 323 1501 59 125 64 2014 777 821 865 2140 40 41 123 2004 61 2141 59 2007 61 2141 59 2009 61 2141 59 2008 61 2141 59 2013 46 2142 40 41 46 2143 40 41 59 125 64 2014 777 2144 2145 40 41 123 688 40 2007 46 2146 40 41 41 123 792 362 43 2004 43 362 59 125 792 362 43 2004 43 362 43 2007 46 2147 40 41 43 362 59 125 773 821 865 2148 40 2005 60 2006 62 2149 44 2121 2150 41 123 2005 60 2006 62 2151 61 2152 46 2153 40 2150 44 744 2154 40 2004 41 44 1503 44 2149 44 2008 44 2155 46 2156 40 41 41 59 2151 46 2157 40 2008 58 58 2158 41 59 2007 61 2151 59 125 773 2159 2160 40 2006 2161 41 123 688 40 2162 40 2004 46 2163 40 41 41 41 123 792 744 2164 40 2161 41 59 125 688 40 2165 40 2004 46 2163 40 41 41 307 2013 46 2166 46 2167 40 2161 46 2168 40 41 41 46 2169 40 41 41 123 792 744 2170 40 2161 46 2168 40 41 41 59 125 792 744 2171 40 2161 41 59 125 773 570 2172 40 41 123 664 40 2006 2161 58 2007 41 123 2173 60 2174 62 2175 61 2176 46 2175 40 2177 46 2178 40 41 44 2161 44 2177 46 2179 40 41 46 2180 40 41 41 59 688 40 2175 46 2181 40 41 41 123 2013 46 2182 40 41 46 2183 40 2175 46 2184 40 41 44 2185 41 59 688 40 2007 46 2186 40 2177 46 2187 40 41 46 2188 40 2189 41 41 41 123 2013 46 2190 40 41 46 2191 40 2192 46 2193 44 2185 41 59 330 2194 46 2195 46 2196 40 2177 46 2178 40 41 46 2197 41 59 688 40 33 40 2177 46 2178 40 41 46 2197 702 2198 41 41 123 792 2185 59 125 125 688 40 2011 349 62 1503 41 123 2199 40 362 41 59 792 2185 59 125 792 2200 59 330 125 125 2201 40 362 41 59 792 2202 59 125 773 570 2203 40 2204 2016 41 123 688 40 33 2012 46 2205 40 41 46 2206 46 2207 41 123 792 2208 59 125 792 2016 323 2209 46 2210 59 125 773 570 2211 40 2204 2016 41 123 688 40 33 2012 46 2212 40 41 46 2213 46 2214 41 123 792 2215 59 125 792 2016 323 2216 46 2217 309 2016 323 2216 46 2218 309 2016 323 2216 46 2219 309 2016 323 2216 46 2220 309 2016 323 2216 46 2221 309 2016 323 2216 46 2222 59 125 773 570 2223 40 2204 2016 41 123 688 40 33 2211 40 2016 41 41 123 330 792 2224 59 125 330 792 2016 323 2225 46 2226 309 2016 323 2225 46 2227 309 2016 323 2225 46 2228 59 125 125 ,"{'AvgLine': 12, 'CountLine': 216, 'CountStmt': 131, 'MaxNesting': 4, 'AvgLineCode': 12, 'AvgEssential': 2, 'AvgLineBlank': 0, 'CountStmtExe': 102, 'MaxEssential': 8, 'SumEssential': 33, 'AvgCyclomatic': 2, 'CountLineCode': 188, 'CountStmtDecl': 39, 'MaxCyclomatic': 12, 'SumCyclomatic': 41, 'AvgLineComment': 0, 'CountClassBase': 2, 'CountLineBlank': 20, 'CountSemicolon': 81, 'CountDeclMethod': 14, 'CountLineCodeExe': 113, 'CountLineComment': 15, 'CountClassCoupled': 31, 'CountClassDerived': 0, 'CountLineCodeDecl': 40, 'CountDeclMethodAll': 16, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.08', 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 16, 'SumCyclomaticStrict': 53, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 7, 'MaxCyclomaticModified': 12, 'PercentLackOfCohesion': 72, 'SumCyclomaticModified': 42, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 7, 'CountDeclInstanceMethod': 14, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 31, 'CountDeclInstanceVariable': 6, 'PercentLackOfCohesionModified': 69}"
2747,Java,"public class BtcWalletService extends WalletService {
    private static final Logger log = LoggerFactory.getLogger(BtcWalletService.class);

    private final AddressEntryList addressEntryList;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public BtcWalletService(WalletsSetup walletsSetup,
                            AddressEntryList addressEntryList,
                            Preferences preferences,
                            FeeService feeService) {
        super(walletsSetup,
                preferences,
                feeService);

        this.addressEntryList = addressEntryList;

        walletsSetup.addSetupCompletedHandler(() -> {
            wallet = walletsSetup.getBtcWallet();
            addListenersToWallet();

            walletsSetup.getChain().addNewBestBlockListener(block -> chainHeightProperty.set(block.getHeight()));
            chainHeightProperty.set(walletsSetup.getChain().getBestChainHeight());
        });
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Overridden Methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    void decryptWallet(@NotNull KeyParameter key) {
        super.decryptWallet(key);

        addressEntryList.getAddressEntriesAsListImmutable().forEach(e -> {
            DeterministicKey keyPair = e.getKeyPair();
            if (keyPair.isEncrypted())
                e.setDeterministicKey(keyPair.decrypt(key));
        });
        addressEntryList.requestPersistence();
    }

    @Override
    void encryptWallet(KeyCrypterScrypt keyCrypterScrypt, KeyParameter key) {
        super.encryptWallet(keyCrypterScrypt, key);
        addressEntryList.getAddressEntriesAsListImmutable().forEach(e -> {
            DeterministicKey keyPair = e.getKeyPair();
            if (keyPair.isEncrypted())
                e.setDeterministicKey(keyPair.encrypt(keyCrypterScrypt, key));
        });
        addressEntryList.requestPersistence();
    }

    @Override
    String getWalletAsString(boolean includePrivKeys) {
        StringBuilder sb = new StringBuilder();
        getAddressEntryListAsImmutableList().forEach(e -> sb.append(e.toString()).append(""\n""));
        //boolean reallyIncludePrivKeys = includePrivKeys && !wallet.isEncrypted();
        return ""Address entry list:\n"" +
                sb.toString() +
                ""\n\n"" +
                wallet.toString(true, includePrivKeys, this.aesKey, true, true, walletsSetup.getChain()) + ""\n\n"" +
                ""All pubKeys as hex:\n"" +
                wallet.printAllPubKeysAsHex();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Public Methods
    ///////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Burn BSQ txs (some proposal txs, asset listing fee tx, proof of burn tx)
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction completePreparedBurnBsqTx(Transaction preparedBurnFeeTx, byte[] opReturnData)
            throws WalletException, InsufficientMoneyException, TransactionVerificationException {
        return completePreparedProposalTx(preparedBurnFeeTx, opReturnData, null, null);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Proposal txs
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction completePreparedReimbursementRequestTx(Coin issuanceAmount,
                                                              Address issuanceAddress,
                                                              Transaction feeTx,
                                                              byte[] opReturnData)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {
        return completePreparedProposalTx(feeTx, opReturnData, issuanceAmount, issuanceAddress);
    }

    public Transaction completePreparedCompensationRequestTx(Coin issuanceAmount,
                                                             Address issuanceAddress,
                                                             Transaction feeTx,
                                                             byte[] opReturnData)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {
        return completePreparedProposalTx(feeTx, opReturnData, issuanceAmount, issuanceAddress);
    }

    private Transaction completePreparedProposalTx(Transaction feeTx, byte[] opReturnData,
                                                   @Nullable Coin issuanceAmount, @Nullable Address issuanceAddress)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {

        // (BsqFee)tx has following structure:
        // inputs [1-n] BSQ inputs (fee)
        // outputs [0-1] BSQ request fee change output (>= 546 Satoshi)

        // preparedCompensationRequestTx has following structure:
        // inputs [1-n] BSQ inputs for request fee
        // inputs [1-n] BTC inputs for BSQ issuance and miner fee
        // outputs [1] Mandatory BSQ request fee change output (>= 546 Satoshi)
        // outputs [1] Potentially BSQ issuance output (>= 546 Satoshi) - in case of a issuance tx, otherwise that output does not exist
        // outputs [0-1] BTC change output from issuance and miner fee inputs (>= 546 Satoshi)
        // outputs [1] OP_RETURN with opReturnData and amount 0
        // mining fee: BTC mining fee + burned BSQ fee

        Transaction preparedTx = new Transaction(params);
        // Copy inputs from BSQ fee tx
        feeTx.getInputs().forEach(preparedTx::addInput);
        int indexOfBtcFirstInput = feeTx.getInputs().size();

        // Need to be first because issuance is not guaranteed to be valid and would otherwise burn change output!
        // BSQ change outputs from BSQ fee inputs.
        feeTx.getOutputs().forEach(preparedTx::addOutput);

        // For generic proposals there is no issuance output, for compensation and reimburse requests there is
        if (issuanceAmount != null && issuanceAddress != null) {
            // BSQ issuance output
            preparedTx.addOutput(issuanceAmount, issuanceAddress);
        }

        // safety check counter to avoid endless loops
        int counter = 0;
        // estimated size of input sig
        int sigSizePerInput = 106;
        // typical size for a tx with 3 inputs
        int txVsizeWithUnsignedInputs = 300;
        Coin txFeePerVbyte = feeService.getTxFeePerVbyte();

        Address changeAddress = getFreshAddressEntry().getAddress();
        checkNotNull(changeAddress, ""changeAddress must not be null"");

        BtcCoinSelector coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        List<TransactionInput> preparedBsqTxInputs = preparedTx.getInputs();
        List<TransactionOutput> preparedBsqTxOutputs = preparedTx.getOutputs();
        Tuple2<Integer, Integer> numInputs = getNumInputs(preparedTx);
        int numLegacyInputs = numInputs.first;
        int numSegwitInputs = numInputs.second;
        Transaction resultTx = null;
        boolean isFeeOutsideTolerance;
        do {
            counter++;
            if (counter >= 10) {
                checkNotNull(resultTx, ""resultTx must not be null"");
                log.error(""Could not calculate the fee. Tx="" + resultTx);
                break;
            }

            Transaction tx = new Transaction(params);
            preparedBsqTxInputs.forEach(tx::addInput);
            preparedBsqTxOutputs.forEach(tx::addOutput);

            SendRequest sendRequest = SendRequest.forTx(tx);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            // signInputs needs to be false as it would try to sign all inputs (BSQ inputs are not in this wallet)
            sendRequest.signInputs = false;

            sendRequest.fee = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4);

            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;

            sendRequest.coinSelector = coinSelector;
            sendRequest.changeAddress = changeAddress;
            wallet.completeTx(sendRequest);

            resultTx = sendRequest.tx;

            // add OP_RETURN output
            resultTx.addOutput(new TransactionOutput(params, resultTx, Coin.ZERO, ScriptBuilder.createOpReturnScript(opReturnData).getProgram()));

            numInputs = getNumInputs(resultTx);
            numLegacyInputs = numInputs.first;
            numSegwitInputs = numInputs.second;
            txVsizeWithUnsignedInputs = resultTx.getVsize();
            long estimatedFeeAsLong = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4).value;

            // calculated fee must be inside of a tolerance range with tx fee
            isFeeOutsideTolerance = Math.abs(resultTx.getFee().value - estimatedFeeAsLong) > 1000;
        }
        while (isFeeOutsideTolerance);

        // Sign all BTC inputs
        signAllBtcInputs(indexOfBtcFirstInput, resultTx);

        checkWalletConsistency(wallet);
        verifyTransaction(resultTx);

        // printTx(""BTC wallet: Signed tx"", resultTx);
        return resultTx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Blind vote tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    // We add BTC inputs to pay miner fees and sign the BTC tx inputs

    // (BsqFee)tx has following structure:
    // inputs [1-n] BSQ inputs (fee + stake)
    // outputs [1] BSQ stake
    // outputs [0-1] BSQ change output (>= 546 Satoshi)

    // preparedVoteTx has following structure:
    // inputs [1-n] BSQ inputs (fee + stake)
    // inputs [1-n] BTC inputs for miner fee
    // outputs [1] BSQ stake
    // outputs [0-1] BSQ change output (>= 546 Satoshi)
    // outputs [0-1] BTC change output from miner fee inputs (>= 546 Satoshi)
    // outputs [1] OP_RETURN with opReturnData and amount 0
    // mining fee: BTC mining fee + burned BSQ fee
    public Transaction completePreparedBlindVoteTx(Transaction preparedTx, byte[] opReturnData)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {
        // First input index for btc inputs (they get added after bsq inputs)
        return completePreparedBsqTxWithBtcFee(preparedTx, opReturnData);
    }

    private Transaction completePreparedBsqTxWithBtcFee(Transaction preparedTx,
                                                        byte[] opReturnData) throws InsufficientMoneyException, TransactionVerificationException, WalletException {
        // Remember index for first BTC input
        int indexOfBtcFirstInput = preparedTx.getInputs().size();

        Transaction tx = addInputsForMinerFee(preparedTx, opReturnData);
        signAllBtcInputs(indexOfBtcFirstInput, tx);

        checkWalletConsistency(wallet);
        verifyTransaction(tx);

        // printTx(""BTC wallet: Signed tx"", tx);
        return tx;
    }

    private Transaction addInputsForMinerFee(Transaction preparedTx,
                                             byte[] opReturnData) throws InsufficientMoneyException {
        // safety check counter to avoid endless loops
        int counter = 0;
        // estimated size of input sig
        int sigSizePerInput = 106;
        // typical size for a tx with 3 inputs
        int txVsizeWithUnsignedInputs = 300;
        Coin txFeePerVbyte = feeService.getTxFeePerVbyte();

        Address changeAddress = getFreshAddressEntry().getAddress();
        checkNotNull(changeAddress, ""changeAddress must not be null"");

        BtcCoinSelector coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        List<TransactionInput> preparedBsqTxInputs = preparedTx.getInputs();
        List<TransactionOutput> preparedBsqTxOutputs = preparedTx.getOutputs();
        Tuple2<Integer, Integer> numInputs = getNumInputs(preparedTx);
        int numLegacyInputs = numInputs.first;
        int numSegwitInputs = numInputs.second;
        Transaction resultTx = null;
        boolean isFeeOutsideTolerance;
        do {
            counter++;
            if (counter >= 10) {
                checkNotNull(resultTx, ""resultTx must not be null"");
                log.error(""Could not calculate the fee. Tx="" + resultTx);
                break;
            }

            Transaction tx = new Transaction(params);
            preparedBsqTxInputs.forEach(tx::addInput);
            preparedBsqTxOutputs.forEach(tx::addOutput);

            SendRequest sendRequest = SendRequest.forTx(tx);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            // signInputs needs to be false as it would try to sign all inputs (BSQ inputs are not in this wallet)
            sendRequest.signInputs = false;

            sendRequest.fee = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4);
            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;

            sendRequest.coinSelector = coinSelector;
            sendRequest.changeAddress = changeAddress;
            wallet.completeTx(sendRequest);

            resultTx = sendRequest.tx;

            // add OP_RETURN output
            resultTx.addOutput(new TransactionOutput(params, resultTx, Coin.ZERO, ScriptBuilder.createOpReturnScript(opReturnData).getProgram()));

            numInputs = getNumInputs(resultTx);
            numLegacyInputs = numInputs.first;
            numSegwitInputs = numInputs.second;
            txVsizeWithUnsignedInputs = resultTx.getVsize();
            final long estimatedFeeAsLong = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4).value;
            // calculated fee must be inside of a tolerance range with tx fee
            isFeeOutsideTolerance = Math.abs(resultTx.getFee().value - estimatedFeeAsLong) > 1000;
        }
        while (isFeeOutsideTolerance);
        return resultTx;
    }

    private void signAllBtcInputs(int indexOfBtcFirstInput, Transaction tx) throws TransactionVerificationException {
        for (int i = indexOfBtcFirstInput; i < tx.getInputs().size(); i++) {
            TransactionInput input = tx.getInputs().get(i);
            checkArgument(input.getConnectedOutput() != null && input.getConnectedOutput().isMine(wallet),
                    ""input.getConnectedOutput() is not in our wallet. That must not happen."");
            signTransactionInput(wallet, aesKey, tx, input, i);
            checkScriptSig(tx, input, i);
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Vote reveal tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    // We add BTC fees to the prepared reveal tx
    // (BsqFee)tx has following structure:
    // inputs [1] BSQ input (stake)
    // output [1] BSQ unlocked stake

    // preparedVoteTx has following structure:
    // inputs [1] BSQ inputs (stake)
    // inputs [1-n] BTC inputs for miner fee
    // outputs [1] BSQ unlocked stake
    // outputs [0-1] BTC change output from miner fee inputs (>= 546 Satoshi)
    // outputs [1] OP_RETURN with opReturnData and amount 0
    // mining fee: BTC mining fee + burned BSQ fee
    public Transaction completePreparedVoteRevealTx(Transaction preparedTx, byte[] opReturnData)
            throws TransactionVerificationException, WalletException, InsufficientMoneyException {
        return completePreparedBsqTxWithBtcFee(preparedTx, opReturnData);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Add fee input to prepared BSQ send tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction completePreparedSendBsqTx(Transaction preparedBsqTx) throws
            TransactionVerificationException, WalletException, InsufficientMoneyException {
        // preparedBsqTx has following structure:
        // inputs [1-n] BSQ inputs
        // outputs [1] BSQ receiver's output
        // outputs [0-1] BSQ change output

        // We add BTC mining fee. Result tx looks like:
        // inputs [1-n] BSQ inputs
        // inputs [1-n] BTC inputs
        // outputs [1] BSQ receiver's output
        // outputs [0-1] BSQ change output
        // outputs [0-1] BTC change output
        // mining fee: BTC mining fee
        Coin txFeePerVbyte = getTxFeeForWithdrawalPerVbyte();
        return completePreparedBsqTx(preparedBsqTx, null, txFeePerVbyte);
    }

    public Transaction completePreparedSendBsqTx(Transaction preparedBsqTx, Coin txFeePerVbyte) throws
            TransactionVerificationException, WalletException, InsufficientMoneyException {
        return completePreparedBsqTx(preparedBsqTx, null, txFeePerVbyte);
    }

    public Transaction completePreparedBsqTx(Transaction preparedBsqTx,
                                             @Nullable byte[] opReturnData) throws
            TransactionVerificationException, WalletException, InsufficientMoneyException {
        Coin txFeePerVbyte = getTxFeeForWithdrawalPerVbyte();
        return completePreparedBsqTx(preparedBsqTx, opReturnData, txFeePerVbyte);
    }

    public Transaction completePreparedBsqTx(Transaction preparedBsqTx,
                                             @Nullable byte[] opReturnData,
                                             Coin txFeePerVbyte) throws
            TransactionVerificationException, WalletException, InsufficientMoneyException {

        // preparedBsqTx has following structure:
        // inputs [1-n] BSQ inputs
        // outputs [1] BSQ receiver's output
        // outputs [0-1] BSQ change output
        // mining fee: optional burned BSQ fee (only if opReturnData != null)

        // We add BTC mining fee. Result tx looks like:
        // inputs [1-n] BSQ inputs
        // inputs [1-n] BTC inputs
        // outputs [0-1] BSQ receiver's output
        // outputs [0-1] BSQ change output
        // outputs [0-1] BTC change output
        // outputs [0-1] OP_RETURN with opReturnData (only if opReturnData != null)
        // mining fee: BTC mining fee + optional burned BSQ fee (only if opReturnData != null)

        // In case of txs for burned BSQ fees we have no receiver output and it might be that there is no change outputs
        // We need to guarantee that min. 1 valid output is added (OP_RETURN does not count). So we use a higher input
        // for BTC to force an additional change output.

        // safety check counter to avoid endless loops
        int counter = 0;
        // estimated size of input sig
        int sigSizePerInput = 106;
        // typical size for a tx with 2 inputs
        int txVsizeWithUnsignedInputs = 203;
        // In case there are no change outputs we force a change by adding min dust to the BTC input
        Coin forcedChangeValue = Coin.ZERO;

        Address changeAddress = getFreshAddressEntry().getAddress();
        checkNotNull(changeAddress, ""changeAddress must not be null"");

        BtcCoinSelector coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        List<TransactionInput> preparedBsqTxInputs = preparedBsqTx.getInputs();
        List<TransactionOutput> preparedBsqTxOutputs = preparedBsqTx.getOutputs();
        // We don't know at this point what type the btc input would be (segwit/legacy).
        // We use legacy to be on the safe side.
        int numLegacyInputs = preparedBsqTxInputs.size() + 1; // We add 1 for the BTC fee input
        int numSegwitInputs = 0;
        Transaction resultTx = null;
        boolean isFeeOutsideTolerance;
        boolean opReturnIsOnlyOutput;
        do {
            counter++;
            if (counter >= 10) {
                checkNotNull(resultTx, ""resultTx must not be null"");
                log.error(""Could not calculate the fee. Tx="" + resultTx);
                break;
            }

            Transaction tx = new Transaction(params);
            preparedBsqTxInputs.forEach(tx::addInput);

            if (forcedChangeValue.isZero()) {
                preparedBsqTxOutputs.forEach(tx::addOutput);
            } else {
                //TODO test that case
                checkArgument(preparedBsqTxOutputs.size() == 0, ""preparedBsqTxOutputs.size must be null in that code branch"");
                tx.addOutput(forcedChangeValue, changeAddress);
            }

            SendRequest sendRequest = SendRequest.forTx(tx);
            sendRequest.shuffleOutputs = false;
            sendRequest.aesKey = aesKey;
            // signInputs needs to be false as it would try to sign all inputs (BSQ inputs are not in this wallet)
            sendRequest.signInputs = false;

            sendRequest.fee = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4);
            sendRequest.feePerKb = Coin.ZERO;
            sendRequest.ensureMinRequiredFee = false;

            sendRequest.coinSelector = coinSelector;
            sendRequest.changeAddress = changeAddress;
            wallet.completeTx(sendRequest);

            resultTx = sendRequest.tx;

            // We might have the rare case that both inputs matched the required fees, so both did not require
            // a change output.
            // In such cases we need to add artificially a change output (OP_RETURN is not allowed as only output)
            opReturnIsOnlyOutput = resultTx.getOutputs().size() == 0;
            forcedChangeValue = opReturnIsOnlyOutput ? Restrictions.getMinNonDustOutput() : Coin.ZERO;

            // add OP_RETURN output
            if (opReturnData != null)
                resultTx.addOutput(new TransactionOutput(params, resultTx, Coin.ZERO, ScriptBuilder.createOpReturnScript(opReturnData).getProgram()));

            Tuple2<Integer, Integer> numInputs = getNumInputs(resultTx);
            numLegacyInputs = numInputs.first;
            numSegwitInputs = numInputs.second;
            txVsizeWithUnsignedInputs = resultTx.getVsize();
            final long estimatedFeeAsLong = txFeePerVbyte.multiply(txVsizeWithUnsignedInputs +
                    sigSizePerInput * numLegacyInputs +
                    sigSizePerInput * numSegwitInputs / 4).value;
            // calculated fee must be inside of a tolerance range with tx fee
            isFeeOutsideTolerance = Math.abs(resultTx.getFee().value - estimatedFeeAsLong) > 1000;
        }
        while (opReturnIsOnlyOutput ||
                isFeeOutsideTolerance ||
                resultTx.getFee().value < txFeePerVbyte.multiply(resultTx.getVsize()).value);

        // Sign all BTC inputs
        signAllBtcInputs(preparedBsqTxInputs.size(), resultTx);

        checkWalletConsistency(wallet);
        verifyTransaction(resultTx);

        printTx(""BTC wallet: Signed tx"", resultTx);
        return resultTx;
    }

    private Tuple2<Integer, Integer> getNumInputs(Transaction tx) {
        int numLegacyInputs = 0;
        int numSegwitInputs = 0;
        for (TransactionInput input : tx.getInputs()) {
            TransactionOutput connectedOutput = input.getConnectedOutput();
            if (connectedOutput == null || ScriptPattern.isP2PKH(connectedOutput.getScriptPubKey()) ||
                    ScriptPattern.isP2PK(connectedOutput.getScriptPubKey())) {
                // If connectedOutput is null, we don't know here the input type. To avoid underpaying fees,
                // we treat it as a legacy input which will result in a higher fee estimation.
                numLegacyInputs++;
            } else if (ScriptPattern.isP2WPKH(connectedOutput.getScriptPubKey())) {
                numSegwitInputs++;
            } else {
                throw new IllegalArgumentException(""Inputs should spend a P2PKH, P2PK or P2WPKH output"");
            }
        }
        return new Tuple2<>(numLegacyInputs, numSegwitInputs);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Commit tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void commitTx(Transaction tx) {
        wallet.commitTx(tx);
        // printTx(""BTC commit Tx"", tx);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // AddressEntry
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Optional<AddressEntry> getAddressEntry(String offerId,
                                                  @SuppressWarnings(""SameParameterValue"") AddressEntry.Context context) {
        return getAddressEntryListAsImmutableList().stream()
                .filter(e -> offerId.equals(e.getOfferId()))
                .filter(e -> context == e.getContext())
                .findAny();
    }

    public AddressEntry getOrCreateAddressEntry(String offerId, AddressEntry.Context context) {
        Optional<AddressEntry> addressEntry = getAddressEntryListAsImmutableList().stream()
                .filter(e -> offerId.equals(e.getOfferId()))
                .filter(e -> context == e.getContext())
                .findAny();
        if (addressEntry.isPresent()) {
            return addressEntry.get();
        } else {
            // We try to use available and not yet used entries
            Optional<AddressEntry> emptyAvailableAddressEntry = getAddressEntryListAsImmutableList().stream()
                    .filter(e -> AddressEntry.Context.AVAILABLE == e.getContext())
                    .filter(e -> isAddressUnused(e.getAddress()))
                    .filter(e -> Script.ScriptType.P2WPKH.equals(e.getAddress().getOutputScriptType()))
                    .findAny();
            if (emptyAvailableAddressEntry.isPresent() &&
                    context != AddressEntry.Context.MULTI_SIG) {    // always use fresh address for MULTI_SIG GH#5880
                return addressEntryList.swapAvailableToAddressEntryWithOfferId(emptyAvailableAddressEntry.get(), context, offerId);
            } else {
                DeterministicKey key = (DeterministicKey) wallet.findKeyFromAddress(wallet.freshReceiveAddress(Script.ScriptType.P2WPKH));
                AddressEntry entry = new AddressEntry(key, context, offerId, true);
                log.info(""getOrCreateAddressEntry: new AddressEntry={}"", entry);
                addressEntryList.addAddressEntry(entry);
                return entry;
            }
        }
    }

    public AddressEntry getArbitratorAddressEntry() {
        AddressEntry.Context context = AddressEntry.Context.ARBITRATOR;
        Optional<AddressEntry> addressEntry = getAddressEntryListAsImmutableList().stream()
                .filter(e -> context == e.getContext())
                .findAny();
        return getOrCreateAddressEntry(context, addressEntry, false);
    }

    public AddressEntry getFreshAddressEntry() {
        return getFreshAddressEntry(true);
    }

    public AddressEntry getFreshAddressEntry(boolean segwit) {
        AddressEntry.Context context = AddressEntry.Context.AVAILABLE;
        Optional<AddressEntry> addressEntry = getAddressEntryListAsImmutableList().stream()
                .filter(e -> context == e.getContext())
                .filter(e -> isAddressUnused(e.getAddress()))
                .filter(e -> {
                    boolean isSegwitOutputScriptType = Script.ScriptType.P2WPKH.equals(e.getAddress().getOutputScriptType());
                    // We need to ensure that we take only addressEntries which matches our segWit flag
                    return isSegwitOutputScriptType == segwit;
                })
                .findAny();
        return getOrCreateAddressEntry(context, addressEntry, segwit);
    }

    public void recoverAddressEntry(String offerId, String address, AddressEntry.Context context) {
        findAddressEntry(address, AddressEntry.Context.AVAILABLE).ifPresent(addressEntry ->
                addressEntryList.swapAvailableToAddressEntryWithOfferId(addressEntry, context, offerId));
    }

    private AddressEntry getOrCreateAddressEntry(AddressEntry.Context context,
                                                 Optional<AddressEntry> addressEntry,
                                                 boolean segwit) {
        if (addressEntry.isPresent()) {
            return addressEntry.get();
        } else {
            DeterministicKey key;
            if (segwit) {
                key = (DeterministicKey) wallet.findKeyFromAddress(wallet.freshReceiveAddress(Script.ScriptType.P2WPKH));
            } else {
                key = (DeterministicKey) wallet.findKeyFromAddress(wallet.freshReceiveAddress(Script.ScriptType.P2PKH));
            }
            AddressEntry entry = new AddressEntry(key, context, segwit);
            log.info(""getOrCreateAddressEntry: add new AddressEntry {}"", entry);
            addressEntryList.addAddressEntry(entry);
            return entry;
        }
    }

    private Optional<AddressEntry> findAddressEntry(String address, AddressEntry.Context context) {
        return getAddressEntryListAsImmutableList().stream()
                .filter(e -> address.equals(e.getAddressString()))
                .filter(e -> context == e.getContext())
                .findAny();
    }

    public List<AddressEntry> getAvailableAddressEntries() {
        return getAddressEntryListAsImmutableList().stream()
                .filter(addressEntry -> AddressEntry.Context.AVAILABLE == addressEntry.getContext())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getAddressEntriesForOpenOffer() {
        return getAddressEntryListAsImmutableList().stream()
                .filter(addressEntry -> AddressEntry.Context.OFFER_FUNDING == addressEntry.getContext() ||
                        AddressEntry.Context.RESERVED_FOR_TRADE == addressEntry.getContext())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getAddressEntriesForTrade() {
        return getAddressEntryListAsImmutableList().stream()
                .filter(addressEntry -> AddressEntry.Context.MULTI_SIG == addressEntry.getContext() ||
                        AddressEntry.Context.TRADE_PAYOUT == addressEntry.getContext())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getAddressEntries(AddressEntry.Context context) {
        return getAddressEntryListAsImmutableList().stream()
                .filter(addressEntry -> context == addressEntry.getContext())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getFundedAvailableAddressEntries() {
        return getAvailableAddressEntries().stream()
                .filter(addressEntry -> getBalanceForAddress(addressEntry.getAddress()).isPositive())
                .collect(Collectors.toList());
    }

    public List<AddressEntry> getAddressEntryListAsImmutableList() {
        return addressEntryList.getAddressEntriesAsListImmutable();
    }

    public void swapTradeEntryToAvailableEntry(String offerId, AddressEntry.Context context) {
        if (context == AddressEntry.Context.MULTI_SIG) {
            log.error(""swapTradeEntryToAvailableEntry called with MULTI_SIG context. "" +
                    ""This in not permitted as we must not reuse those address entries and there "" +
                    ""are no redeemable funds on that addresses. Only the keys are used for creating "" +
                    ""the Multisig address. offerId={}, context={}"", offerId, context);
            return;
        }

        getAddressEntryListAsImmutableList().stream()
                .filter(e -> offerId.equals(e.getOfferId()))
                .filter(e -> context == e.getContext())
                .forEach(e -> {
                    log.info(""swap addressEntry with address {} and offerId {} from context {} to available"",
                            e.getAddressString(), e.getOfferId(), context);
                    addressEntryList.swapToAvailable(e);
                });
    }

    // When funds from MultiSig address is spent we reset the coinLockedInMultiSig value to 0.
    public void resetCoinLockedInMultiSigAddressEntry(String offerId) {
        setCoinLockedInMultiSigAddressEntry(offerId, 0);
    }

    public void setCoinLockedInMultiSigAddressEntry(String offerId, long value) {
        getAddressEntryListAsImmutableList().stream()
                .filter(e -> AddressEntry.Context.MULTI_SIG == e.getContext())
                .filter(e -> offerId.equals(e.getOfferId()))
                .forEach(addressEntry -> setCoinLockedInMultiSigAddressEntry(addressEntry, value));
    }

    public void setCoinLockedInMultiSigAddressEntry(AddressEntry addressEntry, long value) {
        log.info(""Set coinLockedInMultiSig for addressEntry {} to value {}"", addressEntry, value);
        addressEntryList.setCoinLockedInMultiSigAddressEntry(addressEntry, value);
    }

    public void resetAddressEntriesForOpenOffer(String offerId) {
        log.info(""resetAddressEntriesForOpenOffer offerId={}"", offerId);
        swapTradeEntryToAvailableEntry(offerId, AddressEntry.Context.OFFER_FUNDING);
        swapTradeEntryToAvailableEntry(offerId, AddressEntry.Context.RESERVED_FOR_TRADE);
    }

    public void resetAddressEntriesForPendingTrade(String offerId) {
        // We must not swap MULTI_SIG entries as those addresses are not detected in the isAddressUnused
        // check at getOrCreateAddressEntry and could lead to a reuse of those keys and result in the same 2of2 MS
        // address if same peers trade again.

        // We swap TRADE_PAYOUT to be sure all is cleaned up. There might be cases where a user cannot send the funds
        // to an external wallet directly in the last step of the trade, but the funds are in the Bisq wallet anyway and
        // the dealing with the external wallet is pure UI thing. The user can move the funds to the wallet and then
        // send out the funds to the external wallet. As this cleanup is a rare situation and most users do not use
        // the feature to send out the funds we prefer that strategy (if we keep the address entry it might cause
        // complications in some edge cases after a SPV resync).
        swapTradeEntryToAvailableEntry(offerId, AddressEntry.Context.TRADE_PAYOUT);
    }

    public void swapAnyTradeEntryContextToAvailableEntry(String offerId) {
        resetAddressEntriesForOpenOffer(offerId);
        resetAddressEntriesForPendingTrade(offerId);
    }

    public void saveAddressEntryList() {
        addressEntryList.requestPersistence();
    }

    public DeterministicKey getMultiSigKeyPair(String tradeId, byte[] pubKey) {
        Optional<AddressEntry> multiSigAddressEntryOptional = getAddressEntry(tradeId, AddressEntry.Context.MULTI_SIG);
        DeterministicKey multiSigKeyPair;
        if (multiSigAddressEntryOptional.isPresent()) {
            AddressEntry multiSigAddressEntry = multiSigAddressEntryOptional.get();
            multiSigKeyPair = multiSigAddressEntry.getKeyPair();
            if (!Arrays.equals(pubKey, multiSigAddressEntry.getPubKey())) {
                log.error(""Pub Key from AddressEntry does not match key pair from trade data. Trade ID={}\n"" +
                        ""We try to find the keypair in the wallet with the pubKey we found in the trade data."", tradeId);
                multiSigKeyPair = findKeyFromPubKey(pubKey);
            }
        } else {
            log.error(""multiSigAddressEntry not found for trade ID={}.\n"" +
                    ""We try to find the keypair in the wallet with the pubKey we found in the trade data."", tradeId);
            multiSigKeyPair = findKeyFromPubKey(pubKey);
        }

        return multiSigKeyPair;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Balance
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Coin getSavingWalletBalance() {
        return Coin.valueOf(getFundedAvailableAddressEntries().stream()
                .mapToLong(addressEntry -> getBalanceForAddress(addressEntry.getAddress()).value)
                .sum());
    }

    public Stream<AddressEntry> getAddressEntriesForAvailableBalanceStream() {
        Stream<AddressEntry> availableAndPayout = Stream.concat(getAddressEntries(AddressEntry.Context.TRADE_PAYOUT)
                .stream(), getFundedAvailableAddressEntries().stream());
        Stream<AddressEntry> available = Stream.concat(availableAndPayout,
                getAddressEntries(AddressEntry.Context.ARBITRATOR).stream());
        available = Stream.concat(available, getAddressEntries(AddressEntry.Context.OFFER_FUNDING).stream());
        return available.filter(addressEntry -> getBalanceForAddress(addressEntry.getAddress()).isPositive());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Double spend unconfirmed transaction (unlock in case we got into a tx with a too low mining fee)
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void doubleSpendTransaction(String txId, Runnable resultHandler, ErrorMessageHandler errorMessageHandler)
            throws InsufficientFundsException {
        AddressEntry addressEntry = getFreshAddressEntry();
        checkNotNull(addressEntry.getAddress(), ""addressEntry.getAddress() must not be null"");
        Optional<Transaction> transactionOptional = wallet.getTransactions(true).stream()
                .filter(t -> t.getTxId().toString().equals(txId))
                .findAny();
        if (transactionOptional.isPresent()) {
            Transaction txToDoubleSpend = transactionOptional.get();
            Address toAddress = addressEntry.getAddress();
            final TransactionConfidence.ConfidenceType confidenceType = txToDoubleSpend.getConfidence().getConfidenceType();
            if (confidenceType == TransactionConfidence.ConfidenceType.PENDING) {
                log.debug(""txToDoubleSpend no. of inputs "" + txToDoubleSpend.getInputs().size());

                Transaction newTransaction = new Transaction(params);
                txToDoubleSpend.getInputs().forEach(input -> {
                            final TransactionOutput connectedOutput = input.getConnectedOutput();
                            if (connectedOutput != null &&
                                    connectedOutput.isMine(wallet) &&
                                    connectedOutput.getParentTransaction() != null &&
                                    connectedOutput.getParentTransaction().getConfidence() != null &&
                                    input.getValue() != null) {
                                //if (connectedOutput.getParentTransaction().getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING) {
                                newTransaction.addInput(new TransactionInput(params,
                                        newTransaction,
                                        new byte[]{},
                                        new TransactionOutPoint(params, input.getOutpoint().getIndex(),
                                                new Transaction(params, connectedOutput.getParentTransaction().bitcoinSerialize())),
                                        Coin.valueOf(input.getValue().value)));
                               /* } else {
                                    log.warn(""Confidence of parent tx is not of type BUILDING: ConfidenceType="" +
                                            connectedOutput.getParentTransaction().getConfidence().getConfidenceType());
                                }*/
                            }
                        }
                );

                log.info(""newTransaction no. of inputs "" + newTransaction.getInputs().size());
                log.info(""newTransaction vsize in vkB "" + newTransaction.getVsize() / 1024);

                if (!newTransaction.getInputs().isEmpty()) {
                    Coin amount = Coin.valueOf(newTransaction.getInputs().stream()
                            .mapToLong(input -> input.getValue() != null ? input.getValue().value : 0)
                            .sum());
                    newTransaction.addOutput(amount, toAddress);

                    try {
                        Coin fee;
                        int counter = 0;
                        int txVsize = 0;
                        Transaction tx;
                        SendRequest sendRequest;
                        Coin txFeeForWithdrawalPerVbyte = getTxFeeForWithdrawalPerVbyte();
                        do {
                            counter++;
                            fee = txFeeForWithdrawalPerVbyte.multiply(txVsize);
                            newTransaction.clearOutputs();
                            newTransaction.addOutput(amount.subtract(fee), toAddress);

                            sendRequest = SendRequest.forTx(newTransaction);
                            sendRequest.fee = fee;
                            sendRequest.feePerKb = Coin.ZERO;
                            sendRequest.ensureMinRequiredFee = false;
                            sendRequest.aesKey = aesKey;
                            sendRequest.coinSelector = new BtcCoinSelector(toAddress, preferences.getIgnoreDustThreshold());
                            sendRequest.changeAddress = toAddress;
                            wallet.completeTx(sendRequest);
                            tx = sendRequest.tx;
                            txVsize = tx.getVsize();
                            printTx(""FeeEstimationTransaction"", tx);
                            sendRequest.tx.getOutputs().forEach(o -> log.debug(""Output value "" + o.getValue().toFriendlyString()));
                        }
                        while (feeEstimationNotSatisfied(counter, tx));

                        if (counter == 10)
                            log.error(""Could not calculate the fee. Tx="" + tx);


                        Wallet.SendResult sendResult = null;
                        try {
                            sendRequest = SendRequest.forTx(newTransaction);
                            sendRequest.fee = fee;
                            sendRequest.feePerKb = Coin.ZERO;
                            sendRequest.ensureMinRequiredFee = false;
                            sendRequest.aesKey = aesKey;
                            sendRequest.coinSelector = new BtcCoinSelector(toAddress, preferences.getIgnoreDustThreshold());
                            sendRequest.changeAddress = toAddress;
                            sendResult = wallet.sendCoins(sendRequest);
                        } catch (InsufficientMoneyException e) {
                            // in some cases getFee did not calculate correctly and we still get an InsufficientMoneyException
                            log.warn(""We still have a missing fee "" + (e.missing != null ? e.missing.toFriendlyString() : """"));

                            amount = amount.subtract(e.missing);
                            newTransaction.clearOutputs();
                            newTransaction.addOutput(amount, toAddress);

                            sendRequest = SendRequest.forTx(newTransaction);
                            sendRequest.fee = fee;
                            sendRequest.feePerKb = Coin.ZERO;
                            sendRequest.ensureMinRequiredFee = false;
                            sendRequest.aesKey = aesKey;
                            sendRequest.coinSelector = new BtcCoinSelector(toAddress,
                                    preferences.getIgnoreDustThreshold(), false);
                            sendRequest.changeAddress = toAddress;

                            try {
                                sendResult = wallet.sendCoins(sendRequest);
                                printTx(""FeeEstimationTransaction"", newTransaction);

                                // For better redundancy in case the broadcast via BitcoinJ fails we also
                                // publish the tx via mempool nodes.
                                MemPoolSpaceTxBroadcaster.broadcastTx(sendResult.tx);
                            } catch (InsufficientMoneyException e2) {
                                errorMessageHandler.handleErrorMessage(""We did not get the correct fee calculated. "" + (e2.missing != null ? e2.missing.toFriendlyString() : """"));
                            }
                        }
                        if (sendResult != null) {
                            log.info(""Broadcasting double spending transaction. "" + sendResult.tx);
                            Futures.addCallback(sendResult.broadcastComplete, new FutureCallback<>() {
                                @Override
                                public void onSuccess(Transaction result) {
                                    log.info(""Double spending transaction published. "" + result);
                                    resultHandler.run();
                                }

                                @Override
                                public void onFailure(@NotNull Throwable t) {
                                    log.error(""Broadcasting double spending transaction failed. "" + t.getMessage());
                                    errorMessageHandler.handleErrorMessage(t.getMessage());
                                }
                            }, MoreExecutors.directExecutor());
                        }

                    } catch (InsufficientMoneyException e) {
                        throw new InsufficientFundsException(""The fees for that transaction exceed the available funds "" +
                                ""or the resulting output value is below the min. dust value:\n"" +
                                ""Missing "" + (e.missing != null ? e.missing.toFriendlyString() : ""null""));
                    }
                } else {
                    String errorMessage = ""We could not find inputs we control in the transaction we want to double spend."";
                    log.warn(errorMessage);
                    errorMessageHandler.handleErrorMessage(errorMessage);
                }
            } else if (confidenceType == TransactionConfidence.ConfidenceType.BUILDING) {
                errorMessageHandler.handleErrorMessage(""That transaction is already in the blockchain so we cannot double spend it."");
            } else if (confidenceType == TransactionConfidence.ConfidenceType.DEAD) {
                errorMessageHandler.handleErrorMessage(""One of the inputs of that transaction has been already double spent."");
            }
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Withdrawal Fee calculation
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction getFeeEstimationTransaction(String fromAddress,
                                                   String toAddress,
                                                   Coin amount,
                                                   AddressEntry.Context context)
            throws AddressFormatException, AddressEntryException, InsufficientFundsException {

        Optional<AddressEntry> addressEntry = findAddressEntry(fromAddress, context);
        if (!addressEntry.isPresent())
            throw new AddressEntryException(""WithdrawFromAddress is not found in our wallet."");

        checkNotNull(addressEntry.get().getAddress(), ""addressEntry.get().getAddress() must nto be null"");

        try {
            Coin fee;
            int counter = 0;
            int txVsize = 0;
            Transaction tx;
            Coin txFeeForWithdrawalPerVbyte = getTxFeeForWithdrawalPerVbyte();
            do {
                counter++;
                fee = txFeeForWithdrawalPerVbyte.multiply(txVsize);
                SendRequest sendRequest = getSendRequest(fromAddress, toAddress, amount, fee, aesKey, context);
                wallet.completeTx(sendRequest);
                tx = sendRequest.tx;
                txVsize = tx.getVsize();
                printTx(""FeeEstimationTransaction"", tx);
            }
            while (feeEstimationNotSatisfied(counter, tx));
            if (counter == 10)
                log.error(""Could not calculate the fee. Tx="" + tx);

            return tx;
        } catch (InsufficientMoneyException e) {
            throw new InsufficientFundsException(""The fees for that transaction exceed the available funds "" +
                    ""or the resulting output value is below the min. dust value:\n"" +
                    ""Missing "" + (e.missing != null ? e.missing.toFriendlyString() : ""null""));
        }
    }

    public Transaction getFeeEstimationTransactionForMultipleAddresses(Set<String> fromAddresses,
                                                                       Coin amount)
            throws AddressFormatException, AddressEntryException, InsufficientFundsException {
        Coin txFeeForWithdrawalPerVbyte = getTxFeeForWithdrawalPerVbyte();
        return getFeeEstimationTransactionForMultipleAddresses(fromAddresses, amount, txFeeForWithdrawalPerVbyte);
    }

    public Transaction getFeeEstimationTransactionForMultipleAddresses(Set<String> fromAddresses,
                                                                       Coin amount,
                                                                       Coin txFeeForWithdrawalPerVbyte)
            throws AddressFormatException, AddressEntryException, InsufficientFundsException {
        Set<AddressEntry> addressEntries = fromAddresses.stream()
                .map(address -> {
                    Optional<AddressEntry> addressEntryOptional = findAddressEntry(address, AddressEntry.Context.AVAILABLE);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.OFFER_FUNDING);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.TRADE_PAYOUT);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.ARBITRATOR);
                    return addressEntryOptional;
                })
                .flatMap(Optional::stream)
                .collect(Collectors.toSet());
        if (addressEntries.isEmpty())
            throw new AddressEntryException(""No Addresses for withdraw  found in our wallet"");

        try {
            Coin fee;
            int counter = 0;
            int txVsize = 0;
            Transaction tx;
            do {
                counter++;
                fee = txFeeForWithdrawalPerVbyte.multiply(txVsize);
                // We use a dummy address for the output
                // We don't know here whether the output is segwit or not but we don't care too much because the size of
                // a segwit ouput is just 3 byte smaller than the size of a legacy ouput.
                final String dummyReceiver = SegwitAddress.fromKey(params, new ECKey()).toString();
                SendRequest sendRequest = getSendRequestForMultipleAddresses(fromAddresses, dummyReceiver, amount, fee, null, aesKey);
                wallet.completeTx(sendRequest);
                tx = sendRequest.tx;
                txVsize = tx.getVsize();
                printTx(""FeeEstimationTransactionForMultipleAddresses"", tx);
            }
            while (feeEstimationNotSatisfied(counter, tx));
            if (counter == 10)
                log.error(""Could not calculate the fee. Tx="" + tx);

            return tx;
        } catch (InsufficientMoneyException e) {
            throw new InsufficientFundsException(""The fees for that transaction exceed the available funds "" +
                    ""or the resulting output value is below the min. dust value:\n"" +
                    ""Missing "" + (e.missing != null ? e.missing.toFriendlyString() : ""null""));
        }
    }

    private boolean feeEstimationNotSatisfied(int counter, Transaction tx) {
        return feeEstimationNotSatisfied(counter, tx, getTxFeeForWithdrawalPerVbyte());
    }

    private boolean feeEstimationNotSatisfied(int counter, Transaction tx, Coin txFeeForWithdrawalPerVbyte) {
        long targetFee = txFeeForWithdrawalPerVbyte.multiply(tx.getVsize()).value;
        return counter < 10 &&
                (tx.getFee().value < targetFee ||
                        tx.getFee().value - targetFee > 1000);
    }

    public int getEstimatedFeeTxVsize(List<Coin> outputValues, Coin txFee)
            throws InsufficientMoneyException, AddressFormatException {
        Transaction transaction = new Transaction(params);
        // In reality txs have a mix of segwit/legacy ouputs, but we don't care too much because the size of
        // a segwit ouput is just 3 byte smaller than the size of a legacy ouput.
        Address dummyAddress = SegwitAddress.fromKey(params, new ECKey());
        outputValues.forEach(outputValue -> transaction.addOutput(outputValue, dummyAddress));

        SendRequest sendRequest = SendRequest.forTx(transaction);
        sendRequest.shuffleOutputs = false;
        sendRequest.aesKey = aesKey;
        sendRequest.coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        sendRequest.fee = txFee;
        sendRequest.feePerKb = Coin.ZERO;
        sendRequest.ensureMinRequiredFee = false;
        sendRequest.changeAddress = dummyAddress;
        wallet.completeTx(sendRequest);
        return transaction.getVsize();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Withdrawal Send
    ///////////////////////////////////////////////////////////////////////////////////////////

    public String sendFunds(String fromAddress,
                            String toAddress,
                            Coin receiverAmount,
                            Coin fee,
                            @Nullable KeyParameter aesKey,
                            @SuppressWarnings(""SameParameterValue"") AddressEntry.Context context,
                            @Nullable String memo,
                            FutureCallback<Transaction> callback) throws AddressFormatException,
            AddressEntryException, InsufficientMoneyException {
        SendRequest sendRequest = getSendRequest(fromAddress, toAddress, receiverAmount, fee, aesKey, context);
        Wallet.SendResult sendResult = wallet.sendCoins(sendRequest);
        Futures.addCallback(sendResult.broadcastComplete, callback, MoreExecutors.directExecutor());
        if (memo != null) {
            sendResult.tx.setMemo(memo);
        }

        // For better redundancy in case the broadcast via BitcoinJ fails we also
        // publish the tx via mempool nodes.
        MemPoolSpaceTxBroadcaster.broadcastTx(sendResult.tx);

        return sendResult.tx.getTxId().toString();
    }

    public Transaction sendFundsForMultipleAddresses(Set<String> fromAddresses,
                                                     String toAddress,
                                                     Coin receiverAmount,
                                                     Coin fee,
                                                     @Nullable String changeAddress,
                                                     @Nullable KeyParameter aesKey,
                                                     @Nullable String memo,
                                                     FutureCallback<Transaction> callback) throws AddressFormatException,
            AddressEntryException, InsufficientMoneyException {

        SendRequest request = getSendRequestForMultipleAddresses(fromAddresses, toAddress, receiverAmount, fee, changeAddress, aesKey);
        Wallet.SendResult sendResult = wallet.sendCoins(request);
        Futures.addCallback(sendResult.broadcastComplete, callback, MoreExecutors.directExecutor());
        if (memo != null) {
            sendResult.tx.setMemo(memo);
        }
        printTx(""sendFunds"", sendResult.tx);

        // For better redundancy in case the broadcast via BitcoinJ fails we also
        // publish the tx via mempool nodes.
        MemPoolSpaceTxBroadcaster.broadcastTx(sendResult.tx);

        return sendResult.tx;
    }

    private SendRequest getSendRequest(String fromAddress,
                                       String toAddress,
                                       Coin amount,
                                       Coin fee,
                                       @Nullable KeyParameter aesKey,
                                       AddressEntry.Context context) throws AddressFormatException,
            AddressEntryException {
        Transaction tx = new Transaction(params);
        final Coin receiverAmount = amount.subtract(fee);
        Preconditions.checkArgument(Restrictions.isAboveDust(receiverAmount),
                ""The amount is too low (dust limit)."");
        tx.addOutput(receiverAmount, Address.fromString(params, toAddress));

        SendRequest sendRequest = SendRequest.forTx(tx);
        sendRequest.fee = fee;
        sendRequest.feePerKb = Coin.ZERO;
        sendRequest.ensureMinRequiredFee = false;
        sendRequest.aesKey = aesKey;
        sendRequest.shuffleOutputs = false;
        Optional<AddressEntry> addressEntry = findAddressEntry(fromAddress, context);
        if (!addressEntry.isPresent())
            throw new AddressEntryException(""WithdrawFromAddress is not found in our wallet."");

        checkNotNull(addressEntry.get(), ""addressEntry.get() must not be null"");
        checkNotNull(addressEntry.get().getAddress(), ""addressEntry.get().getAddress() must not be null"");
        sendRequest.coinSelector = new BtcCoinSelector(addressEntry.get().getAddress(), preferences.getIgnoreDustThreshold());
        sendRequest.changeAddress = addressEntry.get().getAddress();
        return sendRequest;
    }

    private SendRequest getSendRequestForMultipleAddresses(Set<String> fromAddresses,
                                                           String toAddress,
                                                           Coin amount,
                                                           Coin fee,
                                                           @Nullable String changeAddress,
                                                           @Nullable KeyParameter aesKey) throws
            AddressFormatException, AddressEntryException {
        Transaction tx = new Transaction(params);
        final Coin netValue = amount.subtract(fee);
        checkArgument(Restrictions.isAboveDust(netValue),
                ""The amount is too low (dust limit)."");

        tx.addOutput(netValue, Address.fromString(params, toAddress));

        SendRequest sendRequest = SendRequest.forTx(tx);
        sendRequest.fee = fee;
        sendRequest.feePerKb = Coin.ZERO;
        sendRequest.ensureMinRequiredFee = false;
        sendRequest.aesKey = aesKey;
        sendRequest.shuffleOutputs = false;
        Set<AddressEntry> addressEntries = fromAddresses.stream()
                .map(address -> {
                    Optional<AddressEntry> addressEntryOptional = findAddressEntry(address, AddressEntry.Context.AVAILABLE);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.OFFER_FUNDING);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.TRADE_PAYOUT);
                    if (!addressEntryOptional.isPresent())
                        addressEntryOptional = findAddressEntry(address, AddressEntry.Context.ARBITRATOR);
                    return addressEntryOptional;
                })
                .flatMap(Optional::stream)
                .collect(Collectors.toSet());
        if (addressEntries.isEmpty())
            throw new AddressEntryException(""No Addresses for withdraw found in our wallet"");

        sendRequest.coinSelector = new BtcCoinSelector(walletsSetup.getAddressesFromAddressEntries(addressEntries),
                preferences.getIgnoreDustThreshold());
        Optional<AddressEntry> addressEntryOptional = Optional.empty();

        if (changeAddress != null)
            addressEntryOptional = findAddressEntry(changeAddress, AddressEntry.Context.AVAILABLE);

        AddressEntry changeAddressAddressEntry = addressEntryOptional.orElseGet(this::getFreshAddressEntry);
        checkNotNull(changeAddressAddressEntry, ""change address must not be null"");
        sendRequest.changeAddress = changeAddressAddressEntry.getAddress();
        return sendRequest;
    }

    // We ignore utxos which are considered dust attacks for spying on users' wallets.
    // The ignoreDustThreshold value is set in the preferences. If not set we use default non dust
    // value of 546 sat.
    @Override
    protected boolean isDustAttackUtxo(TransactionOutput output) {
        return output.getValue().value < preferences.getIgnoreDustThreshold();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Refund payoutTx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Transaction createRefundPayoutTx(Coin buyerAmount,
                                            Coin sellerAmount,
                                            Coin fee,
                                            String buyerAddressString,
                                            String sellerAddressString)
            throws AddressFormatException, InsufficientMoneyException, WalletException, TransactionVerificationException {
        Transaction tx = new Transaction(params);
        Preconditions.checkArgument(buyerAmount.add(sellerAmount).isPositive(),
                ""The sellerAmount + buyerAmount must be positive."");
        // buyerAmount can be 0
        if (buyerAmount.isPositive()) {
            Preconditions.checkArgument(Restrictions.isAboveDust(buyerAmount),
                    ""The buyerAmount is too low (dust limit)."");

            tx.addOutput(buyerAmount, Address.fromString(params, buyerAddressString));
        }
        // sellerAmount can be 0
        if (sellerAmount.isPositive()) {
            Preconditions.checkArgument(Restrictions.isAboveDust(sellerAmount),
                    ""The sellerAmount is too low (dust limit)."");

            tx.addOutput(sellerAmount, Address.fromString(params, sellerAddressString));
        }

        SendRequest sendRequest = SendRequest.forTx(tx);
        sendRequest.fee = fee;
        sendRequest.feePerKb = Coin.ZERO;
        sendRequest.ensureMinRequiredFee = false;
        sendRequest.aesKey = aesKey;
        sendRequest.shuffleOutputs = false;
        sendRequest.coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        sendRequest.changeAddress = getFreshAddressEntry().getAddress();

        checkNotNull(wallet);
        wallet.completeTx(sendRequest);

        Transaction resultTx = sendRequest.tx;
        checkWalletConsistency(wallet);
        verifyTransaction(resultTx);

        WalletService.printTx(""createRefundPayoutTx"", resultTx);

        return resultTx;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Find inputs and change
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Tuple2<List<RawTransactionInput>, Coin> getInputsAndChange(Coin required) throws InsufficientMoneyException {
        BtcCoinSelector coinSelector = new BtcCoinSelector(walletsSetup.getAddressesByContext(AddressEntry.Context.AVAILABLE),
                preferences.getIgnoreDustThreshold());
        CoinSelection coinSelection = coinSelector.select(required, Objects.requireNonNull(wallet).calculateAllSpendCandidates());

        Coin change;
        try {
            change = coinSelector.getChange(required, coinSelection);
        } catch (InsufficientMoneyException e) {
            log.error(""Missing funds in getSellersBtcInputsForBsqSwapTx. missing={}"", e.missing);
            throw new InsufficientMoneyException(e.missing);
        }

        Transaction dummyTx = new Transaction(params);
        coinSelection.gathered.forEach(dummyTx::addInput);
        List<RawTransactionInput> inputs = dummyTx.getInputs().stream()
                .map(RawTransactionInput::new)
                .collect(Collectors.toList());
        return new Tuple2<>(inputs, change);
    }
}",1,777 587 2000 650 2001 123 773 809 657 2002 2003 61 2004 46 2005 40 2000 46 587 41 59 773 657 2006 2007 59 331 330 331 64 2008 777 2000 40 2009 2010 44 2006 2007 44 2011 2012 44 2013 2014 41 123 818 40 2010 44 2012 44 2014 41 59 823 46 2007 61 2007 59 2010 46 2015 40 40 41 45 62 123 2016 61 2010 46 2017 40 41 59 2018 40 41 59 2010 46 2019 40 41 46 2020 40 2021 45 62 2022 46 2023 40 2021 46 2024 40 41 41 41 59 2022 46 2023 40 2010 46 2019 40 41 46 2025 40 41 41 59 125 41 59 125 331 330 331 64 2026 865 2027 40 64 2028 2029 2030 41 123 818 46 2027 40 2030 41 59 2007 46 2031 40 41 46 2032 40 2033 45 62 123 2034 2035 61 2033 46 2036 40 41 59 688 40 2035 46 2037 40 41 41 2033 46 2038 40 2035 46 2039 40 2030 41 41 59 125 41 59 2007 46 2040 40 41 59 125 64 2026 865 2041 40 2042 2043 44 2029 2030 41 123 818 46 2041 40 2043 44 2030 41 59 2007 46 2044 40 41 46 2045 40 2046 45 62 123 2047 2048 61 2046 46 2049 40 41 59 688 40 2048 46 2050 40 41 41 2046 46 2051 40 2048 46 2052 40 2043 44 2030 41 41 59 125 41 59 2007 46 2053 40 41 59 125 64 2026 2054 2055 40 570 2056 41 123 2057 2058 61 744 2057 40 41 59 2059 40 41 46 2060 40 2061 45 62 2058 46 2062 40 2061 46 2063 40 41 41 46 2062 40 362 41 41 59 330 792 362 43 2058 46 2063 40 41 43 362 43 2064 46 2063 40 2065 44 2056 44 823 46 2066 44 2065 44 2065 44 2010 46 2067 40 41 41 43 362 43 362 43 2064 46 2068 40 41 59 125 331 330 331 331 330 331 777 2069 2070 40 2069 2071 44 574 91 93 2072 41 826 2073 44 2074 44 2075 123 792 2076 40 2071 44 2072 44 2077 44 2077 41 59 125 331 330 331 777 2069 2078 40 2079 2080 44 2081 2082 44 2069 2083 44 574 91 93 2072 41 826 2075 44 2073 44 2074 123 792 2084 40 2083 44 2072 44 2080 44 2082 41 59 125 777 2069 2085 40 2079 2080 44 2081 2082 44 2069 2083 44 574 91 93 2072 41 826 2075 44 2073 44 2074 123 792 2086 40 2083 44 2072 44 2080 44 2082 41 59 125 773 2069 2087 40 2069 2083 44 574 91 93 2072 44 64 2088 2079 2080 44 64 2088 2081 2082 41 826 2075 44 2073 44 2074 123 330 330 330 330 330 330 330 330 330 330 330 2069 2089 61 744 2069 40 2090 41 59 330 2083 46 2091 40 41 46 2092 40 2089 58 58 2093 41 59 704 2094 61 2083 46 2091 40 41 46 2095 40 41 59 330 330 2083 46 2096 40 41 46 2092 40 2089 58 58 2097 41 59 330 688 40 2080 340 2098 307 2082 340 2098 41 123 330 2089 46 2097 40 2080 44 2082 41 59 125 330 704 2099 61 1500 59 330 704 2100 61 1504 59 330 704 2101 61 1504 59 2079 2102 61 2014 46 2103 40 41 59 2081 2104 61 2105 40 41 46 2106 40 41 59 2107 40 2104 44 362 41 59 2108 2109 61 744 2108 40 2010 46 2110 40 2111 46 2112 46 2113 41 44 2012 46 2114 40 41 41 59 2115 60 2116 62 2117 61 2089 46 2091 40 41 59 2115 60 2118 62 2119 61 2089 46 2096 40 41 59 2120 60 2121 44 2121 62 2122 61 2123 40 2089 41 59 704 2124 61 2122 46 2125 59 704 2126 61 2122 46 2127 59 2069 2128 61 2098 59 570 2129 59 624 123 2099 349 59 688 40 2099 325 1502 41 123 2107 40 2128 44 362 41 59 2003 46 2130 40 362 43 2128 41 59 572 59 125 2069 2131 61 744 2069 40 2090 41 59 2117 46 2092 40 2131 58 58 2093 41 59 2119 46 2092 40 2131 58 58 2097 41 59 2132 2133 61 2132 46 2134 40 2131 41 59 2133 46 2135 61 2136 59 2133 46 2137 61 2137 59 330 2133 46 2138 61 2136 59 2133 46 2139 61 2102 46 2140 40 2101 43 2100 42 2124 43 2100 42 2126 47 1502 41 59 2133 46 2141 61 2079 46 2142 59 2133 46 2143 61 2136 59 2133 46 2109 61 2109 59 2133 46 2104 61 2104 59 2144 46 2145 40 2133 41 59 2128 61 2133 46 2131 59 330 2128 46 2097 40 744 2118 40 2090 44 2128 44 2079 46 2142 44 2146 46 2147 40 2072 41 46 2148 40 41 41 41 59 2122 61 2123 40 2128 41 59 2124 61 2122 46 2125 59 2126 61 2122 46 2127 59 2101 61 2128 46 2149 40 41 59 726 2150 61 2102 46 2140 40 2101 43 2100 42 2124 43 2100 42 2126 47 1502 41 46 2151 59 330 2129 61 2152 46 2153 40 2128 46 2154 40 41 46 2151 45 2150 41 62 1504 59 125 870 40 2129 41 59 330 2155 40 2094 44 2128 41 59 2156 40 2157 41 59 2158 40 2128 41 59 330 792 2128 59 125 331 330 331 330 330 330 330 330 330 330 330 330 330 330 330 330 777 2069 2159 40 2069 2160 44 574 91 93 2072 41 826 2075 44 2073 44 2074 123 330 792 2161 40 2160 44 2072 41 59 125 773 2069 2162 40 2069 2160 44 574 91 93 2072 41 826 2074 44 2075 44 2073 123 330 704 2163 61 2160 46 2164 40 41 46 2165 40 41 59 2069 2166 61 2167 40 2160 44 2072 41 59 2168 40 2163 44 2166 41 59 2169 40 2170 41 59 2171 40 2166 41 59 330 792 2166 59 125 773 2069 2172 40 2069 2160 44 574 91 93 2072 41 826 2074 123 330 704 2173 61 1500 59 330 704 2174 61 1504 59 330 704 2175 61 1504 59 2079 2176 61 2014 46 2177 40 41 59 2081 2178 61 2179 40 41 46 2180 40 41 59 2181 40 2178 44 362 41 59 2182 2183 61 744 2182 40 2010 46 2184 40 2185 46 2186 46 2187 41 44 2012 46 2188 40 41 41 59 2189 60 2190 62 2191 61 2160 46 2192 40 41 59 2189 60 2193 62 2194 61 2160 46 2195 40 41 59 2196 60 2197 44 2197 62 2198 61 2199 40 2160 41 59 704 2200 61 2198 46 2201 59 704 2202 61 2198 46 2203 59 2069 2204 61 2205 59 570 2206 59 624 123 2173 349 59 688 40 2173 325 1502 41 123 2181 40 2204 44 362 41 59 2003 46 2207 40 362 43 2204 41 59 572 59 125 2069 2208 61 744 2069 40 2209 41 59 2191 46 2210 40 2208 58 58 2211 41 59 2194 46 2210 40 2208 58 58 2212 41 59 2213 2214 61 2213 46 2215 40 2208 41 59 2214 46 2216 61 2217 59 2214 46 2218 61 2218 59 330 2214 46 2219 61 2217 59 2214 46 2220 61 2176 46 2221 40 2175 43 2174 42 2200 43 2174 42 2202 47 1502 41 59 2214 46 2222 61 2079 46 2223 59 2214 46 2224 61 2217 59 2214 46 2183 61 2183 59 2214 46 2178 61 2178 59 2225 46 2226 40 2214 41 59 2204 61 2214 46 2208 59 330 2204 46 2212 40 744 2193 40 2209 44 2204 44 2079 46 2223 44 2227 46 2228 40 2072 41 46 2229 40 41 41 41 59 2198 61 2199 40 2204 41 59 2200 61 2198 46 2201 59 2202 61 2198 46 2203 59 2175 61 2204 46 2230 40 41 59 657 726 2231 61 2176 46 2221 40 2175 43 2174 42 2200 43 2174 42 2202 47 1502 41 46 2232 59 330 2206 61 2233 46 2234 40 2204 46 2235 40 41 46 2232 45 2231 41 62 1504 59 125 870 40 2206 41 59 792 2204 59 125 773 865 2236 40 704 2237 44 2069 2238 41 826 2075 123 664 40 704 2239 61 2237 59 2239 60 2238 46 2240 40 41 46 2241 40 41 59 2239 349 41 123 2242 2243 61 2238 46 2240 40 41 46 2244 40 2239 41 59 2245 40 2243 46 2246 40 41 340 2247 307 2243 46 2246 40 41 46 2248 40 2249 41 44 362 41 59 2250 40 2249 44 2251 44 2238 44 2243 44 2239 41 59 2252 40 2238 44 2243 44 2239 41 59 125 125 331 330 331 330 330 330 330 330 330 330 330 330 330 330 777 2069 2253 40 2069 2160 44 574 91 93 2072 41 826 2075 44 2073 44 2074 123 792 2162 40 2160 44 2072 41 59 125 331 330 331 777 2069 2254 40 2069 2255 41 826 2075 44 2073 44 2074 123 330 330 330 330 330 330 330 330 330 330 330 2079 2256 61 2257 40 41 59 792 2258 40 2255 44 2259 44 2256 41 59 125 777 2069 2254 40 2069 2255 44 2079 2260 41 826 2075 44 2073 44 2074 123 792 2261 40 2255 44 2262 44 2260 41 59 125 777 2069 2263 40 2069 2255 44 64 2088 574 91 93 2072 41 826 2075 44 2073 44 2074 123 2079 2260 61 2264 40 41 59 792 2263 40 2255 44 2072 44 2260 41 59 125 777 2069 2263 40 2069 2255 44 64 2088 574 91 93 2072 44 2079 2260 41 826 2075 44 2073 44 2074 123 330 330 330 330 330 330 330 330 330 330 330 330 330 330 330 330 330 704 2265 61 1500 59 330 704 2266 61 1504 59 330 704 2267 61 1504 59 330 2079 2268 61 2079 46 2269 59 2081 2270 61 2271 40 41 46 2272 40 41 59 2273 40 2270 44 362 41 59 2274 2275 61 744 2274 40 2010 46 2276 40 2277 46 2278 46 2279 41 44 2012 46 2280 40 41 41 59 2281 60 2282 62 2283 61 2255 46 2284 40 41 59 2281 60 2285 62 2286 61 2255 46 2287 40 41 59 330 330 704 2288 61 2283 46 2289 40 41 43 1501 59 330 704 2290 61 1500 59 2069 2291 61 2292 59 570 2293 59 570 2294 59 624 123 2265 349 59 688 40 2265 325 1502 41 123 2273 40 2291 44 362 41 59 2003 46 2295 40 362 43 2291 41 59 572 59 125 2069 2238 61 744 2069 40 2296 41 59 2283 46 2297 40 2238 58 58 2298 41 59 688 40 2268 46 2299 40 41 41 123 2286 46 2297 40 2238 58 58 2300 41 59 125 630 123 330 2301 40 2286 46 2289 40 41 323 1500 44 362 41 59 2238 46 2302 40 2268 44 2270 41 59 125 2303 2304 61 2303 46 2305 40 2238 41 59 2304 46 2306 61 2307 59 2304 46 2308 61 2308 59 330 2304 46 2309 61 2307 59 2304 46 2310 61 2260 46 2311 40 2267 43 2266 42 2288 43 2266 42 2290 47 1502 41 59 2304 46 2312 61 2079 46 2269 59 2304 46 2313 61 2307 59 2304 46 2275 61 2275 59 2304 46 2270 61 2270 59 2314 46 2315 40 2304 41 59 2291 61 2304 46 2238 59 330 330 330 2294 61 2291 46 2287 40 41 46 2289 40 41 323 1500 59 2268 61 2294 63 2316 46 2317 40 41 58 2079 46 2269 59 330 688 40 2072 340 2292 41 2291 46 2318 40 744 2285 40 2296 44 2291 44 2079 46 2269 44 2319 46 2320 40 2072 41 46 2321 40 41 41 41 59 2322 60 2323 44 2323 62 2324 61 2325 40 2291 41 59 2288 61 2324 46 2326 59 2290 61 2324 46 2327 59 2267 61 2291 46 2328 40 41 59 657 726 2329 61 2260 46 2311 40 2267 43 2266 42 2288 43 2266 42 2290 47 1502 41 46 2330 59 330 2293 61 2331 46 2332 40 2291 46 2333 40 41 46 2330 45 2329 41 62 1504 59 125 870 40 2294 309 2293 309 2291 46 2334 40 41 46 2335 60 2260 46 2336 40 2291 46 2337 40 41 41 46 2335 41 59 330 2236 40 2283 46 2289 40 41 44 2291 41 59 2338 40 2339 41 59 2340 40 2291 41 59 2341 40 362 44 2291 41 59 792 2291 59 125 773 2342 60 2343 44 2343 62 2344 40 2069 2238 41 123 704 2345 61 1500 59 704 2346 61 1500 59 664 40 2347 2348 58 2238 46 2349 40 41 41 123 2350 2351 61 2348 46 2352 40 41 59 688 40 2351 323 2353 309 2354 46 2355 40 2351 46 2356 40 41 41 309 2354 46 2357 40 2351 46 2356 40 41 41 41 123 330 330 2345 349 59 125 630 688 40 2354 46 2358 40 2351 46 2356 40 41 41 41 123 2346 349 59 125 630 123 825 744 2359 40 362 41 59 125 125 792 744 2342 60 62 40 2345 44 2346 41 59 125 331 330 331 777 865 2360 40 2069 2238 41 123 2361 46 2360 40 2238 41 59 330 125 331 330 331 777 2362 60 2363 62 2364 40 2054 2365 44 64 2366 40 362 41 2363 46 2367 2368 41 123 792 2369 40 41 46 2370 40 41 46 2371 40 2372 45 62 2365 46 2373 40 2372 46 2374 40 41 41 41 46 2371 40 2372 45 62 2368 323 2372 46 2375 40 41 41 46 2376 40 41 59 125 777 2363 2377 40 2054 2365 44 2363 46 2367 2368 41 123 2362 60 2363 62 2378 61 2379 40 41 46 2380 40 41 46 2381 40 2382 45 62 2365 46 2383 40 2382 46 2384 40 41 41 41 46 2381 40 2382 45 62 2368 323 2382 46 2385 40 41 41 46 2386 40 41 59 688 40 2378 46 2387 40 41 41 123 792 2378 46 2388 40 41 59 125 630 123 330 2362 60 2363 62 2389 61 2379 40 41 46 2380 40 41 46 2381 40 2382 45 62 2363 46 2367 46 2390 323 2382 46 2385 40 41 41 46 2381 40 2382 45 62 2391 40 2382 46 2392 40 41 41 41 46 2381 40 2382 45 62 2393 46 2394 46 2395 46 2383 40 2382 46 2392 40 41 46 2396 40 41 41 41 46 2386 40 41 59 688 40 2389 46 2387 40 41 307 2368 340 2363 46 2367 46 2397 41 123 330 792 2007 46 2398 40 2389 46 2399 40 41 44 2368 44 2365 41 59 125 630 123 2400 2030 61 40 2400 41 2401 46 2402 40 2401 46 2403 40 2393 46 2394 46 2395 41 41 59 2363 2404 61 744 2363 40 2030 44 2368 44 2365 44 2405 41 59 2003 46 2406 40 362 44 2404 41 59 2007 46 2407 40 2404 41 59 792 2404 59 125 125 125 777 2363 2408 40 41 123 2363 46 2367 2368 61 2363 46 2367 46 2409 59 2362 60 2363 62 2410 61 2411 40 41 46 2412 40 41 46 2413 40 2414 45 62 2368 323 2414 46 2415 40 41 41 46 2416 40 41 59 792 2377 40 2368 44 2410 44 2417 41 59 125 777 2363 2418 40 41 123 792 2418 40 2419 41 59 125 777 2363 2418 40 570 2420 41 123 2363 46 2367 2368 61 2363 46 2367 46 2421 59 2362 60 2363 62 2422 61 2423 40 41 46 2424 40 41 46 2425 40 2426 45 62 2368 323 2426 46 2427 40 41 41 46 2425 40 2426 45 62 2428 40 2426 46 2429 40 41 41 41 46 2425 40 2426 45 62 123 570 2430 61 2431 46 2432 46 2433 46 2434 40 2426 46 2429 40 41 46 2435 40 41 41 59 330 792 2430 323 2420 59 125 41 46 2436 40 41 59 792 2377 40 2368 44 2422 44 2420 41 59 125 777 865 2437 40 2054 2365 44 2054 2438 44 2363 46 2367 2368 41 123 2439 40 2438 44 2363 46 2367 46 2440 41 46 2441 40 2442 45 62 2007 46 2443 40 2442 44 2368 44 2365 41 41 59 125 773 2363 2377 40 2363 46 2367 2368 44 2362 60 2363 62 2444 44 570 2420 41 123 688 40 2444 46 2445 40 41 41 123 792 2444 46 2446 40 41 59 125 630 123 2447 2030 59 688 40 2420 41 123 2030 61 40 2447 41 2448 46 2449 40 2448 46 2450 40 2451 46 2452 46 2453 41 41 59 125 630 123 2030 61 40 2447 41 2454 46 2455 40 2454 46 2456 40 2457 46 2458 46 2459 41 41 59 125 2363 2460 61 744 2363 40 2030 44 2368 44 2420 41 59 2003 46 2461 40 362 44 2460 41 59 2007 46 2462 40 2460 41 59 792 2460 59 125 125 773 2362 60 2363 62 2463 40 2054 2438 44 2363 46 2367 2368 41 123 792 2464 40 41 46 2465 40 41 46 2466 40 2467 45 62 2438 46 2468 40 2467 46 2469 40 41 41 41 46 2466 40 2467 45 62 2368 323 2467 46 2470 40 41 41 46 2471 40 41 59 125 777 2472 60 2363 62 2473 40 41 123 792 2474 40 41 46 2475 40 41 46 2476 40 2444 45 62 2363 46 2367 46 2477 323 2444 46 2478 40 41 41 46 2479 40 2480 46 2481 40 41 41 59 125 777 2472 60 2363 62 2482 40 41 123 792 2483 40 41 46 2484 40 41 46 2485 40 2444 45 62 2363 46 2367 46 2486 323 2444 46 2487 40 41 309 2363 46 2367 46 2488 323 2444 46 2487 40 41 41 46 2489 40 2490 46 2491 40 41 41 59 125 777 2472 60 2363 62 2492 40 41 123 792 2493 40 41 46 2494 40 41 46 2495 40 2444 45 62 2363 46 2367 46 2496 323 2444 46 2497 40 41 309 2363 46 2367 46 2498 323 2444 46 2497 40 41 41 46 2499 40 2500 46 2501 40 41 41 59 125 777 2472 60 2363 62 2502 40 2363 46 2367 2368 41 123 792 2503 40 41 46 2504 40 41 46 2505 40 2444 45 62 2368 323 2444 46 2506 40 41 41 46 2507 40 2508 46 2509 40 41 41 59 125 777 2472 60 2363 62 2510 40 41 123 792 2473 40 41 46 2511 40 41 46 2512 40 2444 45 62 2513 40 2444 46 2514 40 41 41 46 2515 40 41 41 46 2516 40 2517 46 2518 40 41 41 59 125 777 2472 60 2363 62 2519 40 41 123 792 2007 46 2520 40 41 59 125 777 865 2521 40 2054 2365 44 2363 46 2367 2368 41 123 688 40 2368 323 2363 46 2367 46 2522 41 123 2003 46 2523 40 362 43 362 43 362 43 362 44 2365 44 2368 41 59 792 59 125 2519 40 41 46 2524 40 41 46 2525 40 2526 45 62 2365 46 2527 40 2526 46 2528 40 41 41 41 46 2525 40 2526 45 62 2368 323 2526 46 2529 40 41 41 46 2530 40 2526 45 62 123 2003 46 2531 40 362 44 2526 46 2532 40 41 44 2526 46 2528 40 41 44 2368 41 59 2007 46 2533 40 2526 41 59 125 41 59 125 330 777 865 2534 40 2054 2365 41 123 2535 40 2365 44 1500 41 59 125 777 865 2536 40 2054 2365 44 726 2537 41 123 2519 40 41 46 2538 40 41 46 2539 40 2540 45 62 2363 46 2367 46 2541 323 2540 46 2542 40 41 41 46 2539 40 2540 45 62 2365 46 2543 40 2540 46 2544 40 41 41 41 46 2545 40 2444 45 62 2536 40 2444 44 2537 41 41 59 125 777 865 2536 40 2363 2444 44 726 2537 41 123 2003 46 2546 40 362 44 2444 44 2537 41 59 2007 46 2536 40 2444 44 2537 41 59 125 777 865 2547 40 2054 2365 41 123 2003 46 2548 40 362 44 2365 41 59 2521 40 2365 44 2363 46 2367 46 2549 41 59 2521 40 2365 44 2363 46 2367 46 2550 41 59 125 777 865 2551 40 2054 2365 41 123 330 330 330 330 330 330 330 330 330 2521 40 2365 44 2363 46 2367 46 2552 41 59 125 777 865 2553 40 2054 2365 41 123 2547 40 2365 41 59 2551 40 2365 41 59 125 777 865 2554 40 41 123 2007 46 2555 40 41 59 125 777 2556 2557 40 2054 2558 44 574 91 93 2559 41 123 2362 60 2363 62 2560 61 2364 40 2558 44 2363 46 2367 46 2561 41 59 2556 2562 59 688 40 2560 46 2563 40 41 41 123 2363 2564 61 2560 46 2565 40 41 59 2562 61 2564 46 2566 40 41 59 688 40 33 2567 46 2568 40 2559 44 2564 46 2569 40 41 41 41 123 2003 46 2570 40 362 43 362 44 2558 41 59 2562 61 2571 40 2559 41 59 125 125 630 123 2003 46 2572 40 362 43 362 44 2558 41 59 2562 61 2573 40 2559 41 59 125 792 2562 59 125 331 330 331 777 2079 2574 40 41 123 792 2079 46 2575 40 2510 40 41 46 2576 40 41 46 2577 40 2444 45 62 2578 40 2444 46 2579 40 41 41 46 2537 41 46 2580 40 41 41 59 125 777 2581 60 2363 62 2582 40 41 123 2581 60 2363 62 2583 61 2581 46 2584 40 2502 40 2363 46 2367 46 2585 41 46 2586 40 41 44 2510 40 41 46 2586 40 41 41 59 2581 60 2363 62 2587 61 2581 46 2584 40 2583 44 2502 40 2363 46 2367 46 2588 41 46 2586 40 41 41 59 2587 61 2581 46 2584 40 2587 44 2502 40 2363 46 2367 46 2589 41 46 2586 40 41 41 59 792 2587 46 2590 40 2444 45 62 2591 40 2444 46 2592 40 41 41 46 2593 40 41 41 59 125 331 330 331 777 865 2594 40 2054 2595 44 2596 2597 44 2598 2599 41 826 2600 123 2363 2444 61 2418 40 41 59 2601 40 2444 46 2602 40 41 44 362 41 59 2362 60 2069 62 2603 61 2604 46 2605 40 2606 41 46 2607 40 41 46 2608 40 2609 45 62 2609 46 2610 40 41 46 2611 40 41 46 2612 40 2595 41 41 46 2613 40 41 59 688 40 2603 46 2614 40 41 41 123 2069 2615 61 2603 46 2616 40 41 59 2081 2617 61 2444 46 2602 40 41 59 657 2618 46 2619 2620 61 2615 46 2621 40 41 46 2622 40 41 59 688 40 2620 323 2618 46 2619 46 2623 41 123 2003 46 2624 40 362 43 2615 46 2625 40 41 46 2626 40 41 41 59 2069 2627 61 744 2069 40 2628 41 59 2615 46 2625 40 41 46 2629 40 2630 45 62 123 657 2631 2632 61 2630 46 2633 40 41 59 688 40 2632 340 2634 307 2632 46 2635 40 2604 41 307 2632 46 2636 40 41 340 2634 307 2632 46 2636 40 41 46 2621 40 41 340 2634 307 2630 46 2637 40 41 340 2634 41 123 330 2627 46 2638 40 744 2639 40 2628 44 2627 44 744 574 91 93 123 125 44 744 2640 40 2628 44 2630 46 2641 40 41 46 2642 40 41 44 744 2069 40 2628 44 2632 46 2636 40 41 46 2643 40 41 41 41 44 2079 46 2644 40 2630 46 2637 40 41 46 2537 41 41 41 59 305 125 125 41 59 2003 46 2645 40 362 43 2627 46 2625 40 41 46 2626 40 41 41 59 2003 46 2645 40 362 43 2627 46 2646 40 41 47 1505 41 59 688 40 33 2627 46 2625 40 41 46 2647 40 41 41 123 2079 2648 61 2079 46 2649 40 2627 46 2625 40 41 46 2607 40 41 46 2650 40 2630 45 62 2630 46 2651 40 41 340 2652 63 2630 46 2651 40 41 46 2537 58 1500 41 46 2653 40 41 41 59 2627 46 2654 40 2648 44 2617 41 59 830 123 2079 2655 59 704 2656 61 1500 59 704 2657 61 1500 59 2069 2238 59 2658 2659 59 2079 2660 61 2661 40 41 59 624 123 2656 349 59 2655 61 2660 46 2662 40 2657 41 59 2627 46 2663 40 41 59 2627 46 2654 40 2648 46 2664 40 2655 41 44 2617 41 59 2659 61 2658 46 2665 40 2627 41 59 2659 46 2655 61 2655 59 2659 46 2666 61 2079 46 2667 59 2659 46 2668 61 2669 59 2659 46 2670 61 2670 59 2659 46 2671 61 744 2672 40 2617 44 2012 46 2673 40 41 41 59 2659 46 2674 61 2617 59 2604 46 2675 40 2659 41 59 2238 61 2659 46 2238 59 2657 61 2238 46 2646 40 41 59 2676 40 362 44 2238 41 59 2659 46 2238 46 2677 40 41 46 2629 40 2678 45 62 2003 46 2624 40 362 43 2678 46 2651 40 41 46 2679 40 41 41 41 59 125 870 40 2680 40 2656 44 2238 41 41 59 688 40 2656 323 1502 41 2003 46 2681 40 362 43 2238 41 59 2682 46 2683 2684 61 2652 59 830 123 2659 61 2658 46 2685 40 2627 41 59 2659 46 2655 61 2655 59 2659 46 2686 61 2079 46 2687 59 2659 46 2688 61 2689 59 2659 46 2690 61 2690 59 2659 46 2691 61 744 2692 40 2617 44 2012 46 2693 40 41 41 59 2659 46 2694 61 2617 59 2684 61 2604 46 2695 40 2659 41 59 125 580 40 2074 2696 41 123 330 2003 46 2697 40 362 43 40 2696 46 2698 340 2652 63 2696 46 2698 46 2699 40 41 58 362 41 41 59 2648 61 2648 46 2700 40 2696 46 2698 41 59 2627 46 2701 40 41 59 2627 46 2654 40 2648 44 2617 41 59 2659 61 2658 46 2702 40 2627 41 59 2659 46 2655 61 2655 59 2659 46 2703 61 2079 46 2704 59 2659 46 2705 61 2706 59 2659 46 2707 61 2707 59 2659 46 2708 61 744 2709 40 2617 44 2012 46 2710 40 41 44 2706 41 59 2659 46 2711 61 2617 59 830 123 2684 61 2604 46 2712 40 2659 41 59 2713 40 362 44 2627 41 59 330 330 2714 46 2715 40 2684 46 2238 41 59 125 580 40 2074 2716 41 123 2599 46 2717 40 362 43 40 2716 46 2698 340 2652 63 2716 46 2698 46 2699 40 41 58 362 41 41 59 125 125 688 40 2684 340 2652 41 123 2003 46 2645 40 362 43 2684 46 2238 41 59 2718 46 2719 40 2684 46 2720 44 744 2721 60 62 40 41 123 64 2026 777 865 2722 40 2069 2723 41 123 2003 46 2645 40 362 43 2723 41 59 2597 46 2724 40 41 59 125 64 2026 777 865 2725 40 64 2028 2726 2609 41 123 2003 46 2681 40 362 43 2609 46 2727 40 41 41 59 2599 46 2728 40 2609 46 2727 40 41 41 59 125 125 44 2729 46 2730 40 41 41 59 125 125 580 40 2074 2731 41 123 825 744 2600 40 362 43 362 43 362 43 40 2731 46 2732 340 2652 63 2731 46 2732 46 2733 40 41 58 362 41 41 59 125 125 630 123 2054 2734 61 362 59 2003 46 2735 40 2734 41 59 2599 46 2736 40 2734 41 59 125 125 630 688 40 2620 323 2618 46 2619 46 2737 41 123 2599 46 2738 40 362 41 59 125 630 688 40 2620 323 2618 46 2619 46 2739 41 123 2599 46 2740 40 362 41 59 125 125 125 331 330 331 777 2069 2741 40 2054 2742 44 2054 2743 44 2079 2744 44 2363 46 2367 2368 41 826 2745 44 2746 44 2600 123 2362 60 2363 62 2444 61 2463 40 2742 44 2368 41 59 688 40 33 2444 46 2747 40 41 41 825 744 2746 40 362 41 59 2748 40 2444 46 2749 40 41 46 2750 40 41 44 362 41 59 830 123 2079 2751 59 704 2752 61 1500 59 704 2753 61 1500 59 2069 2238 59 2079 2754 61 2755 40 41 59 624 123 2752 349 59 2751 61 2754 46 2756 40 2753 41 59 2757 2758 61 2759 40 2742 44 2743 44 2744 44 2751 44 2760 44 2368 41 59 2761 46 2762 40 2758 41 59 2238 61 2758 46 2238 59 2753 61 2238 46 2763 40 41 59 2764 40 362 44 2238 41 59 125 870 40 2765 40 2752 44 2238 41 41 59 688 40 2752 323 1502 41 2003 46 2766 40 362 43 2238 41 59 792 2238 59 125 580 40 2074 2767 41 123 825 744 2600 40 362 43 362 43 362 43 40 2767 46 2768 340 2769 63 2767 46 2768 46 2770 40 41 58 362 41 41 59 125 125 777 2069 2771 40 2772 60 2054 62 2773 44 2079 2744 41 826 2745 44 2746 44 2600 123 2079 2774 61 2775 40 41 59 792 2771 40 2773 44 2744 44 2774 41 59 125 777 2069 2771 40 2772 60 2054 62 2773 44 2079 2744 44 2079 2776 41 826 2745 44 2746 44 2600 123 2772 60 2363 62 2777 61 2773 46 2778 40 41 46 2779 40 2438 45 62 123 2362 60 2363 62 2780 61 2463 40 2438 44 2363 46 2367 46 2781 41 59 688 40 33 2780 46 2782 40 41 41 2780 61 2463 40 2438 44 2363 46 2367 46 2783 41 59 688 40 33 2780 46 2782 40 41 41 2780 61 2463 40 2438 44 2363 46 2367 46 2784 41 59 688 40 33 2780 46 2782 40 41 41 2780 61 2463 40 2438 44 2363 46 2367 46 2785 41 59 792 2780 59 125 41 46 2786 40 2362 58 58 2778 41 46 2787 40 2788 46 2789 40 41 41 59 688 40 2777 46 2790 40 41 41 825 744 2746 40 362 41 59 830 123 2079 2791 59 704 2792 61 1500 59 704 2793 61 1500 59 2069 2238 59 624 123 2792 349 59 2791 61 2776 46 2794 40 2793 41 59 330 330 330 657 2054 2795 61 2796 46 2797 40 2798 44 744 2799 40 41 41 46 2800 40 41 59 2801 2802 61 2803 40 2773 44 2795 44 2744 44 2791 44 2804 44 2805 41 59 2806 46 2807 40 2802 41 59 2238 61 2802 46 2238 59 2793 61 2238 46 2808 40 41 59 2809 40 362 44 2238 41 59 125 870 40 2810 40 2792 44 2238 41 41 59 688 40 2792 323 1502 41 2003 46 2811 40 362 43 2238 41 59 792 2238 59 125 580 40 2074 2812 41 123 825 744 2600 40 362 43 362 43 362 43 40 2812 46 2813 340 2814 63 2812 46 2813 46 2815 40 41 58 362 41 41 59 125 125 773 570 2816 40 704 2817 44 2069 2238 41 123 792 2816 40 2817 44 2238 44 2818 40 41 41 59 125 773 570 2816 40 704 2817 44 2069 2238 44 2079 2776 41 123 726 2819 61 2776 46 2820 40 2238 46 2821 40 41 41 46 2537 59 792 2817 60 1502 307 40 2238 46 2822 40 41 46 2537 60 2819 309 2238 46 2822 40 41 46 2537 45 2819 62 1504 41 59 125 777 704 2823 40 2472 60 2079 62 2824 44 2079 2825 41 826 2074 44 2745 123 2069 2826 61 744 2069 40 2827 41 59 330 330 2081 2828 61 2829 46 2830 40 2827 44 744 2831 40 41 41 59 2824 46 2832 40 2833 45 62 2826 46 2834 40 2833 44 2828 41 41 59 2835 2836 61 2835 46 2837 40 2826 41 59 2836 46 2838 61 2839 59 2836 46 2840 61 2840 59 2836 46 2841 61 744 2842 40 2010 46 2843 40 2363 46 2367 46 2844 41 44 2012 46 2845 40 41 41 59 2836 46 2846 61 2825 59 2836 46 2847 61 2079 46 2848 59 2836 46 2849 61 2839 59 2836 46 2850 61 2828 59 2851 46 2852 40 2836 41 59 792 2826 46 2853 40 41 59 125 331 330 331 777 2054 2854 40 2054 2742 44 2054 2743 44 2079 2855 44 2079 2856 44 64 2088 2029 2857 44 64 2366 40 362 41 2363 46 2367 2368 44 64 2088 2054 2858 44 2859 60 2069 62 2860 41 826 2745 44 2746 44 2074 123 2861 2862 61 2863 40 2742 44 2743 44 2855 44 2856 44 2857 44 2368 41 59 2864 46 2865 2866 61 2867 46 2868 40 2862 41 59 2869 46 2870 40 2866 46 2871 44 2860 44 2872 46 2873 40 41 41 59 688 40 2858 340 2874 41 123 2866 46 2238 46 2875 40 2858 41 59 125 330 330 2876 46 2877 40 2866 46 2238 41 59 792 2866 46 2238 46 2878 40 41 46 2879 40 41 59 125 777 2069 2880 40 2772 60 2054 62 2773 44 2054 2743 44 2079 2855 44 2079 2856 44 64 2088 2054 2881 44 64 2088 2029 2857 44 64 2088 2054 2858 44 2859 60 2069 62 2860 41 826 2745 44 2746 44 2074 123 2882 2883 61 2884 40 2773 44 2743 44 2855 44 2856 44 2881 44 2857 41 59 2885 46 2886 2887 61 2888 46 2889 40 2883 41 59 2890 46 2891 40 2887 46 2892 44 2860 44 2893 46 2894 40 41 41 59 688 40 2858 340 2895 41 123 2887 46 2238 46 2896 40 2858 41 59 125 2897 40 362 44 2887 46 2238 41 59 330 330 2898 46 2899 40 2887 46 2238 41 59 792 2887 46 2238 59 125 773 2900 2901 40 2054 2742 44 2054 2743 44 2079 2744 44 2079 2856 44 64 2088 2029 2857 44 2363 46 2367 2368 41 826 2745 44 2746 123 2069 2238 61 744 2069 40 2902 41 59 657 2079 2855 61 2744 46 2903 40 2856 41 59 2904 46 2905 40 2906 46 2907 40 2855 41 44 362 41 59 2238 46 2908 40 2855 44 2081 46 2909 40 2902 44 2743 41 41 59 2900 2910 61 2900 46 2911 40 2238 41 59 2910 46 2856 61 2856 59 2910 46 2912 61 2079 46 2913 59 2910 46 2914 61 2915 59 2910 46 2857 61 2857 59 2910 46 2916 61 2915 59 2362 60 2363 62 2444 61 2463 40 2742 44 2368 41 59 688 40 33 2444 46 2917 40 41 41 825 744 2746 40 362 41 59 2918 40 2444 46 2919 40 41 44 362 41 59 2918 40 2444 46 2919 40 41 46 2920 40 41 44 362 41 59 2910 46 2921 61 744 2922 40 2444 46 2919 40 41 46 2920 40 41 44 2012 46 2923 40 41 41 59 2910 46 2881 61 2444 46 2919 40 41 46 2920 40 41 59 792 2910 59 125 773 2900 2924 40 2772 60 2054 62 2773 44 2054 2743 44 2079 2744 44 2079 2856 44 64 2088 2054 2881 44 64 2088 2029 2857 41 826 2745 44 2746 123 2069 2238 61 744 2069 40 2925 41 59 657 2079 2926 61 2744 46 2927 40 2856 41 59 2928 40 2929 46 2930 40 2926 41 44 362 41 59 2238 46 2931 40 2926 44 2081 46 2932 40 2925 44 2743 41 41 59 2900 2933 61 2900 46 2934 40 2238 41 59 2933 46 2856 61 2856 59 2933 46 2935 61 2079 46 2936 59 2933 46 2937 61 2938 59 2933 46 2857 61 2857 59 2933 46 2939 61 2938 59 2772 60 2363 62 2940 61 2773 46 2941 40 41 46 2942 40 2438 45 62 123 2362 60 2363 62 2943 61 2463 40 2438 44 2363 46 2367 46 2944 41 59 688 40 33 2943 46 2945 40 41 41 2943 61 2463 40 2438 44 2363 46 2367 46 2946 41 59 688 40 33 2943 46 2945 40 41 41 2943 61 2463 40 2438 44 2363 46 2367 46 2947 41 59 688 40 33 2943 46 2945 40 41 41 2943 61 2463 40 2438 44 2363 46 2367 46 2948 41 59 792 2943 59 125 41 46 2949 40 2362 58 58 2941 41 46 2950 40 2951 46 2952 40 41 41 59 688 40 2940 46 2953 40 41 41 825 744 2746 40 362 41 59 2933 46 2954 61 744 2955 40 2010 46 2956 40 2940 41 44 2012 46 2957 40 41 41 59 2362 60 2363 62 2958 61 2362 46 2959 40 41 59 688 40 2881 340 2960 41 2958 61 2463 40 2881 44 2363 46 2367 46 2961 41 59 2363 2962 61 2958 46 2963 40 823 58 58 2418 41 59 2964 40 2962 44 362 41 59 2933 46 2881 61 2962 46 2965 40 41 59 792 2933 59 125 330 330 330 64 2026 775 570 2966 40 2967 2968 41 123 792 2968 46 2969 40 41 46 2537 60 2012 46 2970 40 41 59 125 331 330 331 777 2069 2971 40 2079 2972 44 2079 2973 44 2079 2856 44 2054 2974 44 2054 2975 41 826 2745 44 2074 44 2073 44 2075 123 2069 2238 61 744 2069 40 2976 41 59 2977 46 2978 40 2972 46 2979 40 2973 41 46 2980 40 41 44 362 41 59 330 688 40 2972 46 2980 40 41 41 123 2977 46 2978 40 2981 46 2982 40 2972 41 44 362 41 59 2238 46 2983 40 2972 44 2081 46 2984 40 2976 44 2974 41 41 59 125 330 688 40 2973 46 2980 40 41 41 123 2977 46 2978 40 2985 46 2986 40 2973 41 44 362 41 59 2238 46 2987 40 2973 44 2081 46 2988 40 2976 44 2975 41 41 59 125 2900 2989 61 2900 46 2990 40 2238 41 59 2989 46 2856 61 2856 59 2989 46 2991 61 2079 46 2992 59 2989 46 2993 61 2994 59 2989 46 2857 61 2857 59 2989 46 2995 61 2994 59 2989 46 2996 61 744 2997 40 2010 46 2998 40 2363 46 2367 46 2999 41 44 2012 46 3000 40 41 41 59 2989 46 2881 61 2418 40 41 46 3001 40 41 59 3002 40 3003 41 59 3003 46 3004 40 2989 41 59 2069 3005 61 2989 46 2238 59 3006 40 3003 41 59 3007 40 3005 41 59 2001 46 3008 40 362 44 3005 41 59 792 3005 59 125 331 330 331 777 2342 60 2472 60 3009 62 44 2079 62 3010 40 2079 3011 41 826 2074 123 3012 3013 61 744 3012 40 2010 46 3014 40 2363 46 2367 46 3015 41 44 2012 46 3016 40 41 41 59 3017 3018 61 3013 46 3019 40 3011 44 3020 46 3021 40 3022 41 46 3023 40 41 41 59 2079 3024 59 830 123 3024 61 3013 46 3025 40 3011 44 3018 41 59 125 580 40 2074 3026 41 123 2003 46 3027 40 362 44 3026 46 3028 41 59 825 744 2074 40 3026 46 3028 41 59 125 2069 3029 61 744 2069 40 3030 41 59 3018 46 3031 46 3032 40 3029 58 58 3033 41 59 2472 60 3009 62 3034 61 3029 46 3035 40 41 46 3036 40 41 46 3037 40 3009 58 58 744 41 46 3038 40 3039 46 3040 40 41 41 59 792 744 2342 60 62 40 3034 44 3024 41 59 125 125 ,"{'AvgLine': 19, 'CountLine': 1282, 'CountStmt': 589, 'MaxNesting': 2, 'AvgLineCode': 15, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 480, 'MaxEssential': 3, 'SumEssential': 104, 'AvgCyclomatic': 1, 'CountLineCode': 906, 'CountStmtDecl': 202, 'MaxCyclomatic': 15, 'SumCyclomatic': 159, 'AvgLineComment': 1, 'CountClassBase': 1, 'CountLineBlank': 192, 'CountSemicolon': 477, 'CountDeclMethod': 58, 'CountLineCodeExe': 657, 'CountLineComment': 186, 'CountClassCoupled': 50, 'CountClassDerived': 0, 'CountLineCodeDecl': 293, 'CountDeclMethodAll': 134, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.21', 'AvgCyclomaticStrict': 2, 'MaxCyclomaticStrict': 15, 'SumCyclomaticStrict': 174, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 43, 'MaxCyclomaticModified': 15, 'PercentLackOfCohesion': 86, 'SumCyclomaticModified': 159, 'CountDeclClassVariable': 1, 'CountDeclMethodDefault': 3, 'CountDeclMethodPrivate': 11, 'CountDeclInstanceMethod': 58, 'CountDeclMethodProtected': 1, 'CountClassCoupledModified': 50, 'CountDeclInstanceVariable': 1, 'PercentLackOfCohesionModified': 13}"
2778,Java,"@Slf4j
public class CurrencyUtil {
    public static void setup() {
        setBaseCurrencyCode(Config.baseCurrencyNetwork().getCurrencyCode());
    }

    private static final AssetRegistry assetRegistry = new AssetRegistry();

    private static String baseCurrencyCode = ""BTC"";

    // Calls to isFiatCurrency and isCryptoCurrency are very frequent so we use a cache of the results.
    // The main improvement was already achieved with using memoize for the source maps, but
    // the caching still reduces performance costs by about 20% for isCryptoCurrency (1752 ms vs 2121 ms) and about 50%
    // for isFiatCurrency calls (1777 ms vs 3467 ms).
    // See: https://github.com/bisq-network/bisq/pull/4955#issuecomment-745302802
    private static final Map<String, Boolean> isFiatCurrencyMap = new ConcurrentHashMap<>();
    private static final Map<String, Boolean> isCryptoCurrencyMap = new ConcurrentHashMap<>();

    private static Supplier<Map<String, FiatCurrency>> fiatCurrencyMapSupplier = Suppliers.memoize(
            CurrencyUtil::createFiatCurrencyMap)::get;
    private static Supplier<Map<String, CryptoCurrency>> cryptoCurrencyMapSupplier = Suppliers.memoize(
            CurrencyUtil::createCryptoCurrencyMap)::get;

    public static void setBaseCurrencyCode(String baseCurrencyCode) {
        CurrencyUtil.baseCurrencyCode = baseCurrencyCode;
    }

    public static Collection<FiatCurrency> getAllSortedFiatCurrencies() {
        return fiatCurrencyMapSupplier.get().values();  // sorted by currency name
    }

    public static Collection<FiatCurrency> getAllSortedFiatCurrencies(Comparator comparator) {
        return (List<FiatCurrency>) getAllSortedFiatCurrencies().stream()
                .sorted(comparator)                     // sorted by comparator param
                .collect(Collectors.toList());
    }

    private static Map<String, FiatCurrency> createFiatCurrencyMap() {
        return CountryUtil.getAllCountries().stream()
                .map(country -> getCurrencyByCountryCode(country.code))
                .sorted(TradeCurrency::compareTo)
                .distinct()
                .collect(Collectors.toMap(TradeCurrency::getCode, Function.identity(), (x, y) -> x, LinkedHashMap::new));
    }

    public static List<FiatCurrency> getMainFiatCurrencies() {
        TradeCurrency defaultTradeCurrency = getDefaultTradeCurrency();
        List<FiatCurrency> list = new ArrayList<>();
        // Top traded currencies
        list.add(new FiatCurrency(""USD""));
        list.add(new FiatCurrency(""EUR""));
        list.add(new FiatCurrency(""GBP""));
        list.add(new FiatCurrency(""CAD""));
        list.add(new FiatCurrency(""AUD""));
        list.add(new FiatCurrency(""RUB""));
        list.add(new FiatCurrency(""INR""));
        list.add(new FiatCurrency(""NGN""));

        list.sort(TradeCurrency::compareTo);

        FiatCurrency defaultFiatCurrency =
                defaultTradeCurrency instanceof FiatCurrency ? (FiatCurrency) defaultTradeCurrency : null;
        if (defaultFiatCurrency != null && list.contains(defaultFiatCurrency)) {
            list.remove(defaultTradeCurrency);
            list.add(0, defaultFiatCurrency);
        }
        return list;
    }

    public static Collection<CryptoCurrency> getAllSortedCryptoCurrencies() {
        return cryptoCurrencyMapSupplier.get().values();
    }

    private static Map<String, CryptoCurrency> createCryptoCurrencyMap() {
        return getSortedAssetStream()
                .map(CurrencyUtil::assetToCryptoCurrency)
                .collect(Collectors.toMap(TradeCurrency::getCode, Function.identity(), (x, y) -> x, LinkedHashMap::new));
    }

    public static Stream<Asset> getSortedAssetStream() {
        return assetRegistry.stream()
                .filter(CurrencyUtil::assetIsNotBaseCurrency)
                .filter(asset -> isNotBsqOrBsqTradingActivated(asset, Config.baseCurrencyNetwork(), DevEnv.isDaoTradingActivated()))
                .filter(asset -> assetMatchesNetworkIfMainnet(asset, Config.baseCurrencyNetwork()))
                .sorted(Comparator.comparing(Asset::getName));
    }

    public static List<CryptoCurrency> getMainCryptoCurrencies() {
        final List<CryptoCurrency> result = new ArrayList<>();
        result.add(new CryptoCurrency(""XRC"", ""XRhodium""));

        if (DevEnv.isDaoTradingActivated())
            result.add(new CryptoCurrency(""BSQ"", ""BSQ""));

        result.add(new CryptoCurrency(""BEAM"", ""Beam""));
        result.add(new CryptoCurrency(""DASH"", ""Dash""));
        result.add(new CryptoCurrency(""DCR"", ""Decred""));
        result.add(new CryptoCurrency(""ETH"", ""Ether""));
        result.add(new CryptoCurrency(""GRIN"", ""Grin""));
        result.add(new CryptoCurrency(""L-BTC"", ""Liquid Bitcoin""));
        result.add(new CryptoCurrency(""LTC"", ""Litecoin""));
        result.add(new CryptoCurrency(""XMR"", ""Monero""));
        result.add(new CryptoCurrency(""NMC"", ""Namecoin""));
        result.add(new CryptoCurrency(""R-BTC"", ""RSK Smart Bitcoin""));
        result.add(new CryptoCurrency(""SF"", ""Siafund""));
        result.add(new CryptoCurrency(""ZEC"", ""Zcash""));
        result.sort(TradeCurrency::compareTo);

        return result;
    }

    public static List<CryptoCurrency> getRemovedCryptoCurrencies() {
        final List<CryptoCurrency> currencies = new ArrayList<>();
        currencies.add(new CryptoCurrency(""BCH"", ""Bitcoin Cash""));
        currencies.add(new CryptoCurrency(""BCHC"", ""Bitcoin Clashic""));
        currencies.add(new CryptoCurrency(""ACH"", ""AchieveCoin""));
        currencies.add(new CryptoCurrency(""SC"", ""Siacoin""));
        currencies.add(new CryptoCurrency(""PPI"", ""PiedPiper Coin""));
        currencies.add(new CryptoCurrency(""PEPECASH"", ""Pepe Cash""));
        currencies.add(new CryptoCurrency(""GRC"", ""Gridcoin""));
        currencies.add(new CryptoCurrency(""LTZ"", ""LitecoinZ""));
        currencies.add(new CryptoCurrency(""ZOC"", ""01coin""));
        currencies.add(new CryptoCurrency(""BURST"", ""Burstcoin""));
        currencies.add(new CryptoCurrency(""STEEM"", ""Steem""));
        currencies.add(new CryptoCurrency(""DAC"", ""DACash""));
        currencies.add(new CryptoCurrency(""RDD"", ""ReddCoin""));
        return currencies;
    }

    public static List<TradeCurrency> getAllAdvancedCashCurrencies() {
        ArrayList<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""USD""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""RUB""),
                new FiatCurrency(""UAH""),
                new FiatCurrency(""KZT""),
                new FiatCurrency(""BRL"")
        ));
        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    public static List<TradeCurrency> getAllMoneyGramCurrencies() {
        ArrayList<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""AED""),
                new FiatCurrency(""ARS""),
                new FiatCurrency(""AUD""),
                new FiatCurrency(""BND""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""CHF""),
                new FiatCurrency(""CZK""),
                new FiatCurrency(""DKK""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""FJD""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""HKD""),
                new FiatCurrency(""HUF""),
                new FiatCurrency(""IDR""),
                new FiatCurrency(""ILS""),
                new FiatCurrency(""INR""),
                new FiatCurrency(""JPY""),
                new FiatCurrency(""KRW""),
                new FiatCurrency(""KWD""),
                new FiatCurrency(""LKR""),
                new FiatCurrency(""MAD""),
                new FiatCurrency(""MGA""),
                new FiatCurrency(""MXN""),
                new FiatCurrency(""MYR""),
                new FiatCurrency(""NOK""),
                new FiatCurrency(""NZD""),
                new FiatCurrency(""OMR""),
                new FiatCurrency(""PEN""),
                new FiatCurrency(""PGK""),
                new FiatCurrency(""PHP""),
                new FiatCurrency(""PKR""),
                new FiatCurrency(""PLN""),
                new FiatCurrency(""SAR""),
                new FiatCurrency(""SBD""),
                new FiatCurrency(""SCR""),
                new FiatCurrency(""SEK""),
                new FiatCurrency(""SGD""),
                new FiatCurrency(""THB""),
                new FiatCurrency(""TOP""),
                new FiatCurrency(""TRY""),
                new FiatCurrency(""TWD""),
                new FiatCurrency(""USD""),
                new FiatCurrency(""VND""),
                new FiatCurrency(""VUV""),
                new FiatCurrency(""WST""),
                new FiatCurrency(""XOF""),
                new FiatCurrency(""XPF""),
                new FiatCurrency(""ZAR"")
        ));

        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    // https://support.uphold.com/hc/en-us/articles/202473803-Supported-currencies
    public static List<TradeCurrency> getAllUpholdCurrencies() {
        ArrayList<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""USD""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""CNY""),
                new FiatCurrency(""JPY""),
                new FiatCurrency(""CHF""),
                new FiatCurrency(""INR""),
                new FiatCurrency(""MXN""),
                new FiatCurrency(""AUD""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""HKD""),
                new FiatCurrency(""NZD""),
                new FiatCurrency(""SGD""),
                new FiatCurrency(""KES""),
                new FiatCurrency(""ILS""),
                new FiatCurrency(""DKK""),
                new FiatCurrency(""NOK""),
                new FiatCurrency(""SEK""),
                new FiatCurrency(""PLN""),
                new FiatCurrency(""ARS""),
                new FiatCurrency(""BRL""),
                new FiatCurrency(""AED""),
                new FiatCurrency(""PHP"")
        ));

        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    // https://github.com/bisq-network/proposals/issues/243
    public static List<TradeCurrency> getAllTransferwiseCurrencies() {
        ArrayList<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""ARS""),
                new FiatCurrency(""AUD""),
                new FiatCurrency(""XOF""),
                new FiatCurrency(""BGN""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""CLP""),
                new FiatCurrency(""HRK""),
                new FiatCurrency(""CZK""),
                new FiatCurrency(""DKK""),
                new FiatCurrency(""EGP""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""GEL""),
                new FiatCurrency(""HKD""),
                new FiatCurrency(""HUF""),
                new FiatCurrency(""IDR""),
                new FiatCurrency(""ILS""),
                new FiatCurrency(""JPY""),
                new FiatCurrency(""KES""),
                new FiatCurrency(""MYR""),
                new FiatCurrency(""MXN""),
                new FiatCurrency(""MAD""),
                new FiatCurrency(""NPR""),
                new FiatCurrency(""NZD""),
                new FiatCurrency(""NOK""),
                new FiatCurrency(""PKR""),
                new FiatCurrency(""PEN""),
                new FiatCurrency(""PHP""),
                new FiatCurrency(""PLN""),
                new FiatCurrency(""RON""),
                new FiatCurrency(""RUB""),
                new FiatCurrency(""SGD""),
                new FiatCurrency(""ZAR""),
                new FiatCurrency(""KRW""),
                new FiatCurrency(""SEK""),
                new FiatCurrency(""CHF""),
                new FiatCurrency(""THB""),
                new FiatCurrency(""TRY""),
                new FiatCurrency(""UGX""),
                new FiatCurrency(""AED""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""VND""),
                new FiatCurrency(""ZMW"")
        ));

        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    // https://github.com/bisq-network/growth/issues/233
    public static List<TradeCurrency> getAllPayseraCurrencies() {
        ArrayList<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""AUD""),
                new FiatCurrency(""BGN""),
                new FiatCurrency(""BYN""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""CHF""),
                new FiatCurrency(""CNY""),
                new FiatCurrency(""CZK""),
                new FiatCurrency(""DKK""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""GEL""),
                new FiatCurrency(""HKD""),
                new FiatCurrency(""HRK""),
                new FiatCurrency(""HUF""),
                new FiatCurrency(""ILS""),
                new FiatCurrency(""INR""),
                new FiatCurrency(""JPY""),
                new FiatCurrency(""KZT""),
                new FiatCurrency(""MXN""),
                new FiatCurrency(""NOK""),
                new FiatCurrency(""NZD""),
                new FiatCurrency(""PHP""),
                new FiatCurrency(""PLN""),
                new FiatCurrency(""RON""),
                new FiatCurrency(""RSD""),
                new FiatCurrency(""RUB""),
                new FiatCurrency(""SEK""),
                new FiatCurrency(""SGD""),
                new FiatCurrency(""THB""),
                new FiatCurrency(""TRY""),
                new FiatCurrency(""USD""),
                new FiatCurrency(""ZAR"")
        ));

        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    // https://github.com/bisq-network/growth/issues/235
    public static List<TradeCurrency> getAllPaxumCurrencies() {
        ArrayList<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""USD""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""DKK""),
                new FiatCurrency(""CZK""),
                new FiatCurrency(""AUD""),
                new FiatCurrency(""ZAR""),
                new FiatCurrency(""THB""),
                new FiatCurrency(""CHF""),
                new FiatCurrency(""SEK""),
                new FiatCurrency(""RON""),
                new FiatCurrency(""PLN""),
                new FiatCurrency(""NZD""),
                new FiatCurrency(""NOK""),
                new FiatCurrency(""INR""),
                new FiatCurrency(""IDR""),
                new FiatCurrency(""HUF""),
                new FiatCurrency(""GBP"")
        ));

        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    public static List<TradeCurrency> getAllAmazonGiftCardCurrencies() {
        List<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""AUD""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""INR""),
                new FiatCurrency(""JPY""),
                new FiatCurrency(""SAR""),
                new FiatCurrency(""SEK""),
                new FiatCurrency(""SGD""),
                new FiatCurrency(""TRY""),
                new FiatCurrency(""USD"")
        ));
        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    public static List<TradeCurrency> getAllCapitualCurrencies() {
        return new ArrayList<>(Arrays.asList(
                new FiatCurrency(""BRL""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""USD"")
        ));
    }

    // https://github.com/bisq-network/growth/issues/231
    public static List<TradeCurrency> getAllCelPayCurrencies() {
        return new ArrayList<>(Arrays.asList(
                new FiatCurrency(""AUD""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""HKD""),
                new FiatCurrency(""USD"")
        ));
    }

    // https://github.com/bisq-network/growth/issues/227
    public static List<TradeCurrency> getAllMoneseCurrencies() {
        return new ArrayList<>(Arrays.asList(
                new FiatCurrency(""EUR""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""RON"")
        ));
    }

    // https://github.com/bisq-network/growth/issues/223
    public static List<TradeCurrency> getAllVerseCurrencies() {
        return new ArrayList<>(Arrays.asList(
                new FiatCurrency(""DKK""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""HUF""),
                new FiatCurrency(""PLN""),
                new FiatCurrency(""SEK"")
        ));
    }

    // https://www.revolut.com/help/getting-started/exchanging-currencies/what-fiat-currencies-are-supported-for-holding-and-exchange
    public static List<TradeCurrency> getAllRevolutCurrencies() {
        ArrayList<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""AED""),
                new FiatCurrency(""AUD""),
                new FiatCurrency(""BGN""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""CHF""),
                new FiatCurrency(""CZK""),
                new FiatCurrency(""DKK""),
                new FiatCurrency(""EUR""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""HKD""),
                new FiatCurrency(""HRK""),
                new FiatCurrency(""HUF""),
                new FiatCurrency(""ILS""),
                new FiatCurrency(""ISK""),
                new FiatCurrency(""JPY""),
                new FiatCurrency(""MAD""),
                new FiatCurrency(""MXN""),
                new FiatCurrency(""NOK""),
                new FiatCurrency(""NZD""),
                new FiatCurrency(""PLN""),
                new FiatCurrency(""QAR""),
                new FiatCurrency(""RON""),
                new FiatCurrency(""RSD""),
                new FiatCurrency(""RUB""),
                new FiatCurrency(""SAR""),
                new FiatCurrency(""SEK""),
                new FiatCurrency(""SGD""),
                new FiatCurrency(""THB""),
                new FiatCurrency(""TRY""),
                new FiatCurrency(""USD""),
                new FiatCurrency(""ZAR"")
        ));

        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    public static List<TradeCurrency> getMatureMarketCurrencies() {
        ArrayList<TradeCurrency> currencies = new ArrayList<>(Arrays.asList(
                new FiatCurrency(""EUR""),
                new FiatCurrency(""USD""),
                new FiatCurrency(""GBP""),
                new FiatCurrency(""CAD""),
                new FiatCurrency(""AUD""),
                new FiatCurrency(""BRL"")
        ));
        currencies.sort(Comparator.comparing(TradeCurrency::getCode));
        return currencies;
    }

    public static boolean isFiatCurrency(String currencyCode) {
        if (currencyCode != null && isFiatCurrencyMap.containsKey(currencyCode)) {
            return isFiatCurrencyMap.get(currencyCode);
        }

        try {
            boolean isFiatCurrency = currencyCode != null
                    && !currencyCode.isEmpty()
                    && !isCryptoCurrency(currencyCode)
                    && Currency.getInstance(currencyCode) != null;

            if (currencyCode != null) {
                isFiatCurrencyMap.put(currencyCode, isFiatCurrency);
            }

            return isFiatCurrency;
        } catch (Throwable t) {
            if (currencyCode != null) {
                isFiatCurrencyMap.put(currencyCode, false);
            }
            return false;
        }
    }

    public static Optional<FiatCurrency> getFiatCurrency(String currencyCode) {
        return Optional.ofNullable(fiatCurrencyMapSupplier.get().get(currencyCode));
    }

    /**
     * We return true if it is BTC or any of our currencies available in the assetRegistry.
     * For removed assets it would fail as they are not found but we don't want to conclude that they are fiat then.
     * As the caller might not deal with the case that a currency can be neither a cryptoCurrency nor Fiat if not found
     * we return true as well in case we have no fiat currency for the code.
     *
     * As we use a boolean result for isCryptoCurrency and isFiatCurrency we do not treat missing currencies correctly.
     * To throw an exception might be an option but that will require quite a lot of code change, so we don't do that
     * for the moment, but could be considered for the future. Another maybe better option is to introduce an enum which
     * contains 3 entries (CryptoCurrency, Fiat, Undefined).
     */
    public static boolean isCryptoCurrency(String currencyCode) {
        if (currencyCode != null && isCryptoCurrencyMap.containsKey(currencyCode)) {
            return isCryptoCurrencyMap.get(currencyCode);
        }

        boolean isCryptoCurrency;
        if (currencyCode == null) {
            // Some tests call that method with null values. Should be fixed in the tests but to not break them return false.
            isCryptoCurrency = false;
        } else if (currencyCode.equals(""BTC"")) {
            // BTC is not part of our assetRegistry so treat it extra here. Other old base currencies (LTC, DOGE, DASH)
            // are not supported anymore so we can ignore that case.
            isCryptoCurrency = true;
        } else if (getCryptoCurrency(currencyCode).isPresent()) {
            // If we find the code in our assetRegistry we return true.
            // It might be that an asset was removed from the assetsRegistry, we deal with such cases below by checking if
            // it is a fiat currency
            isCryptoCurrency = true;
        } else if (!getFiatCurrency(currencyCode).isPresent()) {
            // In case the code is from a removed asset we cross check if there exist a fiat currency with that code,
            // if we don't find a fiat currency we treat it as a crypto currency.
            isCryptoCurrency = true;
        } else {
            // If we would have found a fiat currency we return false
            isCryptoCurrency = false;
        }

        if (currencyCode != null) {
            isCryptoCurrencyMap.put(currencyCode, isCryptoCurrency);
        }

        return isCryptoCurrency;
    }

    public static Optional<CryptoCurrency> getCryptoCurrency(String currencyCode) {
        return Optional.ofNullable(cryptoCurrencyMapSupplier.get().get(currencyCode));
    }

    public static Optional<TradeCurrency> getTradeCurrency(String currencyCode) {
        Optional<FiatCurrency> fiatCurrencyOptional = getFiatCurrency(currencyCode);
        if (fiatCurrencyOptional.isPresent() && isFiatCurrency(currencyCode))
            return Optional.of(fiatCurrencyOptional.get());

        Optional<CryptoCurrency> cryptoCurrencyOptional = getCryptoCurrency(currencyCode);
        if (cryptoCurrencyOptional.isPresent() && isCryptoCurrency(currencyCode))
            return Optional.of(cryptoCurrencyOptional.get());

        return Optional.empty();
    }

    public static Optional<List<TradeCurrency>> getTradeCurrencies(List<String> currencyCodes) {
        List<TradeCurrency> tradeCurrencies = new ArrayList<>();
        currencyCodes.stream().forEachOrdered(c ->
                tradeCurrencies.add(getTradeCurrency(c).orElseThrow(() ->
                        new IllegalArgumentException(format(""%s is not a valid trade currency code"", c)))));
        return tradeCurrencies.isEmpty()
                ? Optional.empty()
                : Optional.of(tradeCurrencies);
    }

    public static Optional<List<TradeCurrency>> getTradeCurrenciesInList(List<String> currencyCodes,
                                                                         List<TradeCurrency> validCurrencies) {
        Optional<List<TradeCurrency>> tradeCurrencies = getTradeCurrencies(currencyCodes);
        Consumer<List<TradeCurrency>> validateCandidateCurrencies = (list) -> {
            for (TradeCurrency tradeCurrency : list) {
                if (!validCurrencies.contains(tradeCurrency)) {
                    throw new IllegalArgumentException(
                            format(""%s is not a member of valid currencies list"",
                                    tradeCurrency.getCode()));
                }
            }
        };
        tradeCurrencies.ifPresent(validateCandidateCurrencies);
        return tradeCurrencies;
    }

    public static FiatCurrency getCurrencyByCountryCode(String countryCode) {
        if (countryCode.equals(""XK""))
            return new FiatCurrency(""EUR"");

        Currency currency = Currency.getInstance(new Locale(LanguageUtil.getDefaultLanguage(), countryCode));
        return new FiatCurrency(currency.getCurrencyCode());
    }


    public static String getNameByCode(String currencyCode) {
        if (isCryptoCurrency(currencyCode)) {
            // We might not find the name in case we have a call for a removed asset.
            // If BTC is the code (used in tests) we also want return Bitcoin as name.
            final Optional<CryptoCurrency> removedCryptoCurrency = getRemovedCryptoCurrencies().stream()
                    .filter(cryptoCurrency -> cryptoCurrency.getCode().equals(currencyCode))
                    .findAny();

            String btcOrRemovedAsset = ""BTC"".equals(currencyCode) ? ""Bitcoin"" :
                    removedCryptoCurrency.isPresent() ? removedCryptoCurrency.get().getName() : Res.get(""shared.na"");
            return getCryptoCurrency(currencyCode).map(TradeCurrency::getName).orElse(btcOrRemovedAsset);
        }
        try {
            return Currency.getInstance(currencyCode).getDisplayName();
        } catch (Throwable t) {
            log.debug(""No currency name available {}"", t.getMessage());
            return currencyCode;
        }
    }

    public static Optional<CryptoCurrency> findCryptoCurrencyByName(String currencyName) {
        return getAllSortedCryptoCurrencies().stream()
                .filter(e -> e.getName().equals(currencyName))
                .findAny();
    }

    public static String getNameAndCode(String currencyCode) {
        return getNameByCode(currencyCode) + "" ("" + currencyCode + "")"";
    }

    public static TradeCurrency getDefaultTradeCurrency() {
        return GlobalSettings.getDefaultTradeCurrency();
    }

    private static boolean assetIsNotBaseCurrency(Asset asset) {
        return !assetMatchesCurrencyCode(asset, baseCurrencyCode);
    }

    // TODO We handle assets of other types (Token, ERC20) as matching the network which is not correct.
    // We should add support for network property in those tokens as well.
    public static boolean assetMatchesNetwork(Asset asset, BaseCurrencyNetwork baseCurrencyNetwork) {
        return !(asset instanceof Coin) ||
                ((Coin) asset).getNetwork().name().equals(baseCurrencyNetwork.getNetwork());
    }

    // We only check for coins not other types of assets (TODO network check should be supported for all assets)
    public static boolean assetMatchesNetworkIfMainnet(Asset asset, BaseCurrencyNetwork baseCurrencyNetwork) {
        return !(asset instanceof Coin) ||
                coinMatchesNetworkIfMainnet((Coin) asset, baseCurrencyNetwork);
    }

    // We want all coins available also in testnet or regtest for testing purpose
    public static boolean coinMatchesNetworkIfMainnet(Coin coin, BaseCurrencyNetwork baseCurrencyNetwork) {
        boolean matchesNetwork = assetMatchesNetwork(coin, baseCurrencyNetwork);
        return !baseCurrencyNetwork.isMainnet() || matchesNetwork;
    }

    private static CryptoCurrency assetToCryptoCurrency(Asset asset) {
        return new CryptoCurrency(asset.getTickerSymbol(), asset.getName(), asset instanceof Token);
    }

    private static boolean isNotBsqOrBsqTradingActivated(Asset asset,
                                                         BaseCurrencyNetwork baseCurrencyNetwork,
                                                         boolean daoTradingActivated) {
        return !(asset instanceof BSQ) ||
                daoTradingActivated && assetMatchesNetwork(asset, baseCurrencyNetwork);
    }

    public static boolean assetMatchesCurrencyCode(Asset asset, String currencyCode) {
        return currencyCode.equals(asset.getTickerSymbol());
    }

    public static Optional<Asset> findAsset(AssetRegistry assetRegistry, String currencyCode,
                                            BaseCurrencyNetwork baseCurrencyNetwork, boolean daoTradingActivated) {
        List<Asset> assets = assetRegistry.stream()
                .filter(asset -> assetMatchesCurrencyCode(asset, currencyCode)).collect(Collectors.toList());

        // If we don't have the ticker symbol we throw an exception
        if (!assets.stream().findFirst().isPresent())
            return Optional.empty();

        if (currencyCode.equals(""BSQ"") && baseCurrencyNetwork.isMainnet() && !daoTradingActivated)
            return Optional.empty();

        // We check for exact match with network, e.g. BTC$TESTNET
        Optional<Asset> optionalAssetMatchesNetwork = assets.stream()
                .filter(asset -> assetMatchesNetwork(asset, baseCurrencyNetwork))
                .findFirst();
        if (optionalAssetMatchesNetwork.isPresent())
            return optionalAssetMatchesNetwork;

        // In testnet or regtest we want to show all coins as well. Most coins have only Mainnet defined so we deliver
        // that if no exact match was found in previous step
        if (!baseCurrencyNetwork.isMainnet()) {
            Optional<Asset> optionalAsset = assets.stream().findFirst();
            checkArgument(optionalAsset.isPresent(), ""optionalAsset must be present as we checked for "" +
                    ""not matching ticker symbols already above"");
            return optionalAsset;
        }

        // If we are in mainnet we need have a mainnet asset defined.
        throw new IllegalArgumentException(""We are on mainnet and we could not find an asset with network type mainnet"");
    }

    public static Optional<Asset> findAsset(String tickerSymbol) {
        return assetRegistry.stream()
                .filter(asset -> asset.getTickerSymbol().equals(tickerSymbol))
                .findAny();
    }

    public static Optional<Asset> findAsset(String tickerSymbol, BaseCurrencyNetwork baseCurrencyNetwork) {
        return assetRegistry.stream()
                .filter(asset -> asset.getTickerSymbol().equals(tickerSymbol))
                .filter(asset -> assetMatchesNetwork(asset, baseCurrencyNetwork))
                .findAny();
    }

    // Excludes all assets which got removed by DAO voting
    public static List<CryptoCurrency> getActiveSortedCryptoCurrencies(AssetService assetService,
                                                                       FilterManager filterManager) {
        return getAllSortedCryptoCurrencies().stream()
                .filter(e -> e.getCode().equals(""BSQ"") || assetService.isActive(e.getCode()))
                .filter(e -> !filterManager.isCurrencyBanned(e.getCode()))
                .collect(Collectors.toList());
    }

    public static String getCurrencyPair(String currencyCode) {
        if (isFiatCurrency(currencyCode))
            return Res.getBaseCurrencyCode() + ""/"" + currencyCode;
        else
            return currencyCode + ""/"" + Res.getBaseCurrencyCode();
    }

    public static String getCounterCurrency(String currencyCode) {
        if (isFiatCurrency(currencyCode))
            return currencyCode;
        else
            return Res.getBaseCurrencyCode();
    }

    public static String getPriceWithCurrencyCode(String currencyCode) {
        return getPriceWithCurrencyCode(currencyCode, ""shared.priceInCurForCur"");
    }

    public static String getPriceWithCurrencyCode(String currencyCode, String translationKey) {
        if (isCryptoCurrency(currencyCode))
            return Res.get(translationKey, Res.getBaseCurrencyCode(), currencyCode);
        else
            return Res.get(translationKey, currencyCode, Res.getBaseCurrencyCode());
    }

    public static String getOfferVolumeCode(String currencyCode) {
        return Res.get(""shared.offerVolumeCode"", currencyCode);
    }
}",1,64 2000 777 587 2001 123 777 809 865 2002 40 41 123 2003 40 2004 46 2005 40 41 46 2006 40 41 41 59 125 773 809 657 2007 2008 61 744 2007 40 41 59 773 809 2009 2010 61 362 59 330 330 330 330 330 773 809 657 2011 60 2009 44 2012 62 2013 61 744 2014 60 62 40 41 59 773 809 657 2011 60 2009 44 2012 62 2015 61 744 2014 60 62 40 41 59 773 809 2016 60 2011 60 2009 44 2017 356 2018 61 2019 46 2020 40 2001 58 58 2021 41 58 58 2022 59 773 809 2016 60 2011 60 2009 44 2023 356 2024 61 2019 46 2020 40 2001 58 58 2025 41 58 58 2022 59 777 809 865 2026 40 2009 2010 41 123 2001 46 2010 61 2010 59 125 777 809 2027 60 2017 62 2028 40 41 123 792 2018 46 2022 40 41 46 2029 40 41 59 330 125 777 809 2027 60 2017 62 2028 40 2030 2031 41 123 792 40 2032 60 2017 62 41 2028 40 41 46 2033 40 41 46 2034 40 2031 41 330 46 2035 40 2036 46 2037 40 41 41 59 125 773 809 2011 60 2009 44 2017 62 2021 40 41 123 792 2038 46 2039 40 41 46 2040 40 41 46 2041 40 2042 45 62 2043 40 2042 46 2044 41 41 46 2045 40 2046 58 58 2047 41 46 2048 40 41 46 2049 40 2050 46 2051 40 2046 58 58 2052 44 2053 46 2054 40 41 44 40 2055 44 2056 41 45 62 2055 44 2057 58 58 744 41 41 59 125 777 809 2058 60 2017 62 2059 40 41 123 2060 2061 61 2062 40 41 59 2058 60 2017 62 2063 61 744 2064 60 62 40 41 59 330 2063 46 2065 40 744 2017 40 362 41 41 59 2063 46 2065 40 744 2017 40 362 41 41 59 2063 46 2065 40 744 2017 40 362 41 41 59 2063 46 2065 40 744 2017 40 362 41 41 59 2063 46 2065 40 744 2017 40 362 41 41 59 2063 46 2065 40 744 2017 40 362 41 41 59 2063 46 2065 40 744 2017 40 362 41 41 59 2063 46 2065 40 744 2017 40 362 41 41 59 2063 46 2066 40 2060 58 58 2067 41 59 2017 2068 61 2061 702 2017 63 40 2017 41 2061 58 2069 59 688 40 2068 340 2069 307 2063 46 2070 40 2068 41 41 123 2063 46 2071 40 2061 41 59 2063 46 2065 40 1500 44 2068 41 59 125 792 2063 59 125 777 809 2027 60 2023 62 2072 40 41 123 792 2024 46 2022 40 41 46 2073 40 41 59 125 773 809 2011 60 2009 44 2023 62 2025 40 41 123 792 2074 40 41 46 2075 40 2001 58 58 2076 41 46 2077 40 2078 46 2079 40 2080 58 58 2081 44 2082 46 2083 40 41 44 40 2084 44 2085 41 45 62 2084 44 2086 58 58 744 41 41 59 125 777 809 2087 60 2088 62 2089 40 41 123 792 2008 46 2090 40 41 46 2091 40 2001 58 58 2092 41 46 2091 40 2093 45 62 2094 40 2093 44 2095 46 2096 40 41 44 2097 46 2098 40 41 41 41 46 2091 40 2093 45 62 2099 40 2093 44 2095 46 2096 40 41 41 41 46 2100 40 2030 46 2101 40 2088 58 58 2102 41 41 59 125 777 809 2058 60 2023 62 2103 40 41 123 657 2058 60 2023 62 2104 61 744 2105 60 62 40 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 688 40 2107 46 2108 40 41 41 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2106 40 744 2023 40 362 44 362 41 41 59 2104 46 2109 40 2110 58 58 2111 41 59 792 2104 59 125 777 809 2058 60 2023 62 2112 40 41 123 657 2058 60 2023 62 2113 61 744 2114 60 62 40 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 2113 46 2115 40 744 2023 40 362 44 362 41 41 59 792 2113 59 125 777 809 2058 60 2116 62 2117 40 41 123 2118 60 2116 62 2119 61 744 2118 60 62 40 2120 46 2121 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2119 46 2122 40 2030 46 2123 40 2116 58 58 2124 41 41 59 792 2119 59 125 777 809 2058 60 2116 62 2125 40 41 123 2126 60 2116 62 2127 61 744 2126 60 62 40 2128 46 2129 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2127 46 2130 40 2030 46 2131 40 2116 58 58 2132 41 41 59 792 2127 59 125 330 777 809 2058 60 2116 62 2133 40 41 123 2134 60 2116 62 2135 61 744 2134 60 62 40 2136 46 2137 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2135 46 2138 40 2030 46 2139 40 2116 58 58 2140 41 41 59 792 2135 59 125 330 777 809 2058 60 2116 62 2141 40 41 123 2142 60 2116 62 2143 61 744 2142 60 62 40 2144 46 2145 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2143 46 2146 40 2030 46 2147 40 2116 58 58 2148 41 41 59 792 2143 59 125 330 777 809 2058 60 2116 62 2149 40 41 123 2150 60 2116 62 2151 61 744 2150 60 62 40 2152 46 2153 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2151 46 2154 40 2030 46 2155 40 2116 58 58 2156 41 41 59 792 2151 59 125 330 777 809 2058 60 2116 62 2157 40 41 123 2158 60 2116 62 2159 61 744 2158 60 62 40 2160 46 2161 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2159 46 2162 40 2030 46 2163 40 2116 58 58 2164 41 41 59 792 2159 59 125 777 809 2058 60 2116 62 2165 40 41 123 2058 60 2116 62 2166 61 744 2167 60 62 40 2168 46 2169 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2166 46 2170 40 2030 46 2171 40 2116 58 58 2172 41 41 59 792 2166 59 125 777 809 2058 60 2116 62 2173 40 41 123 792 744 2174 60 62 40 2175 46 2176 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 125 330 777 809 2058 60 2116 62 2177 40 41 123 792 744 2178 60 62 40 2179 46 2180 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 125 330 777 809 2058 60 2116 62 2181 40 41 123 792 744 2182 60 62 40 2183 46 2184 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 125 330 777 809 2058 60 2116 62 2185 40 41 123 792 744 2186 60 62 40 2187 46 2188 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 125 330 777 809 2058 60 2116 62 2189 40 41 123 2190 60 2116 62 2191 61 744 2190 60 62 40 2192 46 2193 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2191 46 2194 40 2030 46 2195 40 2116 58 58 2196 41 41 59 792 2191 59 125 777 809 2058 60 2116 62 2197 40 41 123 2198 60 2116 62 2199 61 744 2198 60 62 40 2200 46 2201 40 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 44 744 2017 40 362 41 41 41 59 2199 46 2202 40 2030 46 2203 40 2116 58 58 2204 41 41 59 792 2199 59 125 777 809 570 2205 40 2009 2206 41 123 688 40 2206 340 2207 307 2013 46 2208 40 2206 41 41 123 792 2013 46 2022 40 2206 41 59 125 830 123 570 2205 61 2206 340 2207 307 33 2206 46 2209 40 41 307 33 2210 40 2206 41 307 2211 46 2212 40 2206 41 340 2207 59 688 40 2206 340 2207 41 123 2013 46 2213 40 2206 44 2205 41 59 125 792 2205 59 125 580 40 2214 2215 41 123 688 40 2206 340 2207 41 123 2013 46 2216 40 2206 44 2217 41 59 125 792 2218 59 125 125 777 809 2219 60 2017 62 2220 40 2009 2206 41 123 792 2219 46 2221 40 2018 46 2022 40 41 46 2022 40 2206 41 41 59 125 306 777 809 570 2222 40 2009 2206 41 123 688 40 2206 340 2223 307 2015 46 2224 40 2206 41 41 123 792 2015 46 2022 40 2206 41 59 125 570 2222 59 688 40 2206 323 2223 41 123 330 2222 61 2225 59 125 630 688 40 2206 46 2226 40 362 41 41 123 330 330 2222 61 2227 59 125 630 688 40 2228 40 2206 41 46 2229 40 41 41 123 330 330 330 2222 61 2230 59 125 630 688 40 33 2220 40 2206 41 46 2229 40 41 41 123 330 330 2222 61 2231 59 125 630 123 330 2222 61 2232 59 125 688 40 2206 340 2223 41 123 2015 46 2233 40 2206 44 2222 41 59 125 792 2222 59 125 777 809 2219 60 2023 62 2234 40 2009 2206 41 123 792 2219 46 2235 40 2024 46 2022 40 41 46 2022 40 2206 41 41 59 125 777 809 2219 60 2116 62 2236 40 2009 2206 41 123 2219 60 2017 62 2237 61 2220 40 2206 41 59 688 40 2237 46 2238 40 41 307 2205 40 2206 41 41 792 2219 46 2239 40 2237 46 2022 40 41 41 59 2219 60 2023 62 2240 61 2234 40 2206 41 59 688 40 2240 46 2238 40 41 307 2222 40 2206 41 41 792 2219 46 2239 40 2240 46 2022 40 41 41 59 792 2219 46 2241 40 41 59 125 777 809 2219 60 2058 60 2116 356 2242 40 2058 60 2009 62 2243 41 123 2058 60 2116 62 2244 61 744 2245 60 62 40 41 59 2243 46 2246 40 41 46 2247 40 2248 45 62 2244 46 2249 40 2236 40 2248 41 46 2250 40 40 41 45 62 744 2251 40 2252 40 362 44 2248 41 41 41 41 41 59 792 2244 46 2253 40 41 63 2219 46 2254 40 41 58 2219 46 2255 40 2244 41 59 125 777 809 2219 60 2058 60 2116 356 2256 40 2058 60 2009 62 2243 44 2058 60 2116 62 2257 41 123 2219 60 2058 60 2116 356 2258 61 2242 40 2243 41 59 2259 60 2058 60 2116 356 2260 61 40 2261 41 45 62 123 664 40 2116 2262 58 2261 41 123 688 40 33 2257 46 2263 40 2262 41 41 123 825 744 2264 40 2265 40 362 44 2262 46 2266 40 41 41 41 59 125 125 125 59 2258 46 2267 40 2260 41 59 792 2258 59 125 777 809 2017 2268 40 2009 2269 41 123 688 40 2269 46 2270 40 362 41 41 792 744 2017 40 362 41 59 2271 2272 61 2271 46 2273 40 744 2274 40 2275 46 2276 40 41 44 2269 41 41 59 792 744 2017 40 2272 46 2277 40 41 41 59 125 777 809 2009 2278 40 2009 2206 41 123 688 40 2222 40 2206 41 41 123 330 330 657 2219 60 2023 62 2279 61 2112 40 41 46 2280 40 41 46 2281 40 2282 45 62 2282 46 2283 40 41 46 2284 40 2206 41 41 46 2285 40 41 59 2009 2286 61 362 46 2284 40 2206 41 63 362 58 2279 46 2287 40 41 63 2279 46 2022 40 41 46 2288 40 41 58 2289 46 2022 40 362 41 59 792 2234 40 2206 41 46 2290 40 2116 58 58 2288 41 46 2291 40 2286 41 59 125 830 123 792 2292 46 2293 40 2206 41 46 2294 40 41 59 125 580 40 2295 2296 41 123 2297 46 2298 40 362 44 2296 46 2299 40 41 41 59 792 2206 59 125 125 777 809 2219 60 2023 62 2300 40 2009 2301 41 123 792 2072 40 41 46 2302 40 41 46 2303 40 2304 45 62 2304 46 2305 40 41 46 2306 40 2301 41 41 46 2307 40 41 59 125 777 809 2009 2308 40 2009 2206 41 123 792 2278 40 2206 41 43 362 43 2206 43 362 59 125 777 809 2116 2309 40 41 123 792 2310 46 2309 40 41 59 125 773 809 570 2311 40 2088 2312 41 123 792 33 2313 40 2312 44 2010 41 59 125 330 330 777 809 570 2314 40 2088 2312 44 2315 2316 41 123 792 33 40 2312 702 2317 41 309 40 40 2317 41 2312 41 46 2318 40 41 46 2319 40 41 46 2320 40 2316 46 2318 40 41 41 59 125 330 777 809 570 2321 40 2088 2312 44 2315 2316 41 123 792 33 40 2312 702 2322 41 309 2323 40 40 2322 41 2312 44 2316 41 59 125 330 777 809 570 2324 40 2325 2326 44 2315 2316 41 123 570 2327 61 2314 40 2326 44 2316 41 59 792 33 2316 46 2328 40 41 309 2327 59 125 773 809 2023 2329 40 2088 2312 41 123 792 744 2023 40 2312 46 2330 40 41 44 2312 46 2331 40 41 44 2312 702 2332 41 59 125 773 809 570 2333 40 2088 2312 44 2315 2316 44 570 2334 41 123 792 33 40 2312 702 2335 41 309 2334 307 2314 40 2312 44 2316 41 59 125 777 809 570 2336 40 2088 2312 44 2009 2206 41 123 792 2206 46 2337 40 2312 46 2338 40 41 41 59 125 777 809 2219 60 2088 62 2339 40 2007 2008 44 2009 2206 44 2315 2316 44 570 2334 41 123 2058 60 2088 62 2340 61 2008 46 2341 40 41 46 2342 40 2312 45 62 2336 40 2312 44 2206 41 41 46 2343 40 2344 46 2345 40 41 41 59 330 688 40 33 2340 46 2341 40 41 46 2346 40 41 46 2347 40 41 41 792 2219 46 2348 40 41 59 688 40 2206 46 2349 40 362 41 307 2316 46 2350 40 41 307 33 2334 41 792 2219 46 2348 40 41 59 330 2219 60 2088 62 2351 61 2340 46 2341 40 41 46 2342 40 2312 45 62 2314 40 2312 44 2316 41 41 46 2346 40 41 59 688 40 2351 46 2347 40 41 41 792 2351 59 330 330 688 40 33 2316 46 2350 40 41 41 123 2219 60 2088 62 2352 61 2340 46 2341 40 41 46 2346 40 41 59 2353 40 2352 46 2347 40 41 44 362 43 362 41 59 792 2352 59 125 330 825 744 2354 40 362 41 59 125 777 809 2219 60 2088 62 2339 40 2009 2355 41 123 792 2008 46 2356 40 41 46 2357 40 2312 45 62 2312 46 2358 40 41 46 2359 40 2355 41 41 46 2360 40 41 59 125 777 809 2219 60 2088 62 2339 40 2009 2355 44 2315 2316 41 123 792 2008 46 2361 40 41 46 2362 40 2312 45 62 2312 46 2363 40 41 46 2364 40 2355 41 41 46 2362 40 2312 45 62 2314 40 2312 44 2316 41 41 46 2365 40 41 59 125 330 777 809 2058 60 2023 62 2366 40 2367 2368 44 2369 2370 41 123 792 2072 40 41 46 2371 40 41 46 2372 40 2373 45 62 2373 46 2374 40 41 46 2375 40 362 41 309 2368 46 2376 40 2373 46 2374 40 41 41 41 46 2372 40 2373 45 62 33 2370 46 2377 40 2373 46 2374 40 41 41 41 46 2378 40 2379 46 2380 40 41 41 59 125 777 809 2009 2381 40 2009 2206 41 123 688 40 2205 40 2206 41 41 792 2382 46 2383 40 41 43 362 43 2206 59 630 792 2206 43 362 43 2382 46 2383 40 41 59 125 777 809 2009 2384 40 2009 2206 41 123 688 40 2205 40 2206 41 41 792 2206 59 630 792 2385 46 2386 40 41 59 125 777 809 2009 2387 40 2009 2206 41 123 792 2387 40 2206 44 362 41 59 125 777 809 2009 2387 40 2009 2206 44 2009 2388 41 123 688 40 2222 40 2206 41 41 792 2389 46 2022 40 2388 44 2389 46 2390 40 41 44 2206 41 59 630 792 2389 46 2022 40 2388 44 2206 44 2389 46 2390 40 41 41 59 125 777 809 2009 2391 40 2009 2206 41 123 792 2392 46 2022 40 362 44 2206 41 59 125 125 ,"{'AvgLine': 12, 'CountLine': 740, 'CountStmt': 242, 'MaxNesting': 2, 'AvgLineCode': 11, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 184, 'MaxEssential': 5, 'SumEssential': 78, 'AvgCyclomatic': 1, 'CountLineCode': 612, 'CountStmtDecl': 88, 'MaxCyclomatic': 7, 'SumCyclomatic': 98, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 82, 'CountSemicolon': 162, 'CountDeclMethod': 52, 'CountLineCodeExe': 484, 'CountLineComment': 48, 'CountClassCoupled': 38, 'CountClassDerived': 0, 'CountLineCodeDecl': 111, 'CountDeclMethodAll': 52, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.08', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 9, 'SumCyclomaticStrict': 114, 'CountDeclClassMethod': 52, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 47, 'MaxCyclomaticModified': 7, 'PercentLackOfCohesion': 96, 'SumCyclomaticModified': 98, 'CountDeclClassVariable': 6, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 5, 'CountDeclInstanceMethod': 0, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 38, 'CountDeclInstanceVariable': 0, 'PercentLackOfCohesionModified': 80}"
2824,Java,"@Slf4j
public class DaoStateService implements DaoSetupService {
    private final DaoState daoState;
    private final GenesisTxInfo genesisTxInfo;
    private final BsqFormatter bsqFormatter;
    private final List<DaoStateListener> daoStateListeners = new CopyOnWriteArrayList<>();
    @Getter
    private boolean parseBlockChainComplete;
    private boolean allowDaoStateChange;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public DaoStateService(DaoState daoState, GenesisTxInfo genesisTxInfo, BsqFormatter bsqFormatter) {
        this.daoState = daoState;
        this.genesisTxInfo = genesisTxInfo;
        this.bsqFormatter = bsqFormatter;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // DaoSetupService
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void addListeners() {
    }

    @Override
    public void start() {
        allowDaoStateChange = true;
        assertDaoStateChange();
        daoState.setChainHeight(genesisTxInfo.getGenesisBlockHeight());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Snapshot
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void applySnapshot(DaoState snapshot) {
        allowDaoStateChange = true;
        assertDaoStateChange();

        log.info(""Apply snapshot with chain height {}"", snapshot.getChainHeight());

        daoState.setChainHeight(snapshot.getChainHeight());

        daoState.setTxCache(snapshot.getTxCache());

        daoState.clearAndSetBlocks(snapshot.getBlocks());

        daoState.getCycles().clear();
        daoState.getCycles().addAll(snapshot.getCycles());

        daoState.getUnspentTxOutputMap().clear();
        daoState.getUnspentTxOutputMap().putAll(snapshot.getUnspentTxOutputMap());

        daoState.getSpentInfoMap().clear();
        daoState.getSpentInfoMap().putAll(snapshot.getSpentInfoMap());

        daoState.getConfiscatedLockupTxList().clear();
        daoState.getConfiscatedLockupTxList().addAll(snapshot.getConfiscatedLockupTxList());

        daoState.getIssuanceMap().clear();
        daoState.getIssuanceMap().putAll(snapshot.getIssuanceMap());

        daoState.getParamChangeList().clear();
        daoState.getParamChangeList().addAll(snapshot.getParamChangeList());

        daoState.getEvaluatedProposalList().clear();
        daoState.getEvaluatedProposalList().addAll(snapshot.getEvaluatedProposalList());

        daoState.getDecryptedBallotsWithMeritsList().clear();
        daoState.getDecryptedBallotsWithMeritsList().addAll(snapshot.getDecryptedBallotsWithMeritsList());
    }

    public DaoState getClone() {
        return DaoState.getClone(daoState);
    }

    public protobuf.DaoState getBsqStateCloneExcludingBlocks() {
        return DaoState.getBsqStateCloneExcludingBlocks(daoState);
    }

    public byte[] getSerializedStateForHashChain() {
        return daoState.getSerializedStateForHashChain();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // ChainHeight
    ///////////////////////////////////////////////////////////////////////////////////////////

    public int getChainHeight() {
        return daoState.getChainHeight();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Cycle
    ///////////////////////////////////////////////////////////////////////////////////////////

    public LinkedList<Cycle> getCycles() {
        return daoState.getCycles();
    }

    public void addCycle(Cycle cycle) {
        assertDaoStateChange();
        getCycles().add(cycle);
    }

    @Nullable
    public Cycle getCurrentCycle() {
        return !getCycles().isEmpty() ? getCycles().getLast() : null;
    }

    public Optional<Cycle> getCycle(int height) {
        return getCycles().stream()
                .filter(cycle -> cycle.getHeightOfFirstBlock() <= height)
                .filter(cycle -> cycle.getHeightOfLastBlock() >= height)
                .findAny();
    }

    public Optional<Integer> getStartHeightOfNextCycle(int blockHeight) {
        return getCycle(blockHeight).map(cycle -> cycle.getHeightOfLastBlock() + 1);
    }

    public Optional<Integer> getStartHeightOfCurrentCycle(int blockHeight) {
        return getCycle(blockHeight).map(cycle -> cycle.getHeightOfFirstBlock());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Block
    ///////////////////////////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Parser events
    ///////////////////////////////////////////////////////////////////////////////////////////

    // First we get the blockHeight set
    public void onNewBlockHeight(int blockHeight) {
        allowDaoStateChange = true;
        daoState.setChainHeight(blockHeight);
        daoStateListeners.forEach(listener -> listener.onNewBlockHeight(blockHeight));
    }

    // Second we get the block added with empty txs
    public void onNewBlockWithEmptyTxs(Block block) {
        assertDaoStateChange();
        if (daoState.getBlocks().isEmpty() && block.getHeight() != getGenesisBlockHeight()) {
            log.warn(""We don't have any blocks yet and we received a block which is not the genesis block. "" +
                    ""We ignore that block as the first block need to be the genesis block. "" +
                    ""That might happen in edge cases at reorgs. Received block={}"", block);
        } else {
            daoState.addBlock(block);

            if (parseBlockChainComplete)
                log.info(""New Block added at blockHeight {}"", block.getHeight());
        }
    }

    // Third we add each successfully parsed BSQ tx to the last block
    public void onNewTxForLastBlock(Block block, Tx tx) {
        assertDaoStateChange();

        getLastBlock().ifPresent(lastBlock -> {
            if (block == lastBlock) {
                // We need to ensure that the txs in all blocks are in sync with the txs in our txMap (cache).
                block.addTx(tx);
                daoState.addToTxCache(tx);
            } else {
                // Not clear if this case can happen but at onNewBlockWithEmptyTxs we handle such a potential edge
                // case as well, so we need to reflect that here as well.
                log.warn(""Block for parsing does not match last block. That might happen in edge cases at reorgs. "" +
                        ""Received block={}"", block);
            }
        });
    }

    // Fourth we get the onParseBlockComplete called after all rawTxs of blocks have been parsed
    public void onParseBlockComplete(Block block) {
        if (parseBlockChainComplete)
            log.info(""Parse block completed: Block height {}, {} BSQ transactions."", block.getHeight(), block.getTxs().size());

        // Need to be called before onParseTxsCompleteAfterBatchProcessing as we use it in
        // VoteResult and other listeners like balances usually listen on onParseTxsCompleteAfterBatchProcessing
        // so we need to make sure that vote result calculation is completed before (e.g. for comp. request to
        // update balance).
        daoStateListeners.forEach(l -> l.onParseBlockComplete(block));

        // We use 2 different handlers as we don't want to update domain listeners during batch processing of all
        // blocks as that causes performance issues. In earlier versions when we updated at each block it took
        // 50 sec. for 4000 blocks, after that change it was about 4 sec.
        // Clients
        if (parseBlockChainComplete)
            daoStateListeners.forEach(l -> l.onParseBlockCompleteAfterBatchProcessing(block));

        // Here listeners must not trigger any state change in the DAO as we trigger the validation service to
        // generate a hash of the state.
        allowDaoStateChange = false;
        daoStateListeners.forEach(l -> l.onDaoStateChanged(block));
    }

    // Called after parsing of all pending blocks is completed
    public void onParseBlockChainComplete() {
        log.info(""Parse blockchain completed"");
        parseBlockChainComplete = true;

        getLastBlock().ifPresent(block -> {
            daoStateListeners.forEach(l -> l.onParseBlockCompleteAfterBatchProcessing(block));
        });

        daoStateListeners.forEach(DaoStateListener::onParseBlockChainComplete);
    }

    public List<Block> getBlocks() {
        return daoState.getBlocks();
    }

    public Optional<Block> getLastBlock() {
        if (!getBlocks().isEmpty())
            return Optional.of(daoState.getLastBlock());
        else
            return Optional.empty();
    }

    public int getBlockHeightOfLastBlock() {
        return getLastBlock().map(Block::getHeight).orElse(0);
    }

    public String getBlockHashOfLastBlock() {
        return getLastBlock().map(Block::getHash).orElse("""");
    }

    public Optional<Block> getBlockAtHeight(int height) {
        return Optional.ofNullable(daoState.getBlocksByHeight().get(height));
    }

    public long getBlockTimeAtBlockHeight(int height) {
        return getBlockAtHeight(height).map(Block::getTime).orElse(0L);
    }

    public boolean containsBlock(Block block) {
        return getBlocks().contains(block);
    }

    public long getBlockTime(int height) {
        return getBlockAtHeight(height).map(Block::getTime).orElse(0L);
    }

    public List<Block> getBlocksFromBlockHeight(int fromBlockHeight) {
        return getBlocksFromBlockHeight(fromBlockHeight, Integer.MAX_VALUE);
    }

    public List<Block> getBlocksFromBlockHeight(int fromBlockHeight, int numMaxBlocks) {
        // We limit requests to numMaxBlocks blocks, to avoid performance issues and too
        // large network data in case a node requests too far back in history.
        return getBlocks().stream()
                .filter(block -> block.getHeight() >= fromBlockHeight)
                .limit(numMaxBlocks)
                .collect(Collectors.toList());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Genesis
    ///////////////////////////////////////////////////////////////////////////////////////////

    public String getGenesisTxId() {
        return genesisTxInfo.getGenesisTxId();
    }

    public int getGenesisBlockHeight() {
        return genesisTxInfo.getGenesisBlockHeight();
    }

    public Coin getGenesisTotalSupply() {
        return Coin.valueOf(genesisTxInfo.getGenesisTotalSupply());
    }

    public Optional<Tx> getGenesisTx() {
        return getTx(getGenesisTxId());
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Tx
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Stream<Tx> getUnorderedTxStream() {
        return daoState.getTxCache().values().stream();
    }

    public int getNumTxs() {
        return daoState.getTxCache().size();
    }

    public List<Tx> getInvalidTxs() {
        return getUnorderedTxStream().filter(tx -> tx.getTxType() == TxType.INVALID).collect(Collectors.toList());
    }

    public List<Tx> getIrregularTxs() {
        return getUnorderedTxStream().filter(tx -> tx.getTxType() == TxType.IRREGULAR).collect(Collectors.toList());
    }

    public Optional<Tx> getTx(String txId) {
        return Optional.ofNullable(daoState.getTxCache().get(txId));
    }

    public boolean containsTx(String txId) {
        return getTx(txId).isPresent();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // TxType
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Optional<TxType> getOptionalTxType(String txId) {
        return getTx(txId).map(Tx::getTxType);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // BurntFee (trade fee and fee burned at proof of burn)
    ///////////////////////////////////////////////////////////////////////////////////////////

    public long getBurntFee(String txId) {
        return getTx(txId).map(Tx::getBurntFee).orElse(0L);
    }

    public boolean hasTxBurntFee(String txId) {
        return getBurntFee(txId) > 0;
    }

    public Set<Tx> getTradeFeeTxs() {
        return getUnorderedTxStream()
                .filter(tx -> tx.getTxType() == TxType.PAY_TRADE_FEE)
                .collect(Collectors.toSet());
    }

    public Set<Tx> getProofOfBurnTxs() {
        return getUnorderedTxStream()
                .filter(tx -> tx.getTxType() == TxType.PROOF_OF_BURN)
                .collect(Collectors.toSet());
    }

    // Any tx with burned BSQ
    public Set<Tx> getBurntFeeTxs() {
        return getUnorderedTxStream()
                .filter(tx -> tx.getBurntFee() > 0)
                .collect(Collectors.toSet());
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // TxInput
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Optional<TxOutput> getConnectedTxOutput(TxInput txInput) {
        return getTx(txInput.getConnectedTxOutputTxId())
                .map(tx -> tx.getTxOutputs().get(txInput.getConnectedTxOutputIndex()));
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // TxOutput
    ///////////////////////////////////////////////////////////////////////////////////////////

    private Stream<TxOutput> getUnorderedTxOutputStream() {
        return getUnorderedTxStream()
                .flatMap(tx -> tx.getTxOutputs().stream());
    }

    public boolean existsTxOutput(TxOutputKey key) {
        return getUnorderedTxOutputStream().anyMatch(txOutput -> txOutput.getKey().equals(key));
    }

    public Optional<TxOutput> getTxOutput(TxOutputKey txOutputKey) {
        return getUnorderedTxOutputStream()
                .filter(txOutput -> txOutput.getKey().equals(txOutputKey))
                .findAny();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // UnspentTxOutput
    ///////////////////////////////////////////////////////////////////////////////////////////

    public TreeMap<TxOutputKey, TxOutput> getUnspentTxOutputMap() {
        return daoState.getUnspentTxOutputMap();
    }

    public void addUnspentTxOutput(TxOutput txOutput) {
        assertDaoStateChange();
        getUnspentTxOutputMap().put(txOutput.getKey(), txOutput);
    }

    public void removeUnspentTxOutput(TxOutput txOutput) {
        assertDaoStateChange();
        getUnspentTxOutputMap().remove(txOutput.getKey());
    }

    public boolean isUnspent(TxOutputKey key) {
        return getUnspentTxOutputMap().containsKey(key);
    }

    public Set<TxOutput> getUnspentTxOutputs() {
        return new HashSet<>(getUnspentTxOutputMap().values());
    }

    public Optional<TxOutput> getUnspentTxOutput(TxOutputKey key) {
        return Optional.ofNullable(getUnspentTxOutputMap().getOrDefault(key, null));
    }

    public long getUnspentTxOutputValue(TxOutputKey key) {
        return getUnspentTxOutput(key)
                .map(BaseTxOutput::getValue)
                .orElse(0L);
    }

    public boolean isTxOutputSpendable(TxOutputKey key) {
        if (!isUnspent(key))
            return false;

        Optional<TxOutput> optionalTxOutput = getUnspentTxOutput(key);
        // The above isUnspent call satisfies optionalTxOutput.isPresent()
        checkArgument(optionalTxOutput.isPresent(), ""optionalTxOutput must be present"");
        TxOutput txOutput = optionalTxOutput.get();
        return isTxOutputSpendable(txOutput);
    }

    public boolean isTxOutputSpendable(TxOutput txOutput) {
        // OP_RETURN_OUTPUTs are actually not spendable but as we have no value on them
        // they would not be used anyway.
        switch (txOutput.getTxOutputType()) {
            case UNDEFINED_OUTPUT:
                return false;
            case GENESIS_OUTPUT:
            case BSQ_OUTPUT:
                return true;
            case BTC_OUTPUT:
                return false;
            case PROPOSAL_OP_RETURN_OUTPUT:
            case COMP_REQ_OP_RETURN_OUTPUT:
            case REIMBURSEMENT_OP_RETURN_OUTPUT:
            case ISSUANCE_CANDIDATE_OUTPUT:
                return true;
            case BLIND_VOTE_LOCK_STAKE_OUTPUT:
                return false;
            case BLIND_VOTE_OP_RETURN_OUTPUT:
            case VOTE_REVEAL_UNLOCK_STAKE_OUTPUT:
            case VOTE_REVEAL_OP_RETURN_OUTPUT:
                return true;
            case ASSET_LISTING_FEE_OP_RETURN_OUTPUT:
            case PROOF_OF_BURN_OP_RETURN_OUTPUT:
                return false;
            case LOCKUP_OUTPUT:
                return false;
            case LOCKUP_OP_RETURN_OUTPUT:
                return true;
            case UNLOCK_OUTPUT:
                return isLockTimeOverForUnlockTxOutput(txOutput);
            case INVALID_OUTPUT:
                return false;
            default:
                return false;
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // TxOutputType
    ///////////////////////////////////////////////////////////////////////////////////////////

    private Set<TxOutput> getTxOutputsByTxOutputType(TxOutputType txOutputType) {
        return daoState.getTxOutputByTxOutputType(txOutputType);
    }

    public boolean isBsqTxOutputType(TxOutput txOutput) {
        final TxOutputType txOutputType = txOutput.getTxOutputType();
        switch (txOutputType) {
            case UNDEFINED_OUTPUT:
                return false;
            case GENESIS_OUTPUT:
            case BSQ_OUTPUT:
                return true;
            case BTC_OUTPUT:
                return false;
            case PROPOSAL_OP_RETURN_OUTPUT:
            case COMP_REQ_OP_RETURN_OUTPUT:
            case REIMBURSEMENT_OP_RETURN_OUTPUT:
                return true;
            case ISSUANCE_CANDIDATE_OUTPUT:
                return isIssuanceTx(txOutput.getTxId());
            case BLIND_VOTE_LOCK_STAKE_OUTPUT:
            case BLIND_VOTE_OP_RETURN_OUTPUT:
            case VOTE_REVEAL_UNLOCK_STAKE_OUTPUT:
            case VOTE_REVEAL_OP_RETURN_OUTPUT:
            case ASSET_LISTING_FEE_OP_RETURN_OUTPUT:
            case PROOF_OF_BURN_OP_RETURN_OUTPUT:
            case LOCKUP_OUTPUT:
            case LOCKUP_OP_RETURN_OUTPUT:
            case UNLOCK_OUTPUT:
                return true;
            case INVALID_OUTPUT:
                return false;
            default:
                return false;
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // TxOutputType - Voting
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Set<TxOutput> getUnspentBlindVoteStakeTxOutputs() {
        return getTxOutputsByTxOutputType(TxOutputType.BLIND_VOTE_LOCK_STAKE_OUTPUT).stream()
                .filter(txOutput -> isUnspent(txOutput.getKey()))
                .collect(Collectors.toSet());
    }

    public Set<TxOutput> getVoteRevealOpReturnTxOutputs() {
        return getTxOutputsByTxOutputType(TxOutputType.VOTE_REVEAL_OP_RETURN_OUTPUT);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // TxOutputType - Issuance
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Set<TxOutput> getIssuanceCandidateTxOutputs() {
        return getTxOutputsByTxOutputType(TxOutputType.ISSUANCE_CANDIDATE_OUTPUT);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Issuance
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void addIssuance(Issuance issuance) {
        assertDaoStateChange();
        daoState.getIssuanceMap().put(issuance.getTxId(), issuance);
    }

    public Set<Issuance> getIssuanceSetForType(IssuanceType issuanceType) {
        return daoState.getIssuanceMap().values().stream()
                .filter(issuance -> issuance.getIssuanceType() == issuanceType)
                .collect(Collectors.toSet());
    }

    public Optional<Issuance> getIssuance(String txId, IssuanceType issuanceType) {
        return getIssuance(txId).filter(issuance -> issuance.getIssuanceType() == issuanceType);
    }

    public Optional<Issuance> getIssuance(String txId) {
        return Optional.ofNullable(daoState.getIssuanceMap().get(txId));
    }

    public boolean isIssuanceTx(String txId) {
        return getIssuance(txId).isPresent();
    }

    public boolean isIssuanceTx(String txId, IssuanceType issuanceType) {
        return getIssuance(txId, issuanceType).isPresent();
    }

    public int getIssuanceBlockHeight(String txId) {
        return getIssuance(txId)
                .map(Issuance::getChainHeight)
                .orElse(0);
    }

    public long getTotalIssuedAmount(IssuanceType issuanceType) {
        return getIssuanceCandidateTxOutputs().stream()
                .filter(txOutput -> isIssuanceTx(txOutput.getTxId(), issuanceType))
                .mapToLong(TxOutput::getValue)
                .sum();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Not accepted issuance candidate outputs of past cycles
    ///////////////////////////////////////////////////////////////////////////////////////////

    public boolean isRejectedIssuanceOutput(TxOutputKey txOutputKey) {
        Cycle currentCycle = getCurrentCycle();
        return currentCycle != null &&
                getIssuanceCandidateTxOutputs().stream()
                        .filter(txOutput -> txOutput.getKey().equals(txOutputKey))
                        .filter(txOutput -> !currentCycle.isInCycle(txOutput.getBlockHeight()))
                        .anyMatch(txOutput -> !isIssuanceTx(txOutput.getTxId()));

    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Bond
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Terminology
    // HashOfBondId - 20 bytes hash of the bond ID
    // Lockup - txOutputs of LOCKUP type
    // Unlocking - UNLOCK txOutputs that are not yet spendable due to lock time
    // Unlocked - UNLOCK txOutputs that are spendable since the lock time has passed
    // LockTime - 0 means that the funds are spendable at the same block of the UNLOCK tx. For the user that is not
    // supported as we do not expose unconfirmed BSQ txs so lockTime of 1 is the smallest the user can actually use.

    // LockTime
    public Optional<Integer> getLockTime(String txId) {
        return getTx(txId).map(Tx::getLockTime);
    }

    public Optional<byte[]> getLockupHash(TxOutput txOutput) {
        Optional<Tx> lockupTx = Optional.empty();
        String txId = txOutput.getTxId();
        if (txOutput.getTxOutputType() == TxOutputType.LOCKUP_OUTPUT) {
            lockupTx = getTx(txId);
        } else if (isUnlockTxOutputAndLockTimeNotOver(txOutput)) {
            if (getTx(txId).isPresent()) {
                Tx unlockTx = getTx(txId).get();
                lockupTx = getTx(unlockTx.getTxInputs().get(0).getConnectedTxOutputTxId());
            }
        }
        if (lockupTx.isPresent()) {
            byte[] opReturnData = lockupTx.get().getLastTxOutput().getOpReturnData();
            if (opReturnData != null)
                return Optional.of(BondConsensus.getHashFromOpReturnData(opReturnData));
        }
        return Optional.empty();
    }

   /* public Set<byte[]> getHashOfBondIdSet() {
        return getTxOutputStream()
                .filter(txOutput -> isUnspent(txOutput.getKey()))
                .filter(txOutput -> txOutput.getTxOutputType() == TxOutputType.LOCKUP ||
                        isUnlockTxOutputAndLockTimeNotOver(txOutput))
                .map(txOutput -> getHash(txOutput).orElse(null))
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }*/

    public boolean isUnlockTxOutputAndLockTimeNotOver(TxOutput txOutput) {
        return txOutput.getTxOutputType() == TxOutputType.UNLOCK_OUTPUT && !isLockTimeOverForUnlockTxOutput(txOutput);
    }

    // Lockup
    public boolean isLockupOutput(TxOutputKey key) {
        Optional<TxOutput> opTxOutput = getUnspentTxOutput(key);
        return opTxOutput.isPresent() && isLockupOutput(opTxOutput.get());
    }

    public boolean isLockupOutput(TxOutput txOutput) {
        return txOutput.getTxOutputType() == TxOutputType.LOCKUP_OUTPUT;
    }

    public Set<TxOutput> getLockupTxOutputs() {
        return getTxOutputsByTxOutputType(TxOutputType.LOCKUP_OUTPUT);
    }

    public Set<TxOutput> getUnlockTxOutputs() {
        return getTxOutputsByTxOutputType(TxOutputType.UNLOCK_OUTPUT);
    }

    public Set<TxOutput> getUnspentLockUpTxOutputs() {
        return getTxOutputsByTxOutputType(TxOutputType.LOCKUP_OUTPUT).stream()
                .filter(txOutput -> isUnspent(txOutput.getKey()))
                .collect(Collectors.toSet());
    }

    public Optional<TxOutput> getLockupTxOutput(String txId) {
        return getTx(txId).flatMap(tx -> tx.getTxOutputs().stream()
                .filter(this::isLockupOutput)
                .findFirst());
    }

    public Optional<TxOutput> getLockupOpReturnTxOutput(String txId) {
        return getTx(txId).map(Tx::getLastTxOutput).filter(txOutput -> txOutput.getOpReturnData() != null);
    }

    // Returns amount of all LOCKUP txOutputs (they might have been unlocking or unlocked in the meantime)
    public long getTotalAmountOfLockupTxOutputs() {
        return getLockupTxOutputs().stream()
                .filter(txOutput -> !isConfiscatedLockupTxOutput(txOutput.getTxId()))
                .mapToLong(TxOutput::getValue)
                .sum();
    }

    // Returns the current locked up amount (excluding unlocking and unlocked)
    public long getTotalLockupAmount() {
        return getTotalAmountOfLockupTxOutputs() - getTotalAmountOfUnLockingTxOutputs() - getTotalAmountOfUnLockedTxOutputs();
    }


    // Unlock
    public boolean isUnspentUnlockOutput(TxOutputKey key) {
        Optional<TxOutput> opTxOutput = getUnspentTxOutput(key);
        return opTxOutput.isPresent() && isUnlockOutput(opTxOutput.get());
    }

    public boolean isUnlockOutput(TxOutput txOutput) {
        return txOutput.getTxOutputType() == TxOutputType.UNLOCK_OUTPUT;
    }

    // Unlocking
    // Return UNLOCK TxOutputs that are not yet spendable as lockTime is not over
    public Stream<TxOutput> getUnspentUnlockingTxOutputsStream() {
        return getTxOutputsByTxOutputType(TxOutputType.UNLOCK_OUTPUT).stream()
                .filter(txOutput -> isUnspent(txOutput.getKey()))
                .filter(txOutput -> !isLockTimeOverForUnlockTxOutput(txOutput));
    }

    public long getTotalAmountOfUnLockingTxOutputs() {
        return getUnspentUnlockingTxOutputsStream()
                .filter(txOutput -> !isConfiscatedUnlockTxOutput(txOutput.getTxId()))
                .mapToLong(TxOutput::getValue)
                .sum();
    }

    public boolean isUnlockingAndUnspent(TxOutputKey key) {
        Optional<TxOutput> opTxOutput = getUnspentTxOutput(key);
        return opTxOutput.isPresent() && isUnlockingAndUnspent(opTxOutput.get());
    }

    public boolean isUnlockingAndUnspent(String unlockTxId) {
        Optional<Tx> optionalTx = getTx(unlockTxId);
        return optionalTx.isPresent() && isUnlockingAndUnspent(optionalTx.get().getTxOutputs().get(0));
    }

    public boolean isUnlockingAndUnspent(TxOutput unlockTxOutput) {
        return unlockTxOutput.getTxOutputType() == TxOutputType.UNLOCK_OUTPUT &&
                isUnspent(unlockTxOutput.getKey()) &&
                !isLockTimeOverForUnlockTxOutput(unlockTxOutput);
    }

    public Optional<Tx> getLockupTxFromUnlockTxId(String unlockTxId) {
        return getTx(unlockTxId).flatMap(tx -> getTx(tx.getTxInputs().get(0).getConnectedTxOutputTxId()));
    }

    public Optional<Tx> getUnlockTxFromLockupTxId(String lockupTxId) {
        return getTx(lockupTxId).flatMap(tx -> getSpentInfo(tx.getTxOutputs().get(0))).flatMap(spentInfo -> getTx(spentInfo.getTxId()));
    }

    // Unlocked
    public Optional<Integer> getUnlockBlockHeight(String txId) {
        return getTx(txId).map(Tx::getUnlockBlockHeight);
    }

    public boolean isLockTimeOverForUnlockTxOutput(TxOutput unlockTxOutput) {
        checkArgument(isUnlockOutput(unlockTxOutput), ""txOutput must be of type UNLOCK"");
        return getUnlockBlockHeight(unlockTxOutput.getTxId())
                .map(unlockBlockHeight -> BondConsensus.isLockTimeOver(unlockBlockHeight, getChainHeight()))
                .orElse(false);
    }

    // We don't care here about the unspent state
    public Stream<TxOutput> getUnlockedTxOutputsStream() {
        return getTxOutputsByTxOutputType(TxOutputType.UNLOCK_OUTPUT).stream()
                .filter(txOutput -> !isConfiscatedUnlockTxOutput(txOutput.getTxId()))
                .filter(this::isLockTimeOverForUnlockTxOutput);
    }

    public long getTotalAmountOfUnLockedTxOutputs() {
        return getUnlockedTxOutputsStream()
                .mapToLong(TxOutput::getValue)
                .sum();
    }

    public long getTotalAmountOfConfiscatedTxOutputs() {
        return daoState.getConfiscatedLockupTxList()
                .stream()
                .flatMap(e -> getTx(e).stream())
                .mapToLong(tx -> tx.getLockupOutput().getValue())
                .sum();
    }

    public long getTotalAmountOfInvalidatedBsq() {
        return getUnorderedTxStream().mapToLong(Tx::getInvalidatedBsq).sum();
    }

    // Contains burnt fee and invalidated bsq due invalid txs
    public long getTotalAmountOfBurntBsq() {
        return getUnorderedTxStream().mapToLong(Tx::getBurntBsq).sum();
    }

    // Confiscate bond
    public void confiscateBond(String lockupTxId) {
        Optional<TxOutput> optionalTxOutput = getLockupTxOutput(lockupTxId);
        if (optionalTxOutput.isPresent()) {
            TxOutput lockupTxOutput = optionalTxOutput.get();
            if (isUnspent(lockupTxOutput.getKey())) {
                log.warn(""confiscateBond: lockupTxOutput {} is still unspent so we can confiscate it."", lockupTxOutput.getKey());
                doConfiscateBond(lockupTxId);
            } else {
                // We lookup for the unlock tx which need to be still in unlocking state
                Optional<SpentInfo> optionalSpentInfo = getSpentInfo(lockupTxOutput);
                checkArgument(optionalSpentInfo.isPresent(), ""optionalSpentInfo must be present"");
                String unlockTxId = optionalSpentInfo.get().getTxId();
                if (isUnlockingAndUnspent(unlockTxId)) {
                    // We found the unlock tx is still not spend
                    log.warn(""confiscateBond: lockupTxOutput {} is still unspent so we can We confiscate it."", lockupTxOutput.getKey());
                    doConfiscateBond(lockupTxId);
                } else {
                    // We could be more radical here and confiscate the output if it is unspent but lock time is over,
                    // but it's probably better to stick to the rules that confiscation can only happen before lock time
                    // is over.
                    log.warn(""We could not confiscate the bond because the unlock tx was already spent or lock time "" +
                            ""has exceeded. unlockTxId={}"", unlockTxId);
                }
            }
        } else {
            log.warn(""No lockupTxOutput found for lockupTxId {}"", lockupTxId);
        }
    }

    private void doConfiscateBond(String lockupTxId) {
        assertDaoStateChange();
        log.warn(""TxId {} added to confiscatedLockupTxIdList."", lockupTxId);
        daoState.getConfiscatedLockupTxList().add(lockupTxId);
    }

    public boolean isConfiscatedOutput(TxOutputKey txOutputKey) {
        if (isLockupOutput(txOutputKey))
            return isConfiscatedLockupTxOutput(txOutputKey.getTxId());
        else if (isUnspentUnlockOutput(txOutputKey))
            return isConfiscatedUnlockTxOutput(txOutputKey.getTxId());
        return false;
    }

    public boolean isConfiscatedLockupTxOutput(String lockupTxId) {
        return daoState.getConfiscatedLockupTxList().contains(lockupTxId);
    }

    public boolean isConfiscatedUnlockTxOutput(String unlockTxId) {
        return getLockupTxFromUnlockTxId(unlockTxId).
                map(lockupTx -> isConfiscatedLockupTxOutput(lockupTx.getId())).
                orElse(false);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Param
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void setNewParam(int blockHeight, Param param, String paramValue) {
        assertDaoStateChange();
        List<ParamChange> paramChangeList = daoState.getParamChangeList();
        getStartHeightOfNextCycle(blockHeight)
                .ifPresent(heightOfNewCycle -> {
                    ParamChange paramChange = new ParamChange(param.name(), paramValue, heightOfNewCycle);
                    paramChangeList.add(paramChange);
                    // Addition with older height should not be possible but to ensure correct sorting lets run a sort.
                    paramChangeList.sort(Comparator.comparingInt(ParamChange::getActivationHeight));
                });
    }

    public String getParamValue(Param param, int blockHeight) {
        List<ParamChange> paramChangeList = new ArrayList<>(daoState.getParamChangeList());
        if (!paramChangeList.isEmpty()) {
            // List is sorted by height, we start from latest entries to find most recent entry.
            for (int i = paramChangeList.size() - 1; i >= 0; i--) {
                ParamChange paramChange = paramChangeList.get(i);
                if (paramChange.getParamName().equals(param.name()) &&
                        blockHeight >= paramChange.getActivationHeight()) {
                    return paramChange.getValue();
                }
            }
        }

        // If no value found we use default values
        return param.getDefaultValue();
    }

    public List<Coin> getParamChangeList(Param param) {
        List<Coin> values = new ArrayList<>();
        for (ParamChange paramChange : daoState.getParamChangeList()) {
            if (paramChange.getParamName().equals(param.name())) {
                values.add(getParamValueAsCoin(param, paramChange.getValue()));
            }
        }
        return values;
    }

    public Coin getParamValueAsCoin(Param param, String paramValue) {
        return bsqFormatter.parseParamValueToCoin(param, paramValue);
    }

    public double getParamValueAsPercentDouble(String paramValue) {
        return ParsingUtils.parsePercentStringToDouble(paramValue);
    }

    public int getParamValueAsBlock(String paramValue) {
        return Integer.parseInt(paramValue);
    }

    public Coin getParamValueAsCoin(Param param, int blockHeight) {
        return getParamValueAsCoin(param, getParamValue(param, blockHeight));
    }

    public double getParamValueAsPercentDouble(Param param, int blockHeight) {
        return getParamValueAsPercentDouble(getParamValue(param, blockHeight));
    }

    public int getParamValueAsBlock(Param param, int blockHeight) {
        return getParamValueAsBlock(getParamValue(param, blockHeight));
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // SpentInfo
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void setSpentInfo(TxOutputKey txOutputKey, SpentInfo spentInfo) {
        assertDaoStateChange();
        daoState.getSpentInfoMap().put(txOutputKey, spentInfo);
    }

    public Optional<SpentInfo> getSpentInfo(TxOutput txOutput) {
        return Optional.ofNullable(daoState.getSpentInfoMap().getOrDefault(txOutput.getKey(), null));
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Vote result data
    ///////////////////////////////////////////////////////////////////////////////////////////

    public List<EvaluatedProposal> getEvaluatedProposalList() {
        return daoState.getEvaluatedProposalList();
    }

    public void addEvaluatedProposalSet(Set<EvaluatedProposal> evaluatedProposals) {
        assertDaoStateChange();

        evaluatedProposals.stream()
                .filter(e -> !daoState.getEvaluatedProposalList().contains(e))
                .forEach(daoState.getEvaluatedProposalList()::add);

        // We need deterministic order for the hash chain
        daoState.getEvaluatedProposalList().sort(Comparator.comparing(EvaluatedProposal::getProposalTxId));
    }

    public List<DecryptedBallotsWithMerits> getDecryptedBallotsWithMeritsList() {
        return daoState.getDecryptedBallotsWithMeritsList();
    }

    public void addDecryptedBallotsWithMeritsSet(Set<DecryptedBallotsWithMerits> decryptedBallotsWithMeritsSet) {
        assertDaoStateChange();

        decryptedBallotsWithMeritsSet.stream()
                .filter(e -> !daoState.getDecryptedBallotsWithMeritsList().contains(e))
                .forEach(daoState.getDecryptedBallotsWithMeritsList()::add);

        // We need deterministic order for the hash chain
        daoState.getDecryptedBallotsWithMeritsList().sort(Comparator.comparing(DecryptedBallotsWithMerits::getBlindVoteTxId));
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Asset listing fee
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Set<TxOutput> getAssetListingFeeOpReturnTxOutputs() {
        return getTxOutputsByTxOutputType(TxOutputType.ASSET_LISTING_FEE_OP_RETURN_OUTPUT);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Proof of burn
    ///////////////////////////////////////////////////////////////////////////////////////////

    public Set<TxOutput> getProofOfBurnOpReturnTxOutputs() {
        return getTxOutputsByTxOutputType(TxOutputType.PROOF_OF_BURN_OP_RETURN_OUTPUT);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Listeners
    ///////////////////////////////////////////////////////////////////////////////////////////

    public void addDaoStateListener(DaoStateListener listener) {
        daoStateListeners.add(listener);
    }

    public void removeDaoStateListener(DaoStateListener listener) {
        daoStateListeners.remove(listener);
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////////////////////////////////////////

    public String daoStateToString() {
        return daoState.toString();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void assertDaoStateChange() {
        if (!allowDaoStateChange)
            throw new RuntimeException(""We got a call which would change the daoState outside of the allowed event phase"");
    }
}",1,64 2000 777 587 2001 693 2002 123 773 657 2003 2004 59 773 657 2005 2006 59 773 657 2007 2008 59 773 657 2009 60 2010 62 2011 61 744 2012 60 62 40 41 59 64 2013 773 570 2014 59 773 570 2015 59 331 330 331 64 2016 777 2001 40 2003 2004 44 2005 2006 44 2007 2008 41 123 823 46 2004 61 2004 59 823 46 2006 61 2006 59 823 46 2008 61 2008 59 125 331 330 331 64 2017 777 865 2018 40 41 123 125 64 2017 777 865 2019 40 41 123 2015 61 2020 59 2021 40 41 59 2004 46 2022 40 2006 46 2023 40 41 41 59 125 331 330 331 777 865 2024 40 2003 2025 41 123 2015 61 2026 59 2027 40 41 59 2028 46 2029 40 362 44 2025 46 2030 40 41 41 59 2004 46 2031 40 2025 46 2030 40 41 41 59 2004 46 2032 40 2025 46 2033 40 41 41 59 2004 46 2034 40 2025 46 2035 40 41 41 59 2004 46 2036 40 41 46 2037 40 41 59 2004 46 2036 40 41 46 2038 40 2025 46 2036 40 41 41 59 2004 46 2039 40 41 46 2037 40 41 59 2004 46 2039 40 41 46 2040 40 2025 46 2039 40 41 41 59 2004 46 2041 40 41 46 2037 40 41 59 2004 46 2041 40 41 46 2040 40 2025 46 2041 40 41 41 59 2004 46 2042 40 41 46 2037 40 41 59 2004 46 2042 40 41 46 2038 40 2025 46 2042 40 41 41 59 2004 46 2043 40 41 46 2037 40 41 59 2004 46 2043 40 41 46 2040 40 2025 46 2043 40 41 41 59 2004 46 2044 40 41 46 2037 40 41 59 2004 46 2044 40 41 46 2038 40 2025 46 2044 40 41 41 59 2004 46 2045 40 41 46 2037 40 41 59 2004 46 2045 40 41 46 2038 40 2025 46 2045 40 41 41 59 2004 46 2046 40 41 46 2037 40 41 59 2004 46 2046 40 41 46 2038 40 2025 46 2046 40 41 41 59 125 777 2003 2047 40 41 123 792 2003 46 2047 40 2004 41 59 125 777 2048 46 2003 2049 40 41 123 792 2003 46 2049 40 2004 41 59 125 777 574 91 93 2050 40 41 123 792 2004 46 2050 40 41 59 125 331 330 331 777 704 2051 40 41 123 792 2004 46 2051 40 41 59 125 331 330 331 777 2052 60 2053 62 2054 40 41 123 792 2004 46 2054 40 41 59 125 777 865 2055 40 2053 2056 41 123 2057 40 41 59 2054 40 41 46 2058 40 2056 41 59 125 64 2059 777 2053 2060 40 41 123 792 33 2054 40 41 46 2061 40 41 63 2054 40 41 46 2062 40 41 58 2063 59 125 777 2064 60 2053 62 2065 40 704 2066 41 123 792 2054 40 41 46 2067 40 41 46 2068 40 2056 45 62 2056 46 2069 40 41 329 2066 41 46 2068 40 2056 45 62 2056 46 2070 40 41 325 2066 41 46 2071 40 41 59 125 777 2064 60 2072 62 2073 40 704 2074 41 123 792 2065 40 2074 41 46 2075 40 2056 45 62 2056 46 2076 40 41 43 1501 41 59 125 777 2064 60 2072 62 2077 40 704 2074 41 123 792 2065 40 2074 41 46 2078 40 2056 45 62 2056 46 2079 40 41 41 59 125 331 330 331 331 330 331 330 777 865 2080 40 704 2074 41 123 2015 61 2081 59 2004 46 2082 40 2074 41 59 2011 46 2083 40 2084 45 62 2084 46 2080 40 2074 41 41 59 125 330 777 865 2085 40 2086 2087 41 123 2088 40 41 59 688 40 2004 46 2089 40 41 46 2090 40 41 307 2087 46 2091 40 41 340 2092 40 41 41 123 2093 46 2094 40 362 43 362 43 362 44 2087 41 59 125 630 123 2004 46 2095 40 2087 41 59 688 40 2014 41 2096 46 2097 40 362 44 2087 46 2091 40 41 41 59 125 125 330 777 865 2098 40 2086 2087 44 2099 2100 41 123 2101 40 41 59 2102 40 41 46 2103 40 2104 45 62 123 688 40 2087 323 2104 41 123 330 2087 46 2105 40 2100 41 59 2004 46 2106 40 2100 41 59 125 630 123 330 330 2107 46 2108 40 362 43 362 44 2087 41 59 125 125 41 59 125 330 777 865 2109 40 2086 2087 41 123 688 40 2014 41 2110 46 2111 40 362 44 2087 46 2112 40 41 44 2087 46 2113 40 41 46 2114 40 41 41 59 330 330 330 330 2011 46 2115 40 2116 45 62 2116 46 2109 40 2087 41 41 59 330 330 330 330 688 40 2014 41 2011 46 2115 40 2116 45 62 2116 46 2117 40 2087 41 41 59 330 330 2015 61 2118 59 2011 46 2115 40 2116 45 62 2116 46 2119 40 2087 41 41 59 125 330 777 865 2120 40 41 123 2121 46 2122 40 362 41 59 2014 61 2123 59 2124 40 41 46 2125 40 2087 45 62 123 2011 46 2126 40 2127 45 62 2127 46 2128 40 2087 41 41 59 125 41 59 2011 46 2129 40 2010 58 58 2120 41 59 125 777 2009 60 2086 62 2130 40 41 123 792 2004 46 2130 40 41 59 125 777 2064 60 2086 62 2131 40 41 123 688 40 33 2130 40 41 46 2132 40 41 41 792 2064 46 2133 40 2004 46 2131 40 41 41 59 630 792 2064 46 2134 40 41 59 125 777 704 2135 40 41 123 792 2131 40 41 46 2136 40 2086 58 58 2137 41 46 2138 40 1500 41 59 125 777 2139 2140 40 41 123 792 2131 40 41 46 2141 40 2086 58 58 2142 41 46 2143 40 362 41 59 125 777 2064 60 2086 62 2144 40 704 2066 41 123 792 2064 46 2145 40 2004 46 2146 40 41 46 2147 40 2066 41 41 59 125 777 726 2148 40 704 2066 41 123 792 2144 40 2066 41 46 2149 40 2086 58 58 2150 41 46 2151 40 1500 41 59 125 777 570 2152 40 2086 2087 41 123 792 2130 40 41 46 2153 40 2087 41 59 125 777 726 2154 40 704 2066 41 123 792 2144 40 2066 41 46 2155 40 2086 58 58 2156 41 46 2157 40 1500 41 59 125 777 2009 60 2086 62 2158 40 704 2159 41 123 792 2158 40 2159 44 2072 46 2160 41 59 125 777 2009 60 2086 62 2158 40 704 2159 44 704 2161 41 123 330 330 792 2130 40 41 46 2162 40 41 46 2163 40 2087 45 62 2087 46 2164 40 41 325 2159 41 46 2165 40 2161 41 46 2166 40 2167 46 2168 40 41 41 59 125 331 330 331 777 2139 2169 40 41 123 792 2006 46 2169 40 41 59 125 777 704 2170 40 41 123 792 2006 46 2170 40 41 59 125 777 2171 2172 40 41 123 792 2171 46 2173 40 2006 46 2172 40 41 41 59 125 777 2064 60 2099 62 2174 40 41 123 792 2175 40 2169 40 41 41 59 125 331 330 331 777 2176 60 2099 62 2177 40 41 123 792 2004 46 2178 40 41 46 2179 40 41 46 2180 40 41 59 125 777 704 2181 40 41 123 792 2004 46 2182 40 41 46 2183 40 41 59 125 777 2009 60 2099 62 2184 40 41 123 792 2177 40 41 46 2185 40 2100 45 62 2100 46 2186 40 41 323 2187 46 2188 41 46 2189 40 2190 46 2191 40 41 41 59 125 777 2009 60 2099 62 2192 40 41 123 792 2177 40 41 46 2193 40 2100 45 62 2100 46 2194 40 41 323 2195 46 2196 41 46 2197 40 2198 46 2199 40 41 41 59 125 777 2064 60 2099 62 2200 40 2139 2201 41 123 792 2064 46 2202 40 2004 46 2203 40 41 46 2204 40 2201 41 41 59 125 777 570 2205 40 2139 2201 41 123 792 2200 40 2201 41 46 2206 40 41 59 125 331 330 331 777 2064 60 2207 62 2208 40 2139 2201 41 123 792 2200 40 2201 41 46 2209 40 2099 58 58 2210 41 59 125 331 330 331 777 726 2211 40 2139 2201 41 123 792 2200 40 2201 41 46 2212 40 2099 58 58 2211 41 46 2213 40 1500 41 59 125 777 570 2214 40 2139 2201 41 123 792 2211 40 2201 41 62 1500 59 125 777 2215 60 2099 62 2216 40 41 123 792 2177 40 41 46 2217 40 2100 45 62 2100 46 2218 40 41 323 2207 46 2219 41 46 2220 40 2221 46 2222 40 41 41 59 125 777 2215 60 2099 62 2223 40 41 123 792 2177 40 41 46 2224 40 2100 45 62 2100 46 2225 40 41 323 2207 46 2226 41 46 2227 40 2228 46 2229 40 41 41 59 125 330 777 2215 60 2099 62 2230 40 41 123 792 2177 40 41 46 2231 40 2100 45 62 2100 46 2211 40 41 62 1500 41 46 2232 40 2233 46 2234 40 41 41 59 125 331 330 331 777 2064 60 2235 62 2236 40 2237 2238 41 123 792 2200 40 2238 46 2239 40 41 41 46 2240 40 2100 45 62 2100 46 2241 40 41 46 2242 40 2238 46 2243 40 41 41 41 59 125 331 330 331 773 2176 60 2235 62 2244 40 41 123 792 2177 40 41 46 2245 40 2100 45 62 2100 46 2246 40 41 46 2247 40 41 41 59 125 777 570 2248 40 2249 2250 41 123 792 2244 40 41 46 2251 40 2252 45 62 2252 46 2253 40 41 46 2254 40 2250 41 41 59 125 777 2064 60 2235 62 2255 40 2249 2256 41 123 792 2244 40 41 46 2257 40 2258 45 62 2258 46 2259 40 41 46 2260 40 2256 41 41 46 2261 40 41 59 125 331 330 331 777 2262 60 2249 44 2235 62 2263 40 41 123 792 2004 46 2263 40 41 59 125 777 865 2264 40 2235 2265 41 123 2266 40 41 59 2263 40 41 46 2267 40 2265 46 2268 40 41 44 2265 41 59 125 777 865 2269 40 2235 2265 41 123 2270 40 41 59 2263 40 41 46 2271 40 2265 46 2272 40 41 41 59 125 777 570 2273 40 2249 2250 41 123 792 2263 40 41 46 2274 40 2250 41 59 125 777 2215 60 2235 62 2275 40 41 123 792 744 2276 60 62 40 2263 40 41 46 2277 40 41 41 59 125 777 2064 60 2235 62 2278 40 2249 2250 41 123 792 2064 46 2279 40 2263 40 41 46 2280 40 2250 44 2281 41 41 59 125 777 726 2282 40 2249 2250 41 123 792 2278 40 2250 41 46 2283 40 2284 58 58 2285 41 46 2286 40 1500 41 59 125 777 570 2287 40 2249 2250 41 123 688 40 33 2273 40 2250 41 41 792 2288 59 2064 60 2235 62 2289 61 2278 40 2250 41 59 330 2290 40 2289 46 2291 40 41 44 362 41 59 2235 2265 61 2289 46 2292 40 41 59 792 2287 40 2265 41 59 125 777 570 2287 40 2235 2265 41 123 330 330 819 40 2265 46 2293 40 41 41 123 579 2294 58 792 2295 59 579 2296 58 579 2297 58 792 2298 59 579 2299 58 792 2295 59 579 2300 58 579 2301 58 579 2302 58 579 2303 58 792 2298 59 579 2304 58 792 2295 59 579 2305 58 579 2306 58 579 2307 58 792 2298 59 579 2308 58 579 2309 58 792 2295 59 579 2310 58 792 2295 59 579 2311 58 792 2298 59 579 2312 58 792 2313 40 2265 41 59 579 2314 58 792 2295 59 613 58 792 2295 59 125 125 331 330 331 773 2215 60 2235 62 2315 40 2316 2317 41 123 792 2004 46 2318 40 2317 41 59 125 777 570 2319 40 2235 2265 41 123 657 2316 2317 61 2265 46 2320 40 41 59 819 40 2317 41 123 579 2321 58 792 2322 59 579 2323 58 579 2324 58 792 2325 59 579 2326 58 792 2322 59 579 2327 58 579 2328 58 579 2329 58 792 2325 59 579 2330 58 792 2331 40 2265 46 2332 40 41 41 59 579 2333 58 579 2334 58 579 2335 58 579 2336 58 579 2337 58 579 2338 58 579 2339 58 579 2340 58 579 2341 58 792 2325 59 579 2342 58 792 2322 59 613 58 792 2322 59 125 125 331 330 331 777 2215 60 2235 62 2343 40 41 123 792 2315 40 2316 46 2344 41 46 2345 40 41 46 2346 40 2265 45 62 2273 40 2265 46 2347 40 41 41 41 46 2348 40 2349 46 2350 40 41 41 59 125 777 2215 60 2235 62 2351 40 41 123 792 2315 40 2316 46 2352 41 59 125 331 330 331 777 2215 60 2235 62 2353 40 41 123 792 2315 40 2316 46 2354 41 59 125 331 330 331 777 865 2355 40 2356 2357 41 123 2358 40 41 59 2004 46 2359 40 41 46 2360 40 2357 46 2361 40 41 44 2357 41 59 125 777 2215 60 2356 62 2362 40 2363 2364 41 123 792 2004 46 2365 40 41 46 2366 40 41 46 2367 40 41 46 2368 40 2357 45 62 2357 46 2369 40 41 323 2364 41 46 2370 40 2371 46 2372 40 41 41 59 125 777 2064 60 2356 62 2373 40 2139 2201 44 2363 2364 41 123 792 2373 40 2201 41 46 2374 40 2357 45 62 2357 46 2375 40 41 323 2364 41 59 125 777 2064 60 2356 62 2373 40 2139 2201 41 123 792 2064 46 2376 40 2004 46 2377 40 41 46 2378 40 2201 41 41 59 125 777 570 2379 40 2139 2201 41 123 792 2373 40 2201 41 46 2380 40 41 59 125 777 570 2379 40 2139 2201 44 2363 2364 41 123 792 2373 40 2201 44 2364 41 46 2381 40 41 59 125 777 704 2382 40 2139 2201 41 123 792 2373 40 2201 41 46 2383 40 2356 58 58 2051 41 46 2384 40 1500 41 59 125 777 726 2385 40 2363 2364 41 123 792 2353 40 41 46 2386 40 41 46 2387 40 2265 45 62 2379 40 2265 46 2388 40 41 44 2364 41 41 46 2389 40 2235 58 58 2390 41 46 2391 40 41 59 125 331 330 331 777 570 2392 40 2249 2256 41 123 2053 2393 61 2060 40 41 59 792 2393 340 2394 307 2353 40 41 46 2395 40 41 46 2396 40 2265 45 62 2265 46 2397 40 41 46 2398 40 2256 41 41 46 2396 40 2265 45 62 33 2393 46 2399 40 2265 46 2400 40 41 41 41 46 2401 40 2265 45 62 33 2379 40 2265 46 2402 40 41 41 41 59 125 331 330 331 330 330 330 330 330 330 330 330 777 2064 60 2072 62 2403 40 2139 2201 41 123 792 2200 40 2201 41 46 2404 40 2099 58 58 2403 41 59 125 777 2064 60 574 91 93 62 2405 40 2235 2265 41 123 2064 60 2099 62 2406 61 2064 46 2407 40 41 59 2139 2201 61 2265 46 2408 40 41 59 688 40 2265 46 2409 40 41 323 2316 46 2410 41 123 2406 61 2200 40 2201 41 59 125 630 688 40 2411 40 2265 41 41 123 688 40 2200 40 2201 41 46 2412 40 41 41 123 2099 2413 61 2200 40 2201 41 46 2414 40 41 59 2406 61 2200 40 2413 46 2415 40 41 46 2414 40 1500 41 46 2416 40 41 41 59 125 125 688 40 2406 46 2417 40 41 41 123 574 91 93 2418 61 2406 46 2419 40 41 46 2420 40 41 46 2421 40 41 59 688 40 2418 340 2422 41 792 2064 46 2423 40 2424 46 2425 40 2418 41 41 59 125 792 2064 46 2407 40 41 59 125 305 777 570 2426 40 2235 2265 41 123 792 2265 46 2427 40 41 323 2316 46 2428 307 33 2429 40 2265 41 59 125 330 777 570 2430 40 2249 2250 41 123 2064 60 2235 62 2431 61 2278 40 2250 41 59 792 2431 46 2432 40 41 307 2430 40 2431 46 2433 40 41 41 59 125 777 570 2430 40 2235 2265 41 123 792 2265 46 2434 40 41 323 2316 46 2435 59 125 777 2215 60 2235 62 2436 40 41 123 792 2315 40 2316 46 2437 41 59 125 777 2215 60 2235 62 2438 40 41 123 792 2315 40 2316 46 2439 41 59 125 777 2215 60 2235 62 2440 40 41 123 792 2315 40 2316 46 2441 41 46 2442 40 41 46 2443 40 2265 45 62 2273 40 2265 46 2444 40 41 41 41 46 2445 40 2446 46 2447 40 41 41 59 125 777 2064 60 2235 62 2448 40 2139 2201 41 123 792 2200 40 2201 41 46 2449 40 2100 45 62 2100 46 2450 40 41 46 2451 40 41 46 2452 40 823 58 58 2430 41 46 2453 40 41 41 59 125 777 2064 60 2235 62 2454 40 2139 2201 41 123 792 2200 40 2201 41 46 2455 40 2099 58 58 2456 41 46 2457 40 2265 45 62 2265 46 2458 40 41 340 2459 41 59 125 330 777 726 2460 40 41 123 792 2436 40 41 46 2461 40 41 46 2462 40 2265 45 62 33 2463 40 2265 46 2464 40 41 41 41 46 2465 40 2235 58 58 2466 41 46 2467 40 41 59 125 330 777 726 2468 40 41 123 792 2460 40 41 45 2469 40 41 45 2470 40 41 59 125 330 777 570 2471 40 2249 2250 41 123 2064 60 2235 62 2472 61 2278 40 2250 41 59 792 2472 46 2473 40 41 307 2474 40 2472 46 2475 40 41 41 59 125 777 570 2476 40 2235 2265 41 123 792 2265 46 2477 40 41 323 2316 46 2478 59 125 330 330 777 2176 60 2235 62 2479 40 41 123 792 2315 40 2316 46 2480 41 46 2481 40 41 46 2482 40 2265 45 62 2273 40 2265 46 2483 40 41 41 41 46 2482 40 2265 45 62 33 2484 40 2265 41 41 59 125 777 726 2485 40 41 123 792 2479 40 41 46 2486 40 2265 45 62 33 2487 40 2265 46 2488 40 41 41 41 46 2489 40 2235 58 58 2490 41 46 2491 40 41 59 125 777 570 2492 40 2249 2250 41 123 2064 60 2235 62 2493 61 2278 40 2250 41 59 792 2493 46 2494 40 41 307 2492 40 2493 46 2495 40 41 41 59 125 777 570 2492 40 2139 2496 41 123 2064 60 2099 62 2497 61 2200 40 2496 41 59 792 2497 46 2498 40 41 307 2492 40 2497 46 2499 40 41 46 2500 40 41 46 2499 40 1500 41 41 59 125 777 570 2492 40 2235 2501 41 123 792 2501 46 2502 40 41 323 2316 46 2503 307 2273 40 2501 46 2504 40 41 41 307 33 2505 40 2501 41 59 125 777 2064 60 2099 62 2506 40 2139 2496 41 123 792 2200 40 2496 41 46 2507 40 2100 45 62 2200 40 2100 46 2508 40 41 46 2509 40 1500 41 46 2510 40 41 41 41 59 125 777 2064 60 2099 62 2511 40 2139 2512 41 123 792 2200 40 2512 41 46 2513 40 2100 45 62 2514 40 2100 46 2515 40 41 46 2516 40 1500 41 41 41 46 2513 40 2517 45 62 2200 40 2517 46 2518 40 41 41 41 59 125 330 777 2064 60 2072 62 2519 40 2139 2201 41 123 792 2200 40 2201 41 46 2520 40 2099 58 58 2519 41 59 125 777 570 2521 40 2235 2501 41 123 2522 40 2476 40 2501 41 44 362 41 59 792 2519 40 2501 46 2523 40 41 41 46 2524 40 2525 45 62 2526 46 2527 40 2525 44 2051 40 41 41 41 46 2528 40 2529 41 59 125 330 777 2176 60 2235 62 2530 40 41 123 792 2315 40 2316 46 2531 41 46 2532 40 41 46 2533 40 2265 45 62 33 2534 40 2265 46 2535 40 41 41 41 46 2533 40 823 58 58 2521 41 59 125 777 726 2536 40 41 123 792 2530 40 41 46 2537 40 2235 58 58 2538 41 46 2539 40 41 59 125 777 726 2540 40 41 123 792 2004 46 2541 40 41 46 2542 40 41 46 2543 40 2544 45 62 2200 40 2544 41 46 2542 40 41 41 46 2545 40 2100 45 62 2100 46 2546 40 41 46 2547 40 41 41 46 2548 40 41 59 125 777 726 2549 40 41 123 792 2177 40 41 46 2550 40 2099 58 58 2551 41 46 2552 40 41 59 125 330 777 726 2553 40 41 123 792 2177 40 41 46 2554 40 2099 58 58 2555 41 46 2556 40 41 59 125 330 777 865 2557 40 2139 2512 41 123 2064 60 2235 62 2558 61 2448 40 2512 41 59 688 40 2558 46 2559 40 41 41 123 2235 2560 61 2558 46 2561 40 41 59 688 40 2273 40 2560 46 2562 40 41 41 41 123 2563 46 2564 40 362 44 2560 46 2562 40 41 41 59 2565 40 2512 41 59 125 630 123 330 2064 60 2566 62 2567 61 2568 40 2560 41 59 2569 40 2567 46 2559 40 41 44 362 41 59 2139 2496 61 2567 46 2561 40 41 46 2570 40 41 59 688 40 2492 40 2496 41 41 123 330 2571 46 2572 40 362 44 2560 46 2562 40 41 41 59 2573 40 2512 41 59 125 630 123 330 330 330 2574 46 2575 40 362 43 362 44 2496 41 59 125 125 125 630 123 2576 46 2577 40 362 44 2512 41 59 125 125 773 865 2578 40 2139 2512 41 123 2579 40 41 59 2580 46 2581 40 362 44 2512 41 59 2004 46 2582 40 41 46 2583 40 2512 41 59 125 777 570 2584 40 2249 2256 41 123 688 40 2430 40 2256 41 41 792 2585 40 2256 46 2586 40 41 41 59 630 688 40 2471 40 2256 41 41 792 2587 40 2256 46 2586 40 41 41 59 792 2588 59 125 777 570 2589 40 2139 2512 41 123 792 2004 46 2590 40 41 46 2591 40 2512 41 59 125 777 570 2592 40 2139 2496 41 123 792 2506 40 2496 41 46 2593 40 2594 45 62 2589 40 2594 46 2595 40 41 41 41 46 2596 40 2597 41 59 125 331 330 331 777 865 2598 40 704 2074 44 2599 2600 44 2139 2601 41 123 2602 40 41 59 2009 60 2603 62 2604 61 2004 46 2605 40 41 59 2073 40 2074 41 46 2606 40 2607 45 62 123 2603 2608 61 744 2603 40 2600 46 2609 40 41 44 2601 44 2607 41 59 2604 46 2610 40 2608 41 59 330 2604 46 2611 40 2612 46 2613 40 2603 58 58 2614 41 41 59 125 41 59 125 777 2139 2615 40 2599 2600 44 704 2074 41 123 2009 60 2616 62 2617 61 744 2618 60 62 40 2004 46 2619 40 41 41 59 688 40 33 2617 46 2620 40 41 41 123 330 664 40 704 2621 61 2617 46 2622 40 41 45 1501 59 2621 325 1500 59 2621 338 41 123 2616 2623 61 2617 46 2624 40 2621 41 59 688 40 2623 46 2625 40 41 46 2626 40 2600 46 2627 40 41 41 307 2074 325 2623 46 2628 40 41 41 123 792 2623 46 2629 40 41 59 125 125 125 330 792 2600 46 2630 40 41 59 125 777 2009 60 2171 62 2631 40 2599 2600 41 123 2009 60 2171 62 2632 61 744 2633 60 62 40 41 59 664 40 2634 2635 58 2004 46 2631 40 41 41 123 688 40 2635 46 2636 40 41 46 2637 40 2600 46 2638 40 41 41 41 123 2632 46 2639 40 2640 40 2600 44 2635 46 2641 40 41 41 41 59 125 125 792 2632 59 125 777 2171 2642 40 2599 2600 44 2139 2601 41 123 792 2008 46 2643 40 2600 44 2601 41 59 125 777 625 2644 40 2139 2601 41 123 792 2645 46 2646 40 2601 41 59 125 777 704 2647 40 2139 2601 41 123 792 2072 46 2648 40 2601 41 59 125 777 2171 2642 40 2599 2600 44 704 2074 41 123 792 2642 40 2600 44 2615 40 2600 44 2074 41 41 59 125 777 625 2644 40 2599 2600 44 704 2074 41 123 792 2644 40 2615 40 2600 44 2074 41 41 59 125 777 704 2647 40 2599 2600 44 704 2074 41 123 792 2647 40 2615 40 2600 44 2074 41 41 59 125 331 330 331 777 865 2649 40 2249 2256 44 2650 2651 41 123 2652 40 41 59 2004 46 2653 40 41 46 2654 40 2256 44 2651 41 59 125 777 2064 60 2650 62 2655 40 2235 2265 41 123 792 2064 46 2656 40 2004 46 2657 40 41 46 2658 40 2265 46 2659 40 41 44 2660 41 41 59 125 331 330 331 777 2009 60 2661 62 2662 40 41 123 792 2004 46 2662 40 41 59 125 777 865 2663 40 2215 60 2661 62 2664 41 123 2665 40 41 59 2664 46 2666 40 41 46 2667 40 2668 45 62 33 2004 46 2662 40 41 46 2669 40 2668 41 41 46 2670 40 2004 46 2662 40 41 58 58 2671 41 59 330 2004 46 2662 40 41 46 2672 40 2673 46 2674 40 2661 58 58 2675 41 41 59 125 777 2009 60 2676 62 2677 40 41 123 792 2004 46 2677 40 41 59 125 777 865 2678 40 2215 60 2676 62 2679 41 123 2680 40 41 59 2679 46 2681 40 41 46 2682 40 2683 45 62 33 2004 46 2677 40 41 46 2684 40 2683 41 41 46 2685 40 2004 46 2677 40 41 58 58 2686 41 59 330 2004 46 2677 40 41 46 2687 40 2688 46 2689 40 2676 58 58 2690 41 41 59 125 331 330 331 777 2215 60 2235 62 2691 40 41 123 792 2315 40 2316 46 2692 41 59 125 331 330 331 777 2215 60 2235 62 2693 40 41 123 792 2315 40 2316 46 2694 41 59 125 331 330 331 777 865 2695 40 2010 2696 41 123 2011 46 2697 40 2696 41 59 125 777 865 2698 40 2010 2696 41 123 2011 46 2699 40 2696 41 59 125 331 330 331 777 2139 2700 40 41 123 792 2004 46 2701 40 41 59 125 331 330 331 773 865 2702 40 41 123 688 40 33 2015 41 825 744 2703 40 362 41 59 125 125 ,"{'AvgLine': 5, 'CountLine': 1014, 'CountStmt': 398, 'MaxNesting': 3, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 265, 'MaxEssential': 4, 'SumEssential': 178, 'AvgCyclomatic': 1, 'CountLineCode': 657, 'CountStmtDecl': 156, 'MaxCyclomatic': 19, 'SumCyclomatic': 231, 'AvgLineComment': 0, 'CountClassBase': 2, 'CountLineBlank': 209, 'CountSemicolon': 245, 'CountDeclMethod': 126, 'CountLineCodeExe': 377, 'CountLineComment': 148, 'CountClassCoupled': 42, 'CountClassDerived': 0, 'CountLineCodeDecl': 160, 'CountDeclMethodAll': 126, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.23', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 19, 'SumCyclomaticStrict': 241, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 122, 'MaxCyclomaticModified': 6, 'PercentLackOfCohesion': 92, 'SumCyclomaticModified': 197, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 4, 'CountDeclInstanceMethod': 126, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 42, 'CountDeclInstanceVariable': 6, 'PercentLackOfCohesionModified': 80}"
2766,Java,"@Getter
@Slf4j
public class ProcessModel implements ProtocolModel<TradingPeer> {

    public static byte[] hashOfPaymentAccountPayload(PaymentAccountPayload paymentAccountPayload) {
        return Hash.getRipemd160hash(checkNotNull(paymentAccountPayload).toProtoMessage().toByteArray());
    }

    // Transient/Immutable (net set in constructor so they are not final, but at init)
    transient private Provider provider;
    transient private TradeManager tradeManager;
    transient private Offer offer;

    // Transient/Mutable
    transient private Transaction takeOfferFeeTx;
    @Setter
    transient private TradeMessage tradeMessage;

    // Added in v1.2.0
    @Setter
    @Nullable
    transient private byte[] delayedPayoutTxSignature;
    @Setter
    @Nullable
    transient private Transaction preparedDelayedPayoutTx;

    // Added in v1.4.0
    // MessageState of the last message sent from the seller to the buyer in the take offer process.
    // It is used only in a task which would not be executed after restart, so no need to persist it.
    @Setter
    transient private ObjectProperty<MessageState> depositTxMessageStateProperty = new SimpleObjectProperty<>(MessageState.UNDEFINED);
    @Setter
    @Getter
    transient private Transaction depositTx;

    // Persistable Immutable
    private final TradingPeer tradingPeer;
    private final String offerId;
    private final String accountId;
    private final PubKeyRing pubKeyRing;

    // Persistable Mutable
    @Nullable
    @Setter
    private String takeOfferFeeTxId;
    @Nullable
    @Setter
    private byte[] payoutTxSignature;
    @Nullable
    @Setter
    private byte[] preparedDepositTx;
    @Nullable
    @Setter
    private List<RawTransactionInput> rawTransactionInputs;
    @Setter
    private long changeOutputValue;
    @Nullable
    @Setter
    private String changeOutputAddress;
    @Setter
    private boolean useSavingsWallet;
    @Setter
    private long fundsNeededForTradeAsLong;
    @Nullable
    @Setter
    private byte[] myMultiSigPubKey;
    // that is used to store temp. the peers address when we get an incoming message before the message is verified.
    // After successful verified we copy that over to the trade.tradingPeerAddress
    @Nullable
    @Setter
    private NodeAddress tempTradingPeerNodeAddress;

    // Added in v.1.1.6
    @Nullable
    @Setter
    private byte[] mediatedPayoutTxSignature;
    @Setter
    private long buyerPayoutAmountFromMediation;
    @Setter
    private long sellerPayoutAmountFromMediation;


    // We want to indicate the user the state of the message delivery of the
    // CounterCurrencyTransferStartedMessage. As well we do an automatic re-send in case it was not ACKed yet.
    // To enable that even after restart we persist the state.
    @Setter
    private ObjectProperty<MessageState> paymentStartedMessageStateProperty = new SimpleObjectProperty<>(MessageState.UNDEFINED);

    public ProcessModel(String offerId, String accountId, PubKeyRing pubKeyRing) {
        this(offerId, accountId, pubKeyRing, new TradingPeer());
    }

    public ProcessModel(String offerId, String accountId, PubKeyRing pubKeyRing, TradingPeer tradingPeer) {
        this.offerId = offerId;
        this.accountId = accountId;
        this.pubKeyRing = pubKeyRing;
        // If tradingPeer was null in persisted data from some error cases we set a new one to not cause nullPointers
        this.tradingPeer = tradingPeer != null ? tradingPeer : new TradingPeer();
    }

    public void applyTransient(Provider provider,
                               TradeManager tradeManager,
                               Offer offer) {
        this.offer = offer;
        this.provider = provider;
        this.tradeManager = tradeManager;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // PROTO BUFFER
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public protobuf.ProcessModel toProtoMessage() {
        protobuf.ProcessModel.Builder builder = protobuf.ProcessModel.newBuilder()
                .setTradingPeer((protobuf.TradingPeer) tradingPeer.toProtoMessage())
                .setOfferId(offerId)
                .setAccountId(accountId)
                .setPubKeyRing(pubKeyRing.toProtoMessage())
                .setChangeOutputValue(changeOutputValue)
                .setUseSavingsWallet(useSavingsWallet)
                .setFundsNeededForTradeAsLong(fundsNeededForTradeAsLong)
                .setPaymentStartedMessageState(paymentStartedMessageStateProperty.get().name())
                .setBuyerPayoutAmountFromMediation(buyerPayoutAmountFromMediation)
                .setSellerPayoutAmountFromMediation(sellerPayoutAmountFromMediation);

        Optional.ofNullable(takeOfferFeeTxId).ifPresent(builder::setTakeOfferFeeTxId);
        Optional.ofNullable(payoutTxSignature).ifPresent(e -> builder.setPayoutTxSignature(ByteString.copyFrom(payoutTxSignature)));
        Optional.ofNullable(preparedDepositTx).ifPresent(e -> builder.setPreparedDepositTx(ByteString.copyFrom(preparedDepositTx)));
        Optional.ofNullable(rawTransactionInputs).ifPresent(e -> builder.addAllRawTransactionInputs(
                ProtoUtil.collectionToProto(rawTransactionInputs, protobuf.RawTransactionInput.class)));
        Optional.ofNullable(changeOutputAddress).ifPresent(builder::setChangeOutputAddress);
        Optional.ofNullable(myMultiSigPubKey).ifPresent(e -> builder.setMyMultiSigPubKey(ByteString.copyFrom(myMultiSigPubKey)));
        Optional.ofNullable(tempTradingPeerNodeAddress).ifPresent(e -> builder.setTempTradingPeerNodeAddress(tempTradingPeerNodeAddress.toProtoMessage()));
        Optional.ofNullable(mediatedPayoutTxSignature).ifPresent(e -> builder.setMediatedPayoutTxSignature(ByteString.copyFrom(e)));

        return builder.build();
    }

    public static ProcessModel fromProto(protobuf.ProcessModel proto, CoreProtoResolver coreProtoResolver) {
        TradingPeer tradingPeer = TradingPeer.fromProto(proto.getTradingPeer(), coreProtoResolver);
        PubKeyRing pubKeyRing = PubKeyRing.fromProto(proto.getPubKeyRing());
        ProcessModel processModel = new ProcessModel(proto.getOfferId(), proto.getAccountId(), pubKeyRing, tradingPeer);
        processModel.setChangeOutputValue(proto.getChangeOutputValue());
        processModel.setUseSavingsWallet(proto.getUseSavingsWallet());
        processModel.setFundsNeededForTradeAsLong(proto.getFundsNeededForTradeAsLong());
        processModel.setBuyerPayoutAmountFromMediation(proto.getBuyerPayoutAmountFromMediation());
        processModel.setSellerPayoutAmountFromMediation(proto.getSellerPayoutAmountFromMediation());

        // nullable
        processModel.setTakeOfferFeeTxId(ProtoUtil.stringOrNullFromProto(proto.getTakeOfferFeeTxId()));
        processModel.setPayoutTxSignature(ProtoUtil.byteArrayOrNullFromProto(proto.getPayoutTxSignature()));
        processModel.setPreparedDepositTx(ProtoUtil.byteArrayOrNullFromProto(proto.getPreparedDepositTx()));
        List<RawTransactionInput> rawTransactionInputs = proto.getRawTransactionInputsList().isEmpty() ?
                null : proto.getRawTransactionInputsList().stream()
                .map(RawTransactionInput::fromProto).collect(Collectors.toList());
        processModel.setRawTransactionInputs(rawTransactionInputs);
        processModel.setChangeOutputAddress(ProtoUtil.stringOrNullFromProto(proto.getChangeOutputAddress()));
        processModel.setMyMultiSigPubKey(ProtoUtil.byteArrayOrNullFromProto(proto.getMyMultiSigPubKey()));
        processModel.setTempTradingPeerNodeAddress(proto.hasTempTradingPeerNodeAddress() ? NodeAddress.fromProto(proto.getTempTradingPeerNodeAddress()) : null);
        processModel.setMediatedPayoutTxSignature(ProtoUtil.byteArrayOrNullFromProto(proto.getMediatedPayoutTxSignature()));

        String paymentStartedMessageStateString = ProtoUtil.stringOrNullFromProto(proto.getPaymentStartedMessageState());
        MessageState paymentStartedMessageState = ProtoUtil.enumFromProto(MessageState.class, paymentStartedMessageStateString);
        processModel.setPaymentStartedMessageState(paymentStartedMessageState);

        return processModel;
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // API
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void onComplete() {
    }

    @Override
    public TradingPeer getTradePeer() {
        return tradingPeer;
    }

    public void setTakeOfferFeeTx(Transaction takeOfferFeeTx) {
        this.takeOfferFeeTx = takeOfferFeeTx;
        takeOfferFeeTxId = takeOfferFeeTx.getTxId().toString();
    }

    @Nullable
    public PaymentAccountPayload getPaymentAccountPayload(Trade trade) {
        PaymentAccount paymentAccount;
        if (trade instanceof MakerTrade)
            paymentAccount = getUser().getPaymentAccount(offer.getMakerPaymentAccountId());
        else
            paymentAccount = getUser().getPaymentAccount(trade.getTakerPaymentAccountId());
        return paymentAccount != null ? paymentAccount.getPaymentAccountPayload() : null;
    }

    public Coin getFundsNeededForTrade() {
        return Coin.valueOf(fundsNeededForTradeAsLong);
    }

    public Transaction resolveTakeOfferFeeTx(Trade trade) {
        if (takeOfferFeeTx == null) {
            if (!trade.isCurrencyForTakerFeeBtc())
                takeOfferFeeTx = getBsqWalletService().getTransaction(takeOfferFeeTxId);
            else
                takeOfferFeeTx = getBtcWalletService().getTransaction(takeOfferFeeTxId);
        }
        return takeOfferFeeTx;
    }

    @Override
    public NodeAddress getMyNodeAddress() {
        return getP2PService().getAddress();
    }

    public void setPaymentStartedAckMessage(AckMessage ackMessage) {
        MessageState messageState = ackMessage.isSuccess() ?
                MessageState.ACKNOWLEDGED :
                MessageState.FAILED;
        setPaymentStartedMessageState(messageState);
    }

    public void setPaymentStartedMessageState(MessageState paymentStartedMessageStateProperty) {
        this.paymentStartedMessageStateProperty.set(paymentStartedMessageStateProperty);
        if (tradeManager != null) {
            tradeManager.requestPersistence();
        }
    }

    public void setDepositTxSentAckMessage(AckMessage ackMessage) {
        MessageState messageState = ackMessage.isSuccess() ?
                MessageState.ACKNOWLEDGED :
                MessageState.FAILED;
        setDepositTxMessageState(messageState);
    }

    public void setDepositTxMessageState(MessageState messageState) {
        this.depositTxMessageStateProperty.set(messageState);
        if (tradeManager != null) {
            tradeManager.requestPersistence();
        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Delegates
    ///////////////////////////////////////////////////////////////////////////////////////////

    public BtcWalletService getBtcWalletService() {
        return provider.getBtcWalletService();
    }

    public AccountAgeWitnessService getAccountAgeWitnessService() {
        return provider.getAccountAgeWitnessService();
    }

    public P2PService getP2PService() {
        return provider.getP2PService();
    }

    public BsqWalletService getBsqWalletService() {
        return provider.getBsqWalletService();
    }

    public TradeWalletService getTradeWalletService() {
        return provider.getTradeWalletService();
    }

    public User getUser() {
        return provider.getUser();
    }

    public OpenOfferManager getOpenOfferManager() {
        return provider.getOpenOfferManager();
    }

    public ReferralIdService getReferralIdService() {
        return provider.getReferralIdService();
    }

    public FilterManager getFilterManager() {
        return provider.getFilterManager();
    }

    public TradeStatisticsManager getTradeStatisticsManager() {
        return provider.getTradeStatisticsManager();
    }

    public ArbitratorManager getArbitratorManager() {
        return provider.getArbitratorManager();
    }

    public MediatorManager getMediatorManager() {
        return provider.getMediatorManager();
    }

    public RefundAgentManager getRefundAgentManager() {
        return provider.getRefundAgentManager();
    }

    public KeyRing getKeyRing() {
        return provider.getKeyRing();
    }

    public DaoFacade getDaoFacade() {
        return provider.getDaoFacade();
    }
}",1,64 2000 64 2001 777 587 2002 693 2003 60 2004 62 123 777 809 574 91 93 2005 40 2006 2007 41 123 792 2008 46 2009 40 2010 40 2007 41 46 2011 40 41 46 2012 40 41 41 59 125 330 828 773 2013 2014 59 828 773 2015 2016 59 828 773 2017 2018 59 330 828 773 2019 2020 59 64 2021 828 773 2022 2023 59 330 64 2021 64 2024 828 773 574 91 93 2025 59 64 2021 64 2024 828 773 2019 2026 59 330 330 330 64 2021 828 773 2027 60 2028 62 2029 61 744 2030 60 62 40 2028 46 2031 41 59 64 2021 64 2000 828 773 2019 2032 59 330 773 657 2004 2033 59 773 657 2034 2035 59 773 657 2034 2036 59 773 657 2037 2038 59 330 64 2024 64 2021 773 2034 2039 59 64 2024 64 2021 773 574 91 93 2040 59 64 2024 64 2021 773 574 91 93 2041 59 64 2024 64 2021 773 2042 60 2043 62 2044 59 64 2021 773 726 2045 59 64 2024 64 2021 773 2034 2046 59 64 2021 773 570 2047 59 64 2021 773 726 2048 59 64 2024 64 2021 773 574 91 93 2049 59 330 330 64 2024 64 2021 773 2050 2051 59 330 64 2024 64 2021 773 574 91 93 2052 59 64 2021 773 726 2053 59 64 2021 773 726 2054 59 330 330 330 64 2021 773 2027 60 2028 62 2055 61 744 2030 60 62 40 2028 46 2031 41 59 777 2002 40 2034 2035 44 2034 2036 44 2037 2038 41 123 823 40 2035 44 2036 44 2038 44 744 2004 40 41 41 59 125 777 2002 40 2034 2035 44 2034 2036 44 2037 2038 44 2004 2033 41 123 823 46 2035 61 2035 59 823 46 2036 61 2036 59 823 46 2038 61 2038 59 330 823 46 2033 61 2033 340 2056 63 2033 58 744 2004 40 41 59 125 777 865 2057 40 2013 2014 44 2015 2016 44 2017 2018 41 123 823 46 2018 61 2018 59 823 46 2014 61 2014 59 823 46 2016 61 2016 59 125 331 330 331 64 2058 777 2059 46 2002 2060 40 41 123 2059 46 2002 46 2061 2062 61 2059 46 2002 46 2063 40 41 46 2064 40 40 2059 46 2004 41 2033 46 2060 40 41 41 46 2065 40 2035 41 46 2066 40 2036 41 46 2067 40 2038 46 2060 40 41 41 46 2068 40 2045 41 46 2069 40 2047 41 46 2070 40 2048 41 46 2071 40 2055 46 2072 40 41 46 2073 40 41 41 46 2074 40 2053 41 46 2075 40 2054 41 59 2076 46 2077 40 2039 41 46 2078 40 2062 58 58 2079 41 59 2076 46 2077 40 2040 41 46 2078 40 2080 45 62 2062 46 2081 40 2082 46 2083 40 2040 41 41 41 59 2076 46 2077 40 2041 41 46 2078 40 2080 45 62 2062 46 2084 40 2082 46 2083 40 2041 41 41 41 59 2076 46 2077 40 2044 41 46 2078 40 2080 45 62 2062 46 2085 40 2086 46 2087 40 2044 44 2059 46 2043 46 587 41 41 41 59 2076 46 2077 40 2046 41 46 2078 40 2062 58 58 2088 41 59 2076 46 2077 40 2049 41 46 2078 40 2080 45 62 2062 46 2089 40 2082 46 2083 40 2049 41 41 41 59 2076 46 2077 40 2051 41 46 2078 40 2080 45 62 2062 46 2090 40 2051 46 2060 40 41 41 41 59 2076 46 2077 40 2052 41 46 2078 40 2080 45 62 2062 46 2091 40 2082 46 2083 40 2080 41 41 41 59 792 2062 46 2092 40 41 59 125 777 809 2002 2093 40 2059 46 2002 2094 44 2095 2096 41 123 2004 2033 61 2004 46 2093 40 2094 46 2097 40 41 44 2096 41 59 2037 2038 61 2037 46 2093 40 2094 46 2098 40 41 41 59 2002 2099 61 744 2002 40 2094 46 2100 40 41 44 2094 46 2101 40 41 44 2038 44 2033 41 59 2099 46 2102 40 2094 46 2103 40 41 41 59 2099 46 2104 40 2094 46 2105 40 41 41 59 2099 46 2106 40 2094 46 2107 40 41 41 59 2099 46 2108 40 2094 46 2109 40 41 41 59 2099 46 2110 40 2094 46 2111 40 41 41 59 330 2099 46 2112 40 2113 46 2114 40 2094 46 2115 40 41 41 41 59 2099 46 2116 40 2113 46 2117 40 2094 46 2118 40 41 41 41 59 2099 46 2119 40 2113 46 2117 40 2094 46 2120 40 41 41 41 59 2042 60 2043 62 2044 61 2094 46 2121 40 41 46 2122 40 41 63 2123 58 2094 46 2121 40 41 46 2124 40 41 46 2125 40 2043 58 58 2093 41 46 2126 40 2127 46 2128 40 41 41 59 2099 46 2129 40 2044 41 59 2099 46 2130 40 2113 46 2114 40 2094 46 2131 40 41 41 41 59 2099 46 2132 40 2113 46 2117 40 2094 46 2133 40 41 41 41 59 2099 46 2134 40 2094 46 2135 40 41 63 2050 46 2093 40 2094 46 2136 40 41 41 58 2123 41 59 2099 46 2137 40 2113 46 2117 40 2094 46 2138 40 41 41 41 59 2034 2139 61 2113 46 2114 40 2094 46 2140 40 41 41 59 2028 2141 61 2113 46 2142 40 2028 46 587 44 2139 41 59 2099 46 2143 40 2141 41 59 792 2099 59 125 331 330 331 64 2058 777 865 2144 40 41 123 125 64 2058 777 2004 2145 40 41 123 792 2033 59 125 777 865 2146 40 2019 2020 41 123 823 46 2020 61 2020 59 2039 61 2020 46 2147 40 41 46 2148 40 41 59 125 64 2024 777 2006 2149 40 2150 2151 41 123 2152 2153 59 688 40 2151 702 2154 41 2153 61 2155 40 41 46 2156 40 2018 46 2157 40 41 41 59 630 2153 61 2155 40 41 46 2156 40 2151 46 2158 40 41 41 59 792 2153 340 2159 63 2153 46 2149 40 41 58 2159 59 125 777 2160 2161 40 41 123 792 2160 46 2162 40 2048 41 59 125 777 2019 2163 40 2150 2151 41 123 688 40 2020 323 2164 41 123 688 40 33 2151 46 2165 40 41 41 2020 61 2166 40 41 46 2167 40 2039 41 59 630 2020 61 2168 40 41 46 2167 40 2039 41 59 125 792 2020 59 125 64 2058 777 2050 2169 40 41 123 792 2170 40 41 46 2171 40 41 59 125 777 865 2172 40 2173 2174 41 123 2028 2175 61 2174 46 2176 40 41 63 2028 46 2177 58 2028 46 2178 59 2179 40 2175 41 59 125 777 865 2180 40 2028 2055 41 123 823 46 2055 46 2181 40 2055 41 59 688 40 2016 340 2182 41 123 2016 46 2183 40 41 59 125 125 777 865 2184 40 2173 2174 41 123 2028 2185 61 2174 46 2186 40 41 63 2028 46 2187 58 2028 46 2188 59 2189 40 2185 41 59 125 777 865 2190 40 2028 2191 41 123 823 46 2029 46 2192 40 2191 41 59 688 40 2016 340 2193 41 123 2016 46 2194 40 41 59 125 125 331 330 331 777 2195 2196 40 41 123 792 2014 46 2196 40 41 59 125 777 2197 2198 40 41 123 792 2014 46 2198 40 41 59 125 777 2199 2200 40 41 123 792 2014 46 2200 40 41 59 125 777 2201 2202 40 41 123 792 2014 46 2202 40 41 59 125 777 2203 2204 40 41 123 792 2014 46 2204 40 41 59 125 777 2205 2206 40 41 123 792 2014 46 2206 40 41 59 125 777 2207 2208 40 41 123 792 2014 46 2208 40 41 59 125 777 2209 2210 40 41 123 792 2014 46 2210 40 41 59 125 777 2211 2212 40 41 123 792 2014 46 2212 40 41 59 125 777 2213 2214 40 41 123 792 2014 46 2214 40 41 59 125 777 2215 2216 40 41 123 792 2014 46 2216 40 41 59 125 777 2217 2218 40 41 123 792 2014 46 2218 40 41 59 125 777 2219 2220 40 41 123 792 2014 46 2220 40 41 59 125 777 2221 2222 40 41 123 792 2014 46 2222 40 41 59 125 777 2223 2224 40 41 123 792 2014 46 2224 40 41 59 125 125 ,"{'AvgLine': 5, 'CountLine': 315, 'CountStmt': 140, 'MaxNesting': 2, 'AvgLineCode': 5, 'AvgEssential': 1, 'AvgLineBlank': 0, 'CountStmtExe': 81, 'MaxEssential': 1, 'SumEssential': 38, 'AvgCyclomatic': 1, 'CountLineCode': 234, 'CountStmtDecl': 70, 'MaxCyclomatic': 3, 'SumCyclomatic': 49, 'AvgLineComment': 0, 'CountClassBase': 2, 'CountLineBlank': 52, 'CountSemicolon': 102, 'CountDeclMethod': 32, 'CountLineCodeExe': 100, 'CountLineComment': 29, 'CountClassCoupled': 48, 'CountClassDerived': 0, 'CountLineCodeDecl': 113, 'CountDeclMethodAll': 32, 'MaxInheritanceTree': 1, 'RatioCommentToCode': '0.12', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 3, 'SumCyclomaticStrict': 49, 'CountDeclClassMethod': 2, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 32, 'MaxCyclomaticModified': 3, 'PercentLackOfCohesion': 94, 'SumCyclomaticModified': 49, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 0, 'CountDeclInstanceMethod': 30, 'CountDeclMethodProtected': 0, 'CountClassCoupledModified': 48, 'CountDeclInstanceVariable': 27, 'PercentLackOfCohesionModified': 92}"
5244,Java,"@FxmlView
public class PendingTradesView extends ActivatableViewAndModel<VBox, PendingTradesViewModel> {
    public interface ChatCallback {
        void onOpenChat(Trade trade);
    }

    private final TradeDetailsWindow tradeDetailsWindow;
    private final Navigation navigation;
    private final KeyRing keyRing;
    private final CoinFormatter formatter;
    private final PrivateNotificationManager privateNotificationManager;
    private final boolean useDevPrivilegeKeys;
    private final boolean useDevModeHeader;
    private final Preferences preferences;
    @FXML
    TableView<PendingTradesListItem> tableView;
    @FXML
    TableColumn<PendingTradesListItem, PendingTradesListItem> priceColumn, volumeColumn, amountColumn, avatarColumn,
            marketColumn, roleColumn, paymentMethodColumn, tradeIdColumn, dateColumn, chatColumn, moveTradeToFailedColumn;
    private SortedList<PendingTradesListItem> sortedList;
    private TradeSubView selectedSubView;
    private EventHandler<KeyEvent> keyEventEventHandler;
    private Scene scene;
    private Subscription selectedTableItemSubscription;
    private Subscription selectedItemSubscription;
    private Stage chatPopupStage;
    private ListChangeListener<PendingTradesListItem> tradesListChangeListener;
    private final Map<String, Long> newChatMessagesByTradeMap = new HashMap<>();
    private String tradeIdOfOpenChat;
    private double chatPopupStageXPosition = -1;
    private double chatPopupStageYPosition = -1;
    private ChangeListener<Number> xPositionListener;
    private ChangeListener<Number> yPositionListener;

    private final Map<String, Button> buttonByTrade = new HashMap<>();
    private final Map<String, JFXBadge> badgeByTrade = new HashMap<>();
    private final Map<String, ListChangeListener<ChatMessage>> listenerByTrade = new HashMap<>();
    private ChangeListener<Trade.DisputeState> disputeStateListener;
    private ChangeListener<MediationResultState> mediationResultStateListener;
    private ChangeListener<Number> getMempoolStatusListener;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, Initialisation
    ///////////////////////////////////////////////////////////////////////////////////////////

    @Inject
    public PendingTradesView(PendingTradesViewModel model,
                             TradeDetailsWindow tradeDetailsWindow,
                             Navigation navigation,
                             KeyRing keyRing,
                             @Named(FormattingUtils.BTC_FORMATTER_KEY) CoinFormatter formatter,
                             PrivateNotificationManager privateNotificationManager,
                             Preferences preferences,
                             @Named(Config.USE_DEV_PRIVILEGE_KEYS) boolean useDevPrivilegeKeys,
                             @Named(Config.USE_DEV_MODE_HEADER) boolean useDevModeHeader) {
        super(model);
        this.tradeDetailsWindow = tradeDetailsWindow;
        this.navigation = navigation;
        this.keyRing = keyRing;
        this.formatter = formatter;
        this.privateNotificationManager = privateNotificationManager;
        this.preferences = preferences;
        this.useDevPrivilegeKeys = useDevPrivilegeKeys;
        this.useDevModeHeader = useDevModeHeader;
    }

    @Override
    public void initialize() {
        priceColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.price"")));
        amountColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.amountWithCur"", Res.getBaseCurrencyCode())));
        volumeColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.amount"")));
        marketColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.market"")));
        roleColumn.setGraphic(new AutoTooltipLabel(Res.get(""portfolio.pending.role"")));
        dateColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.dateTime"")));
        tradeIdColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.tradeId"")));
        paymentMethodColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.paymentMethod"")));
        avatarColumn.setText("""");
        chatColumn.setText("""");
        moveTradeToFailedColumn.setText("""");

        setTradeIdColumnCellFactory();
        setDateColumnCellFactory();
        setAmountColumnCellFactory();
        setPriceColumnCellFactory();
        setVolumeColumnCellFactory();
        setPaymentMethodColumnCellFactory();
        setMarketColumnCellFactory();
        setRoleColumnCellFactory();
        setAvatarColumnCellFactory();
        setChatColumnCellFactory();
        setRemoveTradeColumnCellFactory();

        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        tableView.setPlaceholder(new AutoTooltipLabel(Res.get(""table.placeholder.noItems"", Res.get(""shared.openTrades""))));
        tableView.setMinHeight(100);

        tradeIdColumn.setComparator(Comparator.comparing(o -> o.getTrade().getId()));
        dateColumn.setComparator(Comparator.comparing(o -> o.getTrade().getDate()));
        volumeColumn.setComparator(Comparator.comparing(o -> o.getTrade().getVolume(), Comparator.nullsFirst(Comparator.naturalOrder())));
        amountColumn.setComparator(Comparator.comparing(o -> o.getTrade().getAmount(), Comparator.nullsFirst(Comparator.naturalOrder())));
        priceColumn.setComparator(Comparator.comparing(item -> FormattingUtils.formatPrice(item.getPrice())));
        paymentMethodColumn.setComparator(Comparator.comparing(
                item -> item.getTrade().getOffer() != null ?
                        Res.get(item.getTrade().getOffer().getPaymentMethod().getId()) :
                        null,
                Comparator.nullsFirst(Comparator.naturalOrder())));

        marketColumn.setComparator(Comparator.comparing(model::getMarketLabel));
        roleColumn.setComparator(Comparator.comparing(model::getMyRole));
        avatarColumn.setComparator(Comparator.comparing(
                o -> model.getNumPastTrades(o.getTrade()),
                Comparator.nullsFirst(Comparator.naturalOrder())
        ));
        dateColumn.setSortType(TableColumn.SortType.DESCENDING);
        tableView.getSortOrder().add(dateColumn);

        tableView.setRowFactory(
                tableView -> {
                    final TableRow<PendingTradesListItem> row = new TableRow<>();
                    final ContextMenu rowMenu = new ContextMenu();
                    MenuItem duplicateItem = new MenuItem(Res.get(""portfolio.context.offerLikeThis""));
                    duplicateItem.setOnAction((event) -> {
                        try {
                            OfferPayload offerPayload = row.getItem().getTrade().getOffer().getOfferPayload().orElseThrow();
                            if (offerPayload.getPubKeyRing().equals(keyRing.getPubKeyRing())) {
                                PortfolioUtil.duplicateOffer(navigation, offerPayload);
                            } else {
                                new Popup().warning(Res.get(""portfolio.context.notYourOffer"")).show();
                            }
                        } catch (NullPointerException e) {
                            log.warn(""Unable to get offerPayload - {}"", e.toString());
                        }
                    });
                    rowMenu.getItems().add(duplicateItem);
                    row.contextMenuProperty().bind(
                            Bindings.when(Bindings.isNotNull(row.itemProperty()))
                                    .then(rowMenu)
                                    .otherwise((ContextMenu) null));
                    return row;
                });

        // we use a hidden emergency shortcut to open support ticket
        keyEventEventHandler = keyEvent -> {
            if (Utilities.isAltOrCtrlPressed(KeyCode.O, keyEvent)) {
                Popup popup = new Popup();
                popup.headLine(Res.get(""portfolio.pending.openSupportTicket.headline""))
                        .message(Res.get(""portfolio.pending.openSupportTicket.msg""))
                        .actionButtonText(Res.get(""portfolio.pending.openSupportTicket.headline""))
                        .onAction(model.dataModel::onOpenSupportTicket)
                        .closeButtonText(Res.get(""shared.cancel""))
                        .onClose(popup::hide)
                        .show();
            }
        };

        tradesListChangeListener = c -> onListChanged();

        getMempoolStatusListener = (observable, oldValue, newValue) -> {
            // -1 status is unknown
            // 0 status is FAIL
            // 1 status is PASS
            if (newValue.longValue() >= 0) {
                log.info(""Taker fee validation returned {}"", newValue.longValue());
            }
        };
    }

    @Override
    protected void activate() {
        ObservableList<PendingTradesListItem> list = model.dataModel.list;
        sortedList = new SortedList<>(list);
        sortedList.comparatorProperty().bind(tableView.comparatorProperty());
        tableView.setItems(sortedList);

        updateMoveTradeToFailedColumnState();

        scene = root.getScene();
        if (scene != null) {
            scene.addEventHandler(KeyEvent.KEY_RELEASED, keyEventEventHandler);
        }

        selectedItemSubscription = EasyBind.subscribe(model.dataModel.selectedItemProperty, selectedItem -> {
            if (selectedItem != null) {
                if (selectedSubView != null)
                    selectedSubView.deactivate();

                if (selectedItem.getTrade() != null) {
                    selectedSubView = model.dataModel.tradeManager.isBuyer(model.dataModel.getOffer()) ?
                            new BuyerSubView(model) : new SellerSubView(model);

                    selectedSubView.setMinHeight(440);
                    VBox.setVgrow(selectedSubView, Priority.ALWAYS);
                    if (root.getChildren().size() == 1)
                        root.getChildren().add(selectedSubView);
                    else if (root.getChildren().size() == 2)
                        root.getChildren().set(1, selectedSubView);

                    // create and register a callback so we can be notified when the subview
                    // wants to open the chat window
                    ChatCallback chatCallback = this::openChat;
                    selectedSubView.setChatCallback(chatCallback);
                }

                updateTableSelection();
            } else {
                removeSelectedSubView();
            }

            model.onSelectedItemChanged(selectedItem);

            if (selectedSubView != null && selectedItem != null)
                selectedSubView.activate();
        });

        selectedTableItemSubscription = EasyBind.subscribe(tableView.getSelectionModel().selectedItemProperty(),
                selectedItem -> {
                    if (selectedItem != null && !selectedItem.equals(model.dataModel.selectedItemProperty.get()))
                        model.dataModel.onSelectItem(selectedItem);
                });

        updateTableSelection();

        list.addListener(tradesListChangeListener);
        updateNewChatMessagesByTradeMap();
        model.getMempoolStatus().addListener(getMempoolStatusListener);
    }

    @Override
    protected void deactivate() {
        sortedList.comparatorProperty().unbind();
        selectedItemSubscription.unsubscribe();
        selectedTableItemSubscription.unsubscribe();

        removeSelectedSubView();

        model.dataModel.list.removeListener(tradesListChangeListener);
        model.getMempoolStatus().removeListener(getMempoolStatusListener);

        if (scene != null)
            scene.removeEventHandler(KeyEvent.KEY_RELEASED, keyEventEventHandler);
    }

    private void removeSelectedSubView() {
        if (selectedSubView != null) {
            selectedSubView.deactivate();
            root.getChildren().remove(selectedSubView);
            selectedSubView = null;
        }
    }

    private void updateMoveTradeToFailedColumnState() {
        moveTradeToFailedColumn.setVisible(model.dataModel.list.stream().anyMatch(item -> isMaybeInvalidTrade(item.getTrade())));
    }

    private boolean isMaybeInvalidTrade(Trade trade) {
        return trade.hasErrorMessage() ||
                (Trade.Phase.DEPOSIT_PUBLISHED.ordinal() <= trade.getTradePhase().ordinal() && trade.isTxChainInvalid());
    }

    private void onMoveInvalidTradeToFailedTrades(Trade trade) {
        String msg = trade.isTxChainInvalid() ?
                Res.get(""portfolio.pending.failedTrade.txChainInvalid.moveToFailed"",
                        getInvalidTradeDetails(trade)) :
                Res.get(""portfolio.pending.failedTrade.txChainValid.moveToFailed"",
                        getInvalidTradeDetails(trade));
        new Popup().width(900).attention(msg)
                .onAction(() -> {
                    model.dataModel.onMoveInvalidTradeToFailedTrades(trade);
                    updateMoveTradeToFailedColumnState();
                })
                .actionButtonText(Res.get(""shared.yes""))
                .closeButtonText(Res.get(""shared.no""))
                .show();
    }

    private void onShowInfoForInvalidTrade(Trade trade) {
        new Popup().width(900).attention(Res.get(""portfolio.pending.failedTrade.info.popup"",
                getInvalidTradeDetails(trade)))
                .show();
    }

    private String getInvalidTradeDetails(Trade trade) {
        Contract contract = trade.getContract();
        if (contract == null) {
            return Res.get(""portfolio.pending.failedTrade.missingContract"");
        }

        PubKeyRing myPubKeyRing = model.dataModel.getPubKeyRing();
        boolean isMyRoleBuyer = contract.isMyRoleBuyer(myPubKeyRing);
        boolean isMyRoleMaker = contract.isMyRoleMaker(myPubKeyRing);

        if (trade.getTakerFeeTxId() == null) {
            return isMyRoleMaker ?
                    Res.get(""portfolio.pending.failedTrade.maker.missingTakerFeeTx"") :
                    Res.get(""portfolio.pending.failedTrade.taker.missingTakerFeeTx"");
        }

        if (trade.getDepositTx() == null) {
            return Res.get(""portfolio.pending.failedTrade.missingDepositTx"");
        }

        if (trade.getDelayedPayoutTx() == null) {
            return isMyRoleBuyer ?
                    Res.get(""portfolio.pending.failedTrade.buyer.existingDepositTxButMissingDelayedPayoutTx"") :
                    Res.get(""portfolio.pending.failedTrade.seller.existingDepositTxButMissingDelayedPayoutTx"");
        }

        if (trade.hasErrorMessage()) {
            return Res.get(""portfolio.pending.failedTrade.errorMsgSet"", trade.getErrorMessage());
        }

        return Res.get(""shared.na"");
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Chat
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void updateNewChatMessagesByTradeMap() {
        model.dataModel.list.forEach(t -> {
            Trade trade = t.getTrade();
            newChatMessagesByTradeMap.put(trade.getId(),
                    trade.getChatMessages().stream()
                            .filter(m -> !m.isWasDisplayed())
                            .filter(m -> !m.isSystemMessage())
                            .count());
        });
    }

    private void openChat(Trade trade) {
        if (chatPopupStage != null)
            chatPopupStage.close();

        TraderChatManager traderChatManager = model.dataModel.getTraderChatManager();
        if (trade.getChatMessages().isEmpty()) {
            traderChatManager.addSystemMsg(trade);
        }

        trade.getChatMessages().forEach(m -> m.setWasDisplayed(true));
        model.dataModel.getTradeManager().requestPersistence();
        tradeIdOfOpenChat = trade.getId();

        ChatView chatView = new ChatView(traderChatManager, Res.get(""offerbook.trader""));
        chatView.setAllowAttachments(false);
        chatView.setDisplayHeader(false);
        chatView.initialize();

        AnchorPane pane = new AnchorPane(chatView);
        pane.setPrefSize(760, 500);
        AnchorPane.setLeftAnchor(chatView, 10d);
        AnchorPane.setRightAnchor(chatView, 10d);
        AnchorPane.setTopAnchor(chatView, -20d);
        AnchorPane.setBottomAnchor(chatView, 10d);

        boolean isTaker = !model.dataModel.isMaker(trade.getOffer());
        TradeChatSession tradeChatSession = new TradeChatSession(trade, isTaker);

        disputeStateListener = (observable, oldValue, newValue) -> {
            if (newValue == Trade.DisputeState.DISPUTE_CLOSED || newValue == Trade.DisputeState.REFUND_REQUEST_CLOSED) {
                chatPopupStage.hide();
            }
        };
        trade.disputeStateProperty().addListener(disputeStateListener);

        mediationResultStateListener = (observable, oldValue, newValue) -> {
            if (newValue == MediationResultState.PAYOUT_TX_PUBLISHED ||
                    newValue == MediationResultState.RECEIVED_PAYOUT_TX_PUBLISHED_MSG ||
                    newValue == MediationResultState.PAYOUT_TX_SEEN_IN_NETWORK) {
                chatPopupStage.hide();
            }
        };
        trade.mediationResultStateProperty().addListener(mediationResultStateListener);

        chatView.display(tradeChatSession, pane.widthProperty());

        chatView.activate();
        chatView.scrollToBottom();

        chatPopupStage = new Stage();
        chatPopupStage.setTitle(Res.get(""tradeChat.chatWindowTitle"", trade.getShortId()));
        StackPane owner = MainView.getRootContainer();
        Scene rootScene = owner.getScene();
        chatPopupStage.initOwner(rootScene.getWindow());
        chatPopupStage.initModality(Modality.NONE);
        chatPopupStage.initStyle(StageStyle.DECORATED);
        chatPopupStage.setOnHiding(event -> {
            chatView.deactivate();
            // at close we set all as displayed. While open we ignore updates of the numNewMsg in the list icon.
            trade.getChatMessages().forEach(m -> m.setWasDisplayed(true));
            model.dataModel.getTradeManager().requestPersistence();
            tradeIdOfOpenChat = null;

            if (xPositionListener != null) {
                chatPopupStage.xProperty().removeListener(xPositionListener);
            }
            if (yPositionListener != null) {
                chatPopupStage.xProperty().removeListener(yPositionListener);
            }

            trade.disputeStateProperty().addListener(disputeStateListener);
            trade.mediationResultStateProperty().addListener(mediationResultStateListener);
            traderChatManager.requestPersistence();
        });

        Scene scene = new Scene(pane);
        CssTheme.loadSceneStyles(scene, preferences.getCssTheme(), useDevModeHeader);
        scene.addEventHandler(KeyEvent.KEY_RELEASED, ev -> {
            if (ev.getCode() == KeyCode.ESCAPE) {
                ev.consume();
                chatPopupStage.hide();
            }
        });
        chatPopupStage.setScene(scene);

        chatPopupStage.setOpacity(0);
        chatPopupStage.show();

        xPositionListener = (observable, oldValue, newValue) -> chatPopupStageXPosition = (double) newValue;
        chatPopupStage.xProperty().addListener(xPositionListener);
        yPositionListener = (observable, oldValue, newValue) -> chatPopupStageYPosition = (double) newValue;
        chatPopupStage.yProperty().addListener(yPositionListener);

        if (chatPopupStageXPosition == -1) {
            Window rootSceneWindow = rootScene.getWindow();
            double titleBarHeight = rootSceneWindow.getHeight() - rootScene.getHeight();
            chatPopupStage.setX(Math.round(rootSceneWindow.getX() + (owner.getWidth() - chatPopupStage.getWidth() / 4 * 3)));
            chatPopupStage.setY(Math.round(rootSceneWindow.getY() + titleBarHeight + (owner.getHeight() - chatPopupStage.getHeight() / 4 * 3)));
        } else {
            chatPopupStage.setX(chatPopupStageXPosition);
            chatPopupStage.setY(chatPopupStageYPosition);
        }

        // Delay display to next render frame to avoid that the popup is first quickly displayed in default position
        // and after a short moment in the correct position
        UserThread.execute(() -> chatPopupStage.setOpacity(1));
        updateChatMessageCount(trade, badgeByTrade.get(trade.getId()));
    }

    private void updateChatMessageCount(Trade trade, JFXBadge badge) {
        if (!trade.getId().equals(tradeIdOfOpenChat)) {
            updateNewChatMessagesByTradeMap();
            long num = newChatMessagesByTradeMap.get(trade.getId());
            if (num > 0) {
                badge.setText(String.valueOf(num));
                badge.setEnabled(true);
            } else {
                badge.setText("""");
                badge.setEnabled(false);
            }
        } else {
            badge.setText("""");
            badge.setEnabled(false);
        }
        badge.refreshBadge();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Private
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void updateTableSelection() {
        PendingTradesListItem selectedItemFromModel = model.dataModel.selectedItemProperty.get();
        if (selectedItemFromModel != null) {
            // Select and focus selectedItem from model
            int index = tableView.getItems().indexOf(selectedItemFromModel);
            UserThread.execute(() -> tableView.getSelectionModel().select(index));
        }
    }

    private void onListChanged() {
        updateNewChatMessagesByTradeMap();
        updateMoveTradeToFailedColumnState();
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // CellFactories
    ///////////////////////////////////////////////////////////////////////////////////////////

    private void setTradeIdColumnCellFactory() {
        tradeIdColumn.getStyleClass().add(""first-column"");
        tradeIdColumn.setCellValueFactory((pendingTradesListItem) -> new ReadOnlyObjectWrapper<>(pendingTradesListItem.getValue()));
        tradeIdColumn.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem,
                            PendingTradesListItem> column) {
                        return new TableCell<>() {
                            private Trade trade;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);

                                if (item != null && !empty) {
                                    trade = item.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    setGraphic(null);
                                    if (trade != null && listener != null) {
                                        trade.stateProperty().removeListener(listener);
                                        trade = null;
                                        listener = null;
                                    }
                                }
                            }

                            private void update() {
                                HyperlinkWithIcon field;
                                if (trade == null) return;

                                if (isMaybeInvalidTrade(trade)) {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setIcon(FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE));
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.invalidTradeState.warning"")));
                                    if (trade.isTxChainInvalid()) {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        field.getIcon().getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }
                                } else {
                                    field = new HyperlinkWithIcon(trade.getShortId());
                                    field.setOnAction(event -> tradeDetailsWindow.show(trade));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                }
                                setGraphic(field);
                            }
                        };
                    }
                });
    }

    private void setDateColumnCellFactory() {
        dateColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        dateColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    setGraphic(new AutoTooltipLabel(DisplayUtils.formatDateTime(item.getTrade().getDate())));
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
    }

    private void setAmountColumnCellFactory() {
        amountColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        amountColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(formatter.formatCoin(item.getTrade().getAmount())));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setPriceColumnCellFactory() {
        priceColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        priceColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(FormattingUtils.formatPrice(item.getPrice())));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setVolumeColumnCellFactory() {
        volumeColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        volumeColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    try {
                                        String volume = VolumeUtil.formatVolumeWithCode(item.getTrade().getVolume());
                                        setGraphic(new AutoTooltipLabel(volume));
                                    } catch (Throwable ignore) {
                                        log.debug(ignore.toString()); // Stupidity to make Codacy happy
                                    }
                                } else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setPaymentMethodColumnCellFactory() {
        paymentMethodColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        paymentMethodColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getPaymentMethod(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setMarketColumnCellFactory() {
        marketColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        marketColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                            }
                        };
                    }
                });
    }

    private void setRoleColumnCellFactory() {
        roleColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        roleColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(
                            TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final PendingTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty)
                                    setGraphic(new AutoTooltipLabel(model.getMyRole(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    @SuppressWarnings(""UnusedReturnValue"")
    private TableColumn<PendingTradesListItem, PendingTradesListItem> setAvatarColumnCellFactory() {
        avatarColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        avatarColumn.getStyleClass().addAll(""last-column"", ""avatar-column"");
        avatarColumn.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    final Trade trade = newItem.getTrade();
                                    final NodeAddress tradingPeerNodeAddress = trade.getTradingPeerNodeAddress();
                                    int numPastTrades = model.getNumPastTrades(trade);
                                    String role = Res.get(""peerInfoIcon.tooltip.tradePeer"");
                                    Node peerInfoIcon = new PeerInfoIconTrading(tradingPeerNodeAddress,
                                            role,
                                            numPastTrades,
                                            privateNotificationManager,
                                            trade,
                                            preferences,
                                            model.accountAgeWitnessService,
                                            useDevPrivilegeKeys);
                                    setPadding(new Insets(1, 0, 0, 0));
                                    setGraphic(peerInfoIcon);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
        return avatarColumn;
    }

    @SuppressWarnings(""UnusedReturnValue"")
    private TableColumn<PendingTradesListItem, PendingTradesListItem> setChatColumnCellFactory() {
        chatColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        chatColumn.getStyleClass().addAll(""last-column"", ""avatar-column"");
        chatColumn.setSortable(false);
        chatColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem, PendingTradesListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);

                                if (!empty && newItem != null) {
                                    Trade trade = newItem.getTrade();
                                    String id = trade.getId();

                                    // We use maps for each trade to avoid multiple listener registrations when
                                    // switching views. With current implementation we avoid that but we do not
                                    // remove listeners when a trade is removed (completed) but that has no consequences
                                    // as we will not receive any message anyway from a closed trade. Supporting it
                                    // more correctly would require more effort and managing listener deactivation at
                                    // screen switches (currently we get the update called if we have selected another
                                    // view.
                                    Button button;
                                    if (!buttonByTrade.containsKey(id)) {
                                        button = FormBuilder.getIconButton(MaterialDesignIcon.COMMENT_MULTIPLE_OUTLINE);
                                        buttonByTrade.put(id, button);
                                        button.setTooltip(new Tooltip(Res.get(""tradeChat.openChat"")));
                                    } else {
                                        button = buttonByTrade.get(id);
                                    }

                                    JFXBadge badge;
                                    if (!badgeByTrade.containsKey(id)) {
                                        badge = new JFXBadge(button);
                                        badgeByTrade.put(id, badge);
                                        badge.setPosition(Pos.TOP_RIGHT);
                                    } else {
                                        badge = badgeByTrade.get(id);
                                    }

                                    button.setOnAction(e -> {
                                        tableView.getSelectionModel().select(this.getIndex());
                                        openChat(trade);
                                    });

                                    if (!listenerByTrade.containsKey(id)) {
                                        ListChangeListener<ChatMessage> listener = c -> updateChatMessageCount(trade, badge);
                                        listenerByTrade.put(id, listener);
                                        trade.getChatMessages().addListener(listener);
                                    }

                                    updateChatMessageCount(trade, badge);

                                    setGraphic(badge);
                                } else {
                                    setGraphic(null);
                                }
                            }

                        };
                    }
                });
        return chatColumn;
    }

    private void setRemoveTradeColumnCellFactory() {
        moveTradeToFailedColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        moveTradeToFailedColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<PendingTradesListItem, PendingTradesListItem> call(TableColumn<PendingTradesListItem,
                            PendingTradesListItem> column) {
                        return new TableCell<>() {
                            private Trade trade;
                            private JFXButton warnIconButton, trashIconButton;
                            private ChangeListener<Trade.State> listener;

                            @Override
                            public void updateItem(PendingTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    trade = newItem.getTrade();
                                    listener = (observable, oldValue, newValue) -> update();
                                    trade.stateProperty().addListener(listener);
                                    update();
                                } else {
                                    cleanup();
                                }
                            }

                            private void update() {
                                if (isMaybeInvalidTrade(trade)) {
                                    Text warnIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ALERT_CIRCLE_OUTLINE);
                                    Text trashIcon = FormBuilder.getMediumSizeIcon(MaterialDesignIcon.ARROW_RIGHT_BOLD_BOX_OUTLINE);
                                    if (trade.isTxChainInvalid()) {
                                        trashIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""error-icon"");
                                    } else {
                                        trashIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                        warnIcon.getStyleClass().addAll(""icon"", ""warn-icon"");
                                    }

                                    warnIconButton = new JFXButton("""", warnIcon);
                                    warnIconButton.getStyleClass().add(""hidden-icon-button"");
                                    warnIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.warningIcon.tooltip"")));
                                    warnIconButton.setOnAction(e -> onShowInfoForInvalidTrade(trade));

                                    trashIconButton = new JFXButton("""", trashIcon);
                                    trashIconButton.getStyleClass().add(""hidden-icon-button"");
                                    trashIconButton.setTooltip(new Tooltip(Res.get(""portfolio.pending.failedTrade.moveTradeToFailedIcon.tooltip"")));
                                    trashIconButton.setOnAction(e -> onMoveInvalidTradeToFailedTrades(trade));

                                    HBox hBox = new HBox();
                                    hBox.setSpacing(0);
                                    hBox.getChildren().addAll(warnIconButton, trashIconButton);
                                    setGraphic(hBox);
                                } else {
                                    cleanup();
                                }

                                updateMoveTradeToFailedColumnState();
                            }

                            private void cleanup() {
                                if (warnIconButton != null) {
                                    warnIconButton.setOnAction(null);
                                }
                                if (trashIconButton != null) {
                                    trashIconButton.setOnAction(null);
                                }
                                if (listener != null && trade != null) {
                                    trade.stateProperty().removeListener(listener);
                                }
                                setGraphic(null);
                            }
                        };
                    }
                });
    }
}",1,64 2000 777 587 2001 650 2002 60 2003 44 2004 62 123 777 709 2005 123 865 2006 40 2007 2008 41 59 125 773 657 2009 2010 59 773 657 2011 2012 59 773 657 2013 2014 59 773 657 2015 2016 59 773 657 2017 2018 59 773 657 570 2019 59 773 657 570 2020 59 773 657 2021 2022 59 64 2023 2024 60 2025 62 2026 59 64 2023 2027 60 2025 44 2025 62 2028 44 2029 44 2030 44 2031 44 2032 44 2033 44 2034 44 2035 44 2036 44 2037 44 2038 59 773 2039 60 2025 62 2040 59 773 2041 2042 59 773 2043 60 2044 62 2045 59 773 2046 2047 59 773 2048 2049 59 773 2048 2050 59 773 2051 2052 59 773 2053 60 2025 62 2054 59 773 657 2055 60 2056 44 2057 62 2058 61 744 2059 60 62 40 41 59 773 2056 2060 59 773 625 2061 61 45 1501 59 773 625 2062 61 45 1501 59 773 2063 60 2064 62 2065 59 773 2063 60 2064 62 2066 59 773 657 2055 60 2056 44 2067 62 2068 61 744 2059 60 62 40 41 59 773 657 2055 60 2056 44 2069 62 2070 61 744 2059 60 62 40 41 59 773 657 2055 60 2056 44 2053 60 2071 356 2072 61 744 2059 60 62 40 41 59 773 2063 60 2073 46 2074 62 2075 59 773 2063 60 2076 62 2077 59 773 2063 60 2064 62 2078 59 331 330 331 64 2079 777 2001 40 2004 2080 44 2009 2010 44 2011 2012 44 2013 2014 44 64 2081 40 2082 46 2083 41 2015 2016 44 2017 2018 44 2021 2022 44 64 2081 40 2084 46 2085 41 570 2019 44 64 2081 40 2084 46 2086 41 570 2020 41 123 818 40 2080 41 59 823 46 2010 61 2010 59 823 46 2012 61 2012 59 823 46 2014 61 2014 59 823 46 2016 61 2016 59 823 46 2018 61 2018 59 823 46 2022 61 2022 59 823 46 2019 61 2019 59 823 46 2020 61 2020 59 125 64 2087 777 865 2088 40 41 123 2028 46 2089 40 744 2090 40 2091 46 2092 40 362 41 41 41 59 2030 46 2089 40 744 2090 40 2091 46 2092 40 362 44 2091 46 2093 40 41 41 41 41 59 2029 46 2089 40 744 2090 40 2091 46 2092 40 362 41 41 41 59 2032 46 2089 40 744 2090 40 2091 46 2092 40 362 41 41 41 59 2033 46 2089 40 744 2090 40 2091 46 2092 40 362 41 41 41 59 2036 46 2089 40 744 2090 40 2091 46 2092 40 362 41 41 41 59 2035 46 2089 40 744 2090 40 2091 46 2092 40 362 41 41 41 59 2034 46 2089 40 744 2090 40 2091 46 2092 40 362 41 41 41 59 2031 46 2094 40 362 41 59 2037 46 2094 40 362 41 59 2038 46 2094 40 362 41 59 2095 40 41 59 2096 40 41 59 2097 40 41 59 2098 40 41 59 2099 40 41 59 2100 40 41 59 2101 40 41 59 2102 40 41 59 2103 40 41 59 2104 40 41 59 2105 40 41 59 2026 46 2106 40 2024 46 2107 41 59 2026 46 2108 40 744 2090 40 2091 46 2092 40 362 44 2091 46 2092 40 362 41 41 41 41 59 2026 46 2109 40 1503 41 59 2035 46 2110 40 2111 46 2112 40 2113 45 62 2113 46 2114 40 41 46 2115 40 41 41 41 59 2036 46 2110 40 2111 46 2112 40 2113 45 62 2113 46 2114 40 41 46 2116 40 41 41 41 59 2029 46 2110 40 2111 46 2112 40 2113 45 62 2113 46 2114 40 41 46 2117 40 41 44 2111 46 2118 40 2111 46 2119 40 41 41 41 41 59 2030 46 2110 40 2111 46 2112 40 2113 45 62 2113 46 2114 40 41 46 2120 40 41 44 2111 46 2118 40 2111 46 2119 40 41 41 41 41 59 2028 46 2110 40 2111 46 2112 40 2121 45 62 2082 46 2122 40 2121 46 2123 40 41 41 41 41 59 2034 46 2110 40 2111 46 2112 40 2121 45 62 2121 46 2114 40 41 46 2124 40 41 340 2125 63 2091 46 2092 40 2121 46 2114 40 41 46 2124 40 41 46 2126 40 41 46 2115 40 41 41 58 2125 44 2111 46 2118 40 2111 46 2119 40 41 41 41 41 59 2032 46 2110 40 2111 46 2112 40 2080 58 58 2127 41 41 59 2033 46 2110 40 2111 46 2112 40 2080 58 58 2128 41 41 59 2031 46 2110 40 2111 46 2112 40 2113 45 62 2080 46 2129 40 2113 46 2114 40 41 41 44 2111 46 2118 40 2111 46 2119 40 41 41 41 41 59 2036 46 2130 40 2027 46 2131 46 2132 41 59 2026 46 2133 40 41 46 2134 40 2036 41 59 2026 46 2135 40 2026 45 62 123 657 2136 60 2025 62 2137 61 744 2136 60 62 40 41 59 657 2138 2139 61 744 2138 40 41 59 2140 2141 61 744 2140 40 2091 46 2092 40 362 41 41 59 2141 46 2142 40 40 2143 41 45 62 123 830 123 2144 2145 61 2137 46 2146 40 41 46 2114 40 41 46 2124 40 41 46 2147 40 41 46 2148 40 41 59 688 40 2145 46 2149 40 41 46 2150 40 2014 46 2149 40 41 41 41 123 2151 46 2152 40 2012 44 2145 41 59 125 630 123 744 2153 40 41 46 2154 40 2091 46 2092 40 362 41 41 46 2155 40 41 59 125 125 580 40 2156 2157 41 123 2158 46 2159 40 362 44 2157 46 2160 40 41 41 59 125 125 41 59 2139 46 2161 40 41 46 2134 40 2141 41 59 2137 46 2162 40 41 46 2163 40 2164 46 2165 40 2164 46 2166 40 2137 46 2167 40 41 41 41 46 2168 40 2139 41 46 2169 40 40 2138 41 2125 41 41 59 792 2137 59 125 41 59 330 2045 61 2170 45 62 123 688 40 2171 46 2172 40 2173 46 2174 44 2170 41 41 123 2175 2176 61 744 2175 40 41 59 2176 46 2177 40 2091 46 2092 40 362 41 41 46 2178 40 2091 46 2092 40 362 41 41 46 2179 40 2091 46 2092 40 362 41 41 46 2180 40 2080 46 2181 58 58 2182 41 46 2183 40 2091 46 2092 40 362 41 41 46 2184 40 2176 58 58 2185 41 46 2186 40 41 59 125 125 59 2054 61 2187 45 62 2188 40 41 59 2078 61 40 2189 44 2190 44 2191 41 45 62 123 330 330 330 688 40 2191 46 2192 40 41 325 1500 41 123 2193 46 2194 40 362 44 2191 46 2192 40 41 41 59 125 125 59 125 64 2087 775 865 2195 40 41 123 2196 60 2025 62 2197 61 2080 46 2198 46 2197 59 2040 61 744 2039 60 62 40 2197 41 59 2040 46 2199 40 41 46 2200 40 2026 46 2199 40 41 41 59 2026 46 2201 40 2040 41 59 2202 40 41 59 2047 61 2203 46 2204 40 41 59 688 40 2047 340 2205 41 123 2047 46 2206 40 2044 46 2207 44 2045 41 59 125 2050 61 2208 46 2209 40 2080 46 2198 46 2210 44 2211 45 62 123 688 40 2211 340 2205 41 123 688 40 2042 340 2205 41 2042 46 2212 40 41 59 688 40 2211 46 2213 40 41 340 2205 41 123 2042 61 2080 46 2198 46 2214 46 2215 40 2080 46 2198 46 2216 40 41 41 63 744 2217 40 2080 41 58 744 2218 40 2080 41 59 2042 46 2219 40 1504 41 59 2003 46 2220 40 2042 44 2221 46 2222 41 59 688 40 2203 46 2223 40 41 46 2224 40 41 323 1501 41 2203 46 2223 40 41 46 2225 40 2042 41 59 630 688 40 2203 46 2223 40 41 46 2224 40 41 323 1502 41 2203 46 2223 40 41 46 2226 40 1501 44 2042 41 59 330 330 2005 2227 61 823 58 58 2228 59 2042 46 2229 40 2227 41 59 125 2230 40 41 59 125 630 123 2231 40 41 59 125 2080 46 2232 40 2211 41 59 688 40 2042 340 2205 307 2211 340 2205 41 2042 46 2195 40 41 59 125 41 59 2049 61 2208 46 2209 40 2026 46 2233 40 41 46 2210 40 41 44 2211 45 62 123 688 40 2211 340 2205 307 33 2211 46 2234 40 2080 46 2198 46 2210 46 2235 40 41 41 41 2080 46 2198 46 2236 40 2211 41 59 125 41 59 2237 40 41 59 2197 46 2238 40 2054 41 59 2239 40 41 59 2080 46 2240 40 41 46 2238 40 2078 41 59 125 64 2087 775 865 2241 40 41 123 2040 46 2242 40 41 46 2243 40 41 59 2050 46 2244 40 41 59 2049 46 2244 40 41 59 2245 40 41 59 2080 46 2246 46 2247 46 2248 40 2054 41 59 2080 46 2249 40 41 46 2248 40 2078 41 59 688 40 2047 340 2250 41 2047 46 2251 40 2044 46 2252 44 2045 41 59 125 773 865 2253 40 41 123 688 40 2042 340 2254 41 123 2042 46 2241 40 41 59 2255 46 2256 40 41 46 2257 40 2042 41 59 2042 61 2254 59 125 125 773 865 2258 40 41 123 2038 46 2259 40 2080 46 2260 46 2261 46 2262 40 41 46 2263 40 2264 45 62 2265 40 2264 46 2266 40 41 41 41 41 59 125 773 570 2267 40 2073 2268 41 123 792 2268 46 2269 40 41 309 40 2073 46 2270 46 2271 46 2272 40 41 329 2268 46 2273 40 41 46 2272 40 41 307 2268 46 2274 40 41 41 59 125 773 865 2275 40 2073 2268 41 123 2056 2276 61 2268 46 2277 40 41 63 2278 46 2279 40 362 44 2280 40 2268 41 41 58 2278 46 2279 40 362 44 2280 40 2268 41 41 59 744 2281 40 41 46 2282 40 1504 41 46 2283 40 2276 41 46 2284 40 40 41 45 62 123 2080 46 2285 46 2275 40 2268 41 59 2258 40 41 59 125 41 46 2286 40 2278 46 2279 40 362 41 41 46 2287 40 2278 46 2279 40 362 41 41 46 2288 40 41 59 125 773 865 2289 40 2073 2268 41 123 744 2290 40 41 46 2291 40 1504 41 46 2292 40 2293 46 2294 40 362 44 2295 40 2268 41 41 41 46 2296 40 41 59 125 773 2056 2297 40 2073 2268 41 123 2298 2299 61 2268 46 2300 40 41 59 688 40 2299 323 2301 41 123 792 2302 46 2303 40 362 41 59 125 2304 2305 61 2080 46 2306 46 2307 40 41 59 570 2308 61 2299 46 2308 40 2305 41 59 570 2309 61 2299 46 2309 40 2305 41 59 688 40 2268 46 2310 40 41 323 2301 41 123 792 2309 63 2311 46 2312 40 362 41 58 2311 46 2312 40 362 41 59 125 688 40 2268 46 2313 40 41 323 2301 41 123 792 2314 46 2315 40 362 41 59 125 688 40 2268 46 2316 40 41 323 2301 41 123 792 2308 63 2317 46 2318 40 362 41 58 2317 46 2318 40 362 41 59 125 688 40 2268 46 2319 40 41 41 123 792 2320 46 2321 40 362 44 2268 46 2322 40 41 41 59 125 792 2323 46 2324 40 362 41 59 125 331 330 331 773 865 2325 40 41 123 2080 46 2326 46 2327 46 2328 40 2329 45 62 123 2073 2268 61 2329 46 2330 40 41 59 2058 46 2331 40 2268 46 2332 40 41 44 2268 46 2333 40 41 46 2334 40 41 46 2335 40 2336 45 62 33 2336 46 2337 40 41 41 46 2335 40 2336 45 62 33 2336 46 2338 40 41 41 46 2339 40 41 41 59 125 41 59 125 773 865 2340 40 2073 2268 41 123 688 40 2052 340 2341 41 2052 46 2342 40 41 59 2343 2344 61 2080 46 2345 46 2346 40 41 59 688 40 2268 46 2347 40 41 46 2348 40 41 41 123 2344 46 2349 40 2268 41 59 125 2268 46 2347 40 41 46 2350 40 2351 45 62 2351 46 2352 40 2353 41 41 59 2080 46 2345 46 2354 40 41 46 2355 40 41 59 2060 61 2268 46 2356 40 41 59 2357 2358 61 744 2357 40 2344 44 2359 46 2360 40 362 41 41 59 2358 46 2361 40 2362 41 59 2358 46 2363 40 2362 41 59 2358 46 2088 40 41 59 2364 2365 61 744 2364 40 2358 41 59 2365 46 2366 40 1504 44 1504 41 59 2364 46 2367 40 2358 44 1502 41 59 2364 46 2368 40 2358 44 1502 41 59 2364 46 2369 40 2358 44 45 1503 41 59 2364 46 2370 40 2358 44 1502 41 59 570 2371 61 33 2080 46 2345 46 2372 40 2268 46 2373 40 41 41 59 2374 2375 61 744 2374 40 2268 44 2371 41 59 2075 61 40 2376 44 2377 44 2378 41 45 62 123 688 40 2378 323 2073 46 2074 46 2379 309 2378 323 2073 46 2074 46 2380 41 123 2052 46 2381 40 41 59 125 125 59 2268 46 2382 40 41 46 2383 40 2075 41 59 2077 61 40 2376 44 2377 44 2378 41 45 62 123 688 40 2378 323 2076 46 2384 309 2378 323 2076 46 2385 309 2378 323 2076 46 2386 41 123 2052 46 2387 40 41 59 125 125 59 2268 46 2388 40 41 46 2383 40 2077 41 59 2358 46 2389 40 2375 44 2365 46 2390 40 41 41 59 2358 46 2195 40 41 59 2358 46 2391 40 41 59 2052 61 744 2051 40 41 59 2052 46 2392 40 2359 46 2360 40 362 44 2268 46 2393 40 41 41 41 59 2394 2395 61 2396 46 2397 40 41 59 2046 2398 61 2395 46 2399 40 41 59 2052 46 2400 40 2398 46 2401 40 41 41 59 2052 46 2402 40 2403 46 2404 41 59 2052 46 2405 40 2406 46 2407 41 59 2052 46 2408 40 2409 45 62 123 2358 46 2241 40 41 59 330 2268 46 2347 40 41 46 2350 40 2351 45 62 2351 46 2352 40 2353 41 41 59 2080 46 2345 46 2354 40 41 46 2355 40 41 59 2060 61 2341 59 688 40 2065 340 2341 41 123 2052 46 2410 40 41 46 2411 40 2065 41 59 125 688 40 2066 340 2341 41 123 2052 46 2412 40 41 46 2413 40 2066 41 59 125 2268 46 2382 40 41 46 2383 40 2075 41 59 2268 46 2388 40 41 46 2383 40 2077 41 59 2344 46 2355 40 41 59 125 41 59 2046 2047 61 744 2046 40 2365 41 59 2414 46 2415 40 2047 44 2022 46 2416 40 41 44 2020 41 59 2047 46 2417 40 2044 46 2418 44 2419 45 62 123 688 40 2419 46 2420 40 41 323 2421 46 2422 41 123 2419 46 2423 40 41 59 2052 46 2424 40 41 59 125 125 41 59 2052 46 2425 40 2047 41 59 2052 46 2426 40 1500 41 59 2052 46 2427 40 41 59 2065 61 40 2376 44 2377 44 2378 41 45 62 2061 61 40 625 41 2378 59 2052 46 2428 40 41 46 2383 40 2065 41 59 2066 61 40 2376 44 2377 44 2378 41 45 62 2062 61 40 625 41 2378 59 2052 46 2429 40 41 46 2383 40 2066 41 59 688 40 2061 323 45 1501 41 123 2430 2431 61 2398 46 2401 40 41 59 625 2432 61 2431 46 2433 40 41 45 2398 46 2433 40 41 59 2052 46 2434 40 2435 46 2436 40 2431 46 2437 40 41 43 40 2395 46 2438 40 41 45 2052 46 2438 40 41 47 1502 42 1502 41 41 41 59 2052 46 2439 40 2435 46 2436 40 2431 46 2440 40 41 43 2432 43 40 2395 46 2433 40 41 45 2052 46 2433 40 41 47 1502 42 1502 41 41 41 59 125 630 123 2052 46 2441 40 2061 41 59 2052 46 2442 40 2062 41 59 125 330 330 2443 46 2444 40 40 41 45 62 2052 46 2426 40 1501 41 41 59 2445 40 2268 44 2070 46 2360 40 2268 46 2356 40 41 41 41 59 125 773 865 2446 40 2073 2268 44 2069 2447 41 123 688 40 33 2268 46 2448 40 41 46 2449 40 2060 41 41 123 2325 40 41 59 726 2450 61 2058 46 2451 40 2268 46 2448 40 41 41 59 688 40 2450 62 1500 41 123 2447 46 2452 40 2056 46 2453 40 2450 41 41 59 2447 46 2454 40 2455 41 59 125 630 123 2447 46 2456 40 362 41 59 2447 46 2457 40 2458 41 59 125 125 630 123 2447 46 2459 40 362 41 59 2447 46 2460 40 2461 41 59 125 2447 46 2462 40 41 59 125 331 330 331 773 865 2463 40 41 123 2025 2464 61 2080 46 2465 46 2466 46 2467 40 41 59 688 40 2464 340 2468 41 123 330 704 2469 61 2026 46 2470 40 41 46 2471 40 2464 41 59 2472 46 2473 40 40 41 45 62 2026 46 2474 40 41 46 2475 40 2469 41 41 59 125 125 773 865 2476 40 41 123 2325 40 41 59 2258 40 41 59 125 331 330 331 773 865 2477 40 41 123 2035 46 2478 40 41 46 2479 40 362 41 59 2035 46 2480 40 40 2481 41 45 62 744 2482 60 62 40 2481 46 2483 40 41 41 41 59 2035 46 2484 40 744 2485 60 62 40 41 123 64 2087 777 2486 60 2025 44 2025 62 2487 40 2027 60 2025 44 2025 62 2488 41 123 792 744 2486 60 62 40 41 123 773 2073 2268 59 773 2063 60 2073 46 2489 62 2490 59 64 2087 777 865 2491 40 657 2025 2492 44 570 2493 41 123 818 46 2491 40 2492 44 2493 41 59 688 40 2492 340 2494 307 33 2493 41 123 2268 61 2492 46 2495 40 41 59 2490 61 40 2496 44 2497 44 2498 41 45 62 2499 40 41 59 2268 46 2500 40 41 46 2501 40 2490 41 59 2499 40 41 59 125 630 123 2502 40 2494 41 59 688 40 2268 340 2494 307 2490 340 2494 41 123 2268 46 2503 40 41 46 2504 40 2490 41 59 2268 61 2494 59 2490 61 2494 59 125 125 125 773 865 2505 40 41 123 2506 2507 59 688 40 2268 323 2508 41 792 59 688 40 2267 40 2268 41 41 123 2507 61 744 2506 40 2268 46 2509 40 41 41 59 2507 46 2510 40 2511 46 2512 40 2513 46 2514 41 41 59 2507 46 2515 40 2516 45 62 2010 46 2517 40 2268 41 41 59 2507 46 2518 40 744 2519 40 2520 46 2521 40 362 41 41 41 59 688 40 2268 46 2522 40 41 41 123 2507 46 2523 40 41 46 2478 40 41 46 2524 40 362 44 362 41 59 125 630 123 2507 46 2525 40 41 46 2478 40 41 46 2526 40 362 44 362 41 59 125 125 630 123 2507 61 744 2506 40 2268 46 2527 40 41 41 59 2507 46 2528 40 2529 45 62 2010 46 2530 40 2268 41 41 59 2507 46 2531 40 744 2532 40 2533 46 2534 40 362 41 41 41 59 125 2535 40 2507 41 59 125 125 59 125 125 41 59 125 773 865 2536 40 41 123 2036 46 2537 40 40 2268 41 45 62 744 2538 60 62 40 2268 46 2539 40 41 41 41 59 2036 46 2540 40 744 2541 60 62 40 41 123 64 2087 777 2542 60 2025 44 2025 62 2543 40 2027 60 2025 44 2025 62 2544 41 123 792 744 2542 60 62 40 41 123 64 2087 777 865 2545 40 657 2025 2546 44 570 2547 41 123 818 46 2545 40 2546 44 2547 41 59 688 40 2546 340 2548 307 33 2547 41 123 2549 40 744 2550 40 2551 46 2552 40 2546 46 2553 40 41 46 2554 40 41 41 41 41 59 125 630 123 2555 40 2548 41 59 125 125 125 59 125 125 41 59 125 773 865 2556 40 41 123 2030 46 2557 40 40 2268 41 45 62 744 2558 60 62 40 2268 46 2559 40 41 41 41 59 2030 46 2560 40 744 2561 60 62 40 41 123 64 2087 777 2562 60 2025 44 2025 62 2563 40 2027 60 2025 44 2025 62 2564 41 123 792 744 2562 60 62 40 41 123 64 2087 777 865 2565 40 657 2025 2566 44 570 2567 41 123 818 46 2565 40 2566 44 2567 41 59 688 40 2566 340 2568 307 33 2567 41 2569 40 744 2570 40 2016 46 2571 40 2566 46 2572 40 41 46 2573 40 41 41 41 41 59 630 2569 40 2568 41 59 125 125 59 125 125 41 59 125 773 865 2574 40 41 123 2028 46 2575 40 40 2268 41 45 62 744 2576 60 62 40 2268 46 2577 40 41 41 41 59 2028 46 2578 40 744 2579 60 62 40 41 123 64 2087 777 2580 60 2025 44 2025 62 2581 40 2027 60 2025 44 2025 62 2582 41 123 792 744 2580 60 62 40 41 123 64 2087 777 865 2583 40 657 2025 2584 44 570 2585 41 123 818 46 2583 40 2584 44 2585 41 59 688 40 2584 340 2586 307 33 2585 41 2587 40 744 2588 40 2082 46 2589 40 2584 46 2590 40 41 41 41 41 59 630 2587 40 2586 41 59 125 125 59 125 125 41 59 125 773 865 2591 40 41 123 2029 46 2592 40 40 2268 41 45 62 744 2593 60 62 40 2268 46 2594 40 41 41 41 59 2029 46 2595 40 744 2596 60 62 40 41 123 64 2087 777 2597 60 2025 44 2025 62 2598 40 2027 60 2025 44 2025 62 2599 41 123 792 744 2597 60 62 40 41 123 64 2087 777 865 2600 40 657 2025 2601 44 570 2602 41 123 818 46 2600 40 2601 44 2602 41 59 688 40 2601 340 2603 307 33 2602 41 123 830 123 2056 2604 61 2605 46 2606 40 2601 46 2607 40 41 46 2608 40 41 41 59 2609 40 744 2610 40 2604 41 41 59 125 580 40 2611 2612 41 123 2613 46 2614 40 2612 46 2615 40 41 41 59 330 125 125 630 2616 40 2603 41 59 125 125 59 125 125 41 59 125 773 865 2617 40 41 123 2034 46 2618 40 40 2268 41 45 62 744 2619 60 62 40 2268 46 2620 40 41 41 41 59 2034 46 2621 40 744 2622 60 62 40 41 123 64 2087 777 2623 60 2025 44 2025 62 2624 40 2027 60 2025 44 2025 62 2625 41 123 792 744 2623 60 62 40 41 123 64 2087 777 865 2626 40 657 2025 2627 44 570 2628 41 123 818 46 2626 40 2627 44 2628 41 59 688 40 2627 340 2629 307 33 2628 41 2630 40 744 2631 40 2080 46 2632 40 2627 41 41 41 59 630 2630 40 2629 41 59 125 125 59 125 125 41 59 125 773 865 2633 40 41 123 2032 46 2634 40 40 2268 41 45 62 744 2635 60 62 40 2268 46 2636 40 41 41 41 59 2032 46 2637 40 744 2638 60 62 40 41 123 64 2087 777 2639 60 2025 44 2025 62 2640 40 2027 60 2025 44 2025 62 2641 41 123 792 744 2639 60 62 40 41 123 64 2087 777 865 2642 40 657 2025 2643 44 570 2644 41 123 818 46 2642 40 2643 44 2644 41 59 2645 40 744 2646 40 2080 46 2647 40 2643 41 41 41 59 125 125 59 125 125 41 59 125 773 865 2648 40 41 123 2033 46 2649 40 40 2268 41 45 62 744 2650 60 62 40 2268 46 2651 40 41 41 41 59 2033 46 2652 40 744 2653 60 62 40 41 123 64 2087 777 2654 60 2025 44 2025 62 2655 40 2027 60 2025 44 2025 62 2656 41 123 792 744 2654 60 62 40 41 123 64 2087 777 865 2657 40 657 2025 2658 44 570 2659 41 123 818 46 2657 40 2658 44 2659 41 59 688 40 2658 340 2660 307 33 2659 41 2661 40 744 2662 40 2080 46 2663 40 2658 41 41 41 59 630 2661 40 2660 41 59 125 125 59 125 125 41 59 125 64 2664 40 362 41 773 2027 60 2025 44 2025 62 2665 40 41 123 2031 46 2666 40 40 2268 41 45 62 744 2667 60 62 40 2268 46 2668 40 41 41 41 59 2031 46 2669 40 41 46 2670 40 362 44 362 41 59 2031 46 2671 40 744 2672 60 62 40 41 123 64 2087 777 2673 60 2025 44 2025 62 2674 40 2027 60 2025 44 2025 62 2675 41 123 792 744 2673 60 62 40 41 123 64 2087 777 865 2676 40 2025 2677 44 570 2678 41 123 818 46 2676 40 2677 44 2678 41 59 688 40 33 2678 307 2677 340 2679 41 123 657 2073 2268 61 2677 46 2680 40 41 59 657 2681 2682 61 2268 46 2683 40 41 59 704 2684 61 2080 46 2685 40 2268 41 59 2056 2686 61 2687 46 2688 40 362 41 59 2689 2690 61 744 2691 40 2682 44 2686 44 2684 44 2018 44 2268 44 2022 44 2080 46 2692 44 2019 41 59 2693 40 744 2694 40 1501 44 1500 44 1500 44 1500 41 41 59 2695 40 2690 41 59 125 630 123 2696 40 2679 41 59 125 125 125 59 125 125 41 59 792 2031 59 125 64 2664 40 362 41 773 2027 60 2025 44 2025 62 2697 40 41 123 2037 46 2698 40 40 2268 41 45 62 744 2699 60 62 40 2268 46 2700 40 41 41 41 59 2037 46 2701 40 41 46 2702 40 362 44 362 41 59 2037 46 2703 40 2704 41 59 2037 46 2705 40 744 2706 60 62 40 41 123 64 2087 777 2707 60 2025 44 2025 62 2708 40 2027 60 2025 44 2025 62 2709 41 123 792 744 2707 60 62 40 41 123 64 2087 777 865 2710 40 2025 2711 44 570 2712 41 123 818 46 2710 40 2711 44 2712 41 59 688 40 33 2712 307 2711 340 2713 41 123 2073 2268 61 2711 46 2714 40 41 59 2056 2715 61 2268 46 2716 40 41 59 330 330 330 330 330 330 330 2067 2717 59 688 40 33 2068 46 2718 40 2715 41 41 123 2717 61 2719 46 2720 40 2721 46 2722 41 59 2068 46 2723 40 2715 44 2717 41 59 2717 46 2724 40 744 2725 40 2726 46 2727 40 362 41 41 41 59 125 630 123 2717 61 2068 46 2728 40 2715 41 59 125 2069 2447 59 688 40 33 2070 46 2718 40 2715 41 41 123 2447 61 744 2069 40 2717 41 59 2070 46 2729 40 2715 44 2447 41 59 2447 46 2730 40 2731 46 2732 41 59 125 630 123 2447 61 2070 46 2733 40 2715 41 59 125 2717 46 2734 40 2735 45 62 123 2026 46 2736 40 41 46 2737 40 823 46 2738 40 41 41 59 2340 40 2268 41 59 125 41 59 688 40 33 2072 46 2718 40 2715 41 41 123 2053 60 2071 62 2739 61 2740 45 62 2446 40 2268 44 2447 41 59 2072 46 2741 40 2715 44 2739 41 59 2268 46 2742 40 41 46 2743 40 2739 41 59 125 2446 40 2268 44 2447 41 59 2744 40 2447 41 59 125 630 123 2745 40 2713 41 59 125 125 125 59 125 125 41 59 792 2037 59 125 773 865 2746 40 41 123 2038 46 2747 40 40 2268 41 45 62 744 2748 60 62 40 2268 46 2749 40 41 41 41 59 2038 46 2750 40 744 2751 60 62 40 41 123 64 2087 777 2752 60 2025 44 2025 62 2753 40 2027 60 2025 44 2025 62 2754 41 123 792 744 2752 60 62 40 41 123 773 2073 2268 59 773 2755 2756 44 2757 59 773 2063 60 2073 46 2758 62 2759 59 64 2087 777 865 2760 40 2025 2761 44 570 2762 41 123 818 46 2760 40 2761 44 2762 41 59 688 40 33 2762 307 2761 340 2763 41 123 2268 61 2761 46 2764 40 41 59 2759 61 40 2765 44 2766 44 2767 41 45 62 2768 40 41 59 2268 46 2769 40 41 46 2770 40 2759 41 59 2768 40 41 59 125 630 123 2771 40 41 59 125 125 773 865 2772 40 41 123 688 40 2267 40 2268 41 41 123 2773 2774 61 2775 46 2776 40 2777 46 2778 41 59 2773 2779 61 2775 46 2776 40 2777 46 2780 41 59 688 40 2268 46 2781 40 41 41 123 2779 46 2782 40 41 46 2783 40 362 44 362 41 59 2774 46 2782 40 41 46 2783 40 362 44 362 41 59 125 630 123 2779 46 2784 40 41 46 2785 40 362 44 362 41 59 2774 46 2784 40 41 46 2785 40 362 44 362 41 59 125 2756 61 744 2755 40 362 44 2774 41 59 2756 46 2786 40 41 46 2787 40 362 41 59 2756 46 2788 40 744 2789 40 2790 46 2791 40 362 41 41 41 59 2756 46 2792 40 2793 45 62 2289 40 2268 41 41 59 2757 61 744 2755 40 362 44 2779 41 59 2757 46 2786 40 41 46 2787 40 362 41 59 2757 46 2788 40 744 2789 40 2790 46 2791 40 362 41 41 41 59 2757 46 2792 40 2793 45 62 2275 40 2268 41 41 59 2794 2795 61 744 2794 40 41 59 2795 46 2796 40 1500 41 59 2795 46 2797 40 41 46 2798 40 2756 44 2757 41 59 2799 40 2795 41 59 125 630 123 2800 40 41 59 125 2258 40 41 59 125 773 865 2801 40 41 123 688 40 2756 340 2802 41 123 2756 46 2803 40 2802 41 59 125 688 40 2757 340 2802 41 123 2757 46 2804 40 2802 41 59 125 688 40 2759 340 2802 307 2268 340 2802 41 123 2268 46 2805 40 41 46 2806 40 2759 41 59 125 2807 40 2802 41 59 125 125 59 125 125 41 59 125 125 ,"{'AvgLine': 30, 'CountLine': 872, 'CountStmt': 482, 'MaxNesting': 3, 'AvgLineCode': 26, 'AvgEssential': 1, 'AvgLineBlank': 2, 'CountStmtExe': 391, 'MaxEssential': 6, 'SumEssential': 67, 'AvgCyclomatic': 1, 'CountLineCode': 739, 'CountStmtDecl': 130, 'MaxCyclomatic': 8, 'SumCyclomatic': 95, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 104, 'CountSemicolon': 376, 'CountDeclMethod': 26, 'CountLineCodeExe': 572, 'CountLineComment': 30, 'CountClassCoupled': 75, 'CountClassDerived': 0, 'CountLineCodeDecl': 120, 'CountDeclMethodAll': 41, 'MaxInheritanceTree': 5, 'RatioCommentToCode': '0.04', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 8, 'SumCyclomaticStrict': 102, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 8, 'PercentLackOfCohesion': 93, 'SumCyclomaticModified': 95, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 22, 'CountDeclInstanceMethod': 26, 'CountDeclMethodProtected': 2, 'CountClassCoupledModified': 75, 'CountDeclInstanceVariable': 40, 'PercentLackOfCohesionModified': 93}"
4450,Java,"@FxmlView
public class FailedTradesView extends ActivatableViewAndModel<VBox, FailedTradesViewModel> {

    @FXML
    TableView<FailedTradesListItem> tableView;
    @FXML
    TableColumn<FailedTradesListItem, FailedTradesListItem> priceColumn, amountColumn, volumeColumn,
            marketColumn, directionColumn, dateColumn, tradeIdColumn, stateColumn, removeTradeColumn;
    @FXML
    HBox searchBox;
    @FXML
    AutoTooltipLabel filterLabel;
    @FXML
    InputTextField filterTextField;
    @FXML
    Pane searchBoxSpacer;
    @FXML
    Label numItems;
    @FXML
    Region footerSpacer;
    @FXML
    AutoTooltipButton exportButton;

    private final TradeDetailsWindow tradeDetailsWindow;
    private SortedList<FailedTradesListItem> sortedList;
    private FilteredList<FailedTradesListItem> filteredList;
    private EventHandler<KeyEvent> keyEventEventHandler;
    private ChangeListener<String> filterTextFieldListener;
    private Scene scene;
    private final boolean allowFaultyDelayedTxs;

    @Inject
    public FailedTradesView(FailedTradesViewModel model,
                            TradeDetailsWindow tradeDetailsWindow,
                            @Named(Config.ALLOW_FAULTY_DELAYED_TXS) boolean allowFaultyDelayedTxs) {
        super(model);
        this.tradeDetailsWindow = tradeDetailsWindow;
        this.allowFaultyDelayedTxs = allowFaultyDelayedTxs;
    }

    @Override
    public void initialize() {
        priceColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.price"")));
        amountColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.amountWithCur"", Res.getBaseCurrencyCode())));
        volumeColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.amount"")));
        marketColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.market"")));
        directionColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.offerType"")));
        dateColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.dateTime"")));
        tradeIdColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.tradeId"")));
        stateColumn.setGraphic(new AutoTooltipLabel(Res.get(""shared.state"")));

        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        tableView.setPlaceholder(new AutoTooltipLabel(Res.get(""table.placeholder.noItems"", Res.get(""shared.trades""))));

        setTradeIdColumnCellFactory();
        setDirectionColumnCellFactory();
        setAmountColumnCellFactory();
        setPriceColumnCellFactory();
        setVolumeColumnCellFactory();
        setDateColumnCellFactory();
        setMarketColumnCellFactory();
        setStateColumnCellFactory();
        setRemoveTradeColumnCellFactory();

        tradeIdColumn.setComparator(Comparator.comparing(o -> o.getTrade().getId()));
        dateColumn.setComparator(Comparator.comparing(o -> o.getTrade().getDate()));
        priceColumn.setComparator(Comparator.comparing(o -> o.getTrade().getPrice()));
        volumeColumn.setComparator(Comparator.comparing(o -> o.getTrade().getVolume(), Comparator.nullsFirst(Comparator.naturalOrder())));
        amountColumn.setComparator(Comparator.comparing(o -> o.getTrade().getAmount(), Comparator.nullsFirst(Comparator.naturalOrder())));
        stateColumn.setComparator(Comparator.comparing(model::getState));
        marketColumn.setComparator(Comparator.comparing(model::getMarketLabel));

        dateColumn.setSortType(TableColumn.SortType.DESCENDING);
        tableView.getSortOrder().add(dateColumn);

        keyEventEventHandler = keyEvent -> {
            if (Utilities.isAltOrCtrlPressed(KeyCode.Y, keyEvent)) {
                var checkTxs = checkTxs();
                var checkUnfailString = checkUnfail();
                if (!checkTxs.isEmpty()) {
                    log.warn(""Cannot unfail, error {}"", checkTxs);
                    new Popup().warning(checkTxs)
                            .show();
                } else if (!checkUnfailString.isEmpty()) {
                    log.warn(""Cannot unfail, error {}"", checkUnfailString);
                    new Popup().warning(Res.get(""portfolio.failed.cantUnfail"", checkUnfailString))
                            .show();
                } else {
                    new Popup().warning(Res.get(""portfolio.failed.unfail""))
                            .onAction(this::onUnfail)
                            .show();
                }
            }
        };

        filterLabel.setText(Res.get(""shared.filter""));
        HBox.setMargin(filterLabel, new Insets(5, 0, 0, 10));
        filterTextFieldListener = (observable, oldValue, newValue) -> applyFilteredListPredicate(filterTextField.getText());
        searchBox.setSpacing(5);
        HBox.setHgrow(searchBoxSpacer, Priority.ALWAYS);

        numItems.setId(""num-offers"");
        numItems.setPadding(new Insets(-5, 0, 0, 10));
        HBox.setHgrow(footerSpacer, Priority.ALWAYS);
        HBox.setMargin(exportButton, new Insets(0, 10, 0, 0));
        exportButton.updateText(Res.get(""shared.exportCSV""));
    }

    @Override
    protected void activate() {
        scene = root.getScene();
        if (scene != null) {
            scene.addEventHandler(KeyEvent.KEY_RELEASED, keyEventEventHandler);
        }

        filteredList = new FilteredList<>(model.getList());
        sortedList = new SortedList<>(filteredList);
        sortedList.comparatorProperty().bind(tableView.comparatorProperty());
        tableView.setItems(sortedList);

        numItems.setText(Res.get(""shared.numItemsLabel"", sortedList.size()));
        exportButton.setOnAction(event -> {
            ObservableList<TableColumn<FailedTradesListItem, ?>> tableColumns = tableView.getColumns();
            int reportColumns = tableColumns.size() - 1;    // CSV report excludes the last column (an icon)
            CSVEntryConverter<FailedTradesListItem> headerConverter = item -> {
                String[] columns = new String[reportColumns];
                for (int i = 0; i < columns.length; i++)
                    columns[i] = ((AutoTooltipLabel) tableColumns.get(i).getGraphic()).getText();
                return columns;
            };
            CSVEntryConverter<FailedTradesListItem> contentConverter = item -> {
                String[] columns = new String[reportColumns];
                columns[0] = model.getTradeId(item);
                columns[1] = model.getDate(item);
                columns[2] = model.getMarketLabel(item);
                columns[3] = model.getPrice(item);
                columns[4] = model.getAmount(item);
                columns[5] = model.getVolume(item);
                columns[6] = model.getDirectionLabel(item);
                columns[7] = model.getState(item);
                return columns;
            };

            GUIUtil.exportCSV(""failedTrades.csv"",
                    headerConverter,
                    contentConverter,
                    new FailedTradesListItem(),
                    sortedList,
                    (Stage) root.getScene().getWindow());
        });

        filterTextField.textProperty().addListener(filterTextFieldListener);
        applyFilteredListPredicate(filterTextField.getText());
    }

    @Override
    protected void deactivate() {
        if (scene != null) {
            scene.removeEventHandler(KeyEvent.KEY_RELEASED, keyEventEventHandler);
        }

        sortedList.comparatorProperty().unbind();
        exportButton.setOnAction(null);

        filterTextField.textProperty().removeListener(filterTextFieldListener);
    }

    private void applyFilteredListPredicate(String filterString) {
        filteredList.setPredicate(item -> {
            if (filterString.isEmpty())
                return true;

            Offer offer = item.getTrade().getOffer();

            if (offer.getId().contains(filterString)) {
                return true;
            }
            if (model.getDate(item).contains(filterString)) {
                return true;
            }
            if (model.getMarketLabel(item).contains(filterString)) {
                return true;
            }
            if (model.getPrice(item).contains(filterString)) {
                return true;
            }
            if (model.getVolume(item).contains(filterString)) {
                return true;
            }
            if (model.getAmount(item).contains(filterString)) {
                return true;
            }
            if (model.getDirectionLabel(item).contains(filterString)) {
                return true;
            }
            if (offer.getOfferFeePaymentTxId() != null &&
                    offer.getOfferFeePaymentTxId().contains(filterString)) {
                return true;
            }

            Trade trade = item.getTrade();

            if (trade.getTakerFeeTxId() != null && trade.getTakerFeeTxId().contains(filterString)) {
                return true;
            }
            if (trade.getDepositTxId() != null && trade.getDepositTxId().contains(filterString)) {
                return true;
            }
            if (trade.getPayoutTxId() != null && trade.getPayoutTxId().contains(filterString)) {
                return true;
            }

            Contract contract = trade.getContract();

            boolean isBuyerOnion = false;
            boolean isSellerOnion = false;
            boolean matchesBuyersPaymentAccountData = false;
            boolean matchesSellersPaymentAccountData = false;
            if (contract != null) {
                isBuyerOnion = contract.getBuyerNodeAddress().getFullAddress().contains(filterString);
                isSellerOnion = contract.getSellerNodeAddress().getFullAddress().contains(filterString);
                matchesBuyersPaymentAccountData = contract.getBuyerPaymentAccountPayload() != null &&
                        contract.getBuyerPaymentAccountPayload().getPaymentDetails().contains(filterString);
                matchesSellersPaymentAccountData = contract.getSellerPaymentAccountPayload() != null &&
                        contract.getSellerPaymentAccountPayload().getPaymentDetails().contains(filterString);
            }
            return isBuyerOnion || isSellerOnion ||
                    matchesBuyersPaymentAccountData || matchesSellersPaymentAccountData;
        });
    }

    private void onUnfail() {
        Trade trade = sortedList.get(tableView.getSelectionModel().getFocusedIndex()).getTrade();
        model.dataModel.unfailTrade(trade);
    }

    private String checkUnfail() {
        Trade trade = sortedList.get(tableView.getSelectionModel().getFocusedIndex()).getTrade();
        return model.dataModel.checkUnfail(trade);
    }

    private String checkTxs() {
        Trade trade = sortedList.get(tableView.getSelectionModel().getFocusedIndex()).getTrade();
        log.info(""Initiated unfail of trade {}"", trade.getId());
        if (trade.getDepositTx() == null) {
            log.info(""Check unfail found no depositTx for trade {}"", trade.getId());
            return Res.get(""portfolio.failed.depositTxNull"");
        }
        if (trade.getDelayedPayoutTxBytes() == null) {
            log.info(""Check unfail found no delayedPayoutTxBytes for trade {}"", trade.getId());
            if (!allowFaultyDelayedTxs) {
                return Res.get(""portfolio.failed.delayedPayoutTxNull"");
            }
        }
        return """";
    }

    private void onRevertTrade(Trade trade) {
        new Popup().attention(Res.get(""portfolio.failed.revertToPending.popup""))
                .onAction(() -> {
                    if (!onMoveTradeToPendingTrades(trade)) {
                        new Popup().warning(Res.get(""portfolio.failed.revertToPending.failed"")).show();
                    }
                })
                .actionButtonText(Res.get(""shared.yes""))
                .closeButtonText(Res.get(""shared.no""))
                .show();
    }

    private boolean onMoveTradeToPendingTrades(Trade trade) {
       return model.dataModel.onMoveTradeToPendingTrades(trade);
    }

    private void setTradeIdColumnCellFactory() {
        tradeIdColumn.getStyleClass().add(""first-column"");
        tradeIdColumn.setCellValueFactory((offerListItem) -> new ReadOnlyObjectWrapper<>(offerListItem.getValue()));
        tradeIdColumn.setCellFactory(
                new Callback<>() {

                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(TableColumn<FailedTradesListItem,
                            FailedTradesListItem> column) {
                        return new TableCell<>() {
                            private HyperlinkWithIcon field;

                            @Override
                            public void updateItem(final FailedTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null && !empty) {
                                    field = new HyperlinkWithIcon(model.getTradeId(item));
                                    field.setOnAction(event -> tradeDetailsWindow.show(item.getTrade()));
                                    field.setTooltip(new Tooltip(Res.get(""tooltip.openPopupForDetails"")));
                                    setGraphic(field);
                                } else {
                                    setGraphic(null);
                                    if (field != null)
                                        field.setOnAction(null);
                                }
                            }
                        };
                    }
                });
    }

    private void setDateColumnCellFactory() {
        dateColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        dateColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(
                            TableColumn<FailedTradesListItem, FailedTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final FailedTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setGraphic(new AutoTooltipLabel(model.getDate(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setMarketColumnCellFactory() {
        marketColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        marketColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(
                            TableColumn<FailedTradesListItem, FailedTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final FailedTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getMarketLabel(item)));
                            }
                        };
                    }
                });
    }

    private void setStateColumnCellFactory() {
        stateColumn.getStyleClass().add(""last-column"");
        stateColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        stateColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(
                            TableColumn<FailedTradesListItem, FailedTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final FailedTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setGraphic(new AutoTooltipLabel(model.getState(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }


    private void setAmountColumnCellFactory() {
        amountColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        amountColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(
                            TableColumn<FailedTradesListItem, FailedTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final FailedTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getAmount(item)));
                            }
                        };
                    }
                });
    }

    private void setPriceColumnCellFactory() {
        priceColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        priceColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(
                            TableColumn<FailedTradesListItem, FailedTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final FailedTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getPrice(item)));
                            }
                        };
                    }
                });
    }

    private void setVolumeColumnCellFactory() {
        volumeColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        volumeColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(
                            TableColumn<FailedTradesListItem, FailedTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final FailedTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                if (item != null)
                                    setGraphic(new AutoTooltipLabel(model.getVolume(item)));
                                else
                                    setGraphic(null);
                            }
                        };
                    }
                });
    }

    private void setDirectionColumnCellFactory() {
        directionColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        directionColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(
                            TableColumn<FailedTradesListItem, FailedTradesListItem> column) {
                        return new TableCell<>() {
                            @Override
                            public void updateItem(final FailedTradesListItem item, boolean empty) {
                                super.updateItem(item, empty);
                                setGraphic(new AutoTooltipLabel(model.getDirectionLabel(item)));
                            }
                        };
                    }
                });
    }

    private TableColumn<FailedTradesListItem, FailedTradesListItem> setRemoveTradeColumnCellFactory() {
        removeTradeColumn.setCellValueFactory((trade) -> new ReadOnlyObjectWrapper<>(trade.getValue()));
        removeTradeColumn.setCellFactory(
                new Callback<>() {
                    @Override
                    public TableCell<FailedTradesListItem, FailedTradesListItem> call(TableColumn<FailedTradesListItem,
                            FailedTradesListItem> column) {
                        return new TableCell<>() {

                            @Override
                            public void updateItem(FailedTradesListItem newItem, boolean empty) {
                                super.updateItem(newItem, empty);
                                if (!empty && newItem != null) {
                                    Label icon = FormBuilder.getIcon(AwesomeIcon.UNDO);
                                    icon.getStyleClass().addAll(""icon"", ""dao-remove-proposal-icon"");
                                    JFXButton iconButton = new JFXButton("""", icon);
                                    iconButton.setStyle(""-fx-cursor: hand;"");
                                    iconButton.getStyleClass().add(""hidden-icon-button"");
                                    iconButton.setTooltip(new Tooltip(Res.get(""portfolio.failed.revertToPending"")));
                                    iconButton.setOnAction(e -> onRevertTrade(newItem.getTrade()));
                                    setGraphic(iconButton);
                                } else {
                                    setGraphic(null);
                                }
                            }
                        };
                    }
                });
        return removeTradeColumn;
    }
}",1,64 2000 777 587 2001 650 2002 60 2003 44 2004 62 123 64 2005 2006 60 2007 62 2008 59 64 2005 2009 60 2007 44 2007 62 2010 44 2011 44 2012 44 2013 44 2014 44 2015 44 2016 44 2017 44 2018 59 64 2005 2019 2020 59 64 2005 2021 2022 59 64 2005 2023 2024 59 64 2005 2025 2026 59 64 2005 2027 2028 59 64 2005 2029 2030 59 64 2005 2031 2032 59 773 657 2033 2034 59 773 2035 60 2007 62 2036 59 773 2037 60 2007 62 2038 59 773 2039 60 2040 62 2041 59 773 2042 60 2043 62 2044 59 773 2045 2046 59 773 657 570 2047 59 64 2048 777 2001 40 2004 2049 44 2033 2034 44 64 2050 40 2051 46 2052 41 570 2047 41 123 818 40 2049 41 59 823 46 2034 61 2034 59 823 46 2047 61 2047 59 125 64 2053 777 865 2054 40 41 123 2010 46 2055 40 744 2021 40 2056 46 2057 40 362 41 41 41 59 2011 46 2055 40 744 2021 40 2056 46 2057 40 362 44 2056 46 2058 40 41 41 41 41 59 2012 46 2055 40 744 2021 40 2056 46 2057 40 362 41 41 41 59 2013 46 2055 40 744 2021 40 2056 46 2057 40 362 41 41 41 59 2014 46 2055 40 744 2021 40 2056 46 2057 40 362 41 41 41 59 2015 46 2055 40 744 2021 40 2056 46 2057 40 362 41 41 41 59 2016 46 2055 40 744 2021 40 2056 46 2057 40 362 41 41 41 59 2017 46 2055 40 744 2021 40 2056 46 2057 40 362 41 41 41 59 2008 46 2059 40 2006 46 2060 41 59 2008 46 2061 40 744 2021 40 2056 46 2057 40 362 44 2056 46 2057 40 362 41 41 41 41 59 2062 40 41 59 2063 40 41 59 2064 40 41 59 2065 40 41 59 2066 40 41 59 2067 40 41 59 2068 40 41 59 2069 40 41 59 2070 40 41 59 2016 46 2071 40 2072 46 2073 40 2074 45 62 2074 46 2075 40 41 46 2076 40 41 41 41 59 2015 46 2071 40 2072 46 2073 40 2074 45 62 2074 46 2075 40 41 46 2077 40 41 41 41 59 2010 46 2071 40 2072 46 2073 40 2074 45 62 2074 46 2075 40 41 46 2078 40 41 41 41 59 2012 46 2071 40 2072 46 2073 40 2074 45 62 2074 46 2075 40 41 46 2079 40 41 44 2072 46 2080 40 2072 46 2081 40 41 41 41 41 59 2011 46 2071 40 2072 46 2073 40 2074 45 62 2074 46 2075 40 41 46 2082 40 41 44 2072 46 2080 40 2072 46 2081 40 41 41 41 41 59 2017 46 2071 40 2072 46 2073 40 2049 58 58 2083 41 41 59 2013 46 2071 40 2072 46 2073 40 2049 58 58 2084 41 41 59 2015 46 2085 40 2009 46 2086 46 2087 41 59 2008 46 2088 40 41 46 2089 40 2015 41 59 2041 61 2090 45 62 123 688 40 2091 46 2092 40 2093 46 2094 44 2090 41 41 123 2095 2096 61 2096 40 41 59 2095 2097 61 2098 40 41 59 688 40 33 2096 46 2099 40 41 41 123 2100 46 2101 40 362 44 2096 41 59 744 2102 40 41 46 2103 40 2096 41 46 2104 40 41 59 125 630 688 40 33 2097 46 2099 40 41 41 123 2105 46 2106 40 362 44 2097 41 59 744 2107 40 41 46 2108 40 2056 46 2057 40 362 44 2097 41 41 46 2109 40 41 59 125 630 123 744 2110 40 41 46 2111 40 2056 46 2057 40 362 41 41 46 2112 40 823 58 58 2113 41 46 2114 40 41 59 125 125 125 59 2022 46 2115 40 2056 46 2057 40 362 41 41 59 2019 46 2116 40 2022 44 744 2117 40 1502 44 1500 44 1500 44 1502 41 41 59 2044 61 40 2118 44 2119 44 2120 41 45 62 2121 40 2024 46 2122 40 41 41 59 2020 46 2123 40 1502 41 59 2019 46 2124 40 2026 44 2125 46 2126 41 59 2028 46 2127 40 362 41 59 2028 46 2128 40 744 2117 40 45 1502 44 1500 44 1500 44 1502 41 41 59 2019 46 2124 40 2030 44 2125 46 2126 41 59 2019 46 2116 40 2032 44 744 2117 40 1500 44 1502 44 1500 44 1500 41 41 59 2032 46 2129 40 2056 46 2057 40 362 41 41 59 125 64 2053 775 865 2130 40 41 123 2046 61 2131 46 2132 40 41 59 688 40 2046 340 2133 41 123 2046 46 2134 40 2040 46 2135 44 2041 41 59 125 2038 61 744 2037 60 62 40 2049 46 2136 40 41 41 59 2036 61 744 2035 60 62 40 2038 41 59 2036 46 2137 40 41 46 2138 40 2008 46 2137 40 41 41 59 2008 46 2139 40 2036 41 59 2028 46 2140 40 2141 46 2142 40 362 44 2036 46 2143 40 41 41 41 59 2032 46 2144 40 2145 45 62 123 2146 60 2009 60 2007 44 63 356 2147 61 2008 46 2148 40 41 59 704 2149 61 2147 46 2143 40 41 45 1501 59 330 2150 60 2007 62 2151 61 2152 45 62 123 2043 91 93 2153 61 744 2043 91 2149 93 59 664 40 704 2154 61 1500 59 2154 60 2153 46 2155 59 2154 349 41 2153 91 2154 93 61 40 40 2021 41 2147 46 2142 40 2154 41 46 2156 40 41 41 46 2157 40 41 59 792 2153 59 125 59 2150 60 2007 62 2158 61 2152 45 62 123 2043 91 93 2159 61 744 2043 91 2149 93 59 2159 91 1500 93 61 2049 46 2160 40 2152 41 59 2159 91 1501 93 61 2049 46 2161 40 2152 41 59 2159 91 1502 93 61 2049 46 2162 40 2152 41 59 2159 91 1502 93 61 2049 46 2163 40 2152 41 59 2159 91 1502 93 61 2049 46 2164 40 2152 41 59 2159 91 1502 93 61 2049 46 2165 40 2152 41 59 2159 91 1502 93 61 2049 46 2166 40 2152 41 59 2159 91 1502 93 61 2049 46 2167 40 2152 41 59 792 2159 59 125 59 2168 46 2169 40 362 44 2151 44 2158 44 744 2007 40 41 44 2036 44 40 2170 41 2131 46 2132 40 41 46 2171 40 41 41 59 125 41 59 2024 46 2172 40 41 46 2173 40 2044 41 59 2174 40 2024 46 2175 40 41 41 59 125 64 2053 775 865 2176 40 41 123 688 40 2046 340 2177 41 123 2046 46 2178 40 2040 46 2179 44 2041 41 59 125 2036 46 2180 40 41 46 2181 40 41 59 2032 46 2182 40 2177 41 59 2024 46 2183 40 41 46 2184 40 2044 41 59 125 773 865 2185 40 2043 2186 41 123 2038 46 2187 40 2188 45 62 123 688 40 2186 46 2189 40 41 41 792 2190 59 2191 2192 61 2188 46 2193 40 41 46 2194 40 41 59 688 40 2192 46 2195 40 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2049 46 2197 40 2188 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2049 46 2198 40 2188 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2049 46 2199 40 2188 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2049 46 2200 40 2188 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2049 46 2201 40 2188 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2049 46 2202 40 2188 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2192 46 2203 40 41 340 2204 307 2192 46 2203 40 41 46 2196 40 2186 41 41 123 792 2190 59 125 2205 2206 61 2188 46 2193 40 41 59 688 40 2206 46 2207 40 41 340 2204 307 2206 46 2207 40 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2206 46 2208 40 41 340 2204 307 2206 46 2208 40 41 46 2196 40 2186 41 41 123 792 2190 59 125 688 40 2206 46 2209 40 41 340 2204 307 2206 46 2209 40 41 46 2196 40 2186 41 41 123 792 2190 59 125 2210 2211 61 2206 46 2212 40 41 59 570 2213 61 2214 59 570 2215 61 2214 59 570 2216 61 2214 59 570 2217 61 2214 59 688 40 2211 340 2204 41 123 2213 61 2211 46 2218 40 41 46 2219 40 41 46 2196 40 2186 41 59 2215 61 2211 46 2220 40 41 46 2219 40 41 46 2196 40 2186 41 59 2216 61 2211 46 2221 40 41 340 2204 307 2211 46 2221 40 41 46 2222 40 41 46 2196 40 2186 41 59 2217 61 2211 46 2223 40 41 340 2204 307 2211 46 2223 40 41 46 2222 40 41 46 2196 40 2186 41 59 125 792 2213 309 2215 309 2216 309 2217 59 125 41 59 125 773 865 2224 40 41 123 2225 2226 61 2036 46 2227 40 2008 46 2228 40 41 46 2229 40 41 41 46 2230 40 41 59 2049 46 2231 46 2232 40 2226 41 59 125 773 2043 2233 40 41 123 2234 2235 61 2036 46 2236 40 2008 46 2237 40 41 46 2238 40 41 41 46 2239 40 41 59 792 2049 46 2240 46 2233 40 2235 41 59 125 773 2043 2241 40 41 123 2242 2243 61 2036 46 2244 40 2008 46 2245 40 41 46 2246 40 41 41 46 2247 40 41 59 2248 46 2249 40 362 44 2243 46 2250 40 41 41 59 688 40 2243 46 2251 40 41 323 2252 41 123 2248 46 2249 40 362 44 2243 46 2250 40 41 41 59 792 2253 46 2244 40 362 41 59 125 688 40 2243 46 2254 40 41 323 2252 41 123 2248 46 2249 40 362 44 2243 46 2250 40 41 41 59 688 40 33 2047 41 123 792 2255 46 2244 40 362 41 59 125 125 792 362 59 125 773 865 2256 40 2257 2258 41 123 744 2259 40 41 46 2260 40 2261 46 2262 40 362 41 41 46 2263 40 40 41 45 62 123 688 40 33 2264 40 2258 41 41 123 744 2259 40 41 46 2265 40 2261 46 2262 40 362 41 41 46 2266 40 41 59 125 125 41 46 2267 40 2261 46 2262 40 362 41 41 46 2268 40 2261 46 2262 40 362 41 41 46 2269 40 41 59 125 773 570 2270 40 2257 2258 41 123 792 2049 46 2271 46 2270 40 2258 41 59 125 773 865 2272 40 41 123 2016 46 2273 40 41 46 2274 40 362 41 59 2016 46 2275 40 40 2276 41 45 62 744 2277 60 62 40 2276 46 2278 40 41 41 41 59 2016 46 2279 40 744 2280 60 62 40 41 123 64 2053 777 2281 60 2007 44 2007 62 2282 40 2009 60 2007 44 2007 62 2283 41 123 792 744 2281 60 62 40 41 123 773 2284 2285 59 64 2053 777 865 2286 40 657 2007 2287 44 570 2288 41 123 818 46 2286 40 2287 44 2288 41 59 688 40 2287 340 2289 307 33 2288 41 123 2285 61 744 2284 40 2049 46 2290 40 2287 41 41 59 2285 46 2291 40 2292 45 62 2034 46 2293 40 2287 46 2294 40 41 41 41 59 2285 46 2295 40 744 2296 40 2297 46 2298 40 362 41 41 41 59 2299 40 2285 41 59 125 630 123 2300 40 2289 41 59 688 40 2285 340 2289 41 2285 46 2301 40 2289 41 59 125 125 125 59 125 125 41 59 125 773 865 2302 40 41 123 2015 46 2303 40 40 2258 41 45 62 744 2304 60 62 40 2258 46 2305 40 41 41 41 59 2015 46 2306 40 744 2307 60 62 40 41 123 64 2053 777 2308 60 2007 44 2007 62 2309 40 2009 60 2007 44 2007 62 2310 41 123 792 744 2308 60 62 40 41 123 64 2053 777 865 2311 40 657 2007 2312 44 570 2313 41 123 818 46 2311 40 2312 44 2313 41 59 688 40 2312 340 2314 41 2315 40 744 2021 40 2049 46 2316 40 2312 41 41 41 59 630 2315 40 2314 41 59 125 125 59 125 125 41 59 125 773 865 2317 40 41 123 2013 46 2318 40 40 2258 41 45 62 744 2319 60 62 40 2258 46 2320 40 41 41 41 59 2013 46 2321 40 744 2322 60 62 40 41 123 64 2053 777 2323 60 2007 44 2007 62 2324 40 2009 60 2007 44 2007 62 2325 41 123 792 744 2323 60 62 40 41 123 64 2053 777 865 2326 40 657 2007 2327 44 570 2328 41 123 818 46 2326 40 2327 44 2328 41 59 2329 40 744 2021 40 2049 46 2330 40 2327 41 41 41 59 125 125 59 125 125 41 59 125 773 865 2331 40 41 123 2017 46 2332 40 41 46 2333 40 362 41 59 2017 46 2334 40 40 2258 41 45 62 744 2335 60 62 40 2258 46 2336 40 41 41 41 59 2017 46 2337 40 744 2338 60 62 40 41 123 64 2053 777 2339 60 2007 44 2007 62 2340 40 2009 60 2007 44 2007 62 2341 41 123 792 744 2339 60 62 40 41 123 64 2053 777 865 2342 40 657 2007 2343 44 570 2344 41 123 818 46 2342 40 2343 44 2344 41 59 688 40 2343 340 2345 41 2346 40 744 2021 40 2049 46 2347 40 2343 41 41 41 59 630 2346 40 2345 41 59 125 125 59 125 125 41 59 125 773 865 2348 40 41 123 2011 46 2349 40 40 2258 41 45 62 744 2350 60 62 40 2258 46 2351 40 41 41 41 59 2011 46 2352 40 744 2353 60 62 40 41 123 64 2053 777 2354 60 2007 44 2007 62 2355 40 2009 60 2007 44 2007 62 2356 41 123 792 744 2354 60 62 40 41 123 64 2053 777 865 2357 40 657 2007 2358 44 570 2359 41 123 818 46 2357 40 2358 44 2359 41 59 2360 40 744 2021 40 2049 46 2361 40 2358 41 41 41 59 125 125 59 125 125 41 59 125 773 865 2362 40 41 123 2010 46 2363 40 40 2258 41 45 62 744 2364 60 62 40 2258 46 2365 40 41 41 41 59 2010 46 2366 40 744 2367 60 62 40 41 123 64 2053 777 2368 60 2007 44 2007 62 2369 40 2009 60 2007 44 2007 62 2370 41 123 792 744 2368 60 62 40 41 123 64 2053 777 865 2371 40 657 2007 2372 44 570 2373 41 123 818 46 2371 40 2372 44 2373 41 59 2374 40 744 2021 40 2049 46 2375 40 2372 41 41 41 59 125 125 59 125 125 41 59 125 773 865 2376 40 41 123 2012 46 2377 40 40 2258 41 45 62 744 2378 60 62 40 2258 46 2379 40 41 41 41 59 2012 46 2380 40 744 2381 60 62 40 41 123 64 2053 777 2382 60 2007 44 2007 62 2383 40 2009 60 2007 44 2007 62 2384 41 123 792 744 2382 60 62 40 41 123 64 2053 777 865 2385 40 657 2007 2386 44 570 2387 41 123 818 46 2385 40 2386 44 2387 41 59 688 40 2386 340 2388 41 2389 40 744 2021 40 2049 46 2390 40 2386 41 41 41 59 630 2389 40 2388 41 59 125 125 59 125 125 41 59 125 773 865 2391 40 41 123 2014 46 2392 40 40 2258 41 45 62 744 2393 60 62 40 2258 46 2394 40 41 41 41 59 2014 46 2395 40 744 2396 60 62 40 41 123 64 2053 777 2397 60 2007 44 2007 62 2398 40 2009 60 2007 44 2007 62 2399 41 123 792 744 2397 60 62 40 41 123 64 2053 777 865 2400 40 657 2007 2401 44 570 2402 41 123 818 46 2400 40 2401 44 2402 41 59 2403 40 744 2021 40 2049 46 2404 40 2401 41 41 41 59 125 125 59 125 125 41 59 125 773 2009 60 2007 44 2007 62 2405 40 41 123 2018 46 2406 40 40 2258 41 45 62 744 2407 60 62 40 2258 46 2408 40 41 41 41 59 2018 46 2409 40 744 2410 60 62 40 41 123 64 2053 777 2411 60 2007 44 2007 62 2412 40 2009 60 2007 44 2007 62 2413 41 123 792 744 2411 60 62 40 41 123 64 2053 777 865 2414 40 2007 2415 44 570 2416 41 123 818 46 2414 40 2415 44 2416 41 59 688 40 33 2416 307 2415 340 2417 41 123 2027 2418 61 2419 46 2420 40 2421 46 2422 41 59 2418 46 2423 40 41 46 2424 40 362 44 362 41 59 2425 2426 61 744 2425 40 362 44 2418 41 59 2426 46 2427 40 362 41 59 2426 46 2423 40 41 46 2428 40 362 41 59 2426 46 2429 40 744 2430 40 2431 46 2432 40 362 41 41 41 59 2426 46 2433 40 2434 45 62 2256 40 2415 46 2435 40 41 41 41 59 2436 40 2426 41 59 125 630 123 2437 40 2417 41 59 125 125 125 59 125 125 41 59 792 2018 59 125 125 ,"{'AvgLine': 22, 'CountLine': 472, 'CountStmt': 270, 'MaxNesting': 2, 'AvgLineCode': 21, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 206, 'MaxEssential': 4, 'SumEssential': 53, 'AvgCyclomatic': 1, 'CountLineCode': 428, 'CountStmtDecl': 76, 'MaxCyclomatic': 4, 'SumCyclomatic': 60, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 44, 'CountSemicolon': 203, 'CountDeclMethod': 19, 'CountLineCodeExe': 313, 'CountLineComment': 1, 'CountClassCoupled': 45, 'CountClassDerived': 0, 'CountLineCodeDecl': 75, 'CountDeclMethodAll': 34, 'MaxInheritanceTree': 5, 'RatioCommentToCode': '0.00', 'AvgCyclomaticStrict': 1, 'MaxCyclomaticStrict': 4, 'SumCyclomaticStrict': 69, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 1, 'CountDeclMethodPublic': 2, 'MaxCyclomaticModified': 4, 'PercentLackOfCohesion': 88, 'SumCyclomaticModified': 60, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 15, 'CountDeclInstanceMethod': 19, 'CountDeclMethodProtected': 2, 'CountClassCoupledModified': 45, 'CountDeclInstanceVariable': 24, 'PercentLackOfCohesionModified': 88}"
3212,Java,"public abstract class TradeStepView extends AnchorPane {
    protected final Logger log = LoggerFactory.getLogger(this.getClass());

    protected final PendingTradesViewModel model;
    protected final Trade trade;
    protected final Preferences preferences;
    protected final GridPane gridPane;

    private Subscription tradePeriodStateSubscription, disputeStateSubscription, mediationResultStateSubscription;
    protected int gridRow = 0;
    private TextField timeLeftTextField;
    private ProgressBar timeLeftProgressBar;
    private TxIdTextField txIdTextField;
    private TradeStepInfo tradeStepInfo;
    private Subscription txIdSubscription;
    private ClockWatcher.Listener clockListener;
    private final ChangeListener<String> errorMessageListener;
    protected Label infoLabel;
    private Popup acceptMediationResultPopup;
    private BootstrapListener bootstrapListener;
    private TradeSubView.ChatCallback chatCallback;
    private final NewBestBlockListener newBestBlockListener;
    private ChangeListener<Boolean> pendingTradesInitializedListener;


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Constructor, Initialisation
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected TradeStepView(PendingTradesViewModel model) {
        this.model = model;
        preferences = model.dataModel.preferences;
        trade = model.dataModel.getTrade();
        checkNotNull(trade, ""Trade must not be null at TradeStepView"");

        ScrollPane scrollPane = new ScrollPane();
        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        scrollPane.setFitToHeight(true);
        scrollPane.setFitToWidth(true);

        AnchorPane.setLeftAnchor(scrollPane, 10d);
        AnchorPane.setRightAnchor(scrollPane, 10d);
        AnchorPane.setTopAnchor(scrollPane, 10d);
        AnchorPane.setBottomAnchor(scrollPane, 0d);

        getChildren().add(scrollPane);

        gridPane = new GridPane();

        gridPane.setHgap(Layout.GRID_GAP);
        gridPane.setVgap(Layout.GRID_GAP);
        ColumnConstraints columnConstraints1 = new ColumnConstraints();
        columnConstraints1.setHgrow(Priority.ALWAYS);

        ColumnConstraints columnConstraints2 = new ColumnConstraints();
        columnConstraints2.setHgrow(Priority.ALWAYS);

        gridPane.getColumnConstraints().addAll(columnConstraints1, columnConstraints2);

        scrollPane.setContent(gridPane);

        AnchorPane.setLeftAnchor(this, 0d);
        AnchorPane.setRightAnchor(this, 0d);
        AnchorPane.setTopAnchor(this, -10d);
        AnchorPane.setBottomAnchor(this, 0d);

        addContent();

        errorMessageListener = (observable, oldValue, newValue) -> {
            if (newValue != null)
                new Popup().error(newValue).show();
        };

        clockListener = new ClockWatcher.Listener() {
            @Override
            public void onSecondTick() {
            }

            @Override
            public void onMinuteTick() {
                updateTimeLeft();
            }
        };

        newBestBlockListener = block -> {
            checkIfLockTimeIsOver();
        };
    }

    public void activate() {
        if (txIdTextField != null) {
            if (txIdSubscription != null)
                txIdSubscription.unsubscribe();

            txIdSubscription = EasyBind.subscribe(model.dataModel.txId, id -> {
                if (!id.isEmpty())
                    txIdTextField.setup(id);
                else
                    txIdTextField.cleanup();
            });
        }
        trade.errorMessageProperty().addListener(errorMessageListener);

        if (!isMediationClosedState()) {
            tradeStepInfo.setOnAction(e -> {
                if (this.isTradePeriodOver()) {
                    openSupportTicket();
                } else {
                    openChat();
                }
            });
        }

        // We get mailbox messages processed after we have bootstrapped. This will influence the states we
        // handle in our disputeStateSubscription and mediationResultStateSubscriptions. To avoid that we show
        // popups from incorrect states we wait until we have bootstrapped and the mailbox messages processed.
        if (model.p2PService.isBootstrapped()) {
            registerSubscriptions();
        } else {
            bootstrapListener = new BootstrapListener() {
                @Override
                public void onUpdatedDataReceived() {
                    registerSubscriptions();
                }
            };
            model.p2PService.addP2PServiceListener(bootstrapListener);
        }

        tradePeriodStateSubscription = EasyBind.subscribe(trade.tradePeriodStateProperty(), newValue -> {
            if (newValue != null) {
                updateTradePeriodState(newValue);
            }
        });

        model.clockWatcher.addListener(clockListener);

        if (infoLabel != null) {
            infoLabel.setText(getInfoText());
        }

        BooleanProperty initialized = model.dataModel.tradeManager.getPersistedTradesInitialized();
        if (initialized.get()) {
            onPendingTradesInitialized();
        } else {
            pendingTradesInitializedListener = (observable, oldValue, newValue) -> {
                if (newValue) {
                    onPendingTradesInitialized();
                    UserThread.execute(() -> initialized.removeListener(pendingTradesInitializedListener));
                }
            };
            initialized.addListener(pendingTradesInitializedListener);
        }
    }

    protected void onPendingTradesInitialized() {
        model.dataModel.btcWalletService.addNewBestBlockListener(newBestBlockListener);
        checkIfLockTimeIsOver();
    }

    private void registerSubscriptions() {
        disputeStateSubscription = EasyBind.subscribe(trade.disputeStateProperty(), newValue -> {
            if (newValue != null) {
                updateDisputeState(newValue);
            }
        });

        mediationResultStateSubscription = EasyBind.subscribe(trade.mediationResultStateProperty(), newValue -> {
            if (newValue != null) {
                updateMediationResultState(true);
            }
        });

        UserThread.execute(() -> model.p2PService.removeP2PServiceListener(bootstrapListener));
    }

    private void openSupportTicket() {
        applyOnDisputeOpened();
        model.dataModel.onOpenDispute();
    }

    private void openChat() {
        // call up the chain to open chat
        if (this.chatCallback != null) {
            this.chatCallback.onOpenChat(this.trade);
        }
    }

    public void deactivate() {
        if (txIdSubscription != null)
            txIdSubscription.unsubscribe();

        if (txIdTextField != null)
            txIdTextField.cleanup();

        if (errorMessageListener != null)
            trade.errorMessageProperty().removeListener(errorMessageListener);

        if (disputeStateSubscription != null)
            disputeStateSubscription.unsubscribe();

        if (mediationResultStateSubscription != null)
            mediationResultStateSubscription.unsubscribe();

        if (tradePeriodStateSubscription != null)
            tradePeriodStateSubscription.unsubscribe();

        if (clockListener != null)
            model.clockWatcher.removeListener(clockListener);

        if (tradeStepInfo != null)
            tradeStepInfo.setOnAction(null);

        if (newBestBlockListener != null) {
            model.dataModel.btcWalletService.removeNewBestBlockListener(newBestBlockListener);
        }

        if (acceptMediationResultPopup != null) {
            acceptMediationResultPopup.hide();
            acceptMediationResultPopup = null;
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Content
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected void addContent() {
        addTradeInfoBlock();
        addInfoBlock();
    }

    protected void addTradeInfoBlock() {
        TitledGroupBg tradeInfoTitledGroupBg = addTitledGroupBg(gridPane, gridRow, 3,
                Res.get(""portfolio.pending.tradeInformation""));
        GridPane.setColumnSpan(tradeInfoTitledGroupBg, 2);

        final Tuple3<Label, TxIdTextField, VBox> labelTxIdTextFieldVBoxTuple3 =
                addTopLabelTxIdTextField(gridPane, gridRow,
                        Res.get(""shared.depositTransactionId""),
                        Layout.COMPACT_FIRST_ROW_DISTANCE);

        GridPane.setColumnSpan(labelTxIdTextFieldVBoxTuple3.third, 2);
        txIdTextField = labelTxIdTextFieldVBoxTuple3.second;

        String id = model.dataModel.txId.get();
        if (!id.isEmpty())
            txIdTextField.setup(id);
        else
            txIdTextField.cleanup();

        if (model.dataModel.getTrade() != null) {
            checkNotNull(model.dataModel.getTrade().getOffer(), ""Offer must not be null in TradeStepView"");
            InfoTextField infoTextField = addOpenTradeDuration(gridPane, ++gridRow,
                    model.dataModel.getTrade().getOffer());
            infoTextField.setContentForInfoPopOver(createInfoPopover());
        }

        final Tuple3<Label, TextField, VBox> labelTextFieldVBoxTuple3 = addCompactTopLabelTextField(gridPane, gridRow,
                1, Res.get(""portfolio.pending.remainingTime""), """");

        timeLeftTextField = labelTextFieldVBoxTuple3.second;
        timeLeftTextField.setMinWidth(400);

        timeLeftProgressBar = new JFXProgressBar(0);
        timeLeftProgressBar.setOpacity(0.7);
        timeLeftProgressBar.setMinHeight(9);
        timeLeftProgressBar.setMaxHeight(9);
        timeLeftProgressBar.setMaxWidth(Double.MAX_VALUE);

        GridPane.setRowIndex(timeLeftProgressBar, ++gridRow);
        GridPane.setColumnSpan(timeLeftProgressBar, 2);
        GridPane.setFillWidth(timeLeftProgressBar, true);
        gridPane.getChildren().add(timeLeftProgressBar);

        updateTimeLeft();
    }

    protected void addInfoBlock() {
        final TitledGroupBg titledGroupBg = addTitledGroupBg(gridPane, ++gridRow, 1, getInfoBlockTitle(),
                Layout.COMPACT_GROUP_DISTANCE);
        titledGroupBg.getStyleClass().add(""last"");
        GridPane.setColumnSpan(titledGroupBg, 2);

        infoLabel = addMultilineLabel(gridPane, gridRow, """", Layout.COMPACT_FIRST_ROW_AND_COMPACT_GROUP_DISTANCE);
        GridPane.setColumnSpan(infoLabel, 2);
    }

    protected String getInfoText() {
        return """";
    }

    protected String getInfoBlockTitle() {
        return """";
    }

    private void updateTimeLeft() {
        if (timeLeftTextField != null) {
            String remainingTime = model.getRemainingTradeDurationAsWords();
            timeLeftProgressBar.setProgress(model.getRemainingTradeDurationAsPercentage());
            if (!remainingTime.isEmpty()) {
                timeLeftTextField.setText(Res.get(""portfolio.pending.remainingTimeDetail"",
                        remainingTime, model.getDateForOpenDispute()));
                if (model.showWarning() || model.showDispute()) {
                    timeLeftTextField.getStyleClass().add(""error-text"");
                    timeLeftProgressBar.getStyleClass().add(""error"");
                }
            } else {
                timeLeftTextField.setText(Res.get(""portfolio.pending.tradeNotCompleted"",
                        model.getDateForOpenDispute()));
                timeLeftTextField.getStyleClass().add(""error-text"");
                timeLeftProgressBar.getStyleClass().add(""error"");
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Dispute/warning label and button
    ///////////////////////////////////////////////////////////////////////////////////////////

    // We have the dispute button and text field on the left side, but we handle the content here as it
    // is trade state specific
    public void setTradeStepInfo(TradeStepInfo tradeStepInfo) {
        this.tradeStepInfo = tradeStepInfo;

        tradeStepInfo.setFirstHalfOverWarnTextSupplier(this::getFirstHalfOverWarnText);
        tradeStepInfo.setPeriodOverWarnTextSupplier(this::getPeriodOverWarnText);
    }

    protected void hideTradeStepInfo() {
        tradeStepInfo.setState(TradeStepInfo.State.TRADE_COMPLETED);
    }

    protected String getFirstHalfOverWarnText() {
        return """";
    }


    ///////////////////////////////////////////////////////////////////////////////////////////
    // Dispute
    ///////////////////////////////////////////////////////////////////////////////////////////

    protected String getPeriodOverWarnText() {
        return """";
    }

    protected void applyOnDisputeOpened() {
    }

    protected void updateDisputeState(Trade.DisputeState disputeState) {
        Optional<Dispute> ownDispute;
        switch (disputeState) {
            case NO_DISPUTE:
                break;
            case MEDIATION_REQUESTED:
                if (tradeStepInfo != null) {
                    tradeStepInfo.setFirstHalfOverWarnTextSupplier(this::getFirstHalfOverWarnText);
                }
                applyOnDisputeOpened();

                ownDispute = model.dataModel.mediationManager.findOwnDispute(trade.getId());
                ownDispute.ifPresent(dispute -> {
                    if (tradeStepInfo != null)
                        tradeStepInfo.setState(TradeStepInfo.State.IN_MEDIATION_SELF_REQUESTED);
                });
                break;
            case MEDIATION_STARTED_BY_PEER:
                if (tradeStepInfo != null) {
                    tradeStepInfo.setFirstHalfOverWarnTextSupplier(this::getFirstHalfOverWarnText);
                }
                applyOnDisputeOpened();

                ownDispute = model.dataModel.mediationManager.findOwnDispute(trade.getId());
                ownDispute.ifPresent(dispute -> {
                    if (tradeStepInfo != null) {
                        tradeStepInfo.setState(TradeStepInfo.State.IN_MEDIATION_PEER_REQUESTED);
                    }
                });
                break;
            case MEDIATION_CLOSED:
                if (tradeStepInfo != null) {
                    tradeStepInfo.setOnAction(e -> {
                        updateMediationResultState(false);
                    });
                }

                if (tradeStepInfo != null) {
                    tradeStepInfo.setState(TradeStepInfo.State.MEDIATION_RESULT);
                }

                updateMediationResultState(true);
                break;
            case REFUND_REQUESTED:
                if (tradeStepInfo != null) {
                    tradeStepInfo.setFirstHalfOverWarnTextSupplier(this::getFirstHalfOverWarnText);
                }
                applyOnDisputeOpened();

                ownDispute = model.dataModel.refundManager.findOwnDispute(trade.getId());
                ownDispute.ifPresent(dispute -> {
                    if (tradeStepInfo != null)
                        tradeStepInfo.setState(TradeStepInfo.State.IN_REFUND_REQUEST_SELF_REQUESTED);
                });

                if (acceptMediationResultPopup != null) {
                    acceptMediationResultPopup.hide();
                    acceptMediationResultPopup = null;
                }

                break;
            case REFUND_REQUEST_STARTED_BY_PEER:
                if (tradeStepInfo != null) {
                    tradeStepInfo.setFirstHalfOverWarnTextSupplier(this::getFirstHalfOverWarnText);
                }
                applyOnDisputeOpened();

                ownDispute = model.dataModel.refundManager.findOwnDispute(trade.getId());
                ownDispute.ifPresent(dispute -> {
                    if (tradeStepInfo != null)
                        tradeStepInfo.setState(TradeStepInfo.State.IN_REFUND_REQUEST_PEER_REQUESTED);
                });

                if (acceptMediationResultPopup != null) {
                    acceptMediationResultPopup.hide();
                    acceptMediationResultPopup = null;
                }
                break;
            case REFUND_REQUEST_CLOSED:
                break;
            default:
                break;
        }
    }

    protected void updateMediationResultState(boolean blockOpeningOfResultAcceptedPopup) {
        if (isInArbitration()) {
            if (isRefundRequestStartedByPeer()) {
                tradeStepInfo.setState(TradeStepInfo.State.IN_REFUND_REQUEST_PEER_REQUESTED);
            } else if (isRefundRequestSelfStarted()) {
                tradeStepInfo.setState(TradeStepInfo.State.IN_REFUND_REQUEST_SELF_REQUESTED);
            }
        } else if (isMediationClosedState()) {
            // We do not use the state itself as it is not guaranteed the last state reflects relevant information
            // (e.g. we might receive a RECEIVED_SIG_MSG but then later a SIG_MSG_IN_MAILBOX).
            if (hasSelfAccepted()) {
                tradeStepInfo.setState(TradeStepInfo.State.MEDIATION_RESULT_SELF_ACCEPTED);
                if (!blockOpeningOfResultAcceptedPopup)
                    openMediationResultPopup(Res.get(""portfolio.pending.mediationResult.popup.headline"", trade.getShortId()));
            } else if (peerAccepted()) {
                tradeStepInfo.setState(TradeStepInfo.State.MEDIATION_RESULT_PEER_ACCEPTED);
                if (acceptMediationResultPopup == null) {
                    openMediationResultPopup(Res.get(""portfolio.pending.mediationResult.popup.headline.peerAccepted"", trade.getShortId()));
                }
            } else {
                tradeStepInfo.setState(TradeStepInfo.State.MEDIATION_RESULT);
                openMediationResultPopup(Res.get(""portfolio.pending.mediationResult.popup.headline"", trade.getShortId()));
            }
        }
    }

    private boolean isInArbitration() {
        return isRefundRequestStartedByPeer() || isRefundRequestSelfStarted();
    }

    private boolean isRefundRequestStartedByPeer() {
        return trade.getDisputeState() == Trade.DisputeState.REFUND_REQUEST_STARTED_BY_PEER;
    }

    private boolean isRefundRequestSelfStarted() {
        return trade.getDisputeState() == Trade.DisputeState.REFUND_REQUESTED;
    }

    private boolean isMediationClosedState() {
        return trade.getDisputeState() == Trade.DisputeState.MEDIATION_CLOSED;
    }

    private boolean isTradePeriodOver() {
        return Trade.TradePeriodState.TRADE_PERIOD_OVER == trade.tradePeriodStateProperty().get();
    }

    protected boolean hasSelfAccepted() {
        return trade.getProcessModel().getMediatedPayoutTxSignature() != null;
    }

    private boolean peerAccepted() {
        return trade.getProcessModel().getTradePeer().getMediatedPayoutTxSignature() != null;
    }

    private void openMediationResultPopup(String headLine) {
        if (acceptMediationResultPopup != null) {
            return;
        }

        Optional<Dispute> optionalDispute = model.dataModel.mediationManager.findDispute(trade.getId());
        if (!optionalDispute.isPresent()) {
            return;
        }

        if (trade.getPayoutTx() != null) {
            return;
        }

        if (trade.getDepositTx() == null) {
            log.error(""trade.getDepositTx() was null at openMediationResultPopup. "" +
                    ""We add the trade to failed trades. TradeId={}"", trade.getId());
            new Popup().warning(Res.get(""portfolio.pending.mediationResult.error.depositTxNull"")).show();
            return;
        } else if (trade.getDelayedPayoutTx() == null) {
            log.error(""trade.getDelayedPayoutTx() was null at openMediationResultPopup. "" +
                    ""We add the trade to failed trades. TradeId={}"", trade.getId());
            new Popup().warning(Res.get(""portfolio.pending.mediationResult.error.delayedPayoutTxNull"")).show();
            return;
        }

        DisputeResult disputeResult = optionalDispute.get().getDisputeResultProperty().get();
        Contract contract = checkNotNull(trade.getContract(), ""contract must not be null"");
        boolean isMyRoleBuyer = contract.isMyRoleBuyer(model.dataModel.getPubKeyRing());
        String buyerPayoutAmount = model.btcFormatter.formatCoinWithCode(disputeResult.getBuyerPayoutAmount());
        String sellerPayoutAmount = model.btcFormatter.formatCoinWithCode(disputeResult.getSellerPayoutAmount());
        String myPayoutAmount = isMyRoleBuyer ? buyerPayoutAmount : sellerPayoutAmount;
        String peersPayoutAmount = isMyRoleBuyer ? sellerPayoutAmount : buyerPayoutAmount;

        long lockTime = trade.getDelayedPayoutTx().getLockTime();
        int bestChainHeight = model.dataModel.btcWalletService.getBestChainHeight();
        long remaining = lockTime - bestChainHeight;

        String actionButtonText = hasSelfAccepted() ?
                Res.get(""portfolio.pending.mediationResult.popup.alreadyAccepted"") : Res.get(""shared.accept"");

        String message;
        MediationResultState mediationResultState = checkNotNull(trade).getMediationResultState();
        if (mediationResultState == null) {
            return;
        }

        switch (mediationResultState) {
            case MEDIATION_RESULT_ACCEPTED:
            case SIG_MSG_SENT:
            case SIG_MSG_ARRIVED:
            case SIG_MSG_IN_MAILBOX:
            case SIG_MSG_SEND_FAILED:
                message = Res.get(""portfolio.pending.mediationResult.popup.selfAccepted.lockTimeOver"",
                        FormattingUtils.getDateFromBlockHeight(remaining),
                        lockTime);
                break;
            default:
                message = Res.get(""portfolio.pending.mediationResult.popup.info"",
                        myPayoutAmount,
                        peersPayoutAmount,
                        FormattingUtils.getDateFromBlockHeight(remaining),
                        lockTime);
                break;
        }

        acceptMediationResultPopup = new Popup().width(900)
                .headLine(headLine)
                .instruction(message)
                .actionButtonText(actionButtonText)
                .onAction(() -> {
                    model.dataModel.mediationManager.onAcceptMediationResult(trade,
                            () -> {
                                log.info(""onAcceptMediationResult completed"");
                                acceptMediationResultPopup = null;
                            },
                            errorMessage -> {
                                UserThread.execute(() -> {
                                    new Popup().error(errorMessage).show();
                                    if (acceptMediationResultPopup != null) {
                                        acceptMediationResultPopup.hide();
                                        acceptMediationResultPopup = null;
                                    }
                                });
                            });
                })
                .secondaryActionButtonText(Res.get(""portfolio.pending.mediationResult.popup.openArbitration""))
                .onSecondaryAction(() -> {
                    model.dataModel.mediationManager.rejectMediationResult(trade);
                    model.dataModel.onOpenDispute();
                    acceptMediationResultPopup = null;
                })
                .onClose(() -> {
                    acceptMediationResultPopup = null;
                });

        if (hasSelfAccepted()) {
            acceptMediationResultPopup.disableActionButton();
        }

        acceptMediationResultPopup.show();
    }

    protected String getCurrencyName(Trade trade) {
        return CurrencyUtil.getNameByCode(getCurrencyCode(trade));
    }

    protected String getCurrencyCode(Trade trade) {
        return checkNotNull(trade.getOffer()).getCurrencyCode();
    }

    protected boolean isXmrTrade() {
        return getCurrencyCode(trade).equals(""XMR"");
    }

    private void updateTradePeriodState(Trade.TradePeriodState tradePeriodState) {
        if (trade.getDisputeState() == Trade.DisputeState.NO_DISPUTE) {
            switch (tradePeriodState) {
                case FIRST_HALF:
                    // just for dev testing. not possible to go back in time ;-)
                    if (tradeStepInfo.getState() == TradeStepInfo.State.WARN_PERIOD_OVER) {
                        tradeStepInfo.setState(TradeStepInfo.State.WARN_HALF_PERIOD);
                    } else if (tradeStepInfo.getState() == TradeStepInfo.State.WARN_HALF_PERIOD) {
                        tradeStepInfo.setState(TradeStepInfo.State.SHOW_GET_HELP_BUTTON);
                        tradeStepInfo.setFirstHalfOverWarnTextSupplier(this::getFirstHalfOverWarnText);
                    }
                    break;
                case SECOND_HALF:
                    if (!trade.isFiatReceived()) {
                        if (tradeStepInfo != null) {
                            tradeStepInfo.setFirstHalfOverWarnTextSupplier(this::getFirstHalfOverWarnText);
                            tradeStepInfo.setState(TradeStepInfo.State.WARN_HALF_PERIOD);
                        }
                    } else {
                        tradeStepInfo.setState(TradeStepInfo.State.SHOW_GET_HELP_BUTTON);
                    }
                    break;
                case TRADE_PERIOD_OVER:
                    if (tradeStepInfo != null) {
                        tradeStepInfo.setFirstHalfOverWarnTextSupplier(this::getPeriodOverWarnText);
                        tradeStepInfo.setState(TradeStepInfo.State.WARN_PERIOD_OVER);
                    }
                    break;
            }
        }
    }

    private void checkIfLockTimeIsOver() {
        if (trade.getDisputeState() == Trade.DisputeState.MEDIATION_CLOSED) {
            Transaction delayedPayoutTx = trade.getDelayedPayoutTx();
            if (delayedPayoutTx != null) {
                long lockTime = delayedPayoutTx.getLockTime();
                int bestChainHeight = model.dataModel.btcWalletService.getBestChainHeight();
                long remaining = lockTime - bestChainHeight;
                if (remaining <= 0) {
                    openMediationResultPopup(Res.get(""portfolio.pending.mediationResult.popup.headline"", trade.getShortId()));
                }
            }
        }
    }

    protected void checkForTimeout() {
        long unconfirmedHours = Duration.between(trade.getDate().toInstant(), Instant.now()).toHours();
        if (unconfirmedHours >= 3 && !trade.hasFailed()) {
            String key = ""tradeUnconfirmedTooLong_"" + trade.getShortId();
            if (DontShowAgainLookup.showAgain(key)) {
                new Popup().warning(Res.get(""portfolio.pending.unconfirmedTooLong"", trade.getShortId(), unconfirmedHours))
                        .dontShowAgainId(key)
                        .closeButtonText(Res.get(""shared.ok""))
                        .show();
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    // TradeDurationLimitInfo
    ///////////////////////////////////////////////////////////////////////////////////////////

    private GridPane createInfoPopover() {
        GridPane infoGridPane = new GridPane();
        int rowIndex = 0;
        infoGridPane.setHgap(5);
        infoGridPane.setVgap(10);
        infoGridPane.setPadding(new Insets(10, 10, 10, 10));
        Label label = addMultilineLabel(infoGridPane, rowIndex++, Res.get(""portfolio.pending.tradePeriodInfo""));
        label.setMaxWidth(450);

        HBox warningBox = new HBox();
        warningBox.setMinHeight(30);
        warningBox.setPadding(new Insets(5));
        warningBox.getStyleClass().add(""warning-box"");
        GridPane.setRowIndex(warningBox, rowIndex);
        GridPane.setColumnSpan(warningBox, 2);

        Label warningIcon = new Label();
        AwesomeDude.setIcon(warningIcon, AwesomeIcon.WARNING_SIGN);
        warningIcon.getStyleClass().add(""warning"");

        Label warning = new Label(Res.get(""portfolio.pending.tradePeriodWarning""));
        warning.setWrapText(true);
        warning.setMaxWidth(410);

        warningBox.getChildren().addAll(warningIcon, warning);
        infoGridPane.getChildren().add(warningBox);

        return infoGridPane;
    }

    public void setChatCallback(TradeSubView.ChatCallback chatCallback) {
        this.chatCallback = chatCallback;
    }
}",1,777 539 587 2000 650 2001 123 775 657 2002 2003 61 2004 46 2005 40 823 46 2006 40 41 41 59 775 657 2007 2008 59 775 657 2009 2010 59 775 657 2011 2012 59 775 657 2013 2014 59 773 2015 2016 44 2017 44 2018 59 775 704 2019 61 1500 59 773 2020 2021 59 773 2022 2023 59 773 2024 2025 59 773 2026 2027 59 773 2015 2028 59 773 2029 46 2030 2031 59 773 657 2032 60 2033 62 2034 59 775 2035 2036 59 773 2037 2038 59 773 2039 2040 59 773 2041 46 2042 2043 59 773 657 2044 2045 59 773 2032 60 2046 62 2047 59 331 330 331 775 2000 40 2007 2008 41 123 823 46 2008 61 2008 59 2012 61 2008 46 2048 46 2012 59 2010 61 2008 46 2048 46 2049 40 41 59 2050 40 2010 44 362 41 59 2051 2052 61 744 2051 40 41 59 2052 46 2053 40 2051 46 2054 46 2055 41 59 2052 46 2056 40 2051 46 2054 46 2057 41 59 2052 46 2058 40 2059 41 59 2052 46 2060 40 2059 41 59 2001 46 2061 40 2052 44 1502 41 59 2001 46 2062 40 2052 44 1502 41 59 2001 46 2063 40 2052 44 1502 41 59 2001 46 2064 40 2052 44 1500 41 59 2065 40 41 46 2066 40 2052 41 59 2014 61 744 2013 40 41 59 2014 46 2067 40 2068 46 2069 41 59 2014 46 2070 40 2068 46 2069 41 59 2071 2072 61 744 2071 40 41 59 2072 46 2073 40 2074 46 2075 41 59 2071 2076 61 744 2071 40 41 59 2076 46 2073 40 2074 46 2075 41 59 2014 46 2077 40 41 46 2078 40 2072 44 2076 41 59 2052 46 2079 40 2014 41 59 2001 46 2061 40 823 44 1500 41 59 2001 46 2062 40 823 44 1500 41 59 2001 46 2063 40 823 44 45 1502 41 59 2001 46 2064 40 823 44 1500 41 59 2080 40 41 59 2034 61 40 2081 44 2082 44 2083 41 45 62 123 688 40 2083 340 2084 41 744 2037 40 41 46 2085 40 2083 41 46 2086 40 41 59 125 59 2031 61 744 2029 46 2030 40 41 123 64 2087 777 865 2088 40 41 123 125 64 2087 777 865 2089 40 41 123 2090 40 41 59 125 125 59 2045 61 2091 45 62 123 2092 40 41 59 125 59 125 777 865 2093 40 41 123 688 40 2025 340 2094 41 123 688 40 2028 340 2094 41 2028 46 2095 40 41 59 2028 61 2096 46 2097 40 2008 46 2098 46 2099 44 2100 45 62 123 688 40 33 2100 46 2101 40 41 41 2025 46 2102 40 2100 41 59 630 2025 46 2103 40 41 59 125 41 59 125 2010 46 2104 40 41 46 2105 40 2034 41 59 688 40 33 2106 40 41 41 123 2027 46 2107 40 2108 45 62 123 688 40 823 46 2109 40 41 41 123 2110 40 41 59 125 630 123 2111 40 41 59 125 125 41 59 125 330 330 330 688 40 2008 46 2112 46 2113 40 41 41 123 2114 40 41 59 125 630 123 2040 61 744 2039 40 41 123 64 2115 777 865 2116 40 41 123 2117 40 41 59 125 125 59 2008 46 2112 46 2118 40 2040 41 59 125 2016 61 2119 46 2120 40 2010 46 2121 40 41 44 2122 45 62 123 688 40 2122 340 2094 41 123 2123 40 2122 41 59 125 125 41 59 2008 46 2124 46 2105 40 2031 41 59 688 40 2036 340 2094 41 123 2036 46 2125 40 2126 40 41 41 59 125 2127 2128 61 2008 46 2129 46 2130 46 2131 40 41 59 688 40 2128 46 2132 40 41 41 123 2133 40 41 59 125 630 123 2047 61 40 2134 44 2135 44 2122 41 45 62 123 688 40 2122 41 123 2136 40 41 59 2137 46 2138 40 40 41 45 62 2128 46 2139 40 2047 41 41 59 125 125 59 2128 46 2105 40 2047 41 59 125 125 775 865 2140 40 41 123 2008 46 2141 46 2142 46 2143 40 2045 41 59 2144 40 41 59 125 773 865 2145 40 41 123 2017 61 2146 46 2147 40 2010 46 2148 40 41 44 2149 45 62 123 688 40 2149 340 2150 41 123 2151 40 2149 41 59 125 125 41 59 2018 61 2146 46 2147 40 2010 46 2152 40 41 44 2149 45 62 123 688 40 2149 340 2153 41 123 2154 40 2155 41 59 125 125 41 59 2156 46 2157 40 40 41 45 62 2008 46 2158 46 2159 40 2040 41 41 59 125 773 865 2160 40 41 123 2161 40 41 59 2008 46 2162 46 2163 40 41 59 125 773 865 2164 40 41 123 330 688 40 823 46 2043 340 2165 41 123 823 46 2043 46 2166 40 823 46 2010 41 59 125 125 777 865 2167 40 41 123 688 40 2028 340 2168 41 2028 46 2169 40 41 59 688 40 2025 340 2168 41 2025 46 2170 40 41 59 688 40 2034 340 2168 41 2010 46 2171 40 41 46 2172 40 2034 41 59 688 40 2017 340 2168 41 2017 46 2169 40 41 59 688 40 2018 340 2168 41 2018 46 2169 40 41 59 688 40 2016 340 2168 41 2016 46 2169 40 41 59 688 40 2031 340 2168 41 2008 46 2173 46 2172 40 2031 41 59 688 40 2027 340 2168 41 2027 46 2174 40 2168 41 59 688 40 2045 340 2168 41 123 2008 46 2175 46 2176 46 2177 40 2045 41 59 125 688 40 2038 340 2168 41 123 2038 46 2178 40 41 59 2038 61 2168 59 125 125 331 330 331 775 865 2179 40 41 123 2180 40 41 59 2181 40 41 59 125 775 865 2182 40 41 123 2183 2184 61 2185 40 2014 44 2019 44 1502 44 2186 46 2187 40 362 41 41 59 2013 46 2188 40 2184 44 1502 41 59 657 2189 60 2035 44 2024 44 2190 62 2191 61 2192 40 2014 44 2019 44 2186 46 2187 40 362 41 44 2193 46 2194 41 59 2013 46 2188 40 2191 46 2195 44 1502 41 59 2025 61 2191 46 2196 59 2033 2197 61 2008 46 2198 46 2199 46 2187 40 41 59 688 40 33 2197 46 2200 40 41 41 2025 46 2201 40 2197 41 59 630 2025 46 2202 40 41 59 688 40 2008 46 2198 46 2203 40 41 340 2204 41 123 2205 40 2008 46 2198 46 2203 40 41 46 2206 40 41 44 362 41 59 2207 2208 61 2209 40 2014 44 349 2019 44 2008 46 2198 46 2203 40 41 46 2206 40 41 41 59 2208 46 2210 40 2211 40 41 41 59 125 657 2189 60 2035 44 2020 44 2190 62 2212 61 2213 40 2014 44 2019 44 1501 44 2186 46 2187 40 362 41 44 362 41 59 2021 61 2212 46 2196 59 2021 46 2214 40 1504 41 59 2023 61 744 2215 40 1500 41 59 2023 46 2216 40 1500 41 59 2023 46 2217 40 1502 41 59 2023 46 2218 40 1502 41 59 2023 46 2219 40 2220 46 2221 41 59 2013 46 2222 40 2023 44 349 2019 41 59 2013 46 2188 40 2023 44 1502 41 59 2013 46 2223 40 2023 44 2224 41 59 2014 46 2225 40 41 46 2226 40 2023 41 59 2227 40 41 59 125 775 865 2228 40 41 123 657 2229 2230 61 2231 40 2014 44 349 2019 44 1501 44 2232 40 41 44 2233 46 2234 41 59 2230 46 2235 40 41 46 2236 40 362 41 59 2013 46 2237 40 2230 44 1502 41 59 2036 61 2238 40 2014 44 2019 44 362 44 2233 46 2239 41 59 2013 46 2237 40 2036 44 1502 41 59 125 775 2033 2240 40 41 123 792 362 59 125 775 2033 2241 40 41 123 792 362 59 125 773 865 2242 40 41 123 688 40 2021 340 2243 41 123 2033 2244 61 2008 46 2245 40 41 59 2023 46 2246 40 2008 46 2247 40 41 41 59 688 40 33 2244 46 2248 40 41 41 123 2021 46 2249 40 2250 46 2251 40 362 44 2244 44 2008 46 2252 40 41 41 41 59 688 40 2008 46 2253 40 41 309 2008 46 2254 40 41 41 123 2021 46 2255 40 41 46 2256 40 362 41 59 2023 46 2255 40 41 46 2256 40 362 41 59 125 125 630 123 2021 46 2257 40 2258 46 2259 40 362 44 2008 46 2260 40 41 41 41 59 2021 46 2261 40 41 46 2262 40 362 41 59 2023 46 2261 40 41 46 2262 40 362 41 59 125 125 125 331 330 331 330 330 777 865 2263 40 2026 2027 41 123 823 46 2027 61 2027 59 2027 46 2264 40 823 58 58 2265 41 59 2027 46 2266 40 823 58 58 2267 41 59 125 775 865 2268 40 41 123 2027 46 2269 40 2026 46 2270 46 2271 41 59 125 775 2033 2272 40 41 123 792 362 59 125 331 330 331 775 2033 2273 40 41 123 792 362 59 125 775 865 2274 40 41 123 125 775 865 2275 40 2009 46 2276 2277 41 123 2278 60 2279 62 2280 59 819 40 2277 41 123 579 2281 58 572 59 579 2282 58 688 40 2027 340 2283 41 123 2027 46 2284 40 823 58 58 2272 41 59 125 2274 40 41 59 2280 61 2008 46 2285 46 2286 46 2287 40 2010 46 2288 40 41 41 59 2280 46 2289 40 2290 45 62 123 688 40 2027 340 2283 41 2027 46 2291 40 2026 46 2292 46 2293 41 59 125 41 59 572 59 579 2294 58 688 40 2027 340 2283 41 123 2027 46 2295 40 823 58 58 2272 41 59 125 2274 40 41 59 2280 61 2008 46 2285 46 2286 46 2287 40 2010 46 2288 40 41 41 59 2280 46 2289 40 2290 45 62 123 688 40 2027 340 2283 41 123 2027 46 2296 40 2026 46 2297 46 2298 41 59 125 125 41 59 572 59 579 2299 58 688 40 2027 340 2283 41 123 2027 46 2300 40 2301 45 62 123 2302 40 2303 41 59 125 41 59 125 688 40 2027 340 2283 41 123 2027 46 2304 40 2026 46 2305 46 2306 41 59 125 2307 40 2308 41 59 572 59 579 2309 58 688 40 2027 340 2283 41 123 2027 46 2310 40 823 58 58 2272 41 59 125 2274 40 41 59 2280 61 2008 46 2285 46 2311 46 2287 40 2010 46 2288 40 41 41 59 2280 46 2289 40 2290 45 62 123 688 40 2027 340 2283 41 2027 46 2312 40 2026 46 2313 46 2314 41 59 125 41 59 688 40 2038 340 2283 41 123 2038 46 2315 40 41 59 2038 61 2283 59 125 572 59 579 2316 58 688 40 2027 340 2283 41 123 2027 46 2317 40 823 58 58 2272 41 59 125 2274 40 41 59 2280 61 2008 46 2285 46 2311 46 2287 40 2010 46 2288 40 41 41 59 2280 46 2289 40 2290 45 62 123 688 40 2027 340 2283 41 2027 46 2318 40 2026 46 2319 46 2320 41 59 125 41 59 688 40 2038 340 2283 41 123 2038 46 2321 40 41 59 2038 61 2283 59 125 572 59 579 2322 58 572 59 613 58 572 59 125 125 775 865 2323 40 570 2324 41 123 688 40 2325 40 41 41 123 688 40 2326 40 41 41 123 2027 46 2327 40 2026 46 2328 46 2329 41 59 125 630 688 40 2330 40 41 41 123 2027 46 2331 40 2026 46 2332 46 2333 41 59 125 125 630 688 40 2334 40 41 41 123 330 330 688 40 2335 40 41 41 123 2027 46 2336 40 2026 46 2337 46 2338 41 59 688 40 33 2324 41 2339 40 2340 46 2341 40 362 44 2010 46 2342 40 41 41 41 59 125 630 688 40 2343 40 41 41 123 2027 46 2344 40 2026 46 2345 46 2346 41 59 688 40 2038 323 2347 41 123 2348 40 2349 46 2350 40 362 44 2010 46 2351 40 41 41 41 59 125 125 630 123 2027 46 2352 40 2026 46 2353 46 2354 41 59 2355 40 2356 46 2357 40 362 44 2010 46 2358 40 41 41 41 59 125 125 125 773 570 2359 40 41 123 792 2360 40 41 309 2361 40 41 59 125 773 570 2362 40 41 123 792 2010 46 2363 40 41 323 2009 46 2276 46 2364 59 125 773 570 2365 40 41 123 792 2010 46 2366 40 41 323 2009 46 2276 46 2367 59 125 773 570 2368 40 41 123 792 2010 46 2369 40 41 323 2009 46 2276 46 2370 59 125 773 570 2371 40 41 123 792 2009 46 2372 46 2373 323 2010 46 2374 40 41 46 2375 40 41 59 125 775 570 2376 40 41 123 792 2010 46 2377 40 41 46 2378 40 41 340 2379 59 125 773 570 2380 40 41 123 792 2010 46 2381 40 41 46 2382 40 41 46 2383 40 41 340 2384 59 125 773 865 2385 40 2033 2386 41 123 688 40 2038 340 2387 41 123 792 59 125 2388 60 2389 62 2390 61 2008 46 2391 46 2392 46 2393 40 2010 46 2394 40 41 41 59 688 40 33 2390 46 2395 40 41 41 123 792 59 125 688 40 2010 46 2396 40 41 340 2387 41 123 792 59 125 688 40 2010 46 2397 40 41 323 2387 41 123 2003 46 2398 40 362 43 362 44 2010 46 2394 40 41 41 59 744 2037 40 41 46 2399 40 2400 46 2401 40 362 41 41 46 2402 40 41 59 792 59 125 630 688 40 2010 46 2403 40 41 323 2387 41 123 2003 46 2404 40 362 43 362 44 2010 46 2394 40 41 41 59 744 2037 40 41 46 2405 40 2406 46 2407 40 362 41 41 46 2408 40 41 59 792 59 125 2409 2410 61 2390 46 2411 40 41 46 2412 40 41 46 2411 40 41 59 2413 2414 61 2415 40 2010 46 2416 40 41 44 362 41 59 570 2417 61 2414 46 2417 40 2008 46 2391 46 2418 40 41 41 59 2033 2419 61 2008 46 2420 46 2421 40 2410 46 2422 40 41 41 59 2033 2423 61 2008 46 2420 46 2421 40 2410 46 2424 40 41 41 59 2033 2425 61 2417 63 2419 58 2423 59 2033 2426 61 2417 63 2423 58 2419 59 726 2427 61 2010 46 2403 40 41 46 2428 40 41 59 704 2429 61 2008 46 2391 46 2430 46 2431 40 41 59 726 2432 61 2427 45 2429 59 2033 2433 61 2376 40 41 63 2434 46 2411 40 362 41 58 2434 46 2411 40 362 41 59 2033 2435 59 2436 2437 61 2415 40 2010 41 46 2438 40 41 59 688 40 2437 323 2387 41 123 792 59 125 819 40 2437 41 123 579 2439 58 579 2440 58 579 2441 58 579 2442 58 579 2443 58 2435 61 2434 46 2411 40 362 44 2444 46 2445 40 2432 41 44 2427 41 59 572 59 613 58 2435 61 2434 46 2411 40 362 44 2425 44 2426 44 2444 46 2445 40 2432 41 44 2427 41 59 572 59 125 2038 61 744 2037 40 41 46 2446 40 1504 41 46 2386 40 2386 41 46 2447 40 2435 41 46 2433 40 2433 41 46 2448 40 40 41 45 62 123 2008 46 2391 46 2392 46 2449 40 2010 44 40 41 45 62 123 2003 46 2450 40 362 41 59 2038 61 2387 59 125 44 2451 45 62 123 2452 46 2453 40 40 41 45 62 123 744 2037 40 41 46 2454 40 2451 41 46 2455 40 41 59 688 40 2038 340 2387 41 123 2038 46 2456 40 41 59 2038 61 2387 59 125 125 41 59 125 41 59 125 41 46 2457 40 2434 46 2411 40 362 41 41 46 2458 40 40 41 45 62 123 2008 46 2391 46 2392 46 2459 40 2010 41 59 2008 46 2391 46 2460 40 41 59 2038 61 2387 59 125 41 46 2461 40 40 41 45 62 123 2038 61 2387 59 125 41 59 688 40 2376 40 41 41 123 2038 46 2462 40 41 59 125 2038 46 2463 40 41 59 125 775 2033 2464 40 2009 2010 41 123 792 2465 46 2466 40 2467 40 2010 41 41 59 125 775 2033 2468 40 2009 2010 41 123 792 2469 40 2010 46 2470 40 41 41 46 2468 40 41 59 125 775 570 2471 40 41 123 792 2468 40 2010 41 46 2472 40 362 41 59 125 773 865 2473 40 2009 46 2474 2475 41 123 688 40 2010 46 2476 40 41 323 2009 46 2276 46 2477 41 123 819 40 2475 41 123 579 2478 58 330 688 40 2027 46 2479 40 41 323 2026 46 2480 46 2481 41 123 2027 46 2482 40 2026 46 2480 46 2483 41 59 125 630 688 40 2027 46 2479 40 41 323 2026 46 2480 46 2484 41 123 2027 46 2485 40 2026 46 2480 46 2486 41 59 2027 46 2487 40 823 58 58 2272 41 59 125 572 59 579 2488 58 688 40 33 2010 46 2489 40 41 41 123 688 40 2027 340 2490 41 123 2027 46 2491 40 823 58 58 2272 41 59 2027 46 2492 40 2026 46 2480 46 2484 41 59 125 125 630 123 2027 46 2493 40 2026 46 2480 46 2494 41 59 125 572 59 579 2495 58 688 40 2027 340 2496 41 123 2027 46 2497 40 823 58 58 2273 41 59 2027 46 2498 40 2026 46 2480 46 2481 41 59 125 572 59 125 125 125 773 865 2499 40 41 123 688 40 2010 46 2500 40 41 323 2009 46 2276 46 2501 41 123 2502 2503 61 2010 46 2504 40 41 59 688 40 2503 340 2505 41 123 726 2506 61 2503 46 2507 40 41 59 704 2508 61 2008 46 2509 46 2510 46 2511 40 41 59 726 2512 61 2506 45 2508 59 688 40 2512 329 1500 41 123 2385 40 2513 46 2514 40 362 44 2010 46 2515 40 41 41 41 59 125 125 125 125 775 865 2516 40 41 123 726 2517 61 2518 46 2519 40 2010 46 2520 40 41 46 2521 40 41 44 2522 46 2523 40 41 41 46 2524 40 41 59 688 40 2517 325 1502 307 33 2010 46 2525 40 41 41 123 2033 2526 61 362 43 2010 46 2527 40 41 59 688 40 2528 46 2529 40 2526 41 41 123 744 2037 40 41 46 2530 40 2531 46 2532 40 362 44 2010 46 2527 40 41 44 2517 41 41 46 2533 40 2526 41 46 2534 40 2531 46 2532 40 362 41 41 46 2535 40 41 59 125 125 125 331 330 331 773 2013 2536 40 41 123 2013 2537 61 744 2013 40 41 59 704 2538 61 1500 59 2537 46 2539 40 1502 41 59 2537 46 2540 40 1502 41 59 2537 46 2541 40 744 2542 40 1502 44 1502 44 1502 44 1502 41 41 59 2035 2543 61 2544 40 2537 44 2538 349 44 2545 46 2546 40 362 41 41 59 2543 46 2547 40 1504 41 59 2548 2549 61 744 2548 40 41 59 2549 46 2550 40 1503 41 59 2549 46 2541 40 744 2542 40 1502 41 41 59 2549 46 2551 40 41 46 2552 40 362 41 59 2013 46 2553 40 2549 44 2538 41 59 2013 46 2554 40 2549 44 1502 41 59 2035 2555 61 744 2035 40 41 59 2556 46 2557 40 2555 44 2558 46 2559 41 59 2555 46 2551 40 41 46 2552 40 362 41 59 2035 2560 61 744 2035 40 2545 46 2546 40 362 41 41 59 2560 46 2561 40 2562 41 59 2560 46 2547 40 1504 41 59 2549 46 2563 40 41 46 2564 40 2555 44 2560 41 59 2537 46 2563 40 41 46 2552 40 2549 41 59 792 2537 59 125 777 865 2565 40 2041 46 2042 2043 41 123 823 46 2043 61 2043 59 125 125 ,"{'AvgLine': 17, 'CountLine': 700, 'CountStmt': 394, 'MaxNesting': 4, 'AvgLineCode': 15, 'AvgEssential': 1, 'AvgLineBlank': 1, 'CountStmtExe': 328, 'MaxEssential': 7, 'SumEssential': 59, 'AvgCyclomatic': 3, 'CountLineCode': 563, 'CountStmtDecl': 98, 'MaxCyclomatic': 16, 'SumCyclomatic': 138, 'AvgLineComment': 0, 'CountClassBase': 1, 'CountLineBlank': 113, 'CountSemicolon': 283, 'CountDeclMethod': 36, 'CountLineCodeExe': 415, 'CountLineComment': 24, 'CountClassCoupled': 59, 'CountClassDerived': 7, 'CountLineCodeDecl': 101, 'CountDeclMethodAll': 36, 'MaxInheritanceTree': 2, 'RatioCommentToCode': '0.04', 'AvgCyclomaticStrict': 3, 'MaxCyclomaticStrict': 16, 'SumCyclomaticStrict': 141, 'CountDeclClassMethod': 0, 'AvgCyclomaticModified': 2, 'CountDeclMethodPublic': 4, 'MaxCyclomaticModified': 12, 'PercentLackOfCohesion': 90, 'SumCyclomaticModified': 126, 'CountDeclClassVariable': 0, 'CountDeclMethodDefault': 0, 'CountDeclMethodPrivate': 14, 'CountDeclInstanceMethod': 36, 'CountDeclMethodProtected': 18, 'CountClassCoupledModified': 59, 'CountDeclInstanceVariable': 22, 'PercentLackOfCohesionModified': 87}"
